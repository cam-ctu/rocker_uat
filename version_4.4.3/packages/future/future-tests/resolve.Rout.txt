
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[10:22:27.594] plan(): Setting new future strategy stack:
[10:22:27.595] List of future strategies:
[10:22:27.595] 1. sequential:
[10:22:27.595]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:27.595]    - tweaked: FALSE
[10:22:27.595]    - call: future::plan("sequential")
[10:22:27.609] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> strategies <- supportedStrategies()
> 
> message("*** resolve() ...")
*** resolve() ...
> 
> message("*** resolve() for default ...")
*** resolve() for default ...
> 
> x <- 1
> y <- resolve(x)
> stopifnot(identical(y, x))
> 
> message("*** resolve() for default ... DONE")
*** resolve() for default ... DONE
> 
> 
> for (strategy in strategies) {
+   message(sprintf("- plan('%s') ...", strategy))
+   plan(strategy)
+ 
+   if (strategy == "multisession" && availableCores() >= 2) {
+     message("*** resolve() for Future objects ...")
+     
+     for (result in c(FALSE, TRUE)) {
+       for (recursive in list(FALSE, TRUE, -1, 0, 1, 2, Inf)) {
+         message(sprintf("- result = %s, recursive = %s ...", result, recursive))
+       
+         f <- future({
+           Sys.sleep(0.5)
+           list(a = 1, b = 42L)
+         })
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         f <- future({
+           Sys.sleep(0.5)
+           list(a = 1, b = 42L)
+         }, lazy = TRUE)
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         message("- w/ exception ...")
+         f <- future(list(a = 1, b = 42L, c = stop("Nah!")))
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         f <- future(list(a = 1, b = 42L, c = stop("Nah!")), lazy = TRUE)
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         message(sprintf("- result = %s, recursive = %s ... DONE", result, recursive))
+       } ## for (resolve ...)
+     } ## for (result ...)
+     
+     message("*** resolve() for Future objects ... DONE")
+   } ## if (strategy == "multisession" && availableCores() >= 2)
+   
+   message("*** resolve() for lists ...")
+ 
+   x <- list()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   x$a <- 1
+   x$b <- 2
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   x$a <- future(1)
+   x$b <- future(2)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1, lazy = TRUE)
+   x$b <- future(2)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1, lazy = TRUE)
+   x$b <- future(2, lazy = TRUE)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1)
+   x$b <- future({Sys.sleep(0.5); 2})
+   x[[4]] <- 4
+   dim(x) <- c(2, 2)
+   y <- resolve(x, idxs = 1)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x[[1]]))
+   y <- resolve(x, idxs = 2)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x[[2]]))
+   y <- resolve(x, idxs = 3)
+   stopifnot(identical(y, x))
+   y <- resolve(x, idxs = seq_along(x))
+   stopifnot(identical(y, x))
+   y <- resolve(x, idxs = names(x))
+   stopifnot(identical(y, x))
+ 
+   y <- resolve(x, idxs = matrix(c(1, 2), ncol = 2L), result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   for (kk in 1:3) x[[kk]] <- future({ Sys.sleep(0.1); kk })
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   for (kk in 1:3) x[[kk]] <- future({ Sys.sleep(0.1); kk }, lazy = TRUE)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   x <- list()
+   x$a <- 1
+   x$b <- 2
+ 
+   res <- tryCatch(y <- resolve(x, idxs = 0L), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   x <- list(1, 2)
+   res <- tryCatch(x <- resolve(x, idxs = "a"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for lists ... DONE")
+ 
+ 
+   message("*** resolve() for environments ...")
+ 
+   x <- new.env()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- new.env()
+   x$a <- 1
+   x$b <- 2
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 0L)
+ 
+   x <- new.env()
+   x$a <- future(1)
+   x$b <- future(2)
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x$b))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- new.env()
+   x$a %<-% { 1 }
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)  ## FIXME: Should not do value()!
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- new.env()
+   x$a <- future({ 1 })
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "a")
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "b")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "c")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = names(x), result = TRUE)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, recursive = TRUE, result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for environments ... DONE")
+ 
+ 
+   message("*** resolve() for list environments ...")
+ 
+   x <- listenv()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- listenv()
+   x$a <- 1
+   x$b <- 2
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 0L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- listenv()
+   x$a <- future(1)
+   x$b <- future(2)
+   x$c <- 3
+   names <- names(x)
+   dim(x) <- c(1, 3)
+   names(x) <- names
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- listenv()
+   x$a %<-% { 1 }
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)  ## FIXME: Should not do value()!
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x$a, mustExist = FALSE)))
+   #stopifnot(is.na(futureOf(x$b, mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- listenv()
+   x$a <- future({ 1 })
+   x$b %<-% { Sys.sleep(0.5); 2 }
+   x$c %<-% { 3 }
+   x$d <- 4
+   names <- names(x)
+   dim(x) <- c(2, 2)
+   names(x) <- names
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+   y <- resolve(x, idxs = "a")
+   stopifnot(identical(y, x))
+   stopifnot(identical(futureOf(x$a, mustExist = FALSE), x$a))
+   stopifnot(resolved(x$a))
+   y <- resolve(x, idxs = "b")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   idxs <- matrix(c(1, 2), ncol = 2L)
+   y <- resolve(x, idxs = idxs)
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x$c, mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, idxs = 4L)
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x[[4L]], mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, idxs = names(x), result = TRUE)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, recursive = TRUE, result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   res <- tryCatch(y <- resolve(x, idxs = 0L), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for list environments ... DONE")
+ 
+   message(sprintf("- plan('%s') ...", strategy))
+ } ## for (strategy ...)
- plan('sequential') ...
[10:22:27.795] plan(): Setting new future strategy stack:
[10:22:27.795] List of future strategies:
[10:22:27.795] 1. sequential:
[10:22:27.795]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:27.795]    - tweaked: FALSE
[10:22:27.795]    - call: plan(strategy)
[10:22:27.807] plan(): nbrOfWorkers() = 1
*** resolve() for lists ...
[10:22:27.807] resolve() on list ...
[10:22:27.807]  recursive: 0
[10:22:27.808]  length: 2
[10:22:27.808]  elements: ‘a’, ‘b’
[10:22:27.808]  length: 1 (resolved future 1)
[10:22:27.808]  length: 0 (resolved future 2)
[10:22:27.808] resolve() on list ... DONE
[10:22:27.809] getGlobalsAndPackages() ...
[10:22:27.809] Searching for globals...
[10:22:27.810] 
[10:22:27.811] Searching for globals ... DONE
[10:22:27.811] - globals: [0] <none>
[10:22:27.811] getGlobalsAndPackages() ... DONE
[10:22:27.811] run() for ‘Future’ ...
[10:22:27.811] - state: ‘created’
[10:22:27.812] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:27.812] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:27.812] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:27.812]   - Field: ‘label’
[10:22:27.812]   - Field: ‘local’
[10:22:27.812]   - Field: ‘owner’
[10:22:27.812]   - Field: ‘envir’
[10:22:27.812]   - Field: ‘packages’
[10:22:27.813]   - Field: ‘gc’
[10:22:27.813]   - Field: ‘conditions’
[10:22:27.813]   - Field: ‘expr’
[10:22:27.813]   - Field: ‘uuid’
[10:22:27.813]   - Field: ‘seed’
[10:22:27.813]   - Field: ‘version’
[10:22:27.813]   - Field: ‘result’
[10:22:27.813]   - Field: ‘asynchronous’
[10:22:27.813]   - Field: ‘calls’
[10:22:27.813]   - Field: ‘globals’
[10:22:27.813]   - Field: ‘stdout’
[10:22:27.813]   - Field: ‘earlySignal’
[10:22:27.814]   - Field: ‘lazy’
[10:22:27.814]   - Field: ‘state’
[10:22:27.814] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:27.814] - Launch lazy future ...
[10:22:27.814] Packages needed by the future expression (n = 0): <none>
[10:22:27.814] Packages needed by future strategies (n = 0): <none>
[10:22:27.815] {
[10:22:27.815]     {
[10:22:27.815]         {
[10:22:27.815]             ...future.startTime <- base::Sys.time()
[10:22:27.815]             {
[10:22:27.815]                 {
[10:22:27.815]                   {
[10:22:27.815]                     base::local({
[10:22:27.815]                       has_future <- base::requireNamespace("future", 
[10:22:27.815]                         quietly = TRUE)
[10:22:27.815]                       if (has_future) {
[10:22:27.815]                         ns <- base::getNamespace("future")
[10:22:27.815]                         version <- ns[[".package"]][["version"]]
[10:22:27.815]                         if (is.null(version)) 
[10:22:27.815]                           version <- utils::packageVersion("future")
[10:22:27.815]                       }
[10:22:27.815]                       else {
[10:22:27.815]                         version <- NULL
[10:22:27.815]                       }
[10:22:27.815]                       if (!has_future || version < "1.8.0") {
[10:22:27.815]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:27.815]                           "", base::R.version$version.string), 
[10:22:27.815]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:27.815]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:27.815]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:27.815]                             "release", "version")], collapse = " "), 
[10:22:27.815]                           hostname = base::Sys.info()[["nodename"]])
[10:22:27.815]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:27.815]                           info)
[10:22:27.815]                         info <- base::paste(info, collapse = "; ")
[10:22:27.815]                         if (!has_future) {
[10:22:27.815]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:27.815]                             info)
[10:22:27.815]                         }
[10:22:27.815]                         else {
[10:22:27.815]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:27.815]                             info, version)
[10:22:27.815]                         }
[10:22:27.815]                         base::stop(msg)
[10:22:27.815]                       }
[10:22:27.815]                     })
[10:22:27.815]                   }
[10:22:27.815]                   ...future.strategy.old <- future::plan("list")
[10:22:27.815]                   options(future.plan = NULL)
[10:22:27.815]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:27.815]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:27.815]                 }
[10:22:27.815]                 ...future.workdir <- getwd()
[10:22:27.815]             }
[10:22:27.815]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:27.815]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:27.815]         }
[10:22:27.815]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:27.815]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:27.815]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:27.815]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:27.815]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:27.815]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:27.815]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:27.815]             base::names(...future.oldOptions))
[10:22:27.815]     }
[10:22:27.815]     if (FALSE) {
[10:22:27.815]     }
[10:22:27.815]     else {
[10:22:27.815]         if (TRUE) {
[10:22:27.815]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:27.815]                 open = "w")
[10:22:27.815]         }
[10:22:27.815]         else {
[10:22:27.815]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:27.815]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:27.815]         }
[10:22:27.815]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:27.815]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:27.815]             base::sink(type = "output", split = FALSE)
[10:22:27.815]             base::close(...future.stdout)
[10:22:27.815]         }, add = TRUE)
[10:22:27.815]     }
[10:22:27.815]     ...future.frame <- base::sys.nframe()
[10:22:27.815]     ...future.conditions <- base::list()
[10:22:27.815]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:27.815]     if (FALSE) {
[10:22:27.815]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:27.815]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:27.815]     }
[10:22:27.815]     ...future.result <- base::tryCatch({
[10:22:27.815]         base::withCallingHandlers({
[10:22:27.815]             ...future.value <- base::withVisible(base::local(1))
[10:22:27.815]             future::FutureResult(value = ...future.value$value, 
[10:22:27.815]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:27.815]                   ...future.rng), globalenv = if (FALSE) 
[10:22:27.815]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:27.815]                     ...future.globalenv.names))
[10:22:27.815]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:27.815]         }, condition = base::local({
[10:22:27.815]             c <- base::c
[10:22:27.815]             inherits <- base::inherits
[10:22:27.815]             invokeRestart <- base::invokeRestart
[10:22:27.815]             length <- base::length
[10:22:27.815]             list <- base::list
[10:22:27.815]             seq.int <- base::seq.int
[10:22:27.815]             signalCondition <- base::signalCondition
[10:22:27.815]             sys.calls <- base::sys.calls
[10:22:27.815]             `[[` <- base::`[[`
[10:22:27.815]             `+` <- base::`+`
[10:22:27.815]             `<<-` <- base::`<<-`
[10:22:27.815]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:27.815]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:27.815]                   3L)]
[10:22:27.815]             }
[10:22:27.815]             function(cond) {
[10:22:27.815]                 is_error <- inherits(cond, "error")
[10:22:27.815]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:27.815]                   NULL)
[10:22:27.815]                 if (is_error) {
[10:22:27.815]                   sessionInformation <- function() {
[10:22:27.815]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:27.815]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:27.815]                       search = base::search(), system = base::Sys.info())
[10:22:27.815]                   }
[10:22:27.815]                   ...future.conditions[[length(...future.conditions) + 
[10:22:27.815]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:27.815]                     cond$call), session = sessionInformation(), 
[10:22:27.815]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:27.815]                   signalCondition(cond)
[10:22:27.815]                 }
[10:22:27.815]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:27.815]                 "immediateCondition"))) {
[10:22:27.815]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:27.815]                   ...future.conditions[[length(...future.conditions) + 
[10:22:27.815]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:27.815]                   if (TRUE && !signal) {
[10:22:27.815]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:27.815]                     {
[10:22:27.815]                       inherits <- base::inherits
[10:22:27.815]                       invokeRestart <- base::invokeRestart
[10:22:27.815]                       is.null <- base::is.null
[10:22:27.815]                       muffled <- FALSE
[10:22:27.815]                       if (inherits(cond, "message")) {
[10:22:27.815]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:27.815]                         if (muffled) 
[10:22:27.815]                           invokeRestart("muffleMessage")
[10:22:27.815]                       }
[10:22:27.815]                       else if (inherits(cond, "warning")) {
[10:22:27.815]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:27.815]                         if (muffled) 
[10:22:27.815]                           invokeRestart("muffleWarning")
[10:22:27.815]                       }
[10:22:27.815]                       else if (inherits(cond, "condition")) {
[10:22:27.815]                         if (!is.null(pattern)) {
[10:22:27.815]                           computeRestarts <- base::computeRestarts
[10:22:27.815]                           grepl <- base::grepl
[10:22:27.815]                           restarts <- computeRestarts(cond)
[10:22:27.815]                           for (restart in restarts) {
[10:22:27.815]                             name <- restart$name
[10:22:27.815]                             if (is.null(name)) 
[10:22:27.815]                               next
[10:22:27.815]                             if (!grepl(pattern, name)) 
[10:22:27.815]                               next
[10:22:27.815]                             invokeRestart(restart)
[10:22:27.815]                             muffled <- TRUE
[10:22:27.815]                             break
[10:22:27.815]                           }
[10:22:27.815]                         }
[10:22:27.815]                       }
[10:22:27.815]                       invisible(muffled)
[10:22:27.815]                     }
[10:22:27.815]                     muffleCondition(cond, pattern = "^muffle")
[10:22:27.815]                   }
[10:22:27.815]                 }
[10:22:27.815]                 else {
[10:22:27.815]                   if (TRUE) {
[10:22:27.815]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:27.815]                     {
[10:22:27.815]                       inherits <- base::inherits
[10:22:27.815]                       invokeRestart <- base::invokeRestart
[10:22:27.815]                       is.null <- base::is.null
[10:22:27.815]                       muffled <- FALSE
[10:22:27.815]                       if (inherits(cond, "message")) {
[10:22:27.815]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:27.815]                         if (muffled) 
[10:22:27.815]                           invokeRestart("muffleMessage")
[10:22:27.815]                       }
[10:22:27.815]                       else if (inherits(cond, "warning")) {
[10:22:27.815]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:27.815]                         if (muffled) 
[10:22:27.815]                           invokeRestart("muffleWarning")
[10:22:27.815]                       }
[10:22:27.815]                       else if (inherits(cond, "condition")) {
[10:22:27.815]                         if (!is.null(pattern)) {
[10:22:27.815]                           computeRestarts <- base::computeRestarts
[10:22:27.815]                           grepl <- base::grepl
[10:22:27.815]                           restarts <- computeRestarts(cond)
[10:22:27.815]                           for (restart in restarts) {
[10:22:27.815]                             name <- restart$name
[10:22:27.815]                             if (is.null(name)) 
[10:22:27.815]                               next
[10:22:27.815]                             if (!grepl(pattern, name)) 
[10:22:27.815]                               next
[10:22:27.815]                             invokeRestart(restart)
[10:22:27.815]                             muffled <- TRUE
[10:22:27.815]                             break
[10:22:27.815]                           }
[10:22:27.815]                         }
[10:22:27.815]                       }
[10:22:27.815]                       invisible(muffled)
[10:22:27.815]                     }
[10:22:27.815]                     muffleCondition(cond, pattern = "^muffle")
[10:22:27.815]                   }
[10:22:27.815]                 }
[10:22:27.815]             }
[10:22:27.815]         }))
[10:22:27.815]     }, error = function(ex) {
[10:22:27.815]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:27.815]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:27.815]                 ...future.rng), started = ...future.startTime, 
[10:22:27.815]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:27.815]             version = "1.8"), class = "FutureResult")
[10:22:27.815]     }, finally = {
[10:22:27.815]         if (!identical(...future.workdir, getwd())) 
[10:22:27.815]             setwd(...future.workdir)
[10:22:27.815]         {
[10:22:27.815]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:27.815]                 ...future.oldOptions$nwarnings <- NULL
[10:22:27.815]             }
[10:22:27.815]             base::options(...future.oldOptions)
[10:22:27.815]             if (.Platform$OS.type == "windows") {
[10:22:27.815]                 old_names <- names(...future.oldEnvVars)
[10:22:27.815]                 envs <- base::Sys.getenv()
[10:22:27.815]                 names <- names(envs)
[10:22:27.815]                 common <- intersect(names, old_names)
[10:22:27.815]                 added <- setdiff(names, old_names)
[10:22:27.815]                 removed <- setdiff(old_names, names)
[10:22:27.815]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:27.815]                   envs[common]]
[10:22:27.815]                 NAMES <- toupper(changed)
[10:22:27.815]                 args <- list()
[10:22:27.815]                 for (kk in seq_along(NAMES)) {
[10:22:27.815]                   name <- changed[[kk]]
[10:22:27.815]                   NAME <- NAMES[[kk]]
[10:22:27.815]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:27.815]                     next
[10:22:27.815]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:27.815]                 }
[10:22:27.815]                 NAMES <- toupper(added)
[10:22:27.815]                 for (kk in seq_along(NAMES)) {
[10:22:27.815]                   name <- added[[kk]]
[10:22:27.815]                   NAME <- NAMES[[kk]]
[10:22:27.815]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:27.815]                     next
[10:22:27.815]                   args[[name]] <- ""
[10:22:27.815]                 }
[10:22:27.815]                 NAMES <- toupper(removed)
[10:22:27.815]                 for (kk in seq_along(NAMES)) {
[10:22:27.815]                   name <- removed[[kk]]
[10:22:27.815]                   NAME <- NAMES[[kk]]
[10:22:27.815]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:27.815]                     next
[10:22:27.815]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:27.815]                 }
[10:22:27.815]                 if (length(args) > 0) 
[10:22:27.815]                   base::do.call(base::Sys.setenv, args = args)
[10:22:27.815]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:27.815]             }
[10:22:27.815]             else {
[10:22:27.815]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:27.815]             }
[10:22:27.815]             {
[10:22:27.815]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:27.815]                   0L) {
[10:22:27.815]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:27.815]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:27.815]                   base::options(opts)
[10:22:27.815]                 }
[10:22:27.815]                 {
[10:22:27.815]                   {
[10:22:27.815]                     NULL
[10:22:27.815]                     RNGkind("Mersenne-Twister")
[10:22:27.815]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:27.815]                       inherits = FALSE)
[10:22:27.815]                   }
[10:22:27.815]                   options(future.plan = NULL)
[10:22:27.815]                   if (is.na(NA_character_)) 
[10:22:27.815]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:27.815]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:27.815]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:27.815]                     .init = FALSE)
[10:22:27.815]                 }
[10:22:27.815]             }
[10:22:27.815]         }
[10:22:27.815]     })
[10:22:27.815]     if (TRUE) {
[10:22:27.815]         base::sink(type = "output", split = FALSE)
[10:22:27.815]         if (TRUE) {
[10:22:27.815]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:27.815]         }
[10:22:27.815]         else {
[10:22:27.815]             ...future.result["stdout"] <- base::list(NULL)
[10:22:27.815]         }
[10:22:27.815]         base::close(...future.stdout)
[10:22:27.815]         ...future.stdout <- NULL
[10:22:27.815]     }
[10:22:27.815]     ...future.result$conditions <- ...future.conditions
[10:22:27.815]     ...future.result$finished <- base::Sys.time()
[10:22:27.815]     ...future.result
[10:22:27.815] }
[10:22:27.817] plan(): Setting new future strategy stack:
[10:22:27.817] List of future strategies:
[10:22:27.817] 1. sequential:
[10:22:27.817]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:27.817]    - tweaked: FALSE
[10:22:27.817]    - call: NULL
[10:22:27.818] plan(): nbrOfWorkers() = 1
[10:22:27.819] plan(): Setting new future strategy stack:
[10:22:27.819] List of future strategies:
[10:22:27.819] 1. sequential:
[10:22:27.819]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:27.819]    - tweaked: FALSE
[10:22:27.819]    - call: plan(strategy)
[10:22:27.819] plan(): nbrOfWorkers() = 1
[10:22:27.819] SequentialFuture started (and completed)
[10:22:27.820] - Launch lazy future ... done
[10:22:27.820] run() for ‘SequentialFuture’ ... done
[10:22:27.820] getGlobalsAndPackages() ...
[10:22:27.820] Searching for globals...
[10:22:27.820] 
[10:22:27.820] Searching for globals ... DONE
[10:22:27.820] - globals: [0] <none>
[10:22:27.821] getGlobalsAndPackages() ... DONE
[10:22:27.821] run() for ‘Future’ ...
[10:22:27.821] - state: ‘created’
[10:22:27.821] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:27.821] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:27.821] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:27.821]   - Field: ‘label’
[10:22:27.821]   - Field: ‘local’
[10:22:27.822]   - Field: ‘owner’
[10:22:27.822]   - Field: ‘envir’
[10:22:27.822]   - Field: ‘packages’
[10:22:27.822]   - Field: ‘gc’
[10:22:27.822]   - Field: ‘conditions’
[10:22:27.822]   - Field: ‘expr’
[10:22:27.822]   - Field: ‘uuid’
[10:22:27.822]   - Field: ‘seed’
[10:22:27.822]   - Field: ‘version’
[10:22:27.822]   - Field: ‘result’
[10:22:27.822]   - Field: ‘asynchronous’
[10:22:27.822]   - Field: ‘calls’
[10:22:27.823]   - Field: ‘globals’
[10:22:27.823]   - Field: ‘stdout’
[10:22:27.823]   - Field: ‘earlySignal’
[10:22:27.823]   - Field: ‘lazy’
[10:22:27.823]   - Field: ‘state’
[10:22:27.823] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:27.823] - Launch lazy future ...
[10:22:27.823] Packages needed by the future expression (n = 0): <none>
[10:22:27.823] Packages needed by future strategies (n = 0): <none>
[10:22:27.824] {
[10:22:27.824]     {
[10:22:27.824]         {
[10:22:27.824]             ...future.startTime <- base::Sys.time()
[10:22:27.824]             {
[10:22:27.824]                 {
[10:22:27.824]                   {
[10:22:27.824]                     base::local({
[10:22:27.824]                       has_future <- base::requireNamespace("future", 
[10:22:27.824]                         quietly = TRUE)
[10:22:27.824]                       if (has_future) {
[10:22:27.824]                         ns <- base::getNamespace("future")
[10:22:27.824]                         version <- ns[[".package"]][["version"]]
[10:22:27.824]                         if (is.null(version)) 
[10:22:27.824]                           version <- utils::packageVersion("future")
[10:22:27.824]                       }
[10:22:27.824]                       else {
[10:22:27.824]                         version <- NULL
[10:22:27.824]                       }
[10:22:27.824]                       if (!has_future || version < "1.8.0") {
[10:22:27.824]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:27.824]                           "", base::R.version$version.string), 
[10:22:27.824]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:27.824]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:27.824]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:27.824]                             "release", "version")], collapse = " "), 
[10:22:27.824]                           hostname = base::Sys.info()[["nodename"]])
[10:22:27.824]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:27.824]                           info)
[10:22:27.824]                         info <- base::paste(info, collapse = "; ")
[10:22:27.824]                         if (!has_future) {
[10:22:27.824]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:27.824]                             info)
[10:22:27.824]                         }
[10:22:27.824]                         else {
[10:22:27.824]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:27.824]                             info, version)
[10:22:27.824]                         }
[10:22:27.824]                         base::stop(msg)
[10:22:27.824]                       }
[10:22:27.824]                     })
[10:22:27.824]                   }
[10:22:27.824]                   ...future.strategy.old <- future::plan("list")
[10:22:27.824]                   options(future.plan = NULL)
[10:22:27.824]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:27.824]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:27.824]                 }
[10:22:27.824]                 ...future.workdir <- getwd()
[10:22:27.824]             }
[10:22:27.824]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:27.824]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:27.824]         }
[10:22:27.824]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:27.824]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:27.824]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:27.824]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:27.824]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:27.824]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:27.824]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:27.824]             base::names(...future.oldOptions))
[10:22:27.824]     }
[10:22:27.824]     if (FALSE) {
[10:22:27.824]     }
[10:22:27.824]     else {
[10:22:27.824]         if (TRUE) {
[10:22:27.824]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:27.824]                 open = "w")
[10:22:27.824]         }
[10:22:27.824]         else {
[10:22:27.824]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:27.824]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:27.824]         }
[10:22:27.824]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:27.824]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:27.824]             base::sink(type = "output", split = FALSE)
[10:22:27.824]             base::close(...future.stdout)
[10:22:27.824]         }, add = TRUE)
[10:22:27.824]     }
[10:22:27.824]     ...future.frame <- base::sys.nframe()
[10:22:27.824]     ...future.conditions <- base::list()
[10:22:27.824]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:27.824]     if (FALSE) {
[10:22:27.824]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:27.824]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:27.824]     }
[10:22:27.824]     ...future.result <- base::tryCatch({
[10:22:27.824]         base::withCallingHandlers({
[10:22:27.824]             ...future.value <- base::withVisible(base::local(2))
[10:22:27.824]             future::FutureResult(value = ...future.value$value, 
[10:22:27.824]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:27.824]                   ...future.rng), globalenv = if (FALSE) 
[10:22:27.824]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:27.824]                     ...future.globalenv.names))
[10:22:27.824]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:27.824]         }, condition = base::local({
[10:22:27.824]             c <- base::c
[10:22:27.824]             inherits <- base::inherits
[10:22:27.824]             invokeRestart <- base::invokeRestart
[10:22:27.824]             length <- base::length
[10:22:27.824]             list <- base::list
[10:22:27.824]             seq.int <- base::seq.int
[10:22:27.824]             signalCondition <- base::signalCondition
[10:22:27.824]             sys.calls <- base::sys.calls
[10:22:27.824]             `[[` <- base::`[[`
[10:22:27.824]             `+` <- base::`+`
[10:22:27.824]             `<<-` <- base::`<<-`
[10:22:27.824]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:27.824]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:27.824]                   3L)]
[10:22:27.824]             }
[10:22:27.824]             function(cond) {
[10:22:27.824]                 is_error <- inherits(cond, "error")
[10:22:27.824]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:27.824]                   NULL)
[10:22:27.824]                 if (is_error) {
[10:22:27.824]                   sessionInformation <- function() {
[10:22:27.824]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:27.824]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:27.824]                       search = base::search(), system = base::Sys.info())
[10:22:27.824]                   }
[10:22:27.824]                   ...future.conditions[[length(...future.conditions) + 
[10:22:27.824]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:27.824]                     cond$call), session = sessionInformation(), 
[10:22:27.824]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:27.824]                   signalCondition(cond)
[10:22:27.824]                 }
[10:22:27.824]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:27.824]                 "immediateCondition"))) {
[10:22:27.824]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:27.824]                   ...future.conditions[[length(...future.conditions) + 
[10:22:27.824]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:27.824]                   if (TRUE && !signal) {
[10:22:27.824]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:27.824]                     {
[10:22:27.824]                       inherits <- base::inherits
[10:22:27.824]                       invokeRestart <- base::invokeRestart
[10:22:27.824]                       is.null <- base::is.null
[10:22:27.824]                       muffled <- FALSE
[10:22:27.824]                       if (inherits(cond, "message")) {
[10:22:27.824]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:27.824]                         if (muffled) 
[10:22:27.824]                           invokeRestart("muffleMessage")
[10:22:27.824]                       }
[10:22:27.824]                       else if (inherits(cond, "warning")) {
[10:22:27.824]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:27.824]                         if (muffled) 
[10:22:27.824]                           invokeRestart("muffleWarning")
[10:22:27.824]                       }
[10:22:27.824]                       else if (inherits(cond, "condition")) {
[10:22:27.824]                         if (!is.null(pattern)) {
[10:22:27.824]                           computeRestarts <- base::computeRestarts
[10:22:27.824]                           grepl <- base::grepl
[10:22:27.824]                           restarts <- computeRestarts(cond)
[10:22:27.824]                           for (restart in restarts) {
[10:22:27.824]                             name <- restart$name
[10:22:27.824]                             if (is.null(name)) 
[10:22:27.824]                               next
[10:22:27.824]                             if (!grepl(pattern, name)) 
[10:22:27.824]                               next
[10:22:27.824]                             invokeRestart(restart)
[10:22:27.824]                             muffled <- TRUE
[10:22:27.824]                             break
[10:22:27.824]                           }
[10:22:27.824]                         }
[10:22:27.824]                       }
[10:22:27.824]                       invisible(muffled)
[10:22:27.824]                     }
[10:22:27.824]                     muffleCondition(cond, pattern = "^muffle")
[10:22:27.824]                   }
[10:22:27.824]                 }
[10:22:27.824]                 else {
[10:22:27.824]                   if (TRUE) {
[10:22:27.824]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:27.824]                     {
[10:22:27.824]                       inherits <- base::inherits
[10:22:27.824]                       invokeRestart <- base::invokeRestart
[10:22:27.824]                       is.null <- base::is.null
[10:22:27.824]                       muffled <- FALSE
[10:22:27.824]                       if (inherits(cond, "message")) {
[10:22:27.824]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:27.824]                         if (muffled) 
[10:22:27.824]                           invokeRestart("muffleMessage")
[10:22:27.824]                       }
[10:22:27.824]                       else if (inherits(cond, "warning")) {
[10:22:27.824]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:27.824]                         if (muffled) 
[10:22:27.824]                           invokeRestart("muffleWarning")
[10:22:27.824]                       }
[10:22:27.824]                       else if (inherits(cond, "condition")) {
[10:22:27.824]                         if (!is.null(pattern)) {
[10:22:27.824]                           computeRestarts <- base::computeRestarts
[10:22:27.824]                           grepl <- base::grepl
[10:22:27.824]                           restarts <- computeRestarts(cond)
[10:22:27.824]                           for (restart in restarts) {
[10:22:27.824]                             name <- restart$name
[10:22:27.824]                             if (is.null(name)) 
[10:22:27.824]                               next
[10:22:27.824]                             if (!grepl(pattern, name)) 
[10:22:27.824]                               next
[10:22:27.824]                             invokeRestart(restart)
[10:22:27.824]                             muffled <- TRUE
[10:22:27.824]                             break
[10:22:27.824]                           }
[10:22:27.824]                         }
[10:22:27.824]                       }
[10:22:27.824]                       invisible(muffled)
[10:22:27.824]                     }
[10:22:27.824]                     muffleCondition(cond, pattern = "^muffle")
[10:22:27.824]                   }
[10:22:27.824]                 }
[10:22:27.824]             }
[10:22:27.824]         }))
[10:22:27.824]     }, error = function(ex) {
[10:22:27.824]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:27.824]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:27.824]                 ...future.rng), started = ...future.startTime, 
[10:22:27.824]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:27.824]             version = "1.8"), class = "FutureResult")
[10:22:27.824]     }, finally = {
[10:22:27.824]         if (!identical(...future.workdir, getwd())) 
[10:22:27.824]             setwd(...future.workdir)
[10:22:27.824]         {
[10:22:27.824]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:27.824]                 ...future.oldOptions$nwarnings <- NULL
[10:22:27.824]             }
[10:22:27.824]             base::options(...future.oldOptions)
[10:22:27.824]             if (.Platform$OS.type == "windows") {
[10:22:27.824]                 old_names <- names(...future.oldEnvVars)
[10:22:27.824]                 envs <- base::Sys.getenv()
[10:22:27.824]                 names <- names(envs)
[10:22:27.824]                 common <- intersect(names, old_names)
[10:22:27.824]                 added <- setdiff(names, old_names)
[10:22:27.824]                 removed <- setdiff(old_names, names)
[10:22:27.824]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:27.824]                   envs[common]]
[10:22:27.824]                 NAMES <- toupper(changed)
[10:22:27.824]                 args <- list()
[10:22:27.824]                 for (kk in seq_along(NAMES)) {
[10:22:27.824]                   name <- changed[[kk]]
[10:22:27.824]                   NAME <- NAMES[[kk]]
[10:22:27.824]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:27.824]                     next
[10:22:27.824]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:27.824]                 }
[10:22:27.824]                 NAMES <- toupper(added)
[10:22:27.824]                 for (kk in seq_along(NAMES)) {
[10:22:27.824]                   name <- added[[kk]]
[10:22:27.824]                   NAME <- NAMES[[kk]]
[10:22:27.824]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:27.824]                     next
[10:22:27.824]                   args[[name]] <- ""
[10:22:27.824]                 }
[10:22:27.824]                 NAMES <- toupper(removed)
[10:22:27.824]                 for (kk in seq_along(NAMES)) {
[10:22:27.824]                   name <- removed[[kk]]
[10:22:27.824]                   NAME <- NAMES[[kk]]
[10:22:27.824]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:27.824]                     next
[10:22:27.824]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:27.824]                 }
[10:22:27.824]                 if (length(args) > 0) 
[10:22:27.824]                   base::do.call(base::Sys.setenv, args = args)
[10:22:27.824]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:27.824]             }
[10:22:27.824]             else {
[10:22:27.824]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:27.824]             }
[10:22:27.824]             {
[10:22:27.824]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:27.824]                   0L) {
[10:22:27.824]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:27.824]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:27.824]                   base::options(opts)
[10:22:27.824]                 }
[10:22:27.824]                 {
[10:22:27.824]                   {
[10:22:27.824]                     NULL
[10:22:27.824]                     RNGkind("Mersenne-Twister")
[10:22:27.824]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:27.824]                       inherits = FALSE)
[10:22:27.824]                   }
[10:22:27.824]                   options(future.plan = NULL)
[10:22:27.824]                   if (is.na(NA_character_)) 
[10:22:27.824]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:27.824]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:27.824]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:27.824]                     .init = FALSE)
[10:22:27.824]                 }
[10:22:27.824]             }
[10:22:27.824]         }
[10:22:27.824]     })
[10:22:27.824]     if (TRUE) {
[10:22:27.824]         base::sink(type = "output", split = FALSE)
[10:22:27.824]         if (TRUE) {
[10:22:27.824]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:27.824]         }
[10:22:27.824]         else {
[10:22:27.824]             ...future.result["stdout"] <- base::list(NULL)
[10:22:27.824]         }
[10:22:27.824]         base::close(...future.stdout)
[10:22:27.824]         ...future.stdout <- NULL
[10:22:27.824]     }
[10:22:27.824]     ...future.result$conditions <- ...future.conditions
[10:22:27.824]     ...future.result$finished <- base::Sys.time()
[10:22:27.824]     ...future.result
[10:22:27.824] }
[10:22:27.825] plan(): Setting new future strategy stack:
[10:22:27.826] List of future strategies:
[10:22:27.826] 1. sequential:
[10:22:27.826]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:27.826]    - tweaked: FALSE
[10:22:27.826]    - call: NULL
[10:22:27.826] plan(): nbrOfWorkers() = 1
[10:22:27.827] plan(): Setting new future strategy stack:
[10:22:27.827] List of future strategies:
[10:22:27.827] 1. sequential:
[10:22:27.827]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:27.827]    - tweaked: FALSE
[10:22:27.827]    - call: plan(strategy)
[10:22:27.827] plan(): nbrOfWorkers() = 1
[10:22:27.827] SequentialFuture started (and completed)
[10:22:27.827] - Launch lazy future ... done
[10:22:27.827] run() for ‘SequentialFuture’ ... done
[10:22:27.828] resolve() on list ...
[10:22:27.828]  recursive: 0
[10:22:27.828]  length: 3
[10:22:27.828]  elements: ‘a’, ‘b’, ‘’
[10:22:27.828] resolved() for ‘SequentialFuture’ ...
[10:22:27.828] - state: ‘finished’
[10:22:27.828] - run: TRUE
[10:22:27.828] - result: ‘FutureResult’
[10:22:27.828] resolved() for ‘SequentialFuture’ ... done
[10:22:27.828] Future #1
[10:22:27.829]  length: 2 (resolved future 1)
[10:22:27.829] resolved() for ‘SequentialFuture’ ...
[10:22:27.829] - state: ‘finished’
[10:22:27.829] - run: TRUE
[10:22:27.829] - result: ‘FutureResult’
[10:22:27.829] resolved() for ‘SequentialFuture’ ... done
[10:22:27.829] Future #2
[10:22:27.829]  length: 1 (resolved future 2)
[10:22:27.829]  length: 0 (resolved future 3)
[10:22:27.829] resolve() on list ... DONE
[10:22:27.830] resolved() for ‘SequentialFuture’ ...
[10:22:27.830] - state: ‘finished’
[10:22:27.830] - run: TRUE
[10:22:27.830] - result: ‘FutureResult’
[10:22:27.830] resolved() for ‘SequentialFuture’ ... done
[10:22:27.830] resolved() for ‘SequentialFuture’ ...
[10:22:27.830] - state: ‘finished’
[10:22:27.830] - run: TRUE
[10:22:27.830] - result: ‘FutureResult’
[10:22:27.830] resolved() for ‘SequentialFuture’ ... done
[10:22:27.830] getGlobalsAndPackages() ...
[10:22:27.830] Searching for globals...
[10:22:27.831] 
[10:22:27.831] Searching for globals ... DONE
[10:22:27.831] - globals: [0] <none>
[10:22:27.831] getGlobalsAndPackages() ... DONE
[10:22:27.831] getGlobalsAndPackages() ...
[10:22:27.831] Searching for globals...
[10:22:27.832] 
[10:22:27.832] Searching for globals ... DONE
[10:22:27.832] - globals: [0] <none>
[10:22:27.833] getGlobalsAndPackages() ... DONE
[10:22:27.833] run() for ‘Future’ ...
[10:22:27.833] - state: ‘created’
[10:22:27.834] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:27.834] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:27.834] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:27.834]   - Field: ‘label’
[10:22:27.834]   - Field: ‘local’
[10:22:27.834]   - Field: ‘owner’
[10:22:27.834]   - Field: ‘envir’
[10:22:27.834]   - Field: ‘packages’
[10:22:27.834]   - Field: ‘gc’
[10:22:27.835]   - Field: ‘conditions’
[10:22:27.835]   - Field: ‘expr’
[10:22:27.835]   - Field: ‘uuid’
[10:22:27.835]   - Field: ‘seed’
[10:22:27.835]   - Field: ‘version’
[10:22:27.835]   - Field: ‘result’
[10:22:27.835]   - Field: ‘asynchronous’
[10:22:27.835]   - Field: ‘calls’
[10:22:27.835]   - Field: ‘globals’
[10:22:27.835]   - Field: ‘stdout’
[10:22:27.835]   - Field: ‘earlySignal’
[10:22:27.835]   - Field: ‘lazy’
[10:22:27.836]   - Field: ‘state’
[10:22:27.836] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:27.836] - Launch lazy future ...
[10:22:27.836] Packages needed by the future expression (n = 0): <none>
[10:22:27.836] Packages needed by future strategies (n = 0): <none>
[10:22:27.836] {
[10:22:27.836]     {
[10:22:27.836]         {
[10:22:27.836]             ...future.startTime <- base::Sys.time()
[10:22:27.836]             {
[10:22:27.836]                 {
[10:22:27.836]                   {
[10:22:27.836]                     base::local({
[10:22:27.836]                       has_future <- base::requireNamespace("future", 
[10:22:27.836]                         quietly = TRUE)
[10:22:27.836]                       if (has_future) {
[10:22:27.836]                         ns <- base::getNamespace("future")
[10:22:27.836]                         version <- ns[[".package"]][["version"]]
[10:22:27.836]                         if (is.null(version)) 
[10:22:27.836]                           version <- utils::packageVersion("future")
[10:22:27.836]                       }
[10:22:27.836]                       else {
[10:22:27.836]                         version <- NULL
[10:22:27.836]                       }
[10:22:27.836]                       if (!has_future || version < "1.8.0") {
[10:22:27.836]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:27.836]                           "", base::R.version$version.string), 
[10:22:27.836]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:27.836]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:27.836]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:27.836]                             "release", "version")], collapse = " "), 
[10:22:27.836]                           hostname = base::Sys.info()[["nodename"]])
[10:22:27.836]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:27.836]                           info)
[10:22:27.836]                         info <- base::paste(info, collapse = "; ")
[10:22:27.836]                         if (!has_future) {
[10:22:27.836]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:27.836]                             info)
[10:22:27.836]                         }
[10:22:27.836]                         else {
[10:22:27.836]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:27.836]                             info, version)
[10:22:27.836]                         }
[10:22:27.836]                         base::stop(msg)
[10:22:27.836]                       }
[10:22:27.836]                     })
[10:22:27.836]                   }
[10:22:27.836]                   ...future.strategy.old <- future::plan("list")
[10:22:27.836]                   options(future.plan = NULL)
[10:22:27.836]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:27.836]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:27.836]                 }
[10:22:27.836]                 ...future.workdir <- getwd()
[10:22:27.836]             }
[10:22:27.836]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:27.836]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:27.836]         }
[10:22:27.836]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:27.836]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:27.836]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:27.836]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:27.836]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:27.836]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:27.836]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:27.836]             base::names(...future.oldOptions))
[10:22:27.836]     }
[10:22:27.836]     if (FALSE) {
[10:22:27.836]     }
[10:22:27.836]     else {
[10:22:27.836]         if (TRUE) {
[10:22:27.836]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:27.836]                 open = "w")
[10:22:27.836]         }
[10:22:27.836]         else {
[10:22:27.836]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:27.836]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:27.836]         }
[10:22:27.836]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:27.836]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:27.836]             base::sink(type = "output", split = FALSE)
[10:22:27.836]             base::close(...future.stdout)
[10:22:27.836]         }, add = TRUE)
[10:22:27.836]     }
[10:22:27.836]     ...future.frame <- base::sys.nframe()
[10:22:27.836]     ...future.conditions <- base::list()
[10:22:27.836]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:27.836]     if (FALSE) {
[10:22:27.836]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:27.836]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:27.836]     }
[10:22:27.836]     ...future.result <- base::tryCatch({
[10:22:27.836]         base::withCallingHandlers({
[10:22:27.836]             ...future.value <- base::withVisible(base::local(2))
[10:22:27.836]             future::FutureResult(value = ...future.value$value, 
[10:22:27.836]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:27.836]                   ...future.rng), globalenv = if (FALSE) 
[10:22:27.836]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:27.836]                     ...future.globalenv.names))
[10:22:27.836]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:27.836]         }, condition = base::local({
[10:22:27.836]             c <- base::c
[10:22:27.836]             inherits <- base::inherits
[10:22:27.836]             invokeRestart <- base::invokeRestart
[10:22:27.836]             length <- base::length
[10:22:27.836]             list <- base::list
[10:22:27.836]             seq.int <- base::seq.int
[10:22:27.836]             signalCondition <- base::signalCondition
[10:22:27.836]             sys.calls <- base::sys.calls
[10:22:27.836]             `[[` <- base::`[[`
[10:22:27.836]             `+` <- base::`+`
[10:22:27.836]             `<<-` <- base::`<<-`
[10:22:27.836]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:27.836]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:27.836]                   3L)]
[10:22:27.836]             }
[10:22:27.836]             function(cond) {
[10:22:27.836]                 is_error <- inherits(cond, "error")
[10:22:27.836]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:27.836]                   NULL)
[10:22:27.836]                 if (is_error) {
[10:22:27.836]                   sessionInformation <- function() {
[10:22:27.836]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:27.836]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:27.836]                       search = base::search(), system = base::Sys.info())
[10:22:27.836]                   }
[10:22:27.836]                   ...future.conditions[[length(...future.conditions) + 
[10:22:27.836]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:27.836]                     cond$call), session = sessionInformation(), 
[10:22:27.836]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:27.836]                   signalCondition(cond)
[10:22:27.836]                 }
[10:22:27.836]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:27.836]                 "immediateCondition"))) {
[10:22:27.836]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:27.836]                   ...future.conditions[[length(...future.conditions) + 
[10:22:27.836]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:27.836]                   if (TRUE && !signal) {
[10:22:27.836]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:27.836]                     {
[10:22:27.836]                       inherits <- base::inherits
[10:22:27.836]                       invokeRestart <- base::invokeRestart
[10:22:27.836]                       is.null <- base::is.null
[10:22:27.836]                       muffled <- FALSE
[10:22:27.836]                       if (inherits(cond, "message")) {
[10:22:27.836]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:27.836]                         if (muffled) 
[10:22:27.836]                           invokeRestart("muffleMessage")
[10:22:27.836]                       }
[10:22:27.836]                       else if (inherits(cond, "warning")) {
[10:22:27.836]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:27.836]                         if (muffled) 
[10:22:27.836]                           invokeRestart("muffleWarning")
[10:22:27.836]                       }
[10:22:27.836]                       else if (inherits(cond, "condition")) {
[10:22:27.836]                         if (!is.null(pattern)) {
[10:22:27.836]                           computeRestarts <- base::computeRestarts
[10:22:27.836]                           grepl <- base::grepl
[10:22:27.836]                           restarts <- computeRestarts(cond)
[10:22:27.836]                           for (restart in restarts) {
[10:22:27.836]                             name <- restart$name
[10:22:27.836]                             if (is.null(name)) 
[10:22:27.836]                               next
[10:22:27.836]                             if (!grepl(pattern, name)) 
[10:22:27.836]                               next
[10:22:27.836]                             invokeRestart(restart)
[10:22:27.836]                             muffled <- TRUE
[10:22:27.836]                             break
[10:22:27.836]                           }
[10:22:27.836]                         }
[10:22:27.836]                       }
[10:22:27.836]                       invisible(muffled)
[10:22:27.836]                     }
[10:22:27.836]                     muffleCondition(cond, pattern = "^muffle")
[10:22:27.836]                   }
[10:22:27.836]                 }
[10:22:27.836]                 else {
[10:22:27.836]                   if (TRUE) {
[10:22:27.836]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:27.836]                     {
[10:22:27.836]                       inherits <- base::inherits
[10:22:27.836]                       invokeRestart <- base::invokeRestart
[10:22:27.836]                       is.null <- base::is.null
[10:22:27.836]                       muffled <- FALSE
[10:22:27.836]                       if (inherits(cond, "message")) {
[10:22:27.836]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:27.836]                         if (muffled) 
[10:22:27.836]                           invokeRestart("muffleMessage")
[10:22:27.836]                       }
[10:22:27.836]                       else if (inherits(cond, "warning")) {
[10:22:27.836]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:27.836]                         if (muffled) 
[10:22:27.836]                           invokeRestart("muffleWarning")
[10:22:27.836]                       }
[10:22:27.836]                       else if (inherits(cond, "condition")) {
[10:22:27.836]                         if (!is.null(pattern)) {
[10:22:27.836]                           computeRestarts <- base::computeRestarts
[10:22:27.836]                           grepl <- base::grepl
[10:22:27.836]                           restarts <- computeRestarts(cond)
[10:22:27.836]                           for (restart in restarts) {
[10:22:27.836]                             name <- restart$name
[10:22:27.836]                             if (is.null(name)) 
[10:22:27.836]                               next
[10:22:27.836]                             if (!grepl(pattern, name)) 
[10:22:27.836]                               next
[10:22:27.836]                             invokeRestart(restart)
[10:22:27.836]                             muffled <- TRUE
[10:22:27.836]                             break
[10:22:27.836]                           }
[10:22:27.836]                         }
[10:22:27.836]                       }
[10:22:27.836]                       invisible(muffled)
[10:22:27.836]                     }
[10:22:27.836]                     muffleCondition(cond, pattern = "^muffle")
[10:22:27.836]                   }
[10:22:27.836]                 }
[10:22:27.836]             }
[10:22:27.836]         }))
[10:22:27.836]     }, error = function(ex) {
[10:22:27.836]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:27.836]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:27.836]                 ...future.rng), started = ...future.startTime, 
[10:22:27.836]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:27.836]             version = "1.8"), class = "FutureResult")
[10:22:27.836]     }, finally = {
[10:22:27.836]         if (!identical(...future.workdir, getwd())) 
[10:22:27.836]             setwd(...future.workdir)
[10:22:27.836]         {
[10:22:27.836]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:27.836]                 ...future.oldOptions$nwarnings <- NULL
[10:22:27.836]             }
[10:22:27.836]             base::options(...future.oldOptions)
[10:22:27.836]             if (.Platform$OS.type == "windows") {
[10:22:27.836]                 old_names <- names(...future.oldEnvVars)
[10:22:27.836]                 envs <- base::Sys.getenv()
[10:22:27.836]                 names <- names(envs)
[10:22:27.836]                 common <- intersect(names, old_names)
[10:22:27.836]                 added <- setdiff(names, old_names)
[10:22:27.836]                 removed <- setdiff(old_names, names)
[10:22:27.836]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:27.836]                   envs[common]]
[10:22:27.836]                 NAMES <- toupper(changed)
[10:22:27.836]                 args <- list()
[10:22:27.836]                 for (kk in seq_along(NAMES)) {
[10:22:27.836]                   name <- changed[[kk]]
[10:22:27.836]                   NAME <- NAMES[[kk]]
[10:22:27.836]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:27.836]                     next
[10:22:27.836]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:27.836]                 }
[10:22:27.836]                 NAMES <- toupper(added)
[10:22:27.836]                 for (kk in seq_along(NAMES)) {
[10:22:27.836]                   name <- added[[kk]]
[10:22:27.836]                   NAME <- NAMES[[kk]]
[10:22:27.836]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:27.836]                     next
[10:22:27.836]                   args[[name]] <- ""
[10:22:27.836]                 }
[10:22:27.836]                 NAMES <- toupper(removed)
[10:22:27.836]                 for (kk in seq_along(NAMES)) {
[10:22:27.836]                   name <- removed[[kk]]
[10:22:27.836]                   NAME <- NAMES[[kk]]
[10:22:27.836]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:27.836]                     next
[10:22:27.836]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:27.836]                 }
[10:22:27.836]                 if (length(args) > 0) 
[10:22:27.836]                   base::do.call(base::Sys.setenv, args = args)
[10:22:27.836]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:27.836]             }
[10:22:27.836]             else {
[10:22:27.836]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:27.836]             }
[10:22:27.836]             {
[10:22:27.836]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:27.836]                   0L) {
[10:22:27.836]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:27.836]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:27.836]                   base::options(opts)
[10:22:27.836]                 }
[10:22:27.836]                 {
[10:22:27.836]                   {
[10:22:27.836]                     NULL
[10:22:27.836]                     RNGkind("Mersenne-Twister")
[10:22:27.836]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:27.836]                       inherits = FALSE)
[10:22:27.836]                   }
[10:22:27.836]                   options(future.plan = NULL)
[10:22:27.836]                   if (is.na(NA_character_)) 
[10:22:27.836]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:27.836]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:27.836]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:27.836]                     .init = FALSE)
[10:22:27.836]                 }
[10:22:27.836]             }
[10:22:27.836]         }
[10:22:27.836]     })
[10:22:27.836]     if (TRUE) {
[10:22:27.836]         base::sink(type = "output", split = FALSE)
[10:22:27.836]         if (TRUE) {
[10:22:27.836]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:27.836]         }
[10:22:27.836]         else {
[10:22:27.836]             ...future.result["stdout"] <- base::list(NULL)
[10:22:27.836]         }
[10:22:27.836]         base::close(...future.stdout)
[10:22:27.836]         ...future.stdout <- NULL
[10:22:27.836]     }
[10:22:27.836]     ...future.result$conditions <- ...future.conditions
[10:22:27.836]     ...future.result$finished <- base::Sys.time()
[10:22:27.836]     ...future.result
[10:22:27.836] }
[10:22:27.838] plan(): Setting new future strategy stack:
[10:22:27.838] List of future strategies:
[10:22:27.838] 1. sequential:
[10:22:27.838]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:27.838]    - tweaked: FALSE
[10:22:27.838]    - call: NULL
[10:22:27.839] plan(): nbrOfWorkers() = 1
[10:22:27.839] plan(): Setting new future strategy stack:
[10:22:27.839] List of future strategies:
[10:22:27.839] 1. sequential:
[10:22:27.839]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:27.839]    - tweaked: FALSE
[10:22:27.839]    - call: plan(strategy)
[10:22:27.840] plan(): nbrOfWorkers() = 1
[10:22:27.840] SequentialFuture started (and completed)
[10:22:27.840] - Launch lazy future ... done
[10:22:27.840] run() for ‘SequentialFuture’ ... done
[10:22:27.840] resolve() on list ...
[10:22:27.840]  recursive: 0
[10:22:27.840]  length: 3
[10:22:27.840]  elements: ‘a’, ‘b’, ‘’
[10:22:27.840] run() for ‘Future’ ...
[10:22:27.841] - state: ‘created’
[10:22:27.841] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:27.841] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:27.841] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:27.841]   - Field: ‘label’
[10:22:27.841]   - Field: ‘local’
[10:22:27.841]   - Field: ‘owner’
[10:22:27.841]   - Field: ‘envir’
[10:22:27.841]   - Field: ‘packages’
[10:22:27.842]   - Field: ‘gc’
[10:22:27.842]   - Field: ‘conditions’
[10:22:27.842]   - Field: ‘expr’
[10:22:27.842]   - Field: ‘uuid’
[10:22:27.842]   - Field: ‘seed’
[10:22:27.842]   - Field: ‘version’
[10:22:27.842]   - Field: ‘result’
[10:22:27.842]   - Field: ‘asynchronous’
[10:22:27.842]   - Field: ‘calls’
[10:22:27.842]   - Field: ‘globals’
[10:22:27.842]   - Field: ‘stdout’
[10:22:27.842]   - Field: ‘earlySignal’
[10:22:27.842]   - Field: ‘lazy’
[10:22:27.843]   - Field: ‘state’
[10:22:27.843] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:27.843] - Launch lazy future ...
[10:22:27.843] Packages needed by the future expression (n = 0): <none>
[10:22:27.843] Packages needed by future strategies (n = 0): <none>
[10:22:27.843] {
[10:22:27.843]     {
[10:22:27.843]         {
[10:22:27.843]             ...future.startTime <- base::Sys.time()
[10:22:27.843]             {
[10:22:27.843]                 {
[10:22:27.843]                   {
[10:22:27.843]                     base::local({
[10:22:27.843]                       has_future <- base::requireNamespace("future", 
[10:22:27.843]                         quietly = TRUE)
[10:22:27.843]                       if (has_future) {
[10:22:27.843]                         ns <- base::getNamespace("future")
[10:22:27.843]                         version <- ns[[".package"]][["version"]]
[10:22:27.843]                         if (is.null(version)) 
[10:22:27.843]                           version <- utils::packageVersion("future")
[10:22:27.843]                       }
[10:22:27.843]                       else {
[10:22:27.843]                         version <- NULL
[10:22:27.843]                       }
[10:22:27.843]                       if (!has_future || version < "1.8.0") {
[10:22:27.843]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:27.843]                           "", base::R.version$version.string), 
[10:22:27.843]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:27.843]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:27.843]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:27.843]                             "release", "version")], collapse = " "), 
[10:22:27.843]                           hostname = base::Sys.info()[["nodename"]])
[10:22:27.843]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:27.843]                           info)
[10:22:27.843]                         info <- base::paste(info, collapse = "; ")
[10:22:27.843]                         if (!has_future) {
[10:22:27.843]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:27.843]                             info)
[10:22:27.843]                         }
[10:22:27.843]                         else {
[10:22:27.843]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:27.843]                             info, version)
[10:22:27.843]                         }
[10:22:27.843]                         base::stop(msg)
[10:22:27.843]                       }
[10:22:27.843]                     })
[10:22:27.843]                   }
[10:22:27.843]                   ...future.strategy.old <- future::plan("list")
[10:22:27.843]                   options(future.plan = NULL)
[10:22:27.843]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:27.843]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:27.843]                 }
[10:22:27.843]                 ...future.workdir <- getwd()
[10:22:27.843]             }
[10:22:27.843]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:27.843]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:27.843]         }
[10:22:27.843]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:27.843]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:27.843]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:27.843]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:27.843]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:27.843]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:27.843]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:27.843]             base::names(...future.oldOptions))
[10:22:27.843]     }
[10:22:27.843]     if (FALSE) {
[10:22:27.843]     }
[10:22:27.843]     else {
[10:22:27.843]         if (TRUE) {
[10:22:27.843]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:27.843]                 open = "w")
[10:22:27.843]         }
[10:22:27.843]         else {
[10:22:27.843]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:27.843]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:27.843]         }
[10:22:27.843]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:27.843]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:27.843]             base::sink(type = "output", split = FALSE)
[10:22:27.843]             base::close(...future.stdout)
[10:22:27.843]         }, add = TRUE)
[10:22:27.843]     }
[10:22:27.843]     ...future.frame <- base::sys.nframe()
[10:22:27.843]     ...future.conditions <- base::list()
[10:22:27.843]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:27.843]     if (FALSE) {
[10:22:27.843]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:27.843]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:27.843]     }
[10:22:27.843]     ...future.result <- base::tryCatch({
[10:22:27.843]         base::withCallingHandlers({
[10:22:27.843]             ...future.value <- base::withVisible(base::local(1))
[10:22:27.843]             future::FutureResult(value = ...future.value$value, 
[10:22:27.843]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:27.843]                   ...future.rng), globalenv = if (FALSE) 
[10:22:27.843]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:27.843]                     ...future.globalenv.names))
[10:22:27.843]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:27.843]         }, condition = base::local({
[10:22:27.843]             c <- base::c
[10:22:27.843]             inherits <- base::inherits
[10:22:27.843]             invokeRestart <- base::invokeRestart
[10:22:27.843]             length <- base::length
[10:22:27.843]             list <- base::list
[10:22:27.843]             seq.int <- base::seq.int
[10:22:27.843]             signalCondition <- base::signalCondition
[10:22:27.843]             sys.calls <- base::sys.calls
[10:22:27.843]             `[[` <- base::`[[`
[10:22:27.843]             `+` <- base::`+`
[10:22:27.843]             `<<-` <- base::`<<-`
[10:22:27.843]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:27.843]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:27.843]                   3L)]
[10:22:27.843]             }
[10:22:27.843]             function(cond) {
[10:22:27.843]                 is_error <- inherits(cond, "error")
[10:22:27.843]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:27.843]                   NULL)
[10:22:27.843]                 if (is_error) {
[10:22:27.843]                   sessionInformation <- function() {
[10:22:27.843]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:27.843]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:27.843]                       search = base::search(), system = base::Sys.info())
[10:22:27.843]                   }
[10:22:27.843]                   ...future.conditions[[length(...future.conditions) + 
[10:22:27.843]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:27.843]                     cond$call), session = sessionInformation(), 
[10:22:27.843]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:27.843]                   signalCondition(cond)
[10:22:27.843]                 }
[10:22:27.843]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:27.843]                 "immediateCondition"))) {
[10:22:27.843]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:27.843]                   ...future.conditions[[length(...future.conditions) + 
[10:22:27.843]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:27.843]                   if (TRUE && !signal) {
[10:22:27.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:27.843]                     {
[10:22:27.843]                       inherits <- base::inherits
[10:22:27.843]                       invokeRestart <- base::invokeRestart
[10:22:27.843]                       is.null <- base::is.null
[10:22:27.843]                       muffled <- FALSE
[10:22:27.843]                       if (inherits(cond, "message")) {
[10:22:27.843]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:27.843]                         if (muffled) 
[10:22:27.843]                           invokeRestart("muffleMessage")
[10:22:27.843]                       }
[10:22:27.843]                       else if (inherits(cond, "warning")) {
[10:22:27.843]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:27.843]                         if (muffled) 
[10:22:27.843]                           invokeRestart("muffleWarning")
[10:22:27.843]                       }
[10:22:27.843]                       else if (inherits(cond, "condition")) {
[10:22:27.843]                         if (!is.null(pattern)) {
[10:22:27.843]                           computeRestarts <- base::computeRestarts
[10:22:27.843]                           grepl <- base::grepl
[10:22:27.843]                           restarts <- computeRestarts(cond)
[10:22:27.843]                           for (restart in restarts) {
[10:22:27.843]                             name <- restart$name
[10:22:27.843]                             if (is.null(name)) 
[10:22:27.843]                               next
[10:22:27.843]                             if (!grepl(pattern, name)) 
[10:22:27.843]                               next
[10:22:27.843]                             invokeRestart(restart)
[10:22:27.843]                             muffled <- TRUE
[10:22:27.843]                             break
[10:22:27.843]                           }
[10:22:27.843]                         }
[10:22:27.843]                       }
[10:22:27.843]                       invisible(muffled)
[10:22:27.843]                     }
[10:22:27.843]                     muffleCondition(cond, pattern = "^muffle")
[10:22:27.843]                   }
[10:22:27.843]                 }
[10:22:27.843]                 else {
[10:22:27.843]                   if (TRUE) {
[10:22:27.843]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:27.843]                     {
[10:22:27.843]                       inherits <- base::inherits
[10:22:27.843]                       invokeRestart <- base::invokeRestart
[10:22:27.843]                       is.null <- base::is.null
[10:22:27.843]                       muffled <- FALSE
[10:22:27.843]                       if (inherits(cond, "message")) {
[10:22:27.843]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:27.843]                         if (muffled) 
[10:22:27.843]                           invokeRestart("muffleMessage")
[10:22:27.843]                       }
[10:22:27.843]                       else if (inherits(cond, "warning")) {
[10:22:27.843]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:27.843]                         if (muffled) 
[10:22:27.843]                           invokeRestart("muffleWarning")
[10:22:27.843]                       }
[10:22:27.843]                       else if (inherits(cond, "condition")) {
[10:22:27.843]                         if (!is.null(pattern)) {
[10:22:27.843]                           computeRestarts <- base::computeRestarts
[10:22:27.843]                           grepl <- base::grepl
[10:22:27.843]                           restarts <- computeRestarts(cond)
[10:22:27.843]                           for (restart in restarts) {
[10:22:27.843]                             name <- restart$name
[10:22:27.843]                             if (is.null(name)) 
[10:22:27.843]                               next
[10:22:27.843]                             if (!grepl(pattern, name)) 
[10:22:27.843]                               next
[10:22:27.843]                             invokeRestart(restart)
[10:22:27.843]                             muffled <- TRUE
[10:22:27.843]                             break
[10:22:27.843]                           }
[10:22:27.843]                         }
[10:22:27.843]                       }
[10:22:27.843]                       invisible(muffled)
[10:22:27.843]                     }
[10:22:27.843]                     muffleCondition(cond, pattern = "^muffle")
[10:22:27.843]                   }
[10:22:27.843]                 }
[10:22:27.843]             }
[10:22:27.843]         }))
[10:22:27.843]     }, error = function(ex) {
[10:22:27.843]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:27.843]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:27.843]                 ...future.rng), started = ...future.startTime, 
[10:22:27.843]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:27.843]             version = "1.8"), class = "FutureResult")
[10:22:27.843]     }, finally = {
[10:22:27.843]         if (!identical(...future.workdir, getwd())) 
[10:22:27.843]             setwd(...future.workdir)
[10:22:27.843]         {
[10:22:27.843]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:27.843]                 ...future.oldOptions$nwarnings <- NULL
[10:22:27.843]             }
[10:22:27.843]             base::options(...future.oldOptions)
[10:22:27.843]             if (.Platform$OS.type == "windows") {
[10:22:27.843]                 old_names <- names(...future.oldEnvVars)
[10:22:27.843]                 envs <- base::Sys.getenv()
[10:22:27.843]                 names <- names(envs)
[10:22:27.843]                 common <- intersect(names, old_names)
[10:22:27.843]                 added <- setdiff(names, old_names)
[10:22:27.843]                 removed <- setdiff(old_names, names)
[10:22:27.843]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:27.843]                   envs[common]]
[10:22:27.843]                 NAMES <- toupper(changed)
[10:22:27.843]                 args <- list()
[10:22:27.843]                 for (kk in seq_along(NAMES)) {
[10:22:27.843]                   name <- changed[[kk]]
[10:22:27.843]                   NAME <- NAMES[[kk]]
[10:22:27.843]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:27.843]                     next
[10:22:27.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:27.843]                 }
[10:22:27.843]                 NAMES <- toupper(added)
[10:22:27.843]                 for (kk in seq_along(NAMES)) {
[10:22:27.843]                   name <- added[[kk]]
[10:22:27.843]                   NAME <- NAMES[[kk]]
[10:22:27.843]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:27.843]                     next
[10:22:27.843]                   args[[name]] <- ""
[10:22:27.843]                 }
[10:22:27.843]                 NAMES <- toupper(removed)
[10:22:27.843]                 for (kk in seq_along(NAMES)) {
[10:22:27.843]                   name <- removed[[kk]]
[10:22:27.843]                   NAME <- NAMES[[kk]]
[10:22:27.843]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:27.843]                     next
[10:22:27.843]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:27.843]                 }
[10:22:27.843]                 if (length(args) > 0) 
[10:22:27.843]                   base::do.call(base::Sys.setenv, args = args)
[10:22:27.843]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:27.843]             }
[10:22:27.843]             else {
[10:22:27.843]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:27.843]             }
[10:22:27.843]             {
[10:22:27.843]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:27.843]                   0L) {
[10:22:27.843]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:27.843]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:27.843]                   base::options(opts)
[10:22:27.843]                 }
[10:22:27.843]                 {
[10:22:27.843]                   {
[10:22:27.843]                     NULL
[10:22:27.843]                     RNGkind("Mersenne-Twister")
[10:22:27.843]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:27.843]                       inherits = FALSE)
[10:22:27.843]                   }
[10:22:27.843]                   options(future.plan = NULL)
[10:22:27.843]                   if (is.na(NA_character_)) 
[10:22:27.843]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:27.843]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:27.843]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:27.843]                     .init = FALSE)
[10:22:27.843]                 }
[10:22:27.843]             }
[10:22:27.843]         }
[10:22:27.843]     })
[10:22:27.843]     if (TRUE) {
[10:22:27.843]         base::sink(type = "output", split = FALSE)
[10:22:27.843]         if (TRUE) {
[10:22:27.843]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:27.843]         }
[10:22:27.843]         else {
[10:22:27.843]             ...future.result["stdout"] <- base::list(NULL)
[10:22:27.843]         }
[10:22:27.843]         base::close(...future.stdout)
[10:22:27.843]         ...future.stdout <- NULL
[10:22:27.843]     }
[10:22:27.843]     ...future.result$conditions <- ...future.conditions
[10:22:27.843]     ...future.result$finished <- base::Sys.time()
[10:22:27.843]     ...future.result
[10:22:27.843] }
[10:22:27.845] plan(): Setting new future strategy stack:
[10:22:27.845] List of future strategies:
[10:22:27.845] 1. sequential:
[10:22:27.845]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:27.845]    - tweaked: FALSE
[10:22:27.845]    - call: NULL
[10:22:27.846] plan(): nbrOfWorkers() = 1
[10:22:27.846] plan(): Setting new future strategy stack:
[10:22:27.846] List of future strategies:
[10:22:27.846] 1. sequential:
[10:22:27.846]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:27.846]    - tweaked: FALSE
[10:22:27.846]    - call: plan(strategy)
[10:22:27.847] plan(): nbrOfWorkers() = 1
[10:22:27.847] SequentialFuture started (and completed)
[10:22:27.847] - Launch lazy future ... done
[10:22:27.847] run() for ‘SequentialFuture’ ... done
[10:22:27.847] resolved() for ‘SequentialFuture’ ...
[10:22:27.847] - state: ‘finished’
[10:22:27.847] - run: TRUE
[10:22:27.848] - result: ‘FutureResult’
[10:22:27.848] resolved() for ‘SequentialFuture’ ... done
[10:22:27.848] Future #1
[10:22:27.848]  length: 2 (resolved future 1)
[10:22:27.848] resolved() for ‘SequentialFuture’ ...
[10:22:27.848] - state: ‘finished’
[10:22:27.848] - run: TRUE
[10:22:27.848] - result: ‘FutureResult’
[10:22:27.848] resolved() for ‘SequentialFuture’ ... done
[10:22:27.848] Future #2
[10:22:27.848]  length: 1 (resolved future 2)
[10:22:27.849]  length: 0 (resolved future 3)
[10:22:27.849] resolve() on list ... DONE
[10:22:27.849] resolved() for ‘SequentialFuture’ ...
[10:22:27.849] - state: ‘finished’
[10:22:27.849] - run: TRUE
[10:22:27.849] - result: ‘FutureResult’
[10:22:27.849] resolved() for ‘SequentialFuture’ ... done
[10:22:27.849] resolved() for ‘SequentialFuture’ ...
[10:22:27.849] - state: ‘finished’
[10:22:27.849] - run: TRUE
[10:22:27.849] - result: ‘FutureResult’
[10:22:27.849] resolved() for ‘SequentialFuture’ ... done
[10:22:27.850] getGlobalsAndPackages() ...
[10:22:27.850] Searching for globals...
[10:22:27.850] 
[10:22:27.850] Searching for globals ... DONE
[10:22:27.850] - globals: [0] <none>
[10:22:27.850] getGlobalsAndPackages() ... DONE
[10:22:27.850] getGlobalsAndPackages() ...
[10:22:27.850] Searching for globals...
[10:22:27.851] 
[10:22:27.851] Searching for globals ... DONE
[10:22:27.851] - globals: [0] <none>
[10:22:27.851] getGlobalsAndPackages() ... DONE
[10:22:27.851] resolve() on list ...
[10:22:27.851]  recursive: 0
[10:22:27.851]  length: 3
[10:22:27.851]  elements: ‘a’, ‘b’, ‘’
[10:22:27.851] run() for ‘Future’ ...
[10:22:27.852] - state: ‘created’
[10:22:27.852] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:27.852] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:27.852] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:27.852]   - Field: ‘label’
[10:22:27.852]   - Field: ‘local’
[10:22:27.852]   - Field: ‘owner’
[10:22:27.852]   - Field: ‘envir’
[10:22:27.852]   - Field: ‘packages’
[10:22:27.852]   - Field: ‘gc’
[10:22:27.853]   - Field: ‘conditions’
[10:22:27.853]   - Field: ‘expr’
[10:22:27.853]   - Field: ‘uuid’
[10:22:27.853]   - Field: ‘seed’
[10:22:27.853]   - Field: ‘version’
[10:22:27.853]   - Field: ‘result’
[10:22:27.853]   - Field: ‘asynchronous’
[10:22:27.853]   - Field: ‘calls’
[10:22:27.853]   - Field: ‘globals’
[10:22:27.853]   - Field: ‘stdout’
[10:22:27.853]   - Field: ‘earlySignal’
[10:22:27.853]   - Field: ‘lazy’
[10:22:27.853]   - Field: ‘state’
[10:22:27.854] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:27.854] - Launch lazy future ...
[10:22:27.854] Packages needed by the future expression (n = 0): <none>
[10:22:27.854] Packages needed by future strategies (n = 0): <none>
[10:22:27.854] {
[10:22:27.854]     {
[10:22:27.854]         {
[10:22:27.854]             ...future.startTime <- base::Sys.time()
[10:22:27.854]             {
[10:22:27.854]                 {
[10:22:27.854]                   {
[10:22:27.854]                     base::local({
[10:22:27.854]                       has_future <- base::requireNamespace("future", 
[10:22:27.854]                         quietly = TRUE)
[10:22:27.854]                       if (has_future) {
[10:22:27.854]                         ns <- base::getNamespace("future")
[10:22:27.854]                         version <- ns[[".package"]][["version"]]
[10:22:27.854]                         if (is.null(version)) 
[10:22:27.854]                           version <- utils::packageVersion("future")
[10:22:27.854]                       }
[10:22:27.854]                       else {
[10:22:27.854]                         version <- NULL
[10:22:27.854]                       }
[10:22:27.854]                       if (!has_future || version < "1.8.0") {
[10:22:27.854]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:27.854]                           "", base::R.version$version.string), 
[10:22:27.854]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:27.854]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:27.854]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:27.854]                             "release", "version")], collapse = " "), 
[10:22:27.854]                           hostname = base::Sys.info()[["nodename"]])
[10:22:27.854]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:27.854]                           info)
[10:22:27.854]                         info <- base::paste(info, collapse = "; ")
[10:22:27.854]                         if (!has_future) {
[10:22:27.854]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:27.854]                             info)
[10:22:27.854]                         }
[10:22:27.854]                         else {
[10:22:27.854]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:27.854]                             info, version)
[10:22:27.854]                         }
[10:22:27.854]                         base::stop(msg)
[10:22:27.854]                       }
[10:22:27.854]                     })
[10:22:27.854]                   }
[10:22:27.854]                   ...future.strategy.old <- future::plan("list")
[10:22:27.854]                   options(future.plan = NULL)
[10:22:27.854]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:27.854]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:27.854]                 }
[10:22:27.854]                 ...future.workdir <- getwd()
[10:22:27.854]             }
[10:22:27.854]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:27.854]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:27.854]         }
[10:22:27.854]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:27.854]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:27.854]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:27.854]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:27.854]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:27.854]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:27.854]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:27.854]             base::names(...future.oldOptions))
[10:22:27.854]     }
[10:22:27.854]     if (FALSE) {
[10:22:27.854]     }
[10:22:27.854]     else {
[10:22:27.854]         if (TRUE) {
[10:22:27.854]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:27.854]                 open = "w")
[10:22:27.854]         }
[10:22:27.854]         else {
[10:22:27.854]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:27.854]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:27.854]         }
[10:22:27.854]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:27.854]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:27.854]             base::sink(type = "output", split = FALSE)
[10:22:27.854]             base::close(...future.stdout)
[10:22:27.854]         }, add = TRUE)
[10:22:27.854]     }
[10:22:27.854]     ...future.frame <- base::sys.nframe()
[10:22:27.854]     ...future.conditions <- base::list()
[10:22:27.854]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:27.854]     if (FALSE) {
[10:22:27.854]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:27.854]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:27.854]     }
[10:22:27.854]     ...future.result <- base::tryCatch({
[10:22:27.854]         base::withCallingHandlers({
[10:22:27.854]             ...future.value <- base::withVisible(base::local(1))
[10:22:27.854]             future::FutureResult(value = ...future.value$value, 
[10:22:27.854]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:27.854]                   ...future.rng), globalenv = if (FALSE) 
[10:22:27.854]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:27.854]                     ...future.globalenv.names))
[10:22:27.854]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:27.854]         }, condition = base::local({
[10:22:27.854]             c <- base::c
[10:22:27.854]             inherits <- base::inherits
[10:22:27.854]             invokeRestart <- base::invokeRestart
[10:22:27.854]             length <- base::length
[10:22:27.854]             list <- base::list
[10:22:27.854]             seq.int <- base::seq.int
[10:22:27.854]             signalCondition <- base::signalCondition
[10:22:27.854]             sys.calls <- base::sys.calls
[10:22:27.854]             `[[` <- base::`[[`
[10:22:27.854]             `+` <- base::`+`
[10:22:27.854]             `<<-` <- base::`<<-`
[10:22:27.854]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:27.854]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:27.854]                   3L)]
[10:22:27.854]             }
[10:22:27.854]             function(cond) {
[10:22:27.854]                 is_error <- inherits(cond, "error")
[10:22:27.854]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:27.854]                   NULL)
[10:22:27.854]                 if (is_error) {
[10:22:27.854]                   sessionInformation <- function() {
[10:22:27.854]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:27.854]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:27.854]                       search = base::search(), system = base::Sys.info())
[10:22:27.854]                   }
[10:22:27.854]                   ...future.conditions[[length(...future.conditions) + 
[10:22:27.854]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:27.854]                     cond$call), session = sessionInformation(), 
[10:22:27.854]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:27.854]                   signalCondition(cond)
[10:22:27.854]                 }
[10:22:27.854]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:27.854]                 "immediateCondition"))) {
[10:22:27.854]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:27.854]                   ...future.conditions[[length(...future.conditions) + 
[10:22:27.854]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:27.854]                   if (TRUE && !signal) {
[10:22:27.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:27.854]                     {
[10:22:27.854]                       inherits <- base::inherits
[10:22:27.854]                       invokeRestart <- base::invokeRestart
[10:22:27.854]                       is.null <- base::is.null
[10:22:27.854]                       muffled <- FALSE
[10:22:27.854]                       if (inherits(cond, "message")) {
[10:22:27.854]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:27.854]                         if (muffled) 
[10:22:27.854]                           invokeRestart("muffleMessage")
[10:22:27.854]                       }
[10:22:27.854]                       else if (inherits(cond, "warning")) {
[10:22:27.854]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:27.854]                         if (muffled) 
[10:22:27.854]                           invokeRestart("muffleWarning")
[10:22:27.854]                       }
[10:22:27.854]                       else if (inherits(cond, "condition")) {
[10:22:27.854]                         if (!is.null(pattern)) {
[10:22:27.854]                           computeRestarts <- base::computeRestarts
[10:22:27.854]                           grepl <- base::grepl
[10:22:27.854]                           restarts <- computeRestarts(cond)
[10:22:27.854]                           for (restart in restarts) {
[10:22:27.854]                             name <- restart$name
[10:22:27.854]                             if (is.null(name)) 
[10:22:27.854]                               next
[10:22:27.854]                             if (!grepl(pattern, name)) 
[10:22:27.854]                               next
[10:22:27.854]                             invokeRestart(restart)
[10:22:27.854]                             muffled <- TRUE
[10:22:27.854]                             break
[10:22:27.854]                           }
[10:22:27.854]                         }
[10:22:27.854]                       }
[10:22:27.854]                       invisible(muffled)
[10:22:27.854]                     }
[10:22:27.854]                     muffleCondition(cond, pattern = "^muffle")
[10:22:27.854]                   }
[10:22:27.854]                 }
[10:22:27.854]                 else {
[10:22:27.854]                   if (TRUE) {
[10:22:27.854]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:27.854]                     {
[10:22:27.854]                       inherits <- base::inherits
[10:22:27.854]                       invokeRestart <- base::invokeRestart
[10:22:27.854]                       is.null <- base::is.null
[10:22:27.854]                       muffled <- FALSE
[10:22:27.854]                       if (inherits(cond, "message")) {
[10:22:27.854]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:27.854]                         if (muffled) 
[10:22:27.854]                           invokeRestart("muffleMessage")
[10:22:27.854]                       }
[10:22:27.854]                       else if (inherits(cond, "warning")) {
[10:22:27.854]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:27.854]                         if (muffled) 
[10:22:27.854]                           invokeRestart("muffleWarning")
[10:22:27.854]                       }
[10:22:27.854]                       else if (inherits(cond, "condition")) {
[10:22:27.854]                         if (!is.null(pattern)) {
[10:22:27.854]                           computeRestarts <- base::computeRestarts
[10:22:27.854]                           grepl <- base::grepl
[10:22:27.854]                           restarts <- computeRestarts(cond)
[10:22:27.854]                           for (restart in restarts) {
[10:22:27.854]                             name <- restart$name
[10:22:27.854]                             if (is.null(name)) 
[10:22:27.854]                               next
[10:22:27.854]                             if (!grepl(pattern, name)) 
[10:22:27.854]                               next
[10:22:27.854]                             invokeRestart(restart)
[10:22:27.854]                             muffled <- TRUE
[10:22:27.854]                             break
[10:22:27.854]                           }
[10:22:27.854]                         }
[10:22:27.854]                       }
[10:22:27.854]                       invisible(muffled)
[10:22:27.854]                     }
[10:22:27.854]                     muffleCondition(cond, pattern = "^muffle")
[10:22:27.854]                   }
[10:22:27.854]                 }
[10:22:27.854]             }
[10:22:27.854]         }))
[10:22:27.854]     }, error = function(ex) {
[10:22:27.854]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:27.854]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:27.854]                 ...future.rng), started = ...future.startTime, 
[10:22:27.854]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:27.854]             version = "1.8"), class = "FutureResult")
[10:22:27.854]     }, finally = {
[10:22:27.854]         if (!identical(...future.workdir, getwd())) 
[10:22:27.854]             setwd(...future.workdir)
[10:22:27.854]         {
[10:22:27.854]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:27.854]                 ...future.oldOptions$nwarnings <- NULL
[10:22:27.854]             }
[10:22:27.854]             base::options(...future.oldOptions)
[10:22:27.854]             if (.Platform$OS.type == "windows") {
[10:22:27.854]                 old_names <- names(...future.oldEnvVars)
[10:22:27.854]                 envs <- base::Sys.getenv()
[10:22:27.854]                 names <- names(envs)
[10:22:27.854]                 common <- intersect(names, old_names)
[10:22:27.854]                 added <- setdiff(names, old_names)
[10:22:27.854]                 removed <- setdiff(old_names, names)
[10:22:27.854]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:27.854]                   envs[common]]
[10:22:27.854]                 NAMES <- toupper(changed)
[10:22:27.854]                 args <- list()
[10:22:27.854]                 for (kk in seq_along(NAMES)) {
[10:22:27.854]                   name <- changed[[kk]]
[10:22:27.854]                   NAME <- NAMES[[kk]]
[10:22:27.854]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:27.854]                     next
[10:22:27.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:27.854]                 }
[10:22:27.854]                 NAMES <- toupper(added)
[10:22:27.854]                 for (kk in seq_along(NAMES)) {
[10:22:27.854]                   name <- added[[kk]]
[10:22:27.854]                   NAME <- NAMES[[kk]]
[10:22:27.854]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:27.854]                     next
[10:22:27.854]                   args[[name]] <- ""
[10:22:27.854]                 }
[10:22:27.854]                 NAMES <- toupper(removed)
[10:22:27.854]                 for (kk in seq_along(NAMES)) {
[10:22:27.854]                   name <- removed[[kk]]
[10:22:27.854]                   NAME <- NAMES[[kk]]
[10:22:27.854]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:27.854]                     next
[10:22:27.854]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:27.854]                 }
[10:22:27.854]                 if (length(args) > 0) 
[10:22:27.854]                   base::do.call(base::Sys.setenv, args = args)
[10:22:27.854]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:27.854]             }
[10:22:27.854]             else {
[10:22:27.854]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:27.854]             }
[10:22:27.854]             {
[10:22:27.854]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:27.854]                   0L) {
[10:22:27.854]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:27.854]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:27.854]                   base::options(opts)
[10:22:27.854]                 }
[10:22:27.854]                 {
[10:22:27.854]                   {
[10:22:27.854]                     NULL
[10:22:27.854]                     RNGkind("Mersenne-Twister")
[10:22:27.854]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:27.854]                       inherits = FALSE)
[10:22:27.854]                   }
[10:22:27.854]                   options(future.plan = NULL)
[10:22:27.854]                   if (is.na(NA_character_)) 
[10:22:27.854]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:27.854]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:27.854]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:27.854]                     .init = FALSE)
[10:22:27.854]                 }
[10:22:27.854]             }
[10:22:27.854]         }
[10:22:27.854]     })
[10:22:27.854]     if (TRUE) {
[10:22:27.854]         base::sink(type = "output", split = FALSE)
[10:22:27.854]         if (TRUE) {
[10:22:27.854]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:27.854]         }
[10:22:27.854]         else {
[10:22:27.854]             ...future.result["stdout"] <- base::list(NULL)
[10:22:27.854]         }
[10:22:27.854]         base::close(...future.stdout)
[10:22:27.854]         ...future.stdout <- NULL
[10:22:27.854]     }
[10:22:27.854]     ...future.result$conditions <- ...future.conditions
[10:22:27.854]     ...future.result$finished <- base::Sys.time()
[10:22:27.854]     ...future.result
[10:22:27.854] }
[10:22:27.856] plan(): Setting new future strategy stack:
[10:22:27.856] List of future strategies:
[10:22:27.856] 1. sequential:
[10:22:27.856]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:27.856]    - tweaked: FALSE
[10:22:27.856]    - call: NULL
[10:22:27.856] plan(): nbrOfWorkers() = 1
[10:22:27.857] plan(): Setting new future strategy stack:
[10:22:27.857] List of future strategies:
[10:22:27.857] 1. sequential:
[10:22:27.857]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:27.857]    - tweaked: FALSE
[10:22:27.857]    - call: plan(strategy)
[10:22:27.858] plan(): nbrOfWorkers() = 1
[10:22:27.858] SequentialFuture started (and completed)
[10:22:27.858] - Launch lazy future ... done
[10:22:27.858] run() for ‘SequentialFuture’ ... done
[10:22:27.858] resolved() for ‘SequentialFuture’ ...
[10:22:27.858] - state: ‘finished’
[10:22:27.858] - run: TRUE
[10:22:27.858] - result: ‘FutureResult’
[10:22:27.858] resolved() for ‘SequentialFuture’ ... done
[10:22:27.859] Future #1
[10:22:27.859]  length: 2 (resolved future 1)
[10:22:27.859] run() for ‘Future’ ...
[10:22:27.859] - state: ‘created’
[10:22:27.859] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:27.859] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:27.859] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:27.859]   - Field: ‘label’
[10:22:27.859]   - Field: ‘local’
[10:22:27.860]   - Field: ‘owner’
[10:22:27.860]   - Field: ‘envir’
[10:22:27.860]   - Field: ‘packages’
[10:22:27.860]   - Field: ‘gc’
[10:22:27.860]   - Field: ‘conditions’
[10:22:27.860]   - Field: ‘expr’
[10:22:27.860]   - Field: ‘uuid’
[10:22:27.860]   - Field: ‘seed’
[10:22:27.860]   - Field: ‘version’
[10:22:27.860]   - Field: ‘result’
[10:22:27.860]   - Field: ‘asynchronous’
[10:22:27.860]   - Field: ‘calls’
[10:22:27.861]   - Field: ‘globals’
[10:22:27.861]   - Field: ‘stdout’
[10:22:27.861]   - Field: ‘earlySignal’
[10:22:27.861]   - Field: ‘lazy’
[10:22:27.861]   - Field: ‘state’
[10:22:27.861] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:27.861] - Launch lazy future ...
[10:22:27.861] Packages needed by the future expression (n = 0): <none>
[10:22:27.861] Packages needed by future strategies (n = 0): <none>
[10:22:27.862] {
[10:22:27.862]     {
[10:22:27.862]         {
[10:22:27.862]             ...future.startTime <- base::Sys.time()
[10:22:27.862]             {
[10:22:27.862]                 {
[10:22:27.862]                   {
[10:22:27.862]                     base::local({
[10:22:27.862]                       has_future <- base::requireNamespace("future", 
[10:22:27.862]                         quietly = TRUE)
[10:22:27.862]                       if (has_future) {
[10:22:27.862]                         ns <- base::getNamespace("future")
[10:22:27.862]                         version <- ns[[".package"]][["version"]]
[10:22:27.862]                         if (is.null(version)) 
[10:22:27.862]                           version <- utils::packageVersion("future")
[10:22:27.862]                       }
[10:22:27.862]                       else {
[10:22:27.862]                         version <- NULL
[10:22:27.862]                       }
[10:22:27.862]                       if (!has_future || version < "1.8.0") {
[10:22:27.862]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:27.862]                           "", base::R.version$version.string), 
[10:22:27.862]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:27.862]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:27.862]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:27.862]                             "release", "version")], collapse = " "), 
[10:22:27.862]                           hostname = base::Sys.info()[["nodename"]])
[10:22:27.862]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:27.862]                           info)
[10:22:27.862]                         info <- base::paste(info, collapse = "; ")
[10:22:27.862]                         if (!has_future) {
[10:22:27.862]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:27.862]                             info)
[10:22:27.862]                         }
[10:22:27.862]                         else {
[10:22:27.862]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:27.862]                             info, version)
[10:22:27.862]                         }
[10:22:27.862]                         base::stop(msg)
[10:22:27.862]                       }
[10:22:27.862]                     })
[10:22:27.862]                   }
[10:22:27.862]                   ...future.strategy.old <- future::plan("list")
[10:22:27.862]                   options(future.plan = NULL)
[10:22:27.862]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:27.862]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:27.862]                 }
[10:22:27.862]                 ...future.workdir <- getwd()
[10:22:27.862]             }
[10:22:27.862]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:27.862]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:27.862]         }
[10:22:27.862]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:27.862]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:27.862]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:27.862]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:27.862]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:27.862]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:27.862]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:27.862]             base::names(...future.oldOptions))
[10:22:27.862]     }
[10:22:27.862]     if (FALSE) {
[10:22:27.862]     }
[10:22:27.862]     else {
[10:22:27.862]         if (TRUE) {
[10:22:27.862]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:27.862]                 open = "w")
[10:22:27.862]         }
[10:22:27.862]         else {
[10:22:27.862]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:27.862]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:27.862]         }
[10:22:27.862]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:27.862]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:27.862]             base::sink(type = "output", split = FALSE)
[10:22:27.862]             base::close(...future.stdout)
[10:22:27.862]         }, add = TRUE)
[10:22:27.862]     }
[10:22:27.862]     ...future.frame <- base::sys.nframe()
[10:22:27.862]     ...future.conditions <- base::list()
[10:22:27.862]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:27.862]     if (FALSE) {
[10:22:27.862]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:27.862]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:27.862]     }
[10:22:27.862]     ...future.result <- base::tryCatch({
[10:22:27.862]         base::withCallingHandlers({
[10:22:27.862]             ...future.value <- base::withVisible(base::local(2))
[10:22:27.862]             future::FutureResult(value = ...future.value$value, 
[10:22:27.862]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:27.862]                   ...future.rng), globalenv = if (FALSE) 
[10:22:27.862]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:27.862]                     ...future.globalenv.names))
[10:22:27.862]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:27.862]         }, condition = base::local({
[10:22:27.862]             c <- base::c
[10:22:27.862]             inherits <- base::inherits
[10:22:27.862]             invokeRestart <- base::invokeRestart
[10:22:27.862]             length <- base::length
[10:22:27.862]             list <- base::list
[10:22:27.862]             seq.int <- base::seq.int
[10:22:27.862]             signalCondition <- base::signalCondition
[10:22:27.862]             sys.calls <- base::sys.calls
[10:22:27.862]             `[[` <- base::`[[`
[10:22:27.862]             `+` <- base::`+`
[10:22:27.862]             `<<-` <- base::`<<-`
[10:22:27.862]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:27.862]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:27.862]                   3L)]
[10:22:27.862]             }
[10:22:27.862]             function(cond) {
[10:22:27.862]                 is_error <- inherits(cond, "error")
[10:22:27.862]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:27.862]                   NULL)
[10:22:27.862]                 if (is_error) {
[10:22:27.862]                   sessionInformation <- function() {
[10:22:27.862]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:27.862]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:27.862]                       search = base::search(), system = base::Sys.info())
[10:22:27.862]                   }
[10:22:27.862]                   ...future.conditions[[length(...future.conditions) + 
[10:22:27.862]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:27.862]                     cond$call), session = sessionInformation(), 
[10:22:27.862]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:27.862]                   signalCondition(cond)
[10:22:27.862]                 }
[10:22:27.862]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:27.862]                 "immediateCondition"))) {
[10:22:27.862]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:27.862]                   ...future.conditions[[length(...future.conditions) + 
[10:22:27.862]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:27.862]                   if (TRUE && !signal) {
[10:22:27.862]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:27.862]                     {
[10:22:27.862]                       inherits <- base::inherits
[10:22:27.862]                       invokeRestart <- base::invokeRestart
[10:22:27.862]                       is.null <- base::is.null
[10:22:27.862]                       muffled <- FALSE
[10:22:27.862]                       if (inherits(cond, "message")) {
[10:22:27.862]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:27.862]                         if (muffled) 
[10:22:27.862]                           invokeRestart("muffleMessage")
[10:22:27.862]                       }
[10:22:27.862]                       else if (inherits(cond, "warning")) {
[10:22:27.862]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:27.862]                         if (muffled) 
[10:22:27.862]                           invokeRestart("muffleWarning")
[10:22:27.862]                       }
[10:22:27.862]                       else if (inherits(cond, "condition")) {
[10:22:27.862]                         if (!is.null(pattern)) {
[10:22:27.862]                           computeRestarts <- base::computeRestarts
[10:22:27.862]                           grepl <- base::grepl
[10:22:27.862]                           restarts <- computeRestarts(cond)
[10:22:27.862]                           for (restart in restarts) {
[10:22:27.862]                             name <- restart$name
[10:22:27.862]                             if (is.null(name)) 
[10:22:27.862]                               next
[10:22:27.862]                             if (!grepl(pattern, name)) 
[10:22:27.862]                               next
[10:22:27.862]                             invokeRestart(restart)
[10:22:27.862]                             muffled <- TRUE
[10:22:27.862]                             break
[10:22:27.862]                           }
[10:22:27.862]                         }
[10:22:27.862]                       }
[10:22:27.862]                       invisible(muffled)
[10:22:27.862]                     }
[10:22:27.862]                     muffleCondition(cond, pattern = "^muffle")
[10:22:27.862]                   }
[10:22:27.862]                 }
[10:22:27.862]                 else {
[10:22:27.862]                   if (TRUE) {
[10:22:27.862]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:27.862]                     {
[10:22:27.862]                       inherits <- base::inherits
[10:22:27.862]                       invokeRestart <- base::invokeRestart
[10:22:27.862]                       is.null <- base::is.null
[10:22:27.862]                       muffled <- FALSE
[10:22:27.862]                       if (inherits(cond, "message")) {
[10:22:27.862]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:27.862]                         if (muffled) 
[10:22:27.862]                           invokeRestart("muffleMessage")
[10:22:27.862]                       }
[10:22:27.862]                       else if (inherits(cond, "warning")) {
[10:22:27.862]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:27.862]                         if (muffled) 
[10:22:27.862]                           invokeRestart("muffleWarning")
[10:22:27.862]                       }
[10:22:27.862]                       else if (inherits(cond, "condition")) {
[10:22:27.862]                         if (!is.null(pattern)) {
[10:22:27.862]                           computeRestarts <- base::computeRestarts
[10:22:27.862]                           grepl <- base::grepl
[10:22:27.862]                           restarts <- computeRestarts(cond)
[10:22:27.862]                           for (restart in restarts) {
[10:22:27.862]                             name <- restart$name
[10:22:27.862]                             if (is.null(name)) 
[10:22:27.862]                               next
[10:22:27.862]                             if (!grepl(pattern, name)) 
[10:22:27.862]                               next
[10:22:27.862]                             invokeRestart(restart)
[10:22:27.862]                             muffled <- TRUE
[10:22:27.862]                             break
[10:22:27.862]                           }
[10:22:27.862]                         }
[10:22:27.862]                       }
[10:22:27.862]                       invisible(muffled)
[10:22:27.862]                     }
[10:22:27.862]                     muffleCondition(cond, pattern = "^muffle")
[10:22:27.862]                   }
[10:22:27.862]                 }
[10:22:27.862]             }
[10:22:27.862]         }))
[10:22:27.862]     }, error = function(ex) {
[10:22:27.862]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:27.862]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:27.862]                 ...future.rng), started = ...future.startTime, 
[10:22:27.862]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:27.862]             version = "1.8"), class = "FutureResult")
[10:22:27.862]     }, finally = {
[10:22:27.862]         if (!identical(...future.workdir, getwd())) 
[10:22:27.862]             setwd(...future.workdir)
[10:22:27.862]         {
[10:22:27.862]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:27.862]                 ...future.oldOptions$nwarnings <- NULL
[10:22:27.862]             }
[10:22:27.862]             base::options(...future.oldOptions)
[10:22:27.862]             if (.Platform$OS.type == "windows") {
[10:22:27.862]                 old_names <- names(...future.oldEnvVars)
[10:22:27.862]                 envs <- base::Sys.getenv()
[10:22:27.862]                 names <- names(envs)
[10:22:27.862]                 common <- intersect(names, old_names)
[10:22:27.862]                 added <- setdiff(names, old_names)
[10:22:27.862]                 removed <- setdiff(old_names, names)
[10:22:27.862]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:27.862]                   envs[common]]
[10:22:27.862]                 NAMES <- toupper(changed)
[10:22:27.862]                 args <- list()
[10:22:27.862]                 for (kk in seq_along(NAMES)) {
[10:22:27.862]                   name <- changed[[kk]]
[10:22:27.862]                   NAME <- NAMES[[kk]]
[10:22:27.862]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:27.862]                     next
[10:22:27.862]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:27.862]                 }
[10:22:27.862]                 NAMES <- toupper(added)
[10:22:27.862]                 for (kk in seq_along(NAMES)) {
[10:22:27.862]                   name <- added[[kk]]
[10:22:27.862]                   NAME <- NAMES[[kk]]
[10:22:27.862]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:27.862]                     next
[10:22:27.862]                   args[[name]] <- ""
[10:22:27.862]                 }
[10:22:27.862]                 NAMES <- toupper(removed)
[10:22:27.862]                 for (kk in seq_along(NAMES)) {
[10:22:27.862]                   name <- removed[[kk]]
[10:22:27.862]                   NAME <- NAMES[[kk]]
[10:22:27.862]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:27.862]                     next
[10:22:27.862]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:27.862]                 }
[10:22:27.862]                 if (length(args) > 0) 
[10:22:27.862]                   base::do.call(base::Sys.setenv, args = args)
[10:22:27.862]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:27.862]             }
[10:22:27.862]             else {
[10:22:27.862]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:27.862]             }
[10:22:27.862]             {
[10:22:27.862]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:27.862]                   0L) {
[10:22:27.862]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:27.862]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:27.862]                   base::options(opts)
[10:22:27.862]                 }
[10:22:27.862]                 {
[10:22:27.862]                   {
[10:22:27.862]                     NULL
[10:22:27.862]                     RNGkind("Mersenne-Twister")
[10:22:27.862]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:27.862]                       inherits = FALSE)
[10:22:27.862]                   }
[10:22:27.862]                   options(future.plan = NULL)
[10:22:27.862]                   if (is.na(NA_character_)) 
[10:22:27.862]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:27.862]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:27.862]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:27.862]                     .init = FALSE)
[10:22:27.862]                 }
[10:22:27.862]             }
[10:22:27.862]         }
[10:22:27.862]     })
[10:22:27.862]     if (TRUE) {
[10:22:27.862]         base::sink(type = "output", split = FALSE)
[10:22:27.862]         if (TRUE) {
[10:22:27.862]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:27.862]         }
[10:22:27.862]         else {
[10:22:27.862]             ...future.result["stdout"] <- base::list(NULL)
[10:22:27.862]         }
[10:22:27.862]         base::close(...future.stdout)
[10:22:27.862]         ...future.stdout <- NULL
[10:22:27.862]     }
[10:22:27.862]     ...future.result$conditions <- ...future.conditions
[10:22:27.862]     ...future.result$finished <- base::Sys.time()
[10:22:27.862]     ...future.result
[10:22:27.862] }
[10:22:27.863] plan(): Setting new future strategy stack:
[10:22:27.864] List of future strategies:
[10:22:27.864] 1. sequential:
[10:22:27.864]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:27.864]    - tweaked: FALSE
[10:22:27.864]    - call: NULL
[10:22:27.864] plan(): nbrOfWorkers() = 1
[10:22:27.866] plan(): Setting new future strategy stack:
[10:22:27.866] List of future strategies:
[10:22:27.866] 1. sequential:
[10:22:27.866]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:27.866]    - tweaked: FALSE
[10:22:27.866]    - call: plan(strategy)
[10:22:27.867] plan(): nbrOfWorkers() = 1
[10:22:27.867] SequentialFuture started (and completed)
[10:22:27.867] - Launch lazy future ... done
[10:22:27.867] run() for ‘SequentialFuture’ ... done
[10:22:27.867] resolved() for ‘SequentialFuture’ ...
[10:22:27.867] - state: ‘finished’
[10:22:27.867] - run: TRUE
[10:22:27.867] - result: ‘FutureResult’
[10:22:27.867] resolved() for ‘SequentialFuture’ ... done
[10:22:27.867] Future #2
[10:22:27.868]  length: 1 (resolved future 2)
[10:22:27.868]  length: 0 (resolved future 3)
[10:22:27.868] resolve() on list ... DONE
[10:22:27.868] resolved() for ‘SequentialFuture’ ...
[10:22:27.868] - state: ‘finished’
[10:22:27.868] - run: TRUE
[10:22:27.868] - result: ‘FutureResult’
[10:22:27.868] resolved() for ‘SequentialFuture’ ... done
[10:22:27.868] resolved() for ‘SequentialFuture’ ...
[10:22:27.868] - state: ‘finished’
[10:22:27.868] - run: TRUE
[10:22:27.869] - result: ‘FutureResult’
[10:22:27.869] resolved() for ‘SequentialFuture’ ... done
[10:22:27.869] getGlobalsAndPackages() ...
[10:22:27.869] Searching for globals...
[10:22:27.869] 
[10:22:27.869] Searching for globals ... DONE
[10:22:27.869] - globals: [0] <none>
[10:22:27.869] getGlobalsAndPackages() ... DONE
[10:22:27.870] run() for ‘Future’ ...
[10:22:27.870] - state: ‘created’
[10:22:27.870] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:27.870] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:27.870] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:27.870]   - Field: ‘label’
[10:22:27.870]   - Field: ‘local’
[10:22:27.870]   - Field: ‘owner’
[10:22:27.870]   - Field: ‘envir’
[10:22:27.871]   - Field: ‘packages’
[10:22:27.871]   - Field: ‘gc’
[10:22:27.871]   - Field: ‘conditions’
[10:22:27.871]   - Field: ‘expr’
[10:22:27.871]   - Field: ‘uuid’
[10:22:27.871]   - Field: ‘seed’
[10:22:27.871]   - Field: ‘version’
[10:22:27.871]   - Field: ‘result’
[10:22:27.871]   - Field: ‘asynchronous’
[10:22:27.871]   - Field: ‘calls’
[10:22:27.871]   - Field: ‘globals’
[10:22:27.871]   - Field: ‘stdout’
[10:22:27.872]   - Field: ‘earlySignal’
[10:22:27.872]   - Field: ‘lazy’
[10:22:27.872]   - Field: ‘state’
[10:22:27.872] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:27.872] - Launch lazy future ...
[10:22:27.872] Packages needed by the future expression (n = 0): <none>
[10:22:27.872] Packages needed by future strategies (n = 0): <none>
[10:22:27.872] {
[10:22:27.872]     {
[10:22:27.872]         {
[10:22:27.872]             ...future.startTime <- base::Sys.time()
[10:22:27.872]             {
[10:22:27.872]                 {
[10:22:27.872]                   {
[10:22:27.872]                     base::local({
[10:22:27.872]                       has_future <- base::requireNamespace("future", 
[10:22:27.872]                         quietly = TRUE)
[10:22:27.872]                       if (has_future) {
[10:22:27.872]                         ns <- base::getNamespace("future")
[10:22:27.872]                         version <- ns[[".package"]][["version"]]
[10:22:27.872]                         if (is.null(version)) 
[10:22:27.872]                           version <- utils::packageVersion("future")
[10:22:27.872]                       }
[10:22:27.872]                       else {
[10:22:27.872]                         version <- NULL
[10:22:27.872]                       }
[10:22:27.872]                       if (!has_future || version < "1.8.0") {
[10:22:27.872]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:27.872]                           "", base::R.version$version.string), 
[10:22:27.872]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:27.872]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:27.872]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:27.872]                             "release", "version")], collapse = " "), 
[10:22:27.872]                           hostname = base::Sys.info()[["nodename"]])
[10:22:27.872]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:27.872]                           info)
[10:22:27.872]                         info <- base::paste(info, collapse = "; ")
[10:22:27.872]                         if (!has_future) {
[10:22:27.872]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:27.872]                             info)
[10:22:27.872]                         }
[10:22:27.872]                         else {
[10:22:27.872]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:27.872]                             info, version)
[10:22:27.872]                         }
[10:22:27.872]                         base::stop(msg)
[10:22:27.872]                       }
[10:22:27.872]                     })
[10:22:27.872]                   }
[10:22:27.872]                   ...future.strategy.old <- future::plan("list")
[10:22:27.872]                   options(future.plan = NULL)
[10:22:27.872]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:27.872]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:27.872]                 }
[10:22:27.872]                 ...future.workdir <- getwd()
[10:22:27.872]             }
[10:22:27.872]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:27.872]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:27.872]         }
[10:22:27.872]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:27.872]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:27.872]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:27.872]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:27.872]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:27.872]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:27.872]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:27.872]             base::names(...future.oldOptions))
[10:22:27.872]     }
[10:22:27.872]     if (FALSE) {
[10:22:27.872]     }
[10:22:27.872]     else {
[10:22:27.872]         if (TRUE) {
[10:22:27.872]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:27.872]                 open = "w")
[10:22:27.872]         }
[10:22:27.872]         else {
[10:22:27.872]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:27.872]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:27.872]         }
[10:22:27.872]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:27.872]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:27.872]             base::sink(type = "output", split = FALSE)
[10:22:27.872]             base::close(...future.stdout)
[10:22:27.872]         }, add = TRUE)
[10:22:27.872]     }
[10:22:27.872]     ...future.frame <- base::sys.nframe()
[10:22:27.872]     ...future.conditions <- base::list()
[10:22:27.872]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:27.872]     if (FALSE) {
[10:22:27.872]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:27.872]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:27.872]     }
[10:22:27.872]     ...future.result <- base::tryCatch({
[10:22:27.872]         base::withCallingHandlers({
[10:22:27.872]             ...future.value <- base::withVisible(base::local(1))
[10:22:27.872]             future::FutureResult(value = ...future.value$value, 
[10:22:27.872]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:27.872]                   ...future.rng), globalenv = if (FALSE) 
[10:22:27.872]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:27.872]                     ...future.globalenv.names))
[10:22:27.872]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:27.872]         }, condition = base::local({
[10:22:27.872]             c <- base::c
[10:22:27.872]             inherits <- base::inherits
[10:22:27.872]             invokeRestart <- base::invokeRestart
[10:22:27.872]             length <- base::length
[10:22:27.872]             list <- base::list
[10:22:27.872]             seq.int <- base::seq.int
[10:22:27.872]             signalCondition <- base::signalCondition
[10:22:27.872]             sys.calls <- base::sys.calls
[10:22:27.872]             `[[` <- base::`[[`
[10:22:27.872]             `+` <- base::`+`
[10:22:27.872]             `<<-` <- base::`<<-`
[10:22:27.872]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:27.872]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:27.872]                   3L)]
[10:22:27.872]             }
[10:22:27.872]             function(cond) {
[10:22:27.872]                 is_error <- inherits(cond, "error")
[10:22:27.872]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:27.872]                   NULL)
[10:22:27.872]                 if (is_error) {
[10:22:27.872]                   sessionInformation <- function() {
[10:22:27.872]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:27.872]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:27.872]                       search = base::search(), system = base::Sys.info())
[10:22:27.872]                   }
[10:22:27.872]                   ...future.conditions[[length(...future.conditions) + 
[10:22:27.872]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:27.872]                     cond$call), session = sessionInformation(), 
[10:22:27.872]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:27.872]                   signalCondition(cond)
[10:22:27.872]                 }
[10:22:27.872]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:27.872]                 "immediateCondition"))) {
[10:22:27.872]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:27.872]                   ...future.conditions[[length(...future.conditions) + 
[10:22:27.872]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:27.872]                   if (TRUE && !signal) {
[10:22:27.872]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:27.872]                     {
[10:22:27.872]                       inherits <- base::inherits
[10:22:27.872]                       invokeRestart <- base::invokeRestart
[10:22:27.872]                       is.null <- base::is.null
[10:22:27.872]                       muffled <- FALSE
[10:22:27.872]                       if (inherits(cond, "message")) {
[10:22:27.872]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:27.872]                         if (muffled) 
[10:22:27.872]                           invokeRestart("muffleMessage")
[10:22:27.872]                       }
[10:22:27.872]                       else if (inherits(cond, "warning")) {
[10:22:27.872]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:27.872]                         if (muffled) 
[10:22:27.872]                           invokeRestart("muffleWarning")
[10:22:27.872]                       }
[10:22:27.872]                       else if (inherits(cond, "condition")) {
[10:22:27.872]                         if (!is.null(pattern)) {
[10:22:27.872]                           computeRestarts <- base::computeRestarts
[10:22:27.872]                           grepl <- base::grepl
[10:22:27.872]                           restarts <- computeRestarts(cond)
[10:22:27.872]                           for (restart in restarts) {
[10:22:27.872]                             name <- restart$name
[10:22:27.872]                             if (is.null(name)) 
[10:22:27.872]                               next
[10:22:27.872]                             if (!grepl(pattern, name)) 
[10:22:27.872]                               next
[10:22:27.872]                             invokeRestart(restart)
[10:22:27.872]                             muffled <- TRUE
[10:22:27.872]                             break
[10:22:27.872]                           }
[10:22:27.872]                         }
[10:22:27.872]                       }
[10:22:27.872]                       invisible(muffled)
[10:22:27.872]                     }
[10:22:27.872]                     muffleCondition(cond, pattern = "^muffle")
[10:22:27.872]                   }
[10:22:27.872]                 }
[10:22:27.872]                 else {
[10:22:27.872]                   if (TRUE) {
[10:22:27.872]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:27.872]                     {
[10:22:27.872]                       inherits <- base::inherits
[10:22:27.872]                       invokeRestart <- base::invokeRestart
[10:22:27.872]                       is.null <- base::is.null
[10:22:27.872]                       muffled <- FALSE
[10:22:27.872]                       if (inherits(cond, "message")) {
[10:22:27.872]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:27.872]                         if (muffled) 
[10:22:27.872]                           invokeRestart("muffleMessage")
[10:22:27.872]                       }
[10:22:27.872]                       else if (inherits(cond, "warning")) {
[10:22:27.872]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:27.872]                         if (muffled) 
[10:22:27.872]                           invokeRestart("muffleWarning")
[10:22:27.872]                       }
[10:22:27.872]                       else if (inherits(cond, "condition")) {
[10:22:27.872]                         if (!is.null(pattern)) {
[10:22:27.872]                           computeRestarts <- base::computeRestarts
[10:22:27.872]                           grepl <- base::grepl
[10:22:27.872]                           restarts <- computeRestarts(cond)
[10:22:27.872]                           for (restart in restarts) {
[10:22:27.872]                             name <- restart$name
[10:22:27.872]                             if (is.null(name)) 
[10:22:27.872]                               next
[10:22:27.872]                             if (!grepl(pattern, name)) 
[10:22:27.872]                               next
[10:22:27.872]                             invokeRestart(restart)
[10:22:27.872]                             muffled <- TRUE
[10:22:27.872]                             break
[10:22:27.872]                           }
[10:22:27.872]                         }
[10:22:27.872]                       }
[10:22:27.872]                       invisible(muffled)
[10:22:27.872]                     }
[10:22:27.872]                     muffleCondition(cond, pattern = "^muffle")
[10:22:27.872]                   }
[10:22:27.872]                 }
[10:22:27.872]             }
[10:22:27.872]         }))
[10:22:27.872]     }, error = function(ex) {
[10:22:27.872]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:27.872]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:27.872]                 ...future.rng), started = ...future.startTime, 
[10:22:27.872]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:27.872]             version = "1.8"), class = "FutureResult")
[10:22:27.872]     }, finally = {
[10:22:27.872]         if (!identical(...future.workdir, getwd())) 
[10:22:27.872]             setwd(...future.workdir)
[10:22:27.872]         {
[10:22:27.872]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:27.872]                 ...future.oldOptions$nwarnings <- NULL
[10:22:27.872]             }
[10:22:27.872]             base::options(...future.oldOptions)
[10:22:27.872]             if (.Platform$OS.type == "windows") {
[10:22:27.872]                 old_names <- names(...future.oldEnvVars)
[10:22:27.872]                 envs <- base::Sys.getenv()
[10:22:27.872]                 names <- names(envs)
[10:22:27.872]                 common <- intersect(names, old_names)
[10:22:27.872]                 added <- setdiff(names, old_names)
[10:22:27.872]                 removed <- setdiff(old_names, names)
[10:22:27.872]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:27.872]                   envs[common]]
[10:22:27.872]                 NAMES <- toupper(changed)
[10:22:27.872]                 args <- list()
[10:22:27.872]                 for (kk in seq_along(NAMES)) {
[10:22:27.872]                   name <- changed[[kk]]
[10:22:27.872]                   NAME <- NAMES[[kk]]
[10:22:27.872]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:27.872]                     next
[10:22:27.872]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:27.872]                 }
[10:22:27.872]                 NAMES <- toupper(added)
[10:22:27.872]                 for (kk in seq_along(NAMES)) {
[10:22:27.872]                   name <- added[[kk]]
[10:22:27.872]                   NAME <- NAMES[[kk]]
[10:22:27.872]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:27.872]                     next
[10:22:27.872]                   args[[name]] <- ""
[10:22:27.872]                 }
[10:22:27.872]                 NAMES <- toupper(removed)
[10:22:27.872]                 for (kk in seq_along(NAMES)) {
[10:22:27.872]                   name <- removed[[kk]]
[10:22:27.872]                   NAME <- NAMES[[kk]]
[10:22:27.872]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:27.872]                     next
[10:22:27.872]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:27.872]                 }
[10:22:27.872]                 if (length(args) > 0) 
[10:22:27.872]                   base::do.call(base::Sys.setenv, args = args)
[10:22:27.872]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:27.872]             }
[10:22:27.872]             else {
[10:22:27.872]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:27.872]             }
[10:22:27.872]             {
[10:22:27.872]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:27.872]                   0L) {
[10:22:27.872]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:27.872]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:27.872]                   base::options(opts)
[10:22:27.872]                 }
[10:22:27.872]                 {
[10:22:27.872]                   {
[10:22:27.872]                     NULL
[10:22:27.872]                     RNGkind("Mersenne-Twister")
[10:22:27.872]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:27.872]                       inherits = FALSE)
[10:22:27.872]                   }
[10:22:27.872]                   options(future.plan = NULL)
[10:22:27.872]                   if (is.na(NA_character_)) 
[10:22:27.872]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:27.872]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:27.872]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:27.872]                     .init = FALSE)
[10:22:27.872]                 }
[10:22:27.872]             }
[10:22:27.872]         }
[10:22:27.872]     })
[10:22:27.872]     if (TRUE) {
[10:22:27.872]         base::sink(type = "output", split = FALSE)
[10:22:27.872]         if (TRUE) {
[10:22:27.872]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:27.872]         }
[10:22:27.872]         else {
[10:22:27.872]             ...future.result["stdout"] <- base::list(NULL)
[10:22:27.872]         }
[10:22:27.872]         base::close(...future.stdout)
[10:22:27.872]         ...future.stdout <- NULL
[10:22:27.872]     }
[10:22:27.872]     ...future.result$conditions <- ...future.conditions
[10:22:27.872]     ...future.result$finished <- base::Sys.time()
[10:22:27.872]     ...future.result
[10:22:27.872] }
[10:22:27.874] plan(): Setting new future strategy stack:
[10:22:27.874] List of future strategies:
[10:22:27.874] 1. sequential:
[10:22:27.874]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:27.874]    - tweaked: FALSE
[10:22:27.874]    - call: NULL
[10:22:27.875] plan(): nbrOfWorkers() = 1
[10:22:27.875] plan(): Setting new future strategy stack:
[10:22:27.875] List of future strategies:
[10:22:27.875] 1. sequential:
[10:22:27.875]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:27.875]    - tweaked: FALSE
[10:22:27.875]    - call: plan(strategy)
[10:22:27.876] plan(): nbrOfWorkers() = 1
[10:22:27.876] SequentialFuture started (and completed)
[10:22:27.876] - Launch lazy future ... done
[10:22:27.876] run() for ‘SequentialFuture’ ... done
[10:22:27.876] getGlobalsAndPackages() ...
[10:22:27.876] Searching for globals...
[10:22:27.881] - globals found: [2] ‘{’, ‘Sys.sleep’
[10:22:27.881] Searching for globals ... DONE
[10:22:27.881] Resolving globals: FALSE
[10:22:27.881] 
[10:22:27.881] 
[10:22:27.882] getGlobalsAndPackages() ... DONE
[10:22:27.882] run() for ‘Future’ ...
[10:22:27.882] - state: ‘created’
[10:22:27.882] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:27.882] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:27.882] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:27.882]   - Field: ‘label’
[10:22:27.882]   - Field: ‘local’
[10:22:27.883]   - Field: ‘owner’
[10:22:27.883]   - Field: ‘envir’
[10:22:27.883]   - Field: ‘packages’
[10:22:27.883]   - Field: ‘gc’
[10:22:27.883]   - Field: ‘conditions’
[10:22:27.883]   - Field: ‘expr’
[10:22:27.883]   - Field: ‘uuid’
[10:22:27.883]   - Field: ‘seed’
[10:22:27.883]   - Field: ‘version’
[10:22:27.883]   - Field: ‘result’
[10:22:27.883]   - Field: ‘asynchronous’
[10:22:27.883]   - Field: ‘calls’
[10:22:27.884]   - Field: ‘globals’
[10:22:27.884]   - Field: ‘stdout’
[10:22:27.884]   - Field: ‘earlySignal’
[10:22:27.884]   - Field: ‘lazy’
[10:22:27.884]   - Field: ‘state’
[10:22:27.884] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:27.884] - Launch lazy future ...
[10:22:27.884] Packages needed by the future expression (n = 0): <none>
[10:22:27.884] Packages needed by future strategies (n = 0): <none>
[10:22:27.885] {
[10:22:27.885]     {
[10:22:27.885]         {
[10:22:27.885]             ...future.startTime <- base::Sys.time()
[10:22:27.885]             {
[10:22:27.885]                 {
[10:22:27.885]                   {
[10:22:27.885]                     base::local({
[10:22:27.885]                       has_future <- base::requireNamespace("future", 
[10:22:27.885]                         quietly = TRUE)
[10:22:27.885]                       if (has_future) {
[10:22:27.885]                         ns <- base::getNamespace("future")
[10:22:27.885]                         version <- ns[[".package"]][["version"]]
[10:22:27.885]                         if (is.null(version)) 
[10:22:27.885]                           version <- utils::packageVersion("future")
[10:22:27.885]                       }
[10:22:27.885]                       else {
[10:22:27.885]                         version <- NULL
[10:22:27.885]                       }
[10:22:27.885]                       if (!has_future || version < "1.8.0") {
[10:22:27.885]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:27.885]                           "", base::R.version$version.string), 
[10:22:27.885]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:27.885]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:27.885]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:27.885]                             "release", "version")], collapse = " "), 
[10:22:27.885]                           hostname = base::Sys.info()[["nodename"]])
[10:22:27.885]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:27.885]                           info)
[10:22:27.885]                         info <- base::paste(info, collapse = "; ")
[10:22:27.885]                         if (!has_future) {
[10:22:27.885]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:27.885]                             info)
[10:22:27.885]                         }
[10:22:27.885]                         else {
[10:22:27.885]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:27.885]                             info, version)
[10:22:27.885]                         }
[10:22:27.885]                         base::stop(msg)
[10:22:27.885]                       }
[10:22:27.885]                     })
[10:22:27.885]                   }
[10:22:27.885]                   ...future.strategy.old <- future::plan("list")
[10:22:27.885]                   options(future.plan = NULL)
[10:22:27.885]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:27.885]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:27.885]                 }
[10:22:27.885]                 ...future.workdir <- getwd()
[10:22:27.885]             }
[10:22:27.885]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:27.885]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:27.885]         }
[10:22:27.885]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:27.885]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:27.885]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:27.885]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:27.885]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:27.885]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:27.885]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:27.885]             base::names(...future.oldOptions))
[10:22:27.885]     }
[10:22:27.885]     if (FALSE) {
[10:22:27.885]     }
[10:22:27.885]     else {
[10:22:27.885]         if (TRUE) {
[10:22:27.885]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:27.885]                 open = "w")
[10:22:27.885]         }
[10:22:27.885]         else {
[10:22:27.885]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:27.885]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:27.885]         }
[10:22:27.885]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:27.885]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:27.885]             base::sink(type = "output", split = FALSE)
[10:22:27.885]             base::close(...future.stdout)
[10:22:27.885]         }, add = TRUE)
[10:22:27.885]     }
[10:22:27.885]     ...future.frame <- base::sys.nframe()
[10:22:27.885]     ...future.conditions <- base::list()
[10:22:27.885]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:27.885]     if (FALSE) {
[10:22:27.885]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:27.885]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:27.885]     }
[10:22:27.885]     ...future.result <- base::tryCatch({
[10:22:27.885]         base::withCallingHandlers({
[10:22:27.885]             ...future.value <- base::withVisible(base::local({
[10:22:27.885]                 Sys.sleep(0.5)
[10:22:27.885]                 2
[10:22:27.885]             }))
[10:22:27.885]             future::FutureResult(value = ...future.value$value, 
[10:22:27.885]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:27.885]                   ...future.rng), globalenv = if (FALSE) 
[10:22:27.885]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:27.885]                     ...future.globalenv.names))
[10:22:27.885]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:27.885]         }, condition = base::local({
[10:22:27.885]             c <- base::c
[10:22:27.885]             inherits <- base::inherits
[10:22:27.885]             invokeRestart <- base::invokeRestart
[10:22:27.885]             length <- base::length
[10:22:27.885]             list <- base::list
[10:22:27.885]             seq.int <- base::seq.int
[10:22:27.885]             signalCondition <- base::signalCondition
[10:22:27.885]             sys.calls <- base::sys.calls
[10:22:27.885]             `[[` <- base::`[[`
[10:22:27.885]             `+` <- base::`+`
[10:22:27.885]             `<<-` <- base::`<<-`
[10:22:27.885]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:27.885]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:27.885]                   3L)]
[10:22:27.885]             }
[10:22:27.885]             function(cond) {
[10:22:27.885]                 is_error <- inherits(cond, "error")
[10:22:27.885]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:27.885]                   NULL)
[10:22:27.885]                 if (is_error) {
[10:22:27.885]                   sessionInformation <- function() {
[10:22:27.885]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:27.885]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:27.885]                       search = base::search(), system = base::Sys.info())
[10:22:27.885]                   }
[10:22:27.885]                   ...future.conditions[[length(...future.conditions) + 
[10:22:27.885]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:27.885]                     cond$call), session = sessionInformation(), 
[10:22:27.885]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:27.885]                   signalCondition(cond)
[10:22:27.885]                 }
[10:22:27.885]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:27.885]                 "immediateCondition"))) {
[10:22:27.885]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:27.885]                   ...future.conditions[[length(...future.conditions) + 
[10:22:27.885]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:27.885]                   if (TRUE && !signal) {
[10:22:27.885]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:27.885]                     {
[10:22:27.885]                       inherits <- base::inherits
[10:22:27.885]                       invokeRestart <- base::invokeRestart
[10:22:27.885]                       is.null <- base::is.null
[10:22:27.885]                       muffled <- FALSE
[10:22:27.885]                       if (inherits(cond, "message")) {
[10:22:27.885]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:27.885]                         if (muffled) 
[10:22:27.885]                           invokeRestart("muffleMessage")
[10:22:27.885]                       }
[10:22:27.885]                       else if (inherits(cond, "warning")) {
[10:22:27.885]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:27.885]                         if (muffled) 
[10:22:27.885]                           invokeRestart("muffleWarning")
[10:22:27.885]                       }
[10:22:27.885]                       else if (inherits(cond, "condition")) {
[10:22:27.885]                         if (!is.null(pattern)) {
[10:22:27.885]                           computeRestarts <- base::computeRestarts
[10:22:27.885]                           grepl <- base::grepl
[10:22:27.885]                           restarts <- computeRestarts(cond)
[10:22:27.885]                           for (restart in restarts) {
[10:22:27.885]                             name <- restart$name
[10:22:27.885]                             if (is.null(name)) 
[10:22:27.885]                               next
[10:22:27.885]                             if (!grepl(pattern, name)) 
[10:22:27.885]                               next
[10:22:27.885]                             invokeRestart(restart)
[10:22:27.885]                             muffled <- TRUE
[10:22:27.885]                             break
[10:22:27.885]                           }
[10:22:27.885]                         }
[10:22:27.885]                       }
[10:22:27.885]                       invisible(muffled)
[10:22:27.885]                     }
[10:22:27.885]                     muffleCondition(cond, pattern = "^muffle")
[10:22:27.885]                   }
[10:22:27.885]                 }
[10:22:27.885]                 else {
[10:22:27.885]                   if (TRUE) {
[10:22:27.885]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:27.885]                     {
[10:22:27.885]                       inherits <- base::inherits
[10:22:27.885]                       invokeRestart <- base::invokeRestart
[10:22:27.885]                       is.null <- base::is.null
[10:22:27.885]                       muffled <- FALSE
[10:22:27.885]                       if (inherits(cond, "message")) {
[10:22:27.885]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:27.885]                         if (muffled) 
[10:22:27.885]                           invokeRestart("muffleMessage")
[10:22:27.885]                       }
[10:22:27.885]                       else if (inherits(cond, "warning")) {
[10:22:27.885]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:27.885]                         if (muffled) 
[10:22:27.885]                           invokeRestart("muffleWarning")
[10:22:27.885]                       }
[10:22:27.885]                       else if (inherits(cond, "condition")) {
[10:22:27.885]                         if (!is.null(pattern)) {
[10:22:27.885]                           computeRestarts <- base::computeRestarts
[10:22:27.885]                           grepl <- base::grepl
[10:22:27.885]                           restarts <- computeRestarts(cond)
[10:22:27.885]                           for (restart in restarts) {
[10:22:27.885]                             name <- restart$name
[10:22:27.885]                             if (is.null(name)) 
[10:22:27.885]                               next
[10:22:27.885]                             if (!grepl(pattern, name)) 
[10:22:27.885]                               next
[10:22:27.885]                             invokeRestart(restart)
[10:22:27.885]                             muffled <- TRUE
[10:22:27.885]                             break
[10:22:27.885]                           }
[10:22:27.885]                         }
[10:22:27.885]                       }
[10:22:27.885]                       invisible(muffled)
[10:22:27.885]                     }
[10:22:27.885]                     muffleCondition(cond, pattern = "^muffle")
[10:22:27.885]                   }
[10:22:27.885]                 }
[10:22:27.885]             }
[10:22:27.885]         }))
[10:22:27.885]     }, error = function(ex) {
[10:22:27.885]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:27.885]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:27.885]                 ...future.rng), started = ...future.startTime, 
[10:22:27.885]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:27.885]             version = "1.8"), class = "FutureResult")
[10:22:27.885]     }, finally = {
[10:22:27.885]         if (!identical(...future.workdir, getwd())) 
[10:22:27.885]             setwd(...future.workdir)
[10:22:27.885]         {
[10:22:27.885]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:27.885]                 ...future.oldOptions$nwarnings <- NULL
[10:22:27.885]             }
[10:22:27.885]             base::options(...future.oldOptions)
[10:22:27.885]             if (.Platform$OS.type == "windows") {
[10:22:27.885]                 old_names <- names(...future.oldEnvVars)
[10:22:27.885]                 envs <- base::Sys.getenv()
[10:22:27.885]                 names <- names(envs)
[10:22:27.885]                 common <- intersect(names, old_names)
[10:22:27.885]                 added <- setdiff(names, old_names)
[10:22:27.885]                 removed <- setdiff(old_names, names)
[10:22:27.885]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:27.885]                   envs[common]]
[10:22:27.885]                 NAMES <- toupper(changed)
[10:22:27.885]                 args <- list()
[10:22:27.885]                 for (kk in seq_along(NAMES)) {
[10:22:27.885]                   name <- changed[[kk]]
[10:22:27.885]                   NAME <- NAMES[[kk]]
[10:22:27.885]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:27.885]                     next
[10:22:27.885]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:27.885]                 }
[10:22:27.885]                 NAMES <- toupper(added)
[10:22:27.885]                 for (kk in seq_along(NAMES)) {
[10:22:27.885]                   name <- added[[kk]]
[10:22:27.885]                   NAME <- NAMES[[kk]]
[10:22:27.885]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:27.885]                     next
[10:22:27.885]                   args[[name]] <- ""
[10:22:27.885]                 }
[10:22:27.885]                 NAMES <- toupper(removed)
[10:22:27.885]                 for (kk in seq_along(NAMES)) {
[10:22:27.885]                   name <- removed[[kk]]
[10:22:27.885]                   NAME <- NAMES[[kk]]
[10:22:27.885]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:27.885]                     next
[10:22:27.885]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:27.885]                 }
[10:22:27.885]                 if (length(args) > 0) 
[10:22:27.885]                   base::do.call(base::Sys.setenv, args = args)
[10:22:27.885]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:27.885]             }
[10:22:27.885]             else {
[10:22:27.885]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:27.885]             }
[10:22:27.885]             {
[10:22:27.885]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:27.885]                   0L) {
[10:22:27.885]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:27.885]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:27.885]                   base::options(opts)
[10:22:27.885]                 }
[10:22:27.885]                 {
[10:22:27.885]                   {
[10:22:27.885]                     NULL
[10:22:27.885]                     RNGkind("Mersenne-Twister")
[10:22:27.885]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:27.885]                       inherits = FALSE)
[10:22:27.885]                   }
[10:22:27.885]                   options(future.plan = NULL)
[10:22:27.885]                   if (is.na(NA_character_)) 
[10:22:27.885]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:27.885]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:27.885]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:27.885]                     .init = FALSE)
[10:22:27.885]                 }
[10:22:27.885]             }
[10:22:27.885]         }
[10:22:27.885]     })
[10:22:27.885]     if (TRUE) {
[10:22:27.885]         base::sink(type = "output", split = FALSE)
[10:22:27.885]         if (TRUE) {
[10:22:27.885]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:27.885]         }
[10:22:27.885]         else {
[10:22:27.885]             ...future.result["stdout"] <- base::list(NULL)
[10:22:27.885]         }
[10:22:27.885]         base::close(...future.stdout)
[10:22:27.885]         ...future.stdout <- NULL
[10:22:27.885]     }
[10:22:27.885]     ...future.result$conditions <- ...future.conditions
[10:22:27.885]     ...future.result$finished <- base::Sys.time()
[10:22:27.885]     ...future.result
[10:22:27.885] }
[10:22:27.886] plan(): Setting new future strategy stack:
[10:22:27.887] List of future strategies:
[10:22:27.887] 1. sequential:
[10:22:27.887]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:27.887]    - tweaked: FALSE
[10:22:27.887]    - call: NULL
[10:22:27.887] plan(): nbrOfWorkers() = 1
[10:22:28.389] plan(): Setting new future strategy stack:
[10:22:28.389] List of future strategies:
[10:22:28.389] 1. sequential:
[10:22:28.389]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:28.389]    - tweaked: FALSE
[10:22:28.389]    - call: plan(strategy)
[10:22:28.389] plan(): nbrOfWorkers() = 1
[10:22:28.390] SequentialFuture started (and completed)
[10:22:28.390] - Launch lazy future ... done
[10:22:28.390] run() for ‘SequentialFuture’ ... done
[10:22:28.390] resolve() on list ...
[10:22:28.390]  recursive: 0
[10:22:28.391]  length: 1
[10:22:28.391] 
[10:22:28.391] resolved() for ‘SequentialFuture’ ...
[10:22:28.391] - state: ‘finished’
[10:22:28.391] - run: TRUE
[10:22:28.391] - result: ‘FutureResult’
[10:22:28.391] resolved() for ‘SequentialFuture’ ... done
[10:22:28.391] Future #1
[10:22:28.391]  length: 0 (resolved future 1)
[10:22:28.391] resolve() on list ... DONE
[10:22:28.391] resolved() for ‘SequentialFuture’ ...
[10:22:28.392] - state: ‘finished’
[10:22:28.392] - run: TRUE
[10:22:28.392] - result: ‘FutureResult’
[10:22:28.392] resolved() for ‘SequentialFuture’ ... done
[10:22:28.392] resolve() on list ...
[10:22:28.392]  recursive: 0
[10:22:28.392]  length: 1
[10:22:28.392] 
[10:22:28.392] resolved() for ‘SequentialFuture’ ...
[10:22:28.392] - state: ‘finished’
[10:22:28.393] - run: TRUE
[10:22:28.393] - result: ‘FutureResult’
[10:22:28.393] resolved() for ‘SequentialFuture’ ... done
[10:22:28.393] Future #1
[10:22:28.393]  length: 0 (resolved future 1)
[10:22:28.393] resolve() on list ... DONE
[10:22:28.393] resolved() for ‘SequentialFuture’ ...
[10:22:28.393] - state: ‘finished’
[10:22:28.393] - run: TRUE
[10:22:28.393] - result: ‘FutureResult’
[10:22:28.393] resolved() for ‘SequentialFuture’ ... done
[10:22:28.394] resolve() on list ...
[10:22:28.394]  recursive: 0
[10:22:28.394]  length: 1
[10:22:28.394] 
[10:22:28.394]  length: 0 (resolved future 1)
[10:22:28.394] resolve() on list ... DONE
[10:22:28.394] resolve() on list ...
[10:22:28.394]  recursive: 0
[10:22:28.394]  length: 4
[10:22:28.394] 
[10:22:28.394] resolved() for ‘SequentialFuture’ ...
[10:22:28.395] - state: ‘finished’
[10:22:28.395] - run: TRUE
[10:22:28.395] - result: ‘FutureResult’
[10:22:28.395] resolved() for ‘SequentialFuture’ ... done
[10:22:28.395] Future #1
[10:22:28.395]  length: 3 (resolved future 1)
[10:22:28.395] resolved() for ‘SequentialFuture’ ...
[10:22:28.395] - state: ‘finished’
[10:22:28.395] - run: TRUE
[10:22:28.395] - result: ‘FutureResult’
[10:22:28.395] resolved() for ‘SequentialFuture’ ... done
[10:22:28.396] Future #2
[10:22:28.398]  length: 2 (resolved future 2)
[10:22:28.398]  length: 1 (resolved future 3)
[10:22:28.398]  length: 0 (resolved future 4)
[10:22:28.398] resolve() on list ... DONE
[10:22:28.398] resolve() on list ...
[10:22:28.398]  recursive: 0
[10:22:28.399]  length: 4
[10:22:28.399] 
[10:22:28.399] resolved() for ‘SequentialFuture’ ...
[10:22:28.399] - state: ‘finished’
[10:22:28.399] - run: TRUE
[10:22:28.399] - result: ‘FutureResult’
[10:22:28.399] resolved() for ‘SequentialFuture’ ... done
[10:22:28.399] Future #1
[10:22:28.399]  length: 3 (resolved future 1)
[10:22:28.399] resolved() for ‘SequentialFuture’ ...
[10:22:28.399] - state: ‘finished’
[10:22:28.400] - run: TRUE
[10:22:28.400] - result: ‘FutureResult’
[10:22:28.400] resolved() for ‘SequentialFuture’ ... done
[10:22:28.400] Future #2
[10:22:28.400]  length: 2 (resolved future 2)
[10:22:28.400]  length: 1 (resolved future 3)
[10:22:28.400]  length: 0 (resolved future 4)
[10:22:28.400] resolve() on list ... DONE
[10:22:28.400] resolve() on list ...
[10:22:28.401]  recursive: 0
[10:22:28.401]  length: 1
[10:22:28.401] 
[10:22:28.401]  length: 0 (resolved future 1)
[10:22:28.401] resolve() on list ... DONE
[10:22:28.401] getGlobalsAndPackages() ...
[10:22:28.401] Searching for globals...
[10:22:28.402] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:22:28.402] Searching for globals ... DONE
[10:22:28.402] Resolving globals: FALSE
[10:22:28.403] The total size of the 1 globals is 35 bytes (35 bytes)
[10:22:28.404] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[10:22:28.404] - globals: [1] ‘kk’
[10:22:28.404] 
[10:22:28.404] getGlobalsAndPackages() ... DONE
[10:22:28.404] run() for ‘Future’ ...
[10:22:28.404] - state: ‘created’
[10:22:28.404] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:28.405] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:28.405] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:28.405]   - Field: ‘label’
[10:22:28.405]   - Field: ‘local’
[10:22:28.405]   - Field: ‘owner’
[10:22:28.405]   - Field: ‘envir’
[10:22:28.405]   - Field: ‘packages’
[10:22:28.405]   - Field: ‘gc’
[10:22:28.405]   - Field: ‘conditions’
[10:22:28.405]   - Field: ‘expr’
[10:22:28.406]   - Field: ‘uuid’
[10:22:28.406]   - Field: ‘seed’
[10:22:28.406]   - Field: ‘version’
[10:22:28.406]   - Field: ‘result’
[10:22:28.406]   - Field: ‘asynchronous’
[10:22:28.406]   - Field: ‘calls’
[10:22:28.406]   - Field: ‘globals’
[10:22:28.406]   - Field: ‘stdout’
[10:22:28.406]   - Field: ‘earlySignal’
[10:22:28.406]   - Field: ‘lazy’
[10:22:28.406]   - Field: ‘state’
[10:22:28.406] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:28.407] - Launch lazy future ...
[10:22:28.407] Packages needed by the future expression (n = 0): <none>
[10:22:28.407] Packages needed by future strategies (n = 0): <none>
[10:22:28.407] {
[10:22:28.407]     {
[10:22:28.407]         {
[10:22:28.407]             ...future.startTime <- base::Sys.time()
[10:22:28.407]             {
[10:22:28.407]                 {
[10:22:28.407]                   {
[10:22:28.407]                     base::local({
[10:22:28.407]                       has_future <- base::requireNamespace("future", 
[10:22:28.407]                         quietly = TRUE)
[10:22:28.407]                       if (has_future) {
[10:22:28.407]                         ns <- base::getNamespace("future")
[10:22:28.407]                         version <- ns[[".package"]][["version"]]
[10:22:28.407]                         if (is.null(version)) 
[10:22:28.407]                           version <- utils::packageVersion("future")
[10:22:28.407]                       }
[10:22:28.407]                       else {
[10:22:28.407]                         version <- NULL
[10:22:28.407]                       }
[10:22:28.407]                       if (!has_future || version < "1.8.0") {
[10:22:28.407]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:28.407]                           "", base::R.version$version.string), 
[10:22:28.407]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:28.407]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:28.407]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:28.407]                             "release", "version")], collapse = " "), 
[10:22:28.407]                           hostname = base::Sys.info()[["nodename"]])
[10:22:28.407]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:28.407]                           info)
[10:22:28.407]                         info <- base::paste(info, collapse = "; ")
[10:22:28.407]                         if (!has_future) {
[10:22:28.407]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:28.407]                             info)
[10:22:28.407]                         }
[10:22:28.407]                         else {
[10:22:28.407]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:28.407]                             info, version)
[10:22:28.407]                         }
[10:22:28.407]                         base::stop(msg)
[10:22:28.407]                       }
[10:22:28.407]                     })
[10:22:28.407]                   }
[10:22:28.407]                   ...future.strategy.old <- future::plan("list")
[10:22:28.407]                   options(future.plan = NULL)
[10:22:28.407]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:28.407]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:28.407]                 }
[10:22:28.407]                 ...future.workdir <- getwd()
[10:22:28.407]             }
[10:22:28.407]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:28.407]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:28.407]         }
[10:22:28.407]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:28.407]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:28.407]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:28.407]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:28.407]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:28.407]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:28.407]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:28.407]             base::names(...future.oldOptions))
[10:22:28.407]     }
[10:22:28.407]     if (FALSE) {
[10:22:28.407]     }
[10:22:28.407]     else {
[10:22:28.407]         if (TRUE) {
[10:22:28.407]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:28.407]                 open = "w")
[10:22:28.407]         }
[10:22:28.407]         else {
[10:22:28.407]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:28.407]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:28.407]         }
[10:22:28.407]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:28.407]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:28.407]             base::sink(type = "output", split = FALSE)
[10:22:28.407]             base::close(...future.stdout)
[10:22:28.407]         }, add = TRUE)
[10:22:28.407]     }
[10:22:28.407]     ...future.frame <- base::sys.nframe()
[10:22:28.407]     ...future.conditions <- base::list()
[10:22:28.407]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:28.407]     if (FALSE) {
[10:22:28.407]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:28.407]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:28.407]     }
[10:22:28.407]     ...future.result <- base::tryCatch({
[10:22:28.407]         base::withCallingHandlers({
[10:22:28.407]             ...future.value <- base::withVisible(base::local({
[10:22:28.407]                 Sys.sleep(0.1)
[10:22:28.407]                 kk
[10:22:28.407]             }))
[10:22:28.407]             future::FutureResult(value = ...future.value$value, 
[10:22:28.407]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:28.407]                   ...future.rng), globalenv = if (FALSE) 
[10:22:28.407]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:28.407]                     ...future.globalenv.names))
[10:22:28.407]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:28.407]         }, condition = base::local({
[10:22:28.407]             c <- base::c
[10:22:28.407]             inherits <- base::inherits
[10:22:28.407]             invokeRestart <- base::invokeRestart
[10:22:28.407]             length <- base::length
[10:22:28.407]             list <- base::list
[10:22:28.407]             seq.int <- base::seq.int
[10:22:28.407]             signalCondition <- base::signalCondition
[10:22:28.407]             sys.calls <- base::sys.calls
[10:22:28.407]             `[[` <- base::`[[`
[10:22:28.407]             `+` <- base::`+`
[10:22:28.407]             `<<-` <- base::`<<-`
[10:22:28.407]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:28.407]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:28.407]                   3L)]
[10:22:28.407]             }
[10:22:28.407]             function(cond) {
[10:22:28.407]                 is_error <- inherits(cond, "error")
[10:22:28.407]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:28.407]                   NULL)
[10:22:28.407]                 if (is_error) {
[10:22:28.407]                   sessionInformation <- function() {
[10:22:28.407]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:28.407]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:28.407]                       search = base::search(), system = base::Sys.info())
[10:22:28.407]                   }
[10:22:28.407]                   ...future.conditions[[length(...future.conditions) + 
[10:22:28.407]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:28.407]                     cond$call), session = sessionInformation(), 
[10:22:28.407]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:28.407]                   signalCondition(cond)
[10:22:28.407]                 }
[10:22:28.407]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:28.407]                 "immediateCondition"))) {
[10:22:28.407]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:28.407]                   ...future.conditions[[length(...future.conditions) + 
[10:22:28.407]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:28.407]                   if (TRUE && !signal) {
[10:22:28.407]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:28.407]                     {
[10:22:28.407]                       inherits <- base::inherits
[10:22:28.407]                       invokeRestart <- base::invokeRestart
[10:22:28.407]                       is.null <- base::is.null
[10:22:28.407]                       muffled <- FALSE
[10:22:28.407]                       if (inherits(cond, "message")) {
[10:22:28.407]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:28.407]                         if (muffled) 
[10:22:28.407]                           invokeRestart("muffleMessage")
[10:22:28.407]                       }
[10:22:28.407]                       else if (inherits(cond, "warning")) {
[10:22:28.407]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:28.407]                         if (muffled) 
[10:22:28.407]                           invokeRestart("muffleWarning")
[10:22:28.407]                       }
[10:22:28.407]                       else if (inherits(cond, "condition")) {
[10:22:28.407]                         if (!is.null(pattern)) {
[10:22:28.407]                           computeRestarts <- base::computeRestarts
[10:22:28.407]                           grepl <- base::grepl
[10:22:28.407]                           restarts <- computeRestarts(cond)
[10:22:28.407]                           for (restart in restarts) {
[10:22:28.407]                             name <- restart$name
[10:22:28.407]                             if (is.null(name)) 
[10:22:28.407]                               next
[10:22:28.407]                             if (!grepl(pattern, name)) 
[10:22:28.407]                               next
[10:22:28.407]                             invokeRestart(restart)
[10:22:28.407]                             muffled <- TRUE
[10:22:28.407]                             break
[10:22:28.407]                           }
[10:22:28.407]                         }
[10:22:28.407]                       }
[10:22:28.407]                       invisible(muffled)
[10:22:28.407]                     }
[10:22:28.407]                     muffleCondition(cond, pattern = "^muffle")
[10:22:28.407]                   }
[10:22:28.407]                 }
[10:22:28.407]                 else {
[10:22:28.407]                   if (TRUE) {
[10:22:28.407]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:28.407]                     {
[10:22:28.407]                       inherits <- base::inherits
[10:22:28.407]                       invokeRestart <- base::invokeRestart
[10:22:28.407]                       is.null <- base::is.null
[10:22:28.407]                       muffled <- FALSE
[10:22:28.407]                       if (inherits(cond, "message")) {
[10:22:28.407]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:28.407]                         if (muffled) 
[10:22:28.407]                           invokeRestart("muffleMessage")
[10:22:28.407]                       }
[10:22:28.407]                       else if (inherits(cond, "warning")) {
[10:22:28.407]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:28.407]                         if (muffled) 
[10:22:28.407]                           invokeRestart("muffleWarning")
[10:22:28.407]                       }
[10:22:28.407]                       else if (inherits(cond, "condition")) {
[10:22:28.407]                         if (!is.null(pattern)) {
[10:22:28.407]                           computeRestarts <- base::computeRestarts
[10:22:28.407]                           grepl <- base::grepl
[10:22:28.407]                           restarts <- computeRestarts(cond)
[10:22:28.407]                           for (restart in restarts) {
[10:22:28.407]                             name <- restart$name
[10:22:28.407]                             if (is.null(name)) 
[10:22:28.407]                               next
[10:22:28.407]                             if (!grepl(pattern, name)) 
[10:22:28.407]                               next
[10:22:28.407]                             invokeRestart(restart)
[10:22:28.407]                             muffled <- TRUE
[10:22:28.407]                             break
[10:22:28.407]                           }
[10:22:28.407]                         }
[10:22:28.407]                       }
[10:22:28.407]                       invisible(muffled)
[10:22:28.407]                     }
[10:22:28.407]                     muffleCondition(cond, pattern = "^muffle")
[10:22:28.407]                   }
[10:22:28.407]                 }
[10:22:28.407]             }
[10:22:28.407]         }))
[10:22:28.407]     }, error = function(ex) {
[10:22:28.407]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:28.407]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:28.407]                 ...future.rng), started = ...future.startTime, 
[10:22:28.407]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:28.407]             version = "1.8"), class = "FutureResult")
[10:22:28.407]     }, finally = {
[10:22:28.407]         if (!identical(...future.workdir, getwd())) 
[10:22:28.407]             setwd(...future.workdir)
[10:22:28.407]         {
[10:22:28.407]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:28.407]                 ...future.oldOptions$nwarnings <- NULL
[10:22:28.407]             }
[10:22:28.407]             base::options(...future.oldOptions)
[10:22:28.407]             if (.Platform$OS.type == "windows") {
[10:22:28.407]                 old_names <- names(...future.oldEnvVars)
[10:22:28.407]                 envs <- base::Sys.getenv()
[10:22:28.407]                 names <- names(envs)
[10:22:28.407]                 common <- intersect(names, old_names)
[10:22:28.407]                 added <- setdiff(names, old_names)
[10:22:28.407]                 removed <- setdiff(old_names, names)
[10:22:28.407]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:28.407]                   envs[common]]
[10:22:28.407]                 NAMES <- toupper(changed)
[10:22:28.407]                 args <- list()
[10:22:28.407]                 for (kk in seq_along(NAMES)) {
[10:22:28.407]                   name <- changed[[kk]]
[10:22:28.407]                   NAME <- NAMES[[kk]]
[10:22:28.407]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:28.407]                     next
[10:22:28.407]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:28.407]                 }
[10:22:28.407]                 NAMES <- toupper(added)
[10:22:28.407]                 for (kk in seq_along(NAMES)) {
[10:22:28.407]                   name <- added[[kk]]
[10:22:28.407]                   NAME <- NAMES[[kk]]
[10:22:28.407]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:28.407]                     next
[10:22:28.407]                   args[[name]] <- ""
[10:22:28.407]                 }
[10:22:28.407]                 NAMES <- toupper(removed)
[10:22:28.407]                 for (kk in seq_along(NAMES)) {
[10:22:28.407]                   name <- removed[[kk]]
[10:22:28.407]                   NAME <- NAMES[[kk]]
[10:22:28.407]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:28.407]                     next
[10:22:28.407]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:28.407]                 }
[10:22:28.407]                 if (length(args) > 0) 
[10:22:28.407]                   base::do.call(base::Sys.setenv, args = args)
[10:22:28.407]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:28.407]             }
[10:22:28.407]             else {
[10:22:28.407]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:28.407]             }
[10:22:28.407]             {
[10:22:28.407]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:28.407]                   0L) {
[10:22:28.407]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:28.407]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:28.407]                   base::options(opts)
[10:22:28.407]                 }
[10:22:28.407]                 {
[10:22:28.407]                   {
[10:22:28.407]                     NULL
[10:22:28.407]                     RNGkind("Mersenne-Twister")
[10:22:28.407]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:28.407]                       inherits = FALSE)
[10:22:28.407]                   }
[10:22:28.407]                   options(future.plan = NULL)
[10:22:28.407]                   if (is.na(NA_character_)) 
[10:22:28.407]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:28.407]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:28.407]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:28.407]                     .init = FALSE)
[10:22:28.407]                 }
[10:22:28.407]             }
[10:22:28.407]         }
[10:22:28.407]     })
[10:22:28.407]     if (TRUE) {
[10:22:28.407]         base::sink(type = "output", split = FALSE)
[10:22:28.407]         if (TRUE) {
[10:22:28.407]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:28.407]         }
[10:22:28.407]         else {
[10:22:28.407]             ...future.result["stdout"] <- base::list(NULL)
[10:22:28.407]         }
[10:22:28.407]         base::close(...future.stdout)
[10:22:28.407]         ...future.stdout <- NULL
[10:22:28.407]     }
[10:22:28.407]     ...future.result$conditions <- ...future.conditions
[10:22:28.407]     ...future.result$finished <- base::Sys.time()
[10:22:28.407]     ...future.result
[10:22:28.407] }
[10:22:28.409] assign_globals() ...
[10:22:28.409] List of 1
[10:22:28.409]  $ kk: int 1
[10:22:28.409]  - attr(*, "where")=List of 1
[10:22:28.409]   ..$ kk:<environment: R_EmptyEnv> 
[10:22:28.409]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:28.409]  - attr(*, "resolved")= logi FALSE
[10:22:28.409]  - attr(*, "total_size")= num 35
[10:22:28.409]  - attr(*, "already-done")= logi TRUE
[10:22:28.414] - copied ‘kk’ to environment
[10:22:28.414] assign_globals() ... done
[10:22:28.414] plan(): Setting new future strategy stack:
[10:22:28.414] List of future strategies:
[10:22:28.414] 1. sequential:
[10:22:28.414]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:28.414]    - tweaked: FALSE
[10:22:28.414]    - call: NULL
[10:22:28.414] plan(): nbrOfWorkers() = 1
[10:22:28.516] plan(): Setting new future strategy stack:
[10:22:28.516] List of future strategies:
[10:22:28.516] 1. sequential:
[10:22:28.516]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:28.516]    - tweaked: FALSE
[10:22:28.516]    - call: plan(strategy)
[10:22:28.516] plan(): nbrOfWorkers() = 1
[10:22:28.516] SequentialFuture started (and completed)
[10:22:28.517] - Launch lazy future ... done
[10:22:28.517] run() for ‘SequentialFuture’ ... done
[10:22:28.517] getGlobalsAndPackages() ...
[10:22:28.517] Searching for globals...
[10:22:28.518] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:22:28.518] Searching for globals ... DONE
[10:22:28.518] Resolving globals: FALSE
[10:22:28.518] The total size of the 1 globals is 35 bytes (35 bytes)
[10:22:28.519] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[10:22:28.519] - globals: [1] ‘kk’
[10:22:28.519] 
[10:22:28.519] getGlobalsAndPackages() ... DONE
[10:22:28.519] run() for ‘Future’ ...
[10:22:28.519] - state: ‘created’
[10:22:28.520] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:28.520] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:28.520] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:28.520]   - Field: ‘label’
[10:22:28.520]   - Field: ‘local’
[10:22:28.520]   - Field: ‘owner’
[10:22:28.520]   - Field: ‘envir’
[10:22:28.520]   - Field: ‘packages’
[10:22:28.520]   - Field: ‘gc’
[10:22:28.521]   - Field: ‘conditions’
[10:22:28.521]   - Field: ‘expr’
[10:22:28.521]   - Field: ‘uuid’
[10:22:28.521]   - Field: ‘seed’
[10:22:28.521]   - Field: ‘version’
[10:22:28.521]   - Field: ‘result’
[10:22:28.521]   - Field: ‘asynchronous’
[10:22:28.521]   - Field: ‘calls’
[10:22:28.521]   - Field: ‘globals’
[10:22:28.521]   - Field: ‘stdout’
[10:22:28.521]   - Field: ‘earlySignal’
[10:22:28.521]   - Field: ‘lazy’
[10:22:28.522]   - Field: ‘state’
[10:22:28.522] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:28.522] - Launch lazy future ...
[10:22:28.522] Packages needed by the future expression (n = 0): <none>
[10:22:28.522] Packages needed by future strategies (n = 0): <none>
[10:22:28.522] {
[10:22:28.522]     {
[10:22:28.522]         {
[10:22:28.522]             ...future.startTime <- base::Sys.time()
[10:22:28.522]             {
[10:22:28.522]                 {
[10:22:28.522]                   {
[10:22:28.522]                     base::local({
[10:22:28.522]                       has_future <- base::requireNamespace("future", 
[10:22:28.522]                         quietly = TRUE)
[10:22:28.522]                       if (has_future) {
[10:22:28.522]                         ns <- base::getNamespace("future")
[10:22:28.522]                         version <- ns[[".package"]][["version"]]
[10:22:28.522]                         if (is.null(version)) 
[10:22:28.522]                           version <- utils::packageVersion("future")
[10:22:28.522]                       }
[10:22:28.522]                       else {
[10:22:28.522]                         version <- NULL
[10:22:28.522]                       }
[10:22:28.522]                       if (!has_future || version < "1.8.0") {
[10:22:28.522]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:28.522]                           "", base::R.version$version.string), 
[10:22:28.522]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:28.522]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:28.522]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:28.522]                             "release", "version")], collapse = " "), 
[10:22:28.522]                           hostname = base::Sys.info()[["nodename"]])
[10:22:28.522]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:28.522]                           info)
[10:22:28.522]                         info <- base::paste(info, collapse = "; ")
[10:22:28.522]                         if (!has_future) {
[10:22:28.522]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:28.522]                             info)
[10:22:28.522]                         }
[10:22:28.522]                         else {
[10:22:28.522]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:28.522]                             info, version)
[10:22:28.522]                         }
[10:22:28.522]                         base::stop(msg)
[10:22:28.522]                       }
[10:22:28.522]                     })
[10:22:28.522]                   }
[10:22:28.522]                   ...future.strategy.old <- future::plan("list")
[10:22:28.522]                   options(future.plan = NULL)
[10:22:28.522]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:28.522]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:28.522]                 }
[10:22:28.522]                 ...future.workdir <- getwd()
[10:22:28.522]             }
[10:22:28.522]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:28.522]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:28.522]         }
[10:22:28.522]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:28.522]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:28.522]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:28.522]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:28.522]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:28.522]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:28.522]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:28.522]             base::names(...future.oldOptions))
[10:22:28.522]     }
[10:22:28.522]     if (FALSE) {
[10:22:28.522]     }
[10:22:28.522]     else {
[10:22:28.522]         if (TRUE) {
[10:22:28.522]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:28.522]                 open = "w")
[10:22:28.522]         }
[10:22:28.522]         else {
[10:22:28.522]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:28.522]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:28.522]         }
[10:22:28.522]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:28.522]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:28.522]             base::sink(type = "output", split = FALSE)
[10:22:28.522]             base::close(...future.stdout)
[10:22:28.522]         }, add = TRUE)
[10:22:28.522]     }
[10:22:28.522]     ...future.frame <- base::sys.nframe()
[10:22:28.522]     ...future.conditions <- base::list()
[10:22:28.522]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:28.522]     if (FALSE) {
[10:22:28.522]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:28.522]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:28.522]     }
[10:22:28.522]     ...future.result <- base::tryCatch({
[10:22:28.522]         base::withCallingHandlers({
[10:22:28.522]             ...future.value <- base::withVisible(base::local({
[10:22:28.522]                 Sys.sleep(0.1)
[10:22:28.522]                 kk
[10:22:28.522]             }))
[10:22:28.522]             future::FutureResult(value = ...future.value$value, 
[10:22:28.522]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:28.522]                   ...future.rng), globalenv = if (FALSE) 
[10:22:28.522]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:28.522]                     ...future.globalenv.names))
[10:22:28.522]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:28.522]         }, condition = base::local({
[10:22:28.522]             c <- base::c
[10:22:28.522]             inherits <- base::inherits
[10:22:28.522]             invokeRestart <- base::invokeRestart
[10:22:28.522]             length <- base::length
[10:22:28.522]             list <- base::list
[10:22:28.522]             seq.int <- base::seq.int
[10:22:28.522]             signalCondition <- base::signalCondition
[10:22:28.522]             sys.calls <- base::sys.calls
[10:22:28.522]             `[[` <- base::`[[`
[10:22:28.522]             `+` <- base::`+`
[10:22:28.522]             `<<-` <- base::`<<-`
[10:22:28.522]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:28.522]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:28.522]                   3L)]
[10:22:28.522]             }
[10:22:28.522]             function(cond) {
[10:22:28.522]                 is_error <- inherits(cond, "error")
[10:22:28.522]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:28.522]                   NULL)
[10:22:28.522]                 if (is_error) {
[10:22:28.522]                   sessionInformation <- function() {
[10:22:28.522]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:28.522]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:28.522]                       search = base::search(), system = base::Sys.info())
[10:22:28.522]                   }
[10:22:28.522]                   ...future.conditions[[length(...future.conditions) + 
[10:22:28.522]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:28.522]                     cond$call), session = sessionInformation(), 
[10:22:28.522]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:28.522]                   signalCondition(cond)
[10:22:28.522]                 }
[10:22:28.522]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:28.522]                 "immediateCondition"))) {
[10:22:28.522]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:28.522]                   ...future.conditions[[length(...future.conditions) + 
[10:22:28.522]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:28.522]                   if (TRUE && !signal) {
[10:22:28.522]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:28.522]                     {
[10:22:28.522]                       inherits <- base::inherits
[10:22:28.522]                       invokeRestart <- base::invokeRestart
[10:22:28.522]                       is.null <- base::is.null
[10:22:28.522]                       muffled <- FALSE
[10:22:28.522]                       if (inherits(cond, "message")) {
[10:22:28.522]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:28.522]                         if (muffled) 
[10:22:28.522]                           invokeRestart("muffleMessage")
[10:22:28.522]                       }
[10:22:28.522]                       else if (inherits(cond, "warning")) {
[10:22:28.522]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:28.522]                         if (muffled) 
[10:22:28.522]                           invokeRestart("muffleWarning")
[10:22:28.522]                       }
[10:22:28.522]                       else if (inherits(cond, "condition")) {
[10:22:28.522]                         if (!is.null(pattern)) {
[10:22:28.522]                           computeRestarts <- base::computeRestarts
[10:22:28.522]                           grepl <- base::grepl
[10:22:28.522]                           restarts <- computeRestarts(cond)
[10:22:28.522]                           for (restart in restarts) {
[10:22:28.522]                             name <- restart$name
[10:22:28.522]                             if (is.null(name)) 
[10:22:28.522]                               next
[10:22:28.522]                             if (!grepl(pattern, name)) 
[10:22:28.522]                               next
[10:22:28.522]                             invokeRestart(restart)
[10:22:28.522]                             muffled <- TRUE
[10:22:28.522]                             break
[10:22:28.522]                           }
[10:22:28.522]                         }
[10:22:28.522]                       }
[10:22:28.522]                       invisible(muffled)
[10:22:28.522]                     }
[10:22:28.522]                     muffleCondition(cond, pattern = "^muffle")
[10:22:28.522]                   }
[10:22:28.522]                 }
[10:22:28.522]                 else {
[10:22:28.522]                   if (TRUE) {
[10:22:28.522]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:28.522]                     {
[10:22:28.522]                       inherits <- base::inherits
[10:22:28.522]                       invokeRestart <- base::invokeRestart
[10:22:28.522]                       is.null <- base::is.null
[10:22:28.522]                       muffled <- FALSE
[10:22:28.522]                       if (inherits(cond, "message")) {
[10:22:28.522]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:28.522]                         if (muffled) 
[10:22:28.522]                           invokeRestart("muffleMessage")
[10:22:28.522]                       }
[10:22:28.522]                       else if (inherits(cond, "warning")) {
[10:22:28.522]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:28.522]                         if (muffled) 
[10:22:28.522]                           invokeRestart("muffleWarning")
[10:22:28.522]                       }
[10:22:28.522]                       else if (inherits(cond, "condition")) {
[10:22:28.522]                         if (!is.null(pattern)) {
[10:22:28.522]                           computeRestarts <- base::computeRestarts
[10:22:28.522]                           grepl <- base::grepl
[10:22:28.522]                           restarts <- computeRestarts(cond)
[10:22:28.522]                           for (restart in restarts) {
[10:22:28.522]                             name <- restart$name
[10:22:28.522]                             if (is.null(name)) 
[10:22:28.522]                               next
[10:22:28.522]                             if (!grepl(pattern, name)) 
[10:22:28.522]                               next
[10:22:28.522]                             invokeRestart(restart)
[10:22:28.522]                             muffled <- TRUE
[10:22:28.522]                             break
[10:22:28.522]                           }
[10:22:28.522]                         }
[10:22:28.522]                       }
[10:22:28.522]                       invisible(muffled)
[10:22:28.522]                     }
[10:22:28.522]                     muffleCondition(cond, pattern = "^muffle")
[10:22:28.522]                   }
[10:22:28.522]                 }
[10:22:28.522]             }
[10:22:28.522]         }))
[10:22:28.522]     }, error = function(ex) {
[10:22:28.522]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:28.522]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:28.522]                 ...future.rng), started = ...future.startTime, 
[10:22:28.522]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:28.522]             version = "1.8"), class = "FutureResult")
[10:22:28.522]     }, finally = {
[10:22:28.522]         if (!identical(...future.workdir, getwd())) 
[10:22:28.522]             setwd(...future.workdir)
[10:22:28.522]         {
[10:22:28.522]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:28.522]                 ...future.oldOptions$nwarnings <- NULL
[10:22:28.522]             }
[10:22:28.522]             base::options(...future.oldOptions)
[10:22:28.522]             if (.Platform$OS.type == "windows") {
[10:22:28.522]                 old_names <- names(...future.oldEnvVars)
[10:22:28.522]                 envs <- base::Sys.getenv()
[10:22:28.522]                 names <- names(envs)
[10:22:28.522]                 common <- intersect(names, old_names)
[10:22:28.522]                 added <- setdiff(names, old_names)
[10:22:28.522]                 removed <- setdiff(old_names, names)
[10:22:28.522]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:28.522]                   envs[common]]
[10:22:28.522]                 NAMES <- toupper(changed)
[10:22:28.522]                 args <- list()
[10:22:28.522]                 for (kk in seq_along(NAMES)) {
[10:22:28.522]                   name <- changed[[kk]]
[10:22:28.522]                   NAME <- NAMES[[kk]]
[10:22:28.522]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:28.522]                     next
[10:22:28.522]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:28.522]                 }
[10:22:28.522]                 NAMES <- toupper(added)
[10:22:28.522]                 for (kk in seq_along(NAMES)) {
[10:22:28.522]                   name <- added[[kk]]
[10:22:28.522]                   NAME <- NAMES[[kk]]
[10:22:28.522]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:28.522]                     next
[10:22:28.522]                   args[[name]] <- ""
[10:22:28.522]                 }
[10:22:28.522]                 NAMES <- toupper(removed)
[10:22:28.522]                 for (kk in seq_along(NAMES)) {
[10:22:28.522]                   name <- removed[[kk]]
[10:22:28.522]                   NAME <- NAMES[[kk]]
[10:22:28.522]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:28.522]                     next
[10:22:28.522]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:28.522]                 }
[10:22:28.522]                 if (length(args) > 0) 
[10:22:28.522]                   base::do.call(base::Sys.setenv, args = args)
[10:22:28.522]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:28.522]             }
[10:22:28.522]             else {
[10:22:28.522]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:28.522]             }
[10:22:28.522]             {
[10:22:28.522]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:28.522]                   0L) {
[10:22:28.522]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:28.522]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:28.522]                   base::options(opts)
[10:22:28.522]                 }
[10:22:28.522]                 {
[10:22:28.522]                   {
[10:22:28.522]                     NULL
[10:22:28.522]                     RNGkind("Mersenne-Twister")
[10:22:28.522]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:28.522]                       inherits = FALSE)
[10:22:28.522]                   }
[10:22:28.522]                   options(future.plan = NULL)
[10:22:28.522]                   if (is.na(NA_character_)) 
[10:22:28.522]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:28.522]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:28.522]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:28.522]                     .init = FALSE)
[10:22:28.522]                 }
[10:22:28.522]             }
[10:22:28.522]         }
[10:22:28.522]     })
[10:22:28.522]     if (TRUE) {
[10:22:28.522]         base::sink(type = "output", split = FALSE)
[10:22:28.522]         if (TRUE) {
[10:22:28.522]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:28.522]         }
[10:22:28.522]         else {
[10:22:28.522]             ...future.result["stdout"] <- base::list(NULL)
[10:22:28.522]         }
[10:22:28.522]         base::close(...future.stdout)
[10:22:28.522]         ...future.stdout <- NULL
[10:22:28.522]     }
[10:22:28.522]     ...future.result$conditions <- ...future.conditions
[10:22:28.522]     ...future.result$finished <- base::Sys.time()
[10:22:28.522]     ...future.result
[10:22:28.522] }
[10:22:28.524] assign_globals() ...
[10:22:28.524] List of 1
[10:22:28.524]  $ kk: int 2
[10:22:28.524]  - attr(*, "where")=List of 1
[10:22:28.524]   ..$ kk:<environment: R_EmptyEnv> 
[10:22:28.524]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:28.524]  - attr(*, "resolved")= logi FALSE
[10:22:28.524]  - attr(*, "total_size")= num 35
[10:22:28.524]  - attr(*, "already-done")= logi TRUE
[10:22:28.527] - copied ‘kk’ to environment
[10:22:28.527] assign_globals() ... done
[10:22:28.527] plan(): Setting new future strategy stack:
[10:22:28.527] List of future strategies:
[10:22:28.527] 1. sequential:
[10:22:28.527]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:28.527]    - tweaked: FALSE
[10:22:28.527]    - call: NULL
[10:22:28.527] plan(): nbrOfWorkers() = 1
[10:22:28.630] plan(): Setting new future strategy stack:
[10:22:28.631] List of future strategies:
[10:22:28.631] 1. sequential:
[10:22:28.631]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:28.631]    - tweaked: FALSE
[10:22:28.631]    - call: plan(strategy)
[10:22:28.631] plan(): nbrOfWorkers() = 1
[10:22:28.631] SequentialFuture started (and completed)
[10:22:28.631] - Launch lazy future ... done
[10:22:28.632] run() for ‘SequentialFuture’ ... done
[10:22:28.632] getGlobalsAndPackages() ...
[10:22:28.632] Searching for globals...
[10:22:28.633] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:22:28.633] Searching for globals ... DONE
[10:22:28.633] Resolving globals: FALSE
[10:22:28.633] The total size of the 1 globals is 35 bytes (35 bytes)
[10:22:28.634] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[10:22:28.634] - globals: [1] ‘kk’
[10:22:28.634] 
[10:22:28.634] getGlobalsAndPackages() ... DONE
[10:22:28.634] run() for ‘Future’ ...
[10:22:28.634] - state: ‘created’
[10:22:28.634] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:28.635] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:28.635] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:28.635]   - Field: ‘label’
[10:22:28.635]   - Field: ‘local’
[10:22:28.635]   - Field: ‘owner’
[10:22:28.635]   - Field: ‘envir’
[10:22:28.635]   - Field: ‘packages’
[10:22:28.635]   - Field: ‘gc’
[10:22:28.635]   - Field: ‘conditions’
[10:22:28.636]   - Field: ‘expr’
[10:22:28.636]   - Field: ‘uuid’
[10:22:28.636]   - Field: ‘seed’
[10:22:28.636]   - Field: ‘version’
[10:22:28.636]   - Field: ‘result’
[10:22:28.636]   - Field: ‘asynchronous’
[10:22:28.636]   - Field: ‘calls’
[10:22:28.636]   - Field: ‘globals’
[10:22:28.636]   - Field: ‘stdout’
[10:22:28.636]   - Field: ‘earlySignal’
[10:22:28.636]   - Field: ‘lazy’
[10:22:28.637]   - Field: ‘state’
[10:22:28.637] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:28.637] - Launch lazy future ...
[10:22:28.637] Packages needed by the future expression (n = 0): <none>
[10:22:28.637] Packages needed by future strategies (n = 0): <none>
[10:22:28.637] {
[10:22:28.637]     {
[10:22:28.637]         {
[10:22:28.637]             ...future.startTime <- base::Sys.time()
[10:22:28.637]             {
[10:22:28.637]                 {
[10:22:28.637]                   {
[10:22:28.637]                     base::local({
[10:22:28.637]                       has_future <- base::requireNamespace("future", 
[10:22:28.637]                         quietly = TRUE)
[10:22:28.637]                       if (has_future) {
[10:22:28.637]                         ns <- base::getNamespace("future")
[10:22:28.637]                         version <- ns[[".package"]][["version"]]
[10:22:28.637]                         if (is.null(version)) 
[10:22:28.637]                           version <- utils::packageVersion("future")
[10:22:28.637]                       }
[10:22:28.637]                       else {
[10:22:28.637]                         version <- NULL
[10:22:28.637]                       }
[10:22:28.637]                       if (!has_future || version < "1.8.0") {
[10:22:28.637]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:28.637]                           "", base::R.version$version.string), 
[10:22:28.637]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:28.637]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:28.637]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:28.637]                             "release", "version")], collapse = " "), 
[10:22:28.637]                           hostname = base::Sys.info()[["nodename"]])
[10:22:28.637]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:28.637]                           info)
[10:22:28.637]                         info <- base::paste(info, collapse = "; ")
[10:22:28.637]                         if (!has_future) {
[10:22:28.637]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:28.637]                             info)
[10:22:28.637]                         }
[10:22:28.637]                         else {
[10:22:28.637]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:28.637]                             info, version)
[10:22:28.637]                         }
[10:22:28.637]                         base::stop(msg)
[10:22:28.637]                       }
[10:22:28.637]                     })
[10:22:28.637]                   }
[10:22:28.637]                   ...future.strategy.old <- future::plan("list")
[10:22:28.637]                   options(future.plan = NULL)
[10:22:28.637]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:28.637]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:28.637]                 }
[10:22:28.637]                 ...future.workdir <- getwd()
[10:22:28.637]             }
[10:22:28.637]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:28.637]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:28.637]         }
[10:22:28.637]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:28.637]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:28.637]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:28.637]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:28.637]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:28.637]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:28.637]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:28.637]             base::names(...future.oldOptions))
[10:22:28.637]     }
[10:22:28.637]     if (FALSE) {
[10:22:28.637]     }
[10:22:28.637]     else {
[10:22:28.637]         if (TRUE) {
[10:22:28.637]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:28.637]                 open = "w")
[10:22:28.637]         }
[10:22:28.637]         else {
[10:22:28.637]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:28.637]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:28.637]         }
[10:22:28.637]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:28.637]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:28.637]             base::sink(type = "output", split = FALSE)
[10:22:28.637]             base::close(...future.stdout)
[10:22:28.637]         }, add = TRUE)
[10:22:28.637]     }
[10:22:28.637]     ...future.frame <- base::sys.nframe()
[10:22:28.637]     ...future.conditions <- base::list()
[10:22:28.637]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:28.637]     if (FALSE) {
[10:22:28.637]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:28.637]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:28.637]     }
[10:22:28.637]     ...future.result <- base::tryCatch({
[10:22:28.637]         base::withCallingHandlers({
[10:22:28.637]             ...future.value <- base::withVisible(base::local({
[10:22:28.637]                 Sys.sleep(0.1)
[10:22:28.637]                 kk
[10:22:28.637]             }))
[10:22:28.637]             future::FutureResult(value = ...future.value$value, 
[10:22:28.637]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:28.637]                   ...future.rng), globalenv = if (FALSE) 
[10:22:28.637]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:28.637]                     ...future.globalenv.names))
[10:22:28.637]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:28.637]         }, condition = base::local({
[10:22:28.637]             c <- base::c
[10:22:28.637]             inherits <- base::inherits
[10:22:28.637]             invokeRestart <- base::invokeRestart
[10:22:28.637]             length <- base::length
[10:22:28.637]             list <- base::list
[10:22:28.637]             seq.int <- base::seq.int
[10:22:28.637]             signalCondition <- base::signalCondition
[10:22:28.637]             sys.calls <- base::sys.calls
[10:22:28.637]             `[[` <- base::`[[`
[10:22:28.637]             `+` <- base::`+`
[10:22:28.637]             `<<-` <- base::`<<-`
[10:22:28.637]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:28.637]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:28.637]                   3L)]
[10:22:28.637]             }
[10:22:28.637]             function(cond) {
[10:22:28.637]                 is_error <- inherits(cond, "error")
[10:22:28.637]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:28.637]                   NULL)
[10:22:28.637]                 if (is_error) {
[10:22:28.637]                   sessionInformation <- function() {
[10:22:28.637]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:28.637]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:28.637]                       search = base::search(), system = base::Sys.info())
[10:22:28.637]                   }
[10:22:28.637]                   ...future.conditions[[length(...future.conditions) + 
[10:22:28.637]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:28.637]                     cond$call), session = sessionInformation(), 
[10:22:28.637]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:28.637]                   signalCondition(cond)
[10:22:28.637]                 }
[10:22:28.637]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:28.637]                 "immediateCondition"))) {
[10:22:28.637]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:28.637]                   ...future.conditions[[length(...future.conditions) + 
[10:22:28.637]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:28.637]                   if (TRUE && !signal) {
[10:22:28.637]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:28.637]                     {
[10:22:28.637]                       inherits <- base::inherits
[10:22:28.637]                       invokeRestart <- base::invokeRestart
[10:22:28.637]                       is.null <- base::is.null
[10:22:28.637]                       muffled <- FALSE
[10:22:28.637]                       if (inherits(cond, "message")) {
[10:22:28.637]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:28.637]                         if (muffled) 
[10:22:28.637]                           invokeRestart("muffleMessage")
[10:22:28.637]                       }
[10:22:28.637]                       else if (inherits(cond, "warning")) {
[10:22:28.637]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:28.637]                         if (muffled) 
[10:22:28.637]                           invokeRestart("muffleWarning")
[10:22:28.637]                       }
[10:22:28.637]                       else if (inherits(cond, "condition")) {
[10:22:28.637]                         if (!is.null(pattern)) {
[10:22:28.637]                           computeRestarts <- base::computeRestarts
[10:22:28.637]                           grepl <- base::grepl
[10:22:28.637]                           restarts <- computeRestarts(cond)
[10:22:28.637]                           for (restart in restarts) {
[10:22:28.637]                             name <- restart$name
[10:22:28.637]                             if (is.null(name)) 
[10:22:28.637]                               next
[10:22:28.637]                             if (!grepl(pattern, name)) 
[10:22:28.637]                               next
[10:22:28.637]                             invokeRestart(restart)
[10:22:28.637]                             muffled <- TRUE
[10:22:28.637]                             break
[10:22:28.637]                           }
[10:22:28.637]                         }
[10:22:28.637]                       }
[10:22:28.637]                       invisible(muffled)
[10:22:28.637]                     }
[10:22:28.637]                     muffleCondition(cond, pattern = "^muffle")
[10:22:28.637]                   }
[10:22:28.637]                 }
[10:22:28.637]                 else {
[10:22:28.637]                   if (TRUE) {
[10:22:28.637]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:28.637]                     {
[10:22:28.637]                       inherits <- base::inherits
[10:22:28.637]                       invokeRestart <- base::invokeRestart
[10:22:28.637]                       is.null <- base::is.null
[10:22:28.637]                       muffled <- FALSE
[10:22:28.637]                       if (inherits(cond, "message")) {
[10:22:28.637]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:28.637]                         if (muffled) 
[10:22:28.637]                           invokeRestart("muffleMessage")
[10:22:28.637]                       }
[10:22:28.637]                       else if (inherits(cond, "warning")) {
[10:22:28.637]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:28.637]                         if (muffled) 
[10:22:28.637]                           invokeRestart("muffleWarning")
[10:22:28.637]                       }
[10:22:28.637]                       else if (inherits(cond, "condition")) {
[10:22:28.637]                         if (!is.null(pattern)) {
[10:22:28.637]                           computeRestarts <- base::computeRestarts
[10:22:28.637]                           grepl <- base::grepl
[10:22:28.637]                           restarts <- computeRestarts(cond)
[10:22:28.637]                           for (restart in restarts) {
[10:22:28.637]                             name <- restart$name
[10:22:28.637]                             if (is.null(name)) 
[10:22:28.637]                               next
[10:22:28.637]                             if (!grepl(pattern, name)) 
[10:22:28.637]                               next
[10:22:28.637]                             invokeRestart(restart)
[10:22:28.637]                             muffled <- TRUE
[10:22:28.637]                             break
[10:22:28.637]                           }
[10:22:28.637]                         }
[10:22:28.637]                       }
[10:22:28.637]                       invisible(muffled)
[10:22:28.637]                     }
[10:22:28.637]                     muffleCondition(cond, pattern = "^muffle")
[10:22:28.637]                   }
[10:22:28.637]                 }
[10:22:28.637]             }
[10:22:28.637]         }))
[10:22:28.637]     }, error = function(ex) {
[10:22:28.637]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:28.637]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:28.637]                 ...future.rng), started = ...future.startTime, 
[10:22:28.637]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:28.637]             version = "1.8"), class = "FutureResult")
[10:22:28.637]     }, finally = {
[10:22:28.637]         if (!identical(...future.workdir, getwd())) 
[10:22:28.637]             setwd(...future.workdir)
[10:22:28.637]         {
[10:22:28.637]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:28.637]                 ...future.oldOptions$nwarnings <- NULL
[10:22:28.637]             }
[10:22:28.637]             base::options(...future.oldOptions)
[10:22:28.637]             if (.Platform$OS.type == "windows") {
[10:22:28.637]                 old_names <- names(...future.oldEnvVars)
[10:22:28.637]                 envs <- base::Sys.getenv()
[10:22:28.637]                 names <- names(envs)
[10:22:28.637]                 common <- intersect(names, old_names)
[10:22:28.637]                 added <- setdiff(names, old_names)
[10:22:28.637]                 removed <- setdiff(old_names, names)
[10:22:28.637]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:28.637]                   envs[common]]
[10:22:28.637]                 NAMES <- toupper(changed)
[10:22:28.637]                 args <- list()
[10:22:28.637]                 for (kk in seq_along(NAMES)) {
[10:22:28.637]                   name <- changed[[kk]]
[10:22:28.637]                   NAME <- NAMES[[kk]]
[10:22:28.637]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:28.637]                     next
[10:22:28.637]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:28.637]                 }
[10:22:28.637]                 NAMES <- toupper(added)
[10:22:28.637]                 for (kk in seq_along(NAMES)) {
[10:22:28.637]                   name <- added[[kk]]
[10:22:28.637]                   NAME <- NAMES[[kk]]
[10:22:28.637]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:28.637]                     next
[10:22:28.637]                   args[[name]] <- ""
[10:22:28.637]                 }
[10:22:28.637]                 NAMES <- toupper(removed)
[10:22:28.637]                 for (kk in seq_along(NAMES)) {
[10:22:28.637]                   name <- removed[[kk]]
[10:22:28.637]                   NAME <- NAMES[[kk]]
[10:22:28.637]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:28.637]                     next
[10:22:28.637]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:28.637]                 }
[10:22:28.637]                 if (length(args) > 0) 
[10:22:28.637]                   base::do.call(base::Sys.setenv, args = args)
[10:22:28.637]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:28.637]             }
[10:22:28.637]             else {
[10:22:28.637]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:28.637]             }
[10:22:28.637]             {
[10:22:28.637]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:28.637]                   0L) {
[10:22:28.637]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:28.637]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:28.637]                   base::options(opts)
[10:22:28.637]                 }
[10:22:28.637]                 {
[10:22:28.637]                   {
[10:22:28.637]                     NULL
[10:22:28.637]                     RNGkind("Mersenne-Twister")
[10:22:28.637]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:28.637]                       inherits = FALSE)
[10:22:28.637]                   }
[10:22:28.637]                   options(future.plan = NULL)
[10:22:28.637]                   if (is.na(NA_character_)) 
[10:22:28.637]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:28.637]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:28.637]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:28.637]                     .init = FALSE)
[10:22:28.637]                 }
[10:22:28.637]             }
[10:22:28.637]         }
[10:22:28.637]     })
[10:22:28.637]     if (TRUE) {
[10:22:28.637]         base::sink(type = "output", split = FALSE)
[10:22:28.637]         if (TRUE) {
[10:22:28.637]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:28.637]         }
[10:22:28.637]         else {
[10:22:28.637]             ...future.result["stdout"] <- base::list(NULL)
[10:22:28.637]         }
[10:22:28.637]         base::close(...future.stdout)
[10:22:28.637]         ...future.stdout <- NULL
[10:22:28.637]     }
[10:22:28.637]     ...future.result$conditions <- ...future.conditions
[10:22:28.637]     ...future.result$finished <- base::Sys.time()
[10:22:28.637]     ...future.result
[10:22:28.637] }
[10:22:28.639] assign_globals() ...
[10:22:28.639] List of 1
[10:22:28.639]  $ kk: int 3
[10:22:28.639]  - attr(*, "where")=List of 1
[10:22:28.639]   ..$ kk:<environment: R_EmptyEnv> 
[10:22:28.639]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:28.639]  - attr(*, "resolved")= logi FALSE
[10:22:28.639]  - attr(*, "total_size")= num 35
[10:22:28.639]  - attr(*, "already-done")= logi TRUE
[10:22:28.642] - copied ‘kk’ to environment
[10:22:28.642] assign_globals() ... done
[10:22:28.642] plan(): Setting new future strategy stack:
[10:22:28.642] List of future strategies:
[10:22:28.642] 1. sequential:
[10:22:28.642]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:28.642]    - tweaked: FALSE
[10:22:28.642]    - call: NULL
[10:22:28.642] plan(): nbrOfWorkers() = 1
[10:22:28.744] plan(): Setting new future strategy stack:
[10:22:28.744] List of future strategies:
[10:22:28.744] 1. sequential:
[10:22:28.744]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:28.744]    - tweaked: FALSE
[10:22:28.744]    - call: plan(strategy)
[10:22:28.744] plan(): nbrOfWorkers() = 1
[10:22:28.744] SequentialFuture started (and completed)
[10:22:28.744] - Launch lazy future ... done
[10:22:28.745] run() for ‘SequentialFuture’ ... done
[10:22:28.745] resolve() on list ...
[10:22:28.745]  recursive: 0
[10:22:28.745]  length: 3
[10:22:28.745] 
[10:22:28.745] resolved() for ‘SequentialFuture’ ...
[10:22:28.745] - state: ‘finished’
[10:22:28.745] - run: TRUE
[10:22:28.745] - result: ‘FutureResult’
[10:22:28.745] resolved() for ‘SequentialFuture’ ... done
[10:22:28.745] Future #1
[10:22:28.746]  length: 2 (resolved future 1)
[10:22:28.746] resolved() for ‘SequentialFuture’ ...
[10:22:28.746] - state: ‘finished’
[10:22:28.746] - run: TRUE
[10:22:28.746] - result: ‘FutureResult’
[10:22:28.746] resolved() for ‘SequentialFuture’ ... done
[10:22:28.746] Future #2
[10:22:28.746]  length: 1 (resolved future 2)
[10:22:28.746] resolved() for ‘SequentialFuture’ ...
[10:22:28.746] - state: ‘finished’
[10:22:28.747] - run: TRUE
[10:22:28.747] - result: ‘FutureResult’
[10:22:28.747] resolved() for ‘SequentialFuture’ ... done
[10:22:28.747] Future #3
[10:22:28.747]  length: 0 (resolved future 3)
[10:22:28.747] resolve() on list ... DONE
[10:22:28.747] getGlobalsAndPackages() ...
[10:22:28.747] Searching for globals...
[10:22:28.748] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:22:28.748] Searching for globals ... DONE
[10:22:28.748] Resolving globals: FALSE
[10:22:28.749] The total size of the 1 globals is 35 bytes (35 bytes)
[10:22:28.749] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[10:22:28.749] - globals: [1] ‘kk’
[10:22:28.749] 
[10:22:28.749] getGlobalsAndPackages() ... DONE
[10:22:28.750] getGlobalsAndPackages() ...
[10:22:28.750] Searching for globals...
[10:22:28.751] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:22:28.751] Searching for globals ... DONE
[10:22:28.751] Resolving globals: FALSE
[10:22:28.751] The total size of the 1 globals is 35 bytes (35 bytes)
[10:22:28.751] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[10:22:28.751] - globals: [1] ‘kk’
[10:22:28.752] 
[10:22:28.752] getGlobalsAndPackages() ... DONE
[10:22:28.752] getGlobalsAndPackages() ...
[10:22:28.752] Searching for globals...
[10:22:28.753] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:22:28.753] Searching for globals ... DONE
[10:22:28.753] Resolving globals: FALSE
[10:22:28.753] The total size of the 1 globals is 35 bytes (35 bytes)
[10:22:28.754] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[10:22:28.754] - globals: [1] ‘kk’
[10:22:28.754] 
[10:22:28.754] getGlobalsAndPackages() ... DONE
[10:22:28.754] resolve() on list ...
[10:22:28.754]  recursive: 0
[10:22:28.754]  length: 3
[10:22:28.754] 
[10:22:28.755] run() for ‘Future’ ...
[10:22:28.755] - state: ‘created’
[10:22:28.755] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:28.755] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:28.755] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:28.755]   - Field: ‘label’
[10:22:28.755]   - Field: ‘local’
[10:22:28.755]   - Field: ‘owner’
[10:22:28.755]   - Field: ‘envir’
[10:22:28.756]   - Field: ‘packages’
[10:22:28.756]   - Field: ‘gc’
[10:22:28.756]   - Field: ‘conditions’
[10:22:28.758]   - Field: ‘expr’
[10:22:28.758]   - Field: ‘uuid’
[10:22:28.758]   - Field: ‘seed’
[10:22:28.758]   - Field: ‘version’
[10:22:28.758]   - Field: ‘result’
[10:22:28.758]   - Field: ‘asynchronous’
[10:22:28.758]   - Field: ‘calls’
[10:22:28.758]   - Field: ‘globals’
[10:22:28.758]   - Field: ‘stdout’
[10:22:28.759]   - Field: ‘earlySignal’
[10:22:28.759]   - Field: ‘lazy’
[10:22:28.759]   - Field: ‘state’
[10:22:28.759] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:28.759] - Launch lazy future ...
[10:22:28.759] Packages needed by the future expression (n = 0): <none>
[10:22:28.759] Packages needed by future strategies (n = 0): <none>
[10:22:28.760] {
[10:22:28.760]     {
[10:22:28.760]         {
[10:22:28.760]             ...future.startTime <- base::Sys.time()
[10:22:28.760]             {
[10:22:28.760]                 {
[10:22:28.760]                   {
[10:22:28.760]                     base::local({
[10:22:28.760]                       has_future <- base::requireNamespace("future", 
[10:22:28.760]                         quietly = TRUE)
[10:22:28.760]                       if (has_future) {
[10:22:28.760]                         ns <- base::getNamespace("future")
[10:22:28.760]                         version <- ns[[".package"]][["version"]]
[10:22:28.760]                         if (is.null(version)) 
[10:22:28.760]                           version <- utils::packageVersion("future")
[10:22:28.760]                       }
[10:22:28.760]                       else {
[10:22:28.760]                         version <- NULL
[10:22:28.760]                       }
[10:22:28.760]                       if (!has_future || version < "1.8.0") {
[10:22:28.760]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:28.760]                           "", base::R.version$version.string), 
[10:22:28.760]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:28.760]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:28.760]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:28.760]                             "release", "version")], collapse = " "), 
[10:22:28.760]                           hostname = base::Sys.info()[["nodename"]])
[10:22:28.760]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:28.760]                           info)
[10:22:28.760]                         info <- base::paste(info, collapse = "; ")
[10:22:28.760]                         if (!has_future) {
[10:22:28.760]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:28.760]                             info)
[10:22:28.760]                         }
[10:22:28.760]                         else {
[10:22:28.760]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:28.760]                             info, version)
[10:22:28.760]                         }
[10:22:28.760]                         base::stop(msg)
[10:22:28.760]                       }
[10:22:28.760]                     })
[10:22:28.760]                   }
[10:22:28.760]                   ...future.strategy.old <- future::plan("list")
[10:22:28.760]                   options(future.plan = NULL)
[10:22:28.760]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:28.760]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:28.760]                 }
[10:22:28.760]                 ...future.workdir <- getwd()
[10:22:28.760]             }
[10:22:28.760]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:28.760]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:28.760]         }
[10:22:28.760]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:28.760]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:28.760]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:28.760]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:28.760]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:28.760]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:28.760]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:28.760]             base::names(...future.oldOptions))
[10:22:28.760]     }
[10:22:28.760]     if (FALSE) {
[10:22:28.760]     }
[10:22:28.760]     else {
[10:22:28.760]         if (TRUE) {
[10:22:28.760]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:28.760]                 open = "w")
[10:22:28.760]         }
[10:22:28.760]         else {
[10:22:28.760]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:28.760]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:28.760]         }
[10:22:28.760]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:28.760]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:28.760]             base::sink(type = "output", split = FALSE)
[10:22:28.760]             base::close(...future.stdout)
[10:22:28.760]         }, add = TRUE)
[10:22:28.760]     }
[10:22:28.760]     ...future.frame <- base::sys.nframe()
[10:22:28.760]     ...future.conditions <- base::list()
[10:22:28.760]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:28.760]     if (FALSE) {
[10:22:28.760]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:28.760]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:28.760]     }
[10:22:28.760]     ...future.result <- base::tryCatch({
[10:22:28.760]         base::withCallingHandlers({
[10:22:28.760]             ...future.value <- base::withVisible(base::local({
[10:22:28.760]                 Sys.sleep(0.1)
[10:22:28.760]                 kk
[10:22:28.760]             }))
[10:22:28.760]             future::FutureResult(value = ...future.value$value, 
[10:22:28.760]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:28.760]                   ...future.rng), globalenv = if (FALSE) 
[10:22:28.760]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:28.760]                     ...future.globalenv.names))
[10:22:28.760]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:28.760]         }, condition = base::local({
[10:22:28.760]             c <- base::c
[10:22:28.760]             inherits <- base::inherits
[10:22:28.760]             invokeRestart <- base::invokeRestart
[10:22:28.760]             length <- base::length
[10:22:28.760]             list <- base::list
[10:22:28.760]             seq.int <- base::seq.int
[10:22:28.760]             signalCondition <- base::signalCondition
[10:22:28.760]             sys.calls <- base::sys.calls
[10:22:28.760]             `[[` <- base::`[[`
[10:22:28.760]             `+` <- base::`+`
[10:22:28.760]             `<<-` <- base::`<<-`
[10:22:28.760]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:28.760]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:28.760]                   3L)]
[10:22:28.760]             }
[10:22:28.760]             function(cond) {
[10:22:28.760]                 is_error <- inherits(cond, "error")
[10:22:28.760]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:28.760]                   NULL)
[10:22:28.760]                 if (is_error) {
[10:22:28.760]                   sessionInformation <- function() {
[10:22:28.760]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:28.760]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:28.760]                       search = base::search(), system = base::Sys.info())
[10:22:28.760]                   }
[10:22:28.760]                   ...future.conditions[[length(...future.conditions) + 
[10:22:28.760]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:28.760]                     cond$call), session = sessionInformation(), 
[10:22:28.760]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:28.760]                   signalCondition(cond)
[10:22:28.760]                 }
[10:22:28.760]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:28.760]                 "immediateCondition"))) {
[10:22:28.760]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:28.760]                   ...future.conditions[[length(...future.conditions) + 
[10:22:28.760]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:28.760]                   if (TRUE && !signal) {
[10:22:28.760]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:28.760]                     {
[10:22:28.760]                       inherits <- base::inherits
[10:22:28.760]                       invokeRestart <- base::invokeRestart
[10:22:28.760]                       is.null <- base::is.null
[10:22:28.760]                       muffled <- FALSE
[10:22:28.760]                       if (inherits(cond, "message")) {
[10:22:28.760]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:28.760]                         if (muffled) 
[10:22:28.760]                           invokeRestart("muffleMessage")
[10:22:28.760]                       }
[10:22:28.760]                       else if (inherits(cond, "warning")) {
[10:22:28.760]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:28.760]                         if (muffled) 
[10:22:28.760]                           invokeRestart("muffleWarning")
[10:22:28.760]                       }
[10:22:28.760]                       else if (inherits(cond, "condition")) {
[10:22:28.760]                         if (!is.null(pattern)) {
[10:22:28.760]                           computeRestarts <- base::computeRestarts
[10:22:28.760]                           grepl <- base::grepl
[10:22:28.760]                           restarts <- computeRestarts(cond)
[10:22:28.760]                           for (restart in restarts) {
[10:22:28.760]                             name <- restart$name
[10:22:28.760]                             if (is.null(name)) 
[10:22:28.760]                               next
[10:22:28.760]                             if (!grepl(pattern, name)) 
[10:22:28.760]                               next
[10:22:28.760]                             invokeRestart(restart)
[10:22:28.760]                             muffled <- TRUE
[10:22:28.760]                             break
[10:22:28.760]                           }
[10:22:28.760]                         }
[10:22:28.760]                       }
[10:22:28.760]                       invisible(muffled)
[10:22:28.760]                     }
[10:22:28.760]                     muffleCondition(cond, pattern = "^muffle")
[10:22:28.760]                   }
[10:22:28.760]                 }
[10:22:28.760]                 else {
[10:22:28.760]                   if (TRUE) {
[10:22:28.760]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:28.760]                     {
[10:22:28.760]                       inherits <- base::inherits
[10:22:28.760]                       invokeRestart <- base::invokeRestart
[10:22:28.760]                       is.null <- base::is.null
[10:22:28.760]                       muffled <- FALSE
[10:22:28.760]                       if (inherits(cond, "message")) {
[10:22:28.760]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:28.760]                         if (muffled) 
[10:22:28.760]                           invokeRestart("muffleMessage")
[10:22:28.760]                       }
[10:22:28.760]                       else if (inherits(cond, "warning")) {
[10:22:28.760]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:28.760]                         if (muffled) 
[10:22:28.760]                           invokeRestart("muffleWarning")
[10:22:28.760]                       }
[10:22:28.760]                       else if (inherits(cond, "condition")) {
[10:22:28.760]                         if (!is.null(pattern)) {
[10:22:28.760]                           computeRestarts <- base::computeRestarts
[10:22:28.760]                           grepl <- base::grepl
[10:22:28.760]                           restarts <- computeRestarts(cond)
[10:22:28.760]                           for (restart in restarts) {
[10:22:28.760]                             name <- restart$name
[10:22:28.760]                             if (is.null(name)) 
[10:22:28.760]                               next
[10:22:28.760]                             if (!grepl(pattern, name)) 
[10:22:28.760]                               next
[10:22:28.760]                             invokeRestart(restart)
[10:22:28.760]                             muffled <- TRUE
[10:22:28.760]                             break
[10:22:28.760]                           }
[10:22:28.760]                         }
[10:22:28.760]                       }
[10:22:28.760]                       invisible(muffled)
[10:22:28.760]                     }
[10:22:28.760]                     muffleCondition(cond, pattern = "^muffle")
[10:22:28.760]                   }
[10:22:28.760]                 }
[10:22:28.760]             }
[10:22:28.760]         }))
[10:22:28.760]     }, error = function(ex) {
[10:22:28.760]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:28.760]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:28.760]                 ...future.rng), started = ...future.startTime, 
[10:22:28.760]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:28.760]             version = "1.8"), class = "FutureResult")
[10:22:28.760]     }, finally = {
[10:22:28.760]         if (!identical(...future.workdir, getwd())) 
[10:22:28.760]             setwd(...future.workdir)
[10:22:28.760]         {
[10:22:28.760]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:28.760]                 ...future.oldOptions$nwarnings <- NULL
[10:22:28.760]             }
[10:22:28.760]             base::options(...future.oldOptions)
[10:22:28.760]             if (.Platform$OS.type == "windows") {
[10:22:28.760]                 old_names <- names(...future.oldEnvVars)
[10:22:28.760]                 envs <- base::Sys.getenv()
[10:22:28.760]                 names <- names(envs)
[10:22:28.760]                 common <- intersect(names, old_names)
[10:22:28.760]                 added <- setdiff(names, old_names)
[10:22:28.760]                 removed <- setdiff(old_names, names)
[10:22:28.760]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:28.760]                   envs[common]]
[10:22:28.760]                 NAMES <- toupper(changed)
[10:22:28.760]                 args <- list()
[10:22:28.760]                 for (kk in seq_along(NAMES)) {
[10:22:28.760]                   name <- changed[[kk]]
[10:22:28.760]                   NAME <- NAMES[[kk]]
[10:22:28.760]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:28.760]                     next
[10:22:28.760]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:28.760]                 }
[10:22:28.760]                 NAMES <- toupper(added)
[10:22:28.760]                 for (kk in seq_along(NAMES)) {
[10:22:28.760]                   name <- added[[kk]]
[10:22:28.760]                   NAME <- NAMES[[kk]]
[10:22:28.760]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:28.760]                     next
[10:22:28.760]                   args[[name]] <- ""
[10:22:28.760]                 }
[10:22:28.760]                 NAMES <- toupper(removed)
[10:22:28.760]                 for (kk in seq_along(NAMES)) {
[10:22:28.760]                   name <- removed[[kk]]
[10:22:28.760]                   NAME <- NAMES[[kk]]
[10:22:28.760]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:28.760]                     next
[10:22:28.760]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:28.760]                 }
[10:22:28.760]                 if (length(args) > 0) 
[10:22:28.760]                   base::do.call(base::Sys.setenv, args = args)
[10:22:28.760]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:28.760]             }
[10:22:28.760]             else {
[10:22:28.760]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:28.760]             }
[10:22:28.760]             {
[10:22:28.760]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:28.760]                   0L) {
[10:22:28.760]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:28.760]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:28.760]                   base::options(opts)
[10:22:28.760]                 }
[10:22:28.760]                 {
[10:22:28.760]                   {
[10:22:28.760]                     NULL
[10:22:28.760]                     RNGkind("Mersenne-Twister")
[10:22:28.760]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:28.760]                       inherits = FALSE)
[10:22:28.760]                   }
[10:22:28.760]                   options(future.plan = NULL)
[10:22:28.760]                   if (is.na(NA_character_)) 
[10:22:28.760]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:28.760]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:28.760]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:28.760]                     .init = FALSE)
[10:22:28.760]                 }
[10:22:28.760]             }
[10:22:28.760]         }
[10:22:28.760]     })
[10:22:28.760]     if (TRUE) {
[10:22:28.760]         base::sink(type = "output", split = FALSE)
[10:22:28.760]         if (TRUE) {
[10:22:28.760]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:28.760]         }
[10:22:28.760]         else {
[10:22:28.760]             ...future.result["stdout"] <- base::list(NULL)
[10:22:28.760]         }
[10:22:28.760]         base::close(...future.stdout)
[10:22:28.760]         ...future.stdout <- NULL
[10:22:28.760]     }
[10:22:28.760]     ...future.result$conditions <- ...future.conditions
[10:22:28.760]     ...future.result$finished <- base::Sys.time()
[10:22:28.760]     ...future.result
[10:22:28.760] }
[10:22:28.761] assign_globals() ...
[10:22:28.761] List of 1
[10:22:28.761]  $ kk: int 1
[10:22:28.761]  - attr(*, "where")=List of 1
[10:22:28.761]   ..$ kk:<environment: R_EmptyEnv> 
[10:22:28.761]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:28.761]  - attr(*, "resolved")= logi FALSE
[10:22:28.761]  - attr(*, "total_size")= num 35
[10:22:28.761]  - attr(*, "already-done")= logi TRUE
[10:22:28.764] - copied ‘kk’ to environment
[10:22:28.764] assign_globals() ... done
[10:22:28.764] plan(): Setting new future strategy stack:
[10:22:28.764] List of future strategies:
[10:22:28.764] 1. sequential:
[10:22:28.764]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:28.764]    - tweaked: FALSE
[10:22:28.764]    - call: NULL
[10:22:28.765] plan(): nbrOfWorkers() = 1
[10:22:28.866] plan(): Setting new future strategy stack:
[10:22:28.866] List of future strategies:
[10:22:28.866] 1. sequential:
[10:22:28.866]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:28.866]    - tweaked: FALSE
[10:22:28.866]    - call: plan(strategy)
[10:22:28.866] plan(): nbrOfWorkers() = 1
[10:22:28.867] SequentialFuture started (and completed)
[10:22:28.867] - Launch lazy future ... done
[10:22:28.867] run() for ‘SequentialFuture’ ... done
[10:22:28.867] resolved() for ‘SequentialFuture’ ...
[10:22:28.867] - state: ‘finished’
[10:22:28.867] - run: TRUE
[10:22:28.867] - result: ‘FutureResult’
[10:22:28.867] resolved() for ‘SequentialFuture’ ... done
[10:22:28.867] Future #1
[10:22:28.868]  length: 2 (resolved future 1)
[10:22:28.868] run() for ‘Future’ ...
[10:22:28.868] - state: ‘created’
[10:22:28.868] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:28.868] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:28.868] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:28.868]   - Field: ‘label’
[10:22:28.868]   - Field: ‘local’
[10:22:28.868]   - Field: ‘owner’
[10:22:28.869]   - Field: ‘envir’
[10:22:28.869]   - Field: ‘packages’
[10:22:28.869]   - Field: ‘gc’
[10:22:28.869]   - Field: ‘conditions’
[10:22:28.869]   - Field: ‘expr’
[10:22:28.869]   - Field: ‘uuid’
[10:22:28.869]   - Field: ‘seed’
[10:22:28.869]   - Field: ‘version’
[10:22:28.869]   - Field: ‘result’
[10:22:28.869]   - Field: ‘asynchronous’
[10:22:28.869]   - Field: ‘calls’
[10:22:28.869]   - Field: ‘globals’
[10:22:28.870]   - Field: ‘stdout’
[10:22:28.870]   - Field: ‘earlySignal’
[10:22:28.870]   - Field: ‘lazy’
[10:22:28.870]   - Field: ‘state’
[10:22:28.870] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:28.870] - Launch lazy future ...
[10:22:28.870] Packages needed by the future expression (n = 0): <none>
[10:22:28.870] Packages needed by future strategies (n = 0): <none>
[10:22:28.871] {
[10:22:28.871]     {
[10:22:28.871]         {
[10:22:28.871]             ...future.startTime <- base::Sys.time()
[10:22:28.871]             {
[10:22:28.871]                 {
[10:22:28.871]                   {
[10:22:28.871]                     base::local({
[10:22:28.871]                       has_future <- base::requireNamespace("future", 
[10:22:28.871]                         quietly = TRUE)
[10:22:28.871]                       if (has_future) {
[10:22:28.871]                         ns <- base::getNamespace("future")
[10:22:28.871]                         version <- ns[[".package"]][["version"]]
[10:22:28.871]                         if (is.null(version)) 
[10:22:28.871]                           version <- utils::packageVersion("future")
[10:22:28.871]                       }
[10:22:28.871]                       else {
[10:22:28.871]                         version <- NULL
[10:22:28.871]                       }
[10:22:28.871]                       if (!has_future || version < "1.8.0") {
[10:22:28.871]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:28.871]                           "", base::R.version$version.string), 
[10:22:28.871]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:28.871]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:28.871]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:28.871]                             "release", "version")], collapse = " "), 
[10:22:28.871]                           hostname = base::Sys.info()[["nodename"]])
[10:22:28.871]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:28.871]                           info)
[10:22:28.871]                         info <- base::paste(info, collapse = "; ")
[10:22:28.871]                         if (!has_future) {
[10:22:28.871]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:28.871]                             info)
[10:22:28.871]                         }
[10:22:28.871]                         else {
[10:22:28.871]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:28.871]                             info, version)
[10:22:28.871]                         }
[10:22:28.871]                         base::stop(msg)
[10:22:28.871]                       }
[10:22:28.871]                     })
[10:22:28.871]                   }
[10:22:28.871]                   ...future.strategy.old <- future::plan("list")
[10:22:28.871]                   options(future.plan = NULL)
[10:22:28.871]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:28.871]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:28.871]                 }
[10:22:28.871]                 ...future.workdir <- getwd()
[10:22:28.871]             }
[10:22:28.871]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:28.871]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:28.871]         }
[10:22:28.871]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:28.871]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:28.871]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:28.871]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:28.871]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:28.871]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:28.871]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:28.871]             base::names(...future.oldOptions))
[10:22:28.871]     }
[10:22:28.871]     if (FALSE) {
[10:22:28.871]     }
[10:22:28.871]     else {
[10:22:28.871]         if (TRUE) {
[10:22:28.871]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:28.871]                 open = "w")
[10:22:28.871]         }
[10:22:28.871]         else {
[10:22:28.871]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:28.871]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:28.871]         }
[10:22:28.871]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:28.871]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:28.871]             base::sink(type = "output", split = FALSE)
[10:22:28.871]             base::close(...future.stdout)
[10:22:28.871]         }, add = TRUE)
[10:22:28.871]     }
[10:22:28.871]     ...future.frame <- base::sys.nframe()
[10:22:28.871]     ...future.conditions <- base::list()
[10:22:28.871]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:28.871]     if (FALSE) {
[10:22:28.871]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:28.871]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:28.871]     }
[10:22:28.871]     ...future.result <- base::tryCatch({
[10:22:28.871]         base::withCallingHandlers({
[10:22:28.871]             ...future.value <- base::withVisible(base::local({
[10:22:28.871]                 Sys.sleep(0.1)
[10:22:28.871]                 kk
[10:22:28.871]             }))
[10:22:28.871]             future::FutureResult(value = ...future.value$value, 
[10:22:28.871]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:28.871]                   ...future.rng), globalenv = if (FALSE) 
[10:22:28.871]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:28.871]                     ...future.globalenv.names))
[10:22:28.871]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:28.871]         }, condition = base::local({
[10:22:28.871]             c <- base::c
[10:22:28.871]             inherits <- base::inherits
[10:22:28.871]             invokeRestart <- base::invokeRestart
[10:22:28.871]             length <- base::length
[10:22:28.871]             list <- base::list
[10:22:28.871]             seq.int <- base::seq.int
[10:22:28.871]             signalCondition <- base::signalCondition
[10:22:28.871]             sys.calls <- base::sys.calls
[10:22:28.871]             `[[` <- base::`[[`
[10:22:28.871]             `+` <- base::`+`
[10:22:28.871]             `<<-` <- base::`<<-`
[10:22:28.871]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:28.871]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:28.871]                   3L)]
[10:22:28.871]             }
[10:22:28.871]             function(cond) {
[10:22:28.871]                 is_error <- inherits(cond, "error")
[10:22:28.871]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:28.871]                   NULL)
[10:22:28.871]                 if (is_error) {
[10:22:28.871]                   sessionInformation <- function() {
[10:22:28.871]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:28.871]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:28.871]                       search = base::search(), system = base::Sys.info())
[10:22:28.871]                   }
[10:22:28.871]                   ...future.conditions[[length(...future.conditions) + 
[10:22:28.871]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:28.871]                     cond$call), session = sessionInformation(), 
[10:22:28.871]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:28.871]                   signalCondition(cond)
[10:22:28.871]                 }
[10:22:28.871]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:28.871]                 "immediateCondition"))) {
[10:22:28.871]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:28.871]                   ...future.conditions[[length(...future.conditions) + 
[10:22:28.871]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:28.871]                   if (TRUE && !signal) {
[10:22:28.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:28.871]                     {
[10:22:28.871]                       inherits <- base::inherits
[10:22:28.871]                       invokeRestart <- base::invokeRestart
[10:22:28.871]                       is.null <- base::is.null
[10:22:28.871]                       muffled <- FALSE
[10:22:28.871]                       if (inherits(cond, "message")) {
[10:22:28.871]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:28.871]                         if (muffled) 
[10:22:28.871]                           invokeRestart("muffleMessage")
[10:22:28.871]                       }
[10:22:28.871]                       else if (inherits(cond, "warning")) {
[10:22:28.871]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:28.871]                         if (muffled) 
[10:22:28.871]                           invokeRestart("muffleWarning")
[10:22:28.871]                       }
[10:22:28.871]                       else if (inherits(cond, "condition")) {
[10:22:28.871]                         if (!is.null(pattern)) {
[10:22:28.871]                           computeRestarts <- base::computeRestarts
[10:22:28.871]                           grepl <- base::grepl
[10:22:28.871]                           restarts <- computeRestarts(cond)
[10:22:28.871]                           for (restart in restarts) {
[10:22:28.871]                             name <- restart$name
[10:22:28.871]                             if (is.null(name)) 
[10:22:28.871]                               next
[10:22:28.871]                             if (!grepl(pattern, name)) 
[10:22:28.871]                               next
[10:22:28.871]                             invokeRestart(restart)
[10:22:28.871]                             muffled <- TRUE
[10:22:28.871]                             break
[10:22:28.871]                           }
[10:22:28.871]                         }
[10:22:28.871]                       }
[10:22:28.871]                       invisible(muffled)
[10:22:28.871]                     }
[10:22:28.871]                     muffleCondition(cond, pattern = "^muffle")
[10:22:28.871]                   }
[10:22:28.871]                 }
[10:22:28.871]                 else {
[10:22:28.871]                   if (TRUE) {
[10:22:28.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:28.871]                     {
[10:22:28.871]                       inherits <- base::inherits
[10:22:28.871]                       invokeRestart <- base::invokeRestart
[10:22:28.871]                       is.null <- base::is.null
[10:22:28.871]                       muffled <- FALSE
[10:22:28.871]                       if (inherits(cond, "message")) {
[10:22:28.871]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:28.871]                         if (muffled) 
[10:22:28.871]                           invokeRestart("muffleMessage")
[10:22:28.871]                       }
[10:22:28.871]                       else if (inherits(cond, "warning")) {
[10:22:28.871]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:28.871]                         if (muffled) 
[10:22:28.871]                           invokeRestart("muffleWarning")
[10:22:28.871]                       }
[10:22:28.871]                       else if (inherits(cond, "condition")) {
[10:22:28.871]                         if (!is.null(pattern)) {
[10:22:28.871]                           computeRestarts <- base::computeRestarts
[10:22:28.871]                           grepl <- base::grepl
[10:22:28.871]                           restarts <- computeRestarts(cond)
[10:22:28.871]                           for (restart in restarts) {
[10:22:28.871]                             name <- restart$name
[10:22:28.871]                             if (is.null(name)) 
[10:22:28.871]                               next
[10:22:28.871]                             if (!grepl(pattern, name)) 
[10:22:28.871]                               next
[10:22:28.871]                             invokeRestart(restart)
[10:22:28.871]                             muffled <- TRUE
[10:22:28.871]                             break
[10:22:28.871]                           }
[10:22:28.871]                         }
[10:22:28.871]                       }
[10:22:28.871]                       invisible(muffled)
[10:22:28.871]                     }
[10:22:28.871]                     muffleCondition(cond, pattern = "^muffle")
[10:22:28.871]                   }
[10:22:28.871]                 }
[10:22:28.871]             }
[10:22:28.871]         }))
[10:22:28.871]     }, error = function(ex) {
[10:22:28.871]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:28.871]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:28.871]                 ...future.rng), started = ...future.startTime, 
[10:22:28.871]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:28.871]             version = "1.8"), class = "FutureResult")
[10:22:28.871]     }, finally = {
[10:22:28.871]         if (!identical(...future.workdir, getwd())) 
[10:22:28.871]             setwd(...future.workdir)
[10:22:28.871]         {
[10:22:28.871]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:28.871]                 ...future.oldOptions$nwarnings <- NULL
[10:22:28.871]             }
[10:22:28.871]             base::options(...future.oldOptions)
[10:22:28.871]             if (.Platform$OS.type == "windows") {
[10:22:28.871]                 old_names <- names(...future.oldEnvVars)
[10:22:28.871]                 envs <- base::Sys.getenv()
[10:22:28.871]                 names <- names(envs)
[10:22:28.871]                 common <- intersect(names, old_names)
[10:22:28.871]                 added <- setdiff(names, old_names)
[10:22:28.871]                 removed <- setdiff(old_names, names)
[10:22:28.871]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:28.871]                   envs[common]]
[10:22:28.871]                 NAMES <- toupper(changed)
[10:22:28.871]                 args <- list()
[10:22:28.871]                 for (kk in seq_along(NAMES)) {
[10:22:28.871]                   name <- changed[[kk]]
[10:22:28.871]                   NAME <- NAMES[[kk]]
[10:22:28.871]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:28.871]                     next
[10:22:28.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:28.871]                 }
[10:22:28.871]                 NAMES <- toupper(added)
[10:22:28.871]                 for (kk in seq_along(NAMES)) {
[10:22:28.871]                   name <- added[[kk]]
[10:22:28.871]                   NAME <- NAMES[[kk]]
[10:22:28.871]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:28.871]                     next
[10:22:28.871]                   args[[name]] <- ""
[10:22:28.871]                 }
[10:22:28.871]                 NAMES <- toupper(removed)
[10:22:28.871]                 for (kk in seq_along(NAMES)) {
[10:22:28.871]                   name <- removed[[kk]]
[10:22:28.871]                   NAME <- NAMES[[kk]]
[10:22:28.871]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:28.871]                     next
[10:22:28.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:28.871]                 }
[10:22:28.871]                 if (length(args) > 0) 
[10:22:28.871]                   base::do.call(base::Sys.setenv, args = args)
[10:22:28.871]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:28.871]             }
[10:22:28.871]             else {
[10:22:28.871]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:28.871]             }
[10:22:28.871]             {
[10:22:28.871]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:28.871]                   0L) {
[10:22:28.871]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:28.871]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:28.871]                   base::options(opts)
[10:22:28.871]                 }
[10:22:28.871]                 {
[10:22:28.871]                   {
[10:22:28.871]                     NULL
[10:22:28.871]                     RNGkind("Mersenne-Twister")
[10:22:28.871]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:28.871]                       inherits = FALSE)
[10:22:28.871]                   }
[10:22:28.871]                   options(future.plan = NULL)
[10:22:28.871]                   if (is.na(NA_character_)) 
[10:22:28.871]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:28.871]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:28.871]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:28.871]                     .init = FALSE)
[10:22:28.871]                 }
[10:22:28.871]             }
[10:22:28.871]         }
[10:22:28.871]     })
[10:22:28.871]     if (TRUE) {
[10:22:28.871]         base::sink(type = "output", split = FALSE)
[10:22:28.871]         if (TRUE) {
[10:22:28.871]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:28.871]         }
[10:22:28.871]         else {
[10:22:28.871]             ...future.result["stdout"] <- base::list(NULL)
[10:22:28.871]         }
[10:22:28.871]         base::close(...future.stdout)
[10:22:28.871]         ...future.stdout <- NULL
[10:22:28.871]     }
[10:22:28.871]     ...future.result$conditions <- ...future.conditions
[10:22:28.871]     ...future.result$finished <- base::Sys.time()
[10:22:28.871]     ...future.result
[10:22:28.871] }
[10:22:28.872] assign_globals() ...
[10:22:28.872] List of 1
[10:22:28.872]  $ kk: int 2
[10:22:28.872]  - attr(*, "where")=List of 1
[10:22:28.872]   ..$ kk:<environment: R_EmptyEnv> 
[10:22:28.872]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:28.872]  - attr(*, "resolved")= logi FALSE
[10:22:28.872]  - attr(*, "total_size")= num 35
[10:22:28.872]  - attr(*, "already-done")= logi TRUE
[10:22:28.875] - copied ‘kk’ to environment
[10:22:28.875] assign_globals() ... done
[10:22:28.875] plan(): Setting new future strategy stack:
[10:22:28.875] List of future strategies:
[10:22:28.875] 1. sequential:
[10:22:28.875]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:28.875]    - tweaked: FALSE
[10:22:28.875]    - call: NULL
[10:22:28.876] plan(): nbrOfWorkers() = 1
[10:22:28.977] plan(): Setting new future strategy stack:
[10:22:28.977] List of future strategies:
[10:22:28.977] 1. sequential:
[10:22:28.977]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:28.977]    - tweaked: FALSE
[10:22:28.977]    - call: plan(strategy)
[10:22:28.977] plan(): nbrOfWorkers() = 1
[10:22:28.977] SequentialFuture started (and completed)
[10:22:28.978] - Launch lazy future ... done
[10:22:28.978] run() for ‘SequentialFuture’ ... done
[10:22:28.978] resolved() for ‘SequentialFuture’ ...
[10:22:28.978] - state: ‘finished’
[10:22:28.978] - run: TRUE
[10:22:28.978] - result: ‘FutureResult’
[10:22:28.978] resolved() for ‘SequentialFuture’ ... done
[10:22:28.978] Future #2
[10:22:28.978]  length: 1 (resolved future 2)
[10:22:28.978] run() for ‘Future’ ...
[10:22:28.979] - state: ‘created’
[10:22:28.979] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:28.979] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:28.979] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:28.979]   - Field: ‘label’
[10:22:28.979]   - Field: ‘local’
[10:22:28.979]   - Field: ‘owner’
[10:22:28.979]   - Field: ‘envir’
[10:22:28.979]   - Field: ‘packages’
[10:22:28.980]   - Field: ‘gc’
[10:22:28.980]   - Field: ‘conditions’
[10:22:28.980]   - Field: ‘expr’
[10:22:28.980]   - Field: ‘uuid’
[10:22:28.980]   - Field: ‘seed’
[10:22:28.980]   - Field: ‘version’
[10:22:28.980]   - Field: ‘result’
[10:22:28.980]   - Field: ‘asynchronous’
[10:22:28.980]   - Field: ‘calls’
[10:22:28.980]   - Field: ‘globals’
[10:22:28.980]   - Field: ‘stdout’
[10:22:28.980]   - Field: ‘earlySignal’
[10:22:28.981]   - Field: ‘lazy’
[10:22:28.981]   - Field: ‘state’
[10:22:28.981] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:28.981] - Launch lazy future ...
[10:22:28.981] Packages needed by the future expression (n = 0): <none>
[10:22:28.981] Packages needed by future strategies (n = 0): <none>
[10:22:28.981] {
[10:22:28.981]     {
[10:22:28.981]         {
[10:22:28.981]             ...future.startTime <- base::Sys.time()
[10:22:28.981]             {
[10:22:28.981]                 {
[10:22:28.981]                   {
[10:22:28.981]                     base::local({
[10:22:28.981]                       has_future <- base::requireNamespace("future", 
[10:22:28.981]                         quietly = TRUE)
[10:22:28.981]                       if (has_future) {
[10:22:28.981]                         ns <- base::getNamespace("future")
[10:22:28.981]                         version <- ns[[".package"]][["version"]]
[10:22:28.981]                         if (is.null(version)) 
[10:22:28.981]                           version <- utils::packageVersion("future")
[10:22:28.981]                       }
[10:22:28.981]                       else {
[10:22:28.981]                         version <- NULL
[10:22:28.981]                       }
[10:22:28.981]                       if (!has_future || version < "1.8.0") {
[10:22:28.981]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:28.981]                           "", base::R.version$version.string), 
[10:22:28.981]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:28.981]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:28.981]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:28.981]                             "release", "version")], collapse = " "), 
[10:22:28.981]                           hostname = base::Sys.info()[["nodename"]])
[10:22:28.981]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:28.981]                           info)
[10:22:28.981]                         info <- base::paste(info, collapse = "; ")
[10:22:28.981]                         if (!has_future) {
[10:22:28.981]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:28.981]                             info)
[10:22:28.981]                         }
[10:22:28.981]                         else {
[10:22:28.981]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:28.981]                             info, version)
[10:22:28.981]                         }
[10:22:28.981]                         base::stop(msg)
[10:22:28.981]                       }
[10:22:28.981]                     })
[10:22:28.981]                   }
[10:22:28.981]                   ...future.strategy.old <- future::plan("list")
[10:22:28.981]                   options(future.plan = NULL)
[10:22:28.981]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:28.981]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:28.981]                 }
[10:22:28.981]                 ...future.workdir <- getwd()
[10:22:28.981]             }
[10:22:28.981]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:28.981]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:28.981]         }
[10:22:28.981]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:28.981]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:28.981]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:28.981]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:28.981]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:28.981]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:28.981]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:28.981]             base::names(...future.oldOptions))
[10:22:28.981]     }
[10:22:28.981]     if (FALSE) {
[10:22:28.981]     }
[10:22:28.981]     else {
[10:22:28.981]         if (TRUE) {
[10:22:28.981]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:28.981]                 open = "w")
[10:22:28.981]         }
[10:22:28.981]         else {
[10:22:28.981]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:28.981]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:28.981]         }
[10:22:28.981]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:28.981]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:28.981]             base::sink(type = "output", split = FALSE)
[10:22:28.981]             base::close(...future.stdout)
[10:22:28.981]         }, add = TRUE)
[10:22:28.981]     }
[10:22:28.981]     ...future.frame <- base::sys.nframe()
[10:22:28.981]     ...future.conditions <- base::list()
[10:22:28.981]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:28.981]     if (FALSE) {
[10:22:28.981]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:28.981]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:28.981]     }
[10:22:28.981]     ...future.result <- base::tryCatch({
[10:22:28.981]         base::withCallingHandlers({
[10:22:28.981]             ...future.value <- base::withVisible(base::local({
[10:22:28.981]                 Sys.sleep(0.1)
[10:22:28.981]                 kk
[10:22:28.981]             }))
[10:22:28.981]             future::FutureResult(value = ...future.value$value, 
[10:22:28.981]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:28.981]                   ...future.rng), globalenv = if (FALSE) 
[10:22:28.981]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:28.981]                     ...future.globalenv.names))
[10:22:28.981]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:28.981]         }, condition = base::local({
[10:22:28.981]             c <- base::c
[10:22:28.981]             inherits <- base::inherits
[10:22:28.981]             invokeRestart <- base::invokeRestart
[10:22:28.981]             length <- base::length
[10:22:28.981]             list <- base::list
[10:22:28.981]             seq.int <- base::seq.int
[10:22:28.981]             signalCondition <- base::signalCondition
[10:22:28.981]             sys.calls <- base::sys.calls
[10:22:28.981]             `[[` <- base::`[[`
[10:22:28.981]             `+` <- base::`+`
[10:22:28.981]             `<<-` <- base::`<<-`
[10:22:28.981]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:28.981]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:28.981]                   3L)]
[10:22:28.981]             }
[10:22:28.981]             function(cond) {
[10:22:28.981]                 is_error <- inherits(cond, "error")
[10:22:28.981]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:28.981]                   NULL)
[10:22:28.981]                 if (is_error) {
[10:22:28.981]                   sessionInformation <- function() {
[10:22:28.981]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:28.981]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:28.981]                       search = base::search(), system = base::Sys.info())
[10:22:28.981]                   }
[10:22:28.981]                   ...future.conditions[[length(...future.conditions) + 
[10:22:28.981]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:28.981]                     cond$call), session = sessionInformation(), 
[10:22:28.981]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:28.981]                   signalCondition(cond)
[10:22:28.981]                 }
[10:22:28.981]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:28.981]                 "immediateCondition"))) {
[10:22:28.981]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:28.981]                   ...future.conditions[[length(...future.conditions) + 
[10:22:28.981]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:28.981]                   if (TRUE && !signal) {
[10:22:28.981]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:28.981]                     {
[10:22:28.981]                       inherits <- base::inherits
[10:22:28.981]                       invokeRestart <- base::invokeRestart
[10:22:28.981]                       is.null <- base::is.null
[10:22:28.981]                       muffled <- FALSE
[10:22:28.981]                       if (inherits(cond, "message")) {
[10:22:28.981]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:28.981]                         if (muffled) 
[10:22:28.981]                           invokeRestart("muffleMessage")
[10:22:28.981]                       }
[10:22:28.981]                       else if (inherits(cond, "warning")) {
[10:22:28.981]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:28.981]                         if (muffled) 
[10:22:28.981]                           invokeRestart("muffleWarning")
[10:22:28.981]                       }
[10:22:28.981]                       else if (inherits(cond, "condition")) {
[10:22:28.981]                         if (!is.null(pattern)) {
[10:22:28.981]                           computeRestarts <- base::computeRestarts
[10:22:28.981]                           grepl <- base::grepl
[10:22:28.981]                           restarts <- computeRestarts(cond)
[10:22:28.981]                           for (restart in restarts) {
[10:22:28.981]                             name <- restart$name
[10:22:28.981]                             if (is.null(name)) 
[10:22:28.981]                               next
[10:22:28.981]                             if (!grepl(pattern, name)) 
[10:22:28.981]                               next
[10:22:28.981]                             invokeRestart(restart)
[10:22:28.981]                             muffled <- TRUE
[10:22:28.981]                             break
[10:22:28.981]                           }
[10:22:28.981]                         }
[10:22:28.981]                       }
[10:22:28.981]                       invisible(muffled)
[10:22:28.981]                     }
[10:22:28.981]                     muffleCondition(cond, pattern = "^muffle")
[10:22:28.981]                   }
[10:22:28.981]                 }
[10:22:28.981]                 else {
[10:22:28.981]                   if (TRUE) {
[10:22:28.981]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:28.981]                     {
[10:22:28.981]                       inherits <- base::inherits
[10:22:28.981]                       invokeRestart <- base::invokeRestart
[10:22:28.981]                       is.null <- base::is.null
[10:22:28.981]                       muffled <- FALSE
[10:22:28.981]                       if (inherits(cond, "message")) {
[10:22:28.981]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:28.981]                         if (muffled) 
[10:22:28.981]                           invokeRestart("muffleMessage")
[10:22:28.981]                       }
[10:22:28.981]                       else if (inherits(cond, "warning")) {
[10:22:28.981]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:28.981]                         if (muffled) 
[10:22:28.981]                           invokeRestart("muffleWarning")
[10:22:28.981]                       }
[10:22:28.981]                       else if (inherits(cond, "condition")) {
[10:22:28.981]                         if (!is.null(pattern)) {
[10:22:28.981]                           computeRestarts <- base::computeRestarts
[10:22:28.981]                           grepl <- base::grepl
[10:22:28.981]                           restarts <- computeRestarts(cond)
[10:22:28.981]                           for (restart in restarts) {
[10:22:28.981]                             name <- restart$name
[10:22:28.981]                             if (is.null(name)) 
[10:22:28.981]                               next
[10:22:28.981]                             if (!grepl(pattern, name)) 
[10:22:28.981]                               next
[10:22:28.981]                             invokeRestart(restart)
[10:22:28.981]                             muffled <- TRUE
[10:22:28.981]                             break
[10:22:28.981]                           }
[10:22:28.981]                         }
[10:22:28.981]                       }
[10:22:28.981]                       invisible(muffled)
[10:22:28.981]                     }
[10:22:28.981]                     muffleCondition(cond, pattern = "^muffle")
[10:22:28.981]                   }
[10:22:28.981]                 }
[10:22:28.981]             }
[10:22:28.981]         }))
[10:22:28.981]     }, error = function(ex) {
[10:22:28.981]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:28.981]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:28.981]                 ...future.rng), started = ...future.startTime, 
[10:22:28.981]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:28.981]             version = "1.8"), class = "FutureResult")
[10:22:28.981]     }, finally = {
[10:22:28.981]         if (!identical(...future.workdir, getwd())) 
[10:22:28.981]             setwd(...future.workdir)
[10:22:28.981]         {
[10:22:28.981]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:28.981]                 ...future.oldOptions$nwarnings <- NULL
[10:22:28.981]             }
[10:22:28.981]             base::options(...future.oldOptions)
[10:22:28.981]             if (.Platform$OS.type == "windows") {
[10:22:28.981]                 old_names <- names(...future.oldEnvVars)
[10:22:28.981]                 envs <- base::Sys.getenv()
[10:22:28.981]                 names <- names(envs)
[10:22:28.981]                 common <- intersect(names, old_names)
[10:22:28.981]                 added <- setdiff(names, old_names)
[10:22:28.981]                 removed <- setdiff(old_names, names)
[10:22:28.981]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:28.981]                   envs[common]]
[10:22:28.981]                 NAMES <- toupper(changed)
[10:22:28.981]                 args <- list()
[10:22:28.981]                 for (kk in seq_along(NAMES)) {
[10:22:28.981]                   name <- changed[[kk]]
[10:22:28.981]                   NAME <- NAMES[[kk]]
[10:22:28.981]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:28.981]                     next
[10:22:28.981]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:28.981]                 }
[10:22:28.981]                 NAMES <- toupper(added)
[10:22:28.981]                 for (kk in seq_along(NAMES)) {
[10:22:28.981]                   name <- added[[kk]]
[10:22:28.981]                   NAME <- NAMES[[kk]]
[10:22:28.981]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:28.981]                     next
[10:22:28.981]                   args[[name]] <- ""
[10:22:28.981]                 }
[10:22:28.981]                 NAMES <- toupper(removed)
[10:22:28.981]                 for (kk in seq_along(NAMES)) {
[10:22:28.981]                   name <- removed[[kk]]
[10:22:28.981]                   NAME <- NAMES[[kk]]
[10:22:28.981]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:28.981]                     next
[10:22:28.981]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:28.981]                 }
[10:22:28.981]                 if (length(args) > 0) 
[10:22:28.981]                   base::do.call(base::Sys.setenv, args = args)
[10:22:28.981]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:28.981]             }
[10:22:28.981]             else {
[10:22:28.981]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:28.981]             }
[10:22:28.981]             {
[10:22:28.981]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:28.981]                   0L) {
[10:22:28.981]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:28.981]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:28.981]                   base::options(opts)
[10:22:28.981]                 }
[10:22:28.981]                 {
[10:22:28.981]                   {
[10:22:28.981]                     NULL
[10:22:28.981]                     RNGkind("Mersenne-Twister")
[10:22:28.981]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:28.981]                       inherits = FALSE)
[10:22:28.981]                   }
[10:22:28.981]                   options(future.plan = NULL)
[10:22:28.981]                   if (is.na(NA_character_)) 
[10:22:28.981]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:28.981]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:28.981]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:28.981]                     .init = FALSE)
[10:22:28.981]                 }
[10:22:28.981]             }
[10:22:28.981]         }
[10:22:28.981]     })
[10:22:28.981]     if (TRUE) {
[10:22:28.981]         base::sink(type = "output", split = FALSE)
[10:22:28.981]         if (TRUE) {
[10:22:28.981]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:28.981]         }
[10:22:28.981]         else {
[10:22:28.981]             ...future.result["stdout"] <- base::list(NULL)
[10:22:28.981]         }
[10:22:28.981]         base::close(...future.stdout)
[10:22:28.981]         ...future.stdout <- NULL
[10:22:28.981]     }
[10:22:28.981]     ...future.result$conditions <- ...future.conditions
[10:22:28.981]     ...future.result$finished <- base::Sys.time()
[10:22:28.981]     ...future.result
[10:22:28.981] }
[10:22:28.983] assign_globals() ...
[10:22:28.983] List of 1
[10:22:28.983]  $ kk: int 3
[10:22:28.983]  - attr(*, "where")=List of 1
[10:22:28.983]   ..$ kk:<environment: R_EmptyEnv> 
[10:22:28.983]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:28.983]  - attr(*, "resolved")= logi FALSE
[10:22:28.983]  - attr(*, "total_size")= num 35
[10:22:28.983]  - attr(*, "already-done")= logi TRUE
[10:22:28.986] - copied ‘kk’ to environment
[10:22:28.986] assign_globals() ... done
[10:22:28.986] plan(): Setting new future strategy stack:
[10:22:28.986] List of future strategies:
[10:22:28.986] 1. sequential:
[10:22:28.986]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:28.986]    - tweaked: FALSE
[10:22:28.986]    - call: NULL
[10:22:28.988] plan(): nbrOfWorkers() = 1
[10:22:29.089] plan(): Setting new future strategy stack:
[10:22:29.089] List of future strategies:
[10:22:29.089] 1. sequential:
[10:22:29.089]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:29.089]    - tweaked: FALSE
[10:22:29.089]    - call: plan(strategy)
[10:22:29.090] plan(): nbrOfWorkers() = 1
[10:22:29.090] SequentialFuture started (and completed)
[10:22:29.090] - Launch lazy future ... done
[10:22:29.090] run() for ‘SequentialFuture’ ... done
[10:22:29.090] resolved() for ‘SequentialFuture’ ...
[10:22:29.090] - state: ‘finished’
[10:22:29.090] - run: TRUE
[10:22:29.090] - result: ‘FutureResult’
[10:22:29.091] resolved() for ‘SequentialFuture’ ... done
[10:22:29.091] Future #3
[10:22:29.091]  length: 0 (resolved future 3)
[10:22:29.091] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[10:22:29.092] resolve() on environment ...
[10:22:29.092]  recursive: 0
[10:22:29.093]  elements: [2] ‘a’, ‘b’
[10:22:29.093]  length: 1 (resolved future 1)
[10:22:29.093]  length: 0 (resolved future 2)
[10:22:29.093] resolve() on environment ... DONE
[10:22:29.093] getGlobalsAndPackages() ...
[10:22:29.094] Searching for globals...
[10:22:29.094] 
[10:22:29.094] Searching for globals ... DONE
[10:22:29.094] - globals: [0] <none>
[10:22:29.094] getGlobalsAndPackages() ... DONE
[10:22:29.094] run() for ‘Future’ ...
[10:22:29.094] - state: ‘created’
[10:22:29.095] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:29.095] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:29.095] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:29.095]   - Field: ‘label’
[10:22:29.095]   - Field: ‘local’
[10:22:29.095]   - Field: ‘owner’
[10:22:29.095]   - Field: ‘envir’
[10:22:29.095]   - Field: ‘packages’
[10:22:29.096]   - Field: ‘gc’
[10:22:29.096]   - Field: ‘conditions’
[10:22:29.096]   - Field: ‘expr’
[10:22:29.096]   - Field: ‘uuid’
[10:22:29.096]   - Field: ‘seed’
[10:22:29.096]   - Field: ‘version’
[10:22:29.096]   - Field: ‘result’
[10:22:29.096]   - Field: ‘asynchronous’
[10:22:29.096]   - Field: ‘calls’
[10:22:29.096]   - Field: ‘globals’
[10:22:29.096]   - Field: ‘stdout’
[10:22:29.096]   - Field: ‘earlySignal’
[10:22:29.097]   - Field: ‘lazy’
[10:22:29.097]   - Field: ‘state’
[10:22:29.097] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:29.097] - Launch lazy future ...
[10:22:29.097] Packages needed by the future expression (n = 0): <none>
[10:22:29.097] Packages needed by future strategies (n = 0): <none>
[10:22:29.098] {
[10:22:29.098]     {
[10:22:29.098]         {
[10:22:29.098]             ...future.startTime <- base::Sys.time()
[10:22:29.098]             {
[10:22:29.098]                 {
[10:22:29.098]                   {
[10:22:29.098]                     base::local({
[10:22:29.098]                       has_future <- base::requireNamespace("future", 
[10:22:29.098]                         quietly = TRUE)
[10:22:29.098]                       if (has_future) {
[10:22:29.098]                         ns <- base::getNamespace("future")
[10:22:29.098]                         version <- ns[[".package"]][["version"]]
[10:22:29.098]                         if (is.null(version)) 
[10:22:29.098]                           version <- utils::packageVersion("future")
[10:22:29.098]                       }
[10:22:29.098]                       else {
[10:22:29.098]                         version <- NULL
[10:22:29.098]                       }
[10:22:29.098]                       if (!has_future || version < "1.8.0") {
[10:22:29.098]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:29.098]                           "", base::R.version$version.string), 
[10:22:29.098]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:29.098]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:29.098]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:29.098]                             "release", "version")], collapse = " "), 
[10:22:29.098]                           hostname = base::Sys.info()[["nodename"]])
[10:22:29.098]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:29.098]                           info)
[10:22:29.098]                         info <- base::paste(info, collapse = "; ")
[10:22:29.098]                         if (!has_future) {
[10:22:29.098]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:29.098]                             info)
[10:22:29.098]                         }
[10:22:29.098]                         else {
[10:22:29.098]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:29.098]                             info, version)
[10:22:29.098]                         }
[10:22:29.098]                         base::stop(msg)
[10:22:29.098]                       }
[10:22:29.098]                     })
[10:22:29.098]                   }
[10:22:29.098]                   ...future.strategy.old <- future::plan("list")
[10:22:29.098]                   options(future.plan = NULL)
[10:22:29.098]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:29.098]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:29.098]                 }
[10:22:29.098]                 ...future.workdir <- getwd()
[10:22:29.098]             }
[10:22:29.098]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:29.098]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:29.098]         }
[10:22:29.098]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:29.098]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:29.098]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:29.098]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:29.098]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:29.098]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:29.098]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:29.098]             base::names(...future.oldOptions))
[10:22:29.098]     }
[10:22:29.098]     if (FALSE) {
[10:22:29.098]     }
[10:22:29.098]     else {
[10:22:29.098]         if (TRUE) {
[10:22:29.098]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:29.098]                 open = "w")
[10:22:29.098]         }
[10:22:29.098]         else {
[10:22:29.098]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:29.098]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:29.098]         }
[10:22:29.098]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:29.098]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:29.098]             base::sink(type = "output", split = FALSE)
[10:22:29.098]             base::close(...future.stdout)
[10:22:29.098]         }, add = TRUE)
[10:22:29.098]     }
[10:22:29.098]     ...future.frame <- base::sys.nframe()
[10:22:29.098]     ...future.conditions <- base::list()
[10:22:29.098]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:29.098]     if (FALSE) {
[10:22:29.098]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:29.098]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:29.098]     }
[10:22:29.098]     ...future.result <- base::tryCatch({
[10:22:29.098]         base::withCallingHandlers({
[10:22:29.098]             ...future.value <- base::withVisible(base::local(1))
[10:22:29.098]             future::FutureResult(value = ...future.value$value, 
[10:22:29.098]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:29.098]                   ...future.rng), globalenv = if (FALSE) 
[10:22:29.098]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:29.098]                     ...future.globalenv.names))
[10:22:29.098]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:29.098]         }, condition = base::local({
[10:22:29.098]             c <- base::c
[10:22:29.098]             inherits <- base::inherits
[10:22:29.098]             invokeRestart <- base::invokeRestart
[10:22:29.098]             length <- base::length
[10:22:29.098]             list <- base::list
[10:22:29.098]             seq.int <- base::seq.int
[10:22:29.098]             signalCondition <- base::signalCondition
[10:22:29.098]             sys.calls <- base::sys.calls
[10:22:29.098]             `[[` <- base::`[[`
[10:22:29.098]             `+` <- base::`+`
[10:22:29.098]             `<<-` <- base::`<<-`
[10:22:29.098]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:29.098]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:29.098]                   3L)]
[10:22:29.098]             }
[10:22:29.098]             function(cond) {
[10:22:29.098]                 is_error <- inherits(cond, "error")
[10:22:29.098]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:29.098]                   NULL)
[10:22:29.098]                 if (is_error) {
[10:22:29.098]                   sessionInformation <- function() {
[10:22:29.098]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:29.098]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:29.098]                       search = base::search(), system = base::Sys.info())
[10:22:29.098]                   }
[10:22:29.098]                   ...future.conditions[[length(...future.conditions) + 
[10:22:29.098]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:29.098]                     cond$call), session = sessionInformation(), 
[10:22:29.098]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:29.098]                   signalCondition(cond)
[10:22:29.098]                 }
[10:22:29.098]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:29.098]                 "immediateCondition"))) {
[10:22:29.098]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:29.098]                   ...future.conditions[[length(...future.conditions) + 
[10:22:29.098]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:29.098]                   if (TRUE && !signal) {
[10:22:29.098]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.098]                     {
[10:22:29.098]                       inherits <- base::inherits
[10:22:29.098]                       invokeRestart <- base::invokeRestart
[10:22:29.098]                       is.null <- base::is.null
[10:22:29.098]                       muffled <- FALSE
[10:22:29.098]                       if (inherits(cond, "message")) {
[10:22:29.098]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:29.098]                         if (muffled) 
[10:22:29.098]                           invokeRestart("muffleMessage")
[10:22:29.098]                       }
[10:22:29.098]                       else if (inherits(cond, "warning")) {
[10:22:29.098]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:29.098]                         if (muffled) 
[10:22:29.098]                           invokeRestart("muffleWarning")
[10:22:29.098]                       }
[10:22:29.098]                       else if (inherits(cond, "condition")) {
[10:22:29.098]                         if (!is.null(pattern)) {
[10:22:29.098]                           computeRestarts <- base::computeRestarts
[10:22:29.098]                           grepl <- base::grepl
[10:22:29.098]                           restarts <- computeRestarts(cond)
[10:22:29.098]                           for (restart in restarts) {
[10:22:29.098]                             name <- restart$name
[10:22:29.098]                             if (is.null(name)) 
[10:22:29.098]                               next
[10:22:29.098]                             if (!grepl(pattern, name)) 
[10:22:29.098]                               next
[10:22:29.098]                             invokeRestart(restart)
[10:22:29.098]                             muffled <- TRUE
[10:22:29.098]                             break
[10:22:29.098]                           }
[10:22:29.098]                         }
[10:22:29.098]                       }
[10:22:29.098]                       invisible(muffled)
[10:22:29.098]                     }
[10:22:29.098]                     muffleCondition(cond, pattern = "^muffle")
[10:22:29.098]                   }
[10:22:29.098]                 }
[10:22:29.098]                 else {
[10:22:29.098]                   if (TRUE) {
[10:22:29.098]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.098]                     {
[10:22:29.098]                       inherits <- base::inherits
[10:22:29.098]                       invokeRestart <- base::invokeRestart
[10:22:29.098]                       is.null <- base::is.null
[10:22:29.098]                       muffled <- FALSE
[10:22:29.098]                       if (inherits(cond, "message")) {
[10:22:29.098]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:29.098]                         if (muffled) 
[10:22:29.098]                           invokeRestart("muffleMessage")
[10:22:29.098]                       }
[10:22:29.098]                       else if (inherits(cond, "warning")) {
[10:22:29.098]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:29.098]                         if (muffled) 
[10:22:29.098]                           invokeRestart("muffleWarning")
[10:22:29.098]                       }
[10:22:29.098]                       else if (inherits(cond, "condition")) {
[10:22:29.098]                         if (!is.null(pattern)) {
[10:22:29.098]                           computeRestarts <- base::computeRestarts
[10:22:29.098]                           grepl <- base::grepl
[10:22:29.098]                           restarts <- computeRestarts(cond)
[10:22:29.098]                           for (restart in restarts) {
[10:22:29.098]                             name <- restart$name
[10:22:29.098]                             if (is.null(name)) 
[10:22:29.098]                               next
[10:22:29.098]                             if (!grepl(pattern, name)) 
[10:22:29.098]                               next
[10:22:29.098]                             invokeRestart(restart)
[10:22:29.098]                             muffled <- TRUE
[10:22:29.098]                             break
[10:22:29.098]                           }
[10:22:29.098]                         }
[10:22:29.098]                       }
[10:22:29.098]                       invisible(muffled)
[10:22:29.098]                     }
[10:22:29.098]                     muffleCondition(cond, pattern = "^muffle")
[10:22:29.098]                   }
[10:22:29.098]                 }
[10:22:29.098]             }
[10:22:29.098]         }))
[10:22:29.098]     }, error = function(ex) {
[10:22:29.098]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:29.098]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:29.098]                 ...future.rng), started = ...future.startTime, 
[10:22:29.098]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:29.098]             version = "1.8"), class = "FutureResult")
[10:22:29.098]     }, finally = {
[10:22:29.098]         if (!identical(...future.workdir, getwd())) 
[10:22:29.098]             setwd(...future.workdir)
[10:22:29.098]         {
[10:22:29.098]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:29.098]                 ...future.oldOptions$nwarnings <- NULL
[10:22:29.098]             }
[10:22:29.098]             base::options(...future.oldOptions)
[10:22:29.098]             if (.Platform$OS.type == "windows") {
[10:22:29.098]                 old_names <- names(...future.oldEnvVars)
[10:22:29.098]                 envs <- base::Sys.getenv()
[10:22:29.098]                 names <- names(envs)
[10:22:29.098]                 common <- intersect(names, old_names)
[10:22:29.098]                 added <- setdiff(names, old_names)
[10:22:29.098]                 removed <- setdiff(old_names, names)
[10:22:29.098]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:29.098]                   envs[common]]
[10:22:29.098]                 NAMES <- toupper(changed)
[10:22:29.098]                 args <- list()
[10:22:29.098]                 for (kk in seq_along(NAMES)) {
[10:22:29.098]                   name <- changed[[kk]]
[10:22:29.098]                   NAME <- NAMES[[kk]]
[10:22:29.098]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.098]                     next
[10:22:29.098]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:29.098]                 }
[10:22:29.098]                 NAMES <- toupper(added)
[10:22:29.098]                 for (kk in seq_along(NAMES)) {
[10:22:29.098]                   name <- added[[kk]]
[10:22:29.098]                   NAME <- NAMES[[kk]]
[10:22:29.098]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.098]                     next
[10:22:29.098]                   args[[name]] <- ""
[10:22:29.098]                 }
[10:22:29.098]                 NAMES <- toupper(removed)
[10:22:29.098]                 for (kk in seq_along(NAMES)) {
[10:22:29.098]                   name <- removed[[kk]]
[10:22:29.098]                   NAME <- NAMES[[kk]]
[10:22:29.098]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.098]                     next
[10:22:29.098]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:29.098]                 }
[10:22:29.098]                 if (length(args) > 0) 
[10:22:29.098]                   base::do.call(base::Sys.setenv, args = args)
[10:22:29.098]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:29.098]             }
[10:22:29.098]             else {
[10:22:29.098]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:29.098]             }
[10:22:29.098]             {
[10:22:29.098]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:29.098]                   0L) {
[10:22:29.098]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:29.098]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:29.098]                   base::options(opts)
[10:22:29.098]                 }
[10:22:29.098]                 {
[10:22:29.098]                   {
[10:22:29.098]                     NULL
[10:22:29.098]                     RNGkind("Mersenne-Twister")
[10:22:29.098]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:29.098]                       inherits = FALSE)
[10:22:29.098]                   }
[10:22:29.098]                   options(future.plan = NULL)
[10:22:29.098]                   if (is.na(NA_character_)) 
[10:22:29.098]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:29.098]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:29.098]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:29.098]                     .init = FALSE)
[10:22:29.098]                 }
[10:22:29.098]             }
[10:22:29.098]         }
[10:22:29.098]     })
[10:22:29.098]     if (TRUE) {
[10:22:29.098]         base::sink(type = "output", split = FALSE)
[10:22:29.098]         if (TRUE) {
[10:22:29.098]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:29.098]         }
[10:22:29.098]         else {
[10:22:29.098]             ...future.result["stdout"] <- base::list(NULL)
[10:22:29.098]         }
[10:22:29.098]         base::close(...future.stdout)
[10:22:29.098]         ...future.stdout <- NULL
[10:22:29.098]     }
[10:22:29.098]     ...future.result$conditions <- ...future.conditions
[10:22:29.098]     ...future.result$finished <- base::Sys.time()
[10:22:29.098]     ...future.result
[10:22:29.098] }
[10:22:29.099] plan(): Setting new future strategy stack:
[10:22:29.099] List of future strategies:
[10:22:29.099] 1. sequential:
[10:22:29.099]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:29.099]    - tweaked: FALSE
[10:22:29.099]    - call: NULL
[10:22:29.100] plan(): nbrOfWorkers() = 1
[10:22:29.101] plan(): Setting new future strategy stack:
[10:22:29.101] List of future strategies:
[10:22:29.101] 1. sequential:
[10:22:29.101]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:29.101]    - tweaked: FALSE
[10:22:29.101]    - call: plan(strategy)
[10:22:29.101] plan(): nbrOfWorkers() = 1
[10:22:29.101] SequentialFuture started (and completed)
[10:22:29.101] - Launch lazy future ... done
[10:22:29.101] run() for ‘SequentialFuture’ ... done
[10:22:29.102] getGlobalsAndPackages() ...
[10:22:29.102] Searching for globals...
[10:22:29.102] 
[10:22:29.102] Searching for globals ... DONE
[10:22:29.102] - globals: [0] <none>
[10:22:29.102] getGlobalsAndPackages() ... DONE
[10:22:29.102] run() for ‘Future’ ...
[10:22:29.103] - state: ‘created’
[10:22:29.103] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:29.103] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:29.103] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:29.103]   - Field: ‘label’
[10:22:29.103]   - Field: ‘local’
[10:22:29.103]   - Field: ‘owner’
[10:22:29.103]   - Field: ‘envir’
[10:22:29.103]   - Field: ‘packages’
[10:22:29.104]   - Field: ‘gc’
[10:22:29.104]   - Field: ‘conditions’
[10:22:29.104]   - Field: ‘expr’
[10:22:29.104]   - Field: ‘uuid’
[10:22:29.104]   - Field: ‘seed’
[10:22:29.104]   - Field: ‘version’
[10:22:29.104]   - Field: ‘result’
[10:22:29.104]   - Field: ‘asynchronous’
[10:22:29.104]   - Field: ‘calls’
[10:22:29.104]   - Field: ‘globals’
[10:22:29.104]   - Field: ‘stdout’
[10:22:29.105]   - Field: ‘earlySignal’
[10:22:29.105]   - Field: ‘lazy’
[10:22:29.105]   - Field: ‘state’
[10:22:29.105] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:29.105] - Launch lazy future ...
[10:22:29.105] Packages needed by the future expression (n = 0): <none>
[10:22:29.105] Packages needed by future strategies (n = 0): <none>
[10:22:29.106] {
[10:22:29.106]     {
[10:22:29.106]         {
[10:22:29.106]             ...future.startTime <- base::Sys.time()
[10:22:29.106]             {
[10:22:29.106]                 {
[10:22:29.106]                   {
[10:22:29.106]                     base::local({
[10:22:29.106]                       has_future <- base::requireNamespace("future", 
[10:22:29.106]                         quietly = TRUE)
[10:22:29.106]                       if (has_future) {
[10:22:29.106]                         ns <- base::getNamespace("future")
[10:22:29.106]                         version <- ns[[".package"]][["version"]]
[10:22:29.106]                         if (is.null(version)) 
[10:22:29.106]                           version <- utils::packageVersion("future")
[10:22:29.106]                       }
[10:22:29.106]                       else {
[10:22:29.106]                         version <- NULL
[10:22:29.106]                       }
[10:22:29.106]                       if (!has_future || version < "1.8.0") {
[10:22:29.106]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:29.106]                           "", base::R.version$version.string), 
[10:22:29.106]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:29.106]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:29.106]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:29.106]                             "release", "version")], collapse = " "), 
[10:22:29.106]                           hostname = base::Sys.info()[["nodename"]])
[10:22:29.106]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:29.106]                           info)
[10:22:29.106]                         info <- base::paste(info, collapse = "; ")
[10:22:29.106]                         if (!has_future) {
[10:22:29.106]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:29.106]                             info)
[10:22:29.106]                         }
[10:22:29.106]                         else {
[10:22:29.106]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:29.106]                             info, version)
[10:22:29.106]                         }
[10:22:29.106]                         base::stop(msg)
[10:22:29.106]                       }
[10:22:29.106]                     })
[10:22:29.106]                   }
[10:22:29.106]                   ...future.strategy.old <- future::plan("list")
[10:22:29.106]                   options(future.plan = NULL)
[10:22:29.106]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:29.106]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:29.106]                 }
[10:22:29.106]                 ...future.workdir <- getwd()
[10:22:29.106]             }
[10:22:29.106]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:29.106]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:29.106]         }
[10:22:29.106]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:29.106]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:29.106]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:29.106]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:29.106]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:29.106]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:29.106]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:29.106]             base::names(...future.oldOptions))
[10:22:29.106]     }
[10:22:29.106]     if (FALSE) {
[10:22:29.106]     }
[10:22:29.106]     else {
[10:22:29.106]         if (TRUE) {
[10:22:29.106]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:29.106]                 open = "w")
[10:22:29.106]         }
[10:22:29.106]         else {
[10:22:29.106]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:29.106]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:29.106]         }
[10:22:29.106]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:29.106]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:29.106]             base::sink(type = "output", split = FALSE)
[10:22:29.106]             base::close(...future.stdout)
[10:22:29.106]         }, add = TRUE)
[10:22:29.106]     }
[10:22:29.106]     ...future.frame <- base::sys.nframe()
[10:22:29.106]     ...future.conditions <- base::list()
[10:22:29.106]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:29.106]     if (FALSE) {
[10:22:29.106]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:29.106]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:29.106]     }
[10:22:29.106]     ...future.result <- base::tryCatch({
[10:22:29.106]         base::withCallingHandlers({
[10:22:29.106]             ...future.value <- base::withVisible(base::local(2))
[10:22:29.106]             future::FutureResult(value = ...future.value$value, 
[10:22:29.106]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:29.106]                   ...future.rng), globalenv = if (FALSE) 
[10:22:29.106]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:29.106]                     ...future.globalenv.names))
[10:22:29.106]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:29.106]         }, condition = base::local({
[10:22:29.106]             c <- base::c
[10:22:29.106]             inherits <- base::inherits
[10:22:29.106]             invokeRestart <- base::invokeRestart
[10:22:29.106]             length <- base::length
[10:22:29.106]             list <- base::list
[10:22:29.106]             seq.int <- base::seq.int
[10:22:29.106]             signalCondition <- base::signalCondition
[10:22:29.106]             sys.calls <- base::sys.calls
[10:22:29.106]             `[[` <- base::`[[`
[10:22:29.106]             `+` <- base::`+`
[10:22:29.106]             `<<-` <- base::`<<-`
[10:22:29.106]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:29.106]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:29.106]                   3L)]
[10:22:29.106]             }
[10:22:29.106]             function(cond) {
[10:22:29.106]                 is_error <- inherits(cond, "error")
[10:22:29.106]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:29.106]                   NULL)
[10:22:29.106]                 if (is_error) {
[10:22:29.106]                   sessionInformation <- function() {
[10:22:29.106]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:29.106]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:29.106]                       search = base::search(), system = base::Sys.info())
[10:22:29.106]                   }
[10:22:29.106]                   ...future.conditions[[length(...future.conditions) + 
[10:22:29.106]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:29.106]                     cond$call), session = sessionInformation(), 
[10:22:29.106]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:29.106]                   signalCondition(cond)
[10:22:29.106]                 }
[10:22:29.106]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:29.106]                 "immediateCondition"))) {
[10:22:29.106]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:29.106]                   ...future.conditions[[length(...future.conditions) + 
[10:22:29.106]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:29.106]                   if (TRUE && !signal) {
[10:22:29.106]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.106]                     {
[10:22:29.106]                       inherits <- base::inherits
[10:22:29.106]                       invokeRestart <- base::invokeRestart
[10:22:29.106]                       is.null <- base::is.null
[10:22:29.106]                       muffled <- FALSE
[10:22:29.106]                       if (inherits(cond, "message")) {
[10:22:29.106]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:29.106]                         if (muffled) 
[10:22:29.106]                           invokeRestart("muffleMessage")
[10:22:29.106]                       }
[10:22:29.106]                       else if (inherits(cond, "warning")) {
[10:22:29.106]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:29.106]                         if (muffled) 
[10:22:29.106]                           invokeRestart("muffleWarning")
[10:22:29.106]                       }
[10:22:29.106]                       else if (inherits(cond, "condition")) {
[10:22:29.106]                         if (!is.null(pattern)) {
[10:22:29.106]                           computeRestarts <- base::computeRestarts
[10:22:29.106]                           grepl <- base::grepl
[10:22:29.106]                           restarts <- computeRestarts(cond)
[10:22:29.106]                           for (restart in restarts) {
[10:22:29.106]                             name <- restart$name
[10:22:29.106]                             if (is.null(name)) 
[10:22:29.106]                               next
[10:22:29.106]                             if (!grepl(pattern, name)) 
[10:22:29.106]                               next
[10:22:29.106]                             invokeRestart(restart)
[10:22:29.106]                             muffled <- TRUE
[10:22:29.106]                             break
[10:22:29.106]                           }
[10:22:29.106]                         }
[10:22:29.106]                       }
[10:22:29.106]                       invisible(muffled)
[10:22:29.106]                     }
[10:22:29.106]                     muffleCondition(cond, pattern = "^muffle")
[10:22:29.106]                   }
[10:22:29.106]                 }
[10:22:29.106]                 else {
[10:22:29.106]                   if (TRUE) {
[10:22:29.106]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.106]                     {
[10:22:29.106]                       inherits <- base::inherits
[10:22:29.106]                       invokeRestart <- base::invokeRestart
[10:22:29.106]                       is.null <- base::is.null
[10:22:29.106]                       muffled <- FALSE
[10:22:29.106]                       if (inherits(cond, "message")) {
[10:22:29.106]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:29.106]                         if (muffled) 
[10:22:29.106]                           invokeRestart("muffleMessage")
[10:22:29.106]                       }
[10:22:29.106]                       else if (inherits(cond, "warning")) {
[10:22:29.106]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:29.106]                         if (muffled) 
[10:22:29.106]                           invokeRestart("muffleWarning")
[10:22:29.106]                       }
[10:22:29.106]                       else if (inherits(cond, "condition")) {
[10:22:29.106]                         if (!is.null(pattern)) {
[10:22:29.106]                           computeRestarts <- base::computeRestarts
[10:22:29.106]                           grepl <- base::grepl
[10:22:29.106]                           restarts <- computeRestarts(cond)
[10:22:29.106]                           for (restart in restarts) {
[10:22:29.106]                             name <- restart$name
[10:22:29.106]                             if (is.null(name)) 
[10:22:29.106]                               next
[10:22:29.106]                             if (!grepl(pattern, name)) 
[10:22:29.106]                               next
[10:22:29.106]                             invokeRestart(restart)
[10:22:29.106]                             muffled <- TRUE
[10:22:29.106]                             break
[10:22:29.106]                           }
[10:22:29.106]                         }
[10:22:29.106]                       }
[10:22:29.106]                       invisible(muffled)
[10:22:29.106]                     }
[10:22:29.106]                     muffleCondition(cond, pattern = "^muffle")
[10:22:29.106]                   }
[10:22:29.106]                 }
[10:22:29.106]             }
[10:22:29.106]         }))
[10:22:29.106]     }, error = function(ex) {
[10:22:29.106]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:29.106]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:29.106]                 ...future.rng), started = ...future.startTime, 
[10:22:29.106]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:29.106]             version = "1.8"), class = "FutureResult")
[10:22:29.106]     }, finally = {
[10:22:29.106]         if (!identical(...future.workdir, getwd())) 
[10:22:29.106]             setwd(...future.workdir)
[10:22:29.106]         {
[10:22:29.106]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:29.106]                 ...future.oldOptions$nwarnings <- NULL
[10:22:29.106]             }
[10:22:29.106]             base::options(...future.oldOptions)
[10:22:29.106]             if (.Platform$OS.type == "windows") {
[10:22:29.106]                 old_names <- names(...future.oldEnvVars)
[10:22:29.106]                 envs <- base::Sys.getenv()
[10:22:29.106]                 names <- names(envs)
[10:22:29.106]                 common <- intersect(names, old_names)
[10:22:29.106]                 added <- setdiff(names, old_names)
[10:22:29.106]                 removed <- setdiff(old_names, names)
[10:22:29.106]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:29.106]                   envs[common]]
[10:22:29.106]                 NAMES <- toupper(changed)
[10:22:29.106]                 args <- list()
[10:22:29.106]                 for (kk in seq_along(NAMES)) {
[10:22:29.106]                   name <- changed[[kk]]
[10:22:29.106]                   NAME <- NAMES[[kk]]
[10:22:29.106]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.106]                     next
[10:22:29.106]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:29.106]                 }
[10:22:29.106]                 NAMES <- toupper(added)
[10:22:29.106]                 for (kk in seq_along(NAMES)) {
[10:22:29.106]                   name <- added[[kk]]
[10:22:29.106]                   NAME <- NAMES[[kk]]
[10:22:29.106]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.106]                     next
[10:22:29.106]                   args[[name]] <- ""
[10:22:29.106]                 }
[10:22:29.106]                 NAMES <- toupper(removed)
[10:22:29.106]                 for (kk in seq_along(NAMES)) {
[10:22:29.106]                   name <- removed[[kk]]
[10:22:29.106]                   NAME <- NAMES[[kk]]
[10:22:29.106]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.106]                     next
[10:22:29.106]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:29.106]                 }
[10:22:29.106]                 if (length(args) > 0) 
[10:22:29.106]                   base::do.call(base::Sys.setenv, args = args)
[10:22:29.106]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:29.106]             }
[10:22:29.106]             else {
[10:22:29.106]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:29.106]             }
[10:22:29.106]             {
[10:22:29.106]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:29.106]                   0L) {
[10:22:29.106]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:29.106]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:29.106]                   base::options(opts)
[10:22:29.106]                 }
[10:22:29.106]                 {
[10:22:29.106]                   {
[10:22:29.106]                     NULL
[10:22:29.106]                     RNGkind("Mersenne-Twister")
[10:22:29.106]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:29.106]                       inherits = FALSE)
[10:22:29.106]                   }
[10:22:29.106]                   options(future.plan = NULL)
[10:22:29.106]                   if (is.na(NA_character_)) 
[10:22:29.106]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:29.106]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:29.106]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:29.106]                     .init = FALSE)
[10:22:29.106]                 }
[10:22:29.106]             }
[10:22:29.106]         }
[10:22:29.106]     })
[10:22:29.106]     if (TRUE) {
[10:22:29.106]         base::sink(type = "output", split = FALSE)
[10:22:29.106]         if (TRUE) {
[10:22:29.106]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:29.106]         }
[10:22:29.106]         else {
[10:22:29.106]             ...future.result["stdout"] <- base::list(NULL)
[10:22:29.106]         }
[10:22:29.106]         base::close(...future.stdout)
[10:22:29.106]         ...future.stdout <- NULL
[10:22:29.106]     }
[10:22:29.106]     ...future.result$conditions <- ...future.conditions
[10:22:29.106]     ...future.result$finished <- base::Sys.time()
[10:22:29.106]     ...future.result
[10:22:29.106] }
[10:22:29.107] plan(): Setting new future strategy stack:
[10:22:29.107] List of future strategies:
[10:22:29.107] 1. sequential:
[10:22:29.107]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:29.107]    - tweaked: FALSE
[10:22:29.107]    - call: NULL
[10:22:29.108] plan(): nbrOfWorkers() = 1
[10:22:29.108] plan(): Setting new future strategy stack:
[10:22:29.109] List of future strategies:
[10:22:29.109] 1. sequential:
[10:22:29.109]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:29.109]    - tweaked: FALSE
[10:22:29.109]    - call: plan(strategy)
[10:22:29.109] plan(): nbrOfWorkers() = 1
[10:22:29.109] SequentialFuture started (and completed)
[10:22:29.109] - Launch lazy future ... done
[10:22:29.109] run() for ‘SequentialFuture’ ... done
[10:22:29.110] resolve() on environment ...
[10:22:29.110]  recursive: 0
[10:22:29.110]  elements: [3] ‘a’, ‘b’, ‘c’
[10:22:29.110] resolved() for ‘SequentialFuture’ ...
[10:22:29.111] - state: ‘finished’
[10:22:29.111] - run: TRUE
[10:22:29.111] - result: ‘FutureResult’
[10:22:29.111] resolved() for ‘SequentialFuture’ ... done
[10:22:29.111] Future #1
[10:22:29.111]  length: 2 (resolved future 1)
[10:22:29.111] resolved() for ‘SequentialFuture’ ...
[10:22:29.111] - state: ‘finished’
[10:22:29.111] - run: TRUE
[10:22:29.111] - result: ‘FutureResult’
[10:22:29.111] resolved() for ‘SequentialFuture’ ... done
[10:22:29.112] Future #2
[10:22:29.112]  length: 1 (resolved future 2)
[10:22:29.112]  length: 0 (resolved future 3)
[10:22:29.112] resolve() on environment ... DONE
[10:22:29.112] resolved() for ‘SequentialFuture’ ...
[10:22:29.112] - state: ‘finished’
[10:22:29.112] - run: TRUE
[10:22:29.112] - result: ‘FutureResult’
[10:22:29.112] resolved() for ‘SequentialFuture’ ... done
[10:22:29.112] resolved() for ‘SequentialFuture’ ...
[10:22:29.112] - state: ‘finished’
[10:22:29.113] - run: TRUE
[10:22:29.113] - result: ‘FutureResult’
[10:22:29.113] resolved() for ‘SequentialFuture’ ... done
[10:22:29.113] getGlobalsAndPackages() ...
[10:22:29.114] Searching for globals...
[10:22:29.114] - globals found: [1] ‘{’
[10:22:29.114] Searching for globals ... DONE
[10:22:29.114] Resolving globals: FALSE
[10:22:29.115] 
[10:22:29.115] 
[10:22:29.115] getGlobalsAndPackages() ... DONE
[10:22:29.115] run() for ‘Future’ ...
[10:22:29.115] - state: ‘created’
[10:22:29.117] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:29.117] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:29.117] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:29.118]   - Field: ‘label’
[10:22:29.118]   - Field: ‘local’
[10:22:29.118]   - Field: ‘owner’
[10:22:29.118]   - Field: ‘envir’
[10:22:29.118]   - Field: ‘packages’
[10:22:29.118]   - Field: ‘gc’
[10:22:29.118]   - Field: ‘conditions’
[10:22:29.118]   - Field: ‘expr’
[10:22:29.118]   - Field: ‘uuid’
[10:22:29.118]   - Field: ‘seed’
[10:22:29.119]   - Field: ‘version’
[10:22:29.119]   - Field: ‘result’
[10:22:29.119]   - Field: ‘asynchronous’
[10:22:29.119]   - Field: ‘calls’
[10:22:29.119]   - Field: ‘globals’
[10:22:29.119]   - Field: ‘stdout’
[10:22:29.119]   - Field: ‘earlySignal’
[10:22:29.119]   - Field: ‘lazy’
[10:22:29.119]   - Field: ‘state’
[10:22:29.119] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:29.119] - Launch lazy future ...
[10:22:29.120] Packages needed by the future expression (n = 0): <none>
[10:22:29.120] Packages needed by future strategies (n = 0): <none>
[10:22:29.120] {
[10:22:29.120]     {
[10:22:29.120]         {
[10:22:29.120]             ...future.startTime <- base::Sys.time()
[10:22:29.120]             {
[10:22:29.120]                 {
[10:22:29.120]                   {
[10:22:29.120]                     base::local({
[10:22:29.120]                       has_future <- base::requireNamespace("future", 
[10:22:29.120]                         quietly = TRUE)
[10:22:29.120]                       if (has_future) {
[10:22:29.120]                         ns <- base::getNamespace("future")
[10:22:29.120]                         version <- ns[[".package"]][["version"]]
[10:22:29.120]                         if (is.null(version)) 
[10:22:29.120]                           version <- utils::packageVersion("future")
[10:22:29.120]                       }
[10:22:29.120]                       else {
[10:22:29.120]                         version <- NULL
[10:22:29.120]                       }
[10:22:29.120]                       if (!has_future || version < "1.8.0") {
[10:22:29.120]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:29.120]                           "", base::R.version$version.string), 
[10:22:29.120]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:29.120]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:29.120]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:29.120]                             "release", "version")], collapse = " "), 
[10:22:29.120]                           hostname = base::Sys.info()[["nodename"]])
[10:22:29.120]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:29.120]                           info)
[10:22:29.120]                         info <- base::paste(info, collapse = "; ")
[10:22:29.120]                         if (!has_future) {
[10:22:29.120]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:29.120]                             info)
[10:22:29.120]                         }
[10:22:29.120]                         else {
[10:22:29.120]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:29.120]                             info, version)
[10:22:29.120]                         }
[10:22:29.120]                         base::stop(msg)
[10:22:29.120]                       }
[10:22:29.120]                     })
[10:22:29.120]                   }
[10:22:29.120]                   ...future.strategy.old <- future::plan("list")
[10:22:29.120]                   options(future.plan = NULL)
[10:22:29.120]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:29.120]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:29.120]                 }
[10:22:29.120]                 ...future.workdir <- getwd()
[10:22:29.120]             }
[10:22:29.120]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:29.120]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:29.120]         }
[10:22:29.120]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:29.120]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:29.120]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:29.120]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:29.120]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:29.120]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:29.120]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:29.120]             base::names(...future.oldOptions))
[10:22:29.120]     }
[10:22:29.120]     if (FALSE) {
[10:22:29.120]     }
[10:22:29.120]     else {
[10:22:29.120]         if (TRUE) {
[10:22:29.120]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:29.120]                 open = "w")
[10:22:29.120]         }
[10:22:29.120]         else {
[10:22:29.120]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:29.120]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:29.120]         }
[10:22:29.120]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:29.120]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:29.120]             base::sink(type = "output", split = FALSE)
[10:22:29.120]             base::close(...future.stdout)
[10:22:29.120]         }, add = TRUE)
[10:22:29.120]     }
[10:22:29.120]     ...future.frame <- base::sys.nframe()
[10:22:29.120]     ...future.conditions <- base::list()
[10:22:29.120]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:29.120]     if (FALSE) {
[10:22:29.120]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:29.120]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:29.120]     }
[10:22:29.120]     ...future.result <- base::tryCatch({
[10:22:29.120]         base::withCallingHandlers({
[10:22:29.120]             ...future.value <- base::withVisible(base::local({
[10:22:29.120]                 1
[10:22:29.120]             }))
[10:22:29.120]             future::FutureResult(value = ...future.value$value, 
[10:22:29.120]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:29.120]                   ...future.rng), globalenv = if (FALSE) 
[10:22:29.120]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:29.120]                     ...future.globalenv.names))
[10:22:29.120]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:29.120]         }, condition = base::local({
[10:22:29.120]             c <- base::c
[10:22:29.120]             inherits <- base::inherits
[10:22:29.120]             invokeRestart <- base::invokeRestart
[10:22:29.120]             length <- base::length
[10:22:29.120]             list <- base::list
[10:22:29.120]             seq.int <- base::seq.int
[10:22:29.120]             signalCondition <- base::signalCondition
[10:22:29.120]             sys.calls <- base::sys.calls
[10:22:29.120]             `[[` <- base::`[[`
[10:22:29.120]             `+` <- base::`+`
[10:22:29.120]             `<<-` <- base::`<<-`
[10:22:29.120]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:29.120]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:29.120]                   3L)]
[10:22:29.120]             }
[10:22:29.120]             function(cond) {
[10:22:29.120]                 is_error <- inherits(cond, "error")
[10:22:29.120]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:29.120]                   NULL)
[10:22:29.120]                 if (is_error) {
[10:22:29.120]                   sessionInformation <- function() {
[10:22:29.120]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:29.120]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:29.120]                       search = base::search(), system = base::Sys.info())
[10:22:29.120]                   }
[10:22:29.120]                   ...future.conditions[[length(...future.conditions) + 
[10:22:29.120]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:29.120]                     cond$call), session = sessionInformation(), 
[10:22:29.120]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:29.120]                   signalCondition(cond)
[10:22:29.120]                 }
[10:22:29.120]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:29.120]                 "immediateCondition"))) {
[10:22:29.120]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:29.120]                   ...future.conditions[[length(...future.conditions) + 
[10:22:29.120]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:29.120]                   if (TRUE && !signal) {
[10:22:29.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.120]                     {
[10:22:29.120]                       inherits <- base::inherits
[10:22:29.120]                       invokeRestart <- base::invokeRestart
[10:22:29.120]                       is.null <- base::is.null
[10:22:29.120]                       muffled <- FALSE
[10:22:29.120]                       if (inherits(cond, "message")) {
[10:22:29.120]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:29.120]                         if (muffled) 
[10:22:29.120]                           invokeRestart("muffleMessage")
[10:22:29.120]                       }
[10:22:29.120]                       else if (inherits(cond, "warning")) {
[10:22:29.120]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:29.120]                         if (muffled) 
[10:22:29.120]                           invokeRestart("muffleWarning")
[10:22:29.120]                       }
[10:22:29.120]                       else if (inherits(cond, "condition")) {
[10:22:29.120]                         if (!is.null(pattern)) {
[10:22:29.120]                           computeRestarts <- base::computeRestarts
[10:22:29.120]                           grepl <- base::grepl
[10:22:29.120]                           restarts <- computeRestarts(cond)
[10:22:29.120]                           for (restart in restarts) {
[10:22:29.120]                             name <- restart$name
[10:22:29.120]                             if (is.null(name)) 
[10:22:29.120]                               next
[10:22:29.120]                             if (!grepl(pattern, name)) 
[10:22:29.120]                               next
[10:22:29.120]                             invokeRestart(restart)
[10:22:29.120]                             muffled <- TRUE
[10:22:29.120]                             break
[10:22:29.120]                           }
[10:22:29.120]                         }
[10:22:29.120]                       }
[10:22:29.120]                       invisible(muffled)
[10:22:29.120]                     }
[10:22:29.120]                     muffleCondition(cond, pattern = "^muffle")
[10:22:29.120]                   }
[10:22:29.120]                 }
[10:22:29.120]                 else {
[10:22:29.120]                   if (TRUE) {
[10:22:29.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.120]                     {
[10:22:29.120]                       inherits <- base::inherits
[10:22:29.120]                       invokeRestart <- base::invokeRestart
[10:22:29.120]                       is.null <- base::is.null
[10:22:29.120]                       muffled <- FALSE
[10:22:29.120]                       if (inherits(cond, "message")) {
[10:22:29.120]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:29.120]                         if (muffled) 
[10:22:29.120]                           invokeRestart("muffleMessage")
[10:22:29.120]                       }
[10:22:29.120]                       else if (inherits(cond, "warning")) {
[10:22:29.120]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:29.120]                         if (muffled) 
[10:22:29.120]                           invokeRestart("muffleWarning")
[10:22:29.120]                       }
[10:22:29.120]                       else if (inherits(cond, "condition")) {
[10:22:29.120]                         if (!is.null(pattern)) {
[10:22:29.120]                           computeRestarts <- base::computeRestarts
[10:22:29.120]                           grepl <- base::grepl
[10:22:29.120]                           restarts <- computeRestarts(cond)
[10:22:29.120]                           for (restart in restarts) {
[10:22:29.120]                             name <- restart$name
[10:22:29.120]                             if (is.null(name)) 
[10:22:29.120]                               next
[10:22:29.120]                             if (!grepl(pattern, name)) 
[10:22:29.120]                               next
[10:22:29.120]                             invokeRestart(restart)
[10:22:29.120]                             muffled <- TRUE
[10:22:29.120]                             break
[10:22:29.120]                           }
[10:22:29.120]                         }
[10:22:29.120]                       }
[10:22:29.120]                       invisible(muffled)
[10:22:29.120]                     }
[10:22:29.120]                     muffleCondition(cond, pattern = "^muffle")
[10:22:29.120]                   }
[10:22:29.120]                 }
[10:22:29.120]             }
[10:22:29.120]         }))
[10:22:29.120]     }, error = function(ex) {
[10:22:29.120]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:29.120]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:29.120]                 ...future.rng), started = ...future.startTime, 
[10:22:29.120]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:29.120]             version = "1.8"), class = "FutureResult")
[10:22:29.120]     }, finally = {
[10:22:29.120]         if (!identical(...future.workdir, getwd())) 
[10:22:29.120]             setwd(...future.workdir)
[10:22:29.120]         {
[10:22:29.120]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:29.120]                 ...future.oldOptions$nwarnings <- NULL
[10:22:29.120]             }
[10:22:29.120]             base::options(...future.oldOptions)
[10:22:29.120]             if (.Platform$OS.type == "windows") {
[10:22:29.120]                 old_names <- names(...future.oldEnvVars)
[10:22:29.120]                 envs <- base::Sys.getenv()
[10:22:29.120]                 names <- names(envs)
[10:22:29.120]                 common <- intersect(names, old_names)
[10:22:29.120]                 added <- setdiff(names, old_names)
[10:22:29.120]                 removed <- setdiff(old_names, names)
[10:22:29.120]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:29.120]                   envs[common]]
[10:22:29.120]                 NAMES <- toupper(changed)
[10:22:29.120]                 args <- list()
[10:22:29.120]                 for (kk in seq_along(NAMES)) {
[10:22:29.120]                   name <- changed[[kk]]
[10:22:29.120]                   NAME <- NAMES[[kk]]
[10:22:29.120]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.120]                     next
[10:22:29.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:29.120]                 }
[10:22:29.120]                 NAMES <- toupper(added)
[10:22:29.120]                 for (kk in seq_along(NAMES)) {
[10:22:29.120]                   name <- added[[kk]]
[10:22:29.120]                   NAME <- NAMES[[kk]]
[10:22:29.120]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.120]                     next
[10:22:29.120]                   args[[name]] <- ""
[10:22:29.120]                 }
[10:22:29.120]                 NAMES <- toupper(removed)
[10:22:29.120]                 for (kk in seq_along(NAMES)) {
[10:22:29.120]                   name <- removed[[kk]]
[10:22:29.120]                   NAME <- NAMES[[kk]]
[10:22:29.120]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.120]                     next
[10:22:29.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:29.120]                 }
[10:22:29.120]                 if (length(args) > 0) 
[10:22:29.120]                   base::do.call(base::Sys.setenv, args = args)
[10:22:29.120]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:29.120]             }
[10:22:29.120]             else {
[10:22:29.120]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:29.120]             }
[10:22:29.120]             {
[10:22:29.120]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:29.120]                   0L) {
[10:22:29.120]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:29.120]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:29.120]                   base::options(opts)
[10:22:29.120]                 }
[10:22:29.120]                 {
[10:22:29.120]                   {
[10:22:29.120]                     NULL
[10:22:29.120]                     RNGkind("Mersenne-Twister")
[10:22:29.120]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:29.120]                       inherits = FALSE)
[10:22:29.120]                   }
[10:22:29.120]                   options(future.plan = NULL)
[10:22:29.120]                   if (is.na(NA_character_)) 
[10:22:29.120]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:29.120]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:29.120]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:29.120]                     .init = FALSE)
[10:22:29.120]                 }
[10:22:29.120]             }
[10:22:29.120]         }
[10:22:29.120]     })
[10:22:29.120]     if (TRUE) {
[10:22:29.120]         base::sink(type = "output", split = FALSE)
[10:22:29.120]         if (TRUE) {
[10:22:29.120]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:29.120]         }
[10:22:29.120]         else {
[10:22:29.120]             ...future.result["stdout"] <- base::list(NULL)
[10:22:29.120]         }
[10:22:29.120]         base::close(...future.stdout)
[10:22:29.120]         ...future.stdout <- NULL
[10:22:29.120]     }
[10:22:29.120]     ...future.result$conditions <- ...future.conditions
[10:22:29.120]     ...future.result$finished <- base::Sys.time()
[10:22:29.120]     ...future.result
[10:22:29.120] }
[10:22:29.122] plan(): Setting new future strategy stack:
[10:22:29.122] List of future strategies:
[10:22:29.122] 1. sequential:
[10:22:29.122]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:29.122]    - tweaked: FALSE
[10:22:29.122]    - call: NULL
[10:22:29.122] plan(): nbrOfWorkers() = 1
[10:22:29.123] plan(): Setting new future strategy stack:
[10:22:29.123] List of future strategies:
[10:22:29.123] 1. sequential:
[10:22:29.123]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:29.123]    - tweaked: FALSE
[10:22:29.123]    - call: plan(strategy)
[10:22:29.124] plan(): nbrOfWorkers() = 1
[10:22:29.124] SequentialFuture started (and completed)
[10:22:29.124] - Launch lazy future ... done
[10:22:29.124] run() for ‘SequentialFuture’ ... done
[10:22:29.124] getGlobalsAndPackages() ...
[10:22:29.124] Searching for globals...
[10:22:29.125] - globals found: [1] ‘{’
[10:22:29.125] Searching for globals ... DONE
[10:22:29.125] Resolving globals: FALSE
[10:22:29.125] 
[10:22:29.125] 
[10:22:29.125] getGlobalsAndPackages() ... DONE
[10:22:29.126] run() for ‘Future’ ...
[10:22:29.126] - state: ‘created’
[10:22:29.126] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:29.126] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:29.126] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:29.126]   - Field: ‘label’
[10:22:29.126]   - Field: ‘local’
[10:22:29.126]   - Field: ‘owner’
[10:22:29.127]   - Field: ‘envir’
[10:22:29.127]   - Field: ‘packages’
[10:22:29.127]   - Field: ‘gc’
[10:22:29.127]   - Field: ‘conditions’
[10:22:29.127]   - Field: ‘expr’
[10:22:29.127]   - Field: ‘uuid’
[10:22:29.127]   - Field: ‘seed’
[10:22:29.127]   - Field: ‘version’
[10:22:29.127]   - Field: ‘result’
[10:22:29.127]   - Field: ‘asynchronous’
[10:22:29.127]   - Field: ‘calls’
[10:22:29.127]   - Field: ‘globals’
[10:22:29.128]   - Field: ‘stdout’
[10:22:29.128]   - Field: ‘earlySignal’
[10:22:29.128]   - Field: ‘lazy’
[10:22:29.128]   - Field: ‘state’
[10:22:29.128] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:29.128] - Launch lazy future ...
[10:22:29.128] Packages needed by the future expression (n = 0): <none>
[10:22:29.128] Packages needed by future strategies (n = 0): <none>
[10:22:29.129] {
[10:22:29.129]     {
[10:22:29.129]         {
[10:22:29.129]             ...future.startTime <- base::Sys.time()
[10:22:29.129]             {
[10:22:29.129]                 {
[10:22:29.129]                   {
[10:22:29.129]                     base::local({
[10:22:29.129]                       has_future <- base::requireNamespace("future", 
[10:22:29.129]                         quietly = TRUE)
[10:22:29.129]                       if (has_future) {
[10:22:29.129]                         ns <- base::getNamespace("future")
[10:22:29.129]                         version <- ns[[".package"]][["version"]]
[10:22:29.129]                         if (is.null(version)) 
[10:22:29.129]                           version <- utils::packageVersion("future")
[10:22:29.129]                       }
[10:22:29.129]                       else {
[10:22:29.129]                         version <- NULL
[10:22:29.129]                       }
[10:22:29.129]                       if (!has_future || version < "1.8.0") {
[10:22:29.129]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:29.129]                           "", base::R.version$version.string), 
[10:22:29.129]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:29.129]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:29.129]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:29.129]                             "release", "version")], collapse = " "), 
[10:22:29.129]                           hostname = base::Sys.info()[["nodename"]])
[10:22:29.129]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:29.129]                           info)
[10:22:29.129]                         info <- base::paste(info, collapse = "; ")
[10:22:29.129]                         if (!has_future) {
[10:22:29.129]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:29.129]                             info)
[10:22:29.129]                         }
[10:22:29.129]                         else {
[10:22:29.129]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:29.129]                             info, version)
[10:22:29.129]                         }
[10:22:29.129]                         base::stop(msg)
[10:22:29.129]                       }
[10:22:29.129]                     })
[10:22:29.129]                   }
[10:22:29.129]                   ...future.strategy.old <- future::plan("list")
[10:22:29.129]                   options(future.plan = NULL)
[10:22:29.129]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:29.129]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:29.129]                 }
[10:22:29.129]                 ...future.workdir <- getwd()
[10:22:29.129]             }
[10:22:29.129]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:29.129]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:29.129]         }
[10:22:29.129]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:29.129]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:29.129]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:29.129]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:29.129]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:29.129]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:29.129]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:29.129]             base::names(...future.oldOptions))
[10:22:29.129]     }
[10:22:29.129]     if (FALSE) {
[10:22:29.129]     }
[10:22:29.129]     else {
[10:22:29.129]         if (TRUE) {
[10:22:29.129]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:29.129]                 open = "w")
[10:22:29.129]         }
[10:22:29.129]         else {
[10:22:29.129]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:29.129]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:29.129]         }
[10:22:29.129]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:29.129]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:29.129]             base::sink(type = "output", split = FALSE)
[10:22:29.129]             base::close(...future.stdout)
[10:22:29.129]         }, add = TRUE)
[10:22:29.129]     }
[10:22:29.129]     ...future.frame <- base::sys.nframe()
[10:22:29.129]     ...future.conditions <- base::list()
[10:22:29.129]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:29.129]     if (FALSE) {
[10:22:29.129]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:29.129]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:29.129]     }
[10:22:29.129]     ...future.result <- base::tryCatch({
[10:22:29.129]         base::withCallingHandlers({
[10:22:29.129]             ...future.value <- base::withVisible(base::local({
[10:22:29.129]                 2
[10:22:29.129]             }))
[10:22:29.129]             future::FutureResult(value = ...future.value$value, 
[10:22:29.129]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:29.129]                   ...future.rng), globalenv = if (FALSE) 
[10:22:29.129]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:29.129]                     ...future.globalenv.names))
[10:22:29.129]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:29.129]         }, condition = base::local({
[10:22:29.129]             c <- base::c
[10:22:29.129]             inherits <- base::inherits
[10:22:29.129]             invokeRestart <- base::invokeRestart
[10:22:29.129]             length <- base::length
[10:22:29.129]             list <- base::list
[10:22:29.129]             seq.int <- base::seq.int
[10:22:29.129]             signalCondition <- base::signalCondition
[10:22:29.129]             sys.calls <- base::sys.calls
[10:22:29.129]             `[[` <- base::`[[`
[10:22:29.129]             `+` <- base::`+`
[10:22:29.129]             `<<-` <- base::`<<-`
[10:22:29.129]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:29.129]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:29.129]                   3L)]
[10:22:29.129]             }
[10:22:29.129]             function(cond) {
[10:22:29.129]                 is_error <- inherits(cond, "error")
[10:22:29.129]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:29.129]                   NULL)
[10:22:29.129]                 if (is_error) {
[10:22:29.129]                   sessionInformation <- function() {
[10:22:29.129]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:29.129]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:29.129]                       search = base::search(), system = base::Sys.info())
[10:22:29.129]                   }
[10:22:29.129]                   ...future.conditions[[length(...future.conditions) + 
[10:22:29.129]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:29.129]                     cond$call), session = sessionInformation(), 
[10:22:29.129]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:29.129]                   signalCondition(cond)
[10:22:29.129]                 }
[10:22:29.129]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:29.129]                 "immediateCondition"))) {
[10:22:29.129]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:29.129]                   ...future.conditions[[length(...future.conditions) + 
[10:22:29.129]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:29.129]                   if (TRUE && !signal) {
[10:22:29.129]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.129]                     {
[10:22:29.129]                       inherits <- base::inherits
[10:22:29.129]                       invokeRestart <- base::invokeRestart
[10:22:29.129]                       is.null <- base::is.null
[10:22:29.129]                       muffled <- FALSE
[10:22:29.129]                       if (inherits(cond, "message")) {
[10:22:29.129]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:29.129]                         if (muffled) 
[10:22:29.129]                           invokeRestart("muffleMessage")
[10:22:29.129]                       }
[10:22:29.129]                       else if (inherits(cond, "warning")) {
[10:22:29.129]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:29.129]                         if (muffled) 
[10:22:29.129]                           invokeRestart("muffleWarning")
[10:22:29.129]                       }
[10:22:29.129]                       else if (inherits(cond, "condition")) {
[10:22:29.129]                         if (!is.null(pattern)) {
[10:22:29.129]                           computeRestarts <- base::computeRestarts
[10:22:29.129]                           grepl <- base::grepl
[10:22:29.129]                           restarts <- computeRestarts(cond)
[10:22:29.129]                           for (restart in restarts) {
[10:22:29.129]                             name <- restart$name
[10:22:29.129]                             if (is.null(name)) 
[10:22:29.129]                               next
[10:22:29.129]                             if (!grepl(pattern, name)) 
[10:22:29.129]                               next
[10:22:29.129]                             invokeRestart(restart)
[10:22:29.129]                             muffled <- TRUE
[10:22:29.129]                             break
[10:22:29.129]                           }
[10:22:29.129]                         }
[10:22:29.129]                       }
[10:22:29.129]                       invisible(muffled)
[10:22:29.129]                     }
[10:22:29.129]                     muffleCondition(cond, pattern = "^muffle")
[10:22:29.129]                   }
[10:22:29.129]                 }
[10:22:29.129]                 else {
[10:22:29.129]                   if (TRUE) {
[10:22:29.129]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.129]                     {
[10:22:29.129]                       inherits <- base::inherits
[10:22:29.129]                       invokeRestart <- base::invokeRestart
[10:22:29.129]                       is.null <- base::is.null
[10:22:29.129]                       muffled <- FALSE
[10:22:29.129]                       if (inherits(cond, "message")) {
[10:22:29.129]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:29.129]                         if (muffled) 
[10:22:29.129]                           invokeRestart("muffleMessage")
[10:22:29.129]                       }
[10:22:29.129]                       else if (inherits(cond, "warning")) {
[10:22:29.129]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:29.129]                         if (muffled) 
[10:22:29.129]                           invokeRestart("muffleWarning")
[10:22:29.129]                       }
[10:22:29.129]                       else if (inherits(cond, "condition")) {
[10:22:29.129]                         if (!is.null(pattern)) {
[10:22:29.129]                           computeRestarts <- base::computeRestarts
[10:22:29.129]                           grepl <- base::grepl
[10:22:29.129]                           restarts <- computeRestarts(cond)
[10:22:29.129]                           for (restart in restarts) {
[10:22:29.129]                             name <- restart$name
[10:22:29.129]                             if (is.null(name)) 
[10:22:29.129]                               next
[10:22:29.129]                             if (!grepl(pattern, name)) 
[10:22:29.129]                               next
[10:22:29.129]                             invokeRestart(restart)
[10:22:29.129]                             muffled <- TRUE
[10:22:29.129]                             break
[10:22:29.129]                           }
[10:22:29.129]                         }
[10:22:29.129]                       }
[10:22:29.129]                       invisible(muffled)
[10:22:29.129]                     }
[10:22:29.129]                     muffleCondition(cond, pattern = "^muffle")
[10:22:29.129]                   }
[10:22:29.129]                 }
[10:22:29.129]             }
[10:22:29.129]         }))
[10:22:29.129]     }, error = function(ex) {
[10:22:29.129]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:29.129]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:29.129]                 ...future.rng), started = ...future.startTime, 
[10:22:29.129]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:29.129]             version = "1.8"), class = "FutureResult")
[10:22:29.129]     }, finally = {
[10:22:29.129]         if (!identical(...future.workdir, getwd())) 
[10:22:29.129]             setwd(...future.workdir)
[10:22:29.129]         {
[10:22:29.129]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:29.129]                 ...future.oldOptions$nwarnings <- NULL
[10:22:29.129]             }
[10:22:29.129]             base::options(...future.oldOptions)
[10:22:29.129]             if (.Platform$OS.type == "windows") {
[10:22:29.129]                 old_names <- names(...future.oldEnvVars)
[10:22:29.129]                 envs <- base::Sys.getenv()
[10:22:29.129]                 names <- names(envs)
[10:22:29.129]                 common <- intersect(names, old_names)
[10:22:29.129]                 added <- setdiff(names, old_names)
[10:22:29.129]                 removed <- setdiff(old_names, names)
[10:22:29.129]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:29.129]                   envs[common]]
[10:22:29.129]                 NAMES <- toupper(changed)
[10:22:29.129]                 args <- list()
[10:22:29.129]                 for (kk in seq_along(NAMES)) {
[10:22:29.129]                   name <- changed[[kk]]
[10:22:29.129]                   NAME <- NAMES[[kk]]
[10:22:29.129]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.129]                     next
[10:22:29.129]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:29.129]                 }
[10:22:29.129]                 NAMES <- toupper(added)
[10:22:29.129]                 for (kk in seq_along(NAMES)) {
[10:22:29.129]                   name <- added[[kk]]
[10:22:29.129]                   NAME <- NAMES[[kk]]
[10:22:29.129]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.129]                     next
[10:22:29.129]                   args[[name]] <- ""
[10:22:29.129]                 }
[10:22:29.129]                 NAMES <- toupper(removed)
[10:22:29.129]                 for (kk in seq_along(NAMES)) {
[10:22:29.129]                   name <- removed[[kk]]
[10:22:29.129]                   NAME <- NAMES[[kk]]
[10:22:29.129]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.129]                     next
[10:22:29.129]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:29.129]                 }
[10:22:29.129]                 if (length(args) > 0) 
[10:22:29.129]                   base::do.call(base::Sys.setenv, args = args)
[10:22:29.129]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:29.129]             }
[10:22:29.129]             else {
[10:22:29.129]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:29.129]             }
[10:22:29.129]             {
[10:22:29.129]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:29.129]                   0L) {
[10:22:29.129]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:29.129]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:29.129]                   base::options(opts)
[10:22:29.129]                 }
[10:22:29.129]                 {
[10:22:29.129]                   {
[10:22:29.129]                     NULL
[10:22:29.129]                     RNGkind("Mersenne-Twister")
[10:22:29.129]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:29.129]                       inherits = FALSE)
[10:22:29.129]                   }
[10:22:29.129]                   options(future.plan = NULL)
[10:22:29.129]                   if (is.na(NA_character_)) 
[10:22:29.129]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:29.129]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:29.129]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:29.129]                     .init = FALSE)
[10:22:29.129]                 }
[10:22:29.129]             }
[10:22:29.129]         }
[10:22:29.129]     })
[10:22:29.129]     if (TRUE) {
[10:22:29.129]         base::sink(type = "output", split = FALSE)
[10:22:29.129]         if (TRUE) {
[10:22:29.129]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:29.129]         }
[10:22:29.129]         else {
[10:22:29.129]             ...future.result["stdout"] <- base::list(NULL)
[10:22:29.129]         }
[10:22:29.129]         base::close(...future.stdout)
[10:22:29.129]         ...future.stdout <- NULL
[10:22:29.129]     }
[10:22:29.129]     ...future.result$conditions <- ...future.conditions
[10:22:29.129]     ...future.result$finished <- base::Sys.time()
[10:22:29.129]     ...future.result
[10:22:29.129] }
[10:22:29.130] plan(): Setting new future strategy stack:
[10:22:29.131] List of future strategies:
[10:22:29.131] 1. sequential:
[10:22:29.131]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:29.131]    - tweaked: FALSE
[10:22:29.131]    - call: NULL
[10:22:29.131] plan(): nbrOfWorkers() = 1
[10:22:29.132] plan(): Setting new future strategy stack:
[10:22:29.132] List of future strategies:
[10:22:29.132] 1. sequential:
[10:22:29.132]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:29.132]    - tweaked: FALSE
[10:22:29.132]    - call: plan(strategy)
[10:22:29.132] plan(): nbrOfWorkers() = 1
[10:22:29.132] SequentialFuture started (and completed)
[10:22:29.132] - Launch lazy future ... done
[10:22:29.133] run() for ‘SequentialFuture’ ... done
[10:22:29.133] resolve() on environment ...
[10:22:29.133]  recursive: 0
[10:22:29.134]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[10:22:29.134] resolved() for ‘SequentialFuture’ ...
[10:22:29.134] - state: ‘finished’
[10:22:29.134] - run: TRUE
[10:22:29.134] - result: ‘FutureResult’
[10:22:29.134] resolved() for ‘SequentialFuture’ ... done
[10:22:29.134] Future #1
[10:22:29.134]  length: 2 (resolved future 1)
[10:22:29.134] resolved() for ‘SequentialFuture’ ...
[10:22:29.134] - state: ‘finished’
[10:22:29.135] - run: TRUE
[10:22:29.135] - result: ‘FutureResult’
[10:22:29.135] resolved() for ‘SequentialFuture’ ... done
[10:22:29.135] Future #2
[10:22:29.135]  length: 1 (resolved future 2)
[10:22:29.135]  length: 0 (resolved future 3)
[10:22:29.135] resolve() on environment ... DONE
[10:22:29.135] getGlobalsAndPackages() ...
[10:22:29.135] Searching for globals...
[10:22:29.136] - globals found: [1] ‘{’
[10:22:29.136] Searching for globals ... DONE
[10:22:29.136] Resolving globals: FALSE
[10:22:29.136] 
[10:22:29.137] 
[10:22:29.137] getGlobalsAndPackages() ... DONE
[10:22:29.137] run() for ‘Future’ ...
[10:22:29.137] - state: ‘created’
[10:22:29.137] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:29.137] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:29.137] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:29.137]   - Field: ‘label’
[10:22:29.138]   - Field: ‘local’
[10:22:29.138]   - Field: ‘owner’
[10:22:29.138]   - Field: ‘envir’
[10:22:29.138]   - Field: ‘packages’
[10:22:29.138]   - Field: ‘gc’
[10:22:29.138]   - Field: ‘conditions’
[10:22:29.138]   - Field: ‘expr’
[10:22:29.138]   - Field: ‘uuid’
[10:22:29.138]   - Field: ‘seed’
[10:22:29.138]   - Field: ‘version’
[10:22:29.138]   - Field: ‘result’
[10:22:29.138]   - Field: ‘asynchronous’
[10:22:29.139]   - Field: ‘calls’
[10:22:29.139]   - Field: ‘globals’
[10:22:29.139]   - Field: ‘stdout’
[10:22:29.139]   - Field: ‘earlySignal’
[10:22:29.139]   - Field: ‘lazy’
[10:22:29.139]   - Field: ‘state’
[10:22:29.139] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:29.139] - Launch lazy future ...
[10:22:29.139] Packages needed by the future expression (n = 0): <none>
[10:22:29.139] Packages needed by future strategies (n = 0): <none>
[10:22:29.140] {
[10:22:29.140]     {
[10:22:29.140]         {
[10:22:29.140]             ...future.startTime <- base::Sys.time()
[10:22:29.140]             {
[10:22:29.140]                 {
[10:22:29.140]                   {
[10:22:29.140]                     base::local({
[10:22:29.140]                       has_future <- base::requireNamespace("future", 
[10:22:29.140]                         quietly = TRUE)
[10:22:29.140]                       if (has_future) {
[10:22:29.140]                         ns <- base::getNamespace("future")
[10:22:29.140]                         version <- ns[[".package"]][["version"]]
[10:22:29.140]                         if (is.null(version)) 
[10:22:29.140]                           version <- utils::packageVersion("future")
[10:22:29.140]                       }
[10:22:29.140]                       else {
[10:22:29.140]                         version <- NULL
[10:22:29.140]                       }
[10:22:29.140]                       if (!has_future || version < "1.8.0") {
[10:22:29.140]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:29.140]                           "", base::R.version$version.string), 
[10:22:29.140]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:29.140]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:29.140]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:29.140]                             "release", "version")], collapse = " "), 
[10:22:29.140]                           hostname = base::Sys.info()[["nodename"]])
[10:22:29.140]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:29.140]                           info)
[10:22:29.140]                         info <- base::paste(info, collapse = "; ")
[10:22:29.140]                         if (!has_future) {
[10:22:29.140]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:29.140]                             info)
[10:22:29.140]                         }
[10:22:29.140]                         else {
[10:22:29.140]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:29.140]                             info, version)
[10:22:29.140]                         }
[10:22:29.140]                         base::stop(msg)
[10:22:29.140]                       }
[10:22:29.140]                     })
[10:22:29.140]                   }
[10:22:29.140]                   ...future.strategy.old <- future::plan("list")
[10:22:29.140]                   options(future.plan = NULL)
[10:22:29.140]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:29.140]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:29.140]                 }
[10:22:29.140]                 ...future.workdir <- getwd()
[10:22:29.140]             }
[10:22:29.140]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:29.140]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:29.140]         }
[10:22:29.140]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:29.140]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:29.140]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:29.140]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:29.140]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:29.140]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:29.140]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:29.140]             base::names(...future.oldOptions))
[10:22:29.140]     }
[10:22:29.140]     if (FALSE) {
[10:22:29.140]     }
[10:22:29.140]     else {
[10:22:29.140]         if (TRUE) {
[10:22:29.140]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:29.140]                 open = "w")
[10:22:29.140]         }
[10:22:29.140]         else {
[10:22:29.140]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:29.140]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:29.140]         }
[10:22:29.140]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:29.140]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:29.140]             base::sink(type = "output", split = FALSE)
[10:22:29.140]             base::close(...future.stdout)
[10:22:29.140]         }, add = TRUE)
[10:22:29.140]     }
[10:22:29.140]     ...future.frame <- base::sys.nframe()
[10:22:29.140]     ...future.conditions <- base::list()
[10:22:29.140]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:29.140]     if (FALSE) {
[10:22:29.140]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:29.140]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:29.140]     }
[10:22:29.140]     ...future.result <- base::tryCatch({
[10:22:29.140]         base::withCallingHandlers({
[10:22:29.140]             ...future.value <- base::withVisible(base::local({
[10:22:29.140]                 1
[10:22:29.140]             }))
[10:22:29.140]             future::FutureResult(value = ...future.value$value, 
[10:22:29.140]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:29.140]                   ...future.rng), globalenv = if (FALSE) 
[10:22:29.140]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:29.140]                     ...future.globalenv.names))
[10:22:29.140]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:29.140]         }, condition = base::local({
[10:22:29.140]             c <- base::c
[10:22:29.140]             inherits <- base::inherits
[10:22:29.140]             invokeRestart <- base::invokeRestart
[10:22:29.140]             length <- base::length
[10:22:29.140]             list <- base::list
[10:22:29.140]             seq.int <- base::seq.int
[10:22:29.140]             signalCondition <- base::signalCondition
[10:22:29.140]             sys.calls <- base::sys.calls
[10:22:29.140]             `[[` <- base::`[[`
[10:22:29.140]             `+` <- base::`+`
[10:22:29.140]             `<<-` <- base::`<<-`
[10:22:29.140]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:29.140]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:29.140]                   3L)]
[10:22:29.140]             }
[10:22:29.140]             function(cond) {
[10:22:29.140]                 is_error <- inherits(cond, "error")
[10:22:29.140]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:29.140]                   NULL)
[10:22:29.140]                 if (is_error) {
[10:22:29.140]                   sessionInformation <- function() {
[10:22:29.140]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:29.140]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:29.140]                       search = base::search(), system = base::Sys.info())
[10:22:29.140]                   }
[10:22:29.140]                   ...future.conditions[[length(...future.conditions) + 
[10:22:29.140]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:29.140]                     cond$call), session = sessionInformation(), 
[10:22:29.140]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:29.140]                   signalCondition(cond)
[10:22:29.140]                 }
[10:22:29.140]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:29.140]                 "immediateCondition"))) {
[10:22:29.140]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:29.140]                   ...future.conditions[[length(...future.conditions) + 
[10:22:29.140]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:29.140]                   if (TRUE && !signal) {
[10:22:29.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.140]                     {
[10:22:29.140]                       inherits <- base::inherits
[10:22:29.140]                       invokeRestart <- base::invokeRestart
[10:22:29.140]                       is.null <- base::is.null
[10:22:29.140]                       muffled <- FALSE
[10:22:29.140]                       if (inherits(cond, "message")) {
[10:22:29.140]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:29.140]                         if (muffled) 
[10:22:29.140]                           invokeRestart("muffleMessage")
[10:22:29.140]                       }
[10:22:29.140]                       else if (inherits(cond, "warning")) {
[10:22:29.140]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:29.140]                         if (muffled) 
[10:22:29.140]                           invokeRestart("muffleWarning")
[10:22:29.140]                       }
[10:22:29.140]                       else if (inherits(cond, "condition")) {
[10:22:29.140]                         if (!is.null(pattern)) {
[10:22:29.140]                           computeRestarts <- base::computeRestarts
[10:22:29.140]                           grepl <- base::grepl
[10:22:29.140]                           restarts <- computeRestarts(cond)
[10:22:29.140]                           for (restart in restarts) {
[10:22:29.140]                             name <- restart$name
[10:22:29.140]                             if (is.null(name)) 
[10:22:29.140]                               next
[10:22:29.140]                             if (!grepl(pattern, name)) 
[10:22:29.140]                               next
[10:22:29.140]                             invokeRestart(restart)
[10:22:29.140]                             muffled <- TRUE
[10:22:29.140]                             break
[10:22:29.140]                           }
[10:22:29.140]                         }
[10:22:29.140]                       }
[10:22:29.140]                       invisible(muffled)
[10:22:29.140]                     }
[10:22:29.140]                     muffleCondition(cond, pattern = "^muffle")
[10:22:29.140]                   }
[10:22:29.140]                 }
[10:22:29.140]                 else {
[10:22:29.140]                   if (TRUE) {
[10:22:29.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.140]                     {
[10:22:29.140]                       inherits <- base::inherits
[10:22:29.140]                       invokeRestart <- base::invokeRestart
[10:22:29.140]                       is.null <- base::is.null
[10:22:29.140]                       muffled <- FALSE
[10:22:29.140]                       if (inherits(cond, "message")) {
[10:22:29.140]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:29.140]                         if (muffled) 
[10:22:29.140]                           invokeRestart("muffleMessage")
[10:22:29.140]                       }
[10:22:29.140]                       else if (inherits(cond, "warning")) {
[10:22:29.140]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:29.140]                         if (muffled) 
[10:22:29.140]                           invokeRestart("muffleWarning")
[10:22:29.140]                       }
[10:22:29.140]                       else if (inherits(cond, "condition")) {
[10:22:29.140]                         if (!is.null(pattern)) {
[10:22:29.140]                           computeRestarts <- base::computeRestarts
[10:22:29.140]                           grepl <- base::grepl
[10:22:29.140]                           restarts <- computeRestarts(cond)
[10:22:29.140]                           for (restart in restarts) {
[10:22:29.140]                             name <- restart$name
[10:22:29.140]                             if (is.null(name)) 
[10:22:29.140]                               next
[10:22:29.140]                             if (!grepl(pattern, name)) 
[10:22:29.140]                               next
[10:22:29.140]                             invokeRestart(restart)
[10:22:29.140]                             muffled <- TRUE
[10:22:29.140]                             break
[10:22:29.140]                           }
[10:22:29.140]                         }
[10:22:29.140]                       }
[10:22:29.140]                       invisible(muffled)
[10:22:29.140]                     }
[10:22:29.140]                     muffleCondition(cond, pattern = "^muffle")
[10:22:29.140]                   }
[10:22:29.140]                 }
[10:22:29.140]             }
[10:22:29.140]         }))
[10:22:29.140]     }, error = function(ex) {
[10:22:29.140]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:29.140]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:29.140]                 ...future.rng), started = ...future.startTime, 
[10:22:29.140]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:29.140]             version = "1.8"), class = "FutureResult")
[10:22:29.140]     }, finally = {
[10:22:29.140]         if (!identical(...future.workdir, getwd())) 
[10:22:29.140]             setwd(...future.workdir)
[10:22:29.140]         {
[10:22:29.140]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:29.140]                 ...future.oldOptions$nwarnings <- NULL
[10:22:29.140]             }
[10:22:29.140]             base::options(...future.oldOptions)
[10:22:29.140]             if (.Platform$OS.type == "windows") {
[10:22:29.140]                 old_names <- names(...future.oldEnvVars)
[10:22:29.140]                 envs <- base::Sys.getenv()
[10:22:29.140]                 names <- names(envs)
[10:22:29.140]                 common <- intersect(names, old_names)
[10:22:29.140]                 added <- setdiff(names, old_names)
[10:22:29.140]                 removed <- setdiff(old_names, names)
[10:22:29.140]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:29.140]                   envs[common]]
[10:22:29.140]                 NAMES <- toupper(changed)
[10:22:29.140]                 args <- list()
[10:22:29.140]                 for (kk in seq_along(NAMES)) {
[10:22:29.140]                   name <- changed[[kk]]
[10:22:29.140]                   NAME <- NAMES[[kk]]
[10:22:29.140]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.140]                     next
[10:22:29.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:29.140]                 }
[10:22:29.140]                 NAMES <- toupper(added)
[10:22:29.140]                 for (kk in seq_along(NAMES)) {
[10:22:29.140]                   name <- added[[kk]]
[10:22:29.140]                   NAME <- NAMES[[kk]]
[10:22:29.140]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.140]                     next
[10:22:29.140]                   args[[name]] <- ""
[10:22:29.140]                 }
[10:22:29.140]                 NAMES <- toupper(removed)
[10:22:29.140]                 for (kk in seq_along(NAMES)) {
[10:22:29.140]                   name <- removed[[kk]]
[10:22:29.140]                   NAME <- NAMES[[kk]]
[10:22:29.140]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.140]                     next
[10:22:29.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:29.140]                 }
[10:22:29.140]                 if (length(args) > 0) 
[10:22:29.140]                   base::do.call(base::Sys.setenv, args = args)
[10:22:29.140]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:29.140]             }
[10:22:29.140]             else {
[10:22:29.140]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:29.140]             }
[10:22:29.140]             {
[10:22:29.140]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:29.140]                   0L) {
[10:22:29.140]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:29.140]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:29.140]                   base::options(opts)
[10:22:29.140]                 }
[10:22:29.140]                 {
[10:22:29.140]                   {
[10:22:29.140]                     NULL
[10:22:29.140]                     RNGkind("Mersenne-Twister")
[10:22:29.140]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:29.140]                       inherits = FALSE)
[10:22:29.140]                   }
[10:22:29.140]                   options(future.plan = NULL)
[10:22:29.140]                   if (is.na(NA_character_)) 
[10:22:29.140]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:29.140]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:29.140]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:29.140]                     .init = FALSE)
[10:22:29.140]                 }
[10:22:29.140]             }
[10:22:29.140]         }
[10:22:29.140]     })
[10:22:29.140]     if (TRUE) {
[10:22:29.140]         base::sink(type = "output", split = FALSE)
[10:22:29.140]         if (TRUE) {
[10:22:29.140]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:29.140]         }
[10:22:29.140]         else {
[10:22:29.140]             ...future.result["stdout"] <- base::list(NULL)
[10:22:29.140]         }
[10:22:29.140]         base::close(...future.stdout)
[10:22:29.140]         ...future.stdout <- NULL
[10:22:29.140]     }
[10:22:29.140]     ...future.result$conditions <- ...future.conditions
[10:22:29.140]     ...future.result$finished <- base::Sys.time()
[10:22:29.140]     ...future.result
[10:22:29.140] }
[10:22:29.142] plan(): Setting new future strategy stack:
[10:22:29.142] List of future strategies:
[10:22:29.142] 1. sequential:
[10:22:29.142]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:29.142]    - tweaked: FALSE
[10:22:29.142]    - call: NULL
[10:22:29.142] plan(): nbrOfWorkers() = 1
[10:22:29.143] plan(): Setting new future strategy stack:
[10:22:29.143] List of future strategies:
[10:22:29.143] 1. sequential:
[10:22:29.143]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:29.143]    - tweaked: FALSE
[10:22:29.143]    - call: plan(strategy)
[10:22:29.143] plan(): nbrOfWorkers() = 1
[10:22:29.145] SequentialFuture started (and completed)
[10:22:29.145] - Launch lazy future ... done
[10:22:29.145] run() for ‘SequentialFuture’ ... done
[10:22:29.146] getGlobalsAndPackages() ...
[10:22:29.146] Searching for globals...
[10:22:29.146] - globals found: [1] ‘{’
[10:22:29.147] Searching for globals ... DONE
[10:22:29.147] Resolving globals: FALSE
[10:22:29.147] 
[10:22:29.147] 
[10:22:29.147] getGlobalsAndPackages() ... DONE
[10:22:29.147] run() for ‘Future’ ...
[10:22:29.147] - state: ‘created’
[10:22:29.147] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:29.148] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:29.148] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:29.148]   - Field: ‘label’
[10:22:29.148]   - Field: ‘local’
[10:22:29.148]   - Field: ‘owner’
[10:22:29.148]   - Field: ‘envir’
[10:22:29.148]   - Field: ‘packages’
[10:22:29.148]   - Field: ‘gc’
[10:22:29.148]   - Field: ‘conditions’
[10:22:29.149]   - Field: ‘expr’
[10:22:29.149]   - Field: ‘uuid’
[10:22:29.149]   - Field: ‘seed’
[10:22:29.149]   - Field: ‘version’
[10:22:29.149]   - Field: ‘result’
[10:22:29.149]   - Field: ‘asynchronous’
[10:22:29.149]   - Field: ‘calls’
[10:22:29.149]   - Field: ‘globals’
[10:22:29.149]   - Field: ‘stdout’
[10:22:29.149]   - Field: ‘earlySignal’
[10:22:29.149]   - Field: ‘lazy’
[10:22:29.150]   - Field: ‘state’
[10:22:29.150] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:29.150] - Launch lazy future ...
[10:22:29.150] Packages needed by the future expression (n = 0): <none>
[10:22:29.150] Packages needed by future strategies (n = 0): <none>
[10:22:29.150] {
[10:22:29.150]     {
[10:22:29.150]         {
[10:22:29.150]             ...future.startTime <- base::Sys.time()
[10:22:29.150]             {
[10:22:29.150]                 {
[10:22:29.150]                   {
[10:22:29.150]                     base::local({
[10:22:29.150]                       has_future <- base::requireNamespace("future", 
[10:22:29.150]                         quietly = TRUE)
[10:22:29.150]                       if (has_future) {
[10:22:29.150]                         ns <- base::getNamespace("future")
[10:22:29.150]                         version <- ns[[".package"]][["version"]]
[10:22:29.150]                         if (is.null(version)) 
[10:22:29.150]                           version <- utils::packageVersion("future")
[10:22:29.150]                       }
[10:22:29.150]                       else {
[10:22:29.150]                         version <- NULL
[10:22:29.150]                       }
[10:22:29.150]                       if (!has_future || version < "1.8.0") {
[10:22:29.150]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:29.150]                           "", base::R.version$version.string), 
[10:22:29.150]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:29.150]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:29.150]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:29.150]                             "release", "version")], collapse = " "), 
[10:22:29.150]                           hostname = base::Sys.info()[["nodename"]])
[10:22:29.150]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:29.150]                           info)
[10:22:29.150]                         info <- base::paste(info, collapse = "; ")
[10:22:29.150]                         if (!has_future) {
[10:22:29.150]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:29.150]                             info)
[10:22:29.150]                         }
[10:22:29.150]                         else {
[10:22:29.150]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:29.150]                             info, version)
[10:22:29.150]                         }
[10:22:29.150]                         base::stop(msg)
[10:22:29.150]                       }
[10:22:29.150]                     })
[10:22:29.150]                   }
[10:22:29.150]                   ...future.strategy.old <- future::plan("list")
[10:22:29.150]                   options(future.plan = NULL)
[10:22:29.150]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:29.150]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:29.150]                 }
[10:22:29.150]                 ...future.workdir <- getwd()
[10:22:29.150]             }
[10:22:29.150]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:29.150]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:29.150]         }
[10:22:29.150]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:29.150]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:29.150]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:29.150]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:29.150]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:29.150]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:29.150]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:29.150]             base::names(...future.oldOptions))
[10:22:29.150]     }
[10:22:29.150]     if (FALSE) {
[10:22:29.150]     }
[10:22:29.150]     else {
[10:22:29.150]         if (TRUE) {
[10:22:29.150]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:29.150]                 open = "w")
[10:22:29.150]         }
[10:22:29.150]         else {
[10:22:29.150]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:29.150]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:29.150]         }
[10:22:29.150]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:29.150]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:29.150]             base::sink(type = "output", split = FALSE)
[10:22:29.150]             base::close(...future.stdout)
[10:22:29.150]         }, add = TRUE)
[10:22:29.150]     }
[10:22:29.150]     ...future.frame <- base::sys.nframe()
[10:22:29.150]     ...future.conditions <- base::list()
[10:22:29.150]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:29.150]     if (FALSE) {
[10:22:29.150]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:29.150]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:29.150]     }
[10:22:29.150]     ...future.result <- base::tryCatch({
[10:22:29.150]         base::withCallingHandlers({
[10:22:29.150]             ...future.value <- base::withVisible(base::local({
[10:22:29.150]                 2
[10:22:29.150]             }))
[10:22:29.150]             future::FutureResult(value = ...future.value$value, 
[10:22:29.150]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:29.150]                   ...future.rng), globalenv = if (FALSE) 
[10:22:29.150]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:29.150]                     ...future.globalenv.names))
[10:22:29.150]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:29.150]         }, condition = base::local({
[10:22:29.150]             c <- base::c
[10:22:29.150]             inherits <- base::inherits
[10:22:29.150]             invokeRestart <- base::invokeRestart
[10:22:29.150]             length <- base::length
[10:22:29.150]             list <- base::list
[10:22:29.150]             seq.int <- base::seq.int
[10:22:29.150]             signalCondition <- base::signalCondition
[10:22:29.150]             sys.calls <- base::sys.calls
[10:22:29.150]             `[[` <- base::`[[`
[10:22:29.150]             `+` <- base::`+`
[10:22:29.150]             `<<-` <- base::`<<-`
[10:22:29.150]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:29.150]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:29.150]                   3L)]
[10:22:29.150]             }
[10:22:29.150]             function(cond) {
[10:22:29.150]                 is_error <- inherits(cond, "error")
[10:22:29.150]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:29.150]                   NULL)
[10:22:29.150]                 if (is_error) {
[10:22:29.150]                   sessionInformation <- function() {
[10:22:29.150]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:29.150]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:29.150]                       search = base::search(), system = base::Sys.info())
[10:22:29.150]                   }
[10:22:29.150]                   ...future.conditions[[length(...future.conditions) + 
[10:22:29.150]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:29.150]                     cond$call), session = sessionInformation(), 
[10:22:29.150]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:29.150]                   signalCondition(cond)
[10:22:29.150]                 }
[10:22:29.150]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:29.150]                 "immediateCondition"))) {
[10:22:29.150]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:29.150]                   ...future.conditions[[length(...future.conditions) + 
[10:22:29.150]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:29.150]                   if (TRUE && !signal) {
[10:22:29.150]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.150]                     {
[10:22:29.150]                       inherits <- base::inherits
[10:22:29.150]                       invokeRestart <- base::invokeRestart
[10:22:29.150]                       is.null <- base::is.null
[10:22:29.150]                       muffled <- FALSE
[10:22:29.150]                       if (inherits(cond, "message")) {
[10:22:29.150]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:29.150]                         if (muffled) 
[10:22:29.150]                           invokeRestart("muffleMessage")
[10:22:29.150]                       }
[10:22:29.150]                       else if (inherits(cond, "warning")) {
[10:22:29.150]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:29.150]                         if (muffled) 
[10:22:29.150]                           invokeRestart("muffleWarning")
[10:22:29.150]                       }
[10:22:29.150]                       else if (inherits(cond, "condition")) {
[10:22:29.150]                         if (!is.null(pattern)) {
[10:22:29.150]                           computeRestarts <- base::computeRestarts
[10:22:29.150]                           grepl <- base::grepl
[10:22:29.150]                           restarts <- computeRestarts(cond)
[10:22:29.150]                           for (restart in restarts) {
[10:22:29.150]                             name <- restart$name
[10:22:29.150]                             if (is.null(name)) 
[10:22:29.150]                               next
[10:22:29.150]                             if (!grepl(pattern, name)) 
[10:22:29.150]                               next
[10:22:29.150]                             invokeRestart(restart)
[10:22:29.150]                             muffled <- TRUE
[10:22:29.150]                             break
[10:22:29.150]                           }
[10:22:29.150]                         }
[10:22:29.150]                       }
[10:22:29.150]                       invisible(muffled)
[10:22:29.150]                     }
[10:22:29.150]                     muffleCondition(cond, pattern = "^muffle")
[10:22:29.150]                   }
[10:22:29.150]                 }
[10:22:29.150]                 else {
[10:22:29.150]                   if (TRUE) {
[10:22:29.150]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.150]                     {
[10:22:29.150]                       inherits <- base::inherits
[10:22:29.150]                       invokeRestart <- base::invokeRestart
[10:22:29.150]                       is.null <- base::is.null
[10:22:29.150]                       muffled <- FALSE
[10:22:29.150]                       if (inherits(cond, "message")) {
[10:22:29.150]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:29.150]                         if (muffled) 
[10:22:29.150]                           invokeRestart("muffleMessage")
[10:22:29.150]                       }
[10:22:29.150]                       else if (inherits(cond, "warning")) {
[10:22:29.150]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:29.150]                         if (muffled) 
[10:22:29.150]                           invokeRestart("muffleWarning")
[10:22:29.150]                       }
[10:22:29.150]                       else if (inherits(cond, "condition")) {
[10:22:29.150]                         if (!is.null(pattern)) {
[10:22:29.150]                           computeRestarts <- base::computeRestarts
[10:22:29.150]                           grepl <- base::grepl
[10:22:29.150]                           restarts <- computeRestarts(cond)
[10:22:29.150]                           for (restart in restarts) {
[10:22:29.150]                             name <- restart$name
[10:22:29.150]                             if (is.null(name)) 
[10:22:29.150]                               next
[10:22:29.150]                             if (!grepl(pattern, name)) 
[10:22:29.150]                               next
[10:22:29.150]                             invokeRestart(restart)
[10:22:29.150]                             muffled <- TRUE
[10:22:29.150]                             break
[10:22:29.150]                           }
[10:22:29.150]                         }
[10:22:29.150]                       }
[10:22:29.150]                       invisible(muffled)
[10:22:29.150]                     }
[10:22:29.150]                     muffleCondition(cond, pattern = "^muffle")
[10:22:29.150]                   }
[10:22:29.150]                 }
[10:22:29.150]             }
[10:22:29.150]         }))
[10:22:29.150]     }, error = function(ex) {
[10:22:29.150]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:29.150]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:29.150]                 ...future.rng), started = ...future.startTime, 
[10:22:29.150]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:29.150]             version = "1.8"), class = "FutureResult")
[10:22:29.150]     }, finally = {
[10:22:29.150]         if (!identical(...future.workdir, getwd())) 
[10:22:29.150]             setwd(...future.workdir)
[10:22:29.150]         {
[10:22:29.150]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:29.150]                 ...future.oldOptions$nwarnings <- NULL
[10:22:29.150]             }
[10:22:29.150]             base::options(...future.oldOptions)
[10:22:29.150]             if (.Platform$OS.type == "windows") {
[10:22:29.150]                 old_names <- names(...future.oldEnvVars)
[10:22:29.150]                 envs <- base::Sys.getenv()
[10:22:29.150]                 names <- names(envs)
[10:22:29.150]                 common <- intersect(names, old_names)
[10:22:29.150]                 added <- setdiff(names, old_names)
[10:22:29.150]                 removed <- setdiff(old_names, names)
[10:22:29.150]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:29.150]                   envs[common]]
[10:22:29.150]                 NAMES <- toupper(changed)
[10:22:29.150]                 args <- list()
[10:22:29.150]                 for (kk in seq_along(NAMES)) {
[10:22:29.150]                   name <- changed[[kk]]
[10:22:29.150]                   NAME <- NAMES[[kk]]
[10:22:29.150]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.150]                     next
[10:22:29.150]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:29.150]                 }
[10:22:29.150]                 NAMES <- toupper(added)
[10:22:29.150]                 for (kk in seq_along(NAMES)) {
[10:22:29.150]                   name <- added[[kk]]
[10:22:29.150]                   NAME <- NAMES[[kk]]
[10:22:29.150]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.150]                     next
[10:22:29.150]                   args[[name]] <- ""
[10:22:29.150]                 }
[10:22:29.150]                 NAMES <- toupper(removed)
[10:22:29.150]                 for (kk in seq_along(NAMES)) {
[10:22:29.150]                   name <- removed[[kk]]
[10:22:29.150]                   NAME <- NAMES[[kk]]
[10:22:29.150]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.150]                     next
[10:22:29.150]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:29.150]                 }
[10:22:29.150]                 if (length(args) > 0) 
[10:22:29.150]                   base::do.call(base::Sys.setenv, args = args)
[10:22:29.150]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:29.150]             }
[10:22:29.150]             else {
[10:22:29.150]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:29.150]             }
[10:22:29.150]             {
[10:22:29.150]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:29.150]                   0L) {
[10:22:29.150]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:29.150]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:29.150]                   base::options(opts)
[10:22:29.150]                 }
[10:22:29.150]                 {
[10:22:29.150]                   {
[10:22:29.150]                     NULL
[10:22:29.150]                     RNGkind("Mersenne-Twister")
[10:22:29.150]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:29.150]                       inherits = FALSE)
[10:22:29.150]                   }
[10:22:29.150]                   options(future.plan = NULL)
[10:22:29.150]                   if (is.na(NA_character_)) 
[10:22:29.150]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:29.150]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:29.150]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:29.150]                     .init = FALSE)
[10:22:29.150]                 }
[10:22:29.150]             }
[10:22:29.150]         }
[10:22:29.150]     })
[10:22:29.150]     if (TRUE) {
[10:22:29.150]         base::sink(type = "output", split = FALSE)
[10:22:29.150]         if (TRUE) {
[10:22:29.150]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:29.150]         }
[10:22:29.150]         else {
[10:22:29.150]             ...future.result["stdout"] <- base::list(NULL)
[10:22:29.150]         }
[10:22:29.150]         base::close(...future.stdout)
[10:22:29.150]         ...future.stdout <- NULL
[10:22:29.150]     }
[10:22:29.150]     ...future.result$conditions <- ...future.conditions
[10:22:29.150]     ...future.result$finished <- base::Sys.time()
[10:22:29.150]     ...future.result
[10:22:29.150] }
[10:22:29.152] plan(): Setting new future strategy stack:
[10:22:29.152] List of future strategies:
[10:22:29.152] 1. sequential:
[10:22:29.152]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:29.152]    - tweaked: FALSE
[10:22:29.152]    - call: NULL
[10:22:29.153] plan(): nbrOfWorkers() = 1
[10:22:29.153] plan(): Setting new future strategy stack:
[10:22:29.153] List of future strategies:
[10:22:29.153] 1. sequential:
[10:22:29.153]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:29.153]    - tweaked: FALSE
[10:22:29.153]    - call: plan(strategy)
[10:22:29.154] plan(): nbrOfWorkers() = 1
[10:22:29.154] SequentialFuture started (and completed)
[10:22:29.154] - Launch lazy future ... done
[10:22:29.154] run() for ‘SequentialFuture’ ... done
[10:22:29.155] resolve() on environment ...
[10:22:29.155]  recursive: 0
[10:22:29.155]  elements: [3] ‘a’
[10:22:29.155] resolved() for ‘SequentialFuture’ ...
[10:22:29.155] - state: ‘finished’
[10:22:29.155] - run: TRUE
[10:22:29.156] - result: ‘FutureResult’
[10:22:29.156] resolved() for ‘SequentialFuture’ ... done
[10:22:29.156] Future #1
[10:22:29.156]  length: 2 (resolved future 1)
[10:22:29.156] resolved() for ‘SequentialFuture’ ...
[10:22:29.156] - state: ‘finished’
[10:22:29.156] - run: TRUE
[10:22:29.156] - result: ‘FutureResult’
[10:22:29.156] resolved() for ‘SequentialFuture’ ... done
[10:22:29.156] Future #2
[10:22:29.156]  length: 1 (resolved future 2)
[10:22:29.156]  length: 0 (resolved future 3)
[10:22:29.157] resolve() on environment ... DONE
[10:22:29.157] resolved() for ‘SequentialFuture’ ...
[10:22:29.157] - state: ‘finished’
[10:22:29.157] - run: TRUE
[10:22:29.157] - result: ‘FutureResult’
[10:22:29.157] resolved() for ‘SequentialFuture’ ... done
[10:22:29.157] resolve() on environment ...
[10:22:29.158]  recursive: 0
[10:22:29.158]  elements: [3] ‘b’
[10:22:29.158] resolved() for ‘SequentialFuture’ ...
[10:22:29.158] - state: ‘finished’
[10:22:29.158] - run: TRUE
[10:22:29.158] - result: ‘FutureResult’
[10:22:29.158] resolved() for ‘SequentialFuture’ ... done
[10:22:29.158] Future #1
[10:22:29.159]  length: 2 (resolved future 1)
[10:22:29.159] resolved() for ‘SequentialFuture’ ...
[10:22:29.159] - state: ‘finished’
[10:22:29.159] - run: TRUE
[10:22:29.159] - result: ‘FutureResult’
[10:22:29.159] resolved() for ‘SequentialFuture’ ... done
[10:22:29.159] Future #2
[10:22:29.159]  length: 1 (resolved future 2)
[10:22:29.159]  length: 0 (resolved future 3)
[10:22:29.159] resolve() on environment ... DONE
[10:22:29.160] resolve() on environment ...
[10:22:29.160]  recursive: 0
[10:22:29.160]  elements: [3] ‘c’
[10:22:29.160] resolved() for ‘SequentialFuture’ ...
[10:22:29.160] - state: ‘finished’
[10:22:29.161] - run: TRUE
[10:22:29.161] - result: ‘FutureResult’
[10:22:29.161] resolved() for ‘SequentialFuture’ ... done
[10:22:29.161] Future #1
[10:22:29.161]  length: 2 (resolved future 1)
[10:22:29.161] resolved() for ‘SequentialFuture’ ...
[10:22:29.161] - state: ‘finished’
[10:22:29.161] - run: TRUE
[10:22:29.161] - result: ‘FutureResult’
[10:22:29.161] resolved() for ‘SequentialFuture’ ... done
[10:22:29.161] Future #2
[10:22:29.161]  length: 1 (resolved future 2)
[10:22:29.162]  length: 0 (resolved future 3)
[10:22:29.162] resolve() on environment ... DONE
[10:22:29.162] resolve() on environment ...
[10:22:29.162]  recursive: 0
[10:22:29.163]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[10:22:29.163] resolved() for ‘SequentialFuture’ ...
[10:22:29.163] - state: ‘finished’
[10:22:29.163] - run: TRUE
[10:22:29.163] - result: ‘FutureResult’
[10:22:29.163] resolved() for ‘SequentialFuture’ ... done
[10:22:29.163] Future #1
[10:22:29.164]  length: 2 (resolved future 1)
[10:22:29.164] resolved() for ‘SequentialFuture’ ...
[10:22:29.164] - state: ‘finished’
[10:22:29.164] - run: TRUE
[10:22:29.164] - result: ‘FutureResult’
[10:22:29.164] resolved() for ‘SequentialFuture’ ... done
[10:22:29.164] Future #2
[10:22:29.164]  length: 1 (resolved future 2)
[10:22:29.164]  length: 0 (resolved future 3)
[10:22:29.164] resolve() on environment ... DONE
[10:22:29.165] resolve() on environment ...
[10:22:29.165]  recursive: 99
[10:22:29.165]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[10:22:29.165] resolved() for ‘SequentialFuture’ ...
[10:22:29.166] - state: ‘finished’
[10:22:29.166] - run: TRUE
[10:22:29.166] - result: ‘FutureResult’
[10:22:29.166] resolved() for ‘SequentialFuture’ ... done
[10:22:29.166] Future #1
[10:22:29.166] resolved() for ‘SequentialFuture’ ...
[10:22:29.166] - state: ‘finished’
[10:22:29.166] - run: TRUE
[10:22:29.166] - result: ‘FutureResult’
[10:22:29.166] resolved() for ‘SequentialFuture’ ... done
[10:22:29.166] A SequentialFuture was resolved
[10:22:29.167]  length: 2 (resolved future 1)
[10:22:29.167] resolved() for ‘SequentialFuture’ ...
[10:22:29.167] - state: ‘finished’
[10:22:29.167] - run: TRUE
[10:22:29.167] - result: ‘FutureResult’
[10:22:29.167] resolved() for ‘SequentialFuture’ ... done
[10:22:29.167] Future #2
[10:22:29.167] resolved() for ‘SequentialFuture’ ...
[10:22:29.167] - state: ‘finished’
[10:22:29.167] - run: TRUE
[10:22:29.167] - result: ‘FutureResult’
[10:22:29.167] resolved() for ‘SequentialFuture’ ... done
[10:22:29.169] A SequentialFuture was resolved
[10:22:29.169]  length: 1 (resolved future 2)
[10:22:29.169]  length: 0 (resolved future 3)
[10:22:29.169] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[10:22:29.170] resolve() on list environment ...
[10:22:29.170]  recursive: 0
[10:22:29.171]  length: 2
[10:22:29.171]  elements: ‘a’, ‘b’
[10:22:29.171]  length: 1 (resolved future 1)
[10:22:29.172]  length: 0 (resolved future 2)
[10:22:29.172] resolve() on list environment ... DONE
[10:22:29.172] getGlobalsAndPackages() ...
[10:22:29.172] Searching for globals...
[10:22:29.172] 
[10:22:29.172] Searching for globals ... DONE
[10:22:29.172] - globals: [0] <none>
[10:22:29.172] getGlobalsAndPackages() ... DONE
[10:22:29.173] run() for ‘Future’ ...
[10:22:29.173] - state: ‘created’
[10:22:29.173] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:29.173] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:29.173] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:29.173]   - Field: ‘label’
[10:22:29.173]   - Field: ‘local’
[10:22:29.173]   - Field: ‘owner’
[10:22:29.173]   - Field: ‘envir’
[10:22:29.174]   - Field: ‘packages’
[10:22:29.174]   - Field: ‘gc’
[10:22:29.174]   - Field: ‘conditions’
[10:22:29.174]   - Field: ‘expr’
[10:22:29.174]   - Field: ‘uuid’
[10:22:29.174]   - Field: ‘seed’
[10:22:29.174]   - Field: ‘version’
[10:22:29.174]   - Field: ‘result’
[10:22:29.174]   - Field: ‘asynchronous’
[10:22:29.174]   - Field: ‘calls’
[10:22:29.174]   - Field: ‘globals’
[10:22:29.174]   - Field: ‘stdout’
[10:22:29.175]   - Field: ‘earlySignal’
[10:22:29.175]   - Field: ‘lazy’
[10:22:29.175]   - Field: ‘state’
[10:22:29.175] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:29.175] - Launch lazy future ...
[10:22:29.175] Packages needed by the future expression (n = 0): <none>
[10:22:29.175] Packages needed by future strategies (n = 0): <none>
[10:22:29.176] {
[10:22:29.176]     {
[10:22:29.176]         {
[10:22:29.176]             ...future.startTime <- base::Sys.time()
[10:22:29.176]             {
[10:22:29.176]                 {
[10:22:29.176]                   {
[10:22:29.176]                     base::local({
[10:22:29.176]                       has_future <- base::requireNamespace("future", 
[10:22:29.176]                         quietly = TRUE)
[10:22:29.176]                       if (has_future) {
[10:22:29.176]                         ns <- base::getNamespace("future")
[10:22:29.176]                         version <- ns[[".package"]][["version"]]
[10:22:29.176]                         if (is.null(version)) 
[10:22:29.176]                           version <- utils::packageVersion("future")
[10:22:29.176]                       }
[10:22:29.176]                       else {
[10:22:29.176]                         version <- NULL
[10:22:29.176]                       }
[10:22:29.176]                       if (!has_future || version < "1.8.0") {
[10:22:29.176]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:29.176]                           "", base::R.version$version.string), 
[10:22:29.176]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:29.176]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:29.176]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:29.176]                             "release", "version")], collapse = " "), 
[10:22:29.176]                           hostname = base::Sys.info()[["nodename"]])
[10:22:29.176]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:29.176]                           info)
[10:22:29.176]                         info <- base::paste(info, collapse = "; ")
[10:22:29.176]                         if (!has_future) {
[10:22:29.176]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:29.176]                             info)
[10:22:29.176]                         }
[10:22:29.176]                         else {
[10:22:29.176]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:29.176]                             info, version)
[10:22:29.176]                         }
[10:22:29.176]                         base::stop(msg)
[10:22:29.176]                       }
[10:22:29.176]                     })
[10:22:29.176]                   }
[10:22:29.176]                   ...future.strategy.old <- future::plan("list")
[10:22:29.176]                   options(future.plan = NULL)
[10:22:29.176]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:29.176]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:29.176]                 }
[10:22:29.176]                 ...future.workdir <- getwd()
[10:22:29.176]             }
[10:22:29.176]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:29.176]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:29.176]         }
[10:22:29.176]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:29.176]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:29.176]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:29.176]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:29.176]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:29.176]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:29.176]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:29.176]             base::names(...future.oldOptions))
[10:22:29.176]     }
[10:22:29.176]     if (FALSE) {
[10:22:29.176]     }
[10:22:29.176]     else {
[10:22:29.176]         if (TRUE) {
[10:22:29.176]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:29.176]                 open = "w")
[10:22:29.176]         }
[10:22:29.176]         else {
[10:22:29.176]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:29.176]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:29.176]         }
[10:22:29.176]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:29.176]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:29.176]             base::sink(type = "output", split = FALSE)
[10:22:29.176]             base::close(...future.stdout)
[10:22:29.176]         }, add = TRUE)
[10:22:29.176]     }
[10:22:29.176]     ...future.frame <- base::sys.nframe()
[10:22:29.176]     ...future.conditions <- base::list()
[10:22:29.176]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:29.176]     if (FALSE) {
[10:22:29.176]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:29.176]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:29.176]     }
[10:22:29.176]     ...future.result <- base::tryCatch({
[10:22:29.176]         base::withCallingHandlers({
[10:22:29.176]             ...future.value <- base::withVisible(base::local(1))
[10:22:29.176]             future::FutureResult(value = ...future.value$value, 
[10:22:29.176]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:29.176]                   ...future.rng), globalenv = if (FALSE) 
[10:22:29.176]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:29.176]                     ...future.globalenv.names))
[10:22:29.176]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:29.176]         }, condition = base::local({
[10:22:29.176]             c <- base::c
[10:22:29.176]             inherits <- base::inherits
[10:22:29.176]             invokeRestart <- base::invokeRestart
[10:22:29.176]             length <- base::length
[10:22:29.176]             list <- base::list
[10:22:29.176]             seq.int <- base::seq.int
[10:22:29.176]             signalCondition <- base::signalCondition
[10:22:29.176]             sys.calls <- base::sys.calls
[10:22:29.176]             `[[` <- base::`[[`
[10:22:29.176]             `+` <- base::`+`
[10:22:29.176]             `<<-` <- base::`<<-`
[10:22:29.176]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:29.176]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:29.176]                   3L)]
[10:22:29.176]             }
[10:22:29.176]             function(cond) {
[10:22:29.176]                 is_error <- inherits(cond, "error")
[10:22:29.176]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:29.176]                   NULL)
[10:22:29.176]                 if (is_error) {
[10:22:29.176]                   sessionInformation <- function() {
[10:22:29.176]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:29.176]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:29.176]                       search = base::search(), system = base::Sys.info())
[10:22:29.176]                   }
[10:22:29.176]                   ...future.conditions[[length(...future.conditions) + 
[10:22:29.176]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:29.176]                     cond$call), session = sessionInformation(), 
[10:22:29.176]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:29.176]                   signalCondition(cond)
[10:22:29.176]                 }
[10:22:29.176]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:29.176]                 "immediateCondition"))) {
[10:22:29.176]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:29.176]                   ...future.conditions[[length(...future.conditions) + 
[10:22:29.176]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:29.176]                   if (TRUE && !signal) {
[10:22:29.176]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.176]                     {
[10:22:29.176]                       inherits <- base::inherits
[10:22:29.176]                       invokeRestart <- base::invokeRestart
[10:22:29.176]                       is.null <- base::is.null
[10:22:29.176]                       muffled <- FALSE
[10:22:29.176]                       if (inherits(cond, "message")) {
[10:22:29.176]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:29.176]                         if (muffled) 
[10:22:29.176]                           invokeRestart("muffleMessage")
[10:22:29.176]                       }
[10:22:29.176]                       else if (inherits(cond, "warning")) {
[10:22:29.176]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:29.176]                         if (muffled) 
[10:22:29.176]                           invokeRestart("muffleWarning")
[10:22:29.176]                       }
[10:22:29.176]                       else if (inherits(cond, "condition")) {
[10:22:29.176]                         if (!is.null(pattern)) {
[10:22:29.176]                           computeRestarts <- base::computeRestarts
[10:22:29.176]                           grepl <- base::grepl
[10:22:29.176]                           restarts <- computeRestarts(cond)
[10:22:29.176]                           for (restart in restarts) {
[10:22:29.176]                             name <- restart$name
[10:22:29.176]                             if (is.null(name)) 
[10:22:29.176]                               next
[10:22:29.176]                             if (!grepl(pattern, name)) 
[10:22:29.176]                               next
[10:22:29.176]                             invokeRestart(restart)
[10:22:29.176]                             muffled <- TRUE
[10:22:29.176]                             break
[10:22:29.176]                           }
[10:22:29.176]                         }
[10:22:29.176]                       }
[10:22:29.176]                       invisible(muffled)
[10:22:29.176]                     }
[10:22:29.176]                     muffleCondition(cond, pattern = "^muffle")
[10:22:29.176]                   }
[10:22:29.176]                 }
[10:22:29.176]                 else {
[10:22:29.176]                   if (TRUE) {
[10:22:29.176]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.176]                     {
[10:22:29.176]                       inherits <- base::inherits
[10:22:29.176]                       invokeRestart <- base::invokeRestart
[10:22:29.176]                       is.null <- base::is.null
[10:22:29.176]                       muffled <- FALSE
[10:22:29.176]                       if (inherits(cond, "message")) {
[10:22:29.176]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:29.176]                         if (muffled) 
[10:22:29.176]                           invokeRestart("muffleMessage")
[10:22:29.176]                       }
[10:22:29.176]                       else if (inherits(cond, "warning")) {
[10:22:29.176]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:29.176]                         if (muffled) 
[10:22:29.176]                           invokeRestart("muffleWarning")
[10:22:29.176]                       }
[10:22:29.176]                       else if (inherits(cond, "condition")) {
[10:22:29.176]                         if (!is.null(pattern)) {
[10:22:29.176]                           computeRestarts <- base::computeRestarts
[10:22:29.176]                           grepl <- base::grepl
[10:22:29.176]                           restarts <- computeRestarts(cond)
[10:22:29.176]                           for (restart in restarts) {
[10:22:29.176]                             name <- restart$name
[10:22:29.176]                             if (is.null(name)) 
[10:22:29.176]                               next
[10:22:29.176]                             if (!grepl(pattern, name)) 
[10:22:29.176]                               next
[10:22:29.176]                             invokeRestart(restart)
[10:22:29.176]                             muffled <- TRUE
[10:22:29.176]                             break
[10:22:29.176]                           }
[10:22:29.176]                         }
[10:22:29.176]                       }
[10:22:29.176]                       invisible(muffled)
[10:22:29.176]                     }
[10:22:29.176]                     muffleCondition(cond, pattern = "^muffle")
[10:22:29.176]                   }
[10:22:29.176]                 }
[10:22:29.176]             }
[10:22:29.176]         }))
[10:22:29.176]     }, error = function(ex) {
[10:22:29.176]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:29.176]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:29.176]                 ...future.rng), started = ...future.startTime, 
[10:22:29.176]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:29.176]             version = "1.8"), class = "FutureResult")
[10:22:29.176]     }, finally = {
[10:22:29.176]         if (!identical(...future.workdir, getwd())) 
[10:22:29.176]             setwd(...future.workdir)
[10:22:29.176]         {
[10:22:29.176]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:29.176]                 ...future.oldOptions$nwarnings <- NULL
[10:22:29.176]             }
[10:22:29.176]             base::options(...future.oldOptions)
[10:22:29.176]             if (.Platform$OS.type == "windows") {
[10:22:29.176]                 old_names <- names(...future.oldEnvVars)
[10:22:29.176]                 envs <- base::Sys.getenv()
[10:22:29.176]                 names <- names(envs)
[10:22:29.176]                 common <- intersect(names, old_names)
[10:22:29.176]                 added <- setdiff(names, old_names)
[10:22:29.176]                 removed <- setdiff(old_names, names)
[10:22:29.176]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:29.176]                   envs[common]]
[10:22:29.176]                 NAMES <- toupper(changed)
[10:22:29.176]                 args <- list()
[10:22:29.176]                 for (kk in seq_along(NAMES)) {
[10:22:29.176]                   name <- changed[[kk]]
[10:22:29.176]                   NAME <- NAMES[[kk]]
[10:22:29.176]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.176]                     next
[10:22:29.176]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:29.176]                 }
[10:22:29.176]                 NAMES <- toupper(added)
[10:22:29.176]                 for (kk in seq_along(NAMES)) {
[10:22:29.176]                   name <- added[[kk]]
[10:22:29.176]                   NAME <- NAMES[[kk]]
[10:22:29.176]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.176]                     next
[10:22:29.176]                   args[[name]] <- ""
[10:22:29.176]                 }
[10:22:29.176]                 NAMES <- toupper(removed)
[10:22:29.176]                 for (kk in seq_along(NAMES)) {
[10:22:29.176]                   name <- removed[[kk]]
[10:22:29.176]                   NAME <- NAMES[[kk]]
[10:22:29.176]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.176]                     next
[10:22:29.176]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:29.176]                 }
[10:22:29.176]                 if (length(args) > 0) 
[10:22:29.176]                   base::do.call(base::Sys.setenv, args = args)
[10:22:29.176]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:29.176]             }
[10:22:29.176]             else {
[10:22:29.176]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:29.176]             }
[10:22:29.176]             {
[10:22:29.176]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:29.176]                   0L) {
[10:22:29.176]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:29.176]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:29.176]                   base::options(opts)
[10:22:29.176]                 }
[10:22:29.176]                 {
[10:22:29.176]                   {
[10:22:29.176]                     NULL
[10:22:29.176]                     RNGkind("Mersenne-Twister")
[10:22:29.176]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:29.176]                       inherits = FALSE)
[10:22:29.176]                   }
[10:22:29.176]                   options(future.plan = NULL)
[10:22:29.176]                   if (is.na(NA_character_)) 
[10:22:29.176]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:29.176]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:29.176]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:29.176]                     .init = FALSE)
[10:22:29.176]                 }
[10:22:29.176]             }
[10:22:29.176]         }
[10:22:29.176]     })
[10:22:29.176]     if (TRUE) {
[10:22:29.176]         base::sink(type = "output", split = FALSE)
[10:22:29.176]         if (TRUE) {
[10:22:29.176]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:29.176]         }
[10:22:29.176]         else {
[10:22:29.176]             ...future.result["stdout"] <- base::list(NULL)
[10:22:29.176]         }
[10:22:29.176]         base::close(...future.stdout)
[10:22:29.176]         ...future.stdout <- NULL
[10:22:29.176]     }
[10:22:29.176]     ...future.result$conditions <- ...future.conditions
[10:22:29.176]     ...future.result$finished <- base::Sys.time()
[10:22:29.176]     ...future.result
[10:22:29.176] }
[10:22:29.177] plan(): Setting new future strategy stack:
[10:22:29.177] List of future strategies:
[10:22:29.177] 1. sequential:
[10:22:29.177]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:29.177]    - tweaked: FALSE
[10:22:29.177]    - call: NULL
[10:22:29.178] plan(): nbrOfWorkers() = 1
[10:22:29.179] plan(): Setting new future strategy stack:
[10:22:29.179] List of future strategies:
[10:22:29.179] 1. sequential:
[10:22:29.179]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:29.179]    - tweaked: FALSE
[10:22:29.179]    - call: plan(strategy)
[10:22:29.179] plan(): nbrOfWorkers() = 1
[10:22:29.179] SequentialFuture started (and completed)
[10:22:29.179] - Launch lazy future ... done
[10:22:29.179] run() for ‘SequentialFuture’ ... done
[10:22:29.180] getGlobalsAndPackages() ...
[10:22:29.180] Searching for globals...
[10:22:29.180] 
[10:22:29.180] Searching for globals ... DONE
[10:22:29.180] - globals: [0] <none>
[10:22:29.180] getGlobalsAndPackages() ... DONE
[10:22:29.180] run() for ‘Future’ ...
[10:22:29.180] - state: ‘created’
[10:22:29.181] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:29.181] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:29.181] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:29.181]   - Field: ‘label’
[10:22:29.181]   - Field: ‘local’
[10:22:29.181]   - Field: ‘owner’
[10:22:29.181]   - Field: ‘envir’
[10:22:29.181]   - Field: ‘packages’
[10:22:29.181]   - Field: ‘gc’
[10:22:29.181]   - Field: ‘conditions’
[10:22:29.182]   - Field: ‘expr’
[10:22:29.182]   - Field: ‘uuid’
[10:22:29.182]   - Field: ‘seed’
[10:22:29.182]   - Field: ‘version’
[10:22:29.182]   - Field: ‘result’
[10:22:29.182]   - Field: ‘asynchronous’
[10:22:29.182]   - Field: ‘calls’
[10:22:29.182]   - Field: ‘globals’
[10:22:29.182]   - Field: ‘stdout’
[10:22:29.182]   - Field: ‘earlySignal’
[10:22:29.182]   - Field: ‘lazy’
[10:22:29.182]   - Field: ‘state’
[10:22:29.183] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:29.183] - Launch lazy future ...
[10:22:29.183] Packages needed by the future expression (n = 0): <none>
[10:22:29.183] Packages needed by future strategies (n = 0): <none>
[10:22:29.183] {
[10:22:29.183]     {
[10:22:29.183]         {
[10:22:29.183]             ...future.startTime <- base::Sys.time()
[10:22:29.183]             {
[10:22:29.183]                 {
[10:22:29.183]                   {
[10:22:29.183]                     base::local({
[10:22:29.183]                       has_future <- base::requireNamespace("future", 
[10:22:29.183]                         quietly = TRUE)
[10:22:29.183]                       if (has_future) {
[10:22:29.183]                         ns <- base::getNamespace("future")
[10:22:29.183]                         version <- ns[[".package"]][["version"]]
[10:22:29.183]                         if (is.null(version)) 
[10:22:29.183]                           version <- utils::packageVersion("future")
[10:22:29.183]                       }
[10:22:29.183]                       else {
[10:22:29.183]                         version <- NULL
[10:22:29.183]                       }
[10:22:29.183]                       if (!has_future || version < "1.8.0") {
[10:22:29.183]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:29.183]                           "", base::R.version$version.string), 
[10:22:29.183]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:29.183]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:29.183]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:29.183]                             "release", "version")], collapse = " "), 
[10:22:29.183]                           hostname = base::Sys.info()[["nodename"]])
[10:22:29.183]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:29.183]                           info)
[10:22:29.183]                         info <- base::paste(info, collapse = "; ")
[10:22:29.183]                         if (!has_future) {
[10:22:29.183]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:29.183]                             info)
[10:22:29.183]                         }
[10:22:29.183]                         else {
[10:22:29.183]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:29.183]                             info, version)
[10:22:29.183]                         }
[10:22:29.183]                         base::stop(msg)
[10:22:29.183]                       }
[10:22:29.183]                     })
[10:22:29.183]                   }
[10:22:29.183]                   ...future.strategy.old <- future::plan("list")
[10:22:29.183]                   options(future.plan = NULL)
[10:22:29.183]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:29.183]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:29.183]                 }
[10:22:29.183]                 ...future.workdir <- getwd()
[10:22:29.183]             }
[10:22:29.183]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:29.183]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:29.183]         }
[10:22:29.183]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:29.183]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:29.183]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:29.183]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:29.183]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:29.183]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:29.183]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:29.183]             base::names(...future.oldOptions))
[10:22:29.183]     }
[10:22:29.183]     if (FALSE) {
[10:22:29.183]     }
[10:22:29.183]     else {
[10:22:29.183]         if (TRUE) {
[10:22:29.183]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:29.183]                 open = "w")
[10:22:29.183]         }
[10:22:29.183]         else {
[10:22:29.183]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:29.183]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:29.183]         }
[10:22:29.183]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:29.183]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:29.183]             base::sink(type = "output", split = FALSE)
[10:22:29.183]             base::close(...future.stdout)
[10:22:29.183]         }, add = TRUE)
[10:22:29.183]     }
[10:22:29.183]     ...future.frame <- base::sys.nframe()
[10:22:29.183]     ...future.conditions <- base::list()
[10:22:29.183]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:29.183]     if (FALSE) {
[10:22:29.183]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:29.183]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:29.183]     }
[10:22:29.183]     ...future.result <- base::tryCatch({
[10:22:29.183]         base::withCallingHandlers({
[10:22:29.183]             ...future.value <- base::withVisible(base::local(2))
[10:22:29.183]             future::FutureResult(value = ...future.value$value, 
[10:22:29.183]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:29.183]                   ...future.rng), globalenv = if (FALSE) 
[10:22:29.183]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:29.183]                     ...future.globalenv.names))
[10:22:29.183]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:29.183]         }, condition = base::local({
[10:22:29.183]             c <- base::c
[10:22:29.183]             inherits <- base::inherits
[10:22:29.183]             invokeRestart <- base::invokeRestart
[10:22:29.183]             length <- base::length
[10:22:29.183]             list <- base::list
[10:22:29.183]             seq.int <- base::seq.int
[10:22:29.183]             signalCondition <- base::signalCondition
[10:22:29.183]             sys.calls <- base::sys.calls
[10:22:29.183]             `[[` <- base::`[[`
[10:22:29.183]             `+` <- base::`+`
[10:22:29.183]             `<<-` <- base::`<<-`
[10:22:29.183]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:29.183]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:29.183]                   3L)]
[10:22:29.183]             }
[10:22:29.183]             function(cond) {
[10:22:29.183]                 is_error <- inherits(cond, "error")
[10:22:29.183]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:29.183]                   NULL)
[10:22:29.183]                 if (is_error) {
[10:22:29.183]                   sessionInformation <- function() {
[10:22:29.183]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:29.183]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:29.183]                       search = base::search(), system = base::Sys.info())
[10:22:29.183]                   }
[10:22:29.183]                   ...future.conditions[[length(...future.conditions) + 
[10:22:29.183]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:29.183]                     cond$call), session = sessionInformation(), 
[10:22:29.183]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:29.183]                   signalCondition(cond)
[10:22:29.183]                 }
[10:22:29.183]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:29.183]                 "immediateCondition"))) {
[10:22:29.183]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:29.183]                   ...future.conditions[[length(...future.conditions) + 
[10:22:29.183]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:29.183]                   if (TRUE && !signal) {
[10:22:29.183]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.183]                     {
[10:22:29.183]                       inherits <- base::inherits
[10:22:29.183]                       invokeRestart <- base::invokeRestart
[10:22:29.183]                       is.null <- base::is.null
[10:22:29.183]                       muffled <- FALSE
[10:22:29.183]                       if (inherits(cond, "message")) {
[10:22:29.183]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:29.183]                         if (muffled) 
[10:22:29.183]                           invokeRestart("muffleMessage")
[10:22:29.183]                       }
[10:22:29.183]                       else if (inherits(cond, "warning")) {
[10:22:29.183]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:29.183]                         if (muffled) 
[10:22:29.183]                           invokeRestart("muffleWarning")
[10:22:29.183]                       }
[10:22:29.183]                       else if (inherits(cond, "condition")) {
[10:22:29.183]                         if (!is.null(pattern)) {
[10:22:29.183]                           computeRestarts <- base::computeRestarts
[10:22:29.183]                           grepl <- base::grepl
[10:22:29.183]                           restarts <- computeRestarts(cond)
[10:22:29.183]                           for (restart in restarts) {
[10:22:29.183]                             name <- restart$name
[10:22:29.183]                             if (is.null(name)) 
[10:22:29.183]                               next
[10:22:29.183]                             if (!grepl(pattern, name)) 
[10:22:29.183]                               next
[10:22:29.183]                             invokeRestart(restart)
[10:22:29.183]                             muffled <- TRUE
[10:22:29.183]                             break
[10:22:29.183]                           }
[10:22:29.183]                         }
[10:22:29.183]                       }
[10:22:29.183]                       invisible(muffled)
[10:22:29.183]                     }
[10:22:29.183]                     muffleCondition(cond, pattern = "^muffle")
[10:22:29.183]                   }
[10:22:29.183]                 }
[10:22:29.183]                 else {
[10:22:29.183]                   if (TRUE) {
[10:22:29.183]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.183]                     {
[10:22:29.183]                       inherits <- base::inherits
[10:22:29.183]                       invokeRestart <- base::invokeRestart
[10:22:29.183]                       is.null <- base::is.null
[10:22:29.183]                       muffled <- FALSE
[10:22:29.183]                       if (inherits(cond, "message")) {
[10:22:29.183]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:29.183]                         if (muffled) 
[10:22:29.183]                           invokeRestart("muffleMessage")
[10:22:29.183]                       }
[10:22:29.183]                       else if (inherits(cond, "warning")) {
[10:22:29.183]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:29.183]                         if (muffled) 
[10:22:29.183]                           invokeRestart("muffleWarning")
[10:22:29.183]                       }
[10:22:29.183]                       else if (inherits(cond, "condition")) {
[10:22:29.183]                         if (!is.null(pattern)) {
[10:22:29.183]                           computeRestarts <- base::computeRestarts
[10:22:29.183]                           grepl <- base::grepl
[10:22:29.183]                           restarts <- computeRestarts(cond)
[10:22:29.183]                           for (restart in restarts) {
[10:22:29.183]                             name <- restart$name
[10:22:29.183]                             if (is.null(name)) 
[10:22:29.183]                               next
[10:22:29.183]                             if (!grepl(pattern, name)) 
[10:22:29.183]                               next
[10:22:29.183]                             invokeRestart(restart)
[10:22:29.183]                             muffled <- TRUE
[10:22:29.183]                             break
[10:22:29.183]                           }
[10:22:29.183]                         }
[10:22:29.183]                       }
[10:22:29.183]                       invisible(muffled)
[10:22:29.183]                     }
[10:22:29.183]                     muffleCondition(cond, pattern = "^muffle")
[10:22:29.183]                   }
[10:22:29.183]                 }
[10:22:29.183]             }
[10:22:29.183]         }))
[10:22:29.183]     }, error = function(ex) {
[10:22:29.183]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:29.183]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:29.183]                 ...future.rng), started = ...future.startTime, 
[10:22:29.183]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:29.183]             version = "1.8"), class = "FutureResult")
[10:22:29.183]     }, finally = {
[10:22:29.183]         if (!identical(...future.workdir, getwd())) 
[10:22:29.183]             setwd(...future.workdir)
[10:22:29.183]         {
[10:22:29.183]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:29.183]                 ...future.oldOptions$nwarnings <- NULL
[10:22:29.183]             }
[10:22:29.183]             base::options(...future.oldOptions)
[10:22:29.183]             if (.Platform$OS.type == "windows") {
[10:22:29.183]                 old_names <- names(...future.oldEnvVars)
[10:22:29.183]                 envs <- base::Sys.getenv()
[10:22:29.183]                 names <- names(envs)
[10:22:29.183]                 common <- intersect(names, old_names)
[10:22:29.183]                 added <- setdiff(names, old_names)
[10:22:29.183]                 removed <- setdiff(old_names, names)
[10:22:29.183]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:29.183]                   envs[common]]
[10:22:29.183]                 NAMES <- toupper(changed)
[10:22:29.183]                 args <- list()
[10:22:29.183]                 for (kk in seq_along(NAMES)) {
[10:22:29.183]                   name <- changed[[kk]]
[10:22:29.183]                   NAME <- NAMES[[kk]]
[10:22:29.183]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.183]                     next
[10:22:29.183]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:29.183]                 }
[10:22:29.183]                 NAMES <- toupper(added)
[10:22:29.183]                 for (kk in seq_along(NAMES)) {
[10:22:29.183]                   name <- added[[kk]]
[10:22:29.183]                   NAME <- NAMES[[kk]]
[10:22:29.183]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.183]                     next
[10:22:29.183]                   args[[name]] <- ""
[10:22:29.183]                 }
[10:22:29.183]                 NAMES <- toupper(removed)
[10:22:29.183]                 for (kk in seq_along(NAMES)) {
[10:22:29.183]                   name <- removed[[kk]]
[10:22:29.183]                   NAME <- NAMES[[kk]]
[10:22:29.183]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.183]                     next
[10:22:29.183]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:29.183]                 }
[10:22:29.183]                 if (length(args) > 0) 
[10:22:29.183]                   base::do.call(base::Sys.setenv, args = args)
[10:22:29.183]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:29.183]             }
[10:22:29.183]             else {
[10:22:29.183]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:29.183]             }
[10:22:29.183]             {
[10:22:29.183]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:29.183]                   0L) {
[10:22:29.183]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:29.183]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:29.183]                   base::options(opts)
[10:22:29.183]                 }
[10:22:29.183]                 {
[10:22:29.183]                   {
[10:22:29.183]                     NULL
[10:22:29.183]                     RNGkind("Mersenne-Twister")
[10:22:29.183]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:29.183]                       inherits = FALSE)
[10:22:29.183]                   }
[10:22:29.183]                   options(future.plan = NULL)
[10:22:29.183]                   if (is.na(NA_character_)) 
[10:22:29.183]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:29.183]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:29.183]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:29.183]                     .init = FALSE)
[10:22:29.183]                 }
[10:22:29.183]             }
[10:22:29.183]         }
[10:22:29.183]     })
[10:22:29.183]     if (TRUE) {
[10:22:29.183]         base::sink(type = "output", split = FALSE)
[10:22:29.183]         if (TRUE) {
[10:22:29.183]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:29.183]         }
[10:22:29.183]         else {
[10:22:29.183]             ...future.result["stdout"] <- base::list(NULL)
[10:22:29.183]         }
[10:22:29.183]         base::close(...future.stdout)
[10:22:29.183]         ...future.stdout <- NULL
[10:22:29.183]     }
[10:22:29.183]     ...future.result$conditions <- ...future.conditions
[10:22:29.183]     ...future.result$finished <- base::Sys.time()
[10:22:29.183]     ...future.result
[10:22:29.183] }
[10:22:29.185] plan(): Setting new future strategy stack:
[10:22:29.185] List of future strategies:
[10:22:29.185] 1. sequential:
[10:22:29.185]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:29.185]    - tweaked: FALSE
[10:22:29.185]    - call: NULL
[10:22:29.186] plan(): nbrOfWorkers() = 1
[10:22:29.186] plan(): Setting new future strategy stack:
[10:22:29.186] List of future strategies:
[10:22:29.186] 1. sequential:
[10:22:29.186]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:29.186]    - tweaked: FALSE
[10:22:29.186]    - call: plan(strategy)
[10:22:29.187] plan(): nbrOfWorkers() = 1
[10:22:29.187] SequentialFuture started (and completed)
[10:22:29.187] - Launch lazy future ... done
[10:22:29.187] run() for ‘SequentialFuture’ ... done
[10:22:29.188] resolve() on list environment ...
[10:22:29.188]  recursive: 0
[10:22:29.188]  length: 3
[10:22:29.188]  elements: ‘a’, ‘b’, ‘c’
[10:22:29.189] resolved() for ‘SequentialFuture’ ...
[10:22:29.189] - state: ‘finished’
[10:22:29.189] - run: TRUE
[10:22:29.189] - result: ‘FutureResult’
[10:22:29.189] resolved() for ‘SequentialFuture’ ... done
[10:22:29.189] Future #1
[10:22:29.189]  length: 2 (resolved future 1)
[10:22:29.189] resolved() for ‘SequentialFuture’ ...
[10:22:29.189] - state: ‘finished’
[10:22:29.189] - run: TRUE
[10:22:29.189] - result: ‘FutureResult’
[10:22:29.189] resolved() for ‘SequentialFuture’ ... done
[10:22:29.190] Future #2
[10:22:29.190]  length: 1 (resolved future 2)
[10:22:29.190]  length: 0 (resolved future 3)
[10:22:29.190] resolve() on list environment ... DONE
[10:22:29.191] getGlobalsAndPackages() ...
[10:22:29.191] Searching for globals...
[10:22:29.191] - globals found: [1] ‘{’
[10:22:29.191] Searching for globals ... DONE
[10:22:29.191] Resolving globals: FALSE
[10:22:29.192] 
[10:22:29.192] 
[10:22:29.192] getGlobalsAndPackages() ... DONE
[10:22:29.192] run() for ‘Future’ ...
[10:22:29.192] - state: ‘created’
[10:22:29.192] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:29.192] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:29.193] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:29.193]   - Field: ‘label’
[10:22:29.193]   - Field: ‘local’
[10:22:29.193]   - Field: ‘owner’
[10:22:29.193]   - Field: ‘envir’
[10:22:29.193]   - Field: ‘packages’
[10:22:29.193]   - Field: ‘gc’
[10:22:29.195]   - Field: ‘conditions’
[10:22:29.195]   - Field: ‘expr’
[10:22:29.195]   - Field: ‘uuid’
[10:22:29.195]   - Field: ‘seed’
[10:22:29.195]   - Field: ‘version’
[10:22:29.195]   - Field: ‘result’
[10:22:29.195]   - Field: ‘asynchronous’
[10:22:29.195]   - Field: ‘calls’
[10:22:29.195]   - Field: ‘globals’
[10:22:29.196]   - Field: ‘stdout’
[10:22:29.196]   - Field: ‘earlySignal’
[10:22:29.196]   - Field: ‘lazy’
[10:22:29.196]   - Field: ‘state’
[10:22:29.196] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:29.196] - Launch lazy future ...
[10:22:29.196] Packages needed by the future expression (n = 0): <none>
[10:22:29.196] Packages needed by future strategies (n = 0): <none>
[10:22:29.197] {
[10:22:29.197]     {
[10:22:29.197]         {
[10:22:29.197]             ...future.startTime <- base::Sys.time()
[10:22:29.197]             {
[10:22:29.197]                 {
[10:22:29.197]                   {
[10:22:29.197]                     base::local({
[10:22:29.197]                       has_future <- base::requireNamespace("future", 
[10:22:29.197]                         quietly = TRUE)
[10:22:29.197]                       if (has_future) {
[10:22:29.197]                         ns <- base::getNamespace("future")
[10:22:29.197]                         version <- ns[[".package"]][["version"]]
[10:22:29.197]                         if (is.null(version)) 
[10:22:29.197]                           version <- utils::packageVersion("future")
[10:22:29.197]                       }
[10:22:29.197]                       else {
[10:22:29.197]                         version <- NULL
[10:22:29.197]                       }
[10:22:29.197]                       if (!has_future || version < "1.8.0") {
[10:22:29.197]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:29.197]                           "", base::R.version$version.string), 
[10:22:29.197]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:29.197]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:29.197]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:29.197]                             "release", "version")], collapse = " "), 
[10:22:29.197]                           hostname = base::Sys.info()[["nodename"]])
[10:22:29.197]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:29.197]                           info)
[10:22:29.197]                         info <- base::paste(info, collapse = "; ")
[10:22:29.197]                         if (!has_future) {
[10:22:29.197]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:29.197]                             info)
[10:22:29.197]                         }
[10:22:29.197]                         else {
[10:22:29.197]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:29.197]                             info, version)
[10:22:29.197]                         }
[10:22:29.197]                         base::stop(msg)
[10:22:29.197]                       }
[10:22:29.197]                     })
[10:22:29.197]                   }
[10:22:29.197]                   ...future.strategy.old <- future::plan("list")
[10:22:29.197]                   options(future.plan = NULL)
[10:22:29.197]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:29.197]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:29.197]                 }
[10:22:29.197]                 ...future.workdir <- getwd()
[10:22:29.197]             }
[10:22:29.197]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:29.197]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:29.197]         }
[10:22:29.197]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:29.197]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:29.197]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:29.197]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:29.197]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:29.197]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:29.197]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:29.197]             base::names(...future.oldOptions))
[10:22:29.197]     }
[10:22:29.197]     if (FALSE) {
[10:22:29.197]     }
[10:22:29.197]     else {
[10:22:29.197]         if (TRUE) {
[10:22:29.197]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:29.197]                 open = "w")
[10:22:29.197]         }
[10:22:29.197]         else {
[10:22:29.197]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:29.197]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:29.197]         }
[10:22:29.197]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:29.197]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:29.197]             base::sink(type = "output", split = FALSE)
[10:22:29.197]             base::close(...future.stdout)
[10:22:29.197]         }, add = TRUE)
[10:22:29.197]     }
[10:22:29.197]     ...future.frame <- base::sys.nframe()
[10:22:29.197]     ...future.conditions <- base::list()
[10:22:29.197]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:29.197]     if (FALSE) {
[10:22:29.197]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:29.197]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:29.197]     }
[10:22:29.197]     ...future.result <- base::tryCatch({
[10:22:29.197]         base::withCallingHandlers({
[10:22:29.197]             ...future.value <- base::withVisible(base::local({
[10:22:29.197]                 1
[10:22:29.197]             }))
[10:22:29.197]             future::FutureResult(value = ...future.value$value, 
[10:22:29.197]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:29.197]                   ...future.rng), globalenv = if (FALSE) 
[10:22:29.197]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:29.197]                     ...future.globalenv.names))
[10:22:29.197]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:29.197]         }, condition = base::local({
[10:22:29.197]             c <- base::c
[10:22:29.197]             inherits <- base::inherits
[10:22:29.197]             invokeRestart <- base::invokeRestart
[10:22:29.197]             length <- base::length
[10:22:29.197]             list <- base::list
[10:22:29.197]             seq.int <- base::seq.int
[10:22:29.197]             signalCondition <- base::signalCondition
[10:22:29.197]             sys.calls <- base::sys.calls
[10:22:29.197]             `[[` <- base::`[[`
[10:22:29.197]             `+` <- base::`+`
[10:22:29.197]             `<<-` <- base::`<<-`
[10:22:29.197]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:29.197]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:29.197]                   3L)]
[10:22:29.197]             }
[10:22:29.197]             function(cond) {
[10:22:29.197]                 is_error <- inherits(cond, "error")
[10:22:29.197]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:29.197]                   NULL)
[10:22:29.197]                 if (is_error) {
[10:22:29.197]                   sessionInformation <- function() {
[10:22:29.197]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:29.197]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:29.197]                       search = base::search(), system = base::Sys.info())
[10:22:29.197]                   }
[10:22:29.197]                   ...future.conditions[[length(...future.conditions) + 
[10:22:29.197]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:29.197]                     cond$call), session = sessionInformation(), 
[10:22:29.197]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:29.197]                   signalCondition(cond)
[10:22:29.197]                 }
[10:22:29.197]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:29.197]                 "immediateCondition"))) {
[10:22:29.197]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:29.197]                   ...future.conditions[[length(...future.conditions) + 
[10:22:29.197]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:29.197]                   if (TRUE && !signal) {
[10:22:29.197]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.197]                     {
[10:22:29.197]                       inherits <- base::inherits
[10:22:29.197]                       invokeRestart <- base::invokeRestart
[10:22:29.197]                       is.null <- base::is.null
[10:22:29.197]                       muffled <- FALSE
[10:22:29.197]                       if (inherits(cond, "message")) {
[10:22:29.197]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:29.197]                         if (muffled) 
[10:22:29.197]                           invokeRestart("muffleMessage")
[10:22:29.197]                       }
[10:22:29.197]                       else if (inherits(cond, "warning")) {
[10:22:29.197]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:29.197]                         if (muffled) 
[10:22:29.197]                           invokeRestart("muffleWarning")
[10:22:29.197]                       }
[10:22:29.197]                       else if (inherits(cond, "condition")) {
[10:22:29.197]                         if (!is.null(pattern)) {
[10:22:29.197]                           computeRestarts <- base::computeRestarts
[10:22:29.197]                           grepl <- base::grepl
[10:22:29.197]                           restarts <- computeRestarts(cond)
[10:22:29.197]                           for (restart in restarts) {
[10:22:29.197]                             name <- restart$name
[10:22:29.197]                             if (is.null(name)) 
[10:22:29.197]                               next
[10:22:29.197]                             if (!grepl(pattern, name)) 
[10:22:29.197]                               next
[10:22:29.197]                             invokeRestart(restart)
[10:22:29.197]                             muffled <- TRUE
[10:22:29.197]                             break
[10:22:29.197]                           }
[10:22:29.197]                         }
[10:22:29.197]                       }
[10:22:29.197]                       invisible(muffled)
[10:22:29.197]                     }
[10:22:29.197]                     muffleCondition(cond, pattern = "^muffle")
[10:22:29.197]                   }
[10:22:29.197]                 }
[10:22:29.197]                 else {
[10:22:29.197]                   if (TRUE) {
[10:22:29.197]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.197]                     {
[10:22:29.197]                       inherits <- base::inherits
[10:22:29.197]                       invokeRestart <- base::invokeRestart
[10:22:29.197]                       is.null <- base::is.null
[10:22:29.197]                       muffled <- FALSE
[10:22:29.197]                       if (inherits(cond, "message")) {
[10:22:29.197]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:29.197]                         if (muffled) 
[10:22:29.197]                           invokeRestart("muffleMessage")
[10:22:29.197]                       }
[10:22:29.197]                       else if (inherits(cond, "warning")) {
[10:22:29.197]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:29.197]                         if (muffled) 
[10:22:29.197]                           invokeRestart("muffleWarning")
[10:22:29.197]                       }
[10:22:29.197]                       else if (inherits(cond, "condition")) {
[10:22:29.197]                         if (!is.null(pattern)) {
[10:22:29.197]                           computeRestarts <- base::computeRestarts
[10:22:29.197]                           grepl <- base::grepl
[10:22:29.197]                           restarts <- computeRestarts(cond)
[10:22:29.197]                           for (restart in restarts) {
[10:22:29.197]                             name <- restart$name
[10:22:29.197]                             if (is.null(name)) 
[10:22:29.197]                               next
[10:22:29.197]                             if (!grepl(pattern, name)) 
[10:22:29.197]                               next
[10:22:29.197]                             invokeRestart(restart)
[10:22:29.197]                             muffled <- TRUE
[10:22:29.197]                             break
[10:22:29.197]                           }
[10:22:29.197]                         }
[10:22:29.197]                       }
[10:22:29.197]                       invisible(muffled)
[10:22:29.197]                     }
[10:22:29.197]                     muffleCondition(cond, pattern = "^muffle")
[10:22:29.197]                   }
[10:22:29.197]                 }
[10:22:29.197]             }
[10:22:29.197]         }))
[10:22:29.197]     }, error = function(ex) {
[10:22:29.197]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:29.197]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:29.197]                 ...future.rng), started = ...future.startTime, 
[10:22:29.197]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:29.197]             version = "1.8"), class = "FutureResult")
[10:22:29.197]     }, finally = {
[10:22:29.197]         if (!identical(...future.workdir, getwd())) 
[10:22:29.197]             setwd(...future.workdir)
[10:22:29.197]         {
[10:22:29.197]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:29.197]                 ...future.oldOptions$nwarnings <- NULL
[10:22:29.197]             }
[10:22:29.197]             base::options(...future.oldOptions)
[10:22:29.197]             if (.Platform$OS.type == "windows") {
[10:22:29.197]                 old_names <- names(...future.oldEnvVars)
[10:22:29.197]                 envs <- base::Sys.getenv()
[10:22:29.197]                 names <- names(envs)
[10:22:29.197]                 common <- intersect(names, old_names)
[10:22:29.197]                 added <- setdiff(names, old_names)
[10:22:29.197]                 removed <- setdiff(old_names, names)
[10:22:29.197]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:29.197]                   envs[common]]
[10:22:29.197]                 NAMES <- toupper(changed)
[10:22:29.197]                 args <- list()
[10:22:29.197]                 for (kk in seq_along(NAMES)) {
[10:22:29.197]                   name <- changed[[kk]]
[10:22:29.197]                   NAME <- NAMES[[kk]]
[10:22:29.197]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.197]                     next
[10:22:29.197]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:29.197]                 }
[10:22:29.197]                 NAMES <- toupper(added)
[10:22:29.197]                 for (kk in seq_along(NAMES)) {
[10:22:29.197]                   name <- added[[kk]]
[10:22:29.197]                   NAME <- NAMES[[kk]]
[10:22:29.197]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.197]                     next
[10:22:29.197]                   args[[name]] <- ""
[10:22:29.197]                 }
[10:22:29.197]                 NAMES <- toupper(removed)
[10:22:29.197]                 for (kk in seq_along(NAMES)) {
[10:22:29.197]                   name <- removed[[kk]]
[10:22:29.197]                   NAME <- NAMES[[kk]]
[10:22:29.197]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.197]                     next
[10:22:29.197]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:29.197]                 }
[10:22:29.197]                 if (length(args) > 0) 
[10:22:29.197]                   base::do.call(base::Sys.setenv, args = args)
[10:22:29.197]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:29.197]             }
[10:22:29.197]             else {
[10:22:29.197]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:29.197]             }
[10:22:29.197]             {
[10:22:29.197]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:29.197]                   0L) {
[10:22:29.197]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:29.197]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:29.197]                   base::options(opts)
[10:22:29.197]                 }
[10:22:29.197]                 {
[10:22:29.197]                   {
[10:22:29.197]                     NULL
[10:22:29.197]                     RNGkind("Mersenne-Twister")
[10:22:29.197]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:29.197]                       inherits = FALSE)
[10:22:29.197]                   }
[10:22:29.197]                   options(future.plan = NULL)
[10:22:29.197]                   if (is.na(NA_character_)) 
[10:22:29.197]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:29.197]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:29.197]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:29.197]                     .init = FALSE)
[10:22:29.197]                 }
[10:22:29.197]             }
[10:22:29.197]         }
[10:22:29.197]     })
[10:22:29.197]     if (TRUE) {
[10:22:29.197]         base::sink(type = "output", split = FALSE)
[10:22:29.197]         if (TRUE) {
[10:22:29.197]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:29.197]         }
[10:22:29.197]         else {
[10:22:29.197]             ...future.result["stdout"] <- base::list(NULL)
[10:22:29.197]         }
[10:22:29.197]         base::close(...future.stdout)
[10:22:29.197]         ...future.stdout <- NULL
[10:22:29.197]     }
[10:22:29.197]     ...future.result$conditions <- ...future.conditions
[10:22:29.197]     ...future.result$finished <- base::Sys.time()
[10:22:29.197]     ...future.result
[10:22:29.197] }
[10:22:29.198] plan(): Setting new future strategy stack:
[10:22:29.198] List of future strategies:
[10:22:29.198] 1. sequential:
[10:22:29.198]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:29.198]    - tweaked: FALSE
[10:22:29.198]    - call: NULL
[10:22:29.199] plan(): nbrOfWorkers() = 1
[10:22:29.200] plan(): Setting new future strategy stack:
[10:22:29.200] List of future strategies:
[10:22:29.200] 1. sequential:
[10:22:29.200]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:29.200]    - tweaked: FALSE
[10:22:29.200]    - call: plan(strategy)
[10:22:29.200] plan(): nbrOfWorkers() = 1
[10:22:29.200] SequentialFuture started (and completed)
[10:22:29.200] - Launch lazy future ... done
[10:22:29.200] run() for ‘SequentialFuture’ ... done
[10:22:29.201] getGlobalsAndPackages() ...
[10:22:29.201] Searching for globals...
[10:22:29.201] - globals found: [1] ‘{’
[10:22:29.201] Searching for globals ... DONE
[10:22:29.202] Resolving globals: FALSE
[10:22:29.202] 
[10:22:29.202] 
[10:22:29.202] getGlobalsAndPackages() ... DONE
[10:22:29.202] run() for ‘Future’ ...
[10:22:29.202] - state: ‘created’
[10:22:29.202] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:29.203] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:29.203] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:29.203]   - Field: ‘label’
[10:22:29.203]   - Field: ‘local’
[10:22:29.203]   - Field: ‘owner’
[10:22:29.203]   - Field: ‘envir’
[10:22:29.203]   - Field: ‘packages’
[10:22:29.203]   - Field: ‘gc’
[10:22:29.203]   - Field: ‘conditions’
[10:22:29.203]   - Field: ‘expr’
[10:22:29.204]   - Field: ‘uuid’
[10:22:29.204]   - Field: ‘seed’
[10:22:29.204]   - Field: ‘version’
[10:22:29.204]   - Field: ‘result’
[10:22:29.204]   - Field: ‘asynchronous’
[10:22:29.204]   - Field: ‘calls’
[10:22:29.204]   - Field: ‘globals’
[10:22:29.204]   - Field: ‘stdout’
[10:22:29.204]   - Field: ‘earlySignal’
[10:22:29.204]   - Field: ‘lazy’
[10:22:29.204]   - Field: ‘state’
[10:22:29.204] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:29.205] - Launch lazy future ...
[10:22:29.205] Packages needed by the future expression (n = 0): <none>
[10:22:29.205] Packages needed by future strategies (n = 0): <none>
[10:22:29.205] {
[10:22:29.205]     {
[10:22:29.205]         {
[10:22:29.205]             ...future.startTime <- base::Sys.time()
[10:22:29.205]             {
[10:22:29.205]                 {
[10:22:29.205]                   {
[10:22:29.205]                     base::local({
[10:22:29.205]                       has_future <- base::requireNamespace("future", 
[10:22:29.205]                         quietly = TRUE)
[10:22:29.205]                       if (has_future) {
[10:22:29.205]                         ns <- base::getNamespace("future")
[10:22:29.205]                         version <- ns[[".package"]][["version"]]
[10:22:29.205]                         if (is.null(version)) 
[10:22:29.205]                           version <- utils::packageVersion("future")
[10:22:29.205]                       }
[10:22:29.205]                       else {
[10:22:29.205]                         version <- NULL
[10:22:29.205]                       }
[10:22:29.205]                       if (!has_future || version < "1.8.0") {
[10:22:29.205]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:29.205]                           "", base::R.version$version.string), 
[10:22:29.205]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:29.205]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:29.205]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:29.205]                             "release", "version")], collapse = " "), 
[10:22:29.205]                           hostname = base::Sys.info()[["nodename"]])
[10:22:29.205]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:29.205]                           info)
[10:22:29.205]                         info <- base::paste(info, collapse = "; ")
[10:22:29.205]                         if (!has_future) {
[10:22:29.205]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:29.205]                             info)
[10:22:29.205]                         }
[10:22:29.205]                         else {
[10:22:29.205]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:29.205]                             info, version)
[10:22:29.205]                         }
[10:22:29.205]                         base::stop(msg)
[10:22:29.205]                       }
[10:22:29.205]                     })
[10:22:29.205]                   }
[10:22:29.205]                   ...future.strategy.old <- future::plan("list")
[10:22:29.205]                   options(future.plan = NULL)
[10:22:29.205]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:29.205]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:29.205]                 }
[10:22:29.205]                 ...future.workdir <- getwd()
[10:22:29.205]             }
[10:22:29.205]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:29.205]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:29.205]         }
[10:22:29.205]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:29.205]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:29.205]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:29.205]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:29.205]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:29.205]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:29.205]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:29.205]             base::names(...future.oldOptions))
[10:22:29.205]     }
[10:22:29.205]     if (FALSE) {
[10:22:29.205]     }
[10:22:29.205]     else {
[10:22:29.205]         if (TRUE) {
[10:22:29.205]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:29.205]                 open = "w")
[10:22:29.205]         }
[10:22:29.205]         else {
[10:22:29.205]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:29.205]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:29.205]         }
[10:22:29.205]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:29.205]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:29.205]             base::sink(type = "output", split = FALSE)
[10:22:29.205]             base::close(...future.stdout)
[10:22:29.205]         }, add = TRUE)
[10:22:29.205]     }
[10:22:29.205]     ...future.frame <- base::sys.nframe()
[10:22:29.205]     ...future.conditions <- base::list()
[10:22:29.205]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:29.205]     if (FALSE) {
[10:22:29.205]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:29.205]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:29.205]     }
[10:22:29.205]     ...future.result <- base::tryCatch({
[10:22:29.205]         base::withCallingHandlers({
[10:22:29.205]             ...future.value <- base::withVisible(base::local({
[10:22:29.205]                 2
[10:22:29.205]             }))
[10:22:29.205]             future::FutureResult(value = ...future.value$value, 
[10:22:29.205]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:29.205]                   ...future.rng), globalenv = if (FALSE) 
[10:22:29.205]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:29.205]                     ...future.globalenv.names))
[10:22:29.205]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:29.205]         }, condition = base::local({
[10:22:29.205]             c <- base::c
[10:22:29.205]             inherits <- base::inherits
[10:22:29.205]             invokeRestart <- base::invokeRestart
[10:22:29.205]             length <- base::length
[10:22:29.205]             list <- base::list
[10:22:29.205]             seq.int <- base::seq.int
[10:22:29.205]             signalCondition <- base::signalCondition
[10:22:29.205]             sys.calls <- base::sys.calls
[10:22:29.205]             `[[` <- base::`[[`
[10:22:29.205]             `+` <- base::`+`
[10:22:29.205]             `<<-` <- base::`<<-`
[10:22:29.205]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:29.205]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:29.205]                   3L)]
[10:22:29.205]             }
[10:22:29.205]             function(cond) {
[10:22:29.205]                 is_error <- inherits(cond, "error")
[10:22:29.205]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:29.205]                   NULL)
[10:22:29.205]                 if (is_error) {
[10:22:29.205]                   sessionInformation <- function() {
[10:22:29.205]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:29.205]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:29.205]                       search = base::search(), system = base::Sys.info())
[10:22:29.205]                   }
[10:22:29.205]                   ...future.conditions[[length(...future.conditions) + 
[10:22:29.205]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:29.205]                     cond$call), session = sessionInformation(), 
[10:22:29.205]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:29.205]                   signalCondition(cond)
[10:22:29.205]                 }
[10:22:29.205]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:29.205]                 "immediateCondition"))) {
[10:22:29.205]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:29.205]                   ...future.conditions[[length(...future.conditions) + 
[10:22:29.205]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:29.205]                   if (TRUE && !signal) {
[10:22:29.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.205]                     {
[10:22:29.205]                       inherits <- base::inherits
[10:22:29.205]                       invokeRestart <- base::invokeRestart
[10:22:29.205]                       is.null <- base::is.null
[10:22:29.205]                       muffled <- FALSE
[10:22:29.205]                       if (inherits(cond, "message")) {
[10:22:29.205]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:29.205]                         if (muffled) 
[10:22:29.205]                           invokeRestart("muffleMessage")
[10:22:29.205]                       }
[10:22:29.205]                       else if (inherits(cond, "warning")) {
[10:22:29.205]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:29.205]                         if (muffled) 
[10:22:29.205]                           invokeRestart("muffleWarning")
[10:22:29.205]                       }
[10:22:29.205]                       else if (inherits(cond, "condition")) {
[10:22:29.205]                         if (!is.null(pattern)) {
[10:22:29.205]                           computeRestarts <- base::computeRestarts
[10:22:29.205]                           grepl <- base::grepl
[10:22:29.205]                           restarts <- computeRestarts(cond)
[10:22:29.205]                           for (restart in restarts) {
[10:22:29.205]                             name <- restart$name
[10:22:29.205]                             if (is.null(name)) 
[10:22:29.205]                               next
[10:22:29.205]                             if (!grepl(pattern, name)) 
[10:22:29.205]                               next
[10:22:29.205]                             invokeRestart(restart)
[10:22:29.205]                             muffled <- TRUE
[10:22:29.205]                             break
[10:22:29.205]                           }
[10:22:29.205]                         }
[10:22:29.205]                       }
[10:22:29.205]                       invisible(muffled)
[10:22:29.205]                     }
[10:22:29.205]                     muffleCondition(cond, pattern = "^muffle")
[10:22:29.205]                   }
[10:22:29.205]                 }
[10:22:29.205]                 else {
[10:22:29.205]                   if (TRUE) {
[10:22:29.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.205]                     {
[10:22:29.205]                       inherits <- base::inherits
[10:22:29.205]                       invokeRestart <- base::invokeRestart
[10:22:29.205]                       is.null <- base::is.null
[10:22:29.205]                       muffled <- FALSE
[10:22:29.205]                       if (inherits(cond, "message")) {
[10:22:29.205]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:29.205]                         if (muffled) 
[10:22:29.205]                           invokeRestart("muffleMessage")
[10:22:29.205]                       }
[10:22:29.205]                       else if (inherits(cond, "warning")) {
[10:22:29.205]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:29.205]                         if (muffled) 
[10:22:29.205]                           invokeRestart("muffleWarning")
[10:22:29.205]                       }
[10:22:29.205]                       else if (inherits(cond, "condition")) {
[10:22:29.205]                         if (!is.null(pattern)) {
[10:22:29.205]                           computeRestarts <- base::computeRestarts
[10:22:29.205]                           grepl <- base::grepl
[10:22:29.205]                           restarts <- computeRestarts(cond)
[10:22:29.205]                           for (restart in restarts) {
[10:22:29.205]                             name <- restart$name
[10:22:29.205]                             if (is.null(name)) 
[10:22:29.205]                               next
[10:22:29.205]                             if (!grepl(pattern, name)) 
[10:22:29.205]                               next
[10:22:29.205]                             invokeRestart(restart)
[10:22:29.205]                             muffled <- TRUE
[10:22:29.205]                             break
[10:22:29.205]                           }
[10:22:29.205]                         }
[10:22:29.205]                       }
[10:22:29.205]                       invisible(muffled)
[10:22:29.205]                     }
[10:22:29.205]                     muffleCondition(cond, pattern = "^muffle")
[10:22:29.205]                   }
[10:22:29.205]                 }
[10:22:29.205]             }
[10:22:29.205]         }))
[10:22:29.205]     }, error = function(ex) {
[10:22:29.205]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:29.205]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:29.205]                 ...future.rng), started = ...future.startTime, 
[10:22:29.205]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:29.205]             version = "1.8"), class = "FutureResult")
[10:22:29.205]     }, finally = {
[10:22:29.205]         if (!identical(...future.workdir, getwd())) 
[10:22:29.205]             setwd(...future.workdir)
[10:22:29.205]         {
[10:22:29.205]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:29.205]                 ...future.oldOptions$nwarnings <- NULL
[10:22:29.205]             }
[10:22:29.205]             base::options(...future.oldOptions)
[10:22:29.205]             if (.Platform$OS.type == "windows") {
[10:22:29.205]                 old_names <- names(...future.oldEnvVars)
[10:22:29.205]                 envs <- base::Sys.getenv()
[10:22:29.205]                 names <- names(envs)
[10:22:29.205]                 common <- intersect(names, old_names)
[10:22:29.205]                 added <- setdiff(names, old_names)
[10:22:29.205]                 removed <- setdiff(old_names, names)
[10:22:29.205]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:29.205]                   envs[common]]
[10:22:29.205]                 NAMES <- toupper(changed)
[10:22:29.205]                 args <- list()
[10:22:29.205]                 for (kk in seq_along(NAMES)) {
[10:22:29.205]                   name <- changed[[kk]]
[10:22:29.205]                   NAME <- NAMES[[kk]]
[10:22:29.205]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.205]                     next
[10:22:29.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:29.205]                 }
[10:22:29.205]                 NAMES <- toupper(added)
[10:22:29.205]                 for (kk in seq_along(NAMES)) {
[10:22:29.205]                   name <- added[[kk]]
[10:22:29.205]                   NAME <- NAMES[[kk]]
[10:22:29.205]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.205]                     next
[10:22:29.205]                   args[[name]] <- ""
[10:22:29.205]                 }
[10:22:29.205]                 NAMES <- toupper(removed)
[10:22:29.205]                 for (kk in seq_along(NAMES)) {
[10:22:29.205]                   name <- removed[[kk]]
[10:22:29.205]                   NAME <- NAMES[[kk]]
[10:22:29.205]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.205]                     next
[10:22:29.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:29.205]                 }
[10:22:29.205]                 if (length(args) > 0) 
[10:22:29.205]                   base::do.call(base::Sys.setenv, args = args)
[10:22:29.205]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:29.205]             }
[10:22:29.205]             else {
[10:22:29.205]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:29.205]             }
[10:22:29.205]             {
[10:22:29.205]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:29.205]                   0L) {
[10:22:29.205]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:29.205]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:29.205]                   base::options(opts)
[10:22:29.205]                 }
[10:22:29.205]                 {
[10:22:29.205]                   {
[10:22:29.205]                     NULL
[10:22:29.205]                     RNGkind("Mersenne-Twister")
[10:22:29.205]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:29.205]                       inherits = FALSE)
[10:22:29.205]                   }
[10:22:29.205]                   options(future.plan = NULL)
[10:22:29.205]                   if (is.na(NA_character_)) 
[10:22:29.205]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:29.205]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:29.205]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:29.205]                     .init = FALSE)
[10:22:29.205]                 }
[10:22:29.205]             }
[10:22:29.205]         }
[10:22:29.205]     })
[10:22:29.205]     if (TRUE) {
[10:22:29.205]         base::sink(type = "output", split = FALSE)
[10:22:29.205]         if (TRUE) {
[10:22:29.205]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:29.205]         }
[10:22:29.205]         else {
[10:22:29.205]             ...future.result["stdout"] <- base::list(NULL)
[10:22:29.205]         }
[10:22:29.205]         base::close(...future.stdout)
[10:22:29.205]         ...future.stdout <- NULL
[10:22:29.205]     }
[10:22:29.205]     ...future.result$conditions <- ...future.conditions
[10:22:29.205]     ...future.result$finished <- base::Sys.time()
[10:22:29.205]     ...future.result
[10:22:29.205] }
[10:22:29.207] plan(): Setting new future strategy stack:
[10:22:29.207] List of future strategies:
[10:22:29.207] 1. sequential:
[10:22:29.207]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:29.207]    - tweaked: FALSE
[10:22:29.207]    - call: NULL
[10:22:29.207] plan(): nbrOfWorkers() = 1
[10:22:29.208] plan(): Setting new future strategy stack:
[10:22:29.208] List of future strategies:
[10:22:29.208] 1. sequential:
[10:22:29.208]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:29.208]    - tweaked: FALSE
[10:22:29.208]    - call: plan(strategy)
[10:22:29.209] plan(): nbrOfWorkers() = 1
[10:22:29.209] SequentialFuture started (and completed)
[10:22:29.209] - Launch lazy future ... done
[10:22:29.209] run() for ‘SequentialFuture’ ... done
[10:22:29.209] resolve() on list environment ...
[10:22:29.209]  recursive: 0
[10:22:29.210]  length: 3
[10:22:29.210]  elements: ‘a’, ‘b’, ‘c’
[10:22:29.210] resolved() for ‘SequentialFuture’ ...
[10:22:29.210] - state: ‘finished’
[10:22:29.210] - run: TRUE
[10:22:29.210] - result: ‘FutureResult’
[10:22:29.210] resolved() for ‘SequentialFuture’ ... done
[10:22:29.211] Future #1
[10:22:29.211]  length: 2 (resolved future 1)
[10:22:29.211] resolved() for ‘SequentialFuture’ ...
[10:22:29.211] - state: ‘finished’
[10:22:29.211] - run: TRUE
[10:22:29.211] - result: ‘FutureResult’
[10:22:29.211] resolved() for ‘SequentialFuture’ ... done
[10:22:29.211] Future #2
[10:22:29.211]  length: 1 (resolved future 2)
[10:22:29.211]  length: 0 (resolved future 3)
[10:22:29.211] resolve() on list environment ... DONE
[10:22:29.212] getGlobalsAndPackages() ...
[10:22:29.212] Searching for globals...
[10:22:29.212] - globals found: [1] ‘{’
[10:22:29.212] Searching for globals ... DONE
[10:22:29.213] Resolving globals: FALSE
[10:22:29.213] 
[10:22:29.213] 
[10:22:29.213] getGlobalsAndPackages() ... DONE
[10:22:29.213] run() for ‘Future’ ...
[10:22:29.213] - state: ‘created’
[10:22:29.213] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:29.214] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:29.214] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:29.214]   - Field: ‘label’
[10:22:29.214]   - Field: ‘local’
[10:22:29.214]   - Field: ‘owner’
[10:22:29.214]   - Field: ‘envir’
[10:22:29.214]   - Field: ‘packages’
[10:22:29.214]   - Field: ‘gc’
[10:22:29.214]   - Field: ‘conditions’
[10:22:29.214]   - Field: ‘expr’
[10:22:29.214]   - Field: ‘uuid’
[10:22:29.215]   - Field: ‘seed’
[10:22:29.215]   - Field: ‘version’
[10:22:29.215]   - Field: ‘result’
[10:22:29.215]   - Field: ‘asynchronous’
[10:22:29.215]   - Field: ‘calls’
[10:22:29.215]   - Field: ‘globals’
[10:22:29.215]   - Field: ‘stdout’
[10:22:29.215]   - Field: ‘earlySignal’
[10:22:29.215]   - Field: ‘lazy’
[10:22:29.215]   - Field: ‘state’
[10:22:29.215] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:29.215] - Launch lazy future ...
[10:22:29.216] Packages needed by the future expression (n = 0): <none>
[10:22:29.216] Packages needed by future strategies (n = 0): <none>
[10:22:29.216] {
[10:22:29.216]     {
[10:22:29.216]         {
[10:22:29.216]             ...future.startTime <- base::Sys.time()
[10:22:29.216]             {
[10:22:29.216]                 {
[10:22:29.216]                   {
[10:22:29.216]                     base::local({
[10:22:29.216]                       has_future <- base::requireNamespace("future", 
[10:22:29.216]                         quietly = TRUE)
[10:22:29.216]                       if (has_future) {
[10:22:29.216]                         ns <- base::getNamespace("future")
[10:22:29.216]                         version <- ns[[".package"]][["version"]]
[10:22:29.216]                         if (is.null(version)) 
[10:22:29.216]                           version <- utils::packageVersion("future")
[10:22:29.216]                       }
[10:22:29.216]                       else {
[10:22:29.216]                         version <- NULL
[10:22:29.216]                       }
[10:22:29.216]                       if (!has_future || version < "1.8.0") {
[10:22:29.216]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:29.216]                           "", base::R.version$version.string), 
[10:22:29.216]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:29.216]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:29.216]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:29.216]                             "release", "version")], collapse = " "), 
[10:22:29.216]                           hostname = base::Sys.info()[["nodename"]])
[10:22:29.216]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:29.216]                           info)
[10:22:29.216]                         info <- base::paste(info, collapse = "; ")
[10:22:29.216]                         if (!has_future) {
[10:22:29.216]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:29.216]                             info)
[10:22:29.216]                         }
[10:22:29.216]                         else {
[10:22:29.216]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:29.216]                             info, version)
[10:22:29.216]                         }
[10:22:29.216]                         base::stop(msg)
[10:22:29.216]                       }
[10:22:29.216]                     })
[10:22:29.216]                   }
[10:22:29.216]                   ...future.strategy.old <- future::plan("list")
[10:22:29.216]                   options(future.plan = NULL)
[10:22:29.216]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:29.216]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:29.216]                 }
[10:22:29.216]                 ...future.workdir <- getwd()
[10:22:29.216]             }
[10:22:29.216]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:29.216]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:29.216]         }
[10:22:29.216]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:29.216]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:29.216]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:29.216]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:29.216]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:29.216]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:29.216]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:29.216]             base::names(...future.oldOptions))
[10:22:29.216]     }
[10:22:29.216]     if (FALSE) {
[10:22:29.216]     }
[10:22:29.216]     else {
[10:22:29.216]         if (TRUE) {
[10:22:29.216]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:29.216]                 open = "w")
[10:22:29.216]         }
[10:22:29.216]         else {
[10:22:29.216]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:29.216]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:29.216]         }
[10:22:29.216]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:29.216]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:29.216]             base::sink(type = "output", split = FALSE)
[10:22:29.216]             base::close(...future.stdout)
[10:22:29.216]         }, add = TRUE)
[10:22:29.216]     }
[10:22:29.216]     ...future.frame <- base::sys.nframe()
[10:22:29.216]     ...future.conditions <- base::list()
[10:22:29.216]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:29.216]     if (FALSE) {
[10:22:29.216]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:29.216]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:29.216]     }
[10:22:29.216]     ...future.result <- base::tryCatch({
[10:22:29.216]         base::withCallingHandlers({
[10:22:29.216]             ...future.value <- base::withVisible(base::local({
[10:22:29.216]                 1
[10:22:29.216]             }))
[10:22:29.216]             future::FutureResult(value = ...future.value$value, 
[10:22:29.216]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:29.216]                   ...future.rng), globalenv = if (FALSE) 
[10:22:29.216]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:29.216]                     ...future.globalenv.names))
[10:22:29.216]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:29.216]         }, condition = base::local({
[10:22:29.216]             c <- base::c
[10:22:29.216]             inherits <- base::inherits
[10:22:29.216]             invokeRestart <- base::invokeRestart
[10:22:29.216]             length <- base::length
[10:22:29.216]             list <- base::list
[10:22:29.216]             seq.int <- base::seq.int
[10:22:29.216]             signalCondition <- base::signalCondition
[10:22:29.216]             sys.calls <- base::sys.calls
[10:22:29.216]             `[[` <- base::`[[`
[10:22:29.216]             `+` <- base::`+`
[10:22:29.216]             `<<-` <- base::`<<-`
[10:22:29.216]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:29.216]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:29.216]                   3L)]
[10:22:29.216]             }
[10:22:29.216]             function(cond) {
[10:22:29.216]                 is_error <- inherits(cond, "error")
[10:22:29.216]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:29.216]                   NULL)
[10:22:29.216]                 if (is_error) {
[10:22:29.216]                   sessionInformation <- function() {
[10:22:29.216]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:29.216]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:29.216]                       search = base::search(), system = base::Sys.info())
[10:22:29.216]                   }
[10:22:29.216]                   ...future.conditions[[length(...future.conditions) + 
[10:22:29.216]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:29.216]                     cond$call), session = sessionInformation(), 
[10:22:29.216]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:29.216]                   signalCondition(cond)
[10:22:29.216]                 }
[10:22:29.216]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:29.216]                 "immediateCondition"))) {
[10:22:29.216]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:29.216]                   ...future.conditions[[length(...future.conditions) + 
[10:22:29.216]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:29.216]                   if (TRUE && !signal) {
[10:22:29.216]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.216]                     {
[10:22:29.216]                       inherits <- base::inherits
[10:22:29.216]                       invokeRestart <- base::invokeRestart
[10:22:29.216]                       is.null <- base::is.null
[10:22:29.216]                       muffled <- FALSE
[10:22:29.216]                       if (inherits(cond, "message")) {
[10:22:29.216]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:29.216]                         if (muffled) 
[10:22:29.216]                           invokeRestart("muffleMessage")
[10:22:29.216]                       }
[10:22:29.216]                       else if (inherits(cond, "warning")) {
[10:22:29.216]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:29.216]                         if (muffled) 
[10:22:29.216]                           invokeRestart("muffleWarning")
[10:22:29.216]                       }
[10:22:29.216]                       else if (inherits(cond, "condition")) {
[10:22:29.216]                         if (!is.null(pattern)) {
[10:22:29.216]                           computeRestarts <- base::computeRestarts
[10:22:29.216]                           grepl <- base::grepl
[10:22:29.216]                           restarts <- computeRestarts(cond)
[10:22:29.216]                           for (restart in restarts) {
[10:22:29.216]                             name <- restart$name
[10:22:29.216]                             if (is.null(name)) 
[10:22:29.216]                               next
[10:22:29.216]                             if (!grepl(pattern, name)) 
[10:22:29.216]                               next
[10:22:29.216]                             invokeRestart(restart)
[10:22:29.216]                             muffled <- TRUE
[10:22:29.216]                             break
[10:22:29.216]                           }
[10:22:29.216]                         }
[10:22:29.216]                       }
[10:22:29.216]                       invisible(muffled)
[10:22:29.216]                     }
[10:22:29.216]                     muffleCondition(cond, pattern = "^muffle")
[10:22:29.216]                   }
[10:22:29.216]                 }
[10:22:29.216]                 else {
[10:22:29.216]                   if (TRUE) {
[10:22:29.216]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.216]                     {
[10:22:29.216]                       inherits <- base::inherits
[10:22:29.216]                       invokeRestart <- base::invokeRestart
[10:22:29.216]                       is.null <- base::is.null
[10:22:29.216]                       muffled <- FALSE
[10:22:29.216]                       if (inherits(cond, "message")) {
[10:22:29.216]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:29.216]                         if (muffled) 
[10:22:29.216]                           invokeRestart("muffleMessage")
[10:22:29.216]                       }
[10:22:29.216]                       else if (inherits(cond, "warning")) {
[10:22:29.216]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:29.216]                         if (muffled) 
[10:22:29.216]                           invokeRestart("muffleWarning")
[10:22:29.216]                       }
[10:22:29.216]                       else if (inherits(cond, "condition")) {
[10:22:29.216]                         if (!is.null(pattern)) {
[10:22:29.216]                           computeRestarts <- base::computeRestarts
[10:22:29.216]                           grepl <- base::grepl
[10:22:29.216]                           restarts <- computeRestarts(cond)
[10:22:29.216]                           for (restart in restarts) {
[10:22:29.216]                             name <- restart$name
[10:22:29.216]                             if (is.null(name)) 
[10:22:29.216]                               next
[10:22:29.216]                             if (!grepl(pattern, name)) 
[10:22:29.216]                               next
[10:22:29.216]                             invokeRestart(restart)
[10:22:29.216]                             muffled <- TRUE
[10:22:29.216]                             break
[10:22:29.216]                           }
[10:22:29.216]                         }
[10:22:29.216]                       }
[10:22:29.216]                       invisible(muffled)
[10:22:29.216]                     }
[10:22:29.216]                     muffleCondition(cond, pattern = "^muffle")
[10:22:29.216]                   }
[10:22:29.216]                 }
[10:22:29.216]             }
[10:22:29.216]         }))
[10:22:29.216]     }, error = function(ex) {
[10:22:29.216]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:29.216]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:29.216]                 ...future.rng), started = ...future.startTime, 
[10:22:29.216]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:29.216]             version = "1.8"), class = "FutureResult")
[10:22:29.216]     }, finally = {
[10:22:29.216]         if (!identical(...future.workdir, getwd())) 
[10:22:29.216]             setwd(...future.workdir)
[10:22:29.216]         {
[10:22:29.216]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:29.216]                 ...future.oldOptions$nwarnings <- NULL
[10:22:29.216]             }
[10:22:29.216]             base::options(...future.oldOptions)
[10:22:29.216]             if (.Platform$OS.type == "windows") {
[10:22:29.216]                 old_names <- names(...future.oldEnvVars)
[10:22:29.216]                 envs <- base::Sys.getenv()
[10:22:29.216]                 names <- names(envs)
[10:22:29.216]                 common <- intersect(names, old_names)
[10:22:29.216]                 added <- setdiff(names, old_names)
[10:22:29.216]                 removed <- setdiff(old_names, names)
[10:22:29.216]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:29.216]                   envs[common]]
[10:22:29.216]                 NAMES <- toupper(changed)
[10:22:29.216]                 args <- list()
[10:22:29.216]                 for (kk in seq_along(NAMES)) {
[10:22:29.216]                   name <- changed[[kk]]
[10:22:29.216]                   NAME <- NAMES[[kk]]
[10:22:29.216]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.216]                     next
[10:22:29.216]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:29.216]                 }
[10:22:29.216]                 NAMES <- toupper(added)
[10:22:29.216]                 for (kk in seq_along(NAMES)) {
[10:22:29.216]                   name <- added[[kk]]
[10:22:29.216]                   NAME <- NAMES[[kk]]
[10:22:29.216]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.216]                     next
[10:22:29.216]                   args[[name]] <- ""
[10:22:29.216]                 }
[10:22:29.216]                 NAMES <- toupper(removed)
[10:22:29.216]                 for (kk in seq_along(NAMES)) {
[10:22:29.216]                   name <- removed[[kk]]
[10:22:29.216]                   NAME <- NAMES[[kk]]
[10:22:29.216]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.216]                     next
[10:22:29.216]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:29.216]                 }
[10:22:29.216]                 if (length(args) > 0) 
[10:22:29.216]                   base::do.call(base::Sys.setenv, args = args)
[10:22:29.216]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:29.216]             }
[10:22:29.216]             else {
[10:22:29.216]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:29.216]             }
[10:22:29.216]             {
[10:22:29.216]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:29.216]                   0L) {
[10:22:29.216]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:29.216]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:29.216]                   base::options(opts)
[10:22:29.216]                 }
[10:22:29.216]                 {
[10:22:29.216]                   {
[10:22:29.216]                     NULL
[10:22:29.216]                     RNGkind("Mersenne-Twister")
[10:22:29.216]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:29.216]                       inherits = FALSE)
[10:22:29.216]                   }
[10:22:29.216]                   options(future.plan = NULL)
[10:22:29.216]                   if (is.na(NA_character_)) 
[10:22:29.216]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:29.216]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:29.216]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:29.216]                     .init = FALSE)
[10:22:29.216]                 }
[10:22:29.216]             }
[10:22:29.216]         }
[10:22:29.216]     })
[10:22:29.216]     if (TRUE) {
[10:22:29.216]         base::sink(type = "output", split = FALSE)
[10:22:29.216]         if (TRUE) {
[10:22:29.216]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:29.216]         }
[10:22:29.216]         else {
[10:22:29.216]             ...future.result["stdout"] <- base::list(NULL)
[10:22:29.216]         }
[10:22:29.216]         base::close(...future.stdout)
[10:22:29.216]         ...future.stdout <- NULL
[10:22:29.216]     }
[10:22:29.216]     ...future.result$conditions <- ...future.conditions
[10:22:29.216]     ...future.result$finished <- base::Sys.time()
[10:22:29.216]     ...future.result
[10:22:29.216] }
[10:22:29.218] plan(): Setting new future strategy stack:
[10:22:29.218] List of future strategies:
[10:22:29.218] 1. sequential:
[10:22:29.218]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:29.218]    - tweaked: FALSE
[10:22:29.218]    - call: NULL
[10:22:29.218] plan(): nbrOfWorkers() = 1
[10:22:29.219] plan(): Setting new future strategy stack:
[10:22:29.219] List of future strategies:
[10:22:29.219] 1. sequential:
[10:22:29.219]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:29.219]    - tweaked: FALSE
[10:22:29.219]    - call: plan(strategy)
[10:22:29.221] plan(): nbrOfWorkers() = 1
[10:22:29.221] SequentialFuture started (and completed)
[10:22:29.221] - Launch lazy future ... done
[10:22:29.221] run() for ‘SequentialFuture’ ... done
[10:22:29.222] getGlobalsAndPackages() ...
[10:22:29.222] Searching for globals...
[10:22:29.223] - globals found: [2] ‘{’, ‘Sys.sleep’
[10:22:29.223] Searching for globals ... DONE
[10:22:29.223] Resolving globals: FALSE
[10:22:29.223] 
[10:22:29.223] 
[10:22:29.223] getGlobalsAndPackages() ... DONE
[10:22:29.224] run() for ‘Future’ ...
[10:22:29.224] - state: ‘created’
[10:22:29.224] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:29.224] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:29.224] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:29.224]   - Field: ‘label’
[10:22:29.224]   - Field: ‘local’
[10:22:29.224]   - Field: ‘owner’
[10:22:29.224]   - Field: ‘envir’
[10:22:29.224]   - Field: ‘packages’
[10:22:29.225]   - Field: ‘gc’
[10:22:29.225]   - Field: ‘conditions’
[10:22:29.225]   - Field: ‘expr’
[10:22:29.225]   - Field: ‘uuid’
[10:22:29.225]   - Field: ‘seed’
[10:22:29.225]   - Field: ‘version’
[10:22:29.225]   - Field: ‘result’
[10:22:29.225]   - Field: ‘asynchronous’
[10:22:29.225]   - Field: ‘calls’
[10:22:29.225]   - Field: ‘globals’
[10:22:29.225]   - Field: ‘stdout’
[10:22:29.225]   - Field: ‘earlySignal’
[10:22:29.226]   - Field: ‘lazy’
[10:22:29.226]   - Field: ‘state’
[10:22:29.226] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:29.226] - Launch lazy future ...
[10:22:29.226] Packages needed by the future expression (n = 0): <none>
[10:22:29.226] Packages needed by future strategies (n = 0): <none>
[10:22:29.226] {
[10:22:29.226]     {
[10:22:29.226]         {
[10:22:29.226]             ...future.startTime <- base::Sys.time()
[10:22:29.226]             {
[10:22:29.226]                 {
[10:22:29.226]                   {
[10:22:29.226]                     base::local({
[10:22:29.226]                       has_future <- base::requireNamespace("future", 
[10:22:29.226]                         quietly = TRUE)
[10:22:29.226]                       if (has_future) {
[10:22:29.226]                         ns <- base::getNamespace("future")
[10:22:29.226]                         version <- ns[[".package"]][["version"]]
[10:22:29.226]                         if (is.null(version)) 
[10:22:29.226]                           version <- utils::packageVersion("future")
[10:22:29.226]                       }
[10:22:29.226]                       else {
[10:22:29.226]                         version <- NULL
[10:22:29.226]                       }
[10:22:29.226]                       if (!has_future || version < "1.8.0") {
[10:22:29.226]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:29.226]                           "", base::R.version$version.string), 
[10:22:29.226]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:29.226]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:29.226]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:29.226]                             "release", "version")], collapse = " "), 
[10:22:29.226]                           hostname = base::Sys.info()[["nodename"]])
[10:22:29.226]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:29.226]                           info)
[10:22:29.226]                         info <- base::paste(info, collapse = "; ")
[10:22:29.226]                         if (!has_future) {
[10:22:29.226]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:29.226]                             info)
[10:22:29.226]                         }
[10:22:29.226]                         else {
[10:22:29.226]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:29.226]                             info, version)
[10:22:29.226]                         }
[10:22:29.226]                         base::stop(msg)
[10:22:29.226]                       }
[10:22:29.226]                     })
[10:22:29.226]                   }
[10:22:29.226]                   ...future.strategy.old <- future::plan("list")
[10:22:29.226]                   options(future.plan = NULL)
[10:22:29.226]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:29.226]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:29.226]                 }
[10:22:29.226]                 ...future.workdir <- getwd()
[10:22:29.226]             }
[10:22:29.226]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:29.226]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:29.226]         }
[10:22:29.226]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:29.226]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:29.226]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:29.226]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:29.226]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:29.226]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:29.226]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:29.226]             base::names(...future.oldOptions))
[10:22:29.226]     }
[10:22:29.226]     if (FALSE) {
[10:22:29.226]     }
[10:22:29.226]     else {
[10:22:29.226]         if (TRUE) {
[10:22:29.226]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:29.226]                 open = "w")
[10:22:29.226]         }
[10:22:29.226]         else {
[10:22:29.226]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:29.226]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:29.226]         }
[10:22:29.226]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:29.226]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:29.226]             base::sink(type = "output", split = FALSE)
[10:22:29.226]             base::close(...future.stdout)
[10:22:29.226]         }, add = TRUE)
[10:22:29.226]     }
[10:22:29.226]     ...future.frame <- base::sys.nframe()
[10:22:29.226]     ...future.conditions <- base::list()
[10:22:29.226]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:29.226]     if (FALSE) {
[10:22:29.226]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:29.226]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:29.226]     }
[10:22:29.226]     ...future.result <- base::tryCatch({
[10:22:29.226]         base::withCallingHandlers({
[10:22:29.226]             ...future.value <- base::withVisible(base::local({
[10:22:29.226]                 Sys.sleep(0.5)
[10:22:29.226]                 2
[10:22:29.226]             }))
[10:22:29.226]             future::FutureResult(value = ...future.value$value, 
[10:22:29.226]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:29.226]                   ...future.rng), globalenv = if (FALSE) 
[10:22:29.226]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:29.226]                     ...future.globalenv.names))
[10:22:29.226]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:29.226]         }, condition = base::local({
[10:22:29.226]             c <- base::c
[10:22:29.226]             inherits <- base::inherits
[10:22:29.226]             invokeRestart <- base::invokeRestart
[10:22:29.226]             length <- base::length
[10:22:29.226]             list <- base::list
[10:22:29.226]             seq.int <- base::seq.int
[10:22:29.226]             signalCondition <- base::signalCondition
[10:22:29.226]             sys.calls <- base::sys.calls
[10:22:29.226]             `[[` <- base::`[[`
[10:22:29.226]             `+` <- base::`+`
[10:22:29.226]             `<<-` <- base::`<<-`
[10:22:29.226]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:29.226]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:29.226]                   3L)]
[10:22:29.226]             }
[10:22:29.226]             function(cond) {
[10:22:29.226]                 is_error <- inherits(cond, "error")
[10:22:29.226]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:29.226]                   NULL)
[10:22:29.226]                 if (is_error) {
[10:22:29.226]                   sessionInformation <- function() {
[10:22:29.226]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:29.226]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:29.226]                       search = base::search(), system = base::Sys.info())
[10:22:29.226]                   }
[10:22:29.226]                   ...future.conditions[[length(...future.conditions) + 
[10:22:29.226]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:29.226]                     cond$call), session = sessionInformation(), 
[10:22:29.226]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:29.226]                   signalCondition(cond)
[10:22:29.226]                 }
[10:22:29.226]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:29.226]                 "immediateCondition"))) {
[10:22:29.226]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:29.226]                   ...future.conditions[[length(...future.conditions) + 
[10:22:29.226]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:29.226]                   if (TRUE && !signal) {
[10:22:29.226]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.226]                     {
[10:22:29.226]                       inherits <- base::inherits
[10:22:29.226]                       invokeRestart <- base::invokeRestart
[10:22:29.226]                       is.null <- base::is.null
[10:22:29.226]                       muffled <- FALSE
[10:22:29.226]                       if (inherits(cond, "message")) {
[10:22:29.226]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:29.226]                         if (muffled) 
[10:22:29.226]                           invokeRestart("muffleMessage")
[10:22:29.226]                       }
[10:22:29.226]                       else if (inherits(cond, "warning")) {
[10:22:29.226]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:29.226]                         if (muffled) 
[10:22:29.226]                           invokeRestart("muffleWarning")
[10:22:29.226]                       }
[10:22:29.226]                       else if (inherits(cond, "condition")) {
[10:22:29.226]                         if (!is.null(pattern)) {
[10:22:29.226]                           computeRestarts <- base::computeRestarts
[10:22:29.226]                           grepl <- base::grepl
[10:22:29.226]                           restarts <- computeRestarts(cond)
[10:22:29.226]                           for (restart in restarts) {
[10:22:29.226]                             name <- restart$name
[10:22:29.226]                             if (is.null(name)) 
[10:22:29.226]                               next
[10:22:29.226]                             if (!grepl(pattern, name)) 
[10:22:29.226]                               next
[10:22:29.226]                             invokeRestart(restart)
[10:22:29.226]                             muffled <- TRUE
[10:22:29.226]                             break
[10:22:29.226]                           }
[10:22:29.226]                         }
[10:22:29.226]                       }
[10:22:29.226]                       invisible(muffled)
[10:22:29.226]                     }
[10:22:29.226]                     muffleCondition(cond, pattern = "^muffle")
[10:22:29.226]                   }
[10:22:29.226]                 }
[10:22:29.226]                 else {
[10:22:29.226]                   if (TRUE) {
[10:22:29.226]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.226]                     {
[10:22:29.226]                       inherits <- base::inherits
[10:22:29.226]                       invokeRestart <- base::invokeRestart
[10:22:29.226]                       is.null <- base::is.null
[10:22:29.226]                       muffled <- FALSE
[10:22:29.226]                       if (inherits(cond, "message")) {
[10:22:29.226]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:29.226]                         if (muffled) 
[10:22:29.226]                           invokeRestart("muffleMessage")
[10:22:29.226]                       }
[10:22:29.226]                       else if (inherits(cond, "warning")) {
[10:22:29.226]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:29.226]                         if (muffled) 
[10:22:29.226]                           invokeRestart("muffleWarning")
[10:22:29.226]                       }
[10:22:29.226]                       else if (inherits(cond, "condition")) {
[10:22:29.226]                         if (!is.null(pattern)) {
[10:22:29.226]                           computeRestarts <- base::computeRestarts
[10:22:29.226]                           grepl <- base::grepl
[10:22:29.226]                           restarts <- computeRestarts(cond)
[10:22:29.226]                           for (restart in restarts) {
[10:22:29.226]                             name <- restart$name
[10:22:29.226]                             if (is.null(name)) 
[10:22:29.226]                               next
[10:22:29.226]                             if (!grepl(pattern, name)) 
[10:22:29.226]                               next
[10:22:29.226]                             invokeRestart(restart)
[10:22:29.226]                             muffled <- TRUE
[10:22:29.226]                             break
[10:22:29.226]                           }
[10:22:29.226]                         }
[10:22:29.226]                       }
[10:22:29.226]                       invisible(muffled)
[10:22:29.226]                     }
[10:22:29.226]                     muffleCondition(cond, pattern = "^muffle")
[10:22:29.226]                   }
[10:22:29.226]                 }
[10:22:29.226]             }
[10:22:29.226]         }))
[10:22:29.226]     }, error = function(ex) {
[10:22:29.226]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:29.226]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:29.226]                 ...future.rng), started = ...future.startTime, 
[10:22:29.226]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:29.226]             version = "1.8"), class = "FutureResult")
[10:22:29.226]     }, finally = {
[10:22:29.226]         if (!identical(...future.workdir, getwd())) 
[10:22:29.226]             setwd(...future.workdir)
[10:22:29.226]         {
[10:22:29.226]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:29.226]                 ...future.oldOptions$nwarnings <- NULL
[10:22:29.226]             }
[10:22:29.226]             base::options(...future.oldOptions)
[10:22:29.226]             if (.Platform$OS.type == "windows") {
[10:22:29.226]                 old_names <- names(...future.oldEnvVars)
[10:22:29.226]                 envs <- base::Sys.getenv()
[10:22:29.226]                 names <- names(envs)
[10:22:29.226]                 common <- intersect(names, old_names)
[10:22:29.226]                 added <- setdiff(names, old_names)
[10:22:29.226]                 removed <- setdiff(old_names, names)
[10:22:29.226]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:29.226]                   envs[common]]
[10:22:29.226]                 NAMES <- toupper(changed)
[10:22:29.226]                 args <- list()
[10:22:29.226]                 for (kk in seq_along(NAMES)) {
[10:22:29.226]                   name <- changed[[kk]]
[10:22:29.226]                   NAME <- NAMES[[kk]]
[10:22:29.226]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.226]                     next
[10:22:29.226]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:29.226]                 }
[10:22:29.226]                 NAMES <- toupper(added)
[10:22:29.226]                 for (kk in seq_along(NAMES)) {
[10:22:29.226]                   name <- added[[kk]]
[10:22:29.226]                   NAME <- NAMES[[kk]]
[10:22:29.226]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.226]                     next
[10:22:29.226]                   args[[name]] <- ""
[10:22:29.226]                 }
[10:22:29.226]                 NAMES <- toupper(removed)
[10:22:29.226]                 for (kk in seq_along(NAMES)) {
[10:22:29.226]                   name <- removed[[kk]]
[10:22:29.226]                   NAME <- NAMES[[kk]]
[10:22:29.226]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.226]                     next
[10:22:29.226]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:29.226]                 }
[10:22:29.226]                 if (length(args) > 0) 
[10:22:29.226]                   base::do.call(base::Sys.setenv, args = args)
[10:22:29.226]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:29.226]             }
[10:22:29.226]             else {
[10:22:29.226]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:29.226]             }
[10:22:29.226]             {
[10:22:29.226]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:29.226]                   0L) {
[10:22:29.226]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:29.226]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:29.226]                   base::options(opts)
[10:22:29.226]                 }
[10:22:29.226]                 {
[10:22:29.226]                   {
[10:22:29.226]                     NULL
[10:22:29.226]                     RNGkind("Mersenne-Twister")
[10:22:29.226]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:29.226]                       inherits = FALSE)
[10:22:29.226]                   }
[10:22:29.226]                   options(future.plan = NULL)
[10:22:29.226]                   if (is.na(NA_character_)) 
[10:22:29.226]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:29.226]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:29.226]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:29.226]                     .init = FALSE)
[10:22:29.226]                 }
[10:22:29.226]             }
[10:22:29.226]         }
[10:22:29.226]     })
[10:22:29.226]     if (TRUE) {
[10:22:29.226]         base::sink(type = "output", split = FALSE)
[10:22:29.226]         if (TRUE) {
[10:22:29.226]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:29.226]         }
[10:22:29.226]         else {
[10:22:29.226]             ...future.result["stdout"] <- base::list(NULL)
[10:22:29.226]         }
[10:22:29.226]         base::close(...future.stdout)
[10:22:29.226]         ...future.stdout <- NULL
[10:22:29.226]     }
[10:22:29.226]     ...future.result$conditions <- ...future.conditions
[10:22:29.226]     ...future.result$finished <- base::Sys.time()
[10:22:29.226]     ...future.result
[10:22:29.226] }
[10:22:29.228] plan(): Setting new future strategy stack:
[10:22:29.228] List of future strategies:
[10:22:29.228] 1. sequential:
[10:22:29.228]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:29.228]    - tweaked: FALSE
[10:22:29.228]    - call: NULL
[10:22:29.229] plan(): nbrOfWorkers() = 1
[10:22:29.730] plan(): Setting new future strategy stack:
[10:22:29.730] List of future strategies:
[10:22:29.730] 1. sequential:
[10:22:29.730]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:29.730]    - tweaked: FALSE
[10:22:29.730]    - call: plan(strategy)
[10:22:29.731] plan(): nbrOfWorkers() = 1
[10:22:29.731] SequentialFuture started (and completed)
[10:22:29.731] - Launch lazy future ... done
[10:22:29.732] run() for ‘SequentialFuture’ ... done
[10:22:29.732] getGlobalsAndPackages() ...
[10:22:29.732] Searching for globals...
[10:22:29.733] - globals found: [1] ‘{’
[10:22:29.733] Searching for globals ... DONE
[10:22:29.733] Resolving globals: FALSE
[10:22:29.733] 
[10:22:29.733] 
[10:22:29.733] getGlobalsAndPackages() ... DONE
[10:22:29.734] run() for ‘Future’ ...
[10:22:29.734] - state: ‘created’
[10:22:29.734] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:29.734] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:29.734] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:29.734]   - Field: ‘label’
[10:22:29.735]   - Field: ‘local’
[10:22:29.735]   - Field: ‘owner’
[10:22:29.735]   - Field: ‘envir’
[10:22:29.735]   - Field: ‘packages’
[10:22:29.735]   - Field: ‘gc’
[10:22:29.735]   - Field: ‘conditions’
[10:22:29.735]   - Field: ‘expr’
[10:22:29.735]   - Field: ‘uuid’
[10:22:29.735]   - Field: ‘seed’
[10:22:29.735]   - Field: ‘version’
[10:22:29.735]   - Field: ‘result’
[10:22:29.735]   - Field: ‘asynchronous’
[10:22:29.736]   - Field: ‘calls’
[10:22:29.736]   - Field: ‘globals’
[10:22:29.736]   - Field: ‘stdout’
[10:22:29.736]   - Field: ‘earlySignal’
[10:22:29.736]   - Field: ‘lazy’
[10:22:29.736]   - Field: ‘state’
[10:22:29.736] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:29.736] - Launch lazy future ...
[10:22:29.736] Packages needed by the future expression (n = 0): <none>
[10:22:29.736] Packages needed by future strategies (n = 0): <none>
[10:22:29.737] {
[10:22:29.737]     {
[10:22:29.737]         {
[10:22:29.737]             ...future.startTime <- base::Sys.time()
[10:22:29.737]             {
[10:22:29.737]                 {
[10:22:29.737]                   {
[10:22:29.737]                     base::local({
[10:22:29.737]                       has_future <- base::requireNamespace("future", 
[10:22:29.737]                         quietly = TRUE)
[10:22:29.737]                       if (has_future) {
[10:22:29.737]                         ns <- base::getNamespace("future")
[10:22:29.737]                         version <- ns[[".package"]][["version"]]
[10:22:29.737]                         if (is.null(version)) 
[10:22:29.737]                           version <- utils::packageVersion("future")
[10:22:29.737]                       }
[10:22:29.737]                       else {
[10:22:29.737]                         version <- NULL
[10:22:29.737]                       }
[10:22:29.737]                       if (!has_future || version < "1.8.0") {
[10:22:29.737]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:29.737]                           "", base::R.version$version.string), 
[10:22:29.737]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:29.737]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:29.737]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:29.737]                             "release", "version")], collapse = " "), 
[10:22:29.737]                           hostname = base::Sys.info()[["nodename"]])
[10:22:29.737]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:29.737]                           info)
[10:22:29.737]                         info <- base::paste(info, collapse = "; ")
[10:22:29.737]                         if (!has_future) {
[10:22:29.737]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:29.737]                             info)
[10:22:29.737]                         }
[10:22:29.737]                         else {
[10:22:29.737]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:29.737]                             info, version)
[10:22:29.737]                         }
[10:22:29.737]                         base::stop(msg)
[10:22:29.737]                       }
[10:22:29.737]                     })
[10:22:29.737]                   }
[10:22:29.737]                   ...future.strategy.old <- future::plan("list")
[10:22:29.737]                   options(future.plan = NULL)
[10:22:29.737]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:29.737]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:29.737]                 }
[10:22:29.737]                 ...future.workdir <- getwd()
[10:22:29.737]             }
[10:22:29.737]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:29.737]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:29.737]         }
[10:22:29.737]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:29.737]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:29.737]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:29.737]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:29.737]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:29.737]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:29.737]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:29.737]             base::names(...future.oldOptions))
[10:22:29.737]     }
[10:22:29.737]     if (FALSE) {
[10:22:29.737]     }
[10:22:29.737]     else {
[10:22:29.737]         if (TRUE) {
[10:22:29.737]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:29.737]                 open = "w")
[10:22:29.737]         }
[10:22:29.737]         else {
[10:22:29.737]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:29.737]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:29.737]         }
[10:22:29.737]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:29.737]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:29.737]             base::sink(type = "output", split = FALSE)
[10:22:29.737]             base::close(...future.stdout)
[10:22:29.737]         }, add = TRUE)
[10:22:29.737]     }
[10:22:29.737]     ...future.frame <- base::sys.nframe()
[10:22:29.737]     ...future.conditions <- base::list()
[10:22:29.737]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:29.737]     if (FALSE) {
[10:22:29.737]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:29.737]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:29.737]     }
[10:22:29.737]     ...future.result <- base::tryCatch({
[10:22:29.737]         base::withCallingHandlers({
[10:22:29.737]             ...future.value <- base::withVisible(base::local({
[10:22:29.737]                 3
[10:22:29.737]             }))
[10:22:29.737]             future::FutureResult(value = ...future.value$value, 
[10:22:29.737]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:29.737]                   ...future.rng), globalenv = if (FALSE) 
[10:22:29.737]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:29.737]                     ...future.globalenv.names))
[10:22:29.737]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:29.737]         }, condition = base::local({
[10:22:29.737]             c <- base::c
[10:22:29.737]             inherits <- base::inherits
[10:22:29.737]             invokeRestart <- base::invokeRestart
[10:22:29.737]             length <- base::length
[10:22:29.737]             list <- base::list
[10:22:29.737]             seq.int <- base::seq.int
[10:22:29.737]             signalCondition <- base::signalCondition
[10:22:29.737]             sys.calls <- base::sys.calls
[10:22:29.737]             `[[` <- base::`[[`
[10:22:29.737]             `+` <- base::`+`
[10:22:29.737]             `<<-` <- base::`<<-`
[10:22:29.737]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:29.737]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:29.737]                   3L)]
[10:22:29.737]             }
[10:22:29.737]             function(cond) {
[10:22:29.737]                 is_error <- inherits(cond, "error")
[10:22:29.737]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:29.737]                   NULL)
[10:22:29.737]                 if (is_error) {
[10:22:29.737]                   sessionInformation <- function() {
[10:22:29.737]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:29.737]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:29.737]                       search = base::search(), system = base::Sys.info())
[10:22:29.737]                   }
[10:22:29.737]                   ...future.conditions[[length(...future.conditions) + 
[10:22:29.737]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:29.737]                     cond$call), session = sessionInformation(), 
[10:22:29.737]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:29.737]                   signalCondition(cond)
[10:22:29.737]                 }
[10:22:29.737]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:29.737]                 "immediateCondition"))) {
[10:22:29.737]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:29.737]                   ...future.conditions[[length(...future.conditions) + 
[10:22:29.737]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:29.737]                   if (TRUE && !signal) {
[10:22:29.737]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.737]                     {
[10:22:29.737]                       inherits <- base::inherits
[10:22:29.737]                       invokeRestart <- base::invokeRestart
[10:22:29.737]                       is.null <- base::is.null
[10:22:29.737]                       muffled <- FALSE
[10:22:29.737]                       if (inherits(cond, "message")) {
[10:22:29.737]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:29.737]                         if (muffled) 
[10:22:29.737]                           invokeRestart("muffleMessage")
[10:22:29.737]                       }
[10:22:29.737]                       else if (inherits(cond, "warning")) {
[10:22:29.737]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:29.737]                         if (muffled) 
[10:22:29.737]                           invokeRestart("muffleWarning")
[10:22:29.737]                       }
[10:22:29.737]                       else if (inherits(cond, "condition")) {
[10:22:29.737]                         if (!is.null(pattern)) {
[10:22:29.737]                           computeRestarts <- base::computeRestarts
[10:22:29.737]                           grepl <- base::grepl
[10:22:29.737]                           restarts <- computeRestarts(cond)
[10:22:29.737]                           for (restart in restarts) {
[10:22:29.737]                             name <- restart$name
[10:22:29.737]                             if (is.null(name)) 
[10:22:29.737]                               next
[10:22:29.737]                             if (!grepl(pattern, name)) 
[10:22:29.737]                               next
[10:22:29.737]                             invokeRestart(restart)
[10:22:29.737]                             muffled <- TRUE
[10:22:29.737]                             break
[10:22:29.737]                           }
[10:22:29.737]                         }
[10:22:29.737]                       }
[10:22:29.737]                       invisible(muffled)
[10:22:29.737]                     }
[10:22:29.737]                     muffleCondition(cond, pattern = "^muffle")
[10:22:29.737]                   }
[10:22:29.737]                 }
[10:22:29.737]                 else {
[10:22:29.737]                   if (TRUE) {
[10:22:29.737]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.737]                     {
[10:22:29.737]                       inherits <- base::inherits
[10:22:29.737]                       invokeRestart <- base::invokeRestart
[10:22:29.737]                       is.null <- base::is.null
[10:22:29.737]                       muffled <- FALSE
[10:22:29.737]                       if (inherits(cond, "message")) {
[10:22:29.737]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:29.737]                         if (muffled) 
[10:22:29.737]                           invokeRestart("muffleMessage")
[10:22:29.737]                       }
[10:22:29.737]                       else if (inherits(cond, "warning")) {
[10:22:29.737]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:29.737]                         if (muffled) 
[10:22:29.737]                           invokeRestart("muffleWarning")
[10:22:29.737]                       }
[10:22:29.737]                       else if (inherits(cond, "condition")) {
[10:22:29.737]                         if (!is.null(pattern)) {
[10:22:29.737]                           computeRestarts <- base::computeRestarts
[10:22:29.737]                           grepl <- base::grepl
[10:22:29.737]                           restarts <- computeRestarts(cond)
[10:22:29.737]                           for (restart in restarts) {
[10:22:29.737]                             name <- restart$name
[10:22:29.737]                             if (is.null(name)) 
[10:22:29.737]                               next
[10:22:29.737]                             if (!grepl(pattern, name)) 
[10:22:29.737]                               next
[10:22:29.737]                             invokeRestart(restart)
[10:22:29.737]                             muffled <- TRUE
[10:22:29.737]                             break
[10:22:29.737]                           }
[10:22:29.737]                         }
[10:22:29.737]                       }
[10:22:29.737]                       invisible(muffled)
[10:22:29.737]                     }
[10:22:29.737]                     muffleCondition(cond, pattern = "^muffle")
[10:22:29.737]                   }
[10:22:29.737]                 }
[10:22:29.737]             }
[10:22:29.737]         }))
[10:22:29.737]     }, error = function(ex) {
[10:22:29.737]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:29.737]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:29.737]                 ...future.rng), started = ...future.startTime, 
[10:22:29.737]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:29.737]             version = "1.8"), class = "FutureResult")
[10:22:29.737]     }, finally = {
[10:22:29.737]         if (!identical(...future.workdir, getwd())) 
[10:22:29.737]             setwd(...future.workdir)
[10:22:29.737]         {
[10:22:29.737]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:29.737]                 ...future.oldOptions$nwarnings <- NULL
[10:22:29.737]             }
[10:22:29.737]             base::options(...future.oldOptions)
[10:22:29.737]             if (.Platform$OS.type == "windows") {
[10:22:29.737]                 old_names <- names(...future.oldEnvVars)
[10:22:29.737]                 envs <- base::Sys.getenv()
[10:22:29.737]                 names <- names(envs)
[10:22:29.737]                 common <- intersect(names, old_names)
[10:22:29.737]                 added <- setdiff(names, old_names)
[10:22:29.737]                 removed <- setdiff(old_names, names)
[10:22:29.737]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:29.737]                   envs[common]]
[10:22:29.737]                 NAMES <- toupper(changed)
[10:22:29.737]                 args <- list()
[10:22:29.737]                 for (kk in seq_along(NAMES)) {
[10:22:29.737]                   name <- changed[[kk]]
[10:22:29.737]                   NAME <- NAMES[[kk]]
[10:22:29.737]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.737]                     next
[10:22:29.737]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:29.737]                 }
[10:22:29.737]                 NAMES <- toupper(added)
[10:22:29.737]                 for (kk in seq_along(NAMES)) {
[10:22:29.737]                   name <- added[[kk]]
[10:22:29.737]                   NAME <- NAMES[[kk]]
[10:22:29.737]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.737]                     next
[10:22:29.737]                   args[[name]] <- ""
[10:22:29.737]                 }
[10:22:29.737]                 NAMES <- toupper(removed)
[10:22:29.737]                 for (kk in seq_along(NAMES)) {
[10:22:29.737]                   name <- removed[[kk]]
[10:22:29.737]                   NAME <- NAMES[[kk]]
[10:22:29.737]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.737]                     next
[10:22:29.737]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:29.737]                 }
[10:22:29.737]                 if (length(args) > 0) 
[10:22:29.737]                   base::do.call(base::Sys.setenv, args = args)
[10:22:29.737]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:29.737]             }
[10:22:29.737]             else {
[10:22:29.737]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:29.737]             }
[10:22:29.737]             {
[10:22:29.737]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:29.737]                   0L) {
[10:22:29.737]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:29.737]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:29.737]                   base::options(opts)
[10:22:29.737]                 }
[10:22:29.737]                 {
[10:22:29.737]                   {
[10:22:29.737]                     NULL
[10:22:29.737]                     RNGkind("Mersenne-Twister")
[10:22:29.737]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:29.737]                       inherits = FALSE)
[10:22:29.737]                   }
[10:22:29.737]                   options(future.plan = NULL)
[10:22:29.737]                   if (is.na(NA_character_)) 
[10:22:29.737]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:29.737]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:29.737]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:29.737]                     .init = FALSE)
[10:22:29.737]                 }
[10:22:29.737]             }
[10:22:29.737]         }
[10:22:29.737]     })
[10:22:29.737]     if (TRUE) {
[10:22:29.737]         base::sink(type = "output", split = FALSE)
[10:22:29.737]         if (TRUE) {
[10:22:29.737]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:29.737]         }
[10:22:29.737]         else {
[10:22:29.737]             ...future.result["stdout"] <- base::list(NULL)
[10:22:29.737]         }
[10:22:29.737]         base::close(...future.stdout)
[10:22:29.737]         ...future.stdout <- NULL
[10:22:29.737]     }
[10:22:29.737]     ...future.result$conditions <- ...future.conditions
[10:22:29.737]     ...future.result$finished <- base::Sys.time()
[10:22:29.737]     ...future.result
[10:22:29.737] }
[10:22:29.739] plan(): Setting new future strategy stack:
[10:22:29.739] List of future strategies:
[10:22:29.739] 1. sequential:
[10:22:29.739]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:29.739]    - tweaked: FALSE
[10:22:29.739]    - call: NULL
[10:22:29.739] plan(): nbrOfWorkers() = 1
[10:22:29.740] plan(): Setting new future strategy stack:
[10:22:29.740] List of future strategies:
[10:22:29.740] 1. sequential:
[10:22:29.740]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:29.740]    - tweaked: FALSE
[10:22:29.740]    - call: plan(strategy)
[10:22:29.741] plan(): nbrOfWorkers() = 1
[10:22:29.741] SequentialFuture started (and completed)
[10:22:29.741] - Launch lazy future ... done
[10:22:29.741] run() for ‘SequentialFuture’ ... done
[10:22:29.742] resolve() on list environment ...
[10:22:29.742]  recursive: 0
[10:22:29.742]  length: 4
[10:22:29.742]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:22:29.742] resolved() for ‘SequentialFuture’ ...
[10:22:29.743] - state: ‘finished’
[10:22:29.743] - run: TRUE
[10:22:29.743] - result: ‘FutureResult’
[10:22:29.743] resolved() for ‘SequentialFuture’ ... done
[10:22:29.743] Future #1
[10:22:29.743]  length: 3 (resolved future 1)
[10:22:29.743] resolved() for ‘SequentialFuture’ ...
[10:22:29.743] - state: ‘finished’
[10:22:29.743] - run: TRUE
[10:22:29.743] - result: ‘FutureResult’
[10:22:29.744] resolved() for ‘SequentialFuture’ ... done
[10:22:29.744] Future #2
[10:22:29.744]  length: 2 (resolved future 2)
[10:22:29.744] resolved() for ‘SequentialFuture’ ...
[10:22:29.744] - state: ‘finished’
[10:22:29.744] - run: TRUE
[10:22:29.744] - result: ‘FutureResult’
[10:22:29.744] resolved() for ‘SequentialFuture’ ... done
[10:22:29.744] Future #3
[10:22:29.744]  length: 1 (resolved future 3)
[10:22:29.744]  length: 0 (resolved future 4)
[10:22:29.745] resolve() on list environment ... DONE
[10:22:29.745] resolved() for ‘SequentialFuture’ ...
[10:22:29.745] - state: ‘finished’
[10:22:29.745] - run: TRUE
[10:22:29.745] - result: ‘FutureResult’
[10:22:29.745] resolved() for ‘SequentialFuture’ ... done
[10:22:29.745] resolve() on list environment ...
[10:22:29.745]  recursive: 0
[10:22:29.748]  length: 4
[10:22:29.748]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:22:29.749] resolved() for ‘SequentialFuture’ ...
[10:22:29.749] - state: ‘finished’
[10:22:29.749] - run: TRUE
[10:22:29.749] - result: ‘FutureResult’
[10:22:29.749] resolved() for ‘SequentialFuture’ ... done
[10:22:29.749] Future #1
[10:22:29.749]  length: 3 (resolved future 1)
[10:22:29.749] resolved() for ‘SequentialFuture’ ...
[10:22:29.749] - state: ‘finished’
[10:22:29.749] - run: TRUE
[10:22:29.749] - result: ‘FutureResult’
[10:22:29.750] resolved() for ‘SequentialFuture’ ... done
[10:22:29.750] Future #2
[10:22:29.750]  length: 2 (resolved future 2)
[10:22:29.750] resolved() for ‘SequentialFuture’ ...
[10:22:29.750] - state: ‘finished’
[10:22:29.750] - run: TRUE
[10:22:29.750] - result: ‘FutureResult’
[10:22:29.750] resolved() for ‘SequentialFuture’ ... done
[10:22:29.750] Future #3
[10:22:29.750]  length: 1 (resolved future 3)
[10:22:29.751]  length: 0 (resolved future 4)
[10:22:29.751] resolve() on list environment ... DONE
[10:22:29.751] resolve() on list environment ...
[10:22:29.751]  recursive: 0
[10:22:29.752]  length: 4
[10:22:29.752]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:22:29.752] resolved() for ‘SequentialFuture’ ...
[10:22:29.752] - state: ‘finished’
[10:22:29.752] - run: TRUE
[10:22:29.752] - result: ‘FutureResult’
[10:22:29.752] resolved() for ‘SequentialFuture’ ... done
[10:22:29.752] Future #1
[10:22:29.753]  length: 3 (resolved future 1)
[10:22:29.753] resolved() for ‘SequentialFuture’ ...
[10:22:29.753] - state: ‘finished’
[10:22:29.753] - run: TRUE
[10:22:29.753] - result: ‘FutureResult’
[10:22:29.753] resolved() for ‘SequentialFuture’ ... done
[10:22:29.753] Future #2
[10:22:29.753]  length: 2 (resolved future 2)
[10:22:29.753] resolved() for ‘SequentialFuture’ ...
[10:22:29.753] - state: ‘finished’
[10:22:29.754] - run: TRUE
[10:22:29.754] - result: ‘FutureResult’
[10:22:29.754] resolved() for ‘SequentialFuture’ ... done
[10:22:29.754] Future #3
[10:22:29.754]  length: 1 (resolved future 3)
[10:22:29.754]  length: 0 (resolved future 4)
[10:22:29.754] resolve() on list environment ... DONE
[10:22:29.755] resolve() on list environment ...
[10:22:29.755]  recursive: 0
[10:22:29.755]  length: 4
[10:22:29.755]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:22:29.755] resolved() for ‘SequentialFuture’ ...
[10:22:29.756] - state: ‘finished’
[10:22:29.756] - run: TRUE
[10:22:29.756] - result: ‘FutureResult’
[10:22:29.756] resolved() for ‘SequentialFuture’ ... done
[10:22:29.756] Future #1
[10:22:29.756]  length: 3 (resolved future 1)
[10:22:29.756] resolved() for ‘SequentialFuture’ ...
[10:22:29.756] - state: ‘finished’
[10:22:29.756] - run: TRUE
[10:22:29.756] - result: ‘FutureResult’
[10:22:29.756] resolved() for ‘SequentialFuture’ ... done
[10:22:29.756] Future #2
[10:22:29.757]  length: 2 (resolved future 2)
[10:22:29.757] resolved() for ‘SequentialFuture’ ...
[10:22:29.757] - state: ‘finished’
[10:22:29.757] - run: TRUE
[10:22:29.757] - result: ‘FutureResult’
[10:22:29.757] resolved() for ‘SequentialFuture’ ... done
[10:22:29.757] Future #3
[10:22:29.757]  length: 1 (resolved future 3)
[10:22:29.757]  length: 0 (resolved future 4)
[10:22:29.757] resolve() on list environment ... DONE
[10:22:29.758] resolve() on list environment ...
[10:22:29.758]  recursive: 0
[10:22:29.758]  length: 4
[10:22:29.758]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:22:29.759] resolved() for ‘SequentialFuture’ ...
[10:22:29.759] - state: ‘finished’
[10:22:29.759] - run: TRUE
[10:22:29.759] - result: ‘FutureResult’
[10:22:29.759] resolved() for ‘SequentialFuture’ ... done
[10:22:29.759] Future #1
[10:22:29.759]  length: 3 (resolved future 1)
[10:22:29.759] resolved() for ‘SequentialFuture’ ...
[10:22:29.759] - state: ‘finished’
[10:22:29.759] - run: TRUE
[10:22:29.760] - result: ‘FutureResult’
[10:22:29.760] resolved() for ‘SequentialFuture’ ... done
[10:22:29.760] Future #2
[10:22:29.760]  length: 2 (resolved future 2)
[10:22:29.760] resolved() for ‘SequentialFuture’ ...
[10:22:29.760] - state: ‘finished’
[10:22:29.760] - run: TRUE
[10:22:29.760] - result: ‘FutureResult’
[10:22:29.760] resolved() for ‘SequentialFuture’ ... done
[10:22:29.760] Future #3
[10:22:29.761]  length: 1 (resolved future 3)
[10:22:29.761]  length: 0 (resolved future 4)
[10:22:29.761] resolve() on list environment ... DONE
[10:22:29.761] resolve() on list environment ...
[10:22:29.761]  recursive: 99
[10:22:29.762]  length: 4
[10:22:29.762]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:22:29.762] resolved() for ‘SequentialFuture’ ...
[10:22:29.762] - state: ‘finished’
[10:22:29.762] - run: TRUE
[10:22:29.762] - result: ‘FutureResult’
[10:22:29.763] resolved() for ‘SequentialFuture’ ... done
[10:22:29.763] Future #1
[10:22:29.763] resolved() for ‘SequentialFuture’ ...
[10:22:29.763] - state: ‘finished’
[10:22:29.763] - run: TRUE
[10:22:29.763] - result: ‘FutureResult’
[10:22:29.763] resolved() for ‘SequentialFuture’ ... done
[10:22:29.763] A SequentialFuture was resolved
[10:22:29.763]  length: 3 (resolved future 1)
[10:22:29.763] resolved() for ‘SequentialFuture’ ...
[10:22:29.764] - state: ‘finished’
[10:22:29.764] - run: TRUE
[10:22:29.764] - result: ‘FutureResult’
[10:22:29.764] resolved() for ‘SequentialFuture’ ... done
[10:22:29.764] Future #2
[10:22:29.764] resolved() for ‘SequentialFuture’ ...
[10:22:29.764] - state: ‘finished’
[10:22:29.764] - run: TRUE
[10:22:29.764] - result: ‘FutureResult’
[10:22:29.764] resolved() for ‘SequentialFuture’ ... done
[10:22:29.764] A SequentialFuture was resolved
[10:22:29.765]  length: 2 (resolved future 2)
[10:22:29.765] resolved() for ‘SequentialFuture’ ...
[10:22:29.765] - state: ‘finished’
[10:22:29.765] - run: TRUE
[10:22:29.765] - result: ‘FutureResult’
[10:22:29.765] resolved() for ‘SequentialFuture’ ... done
[10:22:29.765] Future #3
[10:22:29.765] resolved() for ‘SequentialFuture’ ...
[10:22:29.765] - state: ‘finished’
[10:22:29.765] - run: TRUE
[10:22:29.765] - result: ‘FutureResult’
[10:22:29.766] resolved() for ‘SequentialFuture’ ... done
[10:22:29.766] A SequentialFuture was resolved
[10:22:29.766]  length: 1 (resolved future 3)
[10:22:29.766]  length: 0 (resolved future 4)
[10:22:29.766] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('sequential') ...
- plan('multicore') ...
[10:22:29.766] plan(): Setting new future strategy stack:
[10:22:29.767] List of future strategies:
[10:22:29.767] 1. multicore:
[10:22:29.767]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:29.767]    - tweaked: FALSE
[10:22:29.767]    - call: plan(strategy)
[10:22:29.796] plan(): nbrOfWorkers() = 2
*** resolve() for lists ...
[10:22:29.796] resolve() on list ...
[10:22:29.797]  recursive: 0
[10:22:29.797]  length: 2
[10:22:29.797]  elements: ‘a’, ‘b’
[10:22:29.797]  length: 1 (resolved future 1)
[10:22:29.797]  length: 0 (resolved future 2)
[10:22:29.797] resolve() on list ... DONE
[10:22:29.797] getGlobalsAndPackages() ...
[10:22:29.797] Searching for globals...
[10:22:29.798] 
[10:22:29.798] Searching for globals ... DONE
[10:22:29.798] - globals: [0] <none>
[10:22:29.798] getGlobalsAndPackages() ... DONE
[10:22:29.798] run() for ‘Future’ ...
[10:22:29.798] - state: ‘created’
[10:22:29.798] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:29.800] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:29.800] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:29.800]   - Field: ‘label’
[10:22:29.800]   - Field: ‘local’
[10:22:29.800]   - Field: ‘owner’
[10:22:29.800]   - Field: ‘envir’
[10:22:29.800]   - Field: ‘workers’
[10:22:29.801]   - Field: ‘packages’
[10:22:29.801]   - Field: ‘gc’
[10:22:29.801]   - Field: ‘job’
[10:22:29.801]   - Field: ‘conditions’
[10:22:29.801]   - Field: ‘expr’
[10:22:29.801]   - Field: ‘uuid’
[10:22:29.801]   - Field: ‘seed’
[10:22:29.801]   - Field: ‘version’
[10:22:29.801]   - Field: ‘result’
[10:22:29.801]   - Field: ‘asynchronous’
[10:22:29.801]   - Field: ‘calls’
[10:22:29.801]   - Field: ‘globals’
[10:22:29.802]   - Field: ‘stdout’
[10:22:29.802]   - Field: ‘earlySignal’
[10:22:29.802]   - Field: ‘lazy’
[10:22:29.802]   - Field: ‘state’
[10:22:29.802] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:29.802] - Launch lazy future ...
[10:22:29.803] Packages needed by the future expression (n = 0): <none>
[10:22:29.803] Packages needed by future strategies (n = 0): <none>
[10:22:29.803] {
[10:22:29.803]     {
[10:22:29.803]         {
[10:22:29.803]             ...future.startTime <- base::Sys.time()
[10:22:29.803]             {
[10:22:29.803]                 {
[10:22:29.803]                   {
[10:22:29.803]                     {
[10:22:29.803]                       base::local({
[10:22:29.803]                         has_future <- base::requireNamespace("future", 
[10:22:29.803]                           quietly = TRUE)
[10:22:29.803]                         if (has_future) {
[10:22:29.803]                           ns <- base::getNamespace("future")
[10:22:29.803]                           version <- ns[[".package"]][["version"]]
[10:22:29.803]                           if (is.null(version)) 
[10:22:29.803]                             version <- utils::packageVersion("future")
[10:22:29.803]                         }
[10:22:29.803]                         else {
[10:22:29.803]                           version <- NULL
[10:22:29.803]                         }
[10:22:29.803]                         if (!has_future || version < "1.8.0") {
[10:22:29.803]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:29.803]                             "", base::R.version$version.string), 
[10:22:29.803]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:29.803]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:29.803]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:29.803]                               "release", "version")], collapse = " "), 
[10:22:29.803]                             hostname = base::Sys.info()[["nodename"]])
[10:22:29.803]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:29.803]                             info)
[10:22:29.803]                           info <- base::paste(info, collapse = "; ")
[10:22:29.803]                           if (!has_future) {
[10:22:29.803]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:29.803]                               info)
[10:22:29.803]                           }
[10:22:29.803]                           else {
[10:22:29.803]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:29.803]                               info, version)
[10:22:29.803]                           }
[10:22:29.803]                           base::stop(msg)
[10:22:29.803]                         }
[10:22:29.803]                       })
[10:22:29.803]                     }
[10:22:29.803]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:29.803]                     base::options(mc.cores = 1L)
[10:22:29.803]                   }
[10:22:29.803]                   ...future.strategy.old <- future::plan("list")
[10:22:29.803]                   options(future.plan = NULL)
[10:22:29.803]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:29.803]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:29.803]                 }
[10:22:29.803]                 ...future.workdir <- getwd()
[10:22:29.803]             }
[10:22:29.803]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:29.803]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:29.803]         }
[10:22:29.803]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:29.803]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:29.803]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:29.803]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:29.803]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:29.803]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:29.803]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:29.803]             base::names(...future.oldOptions))
[10:22:29.803]     }
[10:22:29.803]     if (FALSE) {
[10:22:29.803]     }
[10:22:29.803]     else {
[10:22:29.803]         if (TRUE) {
[10:22:29.803]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:29.803]                 open = "w")
[10:22:29.803]         }
[10:22:29.803]         else {
[10:22:29.803]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:29.803]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:29.803]         }
[10:22:29.803]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:29.803]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:29.803]             base::sink(type = "output", split = FALSE)
[10:22:29.803]             base::close(...future.stdout)
[10:22:29.803]         }, add = TRUE)
[10:22:29.803]     }
[10:22:29.803]     ...future.frame <- base::sys.nframe()
[10:22:29.803]     ...future.conditions <- base::list()
[10:22:29.803]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:29.803]     if (FALSE) {
[10:22:29.803]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:29.803]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:29.803]     }
[10:22:29.803]     ...future.result <- base::tryCatch({
[10:22:29.803]         base::withCallingHandlers({
[10:22:29.803]             ...future.value <- base::withVisible(base::local({
[10:22:29.803]                 withCallingHandlers({
[10:22:29.803]                   1
[10:22:29.803]                 }, immediateCondition = function(cond) {
[10:22:29.803]                   save_rds <- function (object, pathname, ...) 
[10:22:29.803]                   {
[10:22:29.803]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:29.803]                     if (file_test("-f", pathname_tmp)) {
[10:22:29.803]                       fi_tmp <- file.info(pathname_tmp)
[10:22:29.803]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:29.803]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:29.803]                         fi_tmp[["mtime"]])
[10:22:29.803]                     }
[10:22:29.803]                     tryCatch({
[10:22:29.803]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:29.803]                     }, error = function(ex) {
[10:22:29.803]                       msg <- conditionMessage(ex)
[10:22:29.803]                       fi_tmp <- file.info(pathname_tmp)
[10:22:29.803]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:29.803]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:29.803]                         fi_tmp[["mtime"]], msg)
[10:22:29.803]                       ex$message <- msg
[10:22:29.803]                       stop(ex)
[10:22:29.803]                     })
[10:22:29.803]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:29.803]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:29.803]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:29.803]                       fi_tmp <- file.info(pathname_tmp)
[10:22:29.803]                       fi <- file.info(pathname)
[10:22:29.803]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:29.803]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:29.803]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:29.803]                         fi[["size"]], fi[["mtime"]])
[10:22:29.803]                       stop(msg)
[10:22:29.803]                     }
[10:22:29.803]                     invisible(pathname)
[10:22:29.803]                   }
[10:22:29.803]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:29.803]                     rootPath = tempdir()) 
[10:22:29.803]                   {
[10:22:29.803]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:29.803]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:29.803]                       tmpdir = path, fileext = ".rds")
[10:22:29.803]                     save_rds(obj, file)
[10:22:29.803]                   }
[10:22:29.803]                   saveImmediateCondition(cond, path = "/tmp/RtmpzsJv4f/.future/immediateConditions")
[10:22:29.803]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.803]                   {
[10:22:29.803]                     inherits <- base::inherits
[10:22:29.803]                     invokeRestart <- base::invokeRestart
[10:22:29.803]                     is.null <- base::is.null
[10:22:29.803]                     muffled <- FALSE
[10:22:29.803]                     if (inherits(cond, "message")) {
[10:22:29.803]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:29.803]                       if (muffled) 
[10:22:29.803]                         invokeRestart("muffleMessage")
[10:22:29.803]                     }
[10:22:29.803]                     else if (inherits(cond, "warning")) {
[10:22:29.803]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:29.803]                       if (muffled) 
[10:22:29.803]                         invokeRestart("muffleWarning")
[10:22:29.803]                     }
[10:22:29.803]                     else if (inherits(cond, "condition")) {
[10:22:29.803]                       if (!is.null(pattern)) {
[10:22:29.803]                         computeRestarts <- base::computeRestarts
[10:22:29.803]                         grepl <- base::grepl
[10:22:29.803]                         restarts <- computeRestarts(cond)
[10:22:29.803]                         for (restart in restarts) {
[10:22:29.803]                           name <- restart$name
[10:22:29.803]                           if (is.null(name)) 
[10:22:29.803]                             next
[10:22:29.803]                           if (!grepl(pattern, name)) 
[10:22:29.803]                             next
[10:22:29.803]                           invokeRestart(restart)
[10:22:29.803]                           muffled <- TRUE
[10:22:29.803]                           break
[10:22:29.803]                         }
[10:22:29.803]                       }
[10:22:29.803]                     }
[10:22:29.803]                     invisible(muffled)
[10:22:29.803]                   }
[10:22:29.803]                   muffleCondition(cond)
[10:22:29.803]                 })
[10:22:29.803]             }))
[10:22:29.803]             future::FutureResult(value = ...future.value$value, 
[10:22:29.803]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:29.803]                   ...future.rng), globalenv = if (FALSE) 
[10:22:29.803]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:29.803]                     ...future.globalenv.names))
[10:22:29.803]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:29.803]         }, condition = base::local({
[10:22:29.803]             c <- base::c
[10:22:29.803]             inherits <- base::inherits
[10:22:29.803]             invokeRestart <- base::invokeRestart
[10:22:29.803]             length <- base::length
[10:22:29.803]             list <- base::list
[10:22:29.803]             seq.int <- base::seq.int
[10:22:29.803]             signalCondition <- base::signalCondition
[10:22:29.803]             sys.calls <- base::sys.calls
[10:22:29.803]             `[[` <- base::`[[`
[10:22:29.803]             `+` <- base::`+`
[10:22:29.803]             `<<-` <- base::`<<-`
[10:22:29.803]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:29.803]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:29.803]                   3L)]
[10:22:29.803]             }
[10:22:29.803]             function(cond) {
[10:22:29.803]                 is_error <- inherits(cond, "error")
[10:22:29.803]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:29.803]                   NULL)
[10:22:29.803]                 if (is_error) {
[10:22:29.803]                   sessionInformation <- function() {
[10:22:29.803]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:29.803]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:29.803]                       search = base::search(), system = base::Sys.info())
[10:22:29.803]                   }
[10:22:29.803]                   ...future.conditions[[length(...future.conditions) + 
[10:22:29.803]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:29.803]                     cond$call), session = sessionInformation(), 
[10:22:29.803]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:29.803]                   signalCondition(cond)
[10:22:29.803]                 }
[10:22:29.803]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:29.803]                 "immediateCondition"))) {
[10:22:29.803]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:29.803]                   ...future.conditions[[length(...future.conditions) + 
[10:22:29.803]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:29.803]                   if (TRUE && !signal) {
[10:22:29.803]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.803]                     {
[10:22:29.803]                       inherits <- base::inherits
[10:22:29.803]                       invokeRestart <- base::invokeRestart
[10:22:29.803]                       is.null <- base::is.null
[10:22:29.803]                       muffled <- FALSE
[10:22:29.803]                       if (inherits(cond, "message")) {
[10:22:29.803]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:29.803]                         if (muffled) 
[10:22:29.803]                           invokeRestart("muffleMessage")
[10:22:29.803]                       }
[10:22:29.803]                       else if (inherits(cond, "warning")) {
[10:22:29.803]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:29.803]                         if (muffled) 
[10:22:29.803]                           invokeRestart("muffleWarning")
[10:22:29.803]                       }
[10:22:29.803]                       else if (inherits(cond, "condition")) {
[10:22:29.803]                         if (!is.null(pattern)) {
[10:22:29.803]                           computeRestarts <- base::computeRestarts
[10:22:29.803]                           grepl <- base::grepl
[10:22:29.803]                           restarts <- computeRestarts(cond)
[10:22:29.803]                           for (restart in restarts) {
[10:22:29.803]                             name <- restart$name
[10:22:29.803]                             if (is.null(name)) 
[10:22:29.803]                               next
[10:22:29.803]                             if (!grepl(pattern, name)) 
[10:22:29.803]                               next
[10:22:29.803]                             invokeRestart(restart)
[10:22:29.803]                             muffled <- TRUE
[10:22:29.803]                             break
[10:22:29.803]                           }
[10:22:29.803]                         }
[10:22:29.803]                       }
[10:22:29.803]                       invisible(muffled)
[10:22:29.803]                     }
[10:22:29.803]                     muffleCondition(cond, pattern = "^muffle")
[10:22:29.803]                   }
[10:22:29.803]                 }
[10:22:29.803]                 else {
[10:22:29.803]                   if (TRUE) {
[10:22:29.803]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.803]                     {
[10:22:29.803]                       inherits <- base::inherits
[10:22:29.803]                       invokeRestart <- base::invokeRestart
[10:22:29.803]                       is.null <- base::is.null
[10:22:29.803]                       muffled <- FALSE
[10:22:29.803]                       if (inherits(cond, "message")) {
[10:22:29.803]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:29.803]                         if (muffled) 
[10:22:29.803]                           invokeRestart("muffleMessage")
[10:22:29.803]                       }
[10:22:29.803]                       else if (inherits(cond, "warning")) {
[10:22:29.803]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:29.803]                         if (muffled) 
[10:22:29.803]                           invokeRestart("muffleWarning")
[10:22:29.803]                       }
[10:22:29.803]                       else if (inherits(cond, "condition")) {
[10:22:29.803]                         if (!is.null(pattern)) {
[10:22:29.803]                           computeRestarts <- base::computeRestarts
[10:22:29.803]                           grepl <- base::grepl
[10:22:29.803]                           restarts <- computeRestarts(cond)
[10:22:29.803]                           for (restart in restarts) {
[10:22:29.803]                             name <- restart$name
[10:22:29.803]                             if (is.null(name)) 
[10:22:29.803]                               next
[10:22:29.803]                             if (!grepl(pattern, name)) 
[10:22:29.803]                               next
[10:22:29.803]                             invokeRestart(restart)
[10:22:29.803]                             muffled <- TRUE
[10:22:29.803]                             break
[10:22:29.803]                           }
[10:22:29.803]                         }
[10:22:29.803]                       }
[10:22:29.803]                       invisible(muffled)
[10:22:29.803]                     }
[10:22:29.803]                     muffleCondition(cond, pattern = "^muffle")
[10:22:29.803]                   }
[10:22:29.803]                 }
[10:22:29.803]             }
[10:22:29.803]         }))
[10:22:29.803]     }, error = function(ex) {
[10:22:29.803]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:29.803]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:29.803]                 ...future.rng), started = ...future.startTime, 
[10:22:29.803]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:29.803]             version = "1.8"), class = "FutureResult")
[10:22:29.803]     }, finally = {
[10:22:29.803]         if (!identical(...future.workdir, getwd())) 
[10:22:29.803]             setwd(...future.workdir)
[10:22:29.803]         {
[10:22:29.803]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:29.803]                 ...future.oldOptions$nwarnings <- NULL
[10:22:29.803]             }
[10:22:29.803]             base::options(...future.oldOptions)
[10:22:29.803]             if (.Platform$OS.type == "windows") {
[10:22:29.803]                 old_names <- names(...future.oldEnvVars)
[10:22:29.803]                 envs <- base::Sys.getenv()
[10:22:29.803]                 names <- names(envs)
[10:22:29.803]                 common <- intersect(names, old_names)
[10:22:29.803]                 added <- setdiff(names, old_names)
[10:22:29.803]                 removed <- setdiff(old_names, names)
[10:22:29.803]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:29.803]                   envs[common]]
[10:22:29.803]                 NAMES <- toupper(changed)
[10:22:29.803]                 args <- list()
[10:22:29.803]                 for (kk in seq_along(NAMES)) {
[10:22:29.803]                   name <- changed[[kk]]
[10:22:29.803]                   NAME <- NAMES[[kk]]
[10:22:29.803]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.803]                     next
[10:22:29.803]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:29.803]                 }
[10:22:29.803]                 NAMES <- toupper(added)
[10:22:29.803]                 for (kk in seq_along(NAMES)) {
[10:22:29.803]                   name <- added[[kk]]
[10:22:29.803]                   NAME <- NAMES[[kk]]
[10:22:29.803]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.803]                     next
[10:22:29.803]                   args[[name]] <- ""
[10:22:29.803]                 }
[10:22:29.803]                 NAMES <- toupper(removed)
[10:22:29.803]                 for (kk in seq_along(NAMES)) {
[10:22:29.803]                   name <- removed[[kk]]
[10:22:29.803]                   NAME <- NAMES[[kk]]
[10:22:29.803]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.803]                     next
[10:22:29.803]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:29.803]                 }
[10:22:29.803]                 if (length(args) > 0) 
[10:22:29.803]                   base::do.call(base::Sys.setenv, args = args)
[10:22:29.803]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:29.803]             }
[10:22:29.803]             else {
[10:22:29.803]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:29.803]             }
[10:22:29.803]             {
[10:22:29.803]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:29.803]                   0L) {
[10:22:29.803]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:29.803]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:29.803]                   base::options(opts)
[10:22:29.803]                 }
[10:22:29.803]                 {
[10:22:29.803]                   {
[10:22:29.803]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:29.803]                     NULL
[10:22:29.803]                   }
[10:22:29.803]                   options(future.plan = NULL)
[10:22:29.803]                   if (is.na(NA_character_)) 
[10:22:29.803]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:29.803]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:29.803]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:29.803]                     .init = FALSE)
[10:22:29.803]                 }
[10:22:29.803]             }
[10:22:29.803]         }
[10:22:29.803]     })
[10:22:29.803]     if (TRUE) {
[10:22:29.803]         base::sink(type = "output", split = FALSE)
[10:22:29.803]         if (TRUE) {
[10:22:29.803]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:29.803]         }
[10:22:29.803]         else {
[10:22:29.803]             ...future.result["stdout"] <- base::list(NULL)
[10:22:29.803]         }
[10:22:29.803]         base::close(...future.stdout)
[10:22:29.803]         ...future.stdout <- NULL
[10:22:29.803]     }
[10:22:29.803]     ...future.result$conditions <- ...future.conditions
[10:22:29.803]     ...future.result$finished <- base::Sys.time()
[10:22:29.803]     ...future.result
[10:22:29.803] }
[10:22:29.806] requestCore(): workers = 2
[10:22:29.809] MulticoreFuture started
[10:22:29.809] - Launch lazy future ... done
[10:22:29.809] plan(): Setting new future strategy stack:
[10:22:29.809] run() for ‘MulticoreFuture’ ... done
[10:22:29.810] getGlobalsAndPackages() ...
[10:22:29.810] Searching for globals...
[10:22:29.810] List of future strategies:
[10:22:29.810] 1. sequential:
[10:22:29.810]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:29.810]    - tweaked: FALSE
[10:22:29.810]    - call: NULL
[10:22:29.811] plan(): nbrOfWorkers() = 1
[10:22:29.811] 
[10:22:29.811] Searching for globals ... DONE
[10:22:29.812] - globals: [0] <none>
[10:22:29.812] getGlobalsAndPackages() ... DONE
[10:22:29.812] run() for ‘Future’ ...
[10:22:29.813] - state: ‘created’
[10:22:29.813] plan(): Setting new future strategy stack:
[10:22:29.813] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:29.813] List of future strategies:
[10:22:29.813] 1. multicore:
[10:22:29.813]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:29.813]    - tweaked: FALSE
[10:22:29.813]    - call: plan(strategy)
[10:22:29.816] plan(): nbrOfWorkers() = 2
[10:22:29.816] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:29.816] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:29.817]   - Field: ‘label’
[10:22:29.817]   - Field: ‘local’
[10:22:29.817]   - Field: ‘owner’
[10:22:29.817]   - Field: ‘envir’
[10:22:29.817]   - Field: ‘workers’
[10:22:29.818]   - Field: ‘packages’
[10:22:29.818]   - Field: ‘gc’
[10:22:29.818]   - Field: ‘job’
[10:22:29.818]   - Field: ‘conditions’
[10:22:29.818]   - Field: ‘expr’
[10:22:29.818]   - Field: ‘uuid’
[10:22:29.819]   - Field: ‘seed’
[10:22:29.819]   - Field: ‘version’
[10:22:29.819]   - Field: ‘result’
[10:22:29.819]   - Field: ‘asynchronous’
[10:22:29.819]   - Field: ‘calls’
[10:22:29.820]   - Field: ‘globals’
[10:22:29.820]   - Field: ‘stdout’
[10:22:29.820]   - Field: ‘earlySignal’
[10:22:29.820]   - Field: ‘lazy’
[10:22:29.820]   - Field: ‘state’
[10:22:29.820] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:29.821] - Launch lazy future ...
[10:22:29.821] Packages needed by the future expression (n = 0): <none>
[10:22:29.821] Packages needed by future strategies (n = 0): <none>
[10:22:29.822] {
[10:22:29.822]     {
[10:22:29.822]         {
[10:22:29.822]             ...future.startTime <- base::Sys.time()
[10:22:29.822]             {
[10:22:29.822]                 {
[10:22:29.822]                   {
[10:22:29.822]                     {
[10:22:29.822]                       base::local({
[10:22:29.822]                         has_future <- base::requireNamespace("future", 
[10:22:29.822]                           quietly = TRUE)
[10:22:29.822]                         if (has_future) {
[10:22:29.822]                           ns <- base::getNamespace("future")
[10:22:29.822]                           version <- ns[[".package"]][["version"]]
[10:22:29.822]                           if (is.null(version)) 
[10:22:29.822]                             version <- utils::packageVersion("future")
[10:22:29.822]                         }
[10:22:29.822]                         else {
[10:22:29.822]                           version <- NULL
[10:22:29.822]                         }
[10:22:29.822]                         if (!has_future || version < "1.8.0") {
[10:22:29.822]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:29.822]                             "", base::R.version$version.string), 
[10:22:29.822]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:29.822]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:29.822]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:29.822]                               "release", "version")], collapse = " "), 
[10:22:29.822]                             hostname = base::Sys.info()[["nodename"]])
[10:22:29.822]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:29.822]                             info)
[10:22:29.822]                           info <- base::paste(info, collapse = "; ")
[10:22:29.822]                           if (!has_future) {
[10:22:29.822]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:29.822]                               info)
[10:22:29.822]                           }
[10:22:29.822]                           else {
[10:22:29.822]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:29.822]                               info, version)
[10:22:29.822]                           }
[10:22:29.822]                           base::stop(msg)
[10:22:29.822]                         }
[10:22:29.822]                       })
[10:22:29.822]                     }
[10:22:29.822]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:29.822]                     base::options(mc.cores = 1L)
[10:22:29.822]                   }
[10:22:29.822]                   ...future.strategy.old <- future::plan("list")
[10:22:29.822]                   options(future.plan = NULL)
[10:22:29.822]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:29.822]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:29.822]                 }
[10:22:29.822]                 ...future.workdir <- getwd()
[10:22:29.822]             }
[10:22:29.822]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:29.822]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:29.822]         }
[10:22:29.822]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:29.822]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:29.822]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:29.822]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:29.822]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:29.822]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:29.822]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:29.822]             base::names(...future.oldOptions))
[10:22:29.822]     }
[10:22:29.822]     if (FALSE) {
[10:22:29.822]     }
[10:22:29.822]     else {
[10:22:29.822]         if (TRUE) {
[10:22:29.822]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:29.822]                 open = "w")
[10:22:29.822]         }
[10:22:29.822]         else {
[10:22:29.822]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:29.822]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:29.822]         }
[10:22:29.822]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:29.822]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:29.822]             base::sink(type = "output", split = FALSE)
[10:22:29.822]             base::close(...future.stdout)
[10:22:29.822]         }, add = TRUE)
[10:22:29.822]     }
[10:22:29.822]     ...future.frame <- base::sys.nframe()
[10:22:29.822]     ...future.conditions <- base::list()
[10:22:29.822]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:29.822]     if (FALSE) {
[10:22:29.822]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:29.822]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:29.822]     }
[10:22:29.822]     ...future.result <- base::tryCatch({
[10:22:29.822]         base::withCallingHandlers({
[10:22:29.822]             ...future.value <- base::withVisible(base::local({
[10:22:29.822]                 withCallingHandlers({
[10:22:29.822]                   2
[10:22:29.822]                 }, immediateCondition = function(cond) {
[10:22:29.822]                   save_rds <- function (object, pathname, ...) 
[10:22:29.822]                   {
[10:22:29.822]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:29.822]                     if (file_test("-f", pathname_tmp)) {
[10:22:29.822]                       fi_tmp <- file.info(pathname_tmp)
[10:22:29.822]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:29.822]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:29.822]                         fi_tmp[["mtime"]])
[10:22:29.822]                     }
[10:22:29.822]                     tryCatch({
[10:22:29.822]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:29.822]                     }, error = function(ex) {
[10:22:29.822]                       msg <- conditionMessage(ex)
[10:22:29.822]                       fi_tmp <- file.info(pathname_tmp)
[10:22:29.822]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:29.822]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:29.822]                         fi_tmp[["mtime"]], msg)
[10:22:29.822]                       ex$message <- msg
[10:22:29.822]                       stop(ex)
[10:22:29.822]                     })
[10:22:29.822]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:29.822]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:29.822]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:29.822]                       fi_tmp <- file.info(pathname_tmp)
[10:22:29.822]                       fi <- file.info(pathname)
[10:22:29.822]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:29.822]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:29.822]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:29.822]                         fi[["size"]], fi[["mtime"]])
[10:22:29.822]                       stop(msg)
[10:22:29.822]                     }
[10:22:29.822]                     invisible(pathname)
[10:22:29.822]                   }
[10:22:29.822]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:29.822]                     rootPath = tempdir()) 
[10:22:29.822]                   {
[10:22:29.822]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:29.822]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:29.822]                       tmpdir = path, fileext = ".rds")
[10:22:29.822]                     save_rds(obj, file)
[10:22:29.822]                   }
[10:22:29.822]                   saveImmediateCondition(cond, path = "/tmp/RtmpzsJv4f/.future/immediateConditions")
[10:22:29.822]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.822]                   {
[10:22:29.822]                     inherits <- base::inherits
[10:22:29.822]                     invokeRestart <- base::invokeRestart
[10:22:29.822]                     is.null <- base::is.null
[10:22:29.822]                     muffled <- FALSE
[10:22:29.822]                     if (inherits(cond, "message")) {
[10:22:29.822]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:29.822]                       if (muffled) 
[10:22:29.822]                         invokeRestart("muffleMessage")
[10:22:29.822]                     }
[10:22:29.822]                     else if (inherits(cond, "warning")) {
[10:22:29.822]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:29.822]                       if (muffled) 
[10:22:29.822]                         invokeRestart("muffleWarning")
[10:22:29.822]                     }
[10:22:29.822]                     else if (inherits(cond, "condition")) {
[10:22:29.822]                       if (!is.null(pattern)) {
[10:22:29.822]                         computeRestarts <- base::computeRestarts
[10:22:29.822]                         grepl <- base::grepl
[10:22:29.822]                         restarts <- computeRestarts(cond)
[10:22:29.822]                         for (restart in restarts) {
[10:22:29.822]                           name <- restart$name
[10:22:29.822]                           if (is.null(name)) 
[10:22:29.822]                             next
[10:22:29.822]                           if (!grepl(pattern, name)) 
[10:22:29.822]                             next
[10:22:29.822]                           invokeRestart(restart)
[10:22:29.822]                           muffled <- TRUE
[10:22:29.822]                           break
[10:22:29.822]                         }
[10:22:29.822]                       }
[10:22:29.822]                     }
[10:22:29.822]                     invisible(muffled)
[10:22:29.822]                   }
[10:22:29.822]                   muffleCondition(cond)
[10:22:29.822]                 })
[10:22:29.822]             }))
[10:22:29.822]             future::FutureResult(value = ...future.value$value, 
[10:22:29.822]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:29.822]                   ...future.rng), globalenv = if (FALSE) 
[10:22:29.822]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:29.822]                     ...future.globalenv.names))
[10:22:29.822]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:29.822]         }, condition = base::local({
[10:22:29.822]             c <- base::c
[10:22:29.822]             inherits <- base::inherits
[10:22:29.822]             invokeRestart <- base::invokeRestart
[10:22:29.822]             length <- base::length
[10:22:29.822]             list <- base::list
[10:22:29.822]             seq.int <- base::seq.int
[10:22:29.822]             signalCondition <- base::signalCondition
[10:22:29.822]             sys.calls <- base::sys.calls
[10:22:29.822]             `[[` <- base::`[[`
[10:22:29.822]             `+` <- base::`+`
[10:22:29.822]             `<<-` <- base::`<<-`
[10:22:29.822]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:29.822]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:29.822]                   3L)]
[10:22:29.822]             }
[10:22:29.822]             function(cond) {
[10:22:29.822]                 is_error <- inherits(cond, "error")
[10:22:29.822]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:29.822]                   NULL)
[10:22:29.822]                 if (is_error) {
[10:22:29.822]                   sessionInformation <- function() {
[10:22:29.822]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:29.822]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:29.822]                       search = base::search(), system = base::Sys.info())
[10:22:29.822]                   }
[10:22:29.822]                   ...future.conditions[[length(...future.conditions) + 
[10:22:29.822]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:29.822]                     cond$call), session = sessionInformation(), 
[10:22:29.822]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:29.822]                   signalCondition(cond)
[10:22:29.822]                 }
[10:22:29.822]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:29.822]                 "immediateCondition"))) {
[10:22:29.822]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:29.822]                   ...future.conditions[[length(...future.conditions) + 
[10:22:29.822]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:29.822]                   if (TRUE && !signal) {
[10:22:29.822]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.822]                     {
[10:22:29.822]                       inherits <- base::inherits
[10:22:29.822]                       invokeRestart <- base::invokeRestart
[10:22:29.822]                       is.null <- base::is.null
[10:22:29.822]                       muffled <- FALSE
[10:22:29.822]                       if (inherits(cond, "message")) {
[10:22:29.822]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:29.822]                         if (muffled) 
[10:22:29.822]                           invokeRestart("muffleMessage")
[10:22:29.822]                       }
[10:22:29.822]                       else if (inherits(cond, "warning")) {
[10:22:29.822]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:29.822]                         if (muffled) 
[10:22:29.822]                           invokeRestart("muffleWarning")
[10:22:29.822]                       }
[10:22:29.822]                       else if (inherits(cond, "condition")) {
[10:22:29.822]                         if (!is.null(pattern)) {
[10:22:29.822]                           computeRestarts <- base::computeRestarts
[10:22:29.822]                           grepl <- base::grepl
[10:22:29.822]                           restarts <- computeRestarts(cond)
[10:22:29.822]                           for (restart in restarts) {
[10:22:29.822]                             name <- restart$name
[10:22:29.822]                             if (is.null(name)) 
[10:22:29.822]                               next
[10:22:29.822]                             if (!grepl(pattern, name)) 
[10:22:29.822]                               next
[10:22:29.822]                             invokeRestart(restart)
[10:22:29.822]                             muffled <- TRUE
[10:22:29.822]                             break
[10:22:29.822]                           }
[10:22:29.822]                         }
[10:22:29.822]                       }
[10:22:29.822]                       invisible(muffled)
[10:22:29.822]                     }
[10:22:29.822]                     muffleCondition(cond, pattern = "^muffle")
[10:22:29.822]                   }
[10:22:29.822]                 }
[10:22:29.822]                 else {
[10:22:29.822]                   if (TRUE) {
[10:22:29.822]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.822]                     {
[10:22:29.822]                       inherits <- base::inherits
[10:22:29.822]                       invokeRestart <- base::invokeRestart
[10:22:29.822]                       is.null <- base::is.null
[10:22:29.822]                       muffled <- FALSE
[10:22:29.822]                       if (inherits(cond, "message")) {
[10:22:29.822]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:29.822]                         if (muffled) 
[10:22:29.822]                           invokeRestart("muffleMessage")
[10:22:29.822]                       }
[10:22:29.822]                       else if (inherits(cond, "warning")) {
[10:22:29.822]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:29.822]                         if (muffled) 
[10:22:29.822]                           invokeRestart("muffleWarning")
[10:22:29.822]                       }
[10:22:29.822]                       else if (inherits(cond, "condition")) {
[10:22:29.822]                         if (!is.null(pattern)) {
[10:22:29.822]                           computeRestarts <- base::computeRestarts
[10:22:29.822]                           grepl <- base::grepl
[10:22:29.822]                           restarts <- computeRestarts(cond)
[10:22:29.822]                           for (restart in restarts) {
[10:22:29.822]                             name <- restart$name
[10:22:29.822]                             if (is.null(name)) 
[10:22:29.822]                               next
[10:22:29.822]                             if (!grepl(pattern, name)) 
[10:22:29.822]                               next
[10:22:29.822]                             invokeRestart(restart)
[10:22:29.822]                             muffled <- TRUE
[10:22:29.822]                             break
[10:22:29.822]                           }
[10:22:29.822]                         }
[10:22:29.822]                       }
[10:22:29.822]                       invisible(muffled)
[10:22:29.822]                     }
[10:22:29.822]                     muffleCondition(cond, pattern = "^muffle")
[10:22:29.822]                   }
[10:22:29.822]                 }
[10:22:29.822]             }
[10:22:29.822]         }))
[10:22:29.822]     }, error = function(ex) {
[10:22:29.822]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:29.822]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:29.822]                 ...future.rng), started = ...future.startTime, 
[10:22:29.822]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:29.822]             version = "1.8"), class = "FutureResult")
[10:22:29.822]     }, finally = {
[10:22:29.822]         if (!identical(...future.workdir, getwd())) 
[10:22:29.822]             setwd(...future.workdir)
[10:22:29.822]         {
[10:22:29.822]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:29.822]                 ...future.oldOptions$nwarnings <- NULL
[10:22:29.822]             }
[10:22:29.822]             base::options(...future.oldOptions)
[10:22:29.822]             if (.Platform$OS.type == "windows") {
[10:22:29.822]                 old_names <- names(...future.oldEnvVars)
[10:22:29.822]                 envs <- base::Sys.getenv()
[10:22:29.822]                 names <- names(envs)
[10:22:29.822]                 common <- intersect(names, old_names)
[10:22:29.822]                 added <- setdiff(names, old_names)
[10:22:29.822]                 removed <- setdiff(old_names, names)
[10:22:29.822]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:29.822]                   envs[common]]
[10:22:29.822]                 NAMES <- toupper(changed)
[10:22:29.822]                 args <- list()
[10:22:29.822]                 for (kk in seq_along(NAMES)) {
[10:22:29.822]                   name <- changed[[kk]]
[10:22:29.822]                   NAME <- NAMES[[kk]]
[10:22:29.822]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.822]                     next
[10:22:29.822]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:29.822]                 }
[10:22:29.822]                 NAMES <- toupper(added)
[10:22:29.822]                 for (kk in seq_along(NAMES)) {
[10:22:29.822]                   name <- added[[kk]]
[10:22:29.822]                   NAME <- NAMES[[kk]]
[10:22:29.822]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.822]                     next
[10:22:29.822]                   args[[name]] <- ""
[10:22:29.822]                 }
[10:22:29.822]                 NAMES <- toupper(removed)
[10:22:29.822]                 for (kk in seq_along(NAMES)) {
[10:22:29.822]                   name <- removed[[kk]]
[10:22:29.822]                   NAME <- NAMES[[kk]]
[10:22:29.822]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.822]                     next
[10:22:29.822]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:29.822]                 }
[10:22:29.822]                 if (length(args) > 0) 
[10:22:29.822]                   base::do.call(base::Sys.setenv, args = args)
[10:22:29.822]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:29.822]             }
[10:22:29.822]             else {
[10:22:29.822]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:29.822]             }
[10:22:29.822]             {
[10:22:29.822]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:29.822]                   0L) {
[10:22:29.822]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:29.822]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:29.822]                   base::options(opts)
[10:22:29.822]                 }
[10:22:29.822]                 {
[10:22:29.822]                   {
[10:22:29.822]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:29.822]                     NULL
[10:22:29.822]                   }
[10:22:29.822]                   options(future.plan = NULL)
[10:22:29.822]                   if (is.na(NA_character_)) 
[10:22:29.822]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:29.822]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:29.822]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:29.822]                     .init = FALSE)
[10:22:29.822]                 }
[10:22:29.822]             }
[10:22:29.822]         }
[10:22:29.822]     })
[10:22:29.822]     if (TRUE) {
[10:22:29.822]         base::sink(type = "output", split = FALSE)
[10:22:29.822]         if (TRUE) {
[10:22:29.822]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:29.822]         }
[10:22:29.822]         else {
[10:22:29.822]             ...future.result["stdout"] <- base::list(NULL)
[10:22:29.822]         }
[10:22:29.822]         base::close(...future.stdout)
[10:22:29.822]         ...future.stdout <- NULL
[10:22:29.822]     }
[10:22:29.822]     ...future.result$conditions <- ...future.conditions
[10:22:29.822]     ...future.result$finished <- base::Sys.time()
[10:22:29.822]     ...future.result
[10:22:29.822] }
[10:22:29.826] requestCore(): workers = 2
[10:22:29.834] MulticoreFuture started
[10:22:29.835] - Launch lazy future ... done
[10:22:29.835] run() for ‘MulticoreFuture’ ... done
[10:22:29.835] plan(): Setting new future strategy stack:
[10:22:29.835] resolve() on list ...
[10:22:29.835]  recursive: 0
[10:22:29.836]  length: 3
[10:22:29.836]  elements: ‘a’, ‘b’, ‘’
[10:22:29.835] List of future strategies:
[10:22:29.835] 1. sequential:
[10:22:29.835]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:29.835]    - tweaked: FALSE
[10:22:29.835]    - call: NULL
[10:22:29.836] plan(): nbrOfWorkers() = 1
[10:22:29.838] Future #1
[10:22:29.839] plan(): Setting new future strategy stack:
[10:22:29.839]  length: 2 (resolved future 1)
[10:22:29.839] List of future strategies:
[10:22:29.839] 1. multicore:
[10:22:29.839]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:29.839]    - tweaked: FALSE
[10:22:29.839]    - call: plan(strategy)
[10:22:29.842] plan(): nbrOfWorkers() = 2
[10:22:29.842] Future #2
[10:22:29.842]  length: 1 (resolved future 2)
[10:22:29.843]  length: 0 (resolved future 3)
[10:22:29.843] resolve() on list ... DONE
[10:22:29.843] getGlobalsAndPackages() ...
[10:22:29.844] Searching for globals...
[10:22:29.844] 
[10:22:29.845] Searching for globals ... DONE
[10:22:29.845] - globals: [0] <none>
[10:22:29.845] getGlobalsAndPackages() ... DONE
[10:22:29.845] getGlobalsAndPackages() ...
[10:22:29.846] Searching for globals...
[10:22:29.846] 
[10:22:29.846] Searching for globals ... DONE
[10:22:29.847] - globals: [0] <none>
[10:22:29.847] getGlobalsAndPackages() ... DONE
[10:22:29.847] run() for ‘Future’ ...
[10:22:29.847] - state: ‘created’
[10:22:29.847] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:29.850] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:29.851] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:29.851]   - Field: ‘label’
[10:22:29.851]   - Field: ‘local’
[10:22:29.851]   - Field: ‘owner’
[10:22:29.851]   - Field: ‘envir’
[10:22:29.852]   - Field: ‘workers’
[10:22:29.852]   - Field: ‘packages’
[10:22:29.852]   - Field: ‘gc’
[10:22:29.852]   - Field: ‘job’
[10:22:29.852]   - Field: ‘conditions’
[10:22:29.852]   - Field: ‘expr’
[10:22:29.853]   - Field: ‘uuid’
[10:22:29.853]   - Field: ‘seed’
[10:22:29.853]   - Field: ‘version’
[10:22:29.853]   - Field: ‘result’
[10:22:29.853]   - Field: ‘asynchronous’
[10:22:29.853]   - Field: ‘calls’
[10:22:29.854]   - Field: ‘globals’
[10:22:29.854]   - Field: ‘stdout’
[10:22:29.854]   - Field: ‘earlySignal’
[10:22:29.854]   - Field: ‘lazy’
[10:22:29.854]   - Field: ‘state’
[10:22:29.854] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:29.855] - Launch lazy future ...
[10:22:29.855] Packages needed by the future expression (n = 0): <none>
[10:22:29.855] Packages needed by future strategies (n = 0): <none>
[10:22:29.862] {
[10:22:29.862]     {
[10:22:29.862]         {
[10:22:29.862]             ...future.startTime <- base::Sys.time()
[10:22:29.862]             {
[10:22:29.862]                 {
[10:22:29.862]                   {
[10:22:29.862]                     {
[10:22:29.862]                       base::local({
[10:22:29.862]                         has_future <- base::requireNamespace("future", 
[10:22:29.862]                           quietly = TRUE)
[10:22:29.862]                         if (has_future) {
[10:22:29.862]                           ns <- base::getNamespace("future")
[10:22:29.862]                           version <- ns[[".package"]][["version"]]
[10:22:29.862]                           if (is.null(version)) 
[10:22:29.862]                             version <- utils::packageVersion("future")
[10:22:29.862]                         }
[10:22:29.862]                         else {
[10:22:29.862]                           version <- NULL
[10:22:29.862]                         }
[10:22:29.862]                         if (!has_future || version < "1.8.0") {
[10:22:29.862]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:29.862]                             "", base::R.version$version.string), 
[10:22:29.862]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:29.862]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:29.862]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:29.862]                               "release", "version")], collapse = " "), 
[10:22:29.862]                             hostname = base::Sys.info()[["nodename"]])
[10:22:29.862]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:29.862]                             info)
[10:22:29.862]                           info <- base::paste(info, collapse = "; ")
[10:22:29.862]                           if (!has_future) {
[10:22:29.862]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:29.862]                               info)
[10:22:29.862]                           }
[10:22:29.862]                           else {
[10:22:29.862]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:29.862]                               info, version)
[10:22:29.862]                           }
[10:22:29.862]                           base::stop(msg)
[10:22:29.862]                         }
[10:22:29.862]                       })
[10:22:29.862]                     }
[10:22:29.862]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:29.862]                     base::options(mc.cores = 1L)
[10:22:29.862]                   }
[10:22:29.862]                   ...future.strategy.old <- future::plan("list")
[10:22:29.862]                   options(future.plan = NULL)
[10:22:29.862]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:29.862]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:29.862]                 }
[10:22:29.862]                 ...future.workdir <- getwd()
[10:22:29.862]             }
[10:22:29.862]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:29.862]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:29.862]         }
[10:22:29.862]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:29.862]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:29.862]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:29.862]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:29.862]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:29.862]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:29.862]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:29.862]             base::names(...future.oldOptions))
[10:22:29.862]     }
[10:22:29.862]     if (FALSE) {
[10:22:29.862]     }
[10:22:29.862]     else {
[10:22:29.862]         if (TRUE) {
[10:22:29.862]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:29.862]                 open = "w")
[10:22:29.862]         }
[10:22:29.862]         else {
[10:22:29.862]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:29.862]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:29.862]         }
[10:22:29.862]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:29.862]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:29.862]             base::sink(type = "output", split = FALSE)
[10:22:29.862]             base::close(...future.stdout)
[10:22:29.862]         }, add = TRUE)
[10:22:29.862]     }
[10:22:29.862]     ...future.frame <- base::sys.nframe()
[10:22:29.862]     ...future.conditions <- base::list()
[10:22:29.862]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:29.862]     if (FALSE) {
[10:22:29.862]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:29.862]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:29.862]     }
[10:22:29.862]     ...future.result <- base::tryCatch({
[10:22:29.862]         base::withCallingHandlers({
[10:22:29.862]             ...future.value <- base::withVisible(base::local({
[10:22:29.862]                 withCallingHandlers({
[10:22:29.862]                   2
[10:22:29.862]                 }, immediateCondition = function(cond) {
[10:22:29.862]                   save_rds <- function (object, pathname, ...) 
[10:22:29.862]                   {
[10:22:29.862]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:29.862]                     if (file_test("-f", pathname_tmp)) {
[10:22:29.862]                       fi_tmp <- file.info(pathname_tmp)
[10:22:29.862]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:29.862]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:29.862]                         fi_tmp[["mtime"]])
[10:22:29.862]                     }
[10:22:29.862]                     tryCatch({
[10:22:29.862]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:29.862]                     }, error = function(ex) {
[10:22:29.862]                       msg <- conditionMessage(ex)
[10:22:29.862]                       fi_tmp <- file.info(pathname_tmp)
[10:22:29.862]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:29.862]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:29.862]                         fi_tmp[["mtime"]], msg)
[10:22:29.862]                       ex$message <- msg
[10:22:29.862]                       stop(ex)
[10:22:29.862]                     })
[10:22:29.862]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:29.862]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:29.862]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:29.862]                       fi_tmp <- file.info(pathname_tmp)
[10:22:29.862]                       fi <- file.info(pathname)
[10:22:29.862]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:29.862]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:29.862]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:29.862]                         fi[["size"]], fi[["mtime"]])
[10:22:29.862]                       stop(msg)
[10:22:29.862]                     }
[10:22:29.862]                     invisible(pathname)
[10:22:29.862]                   }
[10:22:29.862]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:29.862]                     rootPath = tempdir()) 
[10:22:29.862]                   {
[10:22:29.862]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:29.862]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:29.862]                       tmpdir = path, fileext = ".rds")
[10:22:29.862]                     save_rds(obj, file)
[10:22:29.862]                   }
[10:22:29.862]                   saveImmediateCondition(cond, path = "/tmp/RtmpzsJv4f/.future/immediateConditions")
[10:22:29.862]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.862]                   {
[10:22:29.862]                     inherits <- base::inherits
[10:22:29.862]                     invokeRestart <- base::invokeRestart
[10:22:29.862]                     is.null <- base::is.null
[10:22:29.862]                     muffled <- FALSE
[10:22:29.862]                     if (inherits(cond, "message")) {
[10:22:29.862]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:29.862]                       if (muffled) 
[10:22:29.862]                         invokeRestart("muffleMessage")
[10:22:29.862]                     }
[10:22:29.862]                     else if (inherits(cond, "warning")) {
[10:22:29.862]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:29.862]                       if (muffled) 
[10:22:29.862]                         invokeRestart("muffleWarning")
[10:22:29.862]                     }
[10:22:29.862]                     else if (inherits(cond, "condition")) {
[10:22:29.862]                       if (!is.null(pattern)) {
[10:22:29.862]                         computeRestarts <- base::computeRestarts
[10:22:29.862]                         grepl <- base::grepl
[10:22:29.862]                         restarts <- computeRestarts(cond)
[10:22:29.862]                         for (restart in restarts) {
[10:22:29.862]                           name <- restart$name
[10:22:29.862]                           if (is.null(name)) 
[10:22:29.862]                             next
[10:22:29.862]                           if (!grepl(pattern, name)) 
[10:22:29.862]                             next
[10:22:29.862]                           invokeRestart(restart)
[10:22:29.862]                           muffled <- TRUE
[10:22:29.862]                           break
[10:22:29.862]                         }
[10:22:29.862]                       }
[10:22:29.862]                     }
[10:22:29.862]                     invisible(muffled)
[10:22:29.862]                   }
[10:22:29.862]                   muffleCondition(cond)
[10:22:29.862]                 })
[10:22:29.862]             }))
[10:22:29.862]             future::FutureResult(value = ...future.value$value, 
[10:22:29.862]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:29.862]                   ...future.rng), globalenv = if (FALSE) 
[10:22:29.862]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:29.862]                     ...future.globalenv.names))
[10:22:29.862]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:29.862]         }, condition = base::local({
[10:22:29.862]             c <- base::c
[10:22:29.862]             inherits <- base::inherits
[10:22:29.862]             invokeRestart <- base::invokeRestart
[10:22:29.862]             length <- base::length
[10:22:29.862]             list <- base::list
[10:22:29.862]             seq.int <- base::seq.int
[10:22:29.862]             signalCondition <- base::signalCondition
[10:22:29.862]             sys.calls <- base::sys.calls
[10:22:29.862]             `[[` <- base::`[[`
[10:22:29.862]             `+` <- base::`+`
[10:22:29.862]             `<<-` <- base::`<<-`
[10:22:29.862]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:29.862]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:29.862]                   3L)]
[10:22:29.862]             }
[10:22:29.862]             function(cond) {
[10:22:29.862]                 is_error <- inherits(cond, "error")
[10:22:29.862]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:29.862]                   NULL)
[10:22:29.862]                 if (is_error) {
[10:22:29.862]                   sessionInformation <- function() {
[10:22:29.862]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:29.862]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:29.862]                       search = base::search(), system = base::Sys.info())
[10:22:29.862]                   }
[10:22:29.862]                   ...future.conditions[[length(...future.conditions) + 
[10:22:29.862]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:29.862]                     cond$call), session = sessionInformation(), 
[10:22:29.862]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:29.862]                   signalCondition(cond)
[10:22:29.862]                 }
[10:22:29.862]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:29.862]                 "immediateCondition"))) {
[10:22:29.862]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:29.862]                   ...future.conditions[[length(...future.conditions) + 
[10:22:29.862]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:29.862]                   if (TRUE && !signal) {
[10:22:29.862]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.862]                     {
[10:22:29.862]                       inherits <- base::inherits
[10:22:29.862]                       invokeRestart <- base::invokeRestart
[10:22:29.862]                       is.null <- base::is.null
[10:22:29.862]                       muffled <- FALSE
[10:22:29.862]                       if (inherits(cond, "message")) {
[10:22:29.862]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:29.862]                         if (muffled) 
[10:22:29.862]                           invokeRestart("muffleMessage")
[10:22:29.862]                       }
[10:22:29.862]                       else if (inherits(cond, "warning")) {
[10:22:29.862]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:29.862]                         if (muffled) 
[10:22:29.862]                           invokeRestart("muffleWarning")
[10:22:29.862]                       }
[10:22:29.862]                       else if (inherits(cond, "condition")) {
[10:22:29.862]                         if (!is.null(pattern)) {
[10:22:29.862]                           computeRestarts <- base::computeRestarts
[10:22:29.862]                           grepl <- base::grepl
[10:22:29.862]                           restarts <- computeRestarts(cond)
[10:22:29.862]                           for (restart in restarts) {
[10:22:29.862]                             name <- restart$name
[10:22:29.862]                             if (is.null(name)) 
[10:22:29.862]                               next
[10:22:29.862]                             if (!grepl(pattern, name)) 
[10:22:29.862]                               next
[10:22:29.862]                             invokeRestart(restart)
[10:22:29.862]                             muffled <- TRUE
[10:22:29.862]                             break
[10:22:29.862]                           }
[10:22:29.862]                         }
[10:22:29.862]                       }
[10:22:29.862]                       invisible(muffled)
[10:22:29.862]                     }
[10:22:29.862]                     muffleCondition(cond, pattern = "^muffle")
[10:22:29.862]                   }
[10:22:29.862]                 }
[10:22:29.862]                 else {
[10:22:29.862]                   if (TRUE) {
[10:22:29.862]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.862]                     {
[10:22:29.862]                       inherits <- base::inherits
[10:22:29.862]                       invokeRestart <- base::invokeRestart
[10:22:29.862]                       is.null <- base::is.null
[10:22:29.862]                       muffled <- FALSE
[10:22:29.862]                       if (inherits(cond, "message")) {
[10:22:29.862]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:29.862]                         if (muffled) 
[10:22:29.862]                           invokeRestart("muffleMessage")
[10:22:29.862]                       }
[10:22:29.862]                       else if (inherits(cond, "warning")) {
[10:22:29.862]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:29.862]                         if (muffled) 
[10:22:29.862]                           invokeRestart("muffleWarning")
[10:22:29.862]                       }
[10:22:29.862]                       else if (inherits(cond, "condition")) {
[10:22:29.862]                         if (!is.null(pattern)) {
[10:22:29.862]                           computeRestarts <- base::computeRestarts
[10:22:29.862]                           grepl <- base::grepl
[10:22:29.862]                           restarts <- computeRestarts(cond)
[10:22:29.862]                           for (restart in restarts) {
[10:22:29.862]                             name <- restart$name
[10:22:29.862]                             if (is.null(name)) 
[10:22:29.862]                               next
[10:22:29.862]                             if (!grepl(pattern, name)) 
[10:22:29.862]                               next
[10:22:29.862]                             invokeRestart(restart)
[10:22:29.862]                             muffled <- TRUE
[10:22:29.862]                             break
[10:22:29.862]                           }
[10:22:29.862]                         }
[10:22:29.862]                       }
[10:22:29.862]                       invisible(muffled)
[10:22:29.862]                     }
[10:22:29.862]                     muffleCondition(cond, pattern = "^muffle")
[10:22:29.862]                   }
[10:22:29.862]                 }
[10:22:29.862]             }
[10:22:29.862]         }))
[10:22:29.862]     }, error = function(ex) {
[10:22:29.862]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:29.862]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:29.862]                 ...future.rng), started = ...future.startTime, 
[10:22:29.862]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:29.862]             version = "1.8"), class = "FutureResult")
[10:22:29.862]     }, finally = {
[10:22:29.862]         if (!identical(...future.workdir, getwd())) 
[10:22:29.862]             setwd(...future.workdir)
[10:22:29.862]         {
[10:22:29.862]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:29.862]                 ...future.oldOptions$nwarnings <- NULL
[10:22:29.862]             }
[10:22:29.862]             base::options(...future.oldOptions)
[10:22:29.862]             if (.Platform$OS.type == "windows") {
[10:22:29.862]                 old_names <- names(...future.oldEnvVars)
[10:22:29.862]                 envs <- base::Sys.getenv()
[10:22:29.862]                 names <- names(envs)
[10:22:29.862]                 common <- intersect(names, old_names)
[10:22:29.862]                 added <- setdiff(names, old_names)
[10:22:29.862]                 removed <- setdiff(old_names, names)
[10:22:29.862]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:29.862]                   envs[common]]
[10:22:29.862]                 NAMES <- toupper(changed)
[10:22:29.862]                 args <- list()
[10:22:29.862]                 for (kk in seq_along(NAMES)) {
[10:22:29.862]                   name <- changed[[kk]]
[10:22:29.862]                   NAME <- NAMES[[kk]]
[10:22:29.862]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.862]                     next
[10:22:29.862]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:29.862]                 }
[10:22:29.862]                 NAMES <- toupper(added)
[10:22:29.862]                 for (kk in seq_along(NAMES)) {
[10:22:29.862]                   name <- added[[kk]]
[10:22:29.862]                   NAME <- NAMES[[kk]]
[10:22:29.862]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.862]                     next
[10:22:29.862]                   args[[name]] <- ""
[10:22:29.862]                 }
[10:22:29.862]                 NAMES <- toupper(removed)
[10:22:29.862]                 for (kk in seq_along(NAMES)) {
[10:22:29.862]                   name <- removed[[kk]]
[10:22:29.862]                   NAME <- NAMES[[kk]]
[10:22:29.862]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.862]                     next
[10:22:29.862]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:29.862]                 }
[10:22:29.862]                 if (length(args) > 0) 
[10:22:29.862]                   base::do.call(base::Sys.setenv, args = args)
[10:22:29.862]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:29.862]             }
[10:22:29.862]             else {
[10:22:29.862]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:29.862]             }
[10:22:29.862]             {
[10:22:29.862]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:29.862]                   0L) {
[10:22:29.862]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:29.862]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:29.862]                   base::options(opts)
[10:22:29.862]                 }
[10:22:29.862]                 {
[10:22:29.862]                   {
[10:22:29.862]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:29.862]                     NULL
[10:22:29.862]                   }
[10:22:29.862]                   options(future.plan = NULL)
[10:22:29.862]                   if (is.na(NA_character_)) 
[10:22:29.862]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:29.862]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:29.862]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:29.862]                     .init = FALSE)
[10:22:29.862]                 }
[10:22:29.862]             }
[10:22:29.862]         }
[10:22:29.862]     })
[10:22:29.862]     if (TRUE) {
[10:22:29.862]         base::sink(type = "output", split = FALSE)
[10:22:29.862]         if (TRUE) {
[10:22:29.862]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:29.862]         }
[10:22:29.862]         else {
[10:22:29.862]             ...future.result["stdout"] <- base::list(NULL)
[10:22:29.862]         }
[10:22:29.862]         base::close(...future.stdout)
[10:22:29.862]         ...future.stdout <- NULL
[10:22:29.862]     }
[10:22:29.862]     ...future.result$conditions <- ...future.conditions
[10:22:29.862]     ...future.result$finished <- base::Sys.time()
[10:22:29.862]     ...future.result
[10:22:29.862] }
[10:22:29.866] requestCore(): workers = 2
[10:22:29.867] Poll #1 (0): usedCores() = 2, workers = 2
[10:22:29.878] result() for MulticoreFuture ...
[10:22:29.881] result() for MulticoreFuture ...
[10:22:29.881] result() for MulticoreFuture ... done
[10:22:29.881] result() for MulticoreFuture ... done
[10:22:29.881] result() for MulticoreFuture ...
[10:22:29.881] result() for MulticoreFuture ... done
[10:22:29.885] MulticoreFuture started
[10:22:29.885] - Launch lazy future ... done
[10:22:29.886] run() for ‘MulticoreFuture’ ... done
[10:22:29.886] plan(): Setting new future strategy stack:
[10:22:29.886] resolve() on list ...
[10:22:29.887]  recursive: 0
[10:22:29.887]  length: 3
[10:22:29.887]  elements: ‘a’, ‘b’, ‘’
[10:22:29.886] List of future strategies:
[10:22:29.886] 1. sequential:
[10:22:29.886]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:29.886]    - tweaked: FALSE
[10:22:29.886]    - call: NULL
[10:22:29.888] run() for ‘Future’ ...
[10:22:29.888] plan(): nbrOfWorkers() = 1
[10:22:29.888] - state: ‘created’
[10:22:29.889] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:29.891] plan(): Setting new future strategy stack:
[10:22:29.892] List of future strategies:
[10:22:29.892] 1. multicore:
[10:22:29.892]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:29.892]    - tweaked: FALSE
[10:22:29.892]    - call: plan(strategy)
[10:22:29.894] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:29.894] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:29.895]   - Field: ‘label’
[10:22:29.895]   - Field: ‘local’
[10:22:29.895]   - Field: ‘owner’
[10:22:29.895]   - Field: ‘envir’
[10:22:29.896]   - Field: ‘workers’
[10:22:29.896] plan(): nbrOfWorkers() = 2
[10:22:29.896]   - Field: ‘packages’
[10:22:29.896]   - Field: ‘gc’
[10:22:29.896]   - Field: ‘job’
[10:22:29.896]   - Field: ‘conditions’
[10:22:29.897]   - Field: ‘expr’
[10:22:29.897]   - Field: ‘uuid’
[10:22:29.897]   - Field: ‘seed’
[10:22:29.897]   - Field: ‘version’
[10:22:29.897]   - Field: ‘result’
[10:22:29.897]   - Field: ‘asynchronous’
[10:22:29.898]   - Field: ‘calls’
[10:22:29.898]   - Field: ‘globals’
[10:22:29.898]   - Field: ‘stdout’
[10:22:29.898]   - Field: ‘earlySignal’
[10:22:29.898]   - Field: ‘lazy’
[10:22:29.898]   - Field: ‘state’
[10:22:29.899] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:29.899] - Launch lazy future ...
[10:22:29.899] Packages needed by the future expression (n = 0): <none>
[10:22:29.899] Packages needed by future strategies (n = 0): <none>
[10:22:29.900] {
[10:22:29.900]     {
[10:22:29.900]         {
[10:22:29.900]             ...future.startTime <- base::Sys.time()
[10:22:29.900]             {
[10:22:29.900]                 {
[10:22:29.900]                   {
[10:22:29.900]                     {
[10:22:29.900]                       base::local({
[10:22:29.900]                         has_future <- base::requireNamespace("future", 
[10:22:29.900]                           quietly = TRUE)
[10:22:29.900]                         if (has_future) {
[10:22:29.900]                           ns <- base::getNamespace("future")
[10:22:29.900]                           version <- ns[[".package"]][["version"]]
[10:22:29.900]                           if (is.null(version)) 
[10:22:29.900]                             version <- utils::packageVersion("future")
[10:22:29.900]                         }
[10:22:29.900]                         else {
[10:22:29.900]                           version <- NULL
[10:22:29.900]                         }
[10:22:29.900]                         if (!has_future || version < "1.8.0") {
[10:22:29.900]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:29.900]                             "", base::R.version$version.string), 
[10:22:29.900]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:29.900]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:29.900]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:29.900]                               "release", "version")], collapse = " "), 
[10:22:29.900]                             hostname = base::Sys.info()[["nodename"]])
[10:22:29.900]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:29.900]                             info)
[10:22:29.900]                           info <- base::paste(info, collapse = "; ")
[10:22:29.900]                           if (!has_future) {
[10:22:29.900]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:29.900]                               info)
[10:22:29.900]                           }
[10:22:29.900]                           else {
[10:22:29.900]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:29.900]                               info, version)
[10:22:29.900]                           }
[10:22:29.900]                           base::stop(msg)
[10:22:29.900]                         }
[10:22:29.900]                       })
[10:22:29.900]                     }
[10:22:29.900]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:29.900]                     base::options(mc.cores = 1L)
[10:22:29.900]                   }
[10:22:29.900]                   ...future.strategy.old <- future::plan("list")
[10:22:29.900]                   options(future.plan = NULL)
[10:22:29.900]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:29.900]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:29.900]                 }
[10:22:29.900]                 ...future.workdir <- getwd()
[10:22:29.900]             }
[10:22:29.900]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:29.900]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:29.900]         }
[10:22:29.900]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:29.900]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:29.900]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:29.900]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:29.900]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:29.900]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:29.900]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:29.900]             base::names(...future.oldOptions))
[10:22:29.900]     }
[10:22:29.900]     if (FALSE) {
[10:22:29.900]     }
[10:22:29.900]     else {
[10:22:29.900]         if (TRUE) {
[10:22:29.900]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:29.900]                 open = "w")
[10:22:29.900]         }
[10:22:29.900]         else {
[10:22:29.900]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:29.900]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:29.900]         }
[10:22:29.900]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:29.900]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:29.900]             base::sink(type = "output", split = FALSE)
[10:22:29.900]             base::close(...future.stdout)
[10:22:29.900]         }, add = TRUE)
[10:22:29.900]     }
[10:22:29.900]     ...future.frame <- base::sys.nframe()
[10:22:29.900]     ...future.conditions <- base::list()
[10:22:29.900]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:29.900]     if (FALSE) {
[10:22:29.900]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:29.900]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:29.900]     }
[10:22:29.900]     ...future.result <- base::tryCatch({
[10:22:29.900]         base::withCallingHandlers({
[10:22:29.900]             ...future.value <- base::withVisible(base::local({
[10:22:29.900]                 withCallingHandlers({
[10:22:29.900]                   1
[10:22:29.900]                 }, immediateCondition = function(cond) {
[10:22:29.900]                   save_rds <- function (object, pathname, ...) 
[10:22:29.900]                   {
[10:22:29.900]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:29.900]                     if (file_test("-f", pathname_tmp)) {
[10:22:29.900]                       fi_tmp <- file.info(pathname_tmp)
[10:22:29.900]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:29.900]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:29.900]                         fi_tmp[["mtime"]])
[10:22:29.900]                     }
[10:22:29.900]                     tryCatch({
[10:22:29.900]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:29.900]                     }, error = function(ex) {
[10:22:29.900]                       msg <- conditionMessage(ex)
[10:22:29.900]                       fi_tmp <- file.info(pathname_tmp)
[10:22:29.900]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:29.900]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:29.900]                         fi_tmp[["mtime"]], msg)
[10:22:29.900]                       ex$message <- msg
[10:22:29.900]                       stop(ex)
[10:22:29.900]                     })
[10:22:29.900]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:29.900]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:29.900]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:29.900]                       fi_tmp <- file.info(pathname_tmp)
[10:22:29.900]                       fi <- file.info(pathname)
[10:22:29.900]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:29.900]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:29.900]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:29.900]                         fi[["size"]], fi[["mtime"]])
[10:22:29.900]                       stop(msg)
[10:22:29.900]                     }
[10:22:29.900]                     invisible(pathname)
[10:22:29.900]                   }
[10:22:29.900]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:29.900]                     rootPath = tempdir()) 
[10:22:29.900]                   {
[10:22:29.900]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:29.900]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:29.900]                       tmpdir = path, fileext = ".rds")
[10:22:29.900]                     save_rds(obj, file)
[10:22:29.900]                   }
[10:22:29.900]                   saveImmediateCondition(cond, path = "/tmp/RtmpzsJv4f/.future/immediateConditions")
[10:22:29.900]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.900]                   {
[10:22:29.900]                     inherits <- base::inherits
[10:22:29.900]                     invokeRestart <- base::invokeRestart
[10:22:29.900]                     is.null <- base::is.null
[10:22:29.900]                     muffled <- FALSE
[10:22:29.900]                     if (inherits(cond, "message")) {
[10:22:29.900]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:29.900]                       if (muffled) 
[10:22:29.900]                         invokeRestart("muffleMessage")
[10:22:29.900]                     }
[10:22:29.900]                     else if (inherits(cond, "warning")) {
[10:22:29.900]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:29.900]                       if (muffled) 
[10:22:29.900]                         invokeRestart("muffleWarning")
[10:22:29.900]                     }
[10:22:29.900]                     else if (inherits(cond, "condition")) {
[10:22:29.900]                       if (!is.null(pattern)) {
[10:22:29.900]                         computeRestarts <- base::computeRestarts
[10:22:29.900]                         grepl <- base::grepl
[10:22:29.900]                         restarts <- computeRestarts(cond)
[10:22:29.900]                         for (restart in restarts) {
[10:22:29.900]                           name <- restart$name
[10:22:29.900]                           if (is.null(name)) 
[10:22:29.900]                             next
[10:22:29.900]                           if (!grepl(pattern, name)) 
[10:22:29.900]                             next
[10:22:29.900]                           invokeRestart(restart)
[10:22:29.900]                           muffled <- TRUE
[10:22:29.900]                           break
[10:22:29.900]                         }
[10:22:29.900]                       }
[10:22:29.900]                     }
[10:22:29.900]                     invisible(muffled)
[10:22:29.900]                   }
[10:22:29.900]                   muffleCondition(cond)
[10:22:29.900]                 })
[10:22:29.900]             }))
[10:22:29.900]             future::FutureResult(value = ...future.value$value, 
[10:22:29.900]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:29.900]                   ...future.rng), globalenv = if (FALSE) 
[10:22:29.900]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:29.900]                     ...future.globalenv.names))
[10:22:29.900]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:29.900]         }, condition = base::local({
[10:22:29.900]             c <- base::c
[10:22:29.900]             inherits <- base::inherits
[10:22:29.900]             invokeRestart <- base::invokeRestart
[10:22:29.900]             length <- base::length
[10:22:29.900]             list <- base::list
[10:22:29.900]             seq.int <- base::seq.int
[10:22:29.900]             signalCondition <- base::signalCondition
[10:22:29.900]             sys.calls <- base::sys.calls
[10:22:29.900]             `[[` <- base::`[[`
[10:22:29.900]             `+` <- base::`+`
[10:22:29.900]             `<<-` <- base::`<<-`
[10:22:29.900]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:29.900]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:29.900]                   3L)]
[10:22:29.900]             }
[10:22:29.900]             function(cond) {
[10:22:29.900]                 is_error <- inherits(cond, "error")
[10:22:29.900]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:29.900]                   NULL)
[10:22:29.900]                 if (is_error) {
[10:22:29.900]                   sessionInformation <- function() {
[10:22:29.900]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:29.900]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:29.900]                       search = base::search(), system = base::Sys.info())
[10:22:29.900]                   }
[10:22:29.900]                   ...future.conditions[[length(...future.conditions) + 
[10:22:29.900]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:29.900]                     cond$call), session = sessionInformation(), 
[10:22:29.900]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:29.900]                   signalCondition(cond)
[10:22:29.900]                 }
[10:22:29.900]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:29.900]                 "immediateCondition"))) {
[10:22:29.900]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:29.900]                   ...future.conditions[[length(...future.conditions) + 
[10:22:29.900]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:29.900]                   if (TRUE && !signal) {
[10:22:29.900]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.900]                     {
[10:22:29.900]                       inherits <- base::inherits
[10:22:29.900]                       invokeRestart <- base::invokeRestart
[10:22:29.900]                       is.null <- base::is.null
[10:22:29.900]                       muffled <- FALSE
[10:22:29.900]                       if (inherits(cond, "message")) {
[10:22:29.900]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:29.900]                         if (muffled) 
[10:22:29.900]                           invokeRestart("muffleMessage")
[10:22:29.900]                       }
[10:22:29.900]                       else if (inherits(cond, "warning")) {
[10:22:29.900]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:29.900]                         if (muffled) 
[10:22:29.900]                           invokeRestart("muffleWarning")
[10:22:29.900]                       }
[10:22:29.900]                       else if (inherits(cond, "condition")) {
[10:22:29.900]                         if (!is.null(pattern)) {
[10:22:29.900]                           computeRestarts <- base::computeRestarts
[10:22:29.900]                           grepl <- base::grepl
[10:22:29.900]                           restarts <- computeRestarts(cond)
[10:22:29.900]                           for (restart in restarts) {
[10:22:29.900]                             name <- restart$name
[10:22:29.900]                             if (is.null(name)) 
[10:22:29.900]                               next
[10:22:29.900]                             if (!grepl(pattern, name)) 
[10:22:29.900]                               next
[10:22:29.900]                             invokeRestart(restart)
[10:22:29.900]                             muffled <- TRUE
[10:22:29.900]                             break
[10:22:29.900]                           }
[10:22:29.900]                         }
[10:22:29.900]                       }
[10:22:29.900]                       invisible(muffled)
[10:22:29.900]                     }
[10:22:29.900]                     muffleCondition(cond, pattern = "^muffle")
[10:22:29.900]                   }
[10:22:29.900]                 }
[10:22:29.900]                 else {
[10:22:29.900]                   if (TRUE) {
[10:22:29.900]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.900]                     {
[10:22:29.900]                       inherits <- base::inherits
[10:22:29.900]                       invokeRestart <- base::invokeRestart
[10:22:29.900]                       is.null <- base::is.null
[10:22:29.900]                       muffled <- FALSE
[10:22:29.900]                       if (inherits(cond, "message")) {
[10:22:29.900]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:29.900]                         if (muffled) 
[10:22:29.900]                           invokeRestart("muffleMessage")
[10:22:29.900]                       }
[10:22:29.900]                       else if (inherits(cond, "warning")) {
[10:22:29.900]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:29.900]                         if (muffled) 
[10:22:29.900]                           invokeRestart("muffleWarning")
[10:22:29.900]                       }
[10:22:29.900]                       else if (inherits(cond, "condition")) {
[10:22:29.900]                         if (!is.null(pattern)) {
[10:22:29.900]                           computeRestarts <- base::computeRestarts
[10:22:29.900]                           grepl <- base::grepl
[10:22:29.900]                           restarts <- computeRestarts(cond)
[10:22:29.900]                           for (restart in restarts) {
[10:22:29.900]                             name <- restart$name
[10:22:29.900]                             if (is.null(name)) 
[10:22:29.900]                               next
[10:22:29.900]                             if (!grepl(pattern, name)) 
[10:22:29.900]                               next
[10:22:29.900]                             invokeRestart(restart)
[10:22:29.900]                             muffled <- TRUE
[10:22:29.900]                             break
[10:22:29.900]                           }
[10:22:29.900]                         }
[10:22:29.900]                       }
[10:22:29.900]                       invisible(muffled)
[10:22:29.900]                     }
[10:22:29.900]                     muffleCondition(cond, pattern = "^muffle")
[10:22:29.900]                   }
[10:22:29.900]                 }
[10:22:29.900]             }
[10:22:29.900]         }))
[10:22:29.900]     }, error = function(ex) {
[10:22:29.900]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:29.900]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:29.900]                 ...future.rng), started = ...future.startTime, 
[10:22:29.900]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:29.900]             version = "1.8"), class = "FutureResult")
[10:22:29.900]     }, finally = {
[10:22:29.900]         if (!identical(...future.workdir, getwd())) 
[10:22:29.900]             setwd(...future.workdir)
[10:22:29.900]         {
[10:22:29.900]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:29.900]                 ...future.oldOptions$nwarnings <- NULL
[10:22:29.900]             }
[10:22:29.900]             base::options(...future.oldOptions)
[10:22:29.900]             if (.Platform$OS.type == "windows") {
[10:22:29.900]                 old_names <- names(...future.oldEnvVars)
[10:22:29.900]                 envs <- base::Sys.getenv()
[10:22:29.900]                 names <- names(envs)
[10:22:29.900]                 common <- intersect(names, old_names)
[10:22:29.900]                 added <- setdiff(names, old_names)
[10:22:29.900]                 removed <- setdiff(old_names, names)
[10:22:29.900]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:29.900]                   envs[common]]
[10:22:29.900]                 NAMES <- toupper(changed)
[10:22:29.900]                 args <- list()
[10:22:29.900]                 for (kk in seq_along(NAMES)) {
[10:22:29.900]                   name <- changed[[kk]]
[10:22:29.900]                   NAME <- NAMES[[kk]]
[10:22:29.900]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.900]                     next
[10:22:29.900]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:29.900]                 }
[10:22:29.900]                 NAMES <- toupper(added)
[10:22:29.900]                 for (kk in seq_along(NAMES)) {
[10:22:29.900]                   name <- added[[kk]]
[10:22:29.900]                   NAME <- NAMES[[kk]]
[10:22:29.900]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.900]                     next
[10:22:29.900]                   args[[name]] <- ""
[10:22:29.900]                 }
[10:22:29.900]                 NAMES <- toupper(removed)
[10:22:29.900]                 for (kk in seq_along(NAMES)) {
[10:22:29.900]                   name <- removed[[kk]]
[10:22:29.900]                   NAME <- NAMES[[kk]]
[10:22:29.900]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.900]                     next
[10:22:29.900]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:29.900]                 }
[10:22:29.900]                 if (length(args) > 0) 
[10:22:29.900]                   base::do.call(base::Sys.setenv, args = args)
[10:22:29.900]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:29.900]             }
[10:22:29.900]             else {
[10:22:29.900]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:29.900]             }
[10:22:29.900]             {
[10:22:29.900]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:29.900]                   0L) {
[10:22:29.900]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:29.900]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:29.900]                   base::options(opts)
[10:22:29.900]                 }
[10:22:29.900]                 {
[10:22:29.900]                   {
[10:22:29.900]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:29.900]                     NULL
[10:22:29.900]                   }
[10:22:29.900]                   options(future.plan = NULL)
[10:22:29.900]                   if (is.na(NA_character_)) 
[10:22:29.900]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:29.900]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:29.900]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:29.900]                     .init = FALSE)
[10:22:29.900]                 }
[10:22:29.900]             }
[10:22:29.900]         }
[10:22:29.900]     })
[10:22:29.900]     if (TRUE) {
[10:22:29.900]         base::sink(type = "output", split = FALSE)
[10:22:29.900]         if (TRUE) {
[10:22:29.900]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:29.900]         }
[10:22:29.900]         else {
[10:22:29.900]             ...future.result["stdout"] <- base::list(NULL)
[10:22:29.900]         }
[10:22:29.900]         base::close(...future.stdout)
[10:22:29.900]         ...future.stdout <- NULL
[10:22:29.900]     }
[10:22:29.900]     ...future.result$conditions <- ...future.conditions
[10:22:29.900]     ...future.result$finished <- base::Sys.time()
[10:22:29.900]     ...future.result
[10:22:29.900] }
[10:22:29.903] requestCore(): workers = 2
[10:22:29.904] Poll #1 (0): usedCores() = 2, workers = 2
[10:22:29.927] result() for MulticoreFuture ...
[10:22:29.928] result() for MulticoreFuture ...
[10:22:29.928] result() for MulticoreFuture ... done
[10:22:29.928] result() for MulticoreFuture ... done
[10:22:29.928] result() for MulticoreFuture ...
[10:22:29.929] result() for MulticoreFuture ... done
[10:22:29.931] MulticoreFuture started
[10:22:29.931] - Launch lazy future ... done
[10:22:29.932] run() for ‘MulticoreFuture’ ... done
[10:22:29.932] plan(): Setting new future strategy stack:
[10:22:29.932] List of future strategies:
[10:22:29.932] 1. sequential:
[10:22:29.932]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:29.932]    - tweaked: FALSE
[10:22:29.932]    - call: NULL
[10:22:29.933] plan(): nbrOfWorkers() = 1
[10:22:29.936] plan(): Setting new future strategy stack:
[10:22:29.936] List of future strategies:
[10:22:29.936] 1. multicore:
[10:22:29.936]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:29.936]    - tweaked: FALSE
[10:22:29.936]    - call: plan(strategy)
[10:22:29.939] plan(): nbrOfWorkers() = 2
[10:22:29.939] Future #1
[10:22:29.940]  length: 2 (resolved future 1)
[10:22:29.940] Future #2
[10:22:29.940]  length: 1 (resolved future 2)
[10:22:29.940]  length: 0 (resolved future 3)
[10:22:29.941] resolve() on list ... DONE
[10:22:29.941] getGlobalsAndPackages() ...
[10:22:29.941] Searching for globals...
[10:22:29.942] 
[10:22:29.942] Searching for globals ... DONE
[10:22:29.942] - globals: [0] <none>
[10:22:29.942] getGlobalsAndPackages() ... DONE
[10:22:29.943] getGlobalsAndPackages() ...
[10:22:29.943] Searching for globals...
[10:22:29.943] 
[10:22:29.943] Searching for globals ... DONE
[10:22:29.944] - globals: [0] <none>
[10:22:29.944] getGlobalsAndPackages() ... DONE
[10:22:29.944] resolve() on list ...
[10:22:29.944]  recursive: 0
[10:22:29.944]  length: 3
[10:22:29.944]  elements: ‘a’, ‘b’, ‘’
[10:22:29.945] run() for ‘Future’ ...
[10:22:29.945] - state: ‘created’
[10:22:29.945] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:29.953] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:29.953] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:29.953]   - Field: ‘label’
[10:22:29.953]   - Field: ‘local’
[10:22:29.954]   - Field: ‘owner’
[10:22:29.954]   - Field: ‘envir’
[10:22:29.955]   - Field: ‘workers’
[10:22:29.955]   - Field: ‘packages’
[10:22:29.955]   - Field: ‘gc’
[10:22:29.955]   - Field: ‘job’
[10:22:29.956]   - Field: ‘conditions’
[10:22:29.956]   - Field: ‘expr’
[10:22:29.956]   - Field: ‘uuid’
[10:22:29.956]   - Field: ‘seed’
[10:22:29.956]   - Field: ‘version’
[10:22:29.956]   - Field: ‘result’
[10:22:29.957]   - Field: ‘asynchronous’
[10:22:29.957]   - Field: ‘calls’
[10:22:29.957]   - Field: ‘globals’
[10:22:29.957]   - Field: ‘stdout’
[10:22:29.957]   - Field: ‘earlySignal’
[10:22:29.957]   - Field: ‘lazy’
[10:22:29.957]   - Field: ‘state’
[10:22:29.958] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:29.958] - Launch lazy future ...
[10:22:29.958] Packages needed by the future expression (n = 0): <none>
[10:22:29.958] Packages needed by future strategies (n = 0): <none>
[10:22:29.959] {
[10:22:29.959]     {
[10:22:29.959]         {
[10:22:29.959]             ...future.startTime <- base::Sys.time()
[10:22:29.959]             {
[10:22:29.959]                 {
[10:22:29.959]                   {
[10:22:29.959]                     {
[10:22:29.959]                       base::local({
[10:22:29.959]                         has_future <- base::requireNamespace("future", 
[10:22:29.959]                           quietly = TRUE)
[10:22:29.959]                         if (has_future) {
[10:22:29.959]                           ns <- base::getNamespace("future")
[10:22:29.959]                           version <- ns[[".package"]][["version"]]
[10:22:29.959]                           if (is.null(version)) 
[10:22:29.959]                             version <- utils::packageVersion("future")
[10:22:29.959]                         }
[10:22:29.959]                         else {
[10:22:29.959]                           version <- NULL
[10:22:29.959]                         }
[10:22:29.959]                         if (!has_future || version < "1.8.0") {
[10:22:29.959]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:29.959]                             "", base::R.version$version.string), 
[10:22:29.959]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:29.959]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:29.959]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:29.959]                               "release", "version")], collapse = " "), 
[10:22:29.959]                             hostname = base::Sys.info()[["nodename"]])
[10:22:29.959]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:29.959]                             info)
[10:22:29.959]                           info <- base::paste(info, collapse = "; ")
[10:22:29.959]                           if (!has_future) {
[10:22:29.959]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:29.959]                               info)
[10:22:29.959]                           }
[10:22:29.959]                           else {
[10:22:29.959]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:29.959]                               info, version)
[10:22:29.959]                           }
[10:22:29.959]                           base::stop(msg)
[10:22:29.959]                         }
[10:22:29.959]                       })
[10:22:29.959]                     }
[10:22:29.959]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:29.959]                     base::options(mc.cores = 1L)
[10:22:29.959]                   }
[10:22:29.959]                   ...future.strategy.old <- future::plan("list")
[10:22:29.959]                   options(future.plan = NULL)
[10:22:29.959]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:29.959]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:29.959]                 }
[10:22:29.959]                 ...future.workdir <- getwd()
[10:22:29.959]             }
[10:22:29.959]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:29.959]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:29.959]         }
[10:22:29.959]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:29.959]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:29.959]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:29.959]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:29.959]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:29.959]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:29.959]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:29.959]             base::names(...future.oldOptions))
[10:22:29.959]     }
[10:22:29.959]     if (FALSE) {
[10:22:29.959]     }
[10:22:29.959]     else {
[10:22:29.959]         if (TRUE) {
[10:22:29.959]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:29.959]                 open = "w")
[10:22:29.959]         }
[10:22:29.959]         else {
[10:22:29.959]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:29.959]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:29.959]         }
[10:22:29.959]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:29.959]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:29.959]             base::sink(type = "output", split = FALSE)
[10:22:29.959]             base::close(...future.stdout)
[10:22:29.959]         }, add = TRUE)
[10:22:29.959]     }
[10:22:29.959]     ...future.frame <- base::sys.nframe()
[10:22:29.959]     ...future.conditions <- base::list()
[10:22:29.959]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:29.959]     if (FALSE) {
[10:22:29.959]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:29.959]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:29.959]     }
[10:22:29.959]     ...future.result <- base::tryCatch({
[10:22:29.959]         base::withCallingHandlers({
[10:22:29.959]             ...future.value <- base::withVisible(base::local({
[10:22:29.959]                 withCallingHandlers({
[10:22:29.959]                   1
[10:22:29.959]                 }, immediateCondition = function(cond) {
[10:22:29.959]                   save_rds <- function (object, pathname, ...) 
[10:22:29.959]                   {
[10:22:29.959]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:29.959]                     if (file_test("-f", pathname_tmp)) {
[10:22:29.959]                       fi_tmp <- file.info(pathname_tmp)
[10:22:29.959]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:29.959]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:29.959]                         fi_tmp[["mtime"]])
[10:22:29.959]                     }
[10:22:29.959]                     tryCatch({
[10:22:29.959]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:29.959]                     }, error = function(ex) {
[10:22:29.959]                       msg <- conditionMessage(ex)
[10:22:29.959]                       fi_tmp <- file.info(pathname_tmp)
[10:22:29.959]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:29.959]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:29.959]                         fi_tmp[["mtime"]], msg)
[10:22:29.959]                       ex$message <- msg
[10:22:29.959]                       stop(ex)
[10:22:29.959]                     })
[10:22:29.959]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:29.959]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:29.959]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:29.959]                       fi_tmp <- file.info(pathname_tmp)
[10:22:29.959]                       fi <- file.info(pathname)
[10:22:29.959]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:29.959]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:29.959]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:29.959]                         fi[["size"]], fi[["mtime"]])
[10:22:29.959]                       stop(msg)
[10:22:29.959]                     }
[10:22:29.959]                     invisible(pathname)
[10:22:29.959]                   }
[10:22:29.959]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:29.959]                     rootPath = tempdir()) 
[10:22:29.959]                   {
[10:22:29.959]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:29.959]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:29.959]                       tmpdir = path, fileext = ".rds")
[10:22:29.959]                     save_rds(obj, file)
[10:22:29.959]                   }
[10:22:29.959]                   saveImmediateCondition(cond, path = "/tmp/RtmpzsJv4f/.future/immediateConditions")
[10:22:29.959]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.959]                   {
[10:22:29.959]                     inherits <- base::inherits
[10:22:29.959]                     invokeRestart <- base::invokeRestart
[10:22:29.959]                     is.null <- base::is.null
[10:22:29.959]                     muffled <- FALSE
[10:22:29.959]                     if (inherits(cond, "message")) {
[10:22:29.959]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:29.959]                       if (muffled) 
[10:22:29.959]                         invokeRestart("muffleMessage")
[10:22:29.959]                     }
[10:22:29.959]                     else if (inherits(cond, "warning")) {
[10:22:29.959]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:29.959]                       if (muffled) 
[10:22:29.959]                         invokeRestart("muffleWarning")
[10:22:29.959]                     }
[10:22:29.959]                     else if (inherits(cond, "condition")) {
[10:22:29.959]                       if (!is.null(pattern)) {
[10:22:29.959]                         computeRestarts <- base::computeRestarts
[10:22:29.959]                         grepl <- base::grepl
[10:22:29.959]                         restarts <- computeRestarts(cond)
[10:22:29.959]                         for (restart in restarts) {
[10:22:29.959]                           name <- restart$name
[10:22:29.959]                           if (is.null(name)) 
[10:22:29.959]                             next
[10:22:29.959]                           if (!grepl(pattern, name)) 
[10:22:29.959]                             next
[10:22:29.959]                           invokeRestart(restart)
[10:22:29.959]                           muffled <- TRUE
[10:22:29.959]                           break
[10:22:29.959]                         }
[10:22:29.959]                       }
[10:22:29.959]                     }
[10:22:29.959]                     invisible(muffled)
[10:22:29.959]                   }
[10:22:29.959]                   muffleCondition(cond)
[10:22:29.959]                 })
[10:22:29.959]             }))
[10:22:29.959]             future::FutureResult(value = ...future.value$value, 
[10:22:29.959]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:29.959]                   ...future.rng), globalenv = if (FALSE) 
[10:22:29.959]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:29.959]                     ...future.globalenv.names))
[10:22:29.959]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:29.959]         }, condition = base::local({
[10:22:29.959]             c <- base::c
[10:22:29.959]             inherits <- base::inherits
[10:22:29.959]             invokeRestart <- base::invokeRestart
[10:22:29.959]             length <- base::length
[10:22:29.959]             list <- base::list
[10:22:29.959]             seq.int <- base::seq.int
[10:22:29.959]             signalCondition <- base::signalCondition
[10:22:29.959]             sys.calls <- base::sys.calls
[10:22:29.959]             `[[` <- base::`[[`
[10:22:29.959]             `+` <- base::`+`
[10:22:29.959]             `<<-` <- base::`<<-`
[10:22:29.959]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:29.959]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:29.959]                   3L)]
[10:22:29.959]             }
[10:22:29.959]             function(cond) {
[10:22:29.959]                 is_error <- inherits(cond, "error")
[10:22:29.959]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:29.959]                   NULL)
[10:22:29.959]                 if (is_error) {
[10:22:29.959]                   sessionInformation <- function() {
[10:22:29.959]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:29.959]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:29.959]                       search = base::search(), system = base::Sys.info())
[10:22:29.959]                   }
[10:22:29.959]                   ...future.conditions[[length(...future.conditions) + 
[10:22:29.959]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:29.959]                     cond$call), session = sessionInformation(), 
[10:22:29.959]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:29.959]                   signalCondition(cond)
[10:22:29.959]                 }
[10:22:29.959]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:29.959]                 "immediateCondition"))) {
[10:22:29.959]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:29.959]                   ...future.conditions[[length(...future.conditions) + 
[10:22:29.959]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:29.959]                   if (TRUE && !signal) {
[10:22:29.959]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.959]                     {
[10:22:29.959]                       inherits <- base::inherits
[10:22:29.959]                       invokeRestart <- base::invokeRestart
[10:22:29.959]                       is.null <- base::is.null
[10:22:29.959]                       muffled <- FALSE
[10:22:29.959]                       if (inherits(cond, "message")) {
[10:22:29.959]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:29.959]                         if (muffled) 
[10:22:29.959]                           invokeRestart("muffleMessage")
[10:22:29.959]                       }
[10:22:29.959]                       else if (inherits(cond, "warning")) {
[10:22:29.959]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:29.959]                         if (muffled) 
[10:22:29.959]                           invokeRestart("muffleWarning")
[10:22:29.959]                       }
[10:22:29.959]                       else if (inherits(cond, "condition")) {
[10:22:29.959]                         if (!is.null(pattern)) {
[10:22:29.959]                           computeRestarts <- base::computeRestarts
[10:22:29.959]                           grepl <- base::grepl
[10:22:29.959]                           restarts <- computeRestarts(cond)
[10:22:29.959]                           for (restart in restarts) {
[10:22:29.959]                             name <- restart$name
[10:22:29.959]                             if (is.null(name)) 
[10:22:29.959]                               next
[10:22:29.959]                             if (!grepl(pattern, name)) 
[10:22:29.959]                               next
[10:22:29.959]                             invokeRestart(restart)
[10:22:29.959]                             muffled <- TRUE
[10:22:29.959]                             break
[10:22:29.959]                           }
[10:22:29.959]                         }
[10:22:29.959]                       }
[10:22:29.959]                       invisible(muffled)
[10:22:29.959]                     }
[10:22:29.959]                     muffleCondition(cond, pattern = "^muffle")
[10:22:29.959]                   }
[10:22:29.959]                 }
[10:22:29.959]                 else {
[10:22:29.959]                   if (TRUE) {
[10:22:29.959]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.959]                     {
[10:22:29.959]                       inherits <- base::inherits
[10:22:29.959]                       invokeRestart <- base::invokeRestart
[10:22:29.959]                       is.null <- base::is.null
[10:22:29.959]                       muffled <- FALSE
[10:22:29.959]                       if (inherits(cond, "message")) {
[10:22:29.959]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:29.959]                         if (muffled) 
[10:22:29.959]                           invokeRestart("muffleMessage")
[10:22:29.959]                       }
[10:22:29.959]                       else if (inherits(cond, "warning")) {
[10:22:29.959]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:29.959]                         if (muffled) 
[10:22:29.959]                           invokeRestart("muffleWarning")
[10:22:29.959]                       }
[10:22:29.959]                       else if (inherits(cond, "condition")) {
[10:22:29.959]                         if (!is.null(pattern)) {
[10:22:29.959]                           computeRestarts <- base::computeRestarts
[10:22:29.959]                           grepl <- base::grepl
[10:22:29.959]                           restarts <- computeRestarts(cond)
[10:22:29.959]                           for (restart in restarts) {
[10:22:29.959]                             name <- restart$name
[10:22:29.959]                             if (is.null(name)) 
[10:22:29.959]                               next
[10:22:29.959]                             if (!grepl(pattern, name)) 
[10:22:29.959]                               next
[10:22:29.959]                             invokeRestart(restart)
[10:22:29.959]                             muffled <- TRUE
[10:22:29.959]                             break
[10:22:29.959]                           }
[10:22:29.959]                         }
[10:22:29.959]                       }
[10:22:29.959]                       invisible(muffled)
[10:22:29.959]                     }
[10:22:29.959]                     muffleCondition(cond, pattern = "^muffle")
[10:22:29.959]                   }
[10:22:29.959]                 }
[10:22:29.959]             }
[10:22:29.959]         }))
[10:22:29.959]     }, error = function(ex) {
[10:22:29.959]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:29.959]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:29.959]                 ...future.rng), started = ...future.startTime, 
[10:22:29.959]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:29.959]             version = "1.8"), class = "FutureResult")
[10:22:29.959]     }, finally = {
[10:22:29.959]         if (!identical(...future.workdir, getwd())) 
[10:22:29.959]             setwd(...future.workdir)
[10:22:29.959]         {
[10:22:29.959]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:29.959]                 ...future.oldOptions$nwarnings <- NULL
[10:22:29.959]             }
[10:22:29.959]             base::options(...future.oldOptions)
[10:22:29.959]             if (.Platform$OS.type == "windows") {
[10:22:29.959]                 old_names <- names(...future.oldEnvVars)
[10:22:29.959]                 envs <- base::Sys.getenv()
[10:22:29.959]                 names <- names(envs)
[10:22:29.959]                 common <- intersect(names, old_names)
[10:22:29.959]                 added <- setdiff(names, old_names)
[10:22:29.959]                 removed <- setdiff(old_names, names)
[10:22:29.959]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:29.959]                   envs[common]]
[10:22:29.959]                 NAMES <- toupper(changed)
[10:22:29.959]                 args <- list()
[10:22:29.959]                 for (kk in seq_along(NAMES)) {
[10:22:29.959]                   name <- changed[[kk]]
[10:22:29.959]                   NAME <- NAMES[[kk]]
[10:22:29.959]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.959]                     next
[10:22:29.959]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:29.959]                 }
[10:22:29.959]                 NAMES <- toupper(added)
[10:22:29.959]                 for (kk in seq_along(NAMES)) {
[10:22:29.959]                   name <- added[[kk]]
[10:22:29.959]                   NAME <- NAMES[[kk]]
[10:22:29.959]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.959]                     next
[10:22:29.959]                   args[[name]] <- ""
[10:22:29.959]                 }
[10:22:29.959]                 NAMES <- toupper(removed)
[10:22:29.959]                 for (kk in seq_along(NAMES)) {
[10:22:29.959]                   name <- removed[[kk]]
[10:22:29.959]                   NAME <- NAMES[[kk]]
[10:22:29.959]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.959]                     next
[10:22:29.959]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:29.959]                 }
[10:22:29.959]                 if (length(args) > 0) 
[10:22:29.959]                   base::do.call(base::Sys.setenv, args = args)
[10:22:29.959]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:29.959]             }
[10:22:29.959]             else {
[10:22:29.959]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:29.959]             }
[10:22:29.959]             {
[10:22:29.959]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:29.959]                   0L) {
[10:22:29.959]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:29.959]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:29.959]                   base::options(opts)
[10:22:29.959]                 }
[10:22:29.959]                 {
[10:22:29.959]                   {
[10:22:29.959]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:29.959]                     NULL
[10:22:29.959]                   }
[10:22:29.959]                   options(future.plan = NULL)
[10:22:29.959]                   if (is.na(NA_character_)) 
[10:22:29.959]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:29.959]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:29.959]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:29.959]                     .init = FALSE)
[10:22:29.959]                 }
[10:22:29.959]             }
[10:22:29.959]         }
[10:22:29.959]     })
[10:22:29.959]     if (TRUE) {
[10:22:29.959]         base::sink(type = "output", split = FALSE)
[10:22:29.959]         if (TRUE) {
[10:22:29.959]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:29.959]         }
[10:22:29.959]         else {
[10:22:29.959]             ...future.result["stdout"] <- base::list(NULL)
[10:22:29.959]         }
[10:22:29.959]         base::close(...future.stdout)
[10:22:29.959]         ...future.stdout <- NULL
[10:22:29.959]     }
[10:22:29.959]     ...future.result$conditions <- ...future.conditions
[10:22:29.959]     ...future.result$finished <- base::Sys.time()
[10:22:29.959]     ...future.result
[10:22:29.959] }
[10:22:29.962] requestCore(): workers = 2
[10:22:29.962] Poll #1 (0): usedCores() = 2, workers = 2
[10:22:29.973] result() for MulticoreFuture ...
[10:22:29.974] result() for MulticoreFuture ...
[10:22:29.974] result() for MulticoreFuture ... done
[10:22:29.974] result() for MulticoreFuture ... done
[10:22:29.974] result() for MulticoreFuture ...
[10:22:29.974] result() for MulticoreFuture ... done
[10:22:29.977] MulticoreFuture started
[10:22:29.978] - Launch lazy future ... done
[10:22:29.978] run() for ‘MulticoreFuture’ ... done
[10:22:29.978] plan(): Setting new future strategy stack:
[10:22:29.978] List of future strategies:
[10:22:29.978] 1. sequential:
[10:22:29.978]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:29.978]    - tweaked: FALSE
[10:22:29.978]    - call: NULL
[10:22:29.980] plan(): nbrOfWorkers() = 1
[10:22:29.982] plan(): Setting new future strategy stack:
[10:22:29.982] List of future strategies:
[10:22:29.982] 1. multicore:
[10:22:29.982]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:29.982]    - tweaked: FALSE
[10:22:29.982]    - call: plan(strategy)
[10:22:29.985] plan(): nbrOfWorkers() = 2
[10:22:29.986] Future #1
[10:22:29.986]  length: 2 (resolved future 1)
[10:22:29.986] run() for ‘Future’ ...
[10:22:29.986] - state: ‘created’
[10:22:29.987] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:29.990] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:29.990] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:29.990]   - Field: ‘label’
[10:22:29.990]   - Field: ‘local’
[10:22:29.990]   - Field: ‘owner’
[10:22:29.990]   - Field: ‘envir’
[10:22:29.990]   - Field: ‘workers’
[10:22:29.991]   - Field: ‘packages’
[10:22:29.991]   - Field: ‘gc’
[10:22:29.991]   - Field: ‘job’
[10:22:29.991]   - Field: ‘conditions’
[10:22:29.991]   - Field: ‘expr’
[10:22:29.991]   - Field: ‘uuid’
[10:22:29.991]   - Field: ‘seed’
[10:22:29.992]   - Field: ‘version’
[10:22:29.992]   - Field: ‘result’
[10:22:29.992]   - Field: ‘asynchronous’
[10:22:29.992]   - Field: ‘calls’
[10:22:29.992]   - Field: ‘globals’
[10:22:29.992]   - Field: ‘stdout’
[10:22:29.992]   - Field: ‘earlySignal’
[10:22:29.993]   - Field: ‘lazy’
[10:22:29.993]   - Field: ‘state’
[10:22:29.993] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:29.993] - Launch lazy future ...
[10:22:29.994] Packages needed by the future expression (n = 0): <none>
[10:22:29.994] Packages needed by future strategies (n = 0): <none>
[10:22:29.994] {
[10:22:29.994]     {
[10:22:29.994]         {
[10:22:29.994]             ...future.startTime <- base::Sys.time()
[10:22:29.994]             {
[10:22:29.994]                 {
[10:22:29.994]                   {
[10:22:29.994]                     {
[10:22:29.994]                       base::local({
[10:22:29.994]                         has_future <- base::requireNamespace("future", 
[10:22:29.994]                           quietly = TRUE)
[10:22:29.994]                         if (has_future) {
[10:22:29.994]                           ns <- base::getNamespace("future")
[10:22:29.994]                           version <- ns[[".package"]][["version"]]
[10:22:29.994]                           if (is.null(version)) 
[10:22:29.994]                             version <- utils::packageVersion("future")
[10:22:29.994]                         }
[10:22:29.994]                         else {
[10:22:29.994]                           version <- NULL
[10:22:29.994]                         }
[10:22:29.994]                         if (!has_future || version < "1.8.0") {
[10:22:29.994]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:29.994]                             "", base::R.version$version.string), 
[10:22:29.994]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:29.994]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:29.994]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:29.994]                               "release", "version")], collapse = " "), 
[10:22:29.994]                             hostname = base::Sys.info()[["nodename"]])
[10:22:29.994]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:29.994]                             info)
[10:22:29.994]                           info <- base::paste(info, collapse = "; ")
[10:22:29.994]                           if (!has_future) {
[10:22:29.994]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:29.994]                               info)
[10:22:29.994]                           }
[10:22:29.994]                           else {
[10:22:29.994]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:29.994]                               info, version)
[10:22:29.994]                           }
[10:22:29.994]                           base::stop(msg)
[10:22:29.994]                         }
[10:22:29.994]                       })
[10:22:29.994]                     }
[10:22:29.994]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:29.994]                     base::options(mc.cores = 1L)
[10:22:29.994]                   }
[10:22:29.994]                   ...future.strategy.old <- future::plan("list")
[10:22:29.994]                   options(future.plan = NULL)
[10:22:29.994]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:29.994]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:29.994]                 }
[10:22:29.994]                 ...future.workdir <- getwd()
[10:22:29.994]             }
[10:22:29.994]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:29.994]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:29.994]         }
[10:22:29.994]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:29.994]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:29.994]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:29.994]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:29.994]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:29.994]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:29.994]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:29.994]             base::names(...future.oldOptions))
[10:22:29.994]     }
[10:22:29.994]     if (FALSE) {
[10:22:29.994]     }
[10:22:29.994]     else {
[10:22:29.994]         if (TRUE) {
[10:22:29.994]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:29.994]                 open = "w")
[10:22:29.994]         }
[10:22:29.994]         else {
[10:22:29.994]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:29.994]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:29.994]         }
[10:22:29.994]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:29.994]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:29.994]             base::sink(type = "output", split = FALSE)
[10:22:29.994]             base::close(...future.stdout)
[10:22:29.994]         }, add = TRUE)
[10:22:29.994]     }
[10:22:29.994]     ...future.frame <- base::sys.nframe()
[10:22:29.994]     ...future.conditions <- base::list()
[10:22:29.994]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:29.994]     if (FALSE) {
[10:22:29.994]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:29.994]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:29.994]     }
[10:22:29.994]     ...future.result <- base::tryCatch({
[10:22:29.994]         base::withCallingHandlers({
[10:22:29.994]             ...future.value <- base::withVisible(base::local({
[10:22:29.994]                 withCallingHandlers({
[10:22:29.994]                   2
[10:22:29.994]                 }, immediateCondition = function(cond) {
[10:22:29.994]                   save_rds <- function (object, pathname, ...) 
[10:22:29.994]                   {
[10:22:29.994]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:29.994]                     if (file_test("-f", pathname_tmp)) {
[10:22:29.994]                       fi_tmp <- file.info(pathname_tmp)
[10:22:29.994]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:29.994]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:29.994]                         fi_tmp[["mtime"]])
[10:22:29.994]                     }
[10:22:29.994]                     tryCatch({
[10:22:29.994]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:29.994]                     }, error = function(ex) {
[10:22:29.994]                       msg <- conditionMessage(ex)
[10:22:29.994]                       fi_tmp <- file.info(pathname_tmp)
[10:22:29.994]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:29.994]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:29.994]                         fi_tmp[["mtime"]], msg)
[10:22:29.994]                       ex$message <- msg
[10:22:29.994]                       stop(ex)
[10:22:29.994]                     })
[10:22:29.994]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:29.994]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:29.994]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:29.994]                       fi_tmp <- file.info(pathname_tmp)
[10:22:29.994]                       fi <- file.info(pathname)
[10:22:29.994]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:29.994]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:29.994]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:29.994]                         fi[["size"]], fi[["mtime"]])
[10:22:29.994]                       stop(msg)
[10:22:29.994]                     }
[10:22:29.994]                     invisible(pathname)
[10:22:29.994]                   }
[10:22:29.994]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:29.994]                     rootPath = tempdir()) 
[10:22:29.994]                   {
[10:22:29.994]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:29.994]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:29.994]                       tmpdir = path, fileext = ".rds")
[10:22:29.994]                     save_rds(obj, file)
[10:22:29.994]                   }
[10:22:29.994]                   saveImmediateCondition(cond, path = "/tmp/RtmpzsJv4f/.future/immediateConditions")
[10:22:29.994]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.994]                   {
[10:22:29.994]                     inherits <- base::inherits
[10:22:29.994]                     invokeRestart <- base::invokeRestart
[10:22:29.994]                     is.null <- base::is.null
[10:22:29.994]                     muffled <- FALSE
[10:22:29.994]                     if (inherits(cond, "message")) {
[10:22:29.994]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:29.994]                       if (muffled) 
[10:22:29.994]                         invokeRestart("muffleMessage")
[10:22:29.994]                     }
[10:22:29.994]                     else if (inherits(cond, "warning")) {
[10:22:29.994]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:29.994]                       if (muffled) 
[10:22:29.994]                         invokeRestart("muffleWarning")
[10:22:29.994]                     }
[10:22:29.994]                     else if (inherits(cond, "condition")) {
[10:22:29.994]                       if (!is.null(pattern)) {
[10:22:29.994]                         computeRestarts <- base::computeRestarts
[10:22:29.994]                         grepl <- base::grepl
[10:22:29.994]                         restarts <- computeRestarts(cond)
[10:22:29.994]                         for (restart in restarts) {
[10:22:29.994]                           name <- restart$name
[10:22:29.994]                           if (is.null(name)) 
[10:22:29.994]                             next
[10:22:29.994]                           if (!grepl(pattern, name)) 
[10:22:29.994]                             next
[10:22:29.994]                           invokeRestart(restart)
[10:22:29.994]                           muffled <- TRUE
[10:22:29.994]                           break
[10:22:29.994]                         }
[10:22:29.994]                       }
[10:22:29.994]                     }
[10:22:29.994]                     invisible(muffled)
[10:22:29.994]                   }
[10:22:29.994]                   muffleCondition(cond)
[10:22:29.994]                 })
[10:22:29.994]             }))
[10:22:29.994]             future::FutureResult(value = ...future.value$value, 
[10:22:29.994]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:29.994]                   ...future.rng), globalenv = if (FALSE) 
[10:22:29.994]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:29.994]                     ...future.globalenv.names))
[10:22:29.994]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:29.994]         }, condition = base::local({
[10:22:29.994]             c <- base::c
[10:22:29.994]             inherits <- base::inherits
[10:22:29.994]             invokeRestart <- base::invokeRestart
[10:22:29.994]             length <- base::length
[10:22:29.994]             list <- base::list
[10:22:29.994]             seq.int <- base::seq.int
[10:22:29.994]             signalCondition <- base::signalCondition
[10:22:29.994]             sys.calls <- base::sys.calls
[10:22:29.994]             `[[` <- base::`[[`
[10:22:29.994]             `+` <- base::`+`
[10:22:29.994]             `<<-` <- base::`<<-`
[10:22:29.994]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:29.994]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:29.994]                   3L)]
[10:22:29.994]             }
[10:22:29.994]             function(cond) {
[10:22:29.994]                 is_error <- inherits(cond, "error")
[10:22:29.994]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:29.994]                   NULL)
[10:22:29.994]                 if (is_error) {
[10:22:29.994]                   sessionInformation <- function() {
[10:22:29.994]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:29.994]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:29.994]                       search = base::search(), system = base::Sys.info())
[10:22:29.994]                   }
[10:22:29.994]                   ...future.conditions[[length(...future.conditions) + 
[10:22:29.994]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:29.994]                     cond$call), session = sessionInformation(), 
[10:22:29.994]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:29.994]                   signalCondition(cond)
[10:22:29.994]                 }
[10:22:29.994]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:29.994]                 "immediateCondition"))) {
[10:22:29.994]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:29.994]                   ...future.conditions[[length(...future.conditions) + 
[10:22:29.994]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:29.994]                   if (TRUE && !signal) {
[10:22:29.994]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.994]                     {
[10:22:29.994]                       inherits <- base::inherits
[10:22:29.994]                       invokeRestart <- base::invokeRestart
[10:22:29.994]                       is.null <- base::is.null
[10:22:29.994]                       muffled <- FALSE
[10:22:29.994]                       if (inherits(cond, "message")) {
[10:22:29.994]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:29.994]                         if (muffled) 
[10:22:29.994]                           invokeRestart("muffleMessage")
[10:22:29.994]                       }
[10:22:29.994]                       else if (inherits(cond, "warning")) {
[10:22:29.994]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:29.994]                         if (muffled) 
[10:22:29.994]                           invokeRestart("muffleWarning")
[10:22:29.994]                       }
[10:22:29.994]                       else if (inherits(cond, "condition")) {
[10:22:29.994]                         if (!is.null(pattern)) {
[10:22:29.994]                           computeRestarts <- base::computeRestarts
[10:22:29.994]                           grepl <- base::grepl
[10:22:29.994]                           restarts <- computeRestarts(cond)
[10:22:29.994]                           for (restart in restarts) {
[10:22:29.994]                             name <- restart$name
[10:22:29.994]                             if (is.null(name)) 
[10:22:29.994]                               next
[10:22:29.994]                             if (!grepl(pattern, name)) 
[10:22:29.994]                               next
[10:22:29.994]                             invokeRestart(restart)
[10:22:29.994]                             muffled <- TRUE
[10:22:29.994]                             break
[10:22:29.994]                           }
[10:22:29.994]                         }
[10:22:29.994]                       }
[10:22:29.994]                       invisible(muffled)
[10:22:29.994]                     }
[10:22:29.994]                     muffleCondition(cond, pattern = "^muffle")
[10:22:29.994]                   }
[10:22:29.994]                 }
[10:22:29.994]                 else {
[10:22:29.994]                   if (TRUE) {
[10:22:29.994]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:29.994]                     {
[10:22:29.994]                       inherits <- base::inherits
[10:22:29.994]                       invokeRestart <- base::invokeRestart
[10:22:29.994]                       is.null <- base::is.null
[10:22:29.994]                       muffled <- FALSE
[10:22:29.994]                       if (inherits(cond, "message")) {
[10:22:29.994]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:29.994]                         if (muffled) 
[10:22:29.994]                           invokeRestart("muffleMessage")
[10:22:29.994]                       }
[10:22:29.994]                       else if (inherits(cond, "warning")) {
[10:22:29.994]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:29.994]                         if (muffled) 
[10:22:29.994]                           invokeRestart("muffleWarning")
[10:22:29.994]                       }
[10:22:29.994]                       else if (inherits(cond, "condition")) {
[10:22:29.994]                         if (!is.null(pattern)) {
[10:22:29.994]                           computeRestarts <- base::computeRestarts
[10:22:29.994]                           grepl <- base::grepl
[10:22:29.994]                           restarts <- computeRestarts(cond)
[10:22:29.994]                           for (restart in restarts) {
[10:22:29.994]                             name <- restart$name
[10:22:29.994]                             if (is.null(name)) 
[10:22:29.994]                               next
[10:22:29.994]                             if (!grepl(pattern, name)) 
[10:22:29.994]                               next
[10:22:29.994]                             invokeRestart(restart)
[10:22:29.994]                             muffled <- TRUE
[10:22:29.994]                             break
[10:22:29.994]                           }
[10:22:29.994]                         }
[10:22:29.994]                       }
[10:22:29.994]                       invisible(muffled)
[10:22:29.994]                     }
[10:22:29.994]                     muffleCondition(cond, pattern = "^muffle")
[10:22:29.994]                   }
[10:22:29.994]                 }
[10:22:29.994]             }
[10:22:29.994]         }))
[10:22:29.994]     }, error = function(ex) {
[10:22:29.994]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:29.994]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:29.994]                 ...future.rng), started = ...future.startTime, 
[10:22:29.994]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:29.994]             version = "1.8"), class = "FutureResult")
[10:22:29.994]     }, finally = {
[10:22:29.994]         if (!identical(...future.workdir, getwd())) 
[10:22:29.994]             setwd(...future.workdir)
[10:22:29.994]         {
[10:22:29.994]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:29.994]                 ...future.oldOptions$nwarnings <- NULL
[10:22:29.994]             }
[10:22:29.994]             base::options(...future.oldOptions)
[10:22:29.994]             if (.Platform$OS.type == "windows") {
[10:22:29.994]                 old_names <- names(...future.oldEnvVars)
[10:22:29.994]                 envs <- base::Sys.getenv()
[10:22:29.994]                 names <- names(envs)
[10:22:29.994]                 common <- intersect(names, old_names)
[10:22:29.994]                 added <- setdiff(names, old_names)
[10:22:29.994]                 removed <- setdiff(old_names, names)
[10:22:29.994]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:29.994]                   envs[common]]
[10:22:29.994]                 NAMES <- toupper(changed)
[10:22:29.994]                 args <- list()
[10:22:29.994]                 for (kk in seq_along(NAMES)) {
[10:22:29.994]                   name <- changed[[kk]]
[10:22:29.994]                   NAME <- NAMES[[kk]]
[10:22:29.994]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.994]                     next
[10:22:29.994]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:29.994]                 }
[10:22:29.994]                 NAMES <- toupper(added)
[10:22:29.994]                 for (kk in seq_along(NAMES)) {
[10:22:29.994]                   name <- added[[kk]]
[10:22:29.994]                   NAME <- NAMES[[kk]]
[10:22:29.994]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.994]                     next
[10:22:29.994]                   args[[name]] <- ""
[10:22:29.994]                 }
[10:22:29.994]                 NAMES <- toupper(removed)
[10:22:29.994]                 for (kk in seq_along(NAMES)) {
[10:22:29.994]                   name <- removed[[kk]]
[10:22:29.994]                   NAME <- NAMES[[kk]]
[10:22:29.994]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:29.994]                     next
[10:22:29.994]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:29.994]                 }
[10:22:29.994]                 if (length(args) > 0) 
[10:22:29.994]                   base::do.call(base::Sys.setenv, args = args)
[10:22:29.994]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:29.994]             }
[10:22:29.994]             else {
[10:22:29.994]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:29.994]             }
[10:22:29.994]             {
[10:22:29.994]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:29.994]                   0L) {
[10:22:29.994]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:29.994]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:29.994]                   base::options(opts)
[10:22:29.994]                 }
[10:22:29.994]                 {
[10:22:29.994]                   {
[10:22:29.994]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:29.994]                     NULL
[10:22:29.994]                   }
[10:22:29.994]                   options(future.plan = NULL)
[10:22:29.994]                   if (is.na(NA_character_)) 
[10:22:29.994]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:29.994]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:29.994]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:29.994]                     .init = FALSE)
[10:22:29.994]                 }
[10:22:29.994]             }
[10:22:29.994]         }
[10:22:29.994]     })
[10:22:29.994]     if (TRUE) {
[10:22:29.994]         base::sink(type = "output", split = FALSE)
[10:22:29.994]         if (TRUE) {
[10:22:29.994]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:29.994]         }
[10:22:29.994]         else {
[10:22:29.994]             ...future.result["stdout"] <- base::list(NULL)
[10:22:29.994]         }
[10:22:29.994]         base::close(...future.stdout)
[10:22:29.994]         ...future.stdout <- NULL
[10:22:29.994]     }
[10:22:29.994]     ...future.result$conditions <- ...future.conditions
[10:22:29.994]     ...future.result$finished <- base::Sys.time()
[10:22:29.994]     ...future.result
[10:22:29.994] }
[10:22:29.998] requestCore(): workers = 2
[10:22:29.998] Poll #1 (0): usedCores() = 2, workers = 2
[10:22:30.009] result() for MulticoreFuture ...
[10:22:30.010] result() for MulticoreFuture ...
[10:22:30.010] result() for MulticoreFuture ... done
[10:22:30.010] result() for MulticoreFuture ... done
[10:22:30.011] result() for MulticoreFuture ...
[10:22:30.011] result() for MulticoreFuture ... done
[10:22:30.013] MulticoreFuture started
[10:22:30.014] - Launch lazy future ... done
[10:22:30.014] run() for ‘MulticoreFuture’ ... done
[10:22:30.014] plan(): Setting new future strategy stack:
[10:22:30.015] List of future strategies:
[10:22:30.015] 1. sequential:
[10:22:30.015]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:30.015]    - tweaked: FALSE
[10:22:30.015]    - call: NULL
[10:22:30.016] plan(): nbrOfWorkers() = 1
[10:22:30.018] plan(): Setting new future strategy stack:
[10:22:30.018] List of future strategies:
[10:22:30.018] 1. multicore:
[10:22:30.018]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:30.018]    - tweaked: FALSE
[10:22:30.018]    - call: plan(strategy)
[10:22:30.021] plan(): nbrOfWorkers() = 2
[10:22:30.022] Future #2
[10:22:30.022]  length: 1 (resolved future 2)
[10:22:30.022]  length: 0 (resolved future 3)
[10:22:30.023] resolve() on list ... DONE
[10:22:30.023] getGlobalsAndPackages() ...
[10:22:30.023] Searching for globals...
[10:22:30.024] 
[10:22:30.024] Searching for globals ... DONE
[10:22:30.024] - globals: [0] <none>
[10:22:30.025] getGlobalsAndPackages() ... DONE
[10:22:30.025] run() for ‘Future’ ...
[10:22:30.025] - state: ‘created’
[10:22:30.026] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:30.028] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:30.028] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:30.028]   - Field: ‘label’
[10:22:30.029]   - Field: ‘local’
[10:22:30.029]   - Field: ‘owner’
[10:22:30.029]   - Field: ‘envir’
[10:22:30.029]   - Field: ‘workers’
[10:22:30.029]   - Field: ‘packages’
[10:22:30.029]   - Field: ‘gc’
[10:22:30.030]   - Field: ‘job’
[10:22:30.030]   - Field: ‘conditions’
[10:22:30.030]   - Field: ‘expr’
[10:22:30.030]   - Field: ‘uuid’
[10:22:30.030]   - Field: ‘seed’
[10:22:30.030]   - Field: ‘version’
[10:22:30.030]   - Field: ‘result’
[10:22:30.031]   - Field: ‘asynchronous’
[10:22:30.031]   - Field: ‘calls’
[10:22:30.031]   - Field: ‘globals’
[10:22:30.031]   - Field: ‘stdout’
[10:22:30.031]   - Field: ‘earlySignal’
[10:22:30.031]   - Field: ‘lazy’
[10:22:30.031]   - Field: ‘state’
[10:22:30.031] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:30.032] - Launch lazy future ...
[10:22:30.032] Packages needed by the future expression (n = 0): <none>
[10:22:30.032] Packages needed by future strategies (n = 0): <none>
[10:22:30.033] {
[10:22:30.033]     {
[10:22:30.033]         {
[10:22:30.033]             ...future.startTime <- base::Sys.time()
[10:22:30.033]             {
[10:22:30.033]                 {
[10:22:30.033]                   {
[10:22:30.033]                     {
[10:22:30.033]                       base::local({
[10:22:30.033]                         has_future <- base::requireNamespace("future", 
[10:22:30.033]                           quietly = TRUE)
[10:22:30.033]                         if (has_future) {
[10:22:30.033]                           ns <- base::getNamespace("future")
[10:22:30.033]                           version <- ns[[".package"]][["version"]]
[10:22:30.033]                           if (is.null(version)) 
[10:22:30.033]                             version <- utils::packageVersion("future")
[10:22:30.033]                         }
[10:22:30.033]                         else {
[10:22:30.033]                           version <- NULL
[10:22:30.033]                         }
[10:22:30.033]                         if (!has_future || version < "1.8.0") {
[10:22:30.033]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:30.033]                             "", base::R.version$version.string), 
[10:22:30.033]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:30.033]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:30.033]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:30.033]                               "release", "version")], collapse = " "), 
[10:22:30.033]                             hostname = base::Sys.info()[["nodename"]])
[10:22:30.033]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:30.033]                             info)
[10:22:30.033]                           info <- base::paste(info, collapse = "; ")
[10:22:30.033]                           if (!has_future) {
[10:22:30.033]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:30.033]                               info)
[10:22:30.033]                           }
[10:22:30.033]                           else {
[10:22:30.033]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:30.033]                               info, version)
[10:22:30.033]                           }
[10:22:30.033]                           base::stop(msg)
[10:22:30.033]                         }
[10:22:30.033]                       })
[10:22:30.033]                     }
[10:22:30.033]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:30.033]                     base::options(mc.cores = 1L)
[10:22:30.033]                   }
[10:22:30.033]                   ...future.strategy.old <- future::plan("list")
[10:22:30.033]                   options(future.plan = NULL)
[10:22:30.033]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:30.033]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:30.033]                 }
[10:22:30.033]                 ...future.workdir <- getwd()
[10:22:30.033]             }
[10:22:30.033]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:30.033]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:30.033]         }
[10:22:30.033]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:30.033]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:30.033]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:30.033]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:30.033]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:30.033]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:30.033]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:30.033]             base::names(...future.oldOptions))
[10:22:30.033]     }
[10:22:30.033]     if (FALSE) {
[10:22:30.033]     }
[10:22:30.033]     else {
[10:22:30.033]         if (TRUE) {
[10:22:30.033]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:30.033]                 open = "w")
[10:22:30.033]         }
[10:22:30.033]         else {
[10:22:30.033]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:30.033]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:30.033]         }
[10:22:30.033]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:30.033]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:30.033]             base::sink(type = "output", split = FALSE)
[10:22:30.033]             base::close(...future.stdout)
[10:22:30.033]         }, add = TRUE)
[10:22:30.033]     }
[10:22:30.033]     ...future.frame <- base::sys.nframe()
[10:22:30.033]     ...future.conditions <- base::list()
[10:22:30.033]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:30.033]     if (FALSE) {
[10:22:30.033]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:30.033]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:30.033]     }
[10:22:30.033]     ...future.result <- base::tryCatch({
[10:22:30.033]         base::withCallingHandlers({
[10:22:30.033]             ...future.value <- base::withVisible(base::local({
[10:22:30.033]                 withCallingHandlers({
[10:22:30.033]                   1
[10:22:30.033]                 }, immediateCondition = function(cond) {
[10:22:30.033]                   save_rds <- function (object, pathname, ...) 
[10:22:30.033]                   {
[10:22:30.033]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:30.033]                     if (file_test("-f", pathname_tmp)) {
[10:22:30.033]                       fi_tmp <- file.info(pathname_tmp)
[10:22:30.033]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:30.033]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:30.033]                         fi_tmp[["mtime"]])
[10:22:30.033]                     }
[10:22:30.033]                     tryCatch({
[10:22:30.033]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:30.033]                     }, error = function(ex) {
[10:22:30.033]                       msg <- conditionMessage(ex)
[10:22:30.033]                       fi_tmp <- file.info(pathname_tmp)
[10:22:30.033]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:30.033]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:30.033]                         fi_tmp[["mtime"]], msg)
[10:22:30.033]                       ex$message <- msg
[10:22:30.033]                       stop(ex)
[10:22:30.033]                     })
[10:22:30.033]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:30.033]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:30.033]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:30.033]                       fi_tmp <- file.info(pathname_tmp)
[10:22:30.033]                       fi <- file.info(pathname)
[10:22:30.033]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:30.033]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:30.033]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:30.033]                         fi[["size"]], fi[["mtime"]])
[10:22:30.033]                       stop(msg)
[10:22:30.033]                     }
[10:22:30.033]                     invisible(pathname)
[10:22:30.033]                   }
[10:22:30.033]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:30.033]                     rootPath = tempdir()) 
[10:22:30.033]                   {
[10:22:30.033]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:30.033]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:30.033]                       tmpdir = path, fileext = ".rds")
[10:22:30.033]                     save_rds(obj, file)
[10:22:30.033]                   }
[10:22:30.033]                   saveImmediateCondition(cond, path = "/tmp/RtmpzsJv4f/.future/immediateConditions")
[10:22:30.033]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:30.033]                   {
[10:22:30.033]                     inherits <- base::inherits
[10:22:30.033]                     invokeRestart <- base::invokeRestart
[10:22:30.033]                     is.null <- base::is.null
[10:22:30.033]                     muffled <- FALSE
[10:22:30.033]                     if (inherits(cond, "message")) {
[10:22:30.033]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:30.033]                       if (muffled) 
[10:22:30.033]                         invokeRestart("muffleMessage")
[10:22:30.033]                     }
[10:22:30.033]                     else if (inherits(cond, "warning")) {
[10:22:30.033]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:30.033]                       if (muffled) 
[10:22:30.033]                         invokeRestart("muffleWarning")
[10:22:30.033]                     }
[10:22:30.033]                     else if (inherits(cond, "condition")) {
[10:22:30.033]                       if (!is.null(pattern)) {
[10:22:30.033]                         computeRestarts <- base::computeRestarts
[10:22:30.033]                         grepl <- base::grepl
[10:22:30.033]                         restarts <- computeRestarts(cond)
[10:22:30.033]                         for (restart in restarts) {
[10:22:30.033]                           name <- restart$name
[10:22:30.033]                           if (is.null(name)) 
[10:22:30.033]                             next
[10:22:30.033]                           if (!grepl(pattern, name)) 
[10:22:30.033]                             next
[10:22:30.033]                           invokeRestart(restart)
[10:22:30.033]                           muffled <- TRUE
[10:22:30.033]                           break
[10:22:30.033]                         }
[10:22:30.033]                       }
[10:22:30.033]                     }
[10:22:30.033]                     invisible(muffled)
[10:22:30.033]                   }
[10:22:30.033]                   muffleCondition(cond)
[10:22:30.033]                 })
[10:22:30.033]             }))
[10:22:30.033]             future::FutureResult(value = ...future.value$value, 
[10:22:30.033]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:30.033]                   ...future.rng), globalenv = if (FALSE) 
[10:22:30.033]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:30.033]                     ...future.globalenv.names))
[10:22:30.033]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:30.033]         }, condition = base::local({
[10:22:30.033]             c <- base::c
[10:22:30.033]             inherits <- base::inherits
[10:22:30.033]             invokeRestart <- base::invokeRestart
[10:22:30.033]             length <- base::length
[10:22:30.033]             list <- base::list
[10:22:30.033]             seq.int <- base::seq.int
[10:22:30.033]             signalCondition <- base::signalCondition
[10:22:30.033]             sys.calls <- base::sys.calls
[10:22:30.033]             `[[` <- base::`[[`
[10:22:30.033]             `+` <- base::`+`
[10:22:30.033]             `<<-` <- base::`<<-`
[10:22:30.033]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:30.033]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:30.033]                   3L)]
[10:22:30.033]             }
[10:22:30.033]             function(cond) {
[10:22:30.033]                 is_error <- inherits(cond, "error")
[10:22:30.033]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:30.033]                   NULL)
[10:22:30.033]                 if (is_error) {
[10:22:30.033]                   sessionInformation <- function() {
[10:22:30.033]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:30.033]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:30.033]                       search = base::search(), system = base::Sys.info())
[10:22:30.033]                   }
[10:22:30.033]                   ...future.conditions[[length(...future.conditions) + 
[10:22:30.033]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:30.033]                     cond$call), session = sessionInformation(), 
[10:22:30.033]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:30.033]                   signalCondition(cond)
[10:22:30.033]                 }
[10:22:30.033]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:30.033]                 "immediateCondition"))) {
[10:22:30.033]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:30.033]                   ...future.conditions[[length(...future.conditions) + 
[10:22:30.033]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:30.033]                   if (TRUE && !signal) {
[10:22:30.033]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:30.033]                     {
[10:22:30.033]                       inherits <- base::inherits
[10:22:30.033]                       invokeRestart <- base::invokeRestart
[10:22:30.033]                       is.null <- base::is.null
[10:22:30.033]                       muffled <- FALSE
[10:22:30.033]                       if (inherits(cond, "message")) {
[10:22:30.033]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:30.033]                         if (muffled) 
[10:22:30.033]                           invokeRestart("muffleMessage")
[10:22:30.033]                       }
[10:22:30.033]                       else if (inherits(cond, "warning")) {
[10:22:30.033]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:30.033]                         if (muffled) 
[10:22:30.033]                           invokeRestart("muffleWarning")
[10:22:30.033]                       }
[10:22:30.033]                       else if (inherits(cond, "condition")) {
[10:22:30.033]                         if (!is.null(pattern)) {
[10:22:30.033]                           computeRestarts <- base::computeRestarts
[10:22:30.033]                           grepl <- base::grepl
[10:22:30.033]                           restarts <- computeRestarts(cond)
[10:22:30.033]                           for (restart in restarts) {
[10:22:30.033]                             name <- restart$name
[10:22:30.033]                             if (is.null(name)) 
[10:22:30.033]                               next
[10:22:30.033]                             if (!grepl(pattern, name)) 
[10:22:30.033]                               next
[10:22:30.033]                             invokeRestart(restart)
[10:22:30.033]                             muffled <- TRUE
[10:22:30.033]                             break
[10:22:30.033]                           }
[10:22:30.033]                         }
[10:22:30.033]                       }
[10:22:30.033]                       invisible(muffled)
[10:22:30.033]                     }
[10:22:30.033]                     muffleCondition(cond, pattern = "^muffle")
[10:22:30.033]                   }
[10:22:30.033]                 }
[10:22:30.033]                 else {
[10:22:30.033]                   if (TRUE) {
[10:22:30.033]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:30.033]                     {
[10:22:30.033]                       inherits <- base::inherits
[10:22:30.033]                       invokeRestart <- base::invokeRestart
[10:22:30.033]                       is.null <- base::is.null
[10:22:30.033]                       muffled <- FALSE
[10:22:30.033]                       if (inherits(cond, "message")) {
[10:22:30.033]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:30.033]                         if (muffled) 
[10:22:30.033]                           invokeRestart("muffleMessage")
[10:22:30.033]                       }
[10:22:30.033]                       else if (inherits(cond, "warning")) {
[10:22:30.033]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:30.033]                         if (muffled) 
[10:22:30.033]                           invokeRestart("muffleWarning")
[10:22:30.033]                       }
[10:22:30.033]                       else if (inherits(cond, "condition")) {
[10:22:30.033]                         if (!is.null(pattern)) {
[10:22:30.033]                           computeRestarts <- base::computeRestarts
[10:22:30.033]                           grepl <- base::grepl
[10:22:30.033]                           restarts <- computeRestarts(cond)
[10:22:30.033]                           for (restart in restarts) {
[10:22:30.033]                             name <- restart$name
[10:22:30.033]                             if (is.null(name)) 
[10:22:30.033]                               next
[10:22:30.033]                             if (!grepl(pattern, name)) 
[10:22:30.033]                               next
[10:22:30.033]                             invokeRestart(restart)
[10:22:30.033]                             muffled <- TRUE
[10:22:30.033]                             break
[10:22:30.033]                           }
[10:22:30.033]                         }
[10:22:30.033]                       }
[10:22:30.033]                       invisible(muffled)
[10:22:30.033]                     }
[10:22:30.033]                     muffleCondition(cond, pattern = "^muffle")
[10:22:30.033]                   }
[10:22:30.033]                 }
[10:22:30.033]             }
[10:22:30.033]         }))
[10:22:30.033]     }, error = function(ex) {
[10:22:30.033]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:30.033]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:30.033]                 ...future.rng), started = ...future.startTime, 
[10:22:30.033]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:30.033]             version = "1.8"), class = "FutureResult")
[10:22:30.033]     }, finally = {
[10:22:30.033]         if (!identical(...future.workdir, getwd())) 
[10:22:30.033]             setwd(...future.workdir)
[10:22:30.033]         {
[10:22:30.033]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:30.033]                 ...future.oldOptions$nwarnings <- NULL
[10:22:30.033]             }
[10:22:30.033]             base::options(...future.oldOptions)
[10:22:30.033]             if (.Platform$OS.type == "windows") {
[10:22:30.033]                 old_names <- names(...future.oldEnvVars)
[10:22:30.033]                 envs <- base::Sys.getenv()
[10:22:30.033]                 names <- names(envs)
[10:22:30.033]                 common <- intersect(names, old_names)
[10:22:30.033]                 added <- setdiff(names, old_names)
[10:22:30.033]                 removed <- setdiff(old_names, names)
[10:22:30.033]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:30.033]                   envs[common]]
[10:22:30.033]                 NAMES <- toupper(changed)
[10:22:30.033]                 args <- list()
[10:22:30.033]                 for (kk in seq_along(NAMES)) {
[10:22:30.033]                   name <- changed[[kk]]
[10:22:30.033]                   NAME <- NAMES[[kk]]
[10:22:30.033]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:30.033]                     next
[10:22:30.033]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:30.033]                 }
[10:22:30.033]                 NAMES <- toupper(added)
[10:22:30.033]                 for (kk in seq_along(NAMES)) {
[10:22:30.033]                   name <- added[[kk]]
[10:22:30.033]                   NAME <- NAMES[[kk]]
[10:22:30.033]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:30.033]                     next
[10:22:30.033]                   args[[name]] <- ""
[10:22:30.033]                 }
[10:22:30.033]                 NAMES <- toupper(removed)
[10:22:30.033]                 for (kk in seq_along(NAMES)) {
[10:22:30.033]                   name <- removed[[kk]]
[10:22:30.033]                   NAME <- NAMES[[kk]]
[10:22:30.033]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:30.033]                     next
[10:22:30.033]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:30.033]                 }
[10:22:30.033]                 if (length(args) > 0) 
[10:22:30.033]                   base::do.call(base::Sys.setenv, args = args)
[10:22:30.033]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:30.033]             }
[10:22:30.033]             else {
[10:22:30.033]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:30.033]             }
[10:22:30.033]             {
[10:22:30.033]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:30.033]                   0L) {
[10:22:30.033]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:30.033]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:30.033]                   base::options(opts)
[10:22:30.033]                 }
[10:22:30.033]                 {
[10:22:30.033]                   {
[10:22:30.033]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:30.033]                     NULL
[10:22:30.033]                   }
[10:22:30.033]                   options(future.plan = NULL)
[10:22:30.033]                   if (is.na(NA_character_)) 
[10:22:30.033]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:30.033]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:30.033]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:30.033]                     .init = FALSE)
[10:22:30.033]                 }
[10:22:30.033]             }
[10:22:30.033]         }
[10:22:30.033]     })
[10:22:30.033]     if (TRUE) {
[10:22:30.033]         base::sink(type = "output", split = FALSE)
[10:22:30.033]         if (TRUE) {
[10:22:30.033]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:30.033]         }
[10:22:30.033]         else {
[10:22:30.033]             ...future.result["stdout"] <- base::list(NULL)
[10:22:30.033]         }
[10:22:30.033]         base::close(...future.stdout)
[10:22:30.033]         ...future.stdout <- NULL
[10:22:30.033]     }
[10:22:30.033]     ...future.result$conditions <- ...future.conditions
[10:22:30.033]     ...future.result$finished <- base::Sys.time()
[10:22:30.033]     ...future.result
[10:22:30.033] }
[10:22:30.036] requestCore(): workers = 2
[10:22:30.037] Poll #1 (0): usedCores() = 2, workers = 2
[10:22:30.048] result() for MulticoreFuture ...
[10:22:30.049] result() for MulticoreFuture ...
[10:22:30.049] result() for MulticoreFuture ... done
[10:22:30.049] result() for MulticoreFuture ... done
[10:22:30.049] result() for MulticoreFuture ...
[10:22:30.049] result() for MulticoreFuture ... done
[10:22:30.052] MulticoreFuture started
[10:22:30.052] - Launch lazy future ... done
[10:22:30.052] run() for ‘MulticoreFuture’ ... done
[10:22:30.053] getGlobalsAndPackages() ...
[10:22:30.053] plan(): Setting new future strategy stack:
[10:22:30.053] Searching for globals...
[10:22:30.053] List of future strategies:
[10:22:30.053] 1. sequential:
[10:22:30.053]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:30.053]    - tweaked: FALSE
[10:22:30.053]    - call: NULL
[10:22:30.054] plan(): nbrOfWorkers() = 1
[10:22:30.056] - globals found: [2] ‘{’, ‘Sys.sleep’
[10:22:30.056] Searching for globals ... DONE
[10:22:30.056] Resolving globals: FALSE
[10:22:30.057] 
[10:22:30.057] 
[10:22:30.057] plan(): Setting new future strategy stack:
[10:22:30.058] getGlobalsAndPackages() ... DONE
[10:22:30.058] List of future strategies:
[10:22:30.058] 1. multicore:
[10:22:30.058]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:30.058]    - tweaked: FALSE
[10:22:30.058]    - call: plan(strategy)
[10:22:30.058] run() for ‘Future’ ...
[10:22:30.058] - state: ‘created’
[10:22:30.059] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:30.062] plan(): nbrOfWorkers() = 2
[10:22:30.067] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:30.068] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:30.068]   - Field: ‘label’
[10:22:30.068]   - Field: ‘local’
[10:22:30.069]   - Field: ‘owner’
[10:22:30.069]   - Field: ‘envir’
[10:22:30.069]   - Field: ‘workers’
[10:22:30.070]   - Field: ‘packages’
[10:22:30.070]   - Field: ‘gc’
[10:22:30.070]   - Field: ‘job’
[10:22:30.071]   - Field: ‘conditions’
[10:22:30.071]   - Field: ‘expr’
[10:22:30.071]   - Field: ‘uuid’
[10:22:30.071]   - Field: ‘seed’
[10:22:30.071]   - Field: ‘version’
[10:22:30.072]   - Field: ‘result’
[10:22:30.072]   - Field: ‘asynchronous’
[10:22:30.072]   - Field: ‘calls’
[10:22:30.072]   - Field: ‘globals’
[10:22:30.072]   - Field: ‘stdout’
[10:22:30.073]   - Field: ‘earlySignal’
[10:22:30.073]   - Field: ‘lazy’
[10:22:30.073]   - Field: ‘state’
[10:22:30.073] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:30.073] - Launch lazy future ...
[10:22:30.074] Packages needed by the future expression (n = 0): <none>
[10:22:30.074] Packages needed by future strategies (n = 0): <none>
[10:22:30.075] {
[10:22:30.075]     {
[10:22:30.075]         {
[10:22:30.075]             ...future.startTime <- base::Sys.time()
[10:22:30.075]             {
[10:22:30.075]                 {
[10:22:30.075]                   {
[10:22:30.075]                     {
[10:22:30.075]                       base::local({
[10:22:30.075]                         has_future <- base::requireNamespace("future", 
[10:22:30.075]                           quietly = TRUE)
[10:22:30.075]                         if (has_future) {
[10:22:30.075]                           ns <- base::getNamespace("future")
[10:22:30.075]                           version <- ns[[".package"]][["version"]]
[10:22:30.075]                           if (is.null(version)) 
[10:22:30.075]                             version <- utils::packageVersion("future")
[10:22:30.075]                         }
[10:22:30.075]                         else {
[10:22:30.075]                           version <- NULL
[10:22:30.075]                         }
[10:22:30.075]                         if (!has_future || version < "1.8.0") {
[10:22:30.075]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:30.075]                             "", base::R.version$version.string), 
[10:22:30.075]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:30.075]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:30.075]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:30.075]                               "release", "version")], collapse = " "), 
[10:22:30.075]                             hostname = base::Sys.info()[["nodename"]])
[10:22:30.075]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:30.075]                             info)
[10:22:30.075]                           info <- base::paste(info, collapse = "; ")
[10:22:30.075]                           if (!has_future) {
[10:22:30.075]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:30.075]                               info)
[10:22:30.075]                           }
[10:22:30.075]                           else {
[10:22:30.075]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:30.075]                               info, version)
[10:22:30.075]                           }
[10:22:30.075]                           base::stop(msg)
[10:22:30.075]                         }
[10:22:30.075]                       })
[10:22:30.075]                     }
[10:22:30.075]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:30.075]                     base::options(mc.cores = 1L)
[10:22:30.075]                   }
[10:22:30.075]                   ...future.strategy.old <- future::plan("list")
[10:22:30.075]                   options(future.plan = NULL)
[10:22:30.075]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:30.075]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:30.075]                 }
[10:22:30.075]                 ...future.workdir <- getwd()
[10:22:30.075]             }
[10:22:30.075]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:30.075]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:30.075]         }
[10:22:30.075]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:30.075]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:30.075]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:30.075]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:30.075]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:30.075]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:30.075]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:30.075]             base::names(...future.oldOptions))
[10:22:30.075]     }
[10:22:30.075]     if (FALSE) {
[10:22:30.075]     }
[10:22:30.075]     else {
[10:22:30.075]         if (TRUE) {
[10:22:30.075]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:30.075]                 open = "w")
[10:22:30.075]         }
[10:22:30.075]         else {
[10:22:30.075]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:30.075]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:30.075]         }
[10:22:30.075]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:30.075]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:30.075]             base::sink(type = "output", split = FALSE)
[10:22:30.075]             base::close(...future.stdout)
[10:22:30.075]         }, add = TRUE)
[10:22:30.075]     }
[10:22:30.075]     ...future.frame <- base::sys.nframe()
[10:22:30.075]     ...future.conditions <- base::list()
[10:22:30.075]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:30.075]     if (FALSE) {
[10:22:30.075]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:30.075]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:30.075]     }
[10:22:30.075]     ...future.result <- base::tryCatch({
[10:22:30.075]         base::withCallingHandlers({
[10:22:30.075]             ...future.value <- base::withVisible(base::local({
[10:22:30.075]                 withCallingHandlers({
[10:22:30.075]                   {
[10:22:30.075]                     Sys.sleep(0.5)
[10:22:30.075]                     2
[10:22:30.075]                   }
[10:22:30.075]                 }, immediateCondition = function(cond) {
[10:22:30.075]                   save_rds <- function (object, pathname, ...) 
[10:22:30.075]                   {
[10:22:30.075]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:30.075]                     if (file_test("-f", pathname_tmp)) {
[10:22:30.075]                       fi_tmp <- file.info(pathname_tmp)
[10:22:30.075]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:30.075]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:30.075]                         fi_tmp[["mtime"]])
[10:22:30.075]                     }
[10:22:30.075]                     tryCatch({
[10:22:30.075]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:30.075]                     }, error = function(ex) {
[10:22:30.075]                       msg <- conditionMessage(ex)
[10:22:30.075]                       fi_tmp <- file.info(pathname_tmp)
[10:22:30.075]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:30.075]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:30.075]                         fi_tmp[["mtime"]], msg)
[10:22:30.075]                       ex$message <- msg
[10:22:30.075]                       stop(ex)
[10:22:30.075]                     })
[10:22:30.075]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:30.075]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:30.075]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:30.075]                       fi_tmp <- file.info(pathname_tmp)
[10:22:30.075]                       fi <- file.info(pathname)
[10:22:30.075]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:30.075]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:30.075]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:30.075]                         fi[["size"]], fi[["mtime"]])
[10:22:30.075]                       stop(msg)
[10:22:30.075]                     }
[10:22:30.075]                     invisible(pathname)
[10:22:30.075]                   }
[10:22:30.075]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:30.075]                     rootPath = tempdir()) 
[10:22:30.075]                   {
[10:22:30.075]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:30.075]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:30.075]                       tmpdir = path, fileext = ".rds")
[10:22:30.075]                     save_rds(obj, file)
[10:22:30.075]                   }
[10:22:30.075]                   saveImmediateCondition(cond, path = "/tmp/RtmpzsJv4f/.future/immediateConditions")
[10:22:30.075]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:30.075]                   {
[10:22:30.075]                     inherits <- base::inherits
[10:22:30.075]                     invokeRestart <- base::invokeRestart
[10:22:30.075]                     is.null <- base::is.null
[10:22:30.075]                     muffled <- FALSE
[10:22:30.075]                     if (inherits(cond, "message")) {
[10:22:30.075]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:30.075]                       if (muffled) 
[10:22:30.075]                         invokeRestart("muffleMessage")
[10:22:30.075]                     }
[10:22:30.075]                     else if (inherits(cond, "warning")) {
[10:22:30.075]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:30.075]                       if (muffled) 
[10:22:30.075]                         invokeRestart("muffleWarning")
[10:22:30.075]                     }
[10:22:30.075]                     else if (inherits(cond, "condition")) {
[10:22:30.075]                       if (!is.null(pattern)) {
[10:22:30.075]                         computeRestarts <- base::computeRestarts
[10:22:30.075]                         grepl <- base::grepl
[10:22:30.075]                         restarts <- computeRestarts(cond)
[10:22:30.075]                         for (restart in restarts) {
[10:22:30.075]                           name <- restart$name
[10:22:30.075]                           if (is.null(name)) 
[10:22:30.075]                             next
[10:22:30.075]                           if (!grepl(pattern, name)) 
[10:22:30.075]                             next
[10:22:30.075]                           invokeRestart(restart)
[10:22:30.075]                           muffled <- TRUE
[10:22:30.075]                           break
[10:22:30.075]                         }
[10:22:30.075]                       }
[10:22:30.075]                     }
[10:22:30.075]                     invisible(muffled)
[10:22:30.075]                   }
[10:22:30.075]                   muffleCondition(cond)
[10:22:30.075]                 })
[10:22:30.075]             }))
[10:22:30.075]             future::FutureResult(value = ...future.value$value, 
[10:22:30.075]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:30.075]                   ...future.rng), globalenv = if (FALSE) 
[10:22:30.075]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:30.075]                     ...future.globalenv.names))
[10:22:30.075]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:30.075]         }, condition = base::local({
[10:22:30.075]             c <- base::c
[10:22:30.075]             inherits <- base::inherits
[10:22:30.075]             invokeRestart <- base::invokeRestart
[10:22:30.075]             length <- base::length
[10:22:30.075]             list <- base::list
[10:22:30.075]             seq.int <- base::seq.int
[10:22:30.075]             signalCondition <- base::signalCondition
[10:22:30.075]             sys.calls <- base::sys.calls
[10:22:30.075]             `[[` <- base::`[[`
[10:22:30.075]             `+` <- base::`+`
[10:22:30.075]             `<<-` <- base::`<<-`
[10:22:30.075]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:30.075]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:30.075]                   3L)]
[10:22:30.075]             }
[10:22:30.075]             function(cond) {
[10:22:30.075]                 is_error <- inherits(cond, "error")
[10:22:30.075]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:30.075]                   NULL)
[10:22:30.075]                 if (is_error) {
[10:22:30.075]                   sessionInformation <- function() {
[10:22:30.075]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:30.075]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:30.075]                       search = base::search(), system = base::Sys.info())
[10:22:30.075]                   }
[10:22:30.075]                   ...future.conditions[[length(...future.conditions) + 
[10:22:30.075]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:30.075]                     cond$call), session = sessionInformation(), 
[10:22:30.075]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:30.075]                   signalCondition(cond)
[10:22:30.075]                 }
[10:22:30.075]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:30.075]                 "immediateCondition"))) {
[10:22:30.075]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:30.075]                   ...future.conditions[[length(...future.conditions) + 
[10:22:30.075]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:30.075]                   if (TRUE && !signal) {
[10:22:30.075]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:30.075]                     {
[10:22:30.075]                       inherits <- base::inherits
[10:22:30.075]                       invokeRestart <- base::invokeRestart
[10:22:30.075]                       is.null <- base::is.null
[10:22:30.075]                       muffled <- FALSE
[10:22:30.075]                       if (inherits(cond, "message")) {
[10:22:30.075]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:30.075]                         if (muffled) 
[10:22:30.075]                           invokeRestart("muffleMessage")
[10:22:30.075]                       }
[10:22:30.075]                       else if (inherits(cond, "warning")) {
[10:22:30.075]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:30.075]                         if (muffled) 
[10:22:30.075]                           invokeRestart("muffleWarning")
[10:22:30.075]                       }
[10:22:30.075]                       else if (inherits(cond, "condition")) {
[10:22:30.075]                         if (!is.null(pattern)) {
[10:22:30.075]                           computeRestarts <- base::computeRestarts
[10:22:30.075]                           grepl <- base::grepl
[10:22:30.075]                           restarts <- computeRestarts(cond)
[10:22:30.075]                           for (restart in restarts) {
[10:22:30.075]                             name <- restart$name
[10:22:30.075]                             if (is.null(name)) 
[10:22:30.075]                               next
[10:22:30.075]                             if (!grepl(pattern, name)) 
[10:22:30.075]                               next
[10:22:30.075]                             invokeRestart(restart)
[10:22:30.075]                             muffled <- TRUE
[10:22:30.075]                             break
[10:22:30.075]                           }
[10:22:30.075]                         }
[10:22:30.075]                       }
[10:22:30.075]                       invisible(muffled)
[10:22:30.075]                     }
[10:22:30.075]                     muffleCondition(cond, pattern = "^muffle")
[10:22:30.075]                   }
[10:22:30.075]                 }
[10:22:30.075]                 else {
[10:22:30.075]                   if (TRUE) {
[10:22:30.075]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:30.075]                     {
[10:22:30.075]                       inherits <- base::inherits
[10:22:30.075]                       invokeRestart <- base::invokeRestart
[10:22:30.075]                       is.null <- base::is.null
[10:22:30.075]                       muffled <- FALSE
[10:22:30.075]                       if (inherits(cond, "message")) {
[10:22:30.075]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:30.075]                         if (muffled) 
[10:22:30.075]                           invokeRestart("muffleMessage")
[10:22:30.075]                       }
[10:22:30.075]                       else if (inherits(cond, "warning")) {
[10:22:30.075]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:30.075]                         if (muffled) 
[10:22:30.075]                           invokeRestart("muffleWarning")
[10:22:30.075]                       }
[10:22:30.075]                       else if (inherits(cond, "condition")) {
[10:22:30.075]                         if (!is.null(pattern)) {
[10:22:30.075]                           computeRestarts <- base::computeRestarts
[10:22:30.075]                           grepl <- base::grepl
[10:22:30.075]                           restarts <- computeRestarts(cond)
[10:22:30.075]                           for (restart in restarts) {
[10:22:30.075]                             name <- restart$name
[10:22:30.075]                             if (is.null(name)) 
[10:22:30.075]                               next
[10:22:30.075]                             if (!grepl(pattern, name)) 
[10:22:30.075]                               next
[10:22:30.075]                             invokeRestart(restart)
[10:22:30.075]                             muffled <- TRUE
[10:22:30.075]                             break
[10:22:30.075]                           }
[10:22:30.075]                         }
[10:22:30.075]                       }
[10:22:30.075]                       invisible(muffled)
[10:22:30.075]                     }
[10:22:30.075]                     muffleCondition(cond, pattern = "^muffle")
[10:22:30.075]                   }
[10:22:30.075]                 }
[10:22:30.075]             }
[10:22:30.075]         }))
[10:22:30.075]     }, error = function(ex) {
[10:22:30.075]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:30.075]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:30.075]                 ...future.rng), started = ...future.startTime, 
[10:22:30.075]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:30.075]             version = "1.8"), class = "FutureResult")
[10:22:30.075]     }, finally = {
[10:22:30.075]         if (!identical(...future.workdir, getwd())) 
[10:22:30.075]             setwd(...future.workdir)
[10:22:30.075]         {
[10:22:30.075]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:30.075]                 ...future.oldOptions$nwarnings <- NULL
[10:22:30.075]             }
[10:22:30.075]             base::options(...future.oldOptions)
[10:22:30.075]             if (.Platform$OS.type == "windows") {
[10:22:30.075]                 old_names <- names(...future.oldEnvVars)
[10:22:30.075]                 envs <- base::Sys.getenv()
[10:22:30.075]                 names <- names(envs)
[10:22:30.075]                 common <- intersect(names, old_names)
[10:22:30.075]                 added <- setdiff(names, old_names)
[10:22:30.075]                 removed <- setdiff(old_names, names)
[10:22:30.075]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:30.075]                   envs[common]]
[10:22:30.075]                 NAMES <- toupper(changed)
[10:22:30.075]                 args <- list()
[10:22:30.075]                 for (kk in seq_along(NAMES)) {
[10:22:30.075]                   name <- changed[[kk]]
[10:22:30.075]                   NAME <- NAMES[[kk]]
[10:22:30.075]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:30.075]                     next
[10:22:30.075]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:30.075]                 }
[10:22:30.075]                 NAMES <- toupper(added)
[10:22:30.075]                 for (kk in seq_along(NAMES)) {
[10:22:30.075]                   name <- added[[kk]]
[10:22:30.075]                   NAME <- NAMES[[kk]]
[10:22:30.075]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:30.075]                     next
[10:22:30.075]                   args[[name]] <- ""
[10:22:30.075]                 }
[10:22:30.075]                 NAMES <- toupper(removed)
[10:22:30.075]                 for (kk in seq_along(NAMES)) {
[10:22:30.075]                   name <- removed[[kk]]
[10:22:30.075]                   NAME <- NAMES[[kk]]
[10:22:30.075]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:30.075]                     next
[10:22:30.075]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:30.075]                 }
[10:22:30.075]                 if (length(args) > 0) 
[10:22:30.075]                   base::do.call(base::Sys.setenv, args = args)
[10:22:30.075]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:30.075]             }
[10:22:30.075]             else {
[10:22:30.075]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:30.075]             }
[10:22:30.075]             {
[10:22:30.075]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:30.075]                   0L) {
[10:22:30.075]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:30.075]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:30.075]                   base::options(opts)
[10:22:30.075]                 }
[10:22:30.075]                 {
[10:22:30.075]                   {
[10:22:30.075]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:30.075]                     NULL
[10:22:30.075]                   }
[10:22:30.075]                   options(future.plan = NULL)
[10:22:30.075]                   if (is.na(NA_character_)) 
[10:22:30.075]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:30.075]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:30.075]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:30.075]                     .init = FALSE)
[10:22:30.075]                 }
[10:22:30.075]             }
[10:22:30.075]         }
[10:22:30.075]     })
[10:22:30.075]     if (TRUE) {
[10:22:30.075]         base::sink(type = "output", split = FALSE)
[10:22:30.075]         if (TRUE) {
[10:22:30.075]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:30.075]         }
[10:22:30.075]         else {
[10:22:30.075]             ...future.result["stdout"] <- base::list(NULL)
[10:22:30.075]         }
[10:22:30.075]         base::close(...future.stdout)
[10:22:30.075]         ...future.stdout <- NULL
[10:22:30.075]     }
[10:22:30.075]     ...future.result$conditions <- ...future.conditions
[10:22:30.075]     ...future.result$finished <- base::Sys.time()
[10:22:30.075]     ...future.result
[10:22:30.075] }
[10:22:30.077] requestCore(): workers = 2
[10:22:30.078] Poll #1 (0): usedCores() = 2, workers = 2
[10:22:30.089] result() for MulticoreFuture ...
[10:22:30.090] result() for MulticoreFuture ...
[10:22:30.090] result() for MulticoreFuture ... done
[10:22:30.090] result() for MulticoreFuture ... done
[10:22:30.090] result() for MulticoreFuture ...
[10:22:30.091] result() for MulticoreFuture ... done
[10:22:30.093] MulticoreFuture started
[10:22:30.094] - Launch lazy future ... done
[10:22:30.094] run() for ‘MulticoreFuture’ ... done
[10:22:30.094] plan(): Setting new future strategy stack:
[10:22:30.095] resolve() on list ...
[10:22:30.095]  recursive: 0
[10:22:30.095]  length: 1
[10:22:30.095] 
[10:22:30.096] Future #1
[10:22:30.095] List of future strategies:
[10:22:30.095] 1. sequential:
[10:22:30.095]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:30.095]    - tweaked: FALSE
[10:22:30.095]    - call: NULL
[10:22:30.096]  length: 0 (resolved future 1)
[10:22:30.096] plan(): nbrOfWorkers() = 1
[10:22:30.096] resolve() on list ... DONE
[10:22:30.097] resolve() on list ...
[10:22:30.097]  recursive: 0
[10:22:30.097]  length: 1
[10:22:30.097] 
[10:22:30.600] plan(): Setting new future strategy stack:
[10:22:30.600] List of future strategies:
[10:22:30.600] 1. multicore:
[10:22:30.600]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:30.600]    - tweaked: FALSE
[10:22:30.600]    - call: plan(strategy)
[10:22:30.603] plan(): nbrOfWorkers() = 2
[10:22:30.608] Future #1
[10:22:30.609]  length: 0 (resolved future 1)
[10:22:30.609] resolve() on list ... DONE
[10:22:30.609] resolve() on list ...
[10:22:30.610]  recursive: 0
[10:22:30.610]  length: 1
[10:22:30.610] 
[10:22:30.610]  length: 0 (resolved future 1)
[10:22:30.610] resolve() on list ... DONE
[10:22:30.611] resolve() on list ...
[10:22:30.611]  recursive: 0
[10:22:30.611]  length: 4
[10:22:30.611] 
[10:22:30.611] Future #1
[10:22:30.612]  length: 3 (resolved future 1)
[10:22:30.612] Future #2
[10:22:30.612]  length: 2 (resolved future 2)
[10:22:30.612]  length: 1 (resolved future 3)
[10:22:30.612]  length: 0 (resolved future 4)
[10:22:30.613] resolve() on list ... DONE
[10:22:30.613] resolve() on list ...
[10:22:30.613]  recursive: 0
[10:22:30.613]  length: 4
[10:22:30.613] 
[10:22:30.614] Future #1
[10:22:30.614]  length: 3 (resolved future 1)
[10:22:30.614] Future #2
[10:22:30.614]  length: 2 (resolved future 2)
[10:22:30.614]  length: 1 (resolved future 3)
[10:22:30.615]  length: 0 (resolved future 4)
[10:22:30.615] resolve() on list ... DONE
[10:22:30.615] resolve() on list ...
[10:22:30.615]  recursive: 0
[10:22:30.615]  length: 1
[10:22:30.616] 
[10:22:30.616]  length: 0 (resolved future 1)
[10:22:30.616] resolve() on list ... DONE
[10:22:30.616] getGlobalsAndPackages() ...
[10:22:30.616] Searching for globals...
[10:22:30.618] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:22:30.618] Searching for globals ... DONE
[10:22:30.618] Resolving globals: FALSE
[10:22:30.619] The total size of the 1 globals is 35 bytes (35 bytes)
[10:22:30.620] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[10:22:30.620] - globals: [1] ‘kk’
[10:22:30.620] 
[10:22:30.620] getGlobalsAndPackages() ... DONE
[10:22:30.621] run() for ‘Future’ ...
[10:22:30.621] - state: ‘created’
[10:22:30.621] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:30.623] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:30.624] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:30.624]   - Field: ‘label’
[10:22:30.624]   - Field: ‘local’
[10:22:30.624]   - Field: ‘owner’
[10:22:30.624]   - Field: ‘envir’
[10:22:30.624]   - Field: ‘workers’
[10:22:30.624]   - Field: ‘packages’
[10:22:30.625]   - Field: ‘gc’
[10:22:30.625]   - Field: ‘job’
[10:22:30.625]   - Field: ‘conditions’
[10:22:30.625]   - Field: ‘expr’
[10:22:30.625]   - Field: ‘uuid’
[10:22:30.625]   - Field: ‘seed’
[10:22:30.625]   - Field: ‘version’
[10:22:30.625]   - Field: ‘result’
[10:22:30.626]   - Field: ‘asynchronous’
[10:22:30.626]   - Field: ‘calls’
[10:22:30.626]   - Field: ‘globals’
[10:22:30.626]   - Field: ‘stdout’
[10:22:30.626]   - Field: ‘earlySignal’
[10:22:30.626]   - Field: ‘lazy’
[10:22:30.626]   - Field: ‘state’
[10:22:30.627] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:30.627] - Launch lazy future ...
[10:22:30.627] Packages needed by the future expression (n = 0): <none>
[10:22:30.627] Packages needed by future strategies (n = 0): <none>
[10:22:30.628] {
[10:22:30.628]     {
[10:22:30.628]         {
[10:22:30.628]             ...future.startTime <- base::Sys.time()
[10:22:30.628]             {
[10:22:30.628]                 {
[10:22:30.628]                   {
[10:22:30.628]                     {
[10:22:30.628]                       base::local({
[10:22:30.628]                         has_future <- base::requireNamespace("future", 
[10:22:30.628]                           quietly = TRUE)
[10:22:30.628]                         if (has_future) {
[10:22:30.628]                           ns <- base::getNamespace("future")
[10:22:30.628]                           version <- ns[[".package"]][["version"]]
[10:22:30.628]                           if (is.null(version)) 
[10:22:30.628]                             version <- utils::packageVersion("future")
[10:22:30.628]                         }
[10:22:30.628]                         else {
[10:22:30.628]                           version <- NULL
[10:22:30.628]                         }
[10:22:30.628]                         if (!has_future || version < "1.8.0") {
[10:22:30.628]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:30.628]                             "", base::R.version$version.string), 
[10:22:30.628]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:30.628]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:30.628]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:30.628]                               "release", "version")], collapse = " "), 
[10:22:30.628]                             hostname = base::Sys.info()[["nodename"]])
[10:22:30.628]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:30.628]                             info)
[10:22:30.628]                           info <- base::paste(info, collapse = "; ")
[10:22:30.628]                           if (!has_future) {
[10:22:30.628]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:30.628]                               info)
[10:22:30.628]                           }
[10:22:30.628]                           else {
[10:22:30.628]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:30.628]                               info, version)
[10:22:30.628]                           }
[10:22:30.628]                           base::stop(msg)
[10:22:30.628]                         }
[10:22:30.628]                       })
[10:22:30.628]                     }
[10:22:30.628]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:30.628]                     base::options(mc.cores = 1L)
[10:22:30.628]                   }
[10:22:30.628]                   ...future.strategy.old <- future::plan("list")
[10:22:30.628]                   options(future.plan = NULL)
[10:22:30.628]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:30.628]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:30.628]                 }
[10:22:30.628]                 ...future.workdir <- getwd()
[10:22:30.628]             }
[10:22:30.628]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:30.628]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:30.628]         }
[10:22:30.628]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:30.628]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:30.628]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:30.628]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:30.628]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:30.628]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:30.628]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:30.628]             base::names(...future.oldOptions))
[10:22:30.628]     }
[10:22:30.628]     if (FALSE) {
[10:22:30.628]     }
[10:22:30.628]     else {
[10:22:30.628]         if (TRUE) {
[10:22:30.628]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:30.628]                 open = "w")
[10:22:30.628]         }
[10:22:30.628]         else {
[10:22:30.628]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:30.628]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:30.628]         }
[10:22:30.628]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:30.628]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:30.628]             base::sink(type = "output", split = FALSE)
[10:22:30.628]             base::close(...future.stdout)
[10:22:30.628]         }, add = TRUE)
[10:22:30.628]     }
[10:22:30.628]     ...future.frame <- base::sys.nframe()
[10:22:30.628]     ...future.conditions <- base::list()
[10:22:30.628]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:30.628]     if (FALSE) {
[10:22:30.628]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:30.628]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:30.628]     }
[10:22:30.628]     ...future.result <- base::tryCatch({
[10:22:30.628]         base::withCallingHandlers({
[10:22:30.628]             ...future.value <- base::withVisible(base::local({
[10:22:30.628]                 withCallingHandlers({
[10:22:30.628]                   {
[10:22:30.628]                     Sys.sleep(0.1)
[10:22:30.628]                     kk
[10:22:30.628]                   }
[10:22:30.628]                 }, immediateCondition = function(cond) {
[10:22:30.628]                   save_rds <- function (object, pathname, ...) 
[10:22:30.628]                   {
[10:22:30.628]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:30.628]                     if (file_test("-f", pathname_tmp)) {
[10:22:30.628]                       fi_tmp <- file.info(pathname_tmp)
[10:22:30.628]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:30.628]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:30.628]                         fi_tmp[["mtime"]])
[10:22:30.628]                     }
[10:22:30.628]                     tryCatch({
[10:22:30.628]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:30.628]                     }, error = function(ex) {
[10:22:30.628]                       msg <- conditionMessage(ex)
[10:22:30.628]                       fi_tmp <- file.info(pathname_tmp)
[10:22:30.628]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:30.628]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:30.628]                         fi_tmp[["mtime"]], msg)
[10:22:30.628]                       ex$message <- msg
[10:22:30.628]                       stop(ex)
[10:22:30.628]                     })
[10:22:30.628]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:30.628]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:30.628]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:30.628]                       fi_tmp <- file.info(pathname_tmp)
[10:22:30.628]                       fi <- file.info(pathname)
[10:22:30.628]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:30.628]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:30.628]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:30.628]                         fi[["size"]], fi[["mtime"]])
[10:22:30.628]                       stop(msg)
[10:22:30.628]                     }
[10:22:30.628]                     invisible(pathname)
[10:22:30.628]                   }
[10:22:30.628]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:30.628]                     rootPath = tempdir()) 
[10:22:30.628]                   {
[10:22:30.628]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:30.628]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:30.628]                       tmpdir = path, fileext = ".rds")
[10:22:30.628]                     save_rds(obj, file)
[10:22:30.628]                   }
[10:22:30.628]                   saveImmediateCondition(cond, path = "/tmp/RtmpzsJv4f/.future/immediateConditions")
[10:22:30.628]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:30.628]                   {
[10:22:30.628]                     inherits <- base::inherits
[10:22:30.628]                     invokeRestart <- base::invokeRestart
[10:22:30.628]                     is.null <- base::is.null
[10:22:30.628]                     muffled <- FALSE
[10:22:30.628]                     if (inherits(cond, "message")) {
[10:22:30.628]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:30.628]                       if (muffled) 
[10:22:30.628]                         invokeRestart("muffleMessage")
[10:22:30.628]                     }
[10:22:30.628]                     else if (inherits(cond, "warning")) {
[10:22:30.628]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:30.628]                       if (muffled) 
[10:22:30.628]                         invokeRestart("muffleWarning")
[10:22:30.628]                     }
[10:22:30.628]                     else if (inherits(cond, "condition")) {
[10:22:30.628]                       if (!is.null(pattern)) {
[10:22:30.628]                         computeRestarts <- base::computeRestarts
[10:22:30.628]                         grepl <- base::grepl
[10:22:30.628]                         restarts <- computeRestarts(cond)
[10:22:30.628]                         for (restart in restarts) {
[10:22:30.628]                           name <- restart$name
[10:22:30.628]                           if (is.null(name)) 
[10:22:30.628]                             next
[10:22:30.628]                           if (!grepl(pattern, name)) 
[10:22:30.628]                             next
[10:22:30.628]                           invokeRestart(restart)
[10:22:30.628]                           muffled <- TRUE
[10:22:30.628]                           break
[10:22:30.628]                         }
[10:22:30.628]                       }
[10:22:30.628]                     }
[10:22:30.628]                     invisible(muffled)
[10:22:30.628]                   }
[10:22:30.628]                   muffleCondition(cond)
[10:22:30.628]                 })
[10:22:30.628]             }))
[10:22:30.628]             future::FutureResult(value = ...future.value$value, 
[10:22:30.628]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:30.628]                   ...future.rng), globalenv = if (FALSE) 
[10:22:30.628]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:30.628]                     ...future.globalenv.names))
[10:22:30.628]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:30.628]         }, condition = base::local({
[10:22:30.628]             c <- base::c
[10:22:30.628]             inherits <- base::inherits
[10:22:30.628]             invokeRestart <- base::invokeRestart
[10:22:30.628]             length <- base::length
[10:22:30.628]             list <- base::list
[10:22:30.628]             seq.int <- base::seq.int
[10:22:30.628]             signalCondition <- base::signalCondition
[10:22:30.628]             sys.calls <- base::sys.calls
[10:22:30.628]             `[[` <- base::`[[`
[10:22:30.628]             `+` <- base::`+`
[10:22:30.628]             `<<-` <- base::`<<-`
[10:22:30.628]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:30.628]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:30.628]                   3L)]
[10:22:30.628]             }
[10:22:30.628]             function(cond) {
[10:22:30.628]                 is_error <- inherits(cond, "error")
[10:22:30.628]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:30.628]                   NULL)
[10:22:30.628]                 if (is_error) {
[10:22:30.628]                   sessionInformation <- function() {
[10:22:30.628]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:30.628]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:30.628]                       search = base::search(), system = base::Sys.info())
[10:22:30.628]                   }
[10:22:30.628]                   ...future.conditions[[length(...future.conditions) + 
[10:22:30.628]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:30.628]                     cond$call), session = sessionInformation(), 
[10:22:30.628]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:30.628]                   signalCondition(cond)
[10:22:30.628]                 }
[10:22:30.628]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:30.628]                 "immediateCondition"))) {
[10:22:30.628]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:30.628]                   ...future.conditions[[length(...future.conditions) + 
[10:22:30.628]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:30.628]                   if (TRUE && !signal) {
[10:22:30.628]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:30.628]                     {
[10:22:30.628]                       inherits <- base::inherits
[10:22:30.628]                       invokeRestart <- base::invokeRestart
[10:22:30.628]                       is.null <- base::is.null
[10:22:30.628]                       muffled <- FALSE
[10:22:30.628]                       if (inherits(cond, "message")) {
[10:22:30.628]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:30.628]                         if (muffled) 
[10:22:30.628]                           invokeRestart("muffleMessage")
[10:22:30.628]                       }
[10:22:30.628]                       else if (inherits(cond, "warning")) {
[10:22:30.628]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:30.628]                         if (muffled) 
[10:22:30.628]                           invokeRestart("muffleWarning")
[10:22:30.628]                       }
[10:22:30.628]                       else if (inherits(cond, "condition")) {
[10:22:30.628]                         if (!is.null(pattern)) {
[10:22:30.628]                           computeRestarts <- base::computeRestarts
[10:22:30.628]                           grepl <- base::grepl
[10:22:30.628]                           restarts <- computeRestarts(cond)
[10:22:30.628]                           for (restart in restarts) {
[10:22:30.628]                             name <- restart$name
[10:22:30.628]                             if (is.null(name)) 
[10:22:30.628]                               next
[10:22:30.628]                             if (!grepl(pattern, name)) 
[10:22:30.628]                               next
[10:22:30.628]                             invokeRestart(restart)
[10:22:30.628]                             muffled <- TRUE
[10:22:30.628]                             break
[10:22:30.628]                           }
[10:22:30.628]                         }
[10:22:30.628]                       }
[10:22:30.628]                       invisible(muffled)
[10:22:30.628]                     }
[10:22:30.628]                     muffleCondition(cond, pattern = "^muffle")
[10:22:30.628]                   }
[10:22:30.628]                 }
[10:22:30.628]                 else {
[10:22:30.628]                   if (TRUE) {
[10:22:30.628]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:30.628]                     {
[10:22:30.628]                       inherits <- base::inherits
[10:22:30.628]                       invokeRestart <- base::invokeRestart
[10:22:30.628]                       is.null <- base::is.null
[10:22:30.628]                       muffled <- FALSE
[10:22:30.628]                       if (inherits(cond, "message")) {
[10:22:30.628]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:30.628]                         if (muffled) 
[10:22:30.628]                           invokeRestart("muffleMessage")
[10:22:30.628]                       }
[10:22:30.628]                       else if (inherits(cond, "warning")) {
[10:22:30.628]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:30.628]                         if (muffled) 
[10:22:30.628]                           invokeRestart("muffleWarning")
[10:22:30.628]                       }
[10:22:30.628]                       else if (inherits(cond, "condition")) {
[10:22:30.628]                         if (!is.null(pattern)) {
[10:22:30.628]                           computeRestarts <- base::computeRestarts
[10:22:30.628]                           grepl <- base::grepl
[10:22:30.628]                           restarts <- computeRestarts(cond)
[10:22:30.628]                           for (restart in restarts) {
[10:22:30.628]                             name <- restart$name
[10:22:30.628]                             if (is.null(name)) 
[10:22:30.628]                               next
[10:22:30.628]                             if (!grepl(pattern, name)) 
[10:22:30.628]                               next
[10:22:30.628]                             invokeRestart(restart)
[10:22:30.628]                             muffled <- TRUE
[10:22:30.628]                             break
[10:22:30.628]                           }
[10:22:30.628]                         }
[10:22:30.628]                       }
[10:22:30.628]                       invisible(muffled)
[10:22:30.628]                     }
[10:22:30.628]                     muffleCondition(cond, pattern = "^muffle")
[10:22:30.628]                   }
[10:22:30.628]                 }
[10:22:30.628]             }
[10:22:30.628]         }))
[10:22:30.628]     }, error = function(ex) {
[10:22:30.628]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:30.628]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:30.628]                 ...future.rng), started = ...future.startTime, 
[10:22:30.628]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:30.628]             version = "1.8"), class = "FutureResult")
[10:22:30.628]     }, finally = {
[10:22:30.628]         if (!identical(...future.workdir, getwd())) 
[10:22:30.628]             setwd(...future.workdir)
[10:22:30.628]         {
[10:22:30.628]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:30.628]                 ...future.oldOptions$nwarnings <- NULL
[10:22:30.628]             }
[10:22:30.628]             base::options(...future.oldOptions)
[10:22:30.628]             if (.Platform$OS.type == "windows") {
[10:22:30.628]                 old_names <- names(...future.oldEnvVars)
[10:22:30.628]                 envs <- base::Sys.getenv()
[10:22:30.628]                 names <- names(envs)
[10:22:30.628]                 common <- intersect(names, old_names)
[10:22:30.628]                 added <- setdiff(names, old_names)
[10:22:30.628]                 removed <- setdiff(old_names, names)
[10:22:30.628]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:30.628]                   envs[common]]
[10:22:30.628]                 NAMES <- toupper(changed)
[10:22:30.628]                 args <- list()
[10:22:30.628]                 for (kk in seq_along(NAMES)) {
[10:22:30.628]                   name <- changed[[kk]]
[10:22:30.628]                   NAME <- NAMES[[kk]]
[10:22:30.628]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:30.628]                     next
[10:22:30.628]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:30.628]                 }
[10:22:30.628]                 NAMES <- toupper(added)
[10:22:30.628]                 for (kk in seq_along(NAMES)) {
[10:22:30.628]                   name <- added[[kk]]
[10:22:30.628]                   NAME <- NAMES[[kk]]
[10:22:30.628]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:30.628]                     next
[10:22:30.628]                   args[[name]] <- ""
[10:22:30.628]                 }
[10:22:30.628]                 NAMES <- toupper(removed)
[10:22:30.628]                 for (kk in seq_along(NAMES)) {
[10:22:30.628]                   name <- removed[[kk]]
[10:22:30.628]                   NAME <- NAMES[[kk]]
[10:22:30.628]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:30.628]                     next
[10:22:30.628]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:30.628]                 }
[10:22:30.628]                 if (length(args) > 0) 
[10:22:30.628]                   base::do.call(base::Sys.setenv, args = args)
[10:22:30.628]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:30.628]             }
[10:22:30.628]             else {
[10:22:30.628]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:30.628]             }
[10:22:30.628]             {
[10:22:30.628]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:30.628]                   0L) {
[10:22:30.628]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:30.628]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:30.628]                   base::options(opts)
[10:22:30.628]                 }
[10:22:30.628]                 {
[10:22:30.628]                   {
[10:22:30.628]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:30.628]                     NULL
[10:22:30.628]                   }
[10:22:30.628]                   options(future.plan = NULL)
[10:22:30.628]                   if (is.na(NA_character_)) 
[10:22:30.628]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:30.628]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:30.628]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:30.628]                     .init = FALSE)
[10:22:30.628]                 }
[10:22:30.628]             }
[10:22:30.628]         }
[10:22:30.628]     })
[10:22:30.628]     if (TRUE) {
[10:22:30.628]         base::sink(type = "output", split = FALSE)
[10:22:30.628]         if (TRUE) {
[10:22:30.628]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:30.628]         }
[10:22:30.628]         else {
[10:22:30.628]             ...future.result["stdout"] <- base::list(NULL)
[10:22:30.628]         }
[10:22:30.628]         base::close(...future.stdout)
[10:22:30.628]         ...future.stdout <- NULL
[10:22:30.628]     }
[10:22:30.628]     ...future.result$conditions <- ...future.conditions
[10:22:30.628]     ...future.result$finished <- base::Sys.time()
[10:22:30.628]     ...future.result
[10:22:30.628] }
[10:22:30.631] assign_globals() ...
[10:22:30.631] List of 1
[10:22:30.631]  $ kk: int 1
[10:22:30.631]  - attr(*, "where")=List of 1
[10:22:30.631]   ..$ kk:<environment: R_EmptyEnv> 
[10:22:30.631]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:30.631]  - attr(*, "resolved")= logi FALSE
[10:22:30.631]  - attr(*, "total_size")= num 35
[10:22:30.631]  - attr(*, "already-done")= logi TRUE
[10:22:30.635] - copied ‘kk’ to environment
[10:22:30.635] assign_globals() ... done
[10:22:30.635] requestCore(): workers = 2
[10:22:30.638] Poll #1 (0): usedCores() = 2, workers = 2
[10:22:30.649] result() for MulticoreFuture ...
[10:22:30.650] result() for MulticoreFuture ...
[10:22:30.650] result() for MulticoreFuture ... done
[10:22:30.650] result() for MulticoreFuture ... done
[10:22:30.651] result() for MulticoreFuture ...
[10:22:30.651] result() for MulticoreFuture ... done
[10:22:30.654] MulticoreFuture started
[10:22:30.654] - Launch lazy future ... done
[10:22:30.655] run() for ‘MulticoreFuture’ ... done
[10:22:30.655] plan(): Setting new future strategy stack:
[10:22:30.655] getGlobalsAndPackages() ...
[10:22:30.656] Searching for globals...
[10:22:30.655] List of future strategies:
[10:22:30.655] 1. sequential:
[10:22:30.655]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:30.655]    - tweaked: FALSE
[10:22:30.655]    - call: NULL
[10:22:30.657] plan(): nbrOfWorkers() = 1
[10:22:30.659] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:22:30.659] Searching for globals ... DONE
[10:22:30.659] Resolving globals: FALSE
[10:22:30.660] The total size of the 1 globals is 35 bytes (35 bytes)
[10:22:30.661] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[10:22:30.661] - globals: [1] ‘kk’
[10:22:30.661] 
[10:22:30.661] getGlobalsAndPackages() ... DONE
[10:22:30.662] run() for ‘Future’ ...
[10:22:30.662] - state: ‘created’
[10:22:30.662] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:30.665] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:30.666] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:30.666]   - Field: ‘label’
[10:22:30.666]   - Field: ‘local’
[10:22:30.666]   - Field: ‘owner’
[10:22:30.666]   - Field: ‘envir’
[10:22:30.667]   - Field: ‘workers’
[10:22:30.667]   - Field: ‘packages’
[10:22:30.667]   - Field: ‘gc’
[10:22:30.667]   - Field: ‘job’
[10:22:30.667]   - Field: ‘conditions’
[10:22:30.667]   - Field: ‘expr’
[10:22:30.667]   - Field: ‘uuid’
[10:22:30.668]   - Field: ‘seed’
[10:22:30.668]   - Field: ‘version’
[10:22:30.668]   - Field: ‘result’
[10:22:30.668]   - Field: ‘asynchronous’
[10:22:30.668]   - Field: ‘calls’
[10:22:30.668]   - Field: ‘globals’
[10:22:30.668]   - Field: ‘stdout’
[10:22:30.669]   - Field: ‘earlySignal’
[10:22:30.669]   - Field: ‘lazy’
[10:22:30.669]   - Field: ‘state’
[10:22:30.669] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:30.669] - Launch lazy future ...
[10:22:30.670] Packages needed by the future expression (n = 0): <none>
[10:22:30.670] Packages needed by future strategies (n = 0): <none>
[10:22:30.670] {
[10:22:30.670]     {
[10:22:30.670]         {
[10:22:30.670]             ...future.startTime <- base::Sys.time()
[10:22:30.670]             {
[10:22:30.670]                 {
[10:22:30.670]                   {
[10:22:30.670]                     {
[10:22:30.670]                       base::local({
[10:22:30.670]                         has_future <- base::requireNamespace("future", 
[10:22:30.670]                           quietly = TRUE)
[10:22:30.670]                         if (has_future) {
[10:22:30.670]                           ns <- base::getNamespace("future")
[10:22:30.670]                           version <- ns[[".package"]][["version"]]
[10:22:30.670]                           if (is.null(version)) 
[10:22:30.670]                             version <- utils::packageVersion("future")
[10:22:30.670]                         }
[10:22:30.670]                         else {
[10:22:30.670]                           version <- NULL
[10:22:30.670]                         }
[10:22:30.670]                         if (!has_future || version < "1.8.0") {
[10:22:30.670]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:30.670]                             "", base::R.version$version.string), 
[10:22:30.670]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:30.670]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:30.670]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:30.670]                               "release", "version")], collapse = " "), 
[10:22:30.670]                             hostname = base::Sys.info()[["nodename"]])
[10:22:30.670]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:30.670]                             info)
[10:22:30.670]                           info <- base::paste(info, collapse = "; ")
[10:22:30.670]                           if (!has_future) {
[10:22:30.670]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:30.670]                               info)
[10:22:30.670]                           }
[10:22:30.670]                           else {
[10:22:30.670]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:30.670]                               info, version)
[10:22:30.670]                           }
[10:22:30.670]                           base::stop(msg)
[10:22:30.670]                         }
[10:22:30.670]                       })
[10:22:30.670]                     }
[10:22:30.670]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:30.670]                     base::options(mc.cores = 1L)
[10:22:30.670]                   }
[10:22:30.670]                   ...future.strategy.old <- future::plan("list")
[10:22:30.670]                   options(future.plan = NULL)
[10:22:30.670]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:30.670]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:30.670]                 }
[10:22:30.670]                 ...future.workdir <- getwd()
[10:22:30.670]             }
[10:22:30.670]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:30.670]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:30.670]         }
[10:22:30.670]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:30.670]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:30.670]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:30.670]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:30.670]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:30.670]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:30.670]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:30.670]             base::names(...future.oldOptions))
[10:22:30.670]     }
[10:22:30.670]     if (FALSE) {
[10:22:30.670]     }
[10:22:30.670]     else {
[10:22:30.670]         if (TRUE) {
[10:22:30.670]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:30.670]                 open = "w")
[10:22:30.670]         }
[10:22:30.670]         else {
[10:22:30.670]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:30.670]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:30.670]         }
[10:22:30.670]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:30.670]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:30.670]             base::sink(type = "output", split = FALSE)
[10:22:30.670]             base::close(...future.stdout)
[10:22:30.670]         }, add = TRUE)
[10:22:30.670]     }
[10:22:30.670]     ...future.frame <- base::sys.nframe()
[10:22:30.670]     ...future.conditions <- base::list()
[10:22:30.670]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:30.670]     if (FALSE) {
[10:22:30.670]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:30.670]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:30.670]     }
[10:22:30.670]     ...future.result <- base::tryCatch({
[10:22:30.670]         base::withCallingHandlers({
[10:22:30.670]             ...future.value <- base::withVisible(base::local({
[10:22:30.670]                 withCallingHandlers({
[10:22:30.670]                   {
[10:22:30.670]                     Sys.sleep(0.1)
[10:22:30.670]                     kk
[10:22:30.670]                   }
[10:22:30.670]                 }, immediateCondition = function(cond) {
[10:22:30.670]                   save_rds <- function (object, pathname, ...) 
[10:22:30.670]                   {
[10:22:30.670]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:30.670]                     if (file_test("-f", pathname_tmp)) {
[10:22:30.670]                       fi_tmp <- file.info(pathname_tmp)
[10:22:30.670]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:30.670]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:30.670]                         fi_tmp[["mtime"]])
[10:22:30.670]                     }
[10:22:30.670]                     tryCatch({
[10:22:30.670]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:30.670]                     }, error = function(ex) {
[10:22:30.670]                       msg <- conditionMessage(ex)
[10:22:30.670]                       fi_tmp <- file.info(pathname_tmp)
[10:22:30.670]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:30.670]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:30.670]                         fi_tmp[["mtime"]], msg)
[10:22:30.670]                       ex$message <- msg
[10:22:30.670]                       stop(ex)
[10:22:30.670]                     })
[10:22:30.670]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:30.670]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:30.670]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:30.670]                       fi_tmp <- file.info(pathname_tmp)
[10:22:30.670]                       fi <- file.info(pathname)
[10:22:30.670]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:30.670]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:30.670]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:30.670]                         fi[["size"]], fi[["mtime"]])
[10:22:30.670]                       stop(msg)
[10:22:30.670]                     }
[10:22:30.670]                     invisible(pathname)
[10:22:30.670]                   }
[10:22:30.670]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:30.670]                     rootPath = tempdir()) 
[10:22:30.670]                   {
[10:22:30.670]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:30.670]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:30.670]                       tmpdir = path, fileext = ".rds")
[10:22:30.670]                     save_rds(obj, file)
[10:22:30.670]                   }
[10:22:30.670]                   saveImmediateCondition(cond, path = "/tmp/RtmpzsJv4f/.future/immediateConditions")
[10:22:30.670]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:30.670]                   {
[10:22:30.670]                     inherits <- base::inherits
[10:22:30.670]                     invokeRestart <- base::invokeRestart
[10:22:30.670]                     is.null <- base::is.null
[10:22:30.670]                     muffled <- FALSE
[10:22:30.670]                     if (inherits(cond, "message")) {
[10:22:30.670]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:30.670]                       if (muffled) 
[10:22:30.670]                         invokeRestart("muffleMessage")
[10:22:30.670]                     }
[10:22:30.670]                     else if (inherits(cond, "warning")) {
[10:22:30.670]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:30.670]                       if (muffled) 
[10:22:30.670]                         invokeRestart("muffleWarning")
[10:22:30.670]                     }
[10:22:30.670]                     else if (inherits(cond, "condition")) {
[10:22:30.670]                       if (!is.null(pattern)) {
[10:22:30.670]                         computeRestarts <- base::computeRestarts
[10:22:30.670]                         grepl <- base::grepl
[10:22:30.670]                         restarts <- computeRestarts(cond)
[10:22:30.670]                         for (restart in restarts) {
[10:22:30.670]                           name <- restart$name
[10:22:30.670]                           if (is.null(name)) 
[10:22:30.670]                             next
[10:22:30.670]                           if (!grepl(pattern, name)) 
[10:22:30.670]                             next
[10:22:30.670]                           invokeRestart(restart)
[10:22:30.670]                           muffled <- TRUE
[10:22:30.670]                           break
[10:22:30.670]                         }
[10:22:30.670]                       }
[10:22:30.670]                     }
[10:22:30.670]                     invisible(muffled)
[10:22:30.670]                   }
[10:22:30.670]                   muffleCondition(cond)
[10:22:30.670]                 })
[10:22:30.670]             }))
[10:22:30.670]             future::FutureResult(value = ...future.value$value, 
[10:22:30.670]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:30.670]                   ...future.rng), globalenv = if (FALSE) 
[10:22:30.670]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:30.670]                     ...future.globalenv.names))
[10:22:30.670]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:30.670]         }, condition = base::local({
[10:22:30.670]             c <- base::c
[10:22:30.670]             inherits <- base::inherits
[10:22:30.670]             invokeRestart <- base::invokeRestart
[10:22:30.670]             length <- base::length
[10:22:30.670]             list <- base::list
[10:22:30.670]             seq.int <- base::seq.int
[10:22:30.670]             signalCondition <- base::signalCondition
[10:22:30.670]             sys.calls <- base::sys.calls
[10:22:30.670]             `[[` <- base::`[[`
[10:22:30.670]             `+` <- base::`+`
[10:22:30.670]             `<<-` <- base::`<<-`
[10:22:30.670]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:30.670]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:30.670]                   3L)]
[10:22:30.670]             }
[10:22:30.670]             function(cond) {
[10:22:30.670]                 is_error <- inherits(cond, "error")
[10:22:30.670]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:30.670]                   NULL)
[10:22:30.670]                 if (is_error) {
[10:22:30.670]                   sessionInformation <- function() {
[10:22:30.670]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:30.670]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:30.670]                       search = base::search(), system = base::Sys.info())
[10:22:30.670]                   }
[10:22:30.670]                   ...future.conditions[[length(...future.conditions) + 
[10:22:30.670]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:30.670]                     cond$call), session = sessionInformation(), 
[10:22:30.670]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:30.670]                   signalCondition(cond)
[10:22:30.670]                 }
[10:22:30.670]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:30.670]                 "immediateCondition"))) {
[10:22:30.670]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:30.670]                   ...future.conditions[[length(...future.conditions) + 
[10:22:30.670]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:30.670]                   if (TRUE && !signal) {
[10:22:30.670]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:30.670]                     {
[10:22:30.670]                       inherits <- base::inherits
[10:22:30.670]                       invokeRestart <- base::invokeRestart
[10:22:30.670]                       is.null <- base::is.null
[10:22:30.670]                       muffled <- FALSE
[10:22:30.670]                       if (inherits(cond, "message")) {
[10:22:30.670]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:30.670]                         if (muffled) 
[10:22:30.670]                           invokeRestart("muffleMessage")
[10:22:30.670]                       }
[10:22:30.670]                       else if (inherits(cond, "warning")) {
[10:22:30.670]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:30.670]                         if (muffled) 
[10:22:30.670]                           invokeRestart("muffleWarning")
[10:22:30.670]                       }
[10:22:30.670]                       else if (inherits(cond, "condition")) {
[10:22:30.670]                         if (!is.null(pattern)) {
[10:22:30.670]                           computeRestarts <- base::computeRestarts
[10:22:30.670]                           grepl <- base::grepl
[10:22:30.670]                           restarts <- computeRestarts(cond)
[10:22:30.670]                           for (restart in restarts) {
[10:22:30.670]                             name <- restart$name
[10:22:30.670]                             if (is.null(name)) 
[10:22:30.670]                               next
[10:22:30.670]                             if (!grepl(pattern, name)) 
[10:22:30.670]                               next
[10:22:30.670]                             invokeRestart(restart)
[10:22:30.670]                             muffled <- TRUE
[10:22:30.670]                             break
[10:22:30.670]                           }
[10:22:30.670]                         }
[10:22:30.670]                       }
[10:22:30.670]                       invisible(muffled)
[10:22:30.670]                     }
[10:22:30.670]                     muffleCondition(cond, pattern = "^muffle")
[10:22:30.670]                   }
[10:22:30.670]                 }
[10:22:30.670]                 else {
[10:22:30.670]                   if (TRUE) {
[10:22:30.670]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:30.670]                     {
[10:22:30.670]                       inherits <- base::inherits
[10:22:30.670]                       invokeRestart <- base::invokeRestart
[10:22:30.670]                       is.null <- base::is.null
[10:22:30.670]                       muffled <- FALSE
[10:22:30.670]                       if (inherits(cond, "message")) {
[10:22:30.670]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:30.670]                         if (muffled) 
[10:22:30.670]                           invokeRestart("muffleMessage")
[10:22:30.670]                       }
[10:22:30.670]                       else if (inherits(cond, "warning")) {
[10:22:30.670]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:30.670]                         if (muffled) 
[10:22:30.670]                           invokeRestart("muffleWarning")
[10:22:30.670]                       }
[10:22:30.670]                       else if (inherits(cond, "condition")) {
[10:22:30.670]                         if (!is.null(pattern)) {
[10:22:30.670]                           computeRestarts <- base::computeRestarts
[10:22:30.670]                           grepl <- base::grepl
[10:22:30.670]                           restarts <- computeRestarts(cond)
[10:22:30.670]                           for (restart in restarts) {
[10:22:30.670]                             name <- restart$name
[10:22:30.670]                             if (is.null(name)) 
[10:22:30.670]                               next
[10:22:30.670]                             if (!grepl(pattern, name)) 
[10:22:30.670]                               next
[10:22:30.670]                             invokeRestart(restart)
[10:22:30.670]                             muffled <- TRUE
[10:22:30.670]                             break
[10:22:30.670]                           }
[10:22:30.670]                         }
[10:22:30.670]                       }
[10:22:30.670]                       invisible(muffled)
[10:22:30.670]                     }
[10:22:30.670]                     muffleCondition(cond, pattern = "^muffle")
[10:22:30.670]                   }
[10:22:30.670]                 }
[10:22:30.670]             }
[10:22:30.670]         }))
[10:22:30.670]     }, error = function(ex) {
[10:22:30.670]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:30.670]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:30.670]                 ...future.rng), started = ...future.startTime, 
[10:22:30.670]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:30.670]             version = "1.8"), class = "FutureResult")
[10:22:30.670]     }, finally = {
[10:22:30.670]         if (!identical(...future.workdir, getwd())) 
[10:22:30.670]             setwd(...future.workdir)
[10:22:30.670]         {
[10:22:30.670]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:30.670]                 ...future.oldOptions$nwarnings <- NULL
[10:22:30.670]             }
[10:22:30.670]             base::options(...future.oldOptions)
[10:22:30.670]             if (.Platform$OS.type == "windows") {
[10:22:30.670]                 old_names <- names(...future.oldEnvVars)
[10:22:30.670]                 envs <- base::Sys.getenv()
[10:22:30.670]                 names <- names(envs)
[10:22:30.670]                 common <- intersect(names, old_names)
[10:22:30.670]                 added <- setdiff(names, old_names)
[10:22:30.670]                 removed <- setdiff(old_names, names)
[10:22:30.670]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:30.670]                   envs[common]]
[10:22:30.670]                 NAMES <- toupper(changed)
[10:22:30.670]                 args <- list()
[10:22:30.670]                 for (kk in seq_along(NAMES)) {
[10:22:30.670]                   name <- changed[[kk]]
[10:22:30.670]                   NAME <- NAMES[[kk]]
[10:22:30.670]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:30.670]                     next
[10:22:30.670]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:30.670]                 }
[10:22:30.670]                 NAMES <- toupper(added)
[10:22:30.670]                 for (kk in seq_along(NAMES)) {
[10:22:30.670]                   name <- added[[kk]]
[10:22:30.670]                   NAME <- NAMES[[kk]]
[10:22:30.670]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:30.670]                     next
[10:22:30.670]                   args[[name]] <- ""
[10:22:30.670]                 }
[10:22:30.670]                 NAMES <- toupper(removed)
[10:22:30.670]                 for (kk in seq_along(NAMES)) {
[10:22:30.670]                   name <- removed[[kk]]
[10:22:30.670]                   NAME <- NAMES[[kk]]
[10:22:30.670]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:30.670]                     next
[10:22:30.670]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:30.670]                 }
[10:22:30.670]                 if (length(args) > 0) 
[10:22:30.670]                   base::do.call(base::Sys.setenv, args = args)
[10:22:30.670]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:30.670]             }
[10:22:30.670]             else {
[10:22:30.670]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:30.670]             }
[10:22:30.670]             {
[10:22:30.670]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:30.670]                   0L) {
[10:22:30.670]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:30.670]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:30.670]                   base::options(opts)
[10:22:30.670]                 }
[10:22:30.670]                 {
[10:22:30.670]                   {
[10:22:30.670]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:30.670]                     NULL
[10:22:30.670]                   }
[10:22:30.670]                   options(future.plan = NULL)
[10:22:30.670]                   if (is.na(NA_character_)) 
[10:22:30.670]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:30.670]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:30.670]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:30.670]                     .init = FALSE)
[10:22:30.670]                 }
[10:22:30.670]             }
[10:22:30.670]         }
[10:22:30.670]     })
[10:22:30.670]     if (TRUE) {
[10:22:30.670]         base::sink(type = "output", split = FALSE)
[10:22:30.670]         if (TRUE) {
[10:22:30.670]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:30.670]         }
[10:22:30.670]         else {
[10:22:30.670]             ...future.result["stdout"] <- base::list(NULL)
[10:22:30.670]         }
[10:22:30.670]         base::close(...future.stdout)
[10:22:30.670]         ...future.stdout <- NULL
[10:22:30.670]     }
[10:22:30.670]     ...future.result$conditions <- ...future.conditions
[10:22:30.670]     ...future.result$finished <- base::Sys.time()
[10:22:30.670]     ...future.result
[10:22:30.670] }
[10:22:30.674] assign_globals() ...
[10:22:30.674] List of 1
[10:22:30.674]  $ kk: int 2
[10:22:30.674]  - attr(*, "where")=List of 1
[10:22:30.674]   ..$ kk:<environment: R_EmptyEnv> 
[10:22:30.674]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:30.674]  - attr(*, "resolved")= logi FALSE
[10:22:30.674]  - attr(*, "total_size")= num 35
[10:22:30.674]  - attr(*, "already-done")= logi TRUE
[10:22:30.678] - copied ‘kk’ to environment
[10:22:30.678] assign_globals() ... done
[10:22:30.678] requestCore(): workers = 2
[10:22:30.679] Poll #1 (0): usedCores() = 2, workers = 2
[10:22:30.689] result() for MulticoreFuture ...
[10:22:30.690] result() for MulticoreFuture ...
[10:22:30.690] result() for MulticoreFuture ... done
[10:22:30.690] result() for MulticoreFuture ... done
[10:22:30.690] result() for MulticoreFuture ...
[10:22:30.691] result() for MulticoreFuture ... done
[10:22:30.693] MulticoreFuture started
[10:22:30.693] - Launch lazy future ... done
[10:22:30.694] run() for ‘MulticoreFuture’ ... done
[10:22:30.694] getGlobalsAndPackages() ...
[10:22:30.694] plan(): Setting new future strategy stack:
[10:22:30.694] Searching for globals...
[10:22:30.694] List of future strategies:
[10:22:30.694] 1. sequential:
[10:22:30.694]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:30.694]    - tweaked: FALSE
[10:22:30.694]    - call: NULL
[10:22:30.696] plan(): nbrOfWorkers() = 1
[10:22:30.697] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:22:30.698] Searching for globals ... DONE
[10:22:30.698] Resolving globals: FALSE
[10:22:30.698] The total size of the 1 globals is 35 bytes (35 bytes)
[10:22:30.699] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[10:22:30.699] - globals: [1] ‘kk’
[10:22:30.699] 
[10:22:30.700] getGlobalsAndPackages() ... DONE
[10:22:30.700] run() for ‘Future’ ...
[10:22:30.700] - state: ‘created’
[10:22:30.701] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:30.704] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:30.704] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:30.704]   - Field: ‘label’
[10:22:30.704]   - Field: ‘local’
[10:22:30.704]   - Field: ‘owner’
[10:22:30.704]   - Field: ‘envir’
[10:22:30.705]   - Field: ‘workers’
[10:22:30.705]   - Field: ‘packages’
[10:22:30.705]   - Field: ‘gc’
[10:22:30.705]   - Field: ‘job’
[10:22:30.705]   - Field: ‘conditions’
[10:22:30.705]   - Field: ‘expr’
[10:22:30.705]   - Field: ‘uuid’
[10:22:30.705]   - Field: ‘seed’
[10:22:30.706]   - Field: ‘version’
[10:22:30.706]   - Field: ‘result’
[10:22:30.706]   - Field: ‘asynchronous’
[10:22:30.706]   - Field: ‘calls’
[10:22:30.706]   - Field: ‘globals’
[10:22:30.706]   - Field: ‘stdout’
[10:22:30.706]   - Field: ‘earlySignal’
[10:22:30.707]   - Field: ‘lazy’
[10:22:30.707]   - Field: ‘state’
[10:22:30.707] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:30.707] - Launch lazy future ...
[10:22:30.707] Packages needed by the future expression (n = 0): <none>
[10:22:30.708] Packages needed by future strategies (n = 0): <none>
[10:22:30.708] {
[10:22:30.708]     {
[10:22:30.708]         {
[10:22:30.708]             ...future.startTime <- base::Sys.time()
[10:22:30.708]             {
[10:22:30.708]                 {
[10:22:30.708]                   {
[10:22:30.708]                     {
[10:22:30.708]                       base::local({
[10:22:30.708]                         has_future <- base::requireNamespace("future", 
[10:22:30.708]                           quietly = TRUE)
[10:22:30.708]                         if (has_future) {
[10:22:30.708]                           ns <- base::getNamespace("future")
[10:22:30.708]                           version <- ns[[".package"]][["version"]]
[10:22:30.708]                           if (is.null(version)) 
[10:22:30.708]                             version <- utils::packageVersion("future")
[10:22:30.708]                         }
[10:22:30.708]                         else {
[10:22:30.708]                           version <- NULL
[10:22:30.708]                         }
[10:22:30.708]                         if (!has_future || version < "1.8.0") {
[10:22:30.708]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:30.708]                             "", base::R.version$version.string), 
[10:22:30.708]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:30.708]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:30.708]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:30.708]                               "release", "version")], collapse = " "), 
[10:22:30.708]                             hostname = base::Sys.info()[["nodename"]])
[10:22:30.708]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:30.708]                             info)
[10:22:30.708]                           info <- base::paste(info, collapse = "; ")
[10:22:30.708]                           if (!has_future) {
[10:22:30.708]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:30.708]                               info)
[10:22:30.708]                           }
[10:22:30.708]                           else {
[10:22:30.708]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:30.708]                               info, version)
[10:22:30.708]                           }
[10:22:30.708]                           base::stop(msg)
[10:22:30.708]                         }
[10:22:30.708]                       })
[10:22:30.708]                     }
[10:22:30.708]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:30.708]                     base::options(mc.cores = 1L)
[10:22:30.708]                   }
[10:22:30.708]                   ...future.strategy.old <- future::plan("list")
[10:22:30.708]                   options(future.plan = NULL)
[10:22:30.708]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:30.708]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:30.708]                 }
[10:22:30.708]                 ...future.workdir <- getwd()
[10:22:30.708]             }
[10:22:30.708]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:30.708]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:30.708]         }
[10:22:30.708]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:30.708]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:30.708]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:30.708]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:30.708]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:30.708]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:30.708]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:30.708]             base::names(...future.oldOptions))
[10:22:30.708]     }
[10:22:30.708]     if (FALSE) {
[10:22:30.708]     }
[10:22:30.708]     else {
[10:22:30.708]         if (TRUE) {
[10:22:30.708]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:30.708]                 open = "w")
[10:22:30.708]         }
[10:22:30.708]         else {
[10:22:30.708]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:30.708]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:30.708]         }
[10:22:30.708]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:30.708]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:30.708]             base::sink(type = "output", split = FALSE)
[10:22:30.708]             base::close(...future.stdout)
[10:22:30.708]         }, add = TRUE)
[10:22:30.708]     }
[10:22:30.708]     ...future.frame <- base::sys.nframe()
[10:22:30.708]     ...future.conditions <- base::list()
[10:22:30.708]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:30.708]     if (FALSE) {
[10:22:30.708]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:30.708]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:30.708]     }
[10:22:30.708]     ...future.result <- base::tryCatch({
[10:22:30.708]         base::withCallingHandlers({
[10:22:30.708]             ...future.value <- base::withVisible(base::local({
[10:22:30.708]                 withCallingHandlers({
[10:22:30.708]                   {
[10:22:30.708]                     Sys.sleep(0.1)
[10:22:30.708]                     kk
[10:22:30.708]                   }
[10:22:30.708]                 }, immediateCondition = function(cond) {
[10:22:30.708]                   save_rds <- function (object, pathname, ...) 
[10:22:30.708]                   {
[10:22:30.708]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:30.708]                     if (file_test("-f", pathname_tmp)) {
[10:22:30.708]                       fi_tmp <- file.info(pathname_tmp)
[10:22:30.708]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:30.708]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:30.708]                         fi_tmp[["mtime"]])
[10:22:30.708]                     }
[10:22:30.708]                     tryCatch({
[10:22:30.708]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:30.708]                     }, error = function(ex) {
[10:22:30.708]                       msg <- conditionMessage(ex)
[10:22:30.708]                       fi_tmp <- file.info(pathname_tmp)
[10:22:30.708]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:30.708]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:30.708]                         fi_tmp[["mtime"]], msg)
[10:22:30.708]                       ex$message <- msg
[10:22:30.708]                       stop(ex)
[10:22:30.708]                     })
[10:22:30.708]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:30.708]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:30.708]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:30.708]                       fi_tmp <- file.info(pathname_tmp)
[10:22:30.708]                       fi <- file.info(pathname)
[10:22:30.708]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:30.708]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:30.708]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:30.708]                         fi[["size"]], fi[["mtime"]])
[10:22:30.708]                       stop(msg)
[10:22:30.708]                     }
[10:22:30.708]                     invisible(pathname)
[10:22:30.708]                   }
[10:22:30.708]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:30.708]                     rootPath = tempdir()) 
[10:22:30.708]                   {
[10:22:30.708]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:30.708]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:30.708]                       tmpdir = path, fileext = ".rds")
[10:22:30.708]                     save_rds(obj, file)
[10:22:30.708]                   }
[10:22:30.708]                   saveImmediateCondition(cond, path = "/tmp/RtmpzsJv4f/.future/immediateConditions")
[10:22:30.708]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:30.708]                   {
[10:22:30.708]                     inherits <- base::inherits
[10:22:30.708]                     invokeRestart <- base::invokeRestart
[10:22:30.708]                     is.null <- base::is.null
[10:22:30.708]                     muffled <- FALSE
[10:22:30.708]                     if (inherits(cond, "message")) {
[10:22:30.708]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:30.708]                       if (muffled) 
[10:22:30.708]                         invokeRestart("muffleMessage")
[10:22:30.708]                     }
[10:22:30.708]                     else if (inherits(cond, "warning")) {
[10:22:30.708]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:30.708]                       if (muffled) 
[10:22:30.708]                         invokeRestart("muffleWarning")
[10:22:30.708]                     }
[10:22:30.708]                     else if (inherits(cond, "condition")) {
[10:22:30.708]                       if (!is.null(pattern)) {
[10:22:30.708]                         computeRestarts <- base::computeRestarts
[10:22:30.708]                         grepl <- base::grepl
[10:22:30.708]                         restarts <- computeRestarts(cond)
[10:22:30.708]                         for (restart in restarts) {
[10:22:30.708]                           name <- restart$name
[10:22:30.708]                           if (is.null(name)) 
[10:22:30.708]                             next
[10:22:30.708]                           if (!grepl(pattern, name)) 
[10:22:30.708]                             next
[10:22:30.708]                           invokeRestart(restart)
[10:22:30.708]                           muffled <- TRUE
[10:22:30.708]                           break
[10:22:30.708]                         }
[10:22:30.708]                       }
[10:22:30.708]                     }
[10:22:30.708]                     invisible(muffled)
[10:22:30.708]                   }
[10:22:30.708]                   muffleCondition(cond)
[10:22:30.708]                 })
[10:22:30.708]             }))
[10:22:30.708]             future::FutureResult(value = ...future.value$value, 
[10:22:30.708]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:30.708]                   ...future.rng), globalenv = if (FALSE) 
[10:22:30.708]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:30.708]                     ...future.globalenv.names))
[10:22:30.708]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:30.708]         }, condition = base::local({
[10:22:30.708]             c <- base::c
[10:22:30.708]             inherits <- base::inherits
[10:22:30.708]             invokeRestart <- base::invokeRestart
[10:22:30.708]             length <- base::length
[10:22:30.708]             list <- base::list
[10:22:30.708]             seq.int <- base::seq.int
[10:22:30.708]             signalCondition <- base::signalCondition
[10:22:30.708]             sys.calls <- base::sys.calls
[10:22:30.708]             `[[` <- base::`[[`
[10:22:30.708]             `+` <- base::`+`
[10:22:30.708]             `<<-` <- base::`<<-`
[10:22:30.708]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:30.708]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:30.708]                   3L)]
[10:22:30.708]             }
[10:22:30.708]             function(cond) {
[10:22:30.708]                 is_error <- inherits(cond, "error")
[10:22:30.708]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:30.708]                   NULL)
[10:22:30.708]                 if (is_error) {
[10:22:30.708]                   sessionInformation <- function() {
[10:22:30.708]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:30.708]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:30.708]                       search = base::search(), system = base::Sys.info())
[10:22:30.708]                   }
[10:22:30.708]                   ...future.conditions[[length(...future.conditions) + 
[10:22:30.708]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:30.708]                     cond$call), session = sessionInformation(), 
[10:22:30.708]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:30.708]                   signalCondition(cond)
[10:22:30.708]                 }
[10:22:30.708]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:30.708]                 "immediateCondition"))) {
[10:22:30.708]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:30.708]                   ...future.conditions[[length(...future.conditions) + 
[10:22:30.708]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:30.708]                   if (TRUE && !signal) {
[10:22:30.708]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:30.708]                     {
[10:22:30.708]                       inherits <- base::inherits
[10:22:30.708]                       invokeRestart <- base::invokeRestart
[10:22:30.708]                       is.null <- base::is.null
[10:22:30.708]                       muffled <- FALSE
[10:22:30.708]                       if (inherits(cond, "message")) {
[10:22:30.708]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:30.708]                         if (muffled) 
[10:22:30.708]                           invokeRestart("muffleMessage")
[10:22:30.708]                       }
[10:22:30.708]                       else if (inherits(cond, "warning")) {
[10:22:30.708]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:30.708]                         if (muffled) 
[10:22:30.708]                           invokeRestart("muffleWarning")
[10:22:30.708]                       }
[10:22:30.708]                       else if (inherits(cond, "condition")) {
[10:22:30.708]                         if (!is.null(pattern)) {
[10:22:30.708]                           computeRestarts <- base::computeRestarts
[10:22:30.708]                           grepl <- base::grepl
[10:22:30.708]                           restarts <- computeRestarts(cond)
[10:22:30.708]                           for (restart in restarts) {
[10:22:30.708]                             name <- restart$name
[10:22:30.708]                             if (is.null(name)) 
[10:22:30.708]                               next
[10:22:30.708]                             if (!grepl(pattern, name)) 
[10:22:30.708]                               next
[10:22:30.708]                             invokeRestart(restart)
[10:22:30.708]                             muffled <- TRUE
[10:22:30.708]                             break
[10:22:30.708]                           }
[10:22:30.708]                         }
[10:22:30.708]                       }
[10:22:30.708]                       invisible(muffled)
[10:22:30.708]                     }
[10:22:30.708]                     muffleCondition(cond, pattern = "^muffle")
[10:22:30.708]                   }
[10:22:30.708]                 }
[10:22:30.708]                 else {
[10:22:30.708]                   if (TRUE) {
[10:22:30.708]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:30.708]                     {
[10:22:30.708]                       inherits <- base::inherits
[10:22:30.708]                       invokeRestart <- base::invokeRestart
[10:22:30.708]                       is.null <- base::is.null
[10:22:30.708]                       muffled <- FALSE
[10:22:30.708]                       if (inherits(cond, "message")) {
[10:22:30.708]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:30.708]                         if (muffled) 
[10:22:30.708]                           invokeRestart("muffleMessage")
[10:22:30.708]                       }
[10:22:30.708]                       else if (inherits(cond, "warning")) {
[10:22:30.708]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:30.708]                         if (muffled) 
[10:22:30.708]                           invokeRestart("muffleWarning")
[10:22:30.708]                       }
[10:22:30.708]                       else if (inherits(cond, "condition")) {
[10:22:30.708]                         if (!is.null(pattern)) {
[10:22:30.708]                           computeRestarts <- base::computeRestarts
[10:22:30.708]                           grepl <- base::grepl
[10:22:30.708]                           restarts <- computeRestarts(cond)
[10:22:30.708]                           for (restart in restarts) {
[10:22:30.708]                             name <- restart$name
[10:22:30.708]                             if (is.null(name)) 
[10:22:30.708]                               next
[10:22:30.708]                             if (!grepl(pattern, name)) 
[10:22:30.708]                               next
[10:22:30.708]                             invokeRestart(restart)
[10:22:30.708]                             muffled <- TRUE
[10:22:30.708]                             break
[10:22:30.708]                           }
[10:22:30.708]                         }
[10:22:30.708]                       }
[10:22:30.708]                       invisible(muffled)
[10:22:30.708]                     }
[10:22:30.708]                     muffleCondition(cond, pattern = "^muffle")
[10:22:30.708]                   }
[10:22:30.708]                 }
[10:22:30.708]             }
[10:22:30.708]         }))
[10:22:30.708]     }, error = function(ex) {
[10:22:30.708]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:30.708]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:30.708]                 ...future.rng), started = ...future.startTime, 
[10:22:30.708]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:30.708]             version = "1.8"), class = "FutureResult")
[10:22:30.708]     }, finally = {
[10:22:30.708]         if (!identical(...future.workdir, getwd())) 
[10:22:30.708]             setwd(...future.workdir)
[10:22:30.708]         {
[10:22:30.708]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:30.708]                 ...future.oldOptions$nwarnings <- NULL
[10:22:30.708]             }
[10:22:30.708]             base::options(...future.oldOptions)
[10:22:30.708]             if (.Platform$OS.type == "windows") {
[10:22:30.708]                 old_names <- names(...future.oldEnvVars)
[10:22:30.708]                 envs <- base::Sys.getenv()
[10:22:30.708]                 names <- names(envs)
[10:22:30.708]                 common <- intersect(names, old_names)
[10:22:30.708]                 added <- setdiff(names, old_names)
[10:22:30.708]                 removed <- setdiff(old_names, names)
[10:22:30.708]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:30.708]                   envs[common]]
[10:22:30.708]                 NAMES <- toupper(changed)
[10:22:30.708]                 args <- list()
[10:22:30.708]                 for (kk in seq_along(NAMES)) {
[10:22:30.708]                   name <- changed[[kk]]
[10:22:30.708]                   NAME <- NAMES[[kk]]
[10:22:30.708]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:30.708]                     next
[10:22:30.708]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:30.708]                 }
[10:22:30.708]                 NAMES <- toupper(added)
[10:22:30.708]                 for (kk in seq_along(NAMES)) {
[10:22:30.708]                   name <- added[[kk]]
[10:22:30.708]                   NAME <- NAMES[[kk]]
[10:22:30.708]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:30.708]                     next
[10:22:30.708]                   args[[name]] <- ""
[10:22:30.708]                 }
[10:22:30.708]                 NAMES <- toupper(removed)
[10:22:30.708]                 for (kk in seq_along(NAMES)) {
[10:22:30.708]                   name <- removed[[kk]]
[10:22:30.708]                   NAME <- NAMES[[kk]]
[10:22:30.708]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:30.708]                     next
[10:22:30.708]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:30.708]                 }
[10:22:30.708]                 if (length(args) > 0) 
[10:22:30.708]                   base::do.call(base::Sys.setenv, args = args)
[10:22:30.708]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:30.708]             }
[10:22:30.708]             else {
[10:22:30.708]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:30.708]             }
[10:22:30.708]             {
[10:22:30.708]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:30.708]                   0L) {
[10:22:30.708]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:30.708]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:30.708]                   base::options(opts)
[10:22:30.708]                 }
[10:22:30.708]                 {
[10:22:30.708]                   {
[10:22:30.708]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:30.708]                     NULL
[10:22:30.708]                   }
[10:22:30.708]                   options(future.plan = NULL)
[10:22:30.708]                   if (is.na(NA_character_)) 
[10:22:30.708]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:30.708]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:30.708]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:30.708]                     .init = FALSE)
[10:22:30.708]                 }
[10:22:30.708]             }
[10:22:30.708]         }
[10:22:30.708]     })
[10:22:30.708]     if (TRUE) {
[10:22:30.708]         base::sink(type = "output", split = FALSE)
[10:22:30.708]         if (TRUE) {
[10:22:30.708]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:30.708]         }
[10:22:30.708]         else {
[10:22:30.708]             ...future.result["stdout"] <- base::list(NULL)
[10:22:30.708]         }
[10:22:30.708]         base::close(...future.stdout)
[10:22:30.708]         ...future.stdout <- NULL
[10:22:30.708]     }
[10:22:30.708]     ...future.result$conditions <- ...future.conditions
[10:22:30.708]     ...future.result$finished <- base::Sys.time()
[10:22:30.708]     ...future.result
[10:22:30.708] }
[10:22:30.712] assign_globals() ...
[10:22:30.712] List of 1
[10:22:30.712]  $ kk: int 3
[10:22:30.712]  - attr(*, "where")=List of 1
[10:22:30.712]   ..$ kk:<environment: R_EmptyEnv> 
[10:22:30.712]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:30.712]  - attr(*, "resolved")= logi FALSE
[10:22:30.712]  - attr(*, "total_size")= num 35
[10:22:30.712]  - attr(*, "already-done")= logi TRUE
[10:22:30.719] - copied ‘kk’ to environment
[10:22:30.719] assign_globals() ... done
[10:22:30.720] requestCore(): workers = 2
[10:22:30.720] Poll #1 (0): usedCores() = 2, workers = 2
[10:22:30.752] Poll #2 (0.03 secs): usedCores() = 2, workers = 2
[10:22:30.759] plan(): Setting new future strategy stack:
[10:22:30.760] List of future strategies:
[10:22:30.760] 1. multicore:
[10:22:30.760]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:30.760]    - tweaked: FALSE
[10:22:30.760]    - call: plan(strategy)
[10:22:30.762] plan(): nbrOfWorkers() = 2
[10:22:30.763] result() for MulticoreFuture ...
[10:22:30.764] result() for MulticoreFuture ...
[10:22:30.764] result() for MulticoreFuture ... done
[10:22:30.764] result() for MulticoreFuture ... done
[10:22:30.764] result() for MulticoreFuture ...
[10:22:30.764] result() for MulticoreFuture ... done
[10:22:30.767] MulticoreFuture started
[10:22:30.768] - Launch lazy future ... done
[10:22:30.768] run() for ‘MulticoreFuture’ ... done
[10:22:30.768] plan(): Setting new future strategy stack:
[10:22:30.769] resolve() on list ...
[10:22:30.769]  recursive: 0
[10:22:30.769]  length: 3
[10:22:30.770] 
[10:22:30.769] List of future strategies:
[10:22:30.769] 1. sequential:
[10:22:30.769]    - args: function (..., envir = parent.[10:22:30.770] Future #1
frame(), workers = "<NULL>")
[10:22:30.769]    - tweaked: FALSE
[10:22:30.769]    - call: NULL
[10:22:30.770]  length: 2 (resolved future 1)
[10:22:30.771] plan(): nbrOfWorkers() = 1
[10:22:30.799] plan(): Setting new future strategy stack:
[10:22:30.799] List of future strategies:
[10:22:30.799] 1. multicore:
[10:22:30.799]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:30.799]    - tweaked: FALSE
[10:22:30.799]    - call: plan(strategy)
[10:22:30.801] plan(): nbrOfWorkers() = 2
[10:22:30.802] Future #2
[10:22:30.802]  length: 1 (resolved future 2)
[10:22:30.873] plan(): Setting new future strategy stack:
[10:22:30.873] List of future strategies:
[10:22:30.873] 1. multicore:
[10:22:30.873]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:30.873]    - tweaked: FALSE
[10:22:30.873]    - call: plan(strategy)
[10:22:30.877] plan(): nbrOfWorkers() = 2
[10:22:30.884] Future #3
[10:22:30.885]  length: 0 (resolved future 3)
[10:22:30.885] resolve() on list ... DONE
[10:22:30.885] getGlobalsAndPackages() ...
[10:22:30.885] Searching for globals...
[10:22:30.887] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:22:30.888] Searching for globals ... DONE
[10:22:30.888] Resolving globals: FALSE
[10:22:30.889] The total size of the 1 globals is 35 bytes (35 bytes)
[10:22:30.889] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[10:22:30.889] - globals: [1] ‘kk’
[10:22:30.890] 
[10:22:30.890] getGlobalsAndPackages() ... DONE
[10:22:30.890] getGlobalsAndPackages() ...
[10:22:30.890] Searching for globals...
[10:22:30.892] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:22:30.892] Searching for globals ... DONE
[10:22:30.892] Resolving globals: FALSE
[10:22:30.893] The total size of the 1 globals is 35 bytes (35 bytes)
[10:22:30.893] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[10:22:30.893] - globals: [1] ‘kk’
[10:22:30.893] 
[10:22:30.894] getGlobalsAndPackages() ... DONE
[10:22:30.894] getGlobalsAndPackages() ...
[10:22:30.894] Searching for globals...
[10:22:30.895] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:22:30.896] Searching for globals ... DONE
[10:22:30.896] Resolving globals: FALSE
[10:22:30.896] The total size of the 1 globals is 35 bytes (35 bytes)
[10:22:30.897] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[10:22:30.897] - globals: [1] ‘kk’
[10:22:30.897] 
[10:22:30.897] getGlobalsAndPackages() ... DONE
[10:22:30.897] resolve() on list ...
[10:22:30.898]  recursive: 0
[10:22:30.898]  length: 3
[10:22:30.898] 
[10:22:30.898] run() for ‘Future’ ...
[10:22:30.898] - state: ‘created’
[10:22:30.898] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:30.901] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:30.901] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:30.901]   - Field: ‘label’
[10:22:30.901]   - Field: ‘local’
[10:22:30.901]   - Field: ‘owner’
[10:22:30.901]   - Field: ‘envir’
[10:22:30.902]   - Field: ‘workers’
[10:22:30.902]   - Field: ‘packages’
[10:22:30.902]   - Field: ‘gc’
[10:22:30.902]   - Field: ‘job’
[10:22:30.902]   - Field: ‘conditions’
[10:22:30.902]   - Field: ‘expr’
[10:22:30.902]   - Field: ‘uuid’
[10:22:30.902]   - Field: ‘seed’
[10:22:30.903]   - Field: ‘version’
[10:22:30.903]   - Field: ‘result’
[10:22:30.903]   - Field: ‘asynchronous’
[10:22:30.903]   - Field: ‘calls’
[10:22:30.903]   - Field: ‘globals’
[10:22:30.903]   - Field: ‘stdout’
[10:22:30.903]   - Field: ‘earlySignal’
[10:22:30.903]   - Field: ‘lazy’
[10:22:30.904]   - Field: ‘state’
[10:22:30.904] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:30.904] - Launch lazy future ...
[10:22:30.904] Packages needed by the future expression (n = 0): <none>
[10:22:30.904] Packages needed by future strategies (n = 0): <none>
[10:22:30.905] {
[10:22:30.905]     {
[10:22:30.905]         {
[10:22:30.905]             ...future.startTime <- base::Sys.time()
[10:22:30.905]             {
[10:22:30.905]                 {
[10:22:30.905]                   {
[10:22:30.905]                     {
[10:22:30.905]                       base::local({
[10:22:30.905]                         has_future <- base::requireNamespace("future", 
[10:22:30.905]                           quietly = TRUE)
[10:22:30.905]                         if (has_future) {
[10:22:30.905]                           ns <- base::getNamespace("future")
[10:22:30.905]                           version <- ns[[".package"]][["version"]]
[10:22:30.905]                           if (is.null(version)) 
[10:22:30.905]                             version <- utils::packageVersion("future")
[10:22:30.905]                         }
[10:22:30.905]                         else {
[10:22:30.905]                           version <- NULL
[10:22:30.905]                         }
[10:22:30.905]                         if (!has_future || version < "1.8.0") {
[10:22:30.905]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:30.905]                             "", base::R.version$version.string), 
[10:22:30.905]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:30.905]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:30.905]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:30.905]                               "release", "version")], collapse = " "), 
[10:22:30.905]                             hostname = base::Sys.info()[["nodename"]])
[10:22:30.905]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:30.905]                             info)
[10:22:30.905]                           info <- base::paste(info, collapse = "; ")
[10:22:30.905]                           if (!has_future) {
[10:22:30.905]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:30.905]                               info)
[10:22:30.905]                           }
[10:22:30.905]                           else {
[10:22:30.905]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:30.905]                               info, version)
[10:22:30.905]                           }
[10:22:30.905]                           base::stop(msg)
[10:22:30.905]                         }
[10:22:30.905]                       })
[10:22:30.905]                     }
[10:22:30.905]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:30.905]                     base::options(mc.cores = 1L)
[10:22:30.905]                   }
[10:22:30.905]                   ...future.strategy.old <- future::plan("list")
[10:22:30.905]                   options(future.plan = NULL)
[10:22:30.905]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:30.905]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:30.905]                 }
[10:22:30.905]                 ...future.workdir <- getwd()
[10:22:30.905]             }
[10:22:30.905]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:30.905]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:30.905]         }
[10:22:30.905]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:30.905]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:30.905]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:30.905]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:30.905]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:30.905]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:30.905]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:30.905]             base::names(...future.oldOptions))
[10:22:30.905]     }
[10:22:30.905]     if (FALSE) {
[10:22:30.905]     }
[10:22:30.905]     else {
[10:22:30.905]         if (TRUE) {
[10:22:30.905]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:30.905]                 open = "w")
[10:22:30.905]         }
[10:22:30.905]         else {
[10:22:30.905]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:30.905]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:30.905]         }
[10:22:30.905]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:30.905]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:30.905]             base::sink(type = "output", split = FALSE)
[10:22:30.905]             base::close(...future.stdout)
[10:22:30.905]         }, add = TRUE)
[10:22:30.905]     }
[10:22:30.905]     ...future.frame <- base::sys.nframe()
[10:22:30.905]     ...future.conditions <- base::list()
[10:22:30.905]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:30.905]     if (FALSE) {
[10:22:30.905]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:30.905]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:30.905]     }
[10:22:30.905]     ...future.result <- base::tryCatch({
[10:22:30.905]         base::withCallingHandlers({
[10:22:30.905]             ...future.value <- base::withVisible(base::local({
[10:22:30.905]                 withCallingHandlers({
[10:22:30.905]                   {
[10:22:30.905]                     Sys.sleep(0.1)
[10:22:30.905]                     kk
[10:22:30.905]                   }
[10:22:30.905]                 }, immediateCondition = function(cond) {
[10:22:30.905]                   save_rds <- function (object, pathname, ...) 
[10:22:30.905]                   {
[10:22:30.905]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:30.905]                     if (file_test("-f", pathname_tmp)) {
[10:22:30.905]                       fi_tmp <- file.info(pathname_tmp)
[10:22:30.905]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:30.905]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:30.905]                         fi_tmp[["mtime"]])
[10:22:30.905]                     }
[10:22:30.905]                     tryCatch({
[10:22:30.905]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:30.905]                     }, error = function(ex) {
[10:22:30.905]                       msg <- conditionMessage(ex)
[10:22:30.905]                       fi_tmp <- file.info(pathname_tmp)
[10:22:30.905]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:30.905]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:30.905]                         fi_tmp[["mtime"]], msg)
[10:22:30.905]                       ex$message <- msg
[10:22:30.905]                       stop(ex)
[10:22:30.905]                     })
[10:22:30.905]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:30.905]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:30.905]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:30.905]                       fi_tmp <- file.info(pathname_tmp)
[10:22:30.905]                       fi <- file.info(pathname)
[10:22:30.905]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:30.905]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:30.905]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:30.905]                         fi[["size"]], fi[["mtime"]])
[10:22:30.905]                       stop(msg)
[10:22:30.905]                     }
[10:22:30.905]                     invisible(pathname)
[10:22:30.905]                   }
[10:22:30.905]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:30.905]                     rootPath = tempdir()) 
[10:22:30.905]                   {
[10:22:30.905]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:30.905]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:30.905]                       tmpdir = path, fileext = ".rds")
[10:22:30.905]                     save_rds(obj, file)
[10:22:30.905]                   }
[10:22:30.905]                   saveImmediateCondition(cond, path = "/tmp/RtmpzsJv4f/.future/immediateConditions")
[10:22:30.905]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:30.905]                   {
[10:22:30.905]                     inherits <- base::inherits
[10:22:30.905]                     invokeRestart <- base::invokeRestart
[10:22:30.905]                     is.null <- base::is.null
[10:22:30.905]                     muffled <- FALSE
[10:22:30.905]                     if (inherits(cond, "message")) {
[10:22:30.905]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:30.905]                       if (muffled) 
[10:22:30.905]                         invokeRestart("muffleMessage")
[10:22:30.905]                     }
[10:22:30.905]                     else if (inherits(cond, "warning")) {
[10:22:30.905]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:30.905]                       if (muffled) 
[10:22:30.905]                         invokeRestart("muffleWarning")
[10:22:30.905]                     }
[10:22:30.905]                     else if (inherits(cond, "condition")) {
[10:22:30.905]                       if (!is.null(pattern)) {
[10:22:30.905]                         computeRestarts <- base::computeRestarts
[10:22:30.905]                         grepl <- base::grepl
[10:22:30.905]                         restarts <- computeRestarts(cond)
[10:22:30.905]                         for (restart in restarts) {
[10:22:30.905]                           name <- restart$name
[10:22:30.905]                           if (is.null(name)) 
[10:22:30.905]                             next
[10:22:30.905]                           if (!grepl(pattern, name)) 
[10:22:30.905]                             next
[10:22:30.905]                           invokeRestart(restart)
[10:22:30.905]                           muffled <- TRUE
[10:22:30.905]                           break
[10:22:30.905]                         }
[10:22:30.905]                       }
[10:22:30.905]                     }
[10:22:30.905]                     invisible(muffled)
[10:22:30.905]                   }
[10:22:30.905]                   muffleCondition(cond)
[10:22:30.905]                 })
[10:22:30.905]             }))
[10:22:30.905]             future::FutureResult(value = ...future.value$value, 
[10:22:30.905]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:30.905]                   ...future.rng), globalenv = if (FALSE) 
[10:22:30.905]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:30.905]                     ...future.globalenv.names))
[10:22:30.905]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:30.905]         }, condition = base::local({
[10:22:30.905]             c <- base::c
[10:22:30.905]             inherits <- base::inherits
[10:22:30.905]             invokeRestart <- base::invokeRestart
[10:22:30.905]             length <- base::length
[10:22:30.905]             list <- base::list
[10:22:30.905]             seq.int <- base::seq.int
[10:22:30.905]             signalCondition <- base::signalCondition
[10:22:30.905]             sys.calls <- base::sys.calls
[10:22:30.905]             `[[` <- base::`[[`
[10:22:30.905]             `+` <- base::`+`
[10:22:30.905]             `<<-` <- base::`<<-`
[10:22:30.905]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:30.905]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:30.905]                   3L)]
[10:22:30.905]             }
[10:22:30.905]             function(cond) {
[10:22:30.905]                 is_error <- inherits(cond, "error")
[10:22:30.905]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:30.905]                   NULL)
[10:22:30.905]                 if (is_error) {
[10:22:30.905]                   sessionInformation <- function() {
[10:22:30.905]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:30.905]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:30.905]                       search = base::search(), system = base::Sys.info())
[10:22:30.905]                   }
[10:22:30.905]                   ...future.conditions[[length(...future.conditions) + 
[10:22:30.905]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:30.905]                     cond$call), session = sessionInformation(), 
[10:22:30.905]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:30.905]                   signalCondition(cond)
[10:22:30.905]                 }
[10:22:30.905]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:30.905]                 "immediateCondition"))) {
[10:22:30.905]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:30.905]                   ...future.conditions[[length(...future.conditions) + 
[10:22:30.905]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:30.905]                   if (TRUE && !signal) {
[10:22:30.905]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:30.905]                     {
[10:22:30.905]                       inherits <- base::inherits
[10:22:30.905]                       invokeRestart <- base::invokeRestart
[10:22:30.905]                       is.null <- base::is.null
[10:22:30.905]                       muffled <- FALSE
[10:22:30.905]                       if (inherits(cond, "message")) {
[10:22:30.905]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:30.905]                         if (muffled) 
[10:22:30.905]                           invokeRestart("muffleMessage")
[10:22:30.905]                       }
[10:22:30.905]                       else if (inherits(cond, "warning")) {
[10:22:30.905]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:30.905]                         if (muffled) 
[10:22:30.905]                           invokeRestart("muffleWarning")
[10:22:30.905]                       }
[10:22:30.905]                       else if (inherits(cond, "condition")) {
[10:22:30.905]                         if (!is.null(pattern)) {
[10:22:30.905]                           computeRestarts <- base::computeRestarts
[10:22:30.905]                           grepl <- base::grepl
[10:22:30.905]                           restarts <- computeRestarts(cond)
[10:22:30.905]                           for (restart in restarts) {
[10:22:30.905]                             name <- restart$name
[10:22:30.905]                             if (is.null(name)) 
[10:22:30.905]                               next
[10:22:30.905]                             if (!grepl(pattern, name)) 
[10:22:30.905]                               next
[10:22:30.905]                             invokeRestart(restart)
[10:22:30.905]                             muffled <- TRUE
[10:22:30.905]                             break
[10:22:30.905]                           }
[10:22:30.905]                         }
[10:22:30.905]                       }
[10:22:30.905]                       invisible(muffled)
[10:22:30.905]                     }
[10:22:30.905]                     muffleCondition(cond, pattern = "^muffle")
[10:22:30.905]                   }
[10:22:30.905]                 }
[10:22:30.905]                 else {
[10:22:30.905]                   if (TRUE) {
[10:22:30.905]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:30.905]                     {
[10:22:30.905]                       inherits <- base::inherits
[10:22:30.905]                       invokeRestart <- base::invokeRestart
[10:22:30.905]                       is.null <- base::is.null
[10:22:30.905]                       muffled <- FALSE
[10:22:30.905]                       if (inherits(cond, "message")) {
[10:22:30.905]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:30.905]                         if (muffled) 
[10:22:30.905]                           invokeRestart("muffleMessage")
[10:22:30.905]                       }
[10:22:30.905]                       else if (inherits(cond, "warning")) {
[10:22:30.905]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:30.905]                         if (muffled) 
[10:22:30.905]                           invokeRestart("muffleWarning")
[10:22:30.905]                       }
[10:22:30.905]                       else if (inherits(cond, "condition")) {
[10:22:30.905]                         if (!is.null(pattern)) {
[10:22:30.905]                           computeRestarts <- base::computeRestarts
[10:22:30.905]                           grepl <- base::grepl
[10:22:30.905]                           restarts <- computeRestarts(cond)
[10:22:30.905]                           for (restart in restarts) {
[10:22:30.905]                             name <- restart$name
[10:22:30.905]                             if (is.null(name)) 
[10:22:30.905]                               next
[10:22:30.905]                             if (!grepl(pattern, name)) 
[10:22:30.905]                               next
[10:22:30.905]                             invokeRestart(restart)
[10:22:30.905]                             muffled <- TRUE
[10:22:30.905]                             break
[10:22:30.905]                           }
[10:22:30.905]                         }
[10:22:30.905]                       }
[10:22:30.905]                       invisible(muffled)
[10:22:30.905]                     }
[10:22:30.905]                     muffleCondition(cond, pattern = "^muffle")
[10:22:30.905]                   }
[10:22:30.905]                 }
[10:22:30.905]             }
[10:22:30.905]         }))
[10:22:30.905]     }, error = function(ex) {
[10:22:30.905]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:30.905]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:30.905]                 ...future.rng), started = ...future.startTime, 
[10:22:30.905]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:30.905]             version = "1.8"), class = "FutureResult")
[10:22:30.905]     }, finally = {
[10:22:30.905]         if (!identical(...future.workdir, getwd())) 
[10:22:30.905]             setwd(...future.workdir)
[10:22:30.905]         {
[10:22:30.905]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:30.905]                 ...future.oldOptions$nwarnings <- NULL
[10:22:30.905]             }
[10:22:30.905]             base::options(...future.oldOptions)
[10:22:30.905]             if (.Platform$OS.type == "windows") {
[10:22:30.905]                 old_names <- names(...future.oldEnvVars)
[10:22:30.905]                 envs <- base::Sys.getenv()
[10:22:30.905]                 names <- names(envs)
[10:22:30.905]                 common <- intersect(names, old_names)
[10:22:30.905]                 added <- setdiff(names, old_names)
[10:22:30.905]                 removed <- setdiff(old_names, names)
[10:22:30.905]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:30.905]                   envs[common]]
[10:22:30.905]                 NAMES <- toupper(changed)
[10:22:30.905]                 args <- list()
[10:22:30.905]                 for (kk in seq_along(NAMES)) {
[10:22:30.905]                   name <- changed[[kk]]
[10:22:30.905]                   NAME <- NAMES[[kk]]
[10:22:30.905]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:30.905]                     next
[10:22:30.905]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:30.905]                 }
[10:22:30.905]                 NAMES <- toupper(added)
[10:22:30.905]                 for (kk in seq_along(NAMES)) {
[10:22:30.905]                   name <- added[[kk]]
[10:22:30.905]                   NAME <- NAMES[[kk]]
[10:22:30.905]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:30.905]                     next
[10:22:30.905]                   args[[name]] <- ""
[10:22:30.905]                 }
[10:22:30.905]                 NAMES <- toupper(removed)
[10:22:30.905]                 for (kk in seq_along(NAMES)) {
[10:22:30.905]                   name <- removed[[kk]]
[10:22:30.905]                   NAME <- NAMES[[kk]]
[10:22:30.905]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:30.905]                     next
[10:22:30.905]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:30.905]                 }
[10:22:30.905]                 if (length(args) > 0) 
[10:22:30.905]                   base::do.call(base::Sys.setenv, args = args)
[10:22:30.905]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:30.905]             }
[10:22:30.905]             else {
[10:22:30.905]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:30.905]             }
[10:22:30.905]             {
[10:22:30.905]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:30.905]                   0L) {
[10:22:30.905]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:30.905]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:30.905]                   base::options(opts)
[10:22:30.905]                 }
[10:22:30.905]                 {
[10:22:30.905]                   {
[10:22:30.905]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:30.905]                     NULL
[10:22:30.905]                   }
[10:22:30.905]                   options(future.plan = NULL)
[10:22:30.905]                   if (is.na(NA_character_)) 
[10:22:30.905]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:30.905]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:30.905]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:30.905]                     .init = FALSE)
[10:22:30.905]                 }
[10:22:30.905]             }
[10:22:30.905]         }
[10:22:30.905]     })
[10:22:30.905]     if (TRUE) {
[10:22:30.905]         base::sink(type = "output", split = FALSE)
[10:22:30.905]         if (TRUE) {
[10:22:30.905]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:30.905]         }
[10:22:30.905]         else {
[10:22:30.905]             ...future.result["stdout"] <- base::list(NULL)
[10:22:30.905]         }
[10:22:30.905]         base::close(...future.stdout)
[10:22:30.905]         ...future.stdout <- NULL
[10:22:30.905]     }
[10:22:30.905]     ...future.result$conditions <- ...future.conditions
[10:22:30.905]     ...future.result$finished <- base::Sys.time()
[10:22:30.905]     ...future.result
[10:22:30.905] }
[10:22:30.909] assign_globals() ...
[10:22:30.909] List of 1
[10:22:30.909]  $ kk: int 1
[10:22:30.909]  - attr(*, "where")=List of 1
[10:22:30.909]   ..$ kk:<environment: R_EmptyEnv> 
[10:22:30.909]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:30.909]  - attr(*, "resolved")= logi FALSE
[10:22:30.909]  - attr(*, "total_size")= num 35
[10:22:30.909]  - attr(*, "already-done")= logi TRUE
[10:22:30.912] - copied ‘kk’ to environment
[10:22:30.912] assign_globals() ... done
[10:22:30.913] requestCore(): workers = 2
[10:22:30.913] Poll #1 (0): usedCores() = 2, workers = 2
[10:22:30.924] result() for MulticoreFuture ...
[10:22:30.924] result() for MulticoreFuture ...
[10:22:30.925] result() for MulticoreFuture ... done
[10:22:30.925] result() for MulticoreFuture ... done
[10:22:30.925] result() for MulticoreFuture ...
[10:22:30.925] result() for MulticoreFuture ... done
[10:22:30.928] MulticoreFuture started
[10:22:30.929] - Launch lazy future ... done
[10:22:30.929] run() for ‘MulticoreFuture’ ... done
[10:22:30.929] plan(): Setting new future strategy stack:
[10:22:30.929] List of future strategies:
[10:22:30.929] 1. sequential:
[10:22:30.929]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:30.929]    - tweaked: FALSE
[10:22:30.929]    - call: NULL
[10:22:30.931] plan(): nbrOfWorkers() = 1
[10:22:30.940] run() for ‘Future’ ...
[10:22:30.940] - state: ‘created’
[10:22:30.940] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:30.948] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:30.948] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:30.949]   - Field: ‘label’
[10:22:30.949]   - Field: ‘local’
[10:22:30.950]   - Field: ‘owner’
[10:22:30.950]   - Field: ‘envir’
[10:22:30.950]   - Field: ‘workers’
[10:22:30.951]   - Field: ‘packages’
[10:22:30.951]   - Field: ‘gc’
[10:22:30.951]   - Field: ‘job’
[10:22:30.951]   - Field: ‘conditions’
[10:22:30.952]   - Field: ‘expr’
[10:22:30.952]   - Field: ‘uuid’
[10:22:30.952]   - Field: ‘seed’
[10:22:30.952]   - Field: ‘version’
[10:22:30.952]   - Field: ‘result’
[10:22:30.953]   - Field: ‘asynchronous’
[10:22:30.953]   - Field: ‘calls’
[10:22:30.953]   - Field: ‘globals’
[10:22:30.953]   - Field: ‘stdout’
[10:22:30.953]   - Field: ‘earlySignal’
[10:22:30.953]   - Field: ‘lazy’
[10:22:30.954]   - Field: ‘state’
[10:22:30.954] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:30.954] - Launch lazy future ...
[10:22:30.954] Packages needed by the future expression (n = 0): <none>
[10:22:30.955] Packages needed by future strategies (n = 0): <none>
[10:22:30.955] {
[10:22:30.955]     {
[10:22:30.955]         {
[10:22:30.955]             ...future.startTime <- base::Sys.time()
[10:22:30.955]             {
[10:22:30.955]                 {
[10:22:30.955]                   {
[10:22:30.955]                     {
[10:22:30.955]                       base::local({
[10:22:30.955]                         has_future <- base::requireNamespace("future", 
[10:22:30.955]                           quietly = TRUE)
[10:22:30.955]                         if (has_future) {
[10:22:30.955]                           ns <- base::getNamespace("future")
[10:22:30.955]                           version <- ns[[".package"]][["version"]]
[10:22:30.955]                           if (is.null(version)) 
[10:22:30.955]                             version <- utils::packageVersion("future")
[10:22:30.955]                         }
[10:22:30.955]                         else {
[10:22:30.955]                           version <- NULL
[10:22:30.955]                         }
[10:22:30.955]                         if (!has_future || version < "1.8.0") {
[10:22:30.955]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:30.955]                             "", base::R.version$version.string), 
[10:22:30.955]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:30.955]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:30.955]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:30.955]                               "release", "version")], collapse = " "), 
[10:22:30.955]                             hostname = base::Sys.info()[["nodename"]])
[10:22:30.955]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:30.955]                             info)
[10:22:30.955]                           info <- base::paste(info, collapse = "; ")
[10:22:30.955]                           if (!has_future) {
[10:22:30.955]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:30.955]                               info)
[10:22:30.955]                           }
[10:22:30.955]                           else {
[10:22:30.955]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:30.955]                               info, version)
[10:22:30.955]                           }
[10:22:30.955]                           base::stop(msg)
[10:22:30.955]                         }
[10:22:30.955]                       })
[10:22:30.955]                     }
[10:22:30.955]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:30.955]                     base::options(mc.cores = 1L)
[10:22:30.955]                   }
[10:22:30.955]                   ...future.strategy.old <- future::plan("list")
[10:22:30.955]                   options(future.plan = NULL)
[10:22:30.955]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:30.955]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:30.955]                 }
[10:22:30.955]                 ...future.workdir <- getwd()
[10:22:30.955]             }
[10:22:30.955]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:30.955]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:30.955]         }
[10:22:30.955]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:30.955]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:30.955]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:30.955]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:30.955]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:30.955]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:30.955]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:30.955]             base::names(...future.oldOptions))
[10:22:30.955]     }
[10:22:30.955]     if (FALSE) {
[10:22:30.955]     }
[10:22:30.955]     else {
[10:22:30.955]         if (TRUE) {
[10:22:30.955]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:30.955]                 open = "w")
[10:22:30.955]         }
[10:22:30.955]         else {
[10:22:30.955]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:30.955]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:30.955]         }
[10:22:30.955]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:30.955]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:30.955]             base::sink(type = "output", split = FALSE)
[10:22:30.955]             base::close(...future.stdout)
[10:22:30.955]         }, add = TRUE)
[10:22:30.955]     }
[10:22:30.955]     ...future.frame <- base::sys.nframe()
[10:22:30.955]     ...future.conditions <- base::list()
[10:22:30.955]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:30.955]     if (FALSE) {
[10:22:30.955]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:30.955]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:30.955]     }
[10:22:30.955]     ...future.result <- base::tryCatch({
[10:22:30.955]         base::withCallingHandlers({
[10:22:30.955]             ...future.value <- base::withVisible(base::local({
[10:22:30.955]                 withCallingHandlers({
[10:22:30.955]                   {
[10:22:30.955]                     Sys.sleep(0.1)
[10:22:30.955]                     kk
[10:22:30.955]                   }
[10:22:30.955]                 }, immediateCondition = function(cond) {
[10:22:30.955]                   save_rds <- function (object, pathname, ...) 
[10:22:30.955]                   {
[10:22:30.955]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:30.955]                     if (file_test("-f", pathname_tmp)) {
[10:22:30.955]                       fi_tmp <- file.info(pathname_tmp)
[10:22:30.955]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:30.955]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:30.955]                         fi_tmp[["mtime"]])
[10:22:30.955]                     }
[10:22:30.955]                     tryCatch({
[10:22:30.955]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:30.955]                     }, error = function(ex) {
[10:22:30.955]                       msg <- conditionMessage(ex)
[10:22:30.955]                       fi_tmp <- file.info(pathname_tmp)
[10:22:30.955]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:30.955]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:30.955]                         fi_tmp[["mtime"]], msg)
[10:22:30.955]                       ex$message <- msg
[10:22:30.955]                       stop(ex)
[10:22:30.955]                     })
[10:22:30.955]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:30.955]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:30.955]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:30.955]                       fi_tmp <- file.info(pathname_tmp)
[10:22:30.955]                       fi <- file.info(pathname)
[10:22:30.955]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:30.955]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:30.955]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:30.955]                         fi[["size"]], fi[["mtime"]])
[10:22:30.955]                       stop(msg)
[10:22:30.955]                     }
[10:22:30.955]                     invisible(pathname)
[10:22:30.955]                   }
[10:22:30.955]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:30.955]                     rootPath = tempdir()) 
[10:22:30.955]                   {
[10:22:30.955]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:30.955]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:30.955]                       tmpdir = path, fileext = ".rds")
[10:22:30.955]                     save_rds(obj, file)
[10:22:30.955]                   }
[10:22:30.955]                   saveImmediateCondition(cond, path = "/tmp/RtmpzsJv4f/.future/immediateConditions")
[10:22:30.955]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:30.955]                   {
[10:22:30.955]                     inherits <- base::inherits
[10:22:30.955]                     invokeRestart <- base::invokeRestart
[10:22:30.955]                     is.null <- base::is.null
[10:22:30.955]                     muffled <- FALSE
[10:22:30.955]                     if (inherits(cond, "message")) {
[10:22:30.955]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:30.955]                       if (muffled) 
[10:22:30.955]                         invokeRestart("muffleMessage")
[10:22:30.955]                     }
[10:22:30.955]                     else if (inherits(cond, "warning")) {
[10:22:30.955]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:30.955]                       if (muffled) 
[10:22:30.955]                         invokeRestart("muffleWarning")
[10:22:30.955]                     }
[10:22:30.955]                     else if (inherits(cond, "condition")) {
[10:22:30.955]                       if (!is.null(pattern)) {
[10:22:30.955]                         computeRestarts <- base::computeRestarts
[10:22:30.955]                         grepl <- base::grepl
[10:22:30.955]                         restarts <- computeRestarts(cond)
[10:22:30.955]                         for (restart in restarts) {
[10:22:30.955]                           name <- restart$name
[10:22:30.955]                           if (is.null(name)) 
[10:22:30.955]                             next
[10:22:30.955]                           if (!grepl(pattern, name)) 
[10:22:30.955]                             next
[10:22:30.955]                           invokeRestart(restart)
[10:22:30.955]                           muffled <- TRUE
[10:22:30.955]                           break
[10:22:30.955]                         }
[10:22:30.955]                       }
[10:22:30.955]                     }
[10:22:30.955]                     invisible(muffled)
[10:22:30.955]                   }
[10:22:30.955]                   muffleCondition(cond)
[10:22:30.955]                 })
[10:22:30.955]             }))
[10:22:30.955]             future::FutureResult(value = ...future.value$value, 
[10:22:30.955]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:30.955]                   ...future.rng), globalenv = if (FALSE) 
[10:22:30.955]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:30.955]                     ...future.globalenv.names))
[10:22:30.955]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:30.955]         }, condition = base::local({
[10:22:30.955]             c <- base::c
[10:22:30.955]             inherits <- base::inherits
[10:22:30.955]             invokeRestart <- base::invokeRestart
[10:22:30.955]             length <- base::length
[10:22:30.955]             list <- base::list
[10:22:30.955]             seq.int <- base::seq.int
[10:22:30.955]             signalCondition <- base::signalCondition
[10:22:30.955]             sys.calls <- base::sys.calls
[10:22:30.955]             `[[` <- base::`[[`
[10:22:30.955]             `+` <- base::`+`
[10:22:30.955]             `<<-` <- base::`<<-`
[10:22:30.955]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:30.955]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:30.955]                   3L)]
[10:22:30.955]             }
[10:22:30.955]             function(cond) {
[10:22:30.955]                 is_error <- inherits(cond, "error")
[10:22:30.955]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:30.955]                   NULL)
[10:22:30.955]                 if (is_error) {
[10:22:30.955]                   sessionInformation <- function() {
[10:22:30.955]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:30.955]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:30.955]                       search = base::search(), system = base::Sys.info())
[10:22:30.955]                   }
[10:22:30.955]                   ...future.conditions[[length(...future.conditions) + 
[10:22:30.955]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:30.955]                     cond$call), session = sessionInformation(), 
[10:22:30.955]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:30.955]                   signalCondition(cond)
[10:22:30.955]                 }
[10:22:30.955]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:30.955]                 "immediateCondition"))) {
[10:22:30.955]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:30.955]                   ...future.conditions[[length(...future.conditions) + 
[10:22:30.955]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:30.955]                   if (TRUE && !signal) {
[10:22:30.955]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:30.955]                     {
[10:22:30.955]                       inherits <- base::inherits
[10:22:30.955]                       invokeRestart <- base::invokeRestart
[10:22:30.955]                       is.null <- base::is.null
[10:22:30.955]                       muffled <- FALSE
[10:22:30.955]                       if (inherits(cond, "message")) {
[10:22:30.955]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:30.955]                         if (muffled) 
[10:22:30.955]                           invokeRestart("muffleMessage")
[10:22:30.955]                       }
[10:22:30.955]                       else if (inherits(cond, "warning")) {
[10:22:30.955]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:30.955]                         if (muffled) 
[10:22:30.955]                           invokeRestart("muffleWarning")
[10:22:30.955]                       }
[10:22:30.955]                       else if (inherits(cond, "condition")) {
[10:22:30.955]                         if (!is.null(pattern)) {
[10:22:30.955]                           computeRestarts <- base::computeRestarts
[10:22:30.955]                           grepl <- base::grepl
[10:22:30.955]                           restarts <- computeRestarts(cond)
[10:22:30.955]                           for (restart in restarts) {
[10:22:30.955]                             name <- restart$name
[10:22:30.955]                             if (is.null(name)) 
[10:22:30.955]                               next
[10:22:30.955]                             if (!grepl(pattern, name)) 
[10:22:30.955]                               next
[10:22:30.955]                             invokeRestart(restart)
[10:22:30.955]                             muffled <- TRUE
[10:22:30.955]                             break
[10:22:30.955]                           }
[10:22:30.955]                         }
[10:22:30.955]                       }
[10:22:30.955]                       invisible(muffled)
[10:22:30.955]                     }
[10:22:30.955]                     muffleCondition(cond, pattern = "^muffle")
[10:22:30.955]                   }
[10:22:30.955]                 }
[10:22:30.955]                 else {
[10:22:30.955]                   if (TRUE) {
[10:22:30.955]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:30.955]                     {
[10:22:30.955]                       inherits <- base::inherits
[10:22:30.955]                       invokeRestart <- base::invokeRestart
[10:22:30.955]                       is.null <- base::is.null
[10:22:30.955]                       muffled <- FALSE
[10:22:30.955]                       if (inherits(cond, "message")) {
[10:22:30.955]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:30.955]                         if (muffled) 
[10:22:30.955]                           invokeRestart("muffleMessage")
[10:22:30.955]                       }
[10:22:30.955]                       else if (inherits(cond, "warning")) {
[10:22:30.955]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:30.955]                         if (muffled) 
[10:22:30.955]                           invokeRestart("muffleWarning")
[10:22:30.955]                       }
[10:22:30.955]                       else if (inherits(cond, "condition")) {
[10:22:30.955]                         if (!is.null(pattern)) {
[10:22:30.955]                           computeRestarts <- base::computeRestarts
[10:22:30.955]                           grepl <- base::grepl
[10:22:30.955]                           restarts <- computeRestarts(cond)
[10:22:30.955]                           for (restart in restarts) {
[10:22:30.955]                             name <- restart$name
[10:22:30.955]                             if (is.null(name)) 
[10:22:30.955]                               next
[10:22:30.955]                             if (!grepl(pattern, name)) 
[10:22:30.955]                               next
[10:22:30.955]                             invokeRestart(restart)
[10:22:30.955]                             muffled <- TRUE
[10:22:30.955]                             break
[10:22:30.955]                           }
[10:22:30.955]                         }
[10:22:30.955]                       }
[10:22:30.955]                       invisible(muffled)
[10:22:30.955]                     }
[10:22:30.955]                     muffleCondition(cond, pattern = "^muffle")
[10:22:30.955]                   }
[10:22:30.955]                 }
[10:22:30.955]             }
[10:22:30.955]         }))
[10:22:30.955]     }, error = function(ex) {
[10:22:30.955]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:30.955]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:30.955]                 ...future.rng), started = ...future.startTime, 
[10:22:30.955]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:30.955]             version = "1.8"), class = "FutureResult")
[10:22:30.955]     }, finally = {
[10:22:30.955]         if (!identical(...future.workdir, getwd())) 
[10:22:30.955]             setwd(...future.workdir)
[10:22:30.955]         {
[10:22:30.955]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:30.955]                 ...future.oldOptions$nwarnings <- NULL
[10:22:30.955]             }
[10:22:30.955]             base::options(...future.oldOptions)
[10:22:30.955]             if (.Platform$OS.type == "windows") {
[10:22:30.955]                 old_names <- names(...future.oldEnvVars)
[10:22:30.955]                 envs <- base::Sys.getenv()
[10:22:30.955]                 names <- names(envs)
[10:22:30.955]                 common <- intersect(names, old_names)
[10:22:30.955]                 added <- setdiff(names, old_names)
[10:22:30.955]                 removed <- setdiff(old_names, names)
[10:22:30.955]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:30.955]                   envs[common]]
[10:22:30.955]                 NAMES <- toupper(changed)
[10:22:30.955]                 args <- list()
[10:22:30.955]                 for (kk in seq_along(NAMES)) {
[10:22:30.955]                   name <- changed[[kk]]
[10:22:30.955]                   NAME <- NAMES[[kk]]
[10:22:30.955]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:30.955]                     next
[10:22:30.955]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:30.955]                 }
[10:22:30.955]                 NAMES <- toupper(added)
[10:22:30.955]                 for (kk in seq_along(NAMES)) {
[10:22:30.955]                   name <- added[[kk]]
[10:22:30.955]                   NAME <- NAMES[[kk]]
[10:22:30.955]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:30.955]                     next
[10:22:30.955]                   args[[name]] <- ""
[10:22:30.955]                 }
[10:22:30.955]                 NAMES <- toupper(removed)
[10:22:30.955]                 for (kk in seq_along(NAMES)) {
[10:22:30.955]                   name <- removed[[kk]]
[10:22:30.955]                   NAME <- NAMES[[kk]]
[10:22:30.955]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:30.955]                     next
[10:22:30.955]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:30.955]                 }
[10:22:30.955]                 if (length(args) > 0) 
[10:22:30.955]                   base::do.call(base::Sys.setenv, args = args)
[10:22:30.955]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:30.955]             }
[10:22:30.955]             else {
[10:22:30.955]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:30.955]             }
[10:22:30.955]             {
[10:22:30.955]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:30.955]                   0L) {
[10:22:30.955]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:30.955]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:30.955]                   base::options(opts)
[10:22:30.955]                 }
[10:22:30.955]                 {
[10:22:30.955]                   {
[10:22:30.955]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:30.955]                     NULL
[10:22:30.955]                   }
[10:22:30.955]                   options(future.plan = NULL)
[10:22:30.955]                   if (is.na(NA_character_)) 
[10:22:30.955]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:30.955]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:30.955]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:30.955]                     .init = FALSE)
[10:22:30.955]                 }
[10:22:30.955]             }
[10:22:30.955]         }
[10:22:30.955]     })
[10:22:30.955]     if (TRUE) {
[10:22:30.955]         base::sink(type = "output", split = FALSE)
[10:22:30.955]         if (TRUE) {
[10:22:30.955]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:30.955]         }
[10:22:30.955]         else {
[10:22:30.955]             ...future.result["stdout"] <- base::list(NULL)
[10:22:30.955]         }
[10:22:30.955]         base::close(...future.stdout)
[10:22:30.955]         ...future.stdout <- NULL
[10:22:30.955]     }
[10:22:30.955]     ...future.result$conditions <- ...future.conditions
[10:22:30.955]     ...future.result$finished <- base::Sys.time()
[10:22:30.955]     ...future.result
[10:22:30.955] }
[10:22:30.958] assign_globals() ...
[10:22:30.958] List of 1
[10:22:30.958]  $ kk: int 2
[10:22:30.958]  - attr(*, "where")=List of 1
[10:22:30.958]   ..$ kk:<environment: R_EmptyEnv> 
[10:22:30.958]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:30.958]  - attr(*, "resolved")= logi FALSE
[10:22:30.958]  - attr(*, "total_size")= num 35
[10:22:30.958]  - attr(*, "already-done")= logi TRUE
[10:22:30.962] - copied ‘kk’ to environment
[10:22:30.962] assign_globals() ... done
[10:22:30.962] requestCore(): workers = 2
[10:22:30.963] Poll #1 (0): usedCores() = 2, workers = 2
[10:22:30.973] result() for MulticoreFuture ...
[10:22:30.974] result() for MulticoreFuture ...
[10:22:30.974] result() for MulticoreFuture ... done
[10:22:30.975] result() for MulticoreFuture ... done
[10:22:30.975] result() for MulticoreFuture ...
[10:22:30.975] result() for MulticoreFuture ... done
[10:22:30.978] MulticoreFuture started
[10:22:30.978] - Launch lazy future ... done
[10:22:30.978] run() for ‘MulticoreFuture’ ... done
[10:22:30.979] plan(): Setting new future strategy stack:
[10:22:30.979] List of future strategies:
[10:22:30.979] 1. sequential:
[10:22:30.979]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:30.979]    - tweaked: FALSE
[10:22:30.979]    - call: NULL
[10:22:30.980] plan(): nbrOfWorkers() = 1
[10:22:30.989] run() for ‘Future’ ...
[10:22:30.989] - state: ‘created’
[10:22:30.990] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:30.993] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:30.993] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:30.994]   - Field: ‘label’
[10:22:30.994]   - Field: ‘local’
[10:22:30.994]   - Field: ‘owner’
[10:22:30.994]   - Field: ‘envir’
[10:22:30.994]   - Field: ‘workers’
[10:22:30.994]   - Field: ‘packages’
[10:22:30.995]   - Field: ‘gc’
[10:22:30.995]   - Field: ‘job’
[10:22:30.995]   - Field: ‘conditions’
[10:22:30.995]   - Field: ‘expr’
[10:22:30.995]   - Field: ‘uuid’
[10:22:30.995]   - Field: ‘seed’
[10:22:30.995]   - Field: ‘version’
[10:22:30.996]   - Field: ‘result’
[10:22:30.996]   - Field: ‘asynchronous’
[10:22:30.996]   - Field: ‘calls’
[10:22:30.996]   - Field: ‘globals’
[10:22:30.996]   - Field: ‘stdout’
[10:22:30.996]   - Field: ‘earlySignal’
[10:22:30.997]   - Field: ‘lazy’
[10:22:30.997]   - Field: ‘state’
[10:22:30.997] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:30.997] - Launch lazy future ...
[10:22:30.998] Packages needed by the future expression (n = 0): <none>
[10:22:30.998] Packages needed by future strategies (n = 0): <none>
[10:22:30.998] {
[10:22:30.998]     {
[10:22:30.998]         {
[10:22:30.998]             ...future.startTime <- base::Sys.time()
[10:22:30.998]             {
[10:22:30.998]                 {
[10:22:30.998]                   {
[10:22:30.998]                     {
[10:22:30.998]                       base::local({
[10:22:30.998]                         has_future <- base::requireNamespace("future", 
[10:22:30.998]                           quietly = TRUE)
[10:22:30.998]                         if (has_future) {
[10:22:30.998]                           ns <- base::getNamespace("future")
[10:22:30.998]                           version <- ns[[".package"]][["version"]]
[10:22:30.998]                           if (is.null(version)) 
[10:22:30.998]                             version <- utils::packageVersion("future")
[10:22:30.998]                         }
[10:22:30.998]                         else {
[10:22:30.998]                           version <- NULL
[10:22:30.998]                         }
[10:22:30.998]                         if (!has_future || version < "1.8.0") {
[10:22:30.998]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:30.998]                             "", base::R.version$version.string), 
[10:22:30.998]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:30.998]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:30.998]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:30.998]                               "release", "version")], collapse = " "), 
[10:22:30.998]                             hostname = base::Sys.info()[["nodename"]])
[10:22:30.998]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:30.998]                             info)
[10:22:30.998]                           info <- base::paste(info, collapse = "; ")
[10:22:30.998]                           if (!has_future) {
[10:22:30.998]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:30.998]                               info)
[10:22:30.998]                           }
[10:22:30.998]                           else {
[10:22:30.998]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:30.998]                               info, version)
[10:22:30.998]                           }
[10:22:30.998]                           base::stop(msg)
[10:22:30.998]                         }
[10:22:30.998]                       })
[10:22:30.998]                     }
[10:22:30.998]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:30.998]                     base::options(mc.cores = 1L)
[10:22:30.998]                   }
[10:22:30.998]                   ...future.strategy.old <- future::plan("list")
[10:22:30.998]                   options(future.plan = NULL)
[10:22:30.998]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:30.998]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:30.998]                 }
[10:22:30.998]                 ...future.workdir <- getwd()
[10:22:30.998]             }
[10:22:30.998]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:30.998]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:30.998]         }
[10:22:30.998]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:30.998]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:30.998]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:30.998]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:30.998]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:30.998]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:30.998]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:30.998]             base::names(...future.oldOptions))
[10:22:30.998]     }
[10:22:30.998]     if (FALSE) {
[10:22:30.998]     }
[10:22:30.998]     else {
[10:22:30.998]         if (TRUE) {
[10:22:30.998]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:30.998]                 open = "w")
[10:22:30.998]         }
[10:22:30.998]         else {
[10:22:30.998]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:30.998]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:30.998]         }
[10:22:30.998]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:30.998]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:30.998]             base::sink(type = "output", split = FALSE)
[10:22:30.998]             base::close(...future.stdout)
[10:22:30.998]         }, add = TRUE)
[10:22:30.998]     }
[10:22:30.998]     ...future.frame <- base::sys.nframe()
[10:22:30.998]     ...future.conditions <- base::list()
[10:22:30.998]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:30.998]     if (FALSE) {
[10:22:30.998]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:30.998]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:30.998]     }
[10:22:30.998]     ...future.result <- base::tryCatch({
[10:22:30.998]         base::withCallingHandlers({
[10:22:30.998]             ...future.value <- base::withVisible(base::local({
[10:22:30.998]                 withCallingHandlers({
[10:22:30.998]                   {
[10:22:30.998]                     Sys.sleep(0.1)
[10:22:30.998]                     kk
[10:22:30.998]                   }
[10:22:30.998]                 }, immediateCondition = function(cond) {
[10:22:30.998]                   save_rds <- function (object, pathname, ...) 
[10:22:30.998]                   {
[10:22:30.998]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:30.998]                     if (file_test("-f", pathname_tmp)) {
[10:22:30.998]                       fi_tmp <- file.info(pathname_tmp)
[10:22:30.998]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:30.998]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:30.998]                         fi_tmp[["mtime"]])
[10:22:30.998]                     }
[10:22:30.998]                     tryCatch({
[10:22:30.998]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:30.998]                     }, error = function(ex) {
[10:22:30.998]                       msg <- conditionMessage(ex)
[10:22:30.998]                       fi_tmp <- file.info(pathname_tmp)
[10:22:30.998]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:30.998]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:30.998]                         fi_tmp[["mtime"]], msg)
[10:22:30.998]                       ex$message <- msg
[10:22:30.998]                       stop(ex)
[10:22:30.998]                     })
[10:22:30.998]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:30.998]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:30.998]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:30.998]                       fi_tmp <- file.info(pathname_tmp)
[10:22:30.998]                       fi <- file.info(pathname)
[10:22:30.998]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:30.998]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:30.998]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:30.998]                         fi[["size"]], fi[["mtime"]])
[10:22:30.998]                       stop(msg)
[10:22:30.998]                     }
[10:22:30.998]                     invisible(pathname)
[10:22:30.998]                   }
[10:22:30.998]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:30.998]                     rootPath = tempdir()) 
[10:22:30.998]                   {
[10:22:30.998]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:30.998]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:30.998]                       tmpdir = path, fileext = ".rds")
[10:22:30.998]                     save_rds(obj, file)
[10:22:30.998]                   }
[10:22:30.998]                   saveImmediateCondition(cond, path = "/tmp/RtmpzsJv4f/.future/immediateConditions")
[10:22:30.998]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:30.998]                   {
[10:22:30.998]                     inherits <- base::inherits
[10:22:30.998]                     invokeRestart <- base::invokeRestart
[10:22:30.998]                     is.null <- base::is.null
[10:22:30.998]                     muffled <- FALSE
[10:22:30.998]                     if (inherits(cond, "message")) {
[10:22:30.998]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:30.998]                       if (muffled) 
[10:22:30.998]                         invokeRestart("muffleMessage")
[10:22:30.998]                     }
[10:22:30.998]                     else if (inherits(cond, "warning")) {
[10:22:30.998]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:30.998]                       if (muffled) 
[10:22:30.998]                         invokeRestart("muffleWarning")
[10:22:30.998]                     }
[10:22:30.998]                     else if (inherits(cond, "condition")) {
[10:22:30.998]                       if (!is.null(pattern)) {
[10:22:30.998]                         computeRestarts <- base::computeRestarts
[10:22:30.998]                         grepl <- base::grepl
[10:22:30.998]                         restarts <- computeRestarts(cond)
[10:22:30.998]                         for (restart in restarts) {
[10:22:30.998]                           name <- restart$name
[10:22:30.998]                           if (is.null(name)) 
[10:22:30.998]                             next
[10:22:30.998]                           if (!grepl(pattern, name)) 
[10:22:30.998]                             next
[10:22:30.998]                           invokeRestart(restart)
[10:22:30.998]                           muffled <- TRUE
[10:22:30.998]                           break
[10:22:30.998]                         }
[10:22:30.998]                       }
[10:22:30.998]                     }
[10:22:30.998]                     invisible(muffled)
[10:22:30.998]                   }
[10:22:30.998]                   muffleCondition(cond)
[10:22:30.998]                 })
[10:22:30.998]             }))
[10:22:30.998]             future::FutureResult(value = ...future.value$value, 
[10:22:30.998]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:30.998]                   ...future.rng), globalenv = if (FALSE) 
[10:22:30.998]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:30.998]                     ...future.globalenv.names))
[10:22:30.998]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:30.998]         }, condition = base::local({
[10:22:30.998]             c <- base::c
[10:22:30.998]             inherits <- base::inherits
[10:22:30.998]             invokeRestart <- base::invokeRestart
[10:22:30.998]             length <- base::length
[10:22:30.998]             list <- base::list
[10:22:30.998]             seq.int <- base::seq.int
[10:22:30.998]             signalCondition <- base::signalCondition
[10:22:30.998]             sys.calls <- base::sys.calls
[10:22:30.998]             `[[` <- base::`[[`
[10:22:30.998]             `+` <- base::`+`
[10:22:30.998]             `<<-` <- base::`<<-`
[10:22:30.998]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:30.998]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:30.998]                   3L)]
[10:22:30.998]             }
[10:22:30.998]             function(cond) {
[10:22:30.998]                 is_error <- inherits(cond, "error")
[10:22:30.998]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:30.998]                   NULL)
[10:22:30.998]                 if (is_error) {
[10:22:30.998]                   sessionInformation <- function() {
[10:22:30.998]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:30.998]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:30.998]                       search = base::search(), system = base::Sys.info())
[10:22:30.998]                   }
[10:22:30.998]                   ...future.conditions[[length(...future.conditions) + 
[10:22:30.998]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:30.998]                     cond$call), session = sessionInformation(), 
[10:22:30.998]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:30.998]                   signalCondition(cond)
[10:22:30.998]                 }
[10:22:30.998]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:30.998]                 "immediateCondition"))) {
[10:22:30.998]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:30.998]                   ...future.conditions[[length(...future.conditions) + 
[10:22:30.998]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:30.998]                   if (TRUE && !signal) {
[10:22:30.998]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:30.998]                     {
[10:22:30.998]                       inherits <- base::inherits
[10:22:30.998]                       invokeRestart <- base::invokeRestart
[10:22:30.998]                       is.null <- base::is.null
[10:22:30.998]                       muffled <- FALSE
[10:22:30.998]                       if (inherits(cond, "message")) {
[10:22:30.998]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:30.998]                         if (muffled) 
[10:22:30.998]                           invokeRestart("muffleMessage")
[10:22:30.998]                       }
[10:22:30.998]                       else if (inherits(cond, "warning")) {
[10:22:30.998]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:30.998]                         if (muffled) 
[10:22:30.998]                           invokeRestart("muffleWarning")
[10:22:30.998]                       }
[10:22:30.998]                       else if (inherits(cond, "condition")) {
[10:22:30.998]                         if (!is.null(pattern)) {
[10:22:30.998]                           computeRestarts <- base::computeRestarts
[10:22:30.998]                           grepl <- base::grepl
[10:22:30.998]                           restarts <- computeRestarts(cond)
[10:22:30.998]                           for (restart in restarts) {
[10:22:30.998]                             name <- restart$name
[10:22:30.998]                             if (is.null(name)) 
[10:22:30.998]                               next
[10:22:30.998]                             if (!grepl(pattern, name)) 
[10:22:30.998]                               next
[10:22:30.998]                             invokeRestart(restart)
[10:22:30.998]                             muffled <- TRUE
[10:22:30.998]                             break
[10:22:30.998]                           }
[10:22:30.998]                         }
[10:22:30.998]                       }
[10:22:30.998]                       invisible(muffled)
[10:22:30.998]                     }
[10:22:30.998]                     muffleCondition(cond, pattern = "^muffle")
[10:22:30.998]                   }
[10:22:30.998]                 }
[10:22:30.998]                 else {
[10:22:30.998]                   if (TRUE) {
[10:22:30.998]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:30.998]                     {
[10:22:30.998]                       inherits <- base::inherits
[10:22:30.998]                       invokeRestart <- base::invokeRestart
[10:22:30.998]                       is.null <- base::is.null
[10:22:30.998]                       muffled <- FALSE
[10:22:30.998]                       if (inherits(cond, "message")) {
[10:22:30.998]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:30.998]                         if (muffled) 
[10:22:30.998]                           invokeRestart("muffleMessage")
[10:22:30.998]                       }
[10:22:30.998]                       else if (inherits(cond, "warning")) {
[10:22:30.998]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:30.998]                         if (muffled) 
[10:22:30.998]                           invokeRestart("muffleWarning")
[10:22:30.998]                       }
[10:22:30.998]                       else if (inherits(cond, "condition")) {
[10:22:30.998]                         if (!is.null(pattern)) {
[10:22:30.998]                           computeRestarts <- base::computeRestarts
[10:22:30.998]                           grepl <- base::grepl
[10:22:30.998]                           restarts <- computeRestarts(cond)
[10:22:30.998]                           for (restart in restarts) {
[10:22:30.998]                             name <- restart$name
[10:22:30.998]                             if (is.null(name)) 
[10:22:30.998]                               next
[10:22:30.998]                             if (!grepl(pattern, name)) 
[10:22:30.998]                               next
[10:22:30.998]                             invokeRestart(restart)
[10:22:30.998]                             muffled <- TRUE
[10:22:30.998]                             break
[10:22:30.998]                           }
[10:22:30.998]                         }
[10:22:30.998]                       }
[10:22:30.998]                       invisible(muffled)
[10:22:30.998]                     }
[10:22:30.998]                     muffleCondition(cond, pattern = "^muffle")
[10:22:30.998]                   }
[10:22:30.998]                 }
[10:22:30.998]             }
[10:22:30.998]         }))
[10:22:30.998]     }, error = function(ex) {
[10:22:30.998]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:30.998]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:30.998]                 ...future.rng), started = ...future.startTime, 
[10:22:30.998]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:30.998]             version = "1.8"), class = "FutureResult")
[10:22:30.998]     }, finally = {
[10:22:30.998]         if (!identical(...future.workdir, getwd())) 
[10:22:30.998]             setwd(...future.workdir)
[10:22:30.998]         {
[10:22:30.998]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:30.998]                 ...future.oldOptions$nwarnings <- NULL
[10:22:30.998]             }
[10:22:30.998]             base::options(...future.oldOptions)
[10:22:30.998]             if (.Platform$OS.type == "windows") {
[10:22:30.998]                 old_names <- names(...future.oldEnvVars)
[10:22:30.998]                 envs <- base::Sys.getenv()
[10:22:30.998]                 names <- names(envs)
[10:22:30.998]                 common <- intersect(names, old_names)
[10:22:30.998]                 added <- setdiff(names, old_names)
[10:22:30.998]                 removed <- setdiff(old_names, names)
[10:22:30.998]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:30.998]                   envs[common]]
[10:22:30.998]                 NAMES <- toupper(changed)
[10:22:30.998]                 args <- list()
[10:22:30.998]                 for (kk in seq_along(NAMES)) {
[10:22:30.998]                   name <- changed[[kk]]
[10:22:30.998]                   NAME <- NAMES[[kk]]
[10:22:30.998]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:30.998]                     next
[10:22:30.998]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:30.998]                 }
[10:22:30.998]                 NAMES <- toupper(added)
[10:22:30.998]                 for (kk in seq_along(NAMES)) {
[10:22:30.998]                   name <- added[[kk]]
[10:22:30.998]                   NAME <- NAMES[[kk]]
[10:22:30.998]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:30.998]                     next
[10:22:30.998]                   args[[name]] <- ""
[10:22:30.998]                 }
[10:22:30.998]                 NAMES <- toupper(removed)
[10:22:30.998]                 for (kk in seq_along(NAMES)) {
[10:22:30.998]                   name <- removed[[kk]]
[10:22:30.998]                   NAME <- NAMES[[kk]]
[10:22:30.998]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:30.998]                     next
[10:22:30.998]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:30.998]                 }
[10:22:30.998]                 if (length(args) > 0) 
[10:22:30.998]                   base::do.call(base::Sys.setenv, args = args)
[10:22:30.998]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:30.998]             }
[10:22:30.998]             else {
[10:22:30.998]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:30.998]             }
[10:22:30.998]             {
[10:22:30.998]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:30.998]                   0L) {
[10:22:30.998]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:30.998]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:30.998]                   base::options(opts)
[10:22:30.998]                 }
[10:22:30.998]                 {
[10:22:30.998]                   {
[10:22:30.998]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:30.998]                     NULL
[10:22:30.998]                   }
[10:22:30.998]                   options(future.plan = NULL)
[10:22:30.998]                   if (is.na(NA_character_)) 
[10:22:30.998]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:30.998]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:30.998]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:30.998]                     .init = FALSE)
[10:22:30.998]                 }
[10:22:30.998]             }
[10:22:30.998]         }
[10:22:30.998]     })
[10:22:30.998]     if (TRUE) {
[10:22:30.998]         base::sink(type = "output", split = FALSE)
[10:22:30.998]         if (TRUE) {
[10:22:30.998]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:30.998]         }
[10:22:30.998]         else {
[10:22:30.998]             ...future.result["stdout"] <- base::list(NULL)
[10:22:30.998]         }
[10:22:30.998]         base::close(...future.stdout)
[10:22:30.998]         ...future.stdout <- NULL
[10:22:30.998]     }
[10:22:30.998]     ...future.result$conditions <- ...future.conditions
[10:22:30.998]     ...future.result$finished <- base::Sys.time()
[10:22:30.998]     ...future.result
[10:22:30.998] }
[10:22:31.002] assign_globals() ...
[10:22:31.002] List of 1
[10:22:31.002]  $ kk: int 3
[10:22:31.002]  - attr(*, "where")=List of 1
[10:22:31.002]   ..$ kk:<environment: R_EmptyEnv> 
[10:22:31.002]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:31.002]  - attr(*, "resolved")= logi FALSE
[10:22:31.002]  - attr(*, "total_size")= num 35
[10:22:31.002]  - attr(*, "already-done")= logi TRUE
[10:22:31.006] - copied ‘kk’ to environment
[10:22:31.006] assign_globals() ... done
[10:22:31.006] requestCore(): workers = 2
[10:22:31.007] Poll #1 (0): usedCores() = 2, workers = 2
[10:22:31.033] plan(): Setting new future strategy stack:
[10:22:31.036] List of future strategies:
[10:22:31.036] 1. multicore:
[10:22:31.036]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:31.036]    - tweaked: FALSE
[10:22:31.036]    - call: plan(strategy)
[10:22:31.038] Poll #2 (0.03 secs): usedCores() = 2, workers = 2
[10:22:31.040] plan(): nbrOfWorkers() = 2
[10:22:31.049] result() for MulticoreFuture ...
[10:22:31.050] result() for MulticoreFuture ...
[10:22:31.050] result() for MulticoreFuture ... done
[10:22:31.050] result() for MulticoreFuture ... done
[10:22:31.050] result() for MulticoreFuture ...
[10:22:31.050] result() for MulticoreFuture ... done
[10:22:31.053] MulticoreFuture started
[10:22:31.053] - Launch lazy future ... done
[10:22:31.053] run() for ‘MulticoreFuture’ ... done
[10:22:31.054] plan(): Setting new future strategy stack:
[10:22:31.054] List of future strategies:
[10:22:31.054] 1. sequential:
[10:22:31.054]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:31.054]    - tweaked: FALSE
[10:22:31.054]    - call: NULL
[10:22:31.055] plan(): nbrOfWorkers() = 1
[10:22:31.074] Future #1
[10:22:31.075]  length: 2 (resolved future 1)
[10:22:31.083] plan(): Setting new future strategy stack:
[10:22:31.083] List of future strategies:
[10:22:31.083] 1. multicore:
[10:22:31.083]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:31.083]    - tweaked: FALSE
[10:22:31.083]    - call: plan(strategy)
[10:22:31.085] plan(): nbrOfWorkers() = 2
[10:22:31.106] Future #2
[10:22:31.106]  length: 1 (resolved future 2)
[10:22:31.158] plan(): Setting new future strategy stack:
[10:22:31.158] List of future strategies:
[10:22:31.158] 1. multicore:
[10:22:31.158]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:31.158]    - tweaked: FALSE
[10:22:31.158]    - call: plan(strategy)
[10:22:31.161] plan(): nbrOfWorkers() = 2
[10:22:31.168] Future #3
[10:22:31.168]  length: 0 (resolved future 3)
[10:22:31.168] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[10:22:31.169] resolve() on environment ...
[10:22:31.169]  recursive: 0
[10:22:31.170]  elements: [2] ‘a’, ‘b’
[10:22:31.170]  length: 1 (resolved future 1)
[10:22:31.171]  length: 0 (resolved future 2)
[10:22:31.171] resolve() on environment ... DONE
[10:22:31.171] getGlobalsAndPackages() ...
[10:22:31.172] Searching for globals...
[10:22:31.172] 
[10:22:31.172] Searching for globals ... DONE
[10:22:31.173] - globals: [0] <none>
[10:22:31.173] getGlobalsAndPackages() ... DONE
[10:22:31.173] run() for ‘Future’ ...
[10:22:31.173] - state: ‘created’
[10:22:31.174] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:31.181] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:31.182] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:31.182]   - Field: ‘label’
[10:22:31.182]   - Field: ‘local’
[10:22:31.183]   - Field: ‘owner’
[10:22:31.183]   - Field: ‘envir’
[10:22:31.183]   - Field: ‘workers’
[10:22:31.183]   - Field: ‘packages’
[10:22:31.183]   - Field: ‘gc’
[10:22:31.184]   - Field: ‘job’
[10:22:31.184]   - Field: ‘conditions’
[10:22:31.184]   - Field: ‘expr’
[10:22:31.184]   - Field: ‘uuid’
[10:22:31.184]   - Field: ‘seed’
[10:22:31.185]   - Field: ‘version’
[10:22:31.185]   - Field: ‘result’
[10:22:31.185]   - Field: ‘asynchronous’
[10:22:31.185]   - Field: ‘calls’
[10:22:31.185]   - Field: ‘globals’
[10:22:31.185]   - Field: ‘stdout’
[10:22:31.186]   - Field: ‘earlySignal’
[10:22:31.186]   - Field: ‘lazy’
[10:22:31.186]   - Field: ‘state’
[10:22:31.186] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:31.186] - Launch lazy future ...
[10:22:31.187] Packages needed by the future expression (n = 0): <none>
[10:22:31.187] Packages needed by future strategies (n = 0): <none>
[10:22:31.188] {
[10:22:31.188]     {
[10:22:31.188]         {
[10:22:31.188]             ...future.startTime <- base::Sys.time()
[10:22:31.188]             {
[10:22:31.188]                 {
[10:22:31.188]                   {
[10:22:31.188]                     {
[10:22:31.188]                       base::local({
[10:22:31.188]                         has_future <- base::requireNamespace("future", 
[10:22:31.188]                           quietly = TRUE)
[10:22:31.188]                         if (has_future) {
[10:22:31.188]                           ns <- base::getNamespace("future")
[10:22:31.188]                           version <- ns[[".package"]][["version"]]
[10:22:31.188]                           if (is.null(version)) 
[10:22:31.188]                             version <- utils::packageVersion("future")
[10:22:31.188]                         }
[10:22:31.188]                         else {
[10:22:31.188]                           version <- NULL
[10:22:31.188]                         }
[10:22:31.188]                         if (!has_future || version < "1.8.0") {
[10:22:31.188]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:31.188]                             "", base::R.version$version.string), 
[10:22:31.188]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:31.188]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:31.188]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:31.188]                               "release", "version")], collapse = " "), 
[10:22:31.188]                             hostname = base::Sys.info()[["nodename"]])
[10:22:31.188]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:31.188]                             info)
[10:22:31.188]                           info <- base::paste(info, collapse = "; ")
[10:22:31.188]                           if (!has_future) {
[10:22:31.188]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:31.188]                               info)
[10:22:31.188]                           }
[10:22:31.188]                           else {
[10:22:31.188]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:31.188]                               info, version)
[10:22:31.188]                           }
[10:22:31.188]                           base::stop(msg)
[10:22:31.188]                         }
[10:22:31.188]                       })
[10:22:31.188]                     }
[10:22:31.188]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:31.188]                     base::options(mc.cores = 1L)
[10:22:31.188]                   }
[10:22:31.188]                   ...future.strategy.old <- future::plan("list")
[10:22:31.188]                   options(future.plan = NULL)
[10:22:31.188]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:31.188]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:31.188]                 }
[10:22:31.188]                 ...future.workdir <- getwd()
[10:22:31.188]             }
[10:22:31.188]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:31.188]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:31.188]         }
[10:22:31.188]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:31.188]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:31.188]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:31.188]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:31.188]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:31.188]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:31.188]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:31.188]             base::names(...future.oldOptions))
[10:22:31.188]     }
[10:22:31.188]     if (FALSE) {
[10:22:31.188]     }
[10:22:31.188]     else {
[10:22:31.188]         if (TRUE) {
[10:22:31.188]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:31.188]                 open = "w")
[10:22:31.188]         }
[10:22:31.188]         else {
[10:22:31.188]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:31.188]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:31.188]         }
[10:22:31.188]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:31.188]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:31.188]             base::sink(type = "output", split = FALSE)
[10:22:31.188]             base::close(...future.stdout)
[10:22:31.188]         }, add = TRUE)
[10:22:31.188]     }
[10:22:31.188]     ...future.frame <- base::sys.nframe()
[10:22:31.188]     ...future.conditions <- base::list()
[10:22:31.188]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:31.188]     if (FALSE) {
[10:22:31.188]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:31.188]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:31.188]     }
[10:22:31.188]     ...future.result <- base::tryCatch({
[10:22:31.188]         base::withCallingHandlers({
[10:22:31.188]             ...future.value <- base::withVisible(base::local({
[10:22:31.188]                 withCallingHandlers({
[10:22:31.188]                   1
[10:22:31.188]                 }, immediateCondition = function(cond) {
[10:22:31.188]                   save_rds <- function (object, pathname, ...) 
[10:22:31.188]                   {
[10:22:31.188]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:31.188]                     if (file_test("-f", pathname_tmp)) {
[10:22:31.188]                       fi_tmp <- file.info(pathname_tmp)
[10:22:31.188]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:31.188]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:31.188]                         fi_tmp[["mtime"]])
[10:22:31.188]                     }
[10:22:31.188]                     tryCatch({
[10:22:31.188]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:31.188]                     }, error = function(ex) {
[10:22:31.188]                       msg <- conditionMessage(ex)
[10:22:31.188]                       fi_tmp <- file.info(pathname_tmp)
[10:22:31.188]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:31.188]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:31.188]                         fi_tmp[["mtime"]], msg)
[10:22:31.188]                       ex$message <- msg
[10:22:31.188]                       stop(ex)
[10:22:31.188]                     })
[10:22:31.188]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:31.188]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:31.188]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:31.188]                       fi_tmp <- file.info(pathname_tmp)
[10:22:31.188]                       fi <- file.info(pathname)
[10:22:31.188]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:31.188]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:31.188]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:31.188]                         fi[["size"]], fi[["mtime"]])
[10:22:31.188]                       stop(msg)
[10:22:31.188]                     }
[10:22:31.188]                     invisible(pathname)
[10:22:31.188]                   }
[10:22:31.188]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:31.188]                     rootPath = tempdir()) 
[10:22:31.188]                   {
[10:22:31.188]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:31.188]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:31.188]                       tmpdir = path, fileext = ".rds")
[10:22:31.188]                     save_rds(obj, file)
[10:22:31.188]                   }
[10:22:31.188]                   saveImmediateCondition(cond, path = "/tmp/RtmpzsJv4f/.future/immediateConditions")
[10:22:31.188]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:31.188]                   {
[10:22:31.188]                     inherits <- base::inherits
[10:22:31.188]                     invokeRestart <- base::invokeRestart
[10:22:31.188]                     is.null <- base::is.null
[10:22:31.188]                     muffled <- FALSE
[10:22:31.188]                     if (inherits(cond, "message")) {
[10:22:31.188]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:31.188]                       if (muffled) 
[10:22:31.188]                         invokeRestart("muffleMessage")
[10:22:31.188]                     }
[10:22:31.188]                     else if (inherits(cond, "warning")) {
[10:22:31.188]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:31.188]                       if (muffled) 
[10:22:31.188]                         invokeRestart("muffleWarning")
[10:22:31.188]                     }
[10:22:31.188]                     else if (inherits(cond, "condition")) {
[10:22:31.188]                       if (!is.null(pattern)) {
[10:22:31.188]                         computeRestarts <- base::computeRestarts
[10:22:31.188]                         grepl <- base::grepl
[10:22:31.188]                         restarts <- computeRestarts(cond)
[10:22:31.188]                         for (restart in restarts) {
[10:22:31.188]                           name <- restart$name
[10:22:31.188]                           if (is.null(name)) 
[10:22:31.188]                             next
[10:22:31.188]                           if (!grepl(pattern, name)) 
[10:22:31.188]                             next
[10:22:31.188]                           invokeRestart(restart)
[10:22:31.188]                           muffled <- TRUE
[10:22:31.188]                           break
[10:22:31.188]                         }
[10:22:31.188]                       }
[10:22:31.188]                     }
[10:22:31.188]                     invisible(muffled)
[10:22:31.188]                   }
[10:22:31.188]                   muffleCondition(cond)
[10:22:31.188]                 })
[10:22:31.188]             }))
[10:22:31.188]             future::FutureResult(value = ...future.value$value, 
[10:22:31.188]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:31.188]                   ...future.rng), globalenv = if (FALSE) 
[10:22:31.188]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:31.188]                     ...future.globalenv.names))
[10:22:31.188]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:31.188]         }, condition = base::local({
[10:22:31.188]             c <- base::c
[10:22:31.188]             inherits <- base::inherits
[10:22:31.188]             invokeRestart <- base::invokeRestart
[10:22:31.188]             length <- base::length
[10:22:31.188]             list <- base::list
[10:22:31.188]             seq.int <- base::seq.int
[10:22:31.188]             signalCondition <- base::signalCondition
[10:22:31.188]             sys.calls <- base::sys.calls
[10:22:31.188]             `[[` <- base::`[[`
[10:22:31.188]             `+` <- base::`+`
[10:22:31.188]             `<<-` <- base::`<<-`
[10:22:31.188]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:31.188]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:31.188]                   3L)]
[10:22:31.188]             }
[10:22:31.188]             function(cond) {
[10:22:31.188]                 is_error <- inherits(cond, "error")
[10:22:31.188]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:31.188]                   NULL)
[10:22:31.188]                 if (is_error) {
[10:22:31.188]                   sessionInformation <- function() {
[10:22:31.188]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:31.188]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:31.188]                       search = base::search(), system = base::Sys.info())
[10:22:31.188]                   }
[10:22:31.188]                   ...future.conditions[[length(...future.conditions) + 
[10:22:31.188]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:31.188]                     cond$call), session = sessionInformation(), 
[10:22:31.188]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:31.188]                   signalCondition(cond)
[10:22:31.188]                 }
[10:22:31.188]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:31.188]                 "immediateCondition"))) {
[10:22:31.188]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:31.188]                   ...future.conditions[[length(...future.conditions) + 
[10:22:31.188]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:31.188]                   if (TRUE && !signal) {
[10:22:31.188]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:31.188]                     {
[10:22:31.188]                       inherits <- base::inherits
[10:22:31.188]                       invokeRestart <- base::invokeRestart
[10:22:31.188]                       is.null <- base::is.null
[10:22:31.188]                       muffled <- FALSE
[10:22:31.188]                       if (inherits(cond, "message")) {
[10:22:31.188]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:31.188]                         if (muffled) 
[10:22:31.188]                           invokeRestart("muffleMessage")
[10:22:31.188]                       }
[10:22:31.188]                       else if (inherits(cond, "warning")) {
[10:22:31.188]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:31.188]                         if (muffled) 
[10:22:31.188]                           invokeRestart("muffleWarning")
[10:22:31.188]                       }
[10:22:31.188]                       else if (inherits(cond, "condition")) {
[10:22:31.188]                         if (!is.null(pattern)) {
[10:22:31.188]                           computeRestarts <- base::computeRestarts
[10:22:31.188]                           grepl <- base::grepl
[10:22:31.188]                           restarts <- computeRestarts(cond)
[10:22:31.188]                           for (restart in restarts) {
[10:22:31.188]                             name <- restart$name
[10:22:31.188]                             if (is.null(name)) 
[10:22:31.188]                               next
[10:22:31.188]                             if (!grepl(pattern, name)) 
[10:22:31.188]                               next
[10:22:31.188]                             invokeRestart(restart)
[10:22:31.188]                             muffled <- TRUE
[10:22:31.188]                             break
[10:22:31.188]                           }
[10:22:31.188]                         }
[10:22:31.188]                       }
[10:22:31.188]                       invisible(muffled)
[10:22:31.188]                     }
[10:22:31.188]                     muffleCondition(cond, pattern = "^muffle")
[10:22:31.188]                   }
[10:22:31.188]                 }
[10:22:31.188]                 else {
[10:22:31.188]                   if (TRUE) {
[10:22:31.188]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:31.188]                     {
[10:22:31.188]                       inherits <- base::inherits
[10:22:31.188]                       invokeRestart <- base::invokeRestart
[10:22:31.188]                       is.null <- base::is.null
[10:22:31.188]                       muffled <- FALSE
[10:22:31.188]                       if (inherits(cond, "message")) {
[10:22:31.188]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:31.188]                         if (muffled) 
[10:22:31.188]                           invokeRestart("muffleMessage")
[10:22:31.188]                       }
[10:22:31.188]                       else if (inherits(cond, "warning")) {
[10:22:31.188]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:31.188]                         if (muffled) 
[10:22:31.188]                           invokeRestart("muffleWarning")
[10:22:31.188]                       }
[10:22:31.188]                       else if (inherits(cond, "condition")) {
[10:22:31.188]                         if (!is.null(pattern)) {
[10:22:31.188]                           computeRestarts <- base::computeRestarts
[10:22:31.188]                           grepl <- base::grepl
[10:22:31.188]                           restarts <- computeRestarts(cond)
[10:22:31.188]                           for (restart in restarts) {
[10:22:31.188]                             name <- restart$name
[10:22:31.188]                             if (is.null(name)) 
[10:22:31.188]                               next
[10:22:31.188]                             if (!grepl(pattern, name)) 
[10:22:31.188]                               next
[10:22:31.188]                             invokeRestart(restart)
[10:22:31.188]                             muffled <- TRUE
[10:22:31.188]                             break
[10:22:31.188]                           }
[10:22:31.188]                         }
[10:22:31.188]                       }
[10:22:31.188]                       invisible(muffled)
[10:22:31.188]                     }
[10:22:31.188]                     muffleCondition(cond, pattern = "^muffle")
[10:22:31.188]                   }
[10:22:31.188]                 }
[10:22:31.188]             }
[10:22:31.188]         }))
[10:22:31.188]     }, error = function(ex) {
[10:22:31.188]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:31.188]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:31.188]                 ...future.rng), started = ...future.startTime, 
[10:22:31.188]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:31.188]             version = "1.8"), class = "FutureResult")
[10:22:31.188]     }, finally = {
[10:22:31.188]         if (!identical(...future.workdir, getwd())) 
[10:22:31.188]             setwd(...future.workdir)
[10:22:31.188]         {
[10:22:31.188]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:31.188]                 ...future.oldOptions$nwarnings <- NULL
[10:22:31.188]             }
[10:22:31.188]             base::options(...future.oldOptions)
[10:22:31.188]             if (.Platform$OS.type == "windows") {
[10:22:31.188]                 old_names <- names(...future.oldEnvVars)
[10:22:31.188]                 envs <- base::Sys.getenv()
[10:22:31.188]                 names <- names(envs)
[10:22:31.188]                 common <- intersect(names, old_names)
[10:22:31.188]                 added <- setdiff(names, old_names)
[10:22:31.188]                 removed <- setdiff(old_names, names)
[10:22:31.188]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:31.188]                   envs[common]]
[10:22:31.188]                 NAMES <- toupper(changed)
[10:22:31.188]                 args <- list()
[10:22:31.188]                 for (kk in seq_along(NAMES)) {
[10:22:31.188]                   name <- changed[[kk]]
[10:22:31.188]                   NAME <- NAMES[[kk]]
[10:22:31.188]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:31.188]                     next
[10:22:31.188]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:31.188]                 }
[10:22:31.188]                 NAMES <- toupper(added)
[10:22:31.188]                 for (kk in seq_along(NAMES)) {
[10:22:31.188]                   name <- added[[kk]]
[10:22:31.188]                   NAME <- NAMES[[kk]]
[10:22:31.188]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:31.188]                     next
[10:22:31.188]                   args[[name]] <- ""
[10:22:31.188]                 }
[10:22:31.188]                 NAMES <- toupper(removed)
[10:22:31.188]                 for (kk in seq_along(NAMES)) {
[10:22:31.188]                   name <- removed[[kk]]
[10:22:31.188]                   NAME <- NAMES[[kk]]
[10:22:31.188]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:31.188]                     next
[10:22:31.188]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:31.188]                 }
[10:22:31.188]                 if (length(args) > 0) 
[10:22:31.188]                   base::do.call(base::Sys.setenv, args = args)
[10:22:31.188]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:31.188]             }
[10:22:31.188]             else {
[10:22:31.188]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:31.188]             }
[10:22:31.188]             {
[10:22:31.188]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:31.188]                   0L) {
[10:22:31.188]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:31.188]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:31.188]                   base::options(opts)
[10:22:31.188]                 }
[10:22:31.188]                 {
[10:22:31.188]                   {
[10:22:31.188]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:31.188]                     NULL
[10:22:31.188]                   }
[10:22:31.188]                   options(future.plan = NULL)
[10:22:31.188]                   if (is.na(NA_character_)) 
[10:22:31.188]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:31.188]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:31.188]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:31.188]                     .init = FALSE)
[10:22:31.188]                 }
[10:22:31.188]             }
[10:22:31.188]         }
[10:22:31.188]     })
[10:22:31.188]     if (TRUE) {
[10:22:31.188]         base::sink(type = "output", split = FALSE)
[10:22:31.188]         if (TRUE) {
[10:22:31.188]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:31.188]         }
[10:22:31.188]         else {
[10:22:31.188]             ...future.result["stdout"] <- base::list(NULL)
[10:22:31.188]         }
[10:22:31.188]         base::close(...future.stdout)
[10:22:31.188]         ...future.stdout <- NULL
[10:22:31.188]     }
[10:22:31.188]     ...future.result$conditions <- ...future.conditions
[10:22:31.188]     ...future.result$finished <- base::Sys.time()
[10:22:31.188]     ...future.result
[10:22:31.188] }
[10:22:31.190] requestCore(): workers = 2
[10:22:31.191] Poll #1 (0): usedCores() = 2, workers = 2
[10:22:31.201] result() for MulticoreFuture ...
[10:22:31.202] result() for MulticoreFuture ...
[10:22:31.202] result() for MulticoreFuture ... done
[10:22:31.202] result() for MulticoreFuture ... done
[10:22:31.202] result() for MulticoreFuture ...
[10:22:31.203] result() for MulticoreFuture ... done
[10:22:31.205] MulticoreFuture started
[10:22:31.205] - Launch lazy future ... done
[10:22:31.206] run() for ‘MulticoreFuture’ ... done
[10:22:31.206] plan(): Setting new future strategy stack:
[10:22:31.206] getGlobalsAndPackages() ...
[10:22:31.207] Searching for globals...
[10:22:31.207] List of future strategies:
[10:22:31.207] 1. sequential:
[10:22:31.207]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:31.207]    - tweaked: FALSE
[10:22:31.207]    - call: NULL
[10:22:31.208] 
[10:22:31.208] Searching for globals ... DONE
[10:22:31.208] plan(): nbrOfWorkers() = 1
[10:22:31.208] - globals: [0] <none>
[10:22:31.208] getGlobalsAndPackages() ... DONE
[10:22:31.209] run() for ‘Future’ ...
[10:22:31.209] - state: ‘created’
[10:22:31.210] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:31.211] plan(): Setting new future strategy stack:
[10:22:31.211] List of future strategies:
[10:22:31.211] 1. multicore:
[10:22:31.211]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:31.211]    - tweaked: FALSE
[10:22:31.211]    - call: plan(strategy)
[10:22:31.214] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:31.215] plan(): nbrOfWorkers() = 2
[10:22:31.215] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:31.215]   - Field: ‘label’
[10:22:31.215]   - Field: ‘local’
[10:22:31.215]   - Field: ‘owner’
[10:22:31.215]   - Field: ‘envir’
[10:22:31.216]   - Field: ‘workers’
[10:22:31.216]   - Field: ‘packages’
[10:22:31.216]   - Field: ‘gc’
[10:22:31.216]   - Field: ‘job’
[10:22:31.216]   - Field: ‘conditions’
[10:22:31.216]   - Field: ‘expr’
[10:22:31.216]   - Field: ‘uuid’
[10:22:31.217]   - Field: ‘seed’
[10:22:31.217]   - Field: ‘version’
[10:22:31.217]   - Field: ‘result’
[10:22:31.217]   - Field: ‘asynchronous’
[10:22:31.217]   - Field: ‘calls’
[10:22:31.217]   - Field: ‘globals’
[10:22:31.217]   - Field: ‘stdout’
[10:22:31.218]   - Field: ‘earlySignal’
[10:22:31.218]   - Field: ‘lazy’
[10:22:31.218]   - Field: ‘state’
[10:22:31.218] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:31.218] - Launch lazy future ...
[10:22:31.219] Packages needed by the future expression (n = 0): <none>
[10:22:31.219] Packages needed by future strategies (n = 0): <none>
[10:22:31.220] {
[10:22:31.220]     {
[10:22:31.220]         {
[10:22:31.220]             ...future.startTime <- base::Sys.time()
[10:22:31.220]             {
[10:22:31.220]                 {
[10:22:31.220]                   {
[10:22:31.220]                     {
[10:22:31.220]                       base::local({
[10:22:31.220]                         has_future <- base::requireNamespace("future", 
[10:22:31.220]                           quietly = TRUE)
[10:22:31.220]                         if (has_future) {
[10:22:31.220]                           ns <- base::getNamespace("future")
[10:22:31.220]                           version <- ns[[".package"]][["version"]]
[10:22:31.220]                           if (is.null(version)) 
[10:22:31.220]                             version <- utils::packageVersion("future")
[10:22:31.220]                         }
[10:22:31.220]                         else {
[10:22:31.220]                           version <- NULL
[10:22:31.220]                         }
[10:22:31.220]                         if (!has_future || version < "1.8.0") {
[10:22:31.220]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:31.220]                             "", base::R.version$version.string), 
[10:22:31.220]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:31.220]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:31.220]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:31.220]                               "release", "version")], collapse = " "), 
[10:22:31.220]                             hostname = base::Sys.info()[["nodename"]])
[10:22:31.220]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:31.220]                             info)
[10:22:31.220]                           info <- base::paste(info, collapse = "; ")
[10:22:31.220]                           if (!has_future) {
[10:22:31.220]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:31.220]                               info)
[10:22:31.220]                           }
[10:22:31.220]                           else {
[10:22:31.220]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:31.220]                               info, version)
[10:22:31.220]                           }
[10:22:31.220]                           base::stop(msg)
[10:22:31.220]                         }
[10:22:31.220]                       })
[10:22:31.220]                     }
[10:22:31.220]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:31.220]                     base::options(mc.cores = 1L)
[10:22:31.220]                   }
[10:22:31.220]                   ...future.strategy.old <- future::plan("list")
[10:22:31.220]                   options(future.plan = NULL)
[10:22:31.220]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:31.220]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:31.220]                 }
[10:22:31.220]                 ...future.workdir <- getwd()
[10:22:31.220]             }
[10:22:31.220]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:31.220]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:31.220]         }
[10:22:31.220]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:31.220]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:31.220]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:31.220]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:31.220]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:31.220]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:31.220]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:31.220]             base::names(...future.oldOptions))
[10:22:31.220]     }
[10:22:31.220]     if (FALSE) {
[10:22:31.220]     }
[10:22:31.220]     else {
[10:22:31.220]         if (TRUE) {
[10:22:31.220]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:31.220]                 open = "w")
[10:22:31.220]         }
[10:22:31.220]         else {
[10:22:31.220]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:31.220]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:31.220]         }
[10:22:31.220]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:31.220]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:31.220]             base::sink(type = "output", split = FALSE)
[10:22:31.220]             base::close(...future.stdout)
[10:22:31.220]         }, add = TRUE)
[10:22:31.220]     }
[10:22:31.220]     ...future.frame <- base::sys.nframe()
[10:22:31.220]     ...future.conditions <- base::list()
[10:22:31.220]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:31.220]     if (FALSE) {
[10:22:31.220]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:31.220]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:31.220]     }
[10:22:31.220]     ...future.result <- base::tryCatch({
[10:22:31.220]         base::withCallingHandlers({
[10:22:31.220]             ...future.value <- base::withVisible(base::local({
[10:22:31.220]                 withCallingHandlers({
[10:22:31.220]                   2
[10:22:31.220]                 }, immediateCondition = function(cond) {
[10:22:31.220]                   save_rds <- function (object, pathname, ...) 
[10:22:31.220]                   {
[10:22:31.220]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:31.220]                     if (file_test("-f", pathname_tmp)) {
[10:22:31.220]                       fi_tmp <- file.info(pathname_tmp)
[10:22:31.220]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:31.220]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:31.220]                         fi_tmp[["mtime"]])
[10:22:31.220]                     }
[10:22:31.220]                     tryCatch({
[10:22:31.220]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:31.220]                     }, error = function(ex) {
[10:22:31.220]                       msg <- conditionMessage(ex)
[10:22:31.220]                       fi_tmp <- file.info(pathname_tmp)
[10:22:31.220]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:31.220]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:31.220]                         fi_tmp[["mtime"]], msg)
[10:22:31.220]                       ex$message <- msg
[10:22:31.220]                       stop(ex)
[10:22:31.220]                     })
[10:22:31.220]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:31.220]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:31.220]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:31.220]                       fi_tmp <- file.info(pathname_tmp)
[10:22:31.220]                       fi <- file.info(pathname)
[10:22:31.220]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:31.220]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:31.220]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:31.220]                         fi[["size"]], fi[["mtime"]])
[10:22:31.220]                       stop(msg)
[10:22:31.220]                     }
[10:22:31.220]                     invisible(pathname)
[10:22:31.220]                   }
[10:22:31.220]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:31.220]                     rootPath = tempdir()) 
[10:22:31.220]                   {
[10:22:31.220]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:31.220]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:31.220]                       tmpdir = path, fileext = ".rds")
[10:22:31.220]                     save_rds(obj, file)
[10:22:31.220]                   }
[10:22:31.220]                   saveImmediateCondition(cond, path = "/tmp/RtmpzsJv4f/.future/immediateConditions")
[10:22:31.220]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:31.220]                   {
[10:22:31.220]                     inherits <- base::inherits
[10:22:31.220]                     invokeRestart <- base::invokeRestart
[10:22:31.220]                     is.null <- base::is.null
[10:22:31.220]                     muffled <- FALSE
[10:22:31.220]                     if (inherits(cond, "message")) {
[10:22:31.220]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:31.220]                       if (muffled) 
[10:22:31.220]                         invokeRestart("muffleMessage")
[10:22:31.220]                     }
[10:22:31.220]                     else if (inherits(cond, "warning")) {
[10:22:31.220]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:31.220]                       if (muffled) 
[10:22:31.220]                         invokeRestart("muffleWarning")
[10:22:31.220]                     }
[10:22:31.220]                     else if (inherits(cond, "condition")) {
[10:22:31.220]                       if (!is.null(pattern)) {
[10:22:31.220]                         computeRestarts <- base::computeRestarts
[10:22:31.220]                         grepl <- base::grepl
[10:22:31.220]                         restarts <- computeRestarts(cond)
[10:22:31.220]                         for (restart in restarts) {
[10:22:31.220]                           name <- restart$name
[10:22:31.220]                           if (is.null(name)) 
[10:22:31.220]                             next
[10:22:31.220]                           if (!grepl(pattern, name)) 
[10:22:31.220]                             next
[10:22:31.220]                           invokeRestart(restart)
[10:22:31.220]                           muffled <- TRUE
[10:22:31.220]                           break
[10:22:31.220]                         }
[10:22:31.220]                       }
[10:22:31.220]                     }
[10:22:31.220]                     invisible(muffled)
[10:22:31.220]                   }
[10:22:31.220]                   muffleCondition(cond)
[10:22:31.220]                 })
[10:22:31.220]             }))
[10:22:31.220]             future::FutureResult(value = ...future.value$value, 
[10:22:31.220]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:31.220]                   ...future.rng), globalenv = if (FALSE) 
[10:22:31.220]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:31.220]                     ...future.globalenv.names))
[10:22:31.220]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:31.220]         }, condition = base::local({
[10:22:31.220]             c <- base::c
[10:22:31.220]             inherits <- base::inherits
[10:22:31.220]             invokeRestart <- base::invokeRestart
[10:22:31.220]             length <- base::length
[10:22:31.220]             list <- base::list
[10:22:31.220]             seq.int <- base::seq.int
[10:22:31.220]             signalCondition <- base::signalCondition
[10:22:31.220]             sys.calls <- base::sys.calls
[10:22:31.220]             `[[` <- base::`[[`
[10:22:31.220]             `+` <- base::`+`
[10:22:31.220]             `<<-` <- base::`<<-`
[10:22:31.220]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:31.220]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:31.220]                   3L)]
[10:22:31.220]             }
[10:22:31.220]             function(cond) {
[10:22:31.220]                 is_error <- inherits(cond, "error")
[10:22:31.220]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:31.220]                   NULL)
[10:22:31.220]                 if (is_error) {
[10:22:31.220]                   sessionInformation <- function() {
[10:22:31.220]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:31.220]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:31.220]                       search = base::search(), system = base::Sys.info())
[10:22:31.220]                   }
[10:22:31.220]                   ...future.conditions[[length(...future.conditions) + 
[10:22:31.220]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:31.220]                     cond$call), session = sessionInformation(), 
[10:22:31.220]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:31.220]                   signalCondition(cond)
[10:22:31.220]                 }
[10:22:31.220]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:31.220]                 "immediateCondition"))) {
[10:22:31.220]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:31.220]                   ...future.conditions[[length(...future.conditions) + 
[10:22:31.220]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:31.220]                   if (TRUE && !signal) {
[10:22:31.220]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:31.220]                     {
[10:22:31.220]                       inherits <- base::inherits
[10:22:31.220]                       invokeRestart <- base::invokeRestart
[10:22:31.220]                       is.null <- base::is.null
[10:22:31.220]                       muffled <- FALSE
[10:22:31.220]                       if (inherits(cond, "message")) {
[10:22:31.220]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:31.220]                         if (muffled) 
[10:22:31.220]                           invokeRestart("muffleMessage")
[10:22:31.220]                       }
[10:22:31.220]                       else if (inherits(cond, "warning")) {
[10:22:31.220]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:31.220]                         if (muffled) 
[10:22:31.220]                           invokeRestart("muffleWarning")
[10:22:31.220]                       }
[10:22:31.220]                       else if (inherits(cond, "condition")) {
[10:22:31.220]                         if (!is.null(pattern)) {
[10:22:31.220]                           computeRestarts <- base::computeRestarts
[10:22:31.220]                           grepl <- base::grepl
[10:22:31.220]                           restarts <- computeRestarts(cond)
[10:22:31.220]                           for (restart in restarts) {
[10:22:31.220]                             name <- restart$name
[10:22:31.220]                             if (is.null(name)) 
[10:22:31.220]                               next
[10:22:31.220]                             if (!grepl(pattern, name)) 
[10:22:31.220]                               next
[10:22:31.220]                             invokeRestart(restart)
[10:22:31.220]                             muffled <- TRUE
[10:22:31.220]                             break
[10:22:31.220]                           }
[10:22:31.220]                         }
[10:22:31.220]                       }
[10:22:31.220]                       invisible(muffled)
[10:22:31.220]                     }
[10:22:31.220]                     muffleCondition(cond, pattern = "^muffle")
[10:22:31.220]                   }
[10:22:31.220]                 }
[10:22:31.220]                 else {
[10:22:31.220]                   if (TRUE) {
[10:22:31.220]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:31.220]                     {
[10:22:31.220]                       inherits <- base::inherits
[10:22:31.220]                       invokeRestart <- base::invokeRestart
[10:22:31.220]                       is.null <- base::is.null
[10:22:31.220]                       muffled <- FALSE
[10:22:31.220]                       if (inherits(cond, "message")) {
[10:22:31.220]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:31.220]                         if (muffled) 
[10:22:31.220]                           invokeRestart("muffleMessage")
[10:22:31.220]                       }
[10:22:31.220]                       else if (inherits(cond, "warning")) {
[10:22:31.220]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:31.220]                         if (muffled) 
[10:22:31.220]                           invokeRestart("muffleWarning")
[10:22:31.220]                       }
[10:22:31.220]                       else if (inherits(cond, "condition")) {
[10:22:31.220]                         if (!is.null(pattern)) {
[10:22:31.220]                           computeRestarts <- base::computeRestarts
[10:22:31.220]                           grepl <- base::grepl
[10:22:31.220]                           restarts <- computeRestarts(cond)
[10:22:31.220]                           for (restart in restarts) {
[10:22:31.220]                             name <- restart$name
[10:22:31.220]                             if (is.null(name)) 
[10:22:31.220]                               next
[10:22:31.220]                             if (!grepl(pattern, name)) 
[10:22:31.220]                               next
[10:22:31.220]                             invokeRestart(restart)
[10:22:31.220]                             muffled <- TRUE
[10:22:31.220]                             break
[10:22:31.220]                           }
[10:22:31.220]                         }
[10:22:31.220]                       }
[10:22:31.220]                       invisible(muffled)
[10:22:31.220]                     }
[10:22:31.220]                     muffleCondition(cond, pattern = "^muffle")
[10:22:31.220]                   }
[10:22:31.220]                 }
[10:22:31.220]             }
[10:22:31.220]         }))
[10:22:31.220]     }, error = function(ex) {
[10:22:31.220]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:31.220]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:31.220]                 ...future.rng), started = ...future.startTime, 
[10:22:31.220]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:31.220]             version = "1.8"), class = "FutureResult")
[10:22:31.220]     }, finally = {
[10:22:31.220]         if (!identical(...future.workdir, getwd())) 
[10:22:31.220]             setwd(...future.workdir)
[10:22:31.220]         {
[10:22:31.220]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:31.220]                 ...future.oldOptions$nwarnings <- NULL
[10:22:31.220]             }
[10:22:31.220]             base::options(...future.oldOptions)
[10:22:31.220]             if (.Platform$OS.type == "windows") {
[10:22:31.220]                 old_names <- names(...future.oldEnvVars)
[10:22:31.220]                 envs <- base::Sys.getenv()
[10:22:31.220]                 names <- names(envs)
[10:22:31.220]                 common <- intersect(names, old_names)
[10:22:31.220]                 added <- setdiff(names, old_names)
[10:22:31.220]                 removed <- setdiff(old_names, names)
[10:22:31.220]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:31.220]                   envs[common]]
[10:22:31.220]                 NAMES <- toupper(changed)
[10:22:31.220]                 args <- list()
[10:22:31.220]                 for (kk in seq_along(NAMES)) {
[10:22:31.220]                   name <- changed[[kk]]
[10:22:31.220]                   NAME <- NAMES[[kk]]
[10:22:31.220]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:31.220]                     next
[10:22:31.220]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:31.220]                 }
[10:22:31.220]                 NAMES <- toupper(added)
[10:22:31.220]                 for (kk in seq_along(NAMES)) {
[10:22:31.220]                   name <- added[[kk]]
[10:22:31.220]                   NAME <- NAMES[[kk]]
[10:22:31.220]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:31.220]                     next
[10:22:31.220]                   args[[name]] <- ""
[10:22:31.220]                 }
[10:22:31.220]                 NAMES <- toupper(removed)
[10:22:31.220]                 for (kk in seq_along(NAMES)) {
[10:22:31.220]                   name <- removed[[kk]]
[10:22:31.220]                   NAME <- NAMES[[kk]]
[10:22:31.220]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:31.220]                     next
[10:22:31.220]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:31.220]                 }
[10:22:31.220]                 if (length(args) > 0) 
[10:22:31.220]                   base::do.call(base::Sys.setenv, args = args)
[10:22:31.220]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:31.220]             }
[10:22:31.220]             else {
[10:22:31.220]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:31.220]             }
[10:22:31.220]             {
[10:22:31.220]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:31.220]                   0L) {
[10:22:31.220]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:31.220]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:31.220]                   base::options(opts)
[10:22:31.220]                 }
[10:22:31.220]                 {
[10:22:31.220]                   {
[10:22:31.220]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:31.220]                     NULL
[10:22:31.220]                   }
[10:22:31.220]                   options(future.plan = NULL)
[10:22:31.220]                   if (is.na(NA_character_)) 
[10:22:31.220]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:31.220]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:31.220]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:31.220]                     .init = FALSE)
[10:22:31.220]                 }
[10:22:31.220]             }
[10:22:31.220]         }
[10:22:31.220]     })
[10:22:31.220]     if (TRUE) {
[10:22:31.220]         base::sink(type = "output", split = FALSE)
[10:22:31.220]         if (TRUE) {
[10:22:31.220]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:31.220]         }
[10:22:31.220]         else {
[10:22:31.220]             ...future.result["stdout"] <- base::list(NULL)
[10:22:31.220]         }
[10:22:31.220]         base::close(...future.stdout)
[10:22:31.220]         ...future.stdout <- NULL
[10:22:31.220]     }
[10:22:31.220]     ...future.result$conditions <- ...future.conditions
[10:22:31.220]     ...future.result$finished <- base::Sys.time()
[10:22:31.220]     ...future.result
[10:22:31.220] }
[10:22:31.223] requestCore(): workers = 2
[10:22:31.223] Poll #1 (0): usedCores() = 2, workers = 2
[10:22:31.234] result() for MulticoreFuture ...
[10:22:31.235] result() for MulticoreFuture ...
[10:22:31.235] result() for MulticoreFuture ... done
[10:22:31.236] result() for MulticoreFuture ... done
[10:22:31.236] result() for MulticoreFuture ...
[10:22:31.236] result() for MulticoreFuture ... done
[10:22:31.239] MulticoreFuture started
[10:22:31.239] - Launch lazy future ... done
[10:22:31.239] run() for ‘MulticoreFuture’ ... done
[10:22:31.240] plan(): Setting new future strategy stack:
[10:22:31.240] List of future strategies:
[10:22:31.240] 1. sequential:
[10:22:31.240]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:31.240]    - tweaked: FALSE
[10:22:31.240]    - call: NULL
[10:22:31.241] resolve() on environment ...
[10:22:31.241] plan(): nbrOfWorkers() = 1
[10:22:31.241]  recursive: 0
[10:22:31.242]  elements: [3] ‘a’, ‘b’, ‘c’
[10:22:31.242] Future #1
[10:22:31.243]  length: 2 (resolved future 1)
[10:22:31.243] plan(): Setting new future strategy stack:
[10:22:31.243] List of future strategies:
[10:22:31.243] 1. multicore:
[10:22:31.243]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:31.243]    - tweaked: FALSE
[10:22:31.243]    - call: plan(strategy)
[10:22:31.246] plan(): nbrOfWorkers() = 2
[10:22:31.247] Future #2
[10:22:31.247]  length: 1 (resolved future 2)
[10:22:31.247]  length: 0 (resolved future 3)
[10:22:31.247] resolve() on environment ... DONE
[10:22:31.249] getGlobalsAndPackages() ...
[10:22:31.249] Searching for globals...
[10:22:31.250] - globals found: [1] ‘{’
[10:22:31.250] Searching for globals ... DONE
[10:22:31.250] Resolving globals: FALSE
[10:22:31.251] 
[10:22:31.251] 
[10:22:31.251] getGlobalsAndPackages() ... DONE
[10:22:31.252] run() for ‘Future’ ...
[10:22:31.252] - state: ‘created’
[10:22:31.252] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:31.254] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:31.255] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:31.255]   - Field: ‘label’
[10:22:31.255]   - Field: ‘local’
[10:22:31.255]   - Field: ‘owner’
[10:22:31.255]   - Field: ‘envir’
[10:22:31.255]   - Field: ‘workers’
[10:22:31.256]   - Field: ‘packages’
[10:22:31.256]   - Field: ‘gc’
[10:22:31.256]   - Field: ‘job’
[10:22:31.256]   - Field: ‘conditions’
[10:22:31.256]   - Field: ‘expr’
[10:22:31.256]   - Field: ‘uuid’
[10:22:31.256]   - Field: ‘seed’
[10:22:31.256]   - Field: ‘version’
[10:22:31.257]   - Field: ‘result’
[10:22:31.257]   - Field: ‘asynchronous’
[10:22:31.257]   - Field: ‘calls’
[10:22:31.257]   - Field: ‘globals’
[10:22:31.257]   - Field: ‘stdout’
[10:22:31.258]   - Field: ‘earlySignal’
[10:22:31.258]   - Field: ‘lazy’
[10:22:31.258]   - Field: ‘state’
[10:22:31.258] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:31.258] - Launch lazy future ...
[10:22:31.259] Packages needed by the future expression (n = 0): <none>
[10:22:31.259] Packages needed by future strategies (n = 0): <none>
[10:22:31.259] {
[10:22:31.259]     {
[10:22:31.259]         {
[10:22:31.259]             ...future.startTime <- base::Sys.time()
[10:22:31.259]             {
[10:22:31.259]                 {
[10:22:31.259]                   {
[10:22:31.259]                     {
[10:22:31.259]                       base::local({
[10:22:31.259]                         has_future <- base::requireNamespace("future", 
[10:22:31.259]                           quietly = TRUE)
[10:22:31.259]                         if (has_future) {
[10:22:31.259]                           ns <- base::getNamespace("future")
[10:22:31.259]                           version <- ns[[".package"]][["version"]]
[10:22:31.259]                           if (is.null(version)) 
[10:22:31.259]                             version <- utils::packageVersion("future")
[10:22:31.259]                         }
[10:22:31.259]                         else {
[10:22:31.259]                           version <- NULL
[10:22:31.259]                         }
[10:22:31.259]                         if (!has_future || version < "1.8.0") {
[10:22:31.259]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:31.259]                             "", base::R.version$version.string), 
[10:22:31.259]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:31.259]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:31.259]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:31.259]                               "release", "version")], collapse = " "), 
[10:22:31.259]                             hostname = base::Sys.info()[["nodename"]])
[10:22:31.259]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:31.259]                             info)
[10:22:31.259]                           info <- base::paste(info, collapse = "; ")
[10:22:31.259]                           if (!has_future) {
[10:22:31.259]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:31.259]                               info)
[10:22:31.259]                           }
[10:22:31.259]                           else {
[10:22:31.259]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:31.259]                               info, version)
[10:22:31.259]                           }
[10:22:31.259]                           base::stop(msg)
[10:22:31.259]                         }
[10:22:31.259]                       })
[10:22:31.259]                     }
[10:22:31.259]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:31.259]                     base::options(mc.cores = 1L)
[10:22:31.259]                   }
[10:22:31.259]                   ...future.strategy.old <- future::plan("list")
[10:22:31.259]                   options(future.plan = NULL)
[10:22:31.259]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:31.259]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:31.259]                 }
[10:22:31.259]                 ...future.workdir <- getwd()
[10:22:31.259]             }
[10:22:31.259]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:31.259]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:31.259]         }
[10:22:31.259]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:31.259]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:31.259]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:31.259]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:31.259]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:31.259]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:31.259]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:31.259]             base::names(...future.oldOptions))
[10:22:31.259]     }
[10:22:31.259]     if (FALSE) {
[10:22:31.259]     }
[10:22:31.259]     else {
[10:22:31.259]         if (TRUE) {
[10:22:31.259]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:31.259]                 open = "w")
[10:22:31.259]         }
[10:22:31.259]         else {
[10:22:31.259]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:31.259]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:31.259]         }
[10:22:31.259]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:31.259]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:31.259]             base::sink(type = "output", split = FALSE)
[10:22:31.259]             base::close(...future.stdout)
[10:22:31.259]         }, add = TRUE)
[10:22:31.259]     }
[10:22:31.259]     ...future.frame <- base::sys.nframe()
[10:22:31.259]     ...future.conditions <- base::list()
[10:22:31.259]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:31.259]     if (FALSE) {
[10:22:31.259]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:31.259]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:31.259]     }
[10:22:31.259]     ...future.result <- base::tryCatch({
[10:22:31.259]         base::withCallingHandlers({
[10:22:31.259]             ...future.value <- base::withVisible(base::local({
[10:22:31.259]                 withCallingHandlers({
[10:22:31.259]                   {
[10:22:31.259]                     1
[10:22:31.259]                   }
[10:22:31.259]                 }, immediateCondition = function(cond) {
[10:22:31.259]                   save_rds <- function (object, pathname, ...) 
[10:22:31.259]                   {
[10:22:31.259]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:31.259]                     if (file_test("-f", pathname_tmp)) {
[10:22:31.259]                       fi_tmp <- file.info(pathname_tmp)
[10:22:31.259]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:31.259]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:31.259]                         fi_tmp[["mtime"]])
[10:22:31.259]                     }
[10:22:31.259]                     tryCatch({
[10:22:31.259]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:31.259]                     }, error = function(ex) {
[10:22:31.259]                       msg <- conditionMessage(ex)
[10:22:31.259]                       fi_tmp <- file.info(pathname_tmp)
[10:22:31.259]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:31.259]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:31.259]                         fi_tmp[["mtime"]], msg)
[10:22:31.259]                       ex$message <- msg
[10:22:31.259]                       stop(ex)
[10:22:31.259]                     })
[10:22:31.259]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:31.259]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:31.259]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:31.259]                       fi_tmp <- file.info(pathname_tmp)
[10:22:31.259]                       fi <- file.info(pathname)
[10:22:31.259]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:31.259]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:31.259]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:31.259]                         fi[["size"]], fi[["mtime"]])
[10:22:31.259]                       stop(msg)
[10:22:31.259]                     }
[10:22:31.259]                     invisible(pathname)
[10:22:31.259]                   }
[10:22:31.259]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:31.259]                     rootPath = tempdir()) 
[10:22:31.259]                   {
[10:22:31.259]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:31.259]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:31.259]                       tmpdir = path, fileext = ".rds")
[10:22:31.259]                     save_rds(obj, file)
[10:22:31.259]                   }
[10:22:31.259]                   saveImmediateCondition(cond, path = "/tmp/RtmpzsJv4f/.future/immediateConditions")
[10:22:31.259]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:31.259]                   {
[10:22:31.259]                     inherits <- base::inherits
[10:22:31.259]                     invokeRestart <- base::invokeRestart
[10:22:31.259]                     is.null <- base::is.null
[10:22:31.259]                     muffled <- FALSE
[10:22:31.259]                     if (inherits(cond, "message")) {
[10:22:31.259]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:31.259]                       if (muffled) 
[10:22:31.259]                         invokeRestart("muffleMessage")
[10:22:31.259]                     }
[10:22:31.259]                     else if (inherits(cond, "warning")) {
[10:22:31.259]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:31.259]                       if (muffled) 
[10:22:31.259]                         invokeRestart("muffleWarning")
[10:22:31.259]                     }
[10:22:31.259]                     else if (inherits(cond, "condition")) {
[10:22:31.259]                       if (!is.null(pattern)) {
[10:22:31.259]                         computeRestarts <- base::computeRestarts
[10:22:31.259]                         grepl <- base::grepl
[10:22:31.259]                         restarts <- computeRestarts(cond)
[10:22:31.259]                         for (restart in restarts) {
[10:22:31.259]                           name <- restart$name
[10:22:31.259]                           if (is.null(name)) 
[10:22:31.259]                             next
[10:22:31.259]                           if (!grepl(pattern, name)) 
[10:22:31.259]                             next
[10:22:31.259]                           invokeRestart(restart)
[10:22:31.259]                           muffled <- TRUE
[10:22:31.259]                           break
[10:22:31.259]                         }
[10:22:31.259]                       }
[10:22:31.259]                     }
[10:22:31.259]                     invisible(muffled)
[10:22:31.259]                   }
[10:22:31.259]                   muffleCondition(cond)
[10:22:31.259]                 })
[10:22:31.259]             }))
[10:22:31.259]             future::FutureResult(value = ...future.value$value, 
[10:22:31.259]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:31.259]                   ...future.rng), globalenv = if (FALSE) 
[10:22:31.259]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:31.259]                     ...future.globalenv.names))
[10:22:31.259]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:31.259]         }, condition = base::local({
[10:22:31.259]             c <- base::c
[10:22:31.259]             inherits <- base::inherits
[10:22:31.259]             invokeRestart <- base::invokeRestart
[10:22:31.259]             length <- base::length
[10:22:31.259]             list <- base::list
[10:22:31.259]             seq.int <- base::seq.int
[10:22:31.259]             signalCondition <- base::signalCondition
[10:22:31.259]             sys.calls <- base::sys.calls
[10:22:31.259]             `[[` <- base::`[[`
[10:22:31.259]             `+` <- base::`+`
[10:22:31.259]             `<<-` <- base::`<<-`
[10:22:31.259]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:31.259]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:31.259]                   3L)]
[10:22:31.259]             }
[10:22:31.259]             function(cond) {
[10:22:31.259]                 is_error <- inherits(cond, "error")
[10:22:31.259]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:31.259]                   NULL)
[10:22:31.259]                 if (is_error) {
[10:22:31.259]                   sessionInformation <- function() {
[10:22:31.259]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:31.259]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:31.259]                       search = base::search(), system = base::Sys.info())
[10:22:31.259]                   }
[10:22:31.259]                   ...future.conditions[[length(...future.conditions) + 
[10:22:31.259]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:31.259]                     cond$call), session = sessionInformation(), 
[10:22:31.259]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:31.259]                   signalCondition(cond)
[10:22:31.259]                 }
[10:22:31.259]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:31.259]                 "immediateCondition"))) {
[10:22:31.259]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:31.259]                   ...future.conditions[[length(...future.conditions) + 
[10:22:31.259]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:31.259]                   if (TRUE && !signal) {
[10:22:31.259]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:31.259]                     {
[10:22:31.259]                       inherits <- base::inherits
[10:22:31.259]                       invokeRestart <- base::invokeRestart
[10:22:31.259]                       is.null <- base::is.null
[10:22:31.259]                       muffled <- FALSE
[10:22:31.259]                       if (inherits(cond, "message")) {
[10:22:31.259]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:31.259]                         if (muffled) 
[10:22:31.259]                           invokeRestart("muffleMessage")
[10:22:31.259]                       }
[10:22:31.259]                       else if (inherits(cond, "warning")) {
[10:22:31.259]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:31.259]                         if (muffled) 
[10:22:31.259]                           invokeRestart("muffleWarning")
[10:22:31.259]                       }
[10:22:31.259]                       else if (inherits(cond, "condition")) {
[10:22:31.259]                         if (!is.null(pattern)) {
[10:22:31.259]                           computeRestarts <- base::computeRestarts
[10:22:31.259]                           grepl <- base::grepl
[10:22:31.259]                           restarts <- computeRestarts(cond)
[10:22:31.259]                           for (restart in restarts) {
[10:22:31.259]                             name <- restart$name
[10:22:31.259]                             if (is.null(name)) 
[10:22:31.259]                               next
[10:22:31.259]                             if (!grepl(pattern, name)) 
[10:22:31.259]                               next
[10:22:31.259]                             invokeRestart(restart)
[10:22:31.259]                             muffled <- TRUE
[10:22:31.259]                             break
[10:22:31.259]                           }
[10:22:31.259]                         }
[10:22:31.259]                       }
[10:22:31.259]                       invisible(muffled)
[10:22:31.259]                     }
[10:22:31.259]                     muffleCondition(cond, pattern = "^muffle")
[10:22:31.259]                   }
[10:22:31.259]                 }
[10:22:31.259]                 else {
[10:22:31.259]                   if (TRUE) {
[10:22:31.259]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:31.259]                     {
[10:22:31.259]                       inherits <- base::inherits
[10:22:31.259]                       invokeRestart <- base::invokeRestart
[10:22:31.259]                       is.null <- base::is.null
[10:22:31.259]                       muffled <- FALSE
[10:22:31.259]                       if (inherits(cond, "message")) {
[10:22:31.259]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:31.259]                         if (muffled) 
[10:22:31.259]                           invokeRestart("muffleMessage")
[10:22:31.259]                       }
[10:22:31.259]                       else if (inherits(cond, "warning")) {
[10:22:31.259]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:31.259]                         if (muffled) 
[10:22:31.259]                           invokeRestart("muffleWarning")
[10:22:31.259]                       }
[10:22:31.259]                       else if (inherits(cond, "condition")) {
[10:22:31.259]                         if (!is.null(pattern)) {
[10:22:31.259]                           computeRestarts <- base::computeRestarts
[10:22:31.259]                           grepl <- base::grepl
[10:22:31.259]                           restarts <- computeRestarts(cond)
[10:22:31.259]                           for (restart in restarts) {
[10:22:31.259]                             name <- restart$name
[10:22:31.259]                             if (is.null(name)) 
[10:22:31.259]                               next
[10:22:31.259]                             if (!grepl(pattern, name)) 
[10:22:31.259]                               next
[10:22:31.259]                             invokeRestart(restart)
[10:22:31.259]                             muffled <- TRUE
[10:22:31.259]                             break
[10:22:31.259]                           }
[10:22:31.259]                         }
[10:22:31.259]                       }
[10:22:31.259]                       invisible(muffled)
[10:22:31.259]                     }
[10:22:31.259]                     muffleCondition(cond, pattern = "^muffle")
[10:22:31.259]                   }
[10:22:31.259]                 }
[10:22:31.259]             }
[10:22:31.259]         }))
[10:22:31.259]     }, error = function(ex) {
[10:22:31.259]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:31.259]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:31.259]                 ...future.rng), started = ...future.startTime, 
[10:22:31.259]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:31.259]             version = "1.8"), class = "FutureResult")
[10:22:31.259]     }, finally = {
[10:22:31.259]         if (!identical(...future.workdir, getwd())) 
[10:22:31.259]             setwd(...future.workdir)
[10:22:31.259]         {
[10:22:31.259]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:31.259]                 ...future.oldOptions$nwarnings <- NULL
[10:22:31.259]             }
[10:22:31.259]             base::options(...future.oldOptions)
[10:22:31.259]             if (.Platform$OS.type == "windows") {
[10:22:31.259]                 old_names <- names(...future.oldEnvVars)
[10:22:31.259]                 envs <- base::Sys.getenv()
[10:22:31.259]                 names <- names(envs)
[10:22:31.259]                 common <- intersect(names, old_names)
[10:22:31.259]                 added <- setdiff(names, old_names)
[10:22:31.259]                 removed <- setdiff(old_names, names)
[10:22:31.259]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:31.259]                   envs[common]]
[10:22:31.259]                 NAMES <- toupper(changed)
[10:22:31.259]                 args <- list()
[10:22:31.259]                 for (kk in seq_along(NAMES)) {
[10:22:31.259]                   name <- changed[[kk]]
[10:22:31.259]                   NAME <- NAMES[[kk]]
[10:22:31.259]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:31.259]                     next
[10:22:31.259]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:31.259]                 }
[10:22:31.259]                 NAMES <- toupper(added)
[10:22:31.259]                 for (kk in seq_along(NAMES)) {
[10:22:31.259]                   name <- added[[kk]]
[10:22:31.259]                   NAME <- NAMES[[kk]]
[10:22:31.259]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:31.259]                     next
[10:22:31.259]                   args[[name]] <- ""
[10:22:31.259]                 }
[10:22:31.259]                 NAMES <- toupper(removed)
[10:22:31.259]                 for (kk in seq_along(NAMES)) {
[10:22:31.259]                   name <- removed[[kk]]
[10:22:31.259]                   NAME <- NAMES[[kk]]
[10:22:31.259]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:31.259]                     next
[10:22:31.259]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:31.259]                 }
[10:22:31.259]                 if (length(args) > 0) 
[10:22:31.259]                   base::do.call(base::Sys.setenv, args = args)
[10:22:31.259]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:31.259]             }
[10:22:31.259]             else {
[10:22:31.259]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:31.259]             }
[10:22:31.259]             {
[10:22:31.259]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:31.259]                   0L) {
[10:22:31.259]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:31.259]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:31.259]                   base::options(opts)
[10:22:31.259]                 }
[10:22:31.259]                 {
[10:22:31.259]                   {
[10:22:31.259]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:31.259]                     NULL
[10:22:31.259]                   }
[10:22:31.259]                   options(future.plan = NULL)
[10:22:31.259]                   if (is.na(NA_character_)) 
[10:22:31.259]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:31.259]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:31.259]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:31.259]                     .init = FALSE)
[10:22:31.259]                 }
[10:22:31.259]             }
[10:22:31.259]         }
[10:22:31.259]     })
[10:22:31.259]     if (TRUE) {
[10:22:31.259]         base::sink(type = "output", split = FALSE)
[10:22:31.259]         if (TRUE) {
[10:22:31.259]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:31.259]         }
[10:22:31.259]         else {
[10:22:31.259]             ...future.result["stdout"] <- base::list(NULL)
[10:22:31.259]         }
[10:22:31.259]         base::close(...future.stdout)
[10:22:31.259]         ...future.stdout <- NULL
[10:22:31.259]     }
[10:22:31.259]     ...future.result$conditions <- ...future.conditions
[10:22:31.259]     ...future.result$finished <- base::Sys.time()
[10:22:31.259]     ...future.result
[10:22:31.259] }
[10:22:31.263] requestCore(): workers = 2
[10:22:31.266] Poll #1 (0): usedCores() = 2, workers = 2
[10:22:31.277] result() for MulticoreFuture ...
[10:22:31.279] result() for MulticoreFuture ...
[10:22:31.279] result() for MulticoreFuture ... done
[10:22:31.279] result() for MulticoreFuture ... done
[10:22:31.280] result() for MulticoreFuture ...
[10:22:31.280] result() for MulticoreFuture ... done
[10:22:31.283] MulticoreFuture started
[10:22:31.284] - Launch lazy future ... done
[10:22:31.284] run() for ‘MulticoreFuture’ ... done
[10:22:31.284] plan(): Setting new future strategy stack:
[10:22:31.285] getGlobalsAndPackages() ...
[10:22:31.284] List of future strategies:
[10:22:31.284] 1. sequential:
[10:22:31.284]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:31.284]    - tweaked: FALSE
[10:22:31.284]    - call: NULL
[10:22:31.286] Searching for globals...
[10:22:31.286] plan(): nbrOfWorkers() = 1
[10:22:31.287] - globals found: [1] ‘{’
[10:22:31.288] Searching for globals ... DONE
[10:22:31.288] Resolving globals: FALSE
[10:22:31.288] plan(): Setting new future strategy stack:
[10:22:31.288] 
[10:22:31.289] 
[10:22:31.288] List of future strategies:
[10:22:31.288] 1. multicore:
[10:22:31.288]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:31.288]    - tweaked: FALSE
[10:22:31.288]    - call: plan(strategy)
[10:22:31.289] getGlobalsAndPackages() ... DONE
[10:22:31.289] run() for ‘Future’ ...
[10:22:31.290] - state: ‘created’
[10:22:31.290] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:31.292] plan(): nbrOfWorkers() = 2
[10:22:31.293] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:31.293] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:31.293]   - Field: ‘label’
[10:22:31.293]   - Field: ‘local’
[10:22:31.293]   - Field: ‘owner’
[10:22:31.294]   - Field: ‘envir’
[10:22:31.294]   - Field: ‘workers’
[10:22:31.294]   - Field: ‘packages’
[10:22:31.294]   - Field: ‘gc’
[10:22:31.294]   - Field: ‘job’
[10:22:31.294]   - Field: ‘conditions’
[10:22:31.295]   - Field: ‘expr’
[10:22:31.295]   - Field: ‘uuid’
[10:22:31.295]   - Field: ‘seed’
[10:22:31.295]   - Field: ‘version’
[10:22:31.295]   - Field: ‘result’
[10:22:31.295]   - Field: ‘asynchronous’
[10:22:31.296]   - Field: ‘calls’
[10:22:31.296]   - Field: ‘globals’
[10:22:31.296]   - Field: ‘stdout’
[10:22:31.296]   - Field: ‘earlySignal’
[10:22:31.296]   - Field: ‘lazy’
[10:22:31.296]   - Field: ‘state’
[10:22:31.296] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:31.297] - Launch lazy future ...
[10:22:31.297] Packages needed by the future expression (n = 0): <none>
[10:22:31.297] Packages needed by future strategies (n = 0): <none>
[10:22:31.298] {
[10:22:31.298]     {
[10:22:31.298]         {
[10:22:31.298]             ...future.startTime <- base::Sys.time()
[10:22:31.298]             {
[10:22:31.298]                 {
[10:22:31.298]                   {
[10:22:31.298]                     {
[10:22:31.298]                       base::local({
[10:22:31.298]                         has_future <- base::requireNamespace("future", 
[10:22:31.298]                           quietly = TRUE)
[10:22:31.298]                         if (has_future) {
[10:22:31.298]                           ns <- base::getNamespace("future")
[10:22:31.298]                           version <- ns[[".package"]][["version"]]
[10:22:31.298]                           if (is.null(version)) 
[10:22:31.298]                             version <- utils::packageVersion("future")
[10:22:31.298]                         }
[10:22:31.298]                         else {
[10:22:31.298]                           version <- NULL
[10:22:31.298]                         }
[10:22:31.298]                         if (!has_future || version < "1.8.0") {
[10:22:31.298]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:31.298]                             "", base::R.version$version.string), 
[10:22:31.298]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:31.298]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:31.298]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:31.298]                               "release", "version")], collapse = " "), 
[10:22:31.298]                             hostname = base::Sys.info()[["nodename"]])
[10:22:31.298]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:31.298]                             info)
[10:22:31.298]                           info <- base::paste(info, collapse = "; ")
[10:22:31.298]                           if (!has_future) {
[10:22:31.298]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:31.298]                               info)
[10:22:31.298]                           }
[10:22:31.298]                           else {
[10:22:31.298]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:31.298]                               info, version)
[10:22:31.298]                           }
[10:22:31.298]                           base::stop(msg)
[10:22:31.298]                         }
[10:22:31.298]                       })
[10:22:31.298]                     }
[10:22:31.298]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:31.298]                     base::options(mc.cores = 1L)
[10:22:31.298]                   }
[10:22:31.298]                   ...future.strategy.old <- future::plan("list")
[10:22:31.298]                   options(future.plan = NULL)
[10:22:31.298]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:31.298]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:31.298]                 }
[10:22:31.298]                 ...future.workdir <- getwd()
[10:22:31.298]             }
[10:22:31.298]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:31.298]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:31.298]         }
[10:22:31.298]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:31.298]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:31.298]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:31.298]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:31.298]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:31.298]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:31.298]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:31.298]             base::names(...future.oldOptions))
[10:22:31.298]     }
[10:22:31.298]     if (FALSE) {
[10:22:31.298]     }
[10:22:31.298]     else {
[10:22:31.298]         if (TRUE) {
[10:22:31.298]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:31.298]                 open = "w")
[10:22:31.298]         }
[10:22:31.298]         else {
[10:22:31.298]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:31.298]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:31.298]         }
[10:22:31.298]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:31.298]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:31.298]             base::sink(type = "output", split = FALSE)
[10:22:31.298]             base::close(...future.stdout)
[10:22:31.298]         }, add = TRUE)
[10:22:31.298]     }
[10:22:31.298]     ...future.frame <- base::sys.nframe()
[10:22:31.298]     ...future.conditions <- base::list()
[10:22:31.298]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:31.298]     if (FALSE) {
[10:22:31.298]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:31.298]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:31.298]     }
[10:22:31.298]     ...future.result <- base::tryCatch({
[10:22:31.298]         base::withCallingHandlers({
[10:22:31.298]             ...future.value <- base::withVisible(base::local({
[10:22:31.298]                 withCallingHandlers({
[10:22:31.298]                   {
[10:22:31.298]                     2
[10:22:31.298]                   }
[10:22:31.298]                 }, immediateCondition = function(cond) {
[10:22:31.298]                   save_rds <- function (object, pathname, ...) 
[10:22:31.298]                   {
[10:22:31.298]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:31.298]                     if (file_test("-f", pathname_tmp)) {
[10:22:31.298]                       fi_tmp <- file.info(pathname_tmp)
[10:22:31.298]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:31.298]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:31.298]                         fi_tmp[["mtime"]])
[10:22:31.298]                     }
[10:22:31.298]                     tryCatch({
[10:22:31.298]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:31.298]                     }, error = function(ex) {
[10:22:31.298]                       msg <- conditionMessage(ex)
[10:22:31.298]                       fi_tmp <- file.info(pathname_tmp)
[10:22:31.298]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:31.298]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:31.298]                         fi_tmp[["mtime"]], msg)
[10:22:31.298]                       ex$message <- msg
[10:22:31.298]                       stop(ex)
[10:22:31.298]                     })
[10:22:31.298]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:31.298]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:31.298]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:31.298]                       fi_tmp <- file.info(pathname_tmp)
[10:22:31.298]                       fi <- file.info(pathname)
[10:22:31.298]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:31.298]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:31.298]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:31.298]                         fi[["size"]], fi[["mtime"]])
[10:22:31.298]                       stop(msg)
[10:22:31.298]                     }
[10:22:31.298]                     invisible(pathname)
[10:22:31.298]                   }
[10:22:31.298]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:31.298]                     rootPath = tempdir()) 
[10:22:31.298]                   {
[10:22:31.298]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:31.298]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:31.298]                       tmpdir = path, fileext = ".rds")
[10:22:31.298]                     save_rds(obj, file)
[10:22:31.298]                   }
[10:22:31.298]                   saveImmediateCondition(cond, path = "/tmp/RtmpzsJv4f/.future/immediateConditions")
[10:22:31.298]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:31.298]                   {
[10:22:31.298]                     inherits <- base::inherits
[10:22:31.298]                     invokeRestart <- base::invokeRestart
[10:22:31.298]                     is.null <- base::is.null
[10:22:31.298]                     muffled <- FALSE
[10:22:31.298]                     if (inherits(cond, "message")) {
[10:22:31.298]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:31.298]                       if (muffled) 
[10:22:31.298]                         invokeRestart("muffleMessage")
[10:22:31.298]                     }
[10:22:31.298]                     else if (inherits(cond, "warning")) {
[10:22:31.298]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:31.298]                       if (muffled) 
[10:22:31.298]                         invokeRestart("muffleWarning")
[10:22:31.298]                     }
[10:22:31.298]                     else if (inherits(cond, "condition")) {
[10:22:31.298]                       if (!is.null(pattern)) {
[10:22:31.298]                         computeRestarts <- base::computeRestarts
[10:22:31.298]                         grepl <- base::grepl
[10:22:31.298]                         restarts <- computeRestarts(cond)
[10:22:31.298]                         for (restart in restarts) {
[10:22:31.298]                           name <- restart$name
[10:22:31.298]                           if (is.null(name)) 
[10:22:31.298]                             next
[10:22:31.298]                           if (!grepl(pattern, name)) 
[10:22:31.298]                             next
[10:22:31.298]                           invokeRestart(restart)
[10:22:31.298]                           muffled <- TRUE
[10:22:31.298]                           break
[10:22:31.298]                         }
[10:22:31.298]                       }
[10:22:31.298]                     }
[10:22:31.298]                     invisible(muffled)
[10:22:31.298]                   }
[10:22:31.298]                   muffleCondition(cond)
[10:22:31.298]                 })
[10:22:31.298]             }))
[10:22:31.298]             future::FutureResult(value = ...future.value$value, 
[10:22:31.298]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:31.298]                   ...future.rng), globalenv = if (FALSE) 
[10:22:31.298]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:31.298]                     ...future.globalenv.names))
[10:22:31.298]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:31.298]         }, condition = base::local({
[10:22:31.298]             c <- base::c
[10:22:31.298]             inherits <- base::inherits
[10:22:31.298]             invokeRestart <- base::invokeRestart
[10:22:31.298]             length <- base::length
[10:22:31.298]             list <- base::list
[10:22:31.298]             seq.int <- base::seq.int
[10:22:31.298]             signalCondition <- base::signalCondition
[10:22:31.298]             sys.calls <- base::sys.calls
[10:22:31.298]             `[[` <- base::`[[`
[10:22:31.298]             `+` <- base::`+`
[10:22:31.298]             `<<-` <- base::`<<-`
[10:22:31.298]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:31.298]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:31.298]                   3L)]
[10:22:31.298]             }
[10:22:31.298]             function(cond) {
[10:22:31.298]                 is_error <- inherits(cond, "error")
[10:22:31.298]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:31.298]                   NULL)
[10:22:31.298]                 if (is_error) {
[10:22:31.298]                   sessionInformation <- function() {
[10:22:31.298]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:31.298]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:31.298]                       search = base::search(), system = base::Sys.info())
[10:22:31.298]                   }
[10:22:31.298]                   ...future.conditions[[length(...future.conditions) + 
[10:22:31.298]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:31.298]                     cond$call), session = sessionInformation(), 
[10:22:31.298]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:31.298]                   signalCondition(cond)
[10:22:31.298]                 }
[10:22:31.298]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:31.298]                 "immediateCondition"))) {
[10:22:31.298]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:31.298]                   ...future.conditions[[length(...future.conditions) + 
[10:22:31.298]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:31.298]                   if (TRUE && !signal) {
[10:22:31.298]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:31.298]                     {
[10:22:31.298]                       inherits <- base::inherits
[10:22:31.298]                       invokeRestart <- base::invokeRestart
[10:22:31.298]                       is.null <- base::is.null
[10:22:31.298]                       muffled <- FALSE
[10:22:31.298]                       if (inherits(cond, "message")) {
[10:22:31.298]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:31.298]                         if (muffled) 
[10:22:31.298]                           invokeRestart("muffleMessage")
[10:22:31.298]                       }
[10:22:31.298]                       else if (inherits(cond, "warning")) {
[10:22:31.298]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:31.298]                         if (muffled) 
[10:22:31.298]                           invokeRestart("muffleWarning")
[10:22:31.298]                       }
[10:22:31.298]                       else if (inherits(cond, "condition")) {
[10:22:31.298]                         if (!is.null(pattern)) {
[10:22:31.298]                           computeRestarts <- base::computeRestarts
[10:22:31.298]                           grepl <- base::grepl
[10:22:31.298]                           restarts <- computeRestarts(cond)
[10:22:31.298]                           for (restart in restarts) {
[10:22:31.298]                             name <- restart$name
[10:22:31.298]                             if (is.null(name)) 
[10:22:31.298]                               next
[10:22:31.298]                             if (!grepl(pattern, name)) 
[10:22:31.298]                               next
[10:22:31.298]                             invokeRestart(restart)
[10:22:31.298]                             muffled <- TRUE
[10:22:31.298]                             break
[10:22:31.298]                           }
[10:22:31.298]                         }
[10:22:31.298]                       }
[10:22:31.298]                       invisible(muffled)
[10:22:31.298]                     }
[10:22:31.298]                     muffleCondition(cond, pattern = "^muffle")
[10:22:31.298]                   }
[10:22:31.298]                 }
[10:22:31.298]                 else {
[10:22:31.298]                   if (TRUE) {
[10:22:31.298]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:31.298]                     {
[10:22:31.298]                       inherits <- base::inherits
[10:22:31.298]                       invokeRestart <- base::invokeRestart
[10:22:31.298]                       is.null <- base::is.null
[10:22:31.298]                       muffled <- FALSE
[10:22:31.298]                       if (inherits(cond, "message")) {
[10:22:31.298]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:31.298]                         if (muffled) 
[10:22:31.298]                           invokeRestart("muffleMessage")
[10:22:31.298]                       }
[10:22:31.298]                       else if (inherits(cond, "warning")) {
[10:22:31.298]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:31.298]                         if (muffled) 
[10:22:31.298]                           invokeRestart("muffleWarning")
[10:22:31.298]                       }
[10:22:31.298]                       else if (inherits(cond, "condition")) {
[10:22:31.298]                         if (!is.null(pattern)) {
[10:22:31.298]                           computeRestarts <- base::computeRestarts
[10:22:31.298]                           grepl <- base::grepl
[10:22:31.298]                           restarts <- computeRestarts(cond)
[10:22:31.298]                           for (restart in restarts) {
[10:22:31.298]                             name <- restart$name
[10:22:31.298]                             if (is.null(name)) 
[10:22:31.298]                               next
[10:22:31.298]                             if (!grepl(pattern, name)) 
[10:22:31.298]                               next
[10:22:31.298]                             invokeRestart(restart)
[10:22:31.298]                             muffled <- TRUE
[10:22:31.298]                             break
[10:22:31.298]                           }
[10:22:31.298]                         }
[10:22:31.298]                       }
[10:22:31.298]                       invisible(muffled)
[10:22:31.298]                     }
[10:22:31.298]                     muffleCondition(cond, pattern = "^muffle")
[10:22:31.298]                   }
[10:22:31.298]                 }
[10:22:31.298]             }
[10:22:31.298]         }))
[10:22:31.298]     }, error = function(ex) {
[10:22:31.298]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:31.298]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:31.298]                 ...future.rng), started = ...future.startTime, 
[10:22:31.298]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:31.298]             version = "1.8"), class = "FutureResult")
[10:22:31.298]     }, finally = {
[10:22:31.298]         if (!identical(...future.workdir, getwd())) 
[10:22:31.298]             setwd(...future.workdir)
[10:22:31.298]         {
[10:22:31.298]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:31.298]                 ...future.oldOptions$nwarnings <- NULL
[10:22:31.298]             }
[10:22:31.298]             base::options(...future.oldOptions)
[10:22:31.298]             if (.Platform$OS.type == "windows") {
[10:22:31.298]                 old_names <- names(...future.oldEnvVars)
[10:22:31.298]                 envs <- base::Sys.getenv()
[10:22:31.298]                 names <- names(envs)
[10:22:31.298]                 common <- intersect(names, old_names)
[10:22:31.298]                 added <- setdiff(names, old_names)
[10:22:31.298]                 removed <- setdiff(old_names, names)
[10:22:31.298]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:31.298]                   envs[common]]
[10:22:31.298]                 NAMES <- toupper(changed)
[10:22:31.298]                 args <- list()
[10:22:31.298]                 for (kk in seq_along(NAMES)) {
[10:22:31.298]                   name <- changed[[kk]]
[10:22:31.298]                   NAME <- NAMES[[kk]]
[10:22:31.298]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:31.298]                     next
[10:22:31.298]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:31.298]                 }
[10:22:31.298]                 NAMES <- toupper(added)
[10:22:31.298]                 for (kk in seq_along(NAMES)) {
[10:22:31.298]                   name <- added[[kk]]
[10:22:31.298]                   NAME <- NAMES[[kk]]
[10:22:31.298]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:31.298]                     next
[10:22:31.298]                   args[[name]] <- ""
[10:22:31.298]                 }
[10:22:31.298]                 NAMES <- toupper(removed)
[10:22:31.298]                 for (kk in seq_along(NAMES)) {
[10:22:31.298]                   name <- removed[[kk]]
[10:22:31.298]                   NAME <- NAMES[[kk]]
[10:22:31.298]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:31.298]                     next
[10:22:31.298]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:31.298]                 }
[10:22:31.298]                 if (length(args) > 0) 
[10:22:31.298]                   base::do.call(base::Sys.setenv, args = args)
[10:22:31.298]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:31.298]             }
[10:22:31.298]             else {
[10:22:31.298]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:31.298]             }
[10:22:31.298]             {
[10:22:31.298]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:31.298]                   0L) {
[10:22:31.298]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:31.298]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:31.298]                   base::options(opts)
[10:22:31.298]                 }
[10:22:31.298]                 {
[10:22:31.298]                   {
[10:22:31.298]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:31.298]                     NULL
[10:22:31.298]                   }
[10:22:31.298]                   options(future.plan = NULL)
[10:22:31.298]                   if (is.na(NA_character_)) 
[10:22:31.298]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:31.298]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:31.298]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:31.298]                     .init = FALSE)
[10:22:31.298]                 }
[10:22:31.298]             }
[10:22:31.298]         }
[10:22:31.298]     })
[10:22:31.298]     if (TRUE) {
[10:22:31.298]         base::sink(type = "output", split = FALSE)
[10:22:31.298]         if (TRUE) {
[10:22:31.298]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:31.298]         }
[10:22:31.298]         else {
[10:22:31.298]             ...future.result["stdout"] <- base::list(NULL)
[10:22:31.298]         }
[10:22:31.298]         base::close(...future.stdout)
[10:22:31.298]         ...future.stdout <- NULL
[10:22:31.298]     }
[10:22:31.298]     ...future.result$conditions <- ...future.conditions
[10:22:31.298]     ...future.result$finished <- base::Sys.time()
[10:22:31.298]     ...future.result
[10:22:31.298] }
[10:22:31.301] requestCore(): workers = 2
[10:22:31.302] Poll #1 (0): usedCores() = 2, workers = 2
[10:22:31.313] result() for MulticoreFuture ...
[10:22:31.313] result() for MulticoreFuture ...
[10:22:31.314] result() for MulticoreFuture ... done
[10:22:31.314] result() for MulticoreFuture ... done
[10:22:31.314] result() for MulticoreFuture ...
[10:22:31.314] result() for MulticoreFuture ... done
[10:22:31.316] MulticoreFuture started
[10:22:31.317] - Launch lazy future ... done
[10:22:31.317] run() for ‘MulticoreFuture’ ... done
[10:22:31.318] plan(): Setting new future strategy stack:
[10:22:31.318] List of future strategies:
[10:22:31.318] 1. sequential:
[10:22:31.318]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:31.318]    - tweaked: FALSE
[10:22:31.318]    - call: NULL
[10:22:31.319] resolve() on environment ...
[10:22:31.320] plan(): nbrOfWorkers() = 1
[10:22:31.320]  recursive: 0
[10:22:31.321]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[10:22:31.321] Future #1
[10:22:31.322]  length: 2 (resolved future 1)
[10:22:31.322] plan(): Setting new future strategy stack:
[10:22:31.323] List of future strategies:
[10:22:31.323] 1. multicore:
[10:22:31.323]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:31.323]    - tweaked: FALSE
[10:22:31.323]    - call: plan(strategy)
[10:22:31.326] plan(): nbrOfWorkers() = 2
[10:22:31.326] Future #2
[10:22:31.326]  length: 1 (resolved future 2)
[10:22:31.327]  length: 0 (resolved future 3)
[10:22:31.327] resolve() on environment ... DONE
[10:22:31.327] getGlobalsAndPackages() ...
[10:22:31.328] Searching for globals...
[10:22:31.329] - globals found: [1] ‘{’
[10:22:31.329] Searching for globals ... DONE
[10:22:31.329] Resolving globals: FALSE
[10:22:31.330] 
[10:22:31.330] 
[10:22:31.330] getGlobalsAndPackages() ... DONE
[10:22:31.330] run() for ‘Future’ ...
[10:22:31.331] - state: ‘created’
[10:22:31.331] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:31.333] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:31.333] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:31.334]   - Field: ‘label’
[10:22:31.334]   - Field: ‘local’
[10:22:31.334]   - Field: ‘owner’
[10:22:31.334]   - Field: ‘envir’
[10:22:31.334]   - Field: ‘workers’
[10:22:31.334]   - Field: ‘packages’
[10:22:31.334]   - Field: ‘gc’
[10:22:31.334]   - Field: ‘job’
[10:22:31.335]   - Field: ‘conditions’
[10:22:31.335]   - Field: ‘expr’
[10:22:31.335]   - Field: ‘uuid’
[10:22:31.335]   - Field: ‘seed’
[10:22:31.335]   - Field: ‘version’
[10:22:31.335]   - Field: ‘result’
[10:22:31.335]   - Field: ‘asynchronous’
[10:22:31.336]   - Field: ‘calls’
[10:22:31.336]   - Field: ‘globals’
[10:22:31.336]   - Field: ‘stdout’
[10:22:31.336]   - Field: ‘earlySignal’
[10:22:31.336]   - Field: ‘lazy’
[10:22:31.336]   - Field: ‘state’
[10:22:31.336] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:31.337] - Launch lazy future ...
[10:22:31.337] Packages needed by the future expression (n = 0): <none>
[10:22:31.337] Packages needed by future strategies (n = 0): <none>
[10:22:31.338] {
[10:22:31.338]     {
[10:22:31.338]         {
[10:22:31.338]             ...future.startTime <- base::Sys.time()
[10:22:31.338]             {
[10:22:31.338]                 {
[10:22:31.338]                   {
[10:22:31.338]                     {
[10:22:31.338]                       base::local({
[10:22:31.338]                         has_future <- base::requireNamespace("future", 
[10:22:31.338]                           quietly = TRUE)
[10:22:31.338]                         if (has_future) {
[10:22:31.338]                           ns <- base::getNamespace("future")
[10:22:31.338]                           version <- ns[[".package"]][["version"]]
[10:22:31.338]                           if (is.null(version)) 
[10:22:31.338]                             version <- utils::packageVersion("future")
[10:22:31.338]                         }
[10:22:31.338]                         else {
[10:22:31.338]                           version <- NULL
[10:22:31.338]                         }
[10:22:31.338]                         if (!has_future || version < "1.8.0") {
[10:22:31.338]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:31.338]                             "", base::R.version$version.string), 
[10:22:31.338]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:31.338]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:31.338]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:31.338]                               "release", "version")], collapse = " "), 
[10:22:31.338]                             hostname = base::Sys.info()[["nodename"]])
[10:22:31.338]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:31.338]                             info)
[10:22:31.338]                           info <- base::paste(info, collapse = "; ")
[10:22:31.338]                           if (!has_future) {
[10:22:31.338]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:31.338]                               info)
[10:22:31.338]                           }
[10:22:31.338]                           else {
[10:22:31.338]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:31.338]                               info, version)
[10:22:31.338]                           }
[10:22:31.338]                           base::stop(msg)
[10:22:31.338]                         }
[10:22:31.338]                       })
[10:22:31.338]                     }
[10:22:31.338]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:31.338]                     base::options(mc.cores = 1L)
[10:22:31.338]                   }
[10:22:31.338]                   ...future.strategy.old <- future::plan("list")
[10:22:31.338]                   options(future.plan = NULL)
[10:22:31.338]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:31.338]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:31.338]                 }
[10:22:31.338]                 ...future.workdir <- getwd()
[10:22:31.338]             }
[10:22:31.338]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:31.338]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:31.338]         }
[10:22:31.338]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:31.338]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:31.338]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:31.338]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:31.338]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:31.338]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:31.338]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:31.338]             base::names(...future.oldOptions))
[10:22:31.338]     }
[10:22:31.338]     if (FALSE) {
[10:22:31.338]     }
[10:22:31.338]     else {
[10:22:31.338]         if (TRUE) {
[10:22:31.338]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:31.338]                 open = "w")
[10:22:31.338]         }
[10:22:31.338]         else {
[10:22:31.338]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:31.338]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:31.338]         }
[10:22:31.338]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:31.338]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:31.338]             base::sink(type = "output", split = FALSE)
[10:22:31.338]             base::close(...future.stdout)
[10:22:31.338]         }, add = TRUE)
[10:22:31.338]     }
[10:22:31.338]     ...future.frame <- base::sys.nframe()
[10:22:31.338]     ...future.conditions <- base::list()
[10:22:31.338]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:31.338]     if (FALSE) {
[10:22:31.338]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:31.338]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:31.338]     }
[10:22:31.338]     ...future.result <- base::tryCatch({
[10:22:31.338]         base::withCallingHandlers({
[10:22:31.338]             ...future.value <- base::withVisible(base::local({
[10:22:31.338]                 withCallingHandlers({
[10:22:31.338]                   {
[10:22:31.338]                     1
[10:22:31.338]                   }
[10:22:31.338]                 }, immediateCondition = function(cond) {
[10:22:31.338]                   save_rds <- function (object, pathname, ...) 
[10:22:31.338]                   {
[10:22:31.338]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:31.338]                     if (file_test("-f", pathname_tmp)) {
[10:22:31.338]                       fi_tmp <- file.info(pathname_tmp)
[10:22:31.338]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:31.338]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:31.338]                         fi_tmp[["mtime"]])
[10:22:31.338]                     }
[10:22:31.338]                     tryCatch({
[10:22:31.338]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:31.338]                     }, error = function(ex) {
[10:22:31.338]                       msg <- conditionMessage(ex)
[10:22:31.338]                       fi_tmp <- file.info(pathname_tmp)
[10:22:31.338]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:31.338]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:31.338]                         fi_tmp[["mtime"]], msg)
[10:22:31.338]                       ex$message <- msg
[10:22:31.338]                       stop(ex)
[10:22:31.338]                     })
[10:22:31.338]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:31.338]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:31.338]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:31.338]                       fi_tmp <- file.info(pathname_tmp)
[10:22:31.338]                       fi <- file.info(pathname)
[10:22:31.338]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:31.338]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:31.338]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:31.338]                         fi[["size"]], fi[["mtime"]])
[10:22:31.338]                       stop(msg)
[10:22:31.338]                     }
[10:22:31.338]                     invisible(pathname)
[10:22:31.338]                   }
[10:22:31.338]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:31.338]                     rootPath = tempdir()) 
[10:22:31.338]                   {
[10:22:31.338]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:31.338]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:31.338]                       tmpdir = path, fileext = ".rds")
[10:22:31.338]                     save_rds(obj, file)
[10:22:31.338]                   }
[10:22:31.338]                   saveImmediateCondition(cond, path = "/tmp/RtmpzsJv4f/.future/immediateConditions")
[10:22:31.338]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:31.338]                   {
[10:22:31.338]                     inherits <- base::inherits
[10:22:31.338]                     invokeRestart <- base::invokeRestart
[10:22:31.338]                     is.null <- base::is.null
[10:22:31.338]                     muffled <- FALSE
[10:22:31.338]                     if (inherits(cond, "message")) {
[10:22:31.338]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:31.338]                       if (muffled) 
[10:22:31.338]                         invokeRestart("muffleMessage")
[10:22:31.338]                     }
[10:22:31.338]                     else if (inherits(cond, "warning")) {
[10:22:31.338]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:31.338]                       if (muffled) 
[10:22:31.338]                         invokeRestart("muffleWarning")
[10:22:31.338]                     }
[10:22:31.338]                     else if (inherits(cond, "condition")) {
[10:22:31.338]                       if (!is.null(pattern)) {
[10:22:31.338]                         computeRestarts <- base::computeRestarts
[10:22:31.338]                         grepl <- base::grepl
[10:22:31.338]                         restarts <- computeRestarts(cond)
[10:22:31.338]                         for (restart in restarts) {
[10:22:31.338]                           name <- restart$name
[10:22:31.338]                           if (is.null(name)) 
[10:22:31.338]                             next
[10:22:31.338]                           if (!grepl(pattern, name)) 
[10:22:31.338]                             next
[10:22:31.338]                           invokeRestart(restart)
[10:22:31.338]                           muffled <- TRUE
[10:22:31.338]                           break
[10:22:31.338]                         }
[10:22:31.338]                       }
[10:22:31.338]                     }
[10:22:31.338]                     invisible(muffled)
[10:22:31.338]                   }
[10:22:31.338]                   muffleCondition(cond)
[10:22:31.338]                 })
[10:22:31.338]             }))
[10:22:31.338]             future::FutureResult(value = ...future.value$value, 
[10:22:31.338]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:31.338]                   ...future.rng), globalenv = if (FALSE) 
[10:22:31.338]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:31.338]                     ...future.globalenv.names))
[10:22:31.338]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:31.338]         }, condition = base::local({
[10:22:31.338]             c <- base::c
[10:22:31.338]             inherits <- base::inherits
[10:22:31.338]             invokeRestart <- base::invokeRestart
[10:22:31.338]             length <- base::length
[10:22:31.338]             list <- base::list
[10:22:31.338]             seq.int <- base::seq.int
[10:22:31.338]             signalCondition <- base::signalCondition
[10:22:31.338]             sys.calls <- base::sys.calls
[10:22:31.338]             `[[` <- base::`[[`
[10:22:31.338]             `+` <- base::`+`
[10:22:31.338]             `<<-` <- base::`<<-`
[10:22:31.338]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:31.338]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:31.338]                   3L)]
[10:22:31.338]             }
[10:22:31.338]             function(cond) {
[10:22:31.338]                 is_error <- inherits(cond, "error")
[10:22:31.338]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:31.338]                   NULL)
[10:22:31.338]                 if (is_error) {
[10:22:31.338]                   sessionInformation <- function() {
[10:22:31.338]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:31.338]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:31.338]                       search = base::search(), system = base::Sys.info())
[10:22:31.338]                   }
[10:22:31.338]                   ...future.conditions[[length(...future.conditions) + 
[10:22:31.338]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:31.338]                     cond$call), session = sessionInformation(), 
[10:22:31.338]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:31.338]                   signalCondition(cond)
[10:22:31.338]                 }
[10:22:31.338]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:31.338]                 "immediateCondition"))) {
[10:22:31.338]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:31.338]                   ...future.conditions[[length(...future.conditions) + 
[10:22:31.338]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:31.338]                   if (TRUE && !signal) {
[10:22:31.338]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:31.338]                     {
[10:22:31.338]                       inherits <- base::inherits
[10:22:31.338]                       invokeRestart <- base::invokeRestart
[10:22:31.338]                       is.null <- base::is.null
[10:22:31.338]                       muffled <- FALSE
[10:22:31.338]                       if (inherits(cond, "message")) {
[10:22:31.338]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:31.338]                         if (muffled) 
[10:22:31.338]                           invokeRestart("muffleMessage")
[10:22:31.338]                       }
[10:22:31.338]                       else if (inherits(cond, "warning")) {
[10:22:31.338]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:31.338]                         if (muffled) 
[10:22:31.338]                           invokeRestart("muffleWarning")
[10:22:31.338]                       }
[10:22:31.338]                       else if (inherits(cond, "condition")) {
[10:22:31.338]                         if (!is.null(pattern)) {
[10:22:31.338]                           computeRestarts <- base::computeRestarts
[10:22:31.338]                           grepl <- base::grepl
[10:22:31.338]                           restarts <- computeRestarts(cond)
[10:22:31.338]                           for (restart in restarts) {
[10:22:31.338]                             name <- restart$name
[10:22:31.338]                             if (is.null(name)) 
[10:22:31.338]                               next
[10:22:31.338]                             if (!grepl(pattern, name)) 
[10:22:31.338]                               next
[10:22:31.338]                             invokeRestart(restart)
[10:22:31.338]                             muffled <- TRUE
[10:22:31.338]                             break
[10:22:31.338]                           }
[10:22:31.338]                         }
[10:22:31.338]                       }
[10:22:31.338]                       invisible(muffled)
[10:22:31.338]                     }
[10:22:31.338]                     muffleCondition(cond, pattern = "^muffle")
[10:22:31.338]                   }
[10:22:31.338]                 }
[10:22:31.338]                 else {
[10:22:31.338]                   if (TRUE) {
[10:22:31.338]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:31.338]                     {
[10:22:31.338]                       inherits <- base::inherits
[10:22:31.338]                       invokeRestart <- base::invokeRestart
[10:22:31.338]                       is.null <- base::is.null
[10:22:31.338]                       muffled <- FALSE
[10:22:31.338]                       if (inherits(cond, "message")) {
[10:22:31.338]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:31.338]                         if (muffled) 
[10:22:31.338]                           invokeRestart("muffleMessage")
[10:22:31.338]                       }
[10:22:31.338]                       else if (inherits(cond, "warning")) {
[10:22:31.338]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:31.338]                         if (muffled) 
[10:22:31.338]                           invokeRestart("muffleWarning")
[10:22:31.338]                       }
[10:22:31.338]                       else if (inherits(cond, "condition")) {
[10:22:31.338]                         if (!is.null(pattern)) {
[10:22:31.338]                           computeRestarts <- base::computeRestarts
[10:22:31.338]                           grepl <- base::grepl
[10:22:31.338]                           restarts <- computeRestarts(cond)
[10:22:31.338]                           for (restart in restarts) {
[10:22:31.338]                             name <- restart$name
[10:22:31.338]                             if (is.null(name)) 
[10:22:31.338]                               next
[10:22:31.338]                             if (!grepl(pattern, name)) 
[10:22:31.338]                               next
[10:22:31.338]                             invokeRestart(restart)
[10:22:31.338]                             muffled <- TRUE
[10:22:31.338]                             break
[10:22:31.338]                           }
[10:22:31.338]                         }
[10:22:31.338]                       }
[10:22:31.338]                       invisible(muffled)
[10:22:31.338]                     }
[10:22:31.338]                     muffleCondition(cond, pattern = "^muffle")
[10:22:31.338]                   }
[10:22:31.338]                 }
[10:22:31.338]             }
[10:22:31.338]         }))
[10:22:31.338]     }, error = function(ex) {
[10:22:31.338]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:31.338]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:31.338]                 ...future.rng), started = ...future.startTime, 
[10:22:31.338]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:31.338]             version = "1.8"), class = "FutureResult")
[10:22:31.338]     }, finally = {
[10:22:31.338]         if (!identical(...future.workdir, getwd())) 
[10:22:31.338]             setwd(...future.workdir)
[10:22:31.338]         {
[10:22:31.338]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:31.338]                 ...future.oldOptions$nwarnings <- NULL
[10:22:31.338]             }
[10:22:31.338]             base::options(...future.oldOptions)
[10:22:31.338]             if (.Platform$OS.type == "windows") {
[10:22:31.338]                 old_names <- names(...future.oldEnvVars)
[10:22:31.338]                 envs <- base::Sys.getenv()
[10:22:31.338]                 names <- names(envs)
[10:22:31.338]                 common <- intersect(names, old_names)
[10:22:31.338]                 added <- setdiff(names, old_names)
[10:22:31.338]                 removed <- setdiff(old_names, names)
[10:22:31.338]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:31.338]                   envs[common]]
[10:22:31.338]                 NAMES <- toupper(changed)
[10:22:31.338]                 args <- list()
[10:22:31.338]                 for (kk in seq_along(NAMES)) {
[10:22:31.338]                   name <- changed[[kk]]
[10:22:31.338]                   NAME <- NAMES[[kk]]
[10:22:31.338]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:31.338]                     next
[10:22:31.338]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:31.338]                 }
[10:22:31.338]                 NAMES <- toupper(added)
[10:22:31.338]                 for (kk in seq_along(NAMES)) {
[10:22:31.338]                   name <- added[[kk]]
[10:22:31.338]                   NAME <- NAMES[[kk]]
[10:22:31.338]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:31.338]                     next
[10:22:31.338]                   args[[name]] <- ""
[10:22:31.338]                 }
[10:22:31.338]                 NAMES <- toupper(removed)
[10:22:31.338]                 for (kk in seq_along(NAMES)) {
[10:22:31.338]                   name <- removed[[kk]]
[10:22:31.338]                   NAME <- NAMES[[kk]]
[10:22:31.338]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:31.338]                     next
[10:22:31.338]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:31.338]                 }
[10:22:31.338]                 if (length(args) > 0) 
[10:22:31.338]                   base::do.call(base::Sys.setenv, args = args)
[10:22:31.338]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:31.338]             }
[10:22:31.338]             else {
[10:22:31.338]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:31.338]             }
[10:22:31.338]             {
[10:22:31.338]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:31.338]                   0L) {
[10:22:31.338]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:31.338]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:31.338]                   base::options(opts)
[10:22:31.338]                 }
[10:22:31.338]                 {
[10:22:31.338]                   {
[10:22:31.338]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:31.338]                     NULL
[10:22:31.338]                   }
[10:22:31.338]                   options(future.plan = NULL)
[10:22:31.338]                   if (is.na(NA_character_)) 
[10:22:31.338]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:31.338]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:31.338]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:31.338]                     .init = FALSE)
[10:22:31.338]                 }
[10:22:31.338]             }
[10:22:31.338]         }
[10:22:31.338]     })
[10:22:31.338]     if (TRUE) {
[10:22:31.338]         base::sink(type = "output", split = FALSE)
[10:22:31.338]         if (TRUE) {
[10:22:31.338]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:31.338]         }
[10:22:31.338]         else {
[10:22:31.338]             ...future.result["stdout"] <- base::list(NULL)
[10:22:31.338]         }
[10:22:31.338]         base::close(...future.stdout)
[10:22:31.338]         ...future.stdout <- NULL
[10:22:31.338]     }
[10:22:31.338]     ...future.result$conditions <- ...future.conditions
[10:22:31.338]     ...future.result$finished <- base::Sys.time()
[10:22:31.338]     ...future.result
[10:22:31.338] }
[10:22:31.341] requestCore(): workers = 2
[10:22:31.342] Poll #1 (0): usedCores() = 2, workers = 2
[10:22:31.352] result() for MulticoreFuture ...
[10:22:31.353] result() for MulticoreFuture ...
[10:22:31.353] result() for MulticoreFuture ... done
[10:22:31.353] result() for MulticoreFuture ... done
[10:22:31.354] result() for MulticoreFuture ...
[10:22:31.354] result() for MulticoreFuture ... done
[10:22:31.356] MulticoreFuture started
[10:22:31.356] - Launch lazy future ... done
[10:22:31.357] run() for ‘MulticoreFuture’ ... done
[10:22:31.357] plan(): Setting new future strategy stack:
[10:22:31.358] getGlobalsAndPackages() ...
[10:22:31.358] Searching for globals...
[10:22:31.357] List of future strategies:
[10:22:31.357] 1. sequential:
[10:22:31.357]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:31.357]    - tweaked: FALSE
[10:22:31.357]    - call: NULL
[10:22:31.359] plan(): nbrOfWorkers() = 1
[10:22:31.360] - globals found: [1] ‘{’
[10:22:31.360] Searching for globals ... DONE
[10:22:31.360] Resolving globals: FALSE
[10:22:31.361] 
[10:22:31.361] 
[10:22:31.362] getGlobalsAndPackages() ... DONE
[10:22:31.362] plan(): Setting new future strategy stack:
[10:22:31.362] run() for ‘Future’ ...
[10:22:31.362] List of future strategies:
[10:22:31.362] 1. multicore:
[10:22:31.362]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:31.362]    - tweaked: FALSE
[10:22:31.362]    - call: plan(strategy)
[10:22:31.363] - state: ‘created’
[10:22:31.369] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:31.370] plan(): nbrOfWorkers() = 2
[10:22:31.374] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:31.374] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:31.374]   - Field: ‘label’
[10:22:31.375]   - Field: ‘local’
[10:22:31.375]   - Field: ‘owner’
[10:22:31.375]   - Field: ‘envir’
[10:22:31.375]   - Field: ‘workers’
[10:22:31.375]   - Field: ‘packages’
[10:22:31.376]   - Field: ‘gc’
[10:22:31.376]   - Field: ‘job’
[10:22:31.376]   - Field: ‘conditions’
[10:22:31.376]   - Field: ‘expr’
[10:22:31.376]   - Field: ‘uuid’
[10:22:31.376]   - Field: ‘seed’
[10:22:31.377]   - Field: ‘version’
[10:22:31.377]   - Field: ‘result’
[10:22:31.377]   - Field: ‘asynchronous’
[10:22:31.377]   - Field: ‘calls’
[10:22:31.377]   - Field: ‘globals’
[10:22:31.377]   - Field: ‘stdout’
[10:22:31.378]   - Field: ‘earlySignal’
[10:22:31.378]   - Field: ‘lazy’
[10:22:31.378]   - Field: ‘state’
[10:22:31.378] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:31.378] - Launch lazy future ...
[10:22:31.379] Packages needed by the future expression (n = 0): <none>
[10:22:31.379] Packages needed by future strategies (n = 0): <none>
[10:22:31.380] {
[10:22:31.380]     {
[10:22:31.380]         {
[10:22:31.380]             ...future.startTime <- base::Sys.time()
[10:22:31.380]             {
[10:22:31.380]                 {
[10:22:31.380]                   {
[10:22:31.380]                     {
[10:22:31.380]                       base::local({
[10:22:31.380]                         has_future <- base::requireNamespace("future", 
[10:22:31.380]                           quietly = TRUE)
[10:22:31.380]                         if (has_future) {
[10:22:31.380]                           ns <- base::getNamespace("future")
[10:22:31.380]                           version <- ns[[".package"]][["version"]]
[10:22:31.380]                           if (is.null(version)) 
[10:22:31.380]                             version <- utils::packageVersion("future")
[10:22:31.380]                         }
[10:22:31.380]                         else {
[10:22:31.380]                           version <- NULL
[10:22:31.380]                         }
[10:22:31.380]                         if (!has_future || version < "1.8.0") {
[10:22:31.380]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:31.380]                             "", base::R.version$version.string), 
[10:22:31.380]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:31.380]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:31.380]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:31.380]                               "release", "version")], collapse = " "), 
[10:22:31.380]                             hostname = base::Sys.info()[["nodename"]])
[10:22:31.380]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:31.380]                             info)
[10:22:31.380]                           info <- base::paste(info, collapse = "; ")
[10:22:31.380]                           if (!has_future) {
[10:22:31.380]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:31.380]                               info)
[10:22:31.380]                           }
[10:22:31.380]                           else {
[10:22:31.380]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:31.380]                               info, version)
[10:22:31.380]                           }
[10:22:31.380]                           base::stop(msg)
[10:22:31.380]                         }
[10:22:31.380]                       })
[10:22:31.380]                     }
[10:22:31.380]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:31.380]                     base::options(mc.cores = 1L)
[10:22:31.380]                   }
[10:22:31.380]                   ...future.strategy.old <- future::plan("list")
[10:22:31.380]                   options(future.plan = NULL)
[10:22:31.380]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:31.380]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:31.380]                 }
[10:22:31.380]                 ...future.workdir <- getwd()
[10:22:31.380]             }
[10:22:31.380]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:31.380]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:31.380]         }
[10:22:31.380]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:31.380]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:31.380]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:31.380]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:31.380]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:31.380]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:31.380]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:31.380]             base::names(...future.oldOptions))
[10:22:31.380]     }
[10:22:31.380]     if (FALSE) {
[10:22:31.380]     }
[10:22:31.380]     else {
[10:22:31.380]         if (TRUE) {
[10:22:31.380]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:31.380]                 open = "w")
[10:22:31.380]         }
[10:22:31.380]         else {
[10:22:31.380]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:31.380]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:31.380]         }
[10:22:31.380]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:31.380]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:31.380]             base::sink(type = "output", split = FALSE)
[10:22:31.380]             base::close(...future.stdout)
[10:22:31.380]         }, add = TRUE)
[10:22:31.380]     }
[10:22:31.380]     ...future.frame <- base::sys.nframe()
[10:22:31.380]     ...future.conditions <- base::list()
[10:22:31.380]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:31.380]     if (FALSE) {
[10:22:31.380]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:31.380]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:31.380]     }
[10:22:31.380]     ...future.result <- base::tryCatch({
[10:22:31.380]         base::withCallingHandlers({
[10:22:31.380]             ...future.value <- base::withVisible(base::local({
[10:22:31.380]                 withCallingHandlers({
[10:22:31.380]                   {
[10:22:31.380]                     2
[10:22:31.380]                   }
[10:22:31.380]                 }, immediateCondition = function(cond) {
[10:22:31.380]                   save_rds <- function (object, pathname, ...) 
[10:22:31.380]                   {
[10:22:31.380]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:31.380]                     if (file_test("-f", pathname_tmp)) {
[10:22:31.380]                       fi_tmp <- file.info(pathname_tmp)
[10:22:31.380]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:31.380]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:31.380]                         fi_tmp[["mtime"]])
[10:22:31.380]                     }
[10:22:31.380]                     tryCatch({
[10:22:31.380]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:31.380]                     }, error = function(ex) {
[10:22:31.380]                       msg <- conditionMessage(ex)
[10:22:31.380]                       fi_tmp <- file.info(pathname_tmp)
[10:22:31.380]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:31.380]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:31.380]                         fi_tmp[["mtime"]], msg)
[10:22:31.380]                       ex$message <- msg
[10:22:31.380]                       stop(ex)
[10:22:31.380]                     })
[10:22:31.380]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:31.380]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:31.380]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:31.380]                       fi_tmp <- file.info(pathname_tmp)
[10:22:31.380]                       fi <- file.info(pathname)
[10:22:31.380]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:31.380]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:31.380]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:31.380]                         fi[["size"]], fi[["mtime"]])
[10:22:31.380]                       stop(msg)
[10:22:31.380]                     }
[10:22:31.380]                     invisible(pathname)
[10:22:31.380]                   }
[10:22:31.380]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:31.380]                     rootPath = tempdir()) 
[10:22:31.380]                   {
[10:22:31.380]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:31.380]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:31.380]                       tmpdir = path, fileext = ".rds")
[10:22:31.380]                     save_rds(obj, file)
[10:22:31.380]                   }
[10:22:31.380]                   saveImmediateCondition(cond, path = "/tmp/RtmpzsJv4f/.future/immediateConditions")
[10:22:31.380]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:31.380]                   {
[10:22:31.380]                     inherits <- base::inherits
[10:22:31.380]                     invokeRestart <- base::invokeRestart
[10:22:31.380]                     is.null <- base::is.null
[10:22:31.380]                     muffled <- FALSE
[10:22:31.380]                     if (inherits(cond, "message")) {
[10:22:31.380]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:31.380]                       if (muffled) 
[10:22:31.380]                         invokeRestart("muffleMessage")
[10:22:31.380]                     }
[10:22:31.380]                     else if (inherits(cond, "warning")) {
[10:22:31.380]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:31.380]                       if (muffled) 
[10:22:31.380]                         invokeRestart("muffleWarning")
[10:22:31.380]                     }
[10:22:31.380]                     else if (inherits(cond, "condition")) {
[10:22:31.380]                       if (!is.null(pattern)) {
[10:22:31.380]                         computeRestarts <- base::computeRestarts
[10:22:31.380]                         grepl <- base::grepl
[10:22:31.380]                         restarts <- computeRestarts(cond)
[10:22:31.380]                         for (restart in restarts) {
[10:22:31.380]                           name <- restart$name
[10:22:31.380]                           if (is.null(name)) 
[10:22:31.380]                             next
[10:22:31.380]                           if (!grepl(pattern, name)) 
[10:22:31.380]                             next
[10:22:31.380]                           invokeRestart(restart)
[10:22:31.380]                           muffled <- TRUE
[10:22:31.380]                           break
[10:22:31.380]                         }
[10:22:31.380]                       }
[10:22:31.380]                     }
[10:22:31.380]                     invisible(muffled)
[10:22:31.380]                   }
[10:22:31.380]                   muffleCondition(cond)
[10:22:31.380]                 })
[10:22:31.380]             }))
[10:22:31.380]             future::FutureResult(value = ...future.value$value, 
[10:22:31.380]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:31.380]                   ...future.rng), globalenv = if (FALSE) 
[10:22:31.380]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:31.380]                     ...future.globalenv.names))
[10:22:31.380]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:31.380]         }, condition = base::local({
[10:22:31.380]             c <- base::c
[10:22:31.380]             inherits <- base::inherits
[10:22:31.380]             invokeRestart <- base::invokeRestart
[10:22:31.380]             length <- base::length
[10:22:31.380]             list <- base::list
[10:22:31.380]             seq.int <- base::seq.int
[10:22:31.380]             signalCondition <- base::signalCondition
[10:22:31.380]             sys.calls <- base::sys.calls
[10:22:31.380]             `[[` <- base::`[[`
[10:22:31.380]             `+` <- base::`+`
[10:22:31.380]             `<<-` <- base::`<<-`
[10:22:31.380]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:31.380]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:31.380]                   3L)]
[10:22:31.380]             }
[10:22:31.380]             function(cond) {
[10:22:31.380]                 is_error <- inherits(cond, "error")
[10:22:31.380]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:31.380]                   NULL)
[10:22:31.380]                 if (is_error) {
[10:22:31.380]                   sessionInformation <- function() {
[10:22:31.380]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:31.380]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:31.380]                       search = base::search(), system = base::Sys.info())
[10:22:31.380]                   }
[10:22:31.380]                   ...future.conditions[[length(...future.conditions) + 
[10:22:31.380]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:31.380]                     cond$call), session = sessionInformation(), 
[10:22:31.380]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:31.380]                   signalCondition(cond)
[10:22:31.380]                 }
[10:22:31.380]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:31.380]                 "immediateCondition"))) {
[10:22:31.380]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:31.380]                   ...future.conditions[[length(...future.conditions) + 
[10:22:31.380]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:31.380]                   if (TRUE && !signal) {
[10:22:31.380]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:31.380]                     {
[10:22:31.380]                       inherits <- base::inherits
[10:22:31.380]                       invokeRestart <- base::invokeRestart
[10:22:31.380]                       is.null <- base::is.null
[10:22:31.380]                       muffled <- FALSE
[10:22:31.380]                       if (inherits(cond, "message")) {
[10:22:31.380]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:31.380]                         if (muffled) 
[10:22:31.380]                           invokeRestart("muffleMessage")
[10:22:31.380]                       }
[10:22:31.380]                       else if (inherits(cond, "warning")) {
[10:22:31.380]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:31.380]                         if (muffled) 
[10:22:31.380]                           invokeRestart("muffleWarning")
[10:22:31.380]                       }
[10:22:31.380]                       else if (inherits(cond, "condition")) {
[10:22:31.380]                         if (!is.null(pattern)) {
[10:22:31.380]                           computeRestarts <- base::computeRestarts
[10:22:31.380]                           grepl <- base::grepl
[10:22:31.380]                           restarts <- computeRestarts(cond)
[10:22:31.380]                           for (restart in restarts) {
[10:22:31.380]                             name <- restart$name
[10:22:31.380]                             if (is.null(name)) 
[10:22:31.380]                               next
[10:22:31.380]                             if (!grepl(pattern, name)) 
[10:22:31.380]                               next
[10:22:31.380]                             invokeRestart(restart)
[10:22:31.380]                             muffled <- TRUE
[10:22:31.380]                             break
[10:22:31.380]                           }
[10:22:31.380]                         }
[10:22:31.380]                       }
[10:22:31.380]                       invisible(muffled)
[10:22:31.380]                     }
[10:22:31.380]                     muffleCondition(cond, pattern = "^muffle")
[10:22:31.380]                   }
[10:22:31.380]                 }
[10:22:31.380]                 else {
[10:22:31.380]                   if (TRUE) {
[10:22:31.380]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:31.380]                     {
[10:22:31.380]                       inherits <- base::inherits
[10:22:31.380]                       invokeRestart <- base::invokeRestart
[10:22:31.380]                       is.null <- base::is.null
[10:22:31.380]                       muffled <- FALSE
[10:22:31.380]                       if (inherits(cond, "message")) {
[10:22:31.380]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:31.380]                         if (muffled) 
[10:22:31.380]                           invokeRestart("muffleMessage")
[10:22:31.380]                       }
[10:22:31.380]                       else if (inherits(cond, "warning")) {
[10:22:31.380]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:31.380]                         if (muffled) 
[10:22:31.380]                           invokeRestart("muffleWarning")
[10:22:31.380]                       }
[10:22:31.380]                       else if (inherits(cond, "condition")) {
[10:22:31.380]                         if (!is.null(pattern)) {
[10:22:31.380]                           computeRestarts <- base::computeRestarts
[10:22:31.380]                           grepl <- base::grepl
[10:22:31.380]                           restarts <- computeRestarts(cond)
[10:22:31.380]                           for (restart in restarts) {
[10:22:31.380]                             name <- restart$name
[10:22:31.380]                             if (is.null(name)) 
[10:22:31.380]                               next
[10:22:31.380]                             if (!grepl(pattern, name)) 
[10:22:31.380]                               next
[10:22:31.380]                             invokeRestart(restart)
[10:22:31.380]                             muffled <- TRUE
[10:22:31.380]                             break
[10:22:31.380]                           }
[10:22:31.380]                         }
[10:22:31.380]                       }
[10:22:31.380]                       invisible(muffled)
[10:22:31.380]                     }
[10:22:31.380]                     muffleCondition(cond, pattern = "^muffle")
[10:22:31.380]                   }
[10:22:31.380]                 }
[10:22:31.380]             }
[10:22:31.380]         }))
[10:22:31.380]     }, error = function(ex) {
[10:22:31.380]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:31.380]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:31.380]                 ...future.rng), started = ...future.startTime, 
[10:22:31.380]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:31.380]             version = "1.8"), class = "FutureResult")
[10:22:31.380]     }, finally = {
[10:22:31.380]         if (!identical(...future.workdir, getwd())) 
[10:22:31.380]             setwd(...future.workdir)
[10:22:31.380]         {
[10:22:31.380]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:31.380]                 ...future.oldOptions$nwarnings <- NULL
[10:22:31.380]             }
[10:22:31.380]             base::options(...future.oldOptions)
[10:22:31.380]             if (.Platform$OS.type == "windows") {
[10:22:31.380]                 old_names <- names(...future.oldEnvVars)
[10:22:31.380]                 envs <- base::Sys.getenv()
[10:22:31.380]                 names <- names(envs)
[10:22:31.380]                 common <- intersect(names, old_names)
[10:22:31.380]                 added <- setdiff(names, old_names)
[10:22:31.380]                 removed <- setdiff(old_names, names)
[10:22:31.380]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:31.380]                   envs[common]]
[10:22:31.380]                 NAMES <- toupper(changed)
[10:22:31.380]                 args <- list()
[10:22:31.380]                 for (kk in seq_along(NAMES)) {
[10:22:31.380]                   name <- changed[[kk]]
[10:22:31.380]                   NAME <- NAMES[[kk]]
[10:22:31.380]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:31.380]                     next
[10:22:31.380]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:31.380]                 }
[10:22:31.380]                 NAMES <- toupper(added)
[10:22:31.380]                 for (kk in seq_along(NAMES)) {
[10:22:31.380]                   name <- added[[kk]]
[10:22:31.380]                   NAME <- NAMES[[kk]]
[10:22:31.380]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:31.380]                     next
[10:22:31.380]                   args[[name]] <- ""
[10:22:31.380]                 }
[10:22:31.380]                 NAMES <- toupper(removed)
[10:22:31.380]                 for (kk in seq_along(NAMES)) {
[10:22:31.380]                   name <- removed[[kk]]
[10:22:31.380]                   NAME <- NAMES[[kk]]
[10:22:31.380]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:31.380]                     next
[10:22:31.380]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:31.380]                 }
[10:22:31.380]                 if (length(args) > 0) 
[10:22:31.380]                   base::do.call(base::Sys.setenv, args = args)
[10:22:31.380]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:31.380]             }
[10:22:31.380]             else {
[10:22:31.380]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:31.380]             }
[10:22:31.380]             {
[10:22:31.380]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:31.380]                   0L) {
[10:22:31.380]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:31.380]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:31.380]                   base::options(opts)
[10:22:31.380]                 }
[10:22:31.380]                 {
[10:22:31.380]                   {
[10:22:31.380]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:31.380]                     NULL
[10:22:31.380]                   }
[10:22:31.380]                   options(future.plan = NULL)
[10:22:31.380]                   if (is.na(NA_character_)) 
[10:22:31.380]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:31.380]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:31.380]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:31.380]                     .init = FALSE)
[10:22:31.380]                 }
[10:22:31.380]             }
[10:22:31.380]         }
[10:22:31.380]     })
[10:22:31.380]     if (TRUE) {
[10:22:31.380]         base::sink(type = "output", split = FALSE)
[10:22:31.380]         if (TRUE) {
[10:22:31.380]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:31.380]         }
[10:22:31.380]         else {
[10:22:31.380]             ...future.result["stdout"] <- base::list(NULL)
[10:22:31.380]         }
[10:22:31.380]         base::close(...future.stdout)
[10:22:31.380]         ...future.stdout <- NULL
[10:22:31.380]     }
[10:22:31.380]     ...future.result$conditions <- ...future.conditions
[10:22:31.380]     ...future.result$finished <- base::Sys.time()
[10:22:31.380]     ...future.result
[10:22:31.380] }
[10:22:31.382] requestCore(): workers = 2
[10:22:31.383] Poll #1 (0): usedCores() = 2, workers = 2
[10:22:31.393] result() for MulticoreFuture ...
[10:22:31.394] result() for MulticoreFuture ...
[10:22:31.395] result() for MulticoreFuture ... done
[10:22:31.395] result() for MulticoreFuture ... done
[10:22:31.395] result() for MulticoreFuture ...
[10:22:31.395] result() for MulticoreFuture ... done
[10:22:31.398] MulticoreFuture started
[10:22:31.399] - Launch lazy future ... done
[10:22:31.399] run() for ‘MulticoreFuture’ ... done
[10:22:31.399] plan(): Setting new future strategy stack:
[10:22:31.399] List of future strategies:
[10:22:31.399] 1. sequential:
[10:22:31.399]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:31.399]    - tweaked: FALSE
[10:22:31.399]    - call: NULL
[10:22:31.400] resolve() on environment ...
[10:22:31.400] plan(): nbrOfWorkers() = 1
[10:22:31.401]  recursive: 0
[10:22:31.401]  elements: [3] ‘a’
[10:22:31.402] Future #1
[10:22:31.402]  length: 2 (resolved future 1)
[10:22:31.403] plan(): Setting new future strategy stack:
[10:22:31.403] List of future strategies:
[10:22:31.403] 1. multicore:
[10:22:31.403]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:31.403]    - tweaked: FALSE
[10:22:31.403]    - call: plan(strategy)
[10:22:31.406] plan(): nbrOfWorkers() = 2
[10:22:31.406] Future #2
[10:22:31.406]  length: 1 (resolved future 2)
[10:22:31.407]  length: 0 (resolved future 3)
[10:22:31.407] resolve() on environment ... DONE
[10:22:31.408] resolve() on environment ...
[10:22:31.408]  recursive: 0
[10:22:31.409]  elements: [3] ‘b’
[10:22:31.409] Future #1
[10:22:31.409]  length: 2 (resolved future 1)
[10:22:31.409] Future #2
[10:22:31.410]  length: 1 (resolved future 2)
[10:22:31.410]  length: 0 (resolved future 3)
[10:22:31.410] resolve() on environment ... DONE
[10:22:31.411] resolve() on environment ...
[10:22:31.411]  recursive: 0
[10:22:31.411]  elements: [3] ‘c’
[10:22:31.412] Future #1
[10:22:31.412]  length: 2 (resolved future 1)
[10:22:31.412] Future #2
[10:22:31.412]  length: 1 (resolved future 2)
[10:22:31.413]  length: 0 (resolved future 3)
[10:22:31.413] resolve() on environment ... DONE
[10:22:31.413] resolve() on environment ...
[10:22:31.414]  recursive: 0
[10:22:31.414]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[10:22:31.415] Future #1
[10:22:31.415] result() for MulticoreFuture ...
[10:22:31.416] result() for MulticoreFuture ...
[10:22:31.416] result() for MulticoreFuture ... done
[10:22:31.416] result() for MulticoreFuture ... done
[10:22:31.416] result() for MulticoreFuture ...
[10:22:31.417] result() for MulticoreFuture ... done
[10:22:31.417]  length: 2 (resolved future 1)
[10:22:31.417] Future #2
[10:22:31.417] result() for MulticoreFuture ...
[10:22:31.418] result() for MulticoreFuture ...
[10:22:31.418] result() for MulticoreFuture ... done
[10:22:31.419] result() for MulticoreFuture ... done
[10:22:31.419] result() for MulticoreFuture ...
[10:22:31.419] result() for MulticoreFuture ... done
[10:22:31.419]  length: 1 (resolved future 2)
[10:22:31.419]  length: 0 (resolved future 3)
[10:22:31.419] resolve() on environment ... DONE
[10:22:31.420] resolve() on environment ...
[10:22:31.421]  recursive: 99
[10:22:31.421]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[10:22:31.421] Future #1
[10:22:31.421] result() for MulticoreFuture ...
[10:22:31.421] result() for MulticoreFuture ... done
[10:22:31.422] result() for MulticoreFuture ...
[10:22:31.422] result() for MulticoreFuture ... done
[10:22:31.422] A MulticoreFuture was resolved
[10:22:31.422]  length: 2 (resolved future 1)
[10:22:31.422] Future #2
[10:22:31.422] result() for MulticoreFuture ...
[10:22:31.422] result() for MulticoreFuture ... done
[10:22:31.422] result() for MulticoreFuture ...
[10:22:31.423] result() for MulticoreFuture ... done
[10:22:31.423] A MulticoreFuture was resolved
[10:22:31.423]  length: 1 (resolved future 2)
[10:22:31.423]  length: 0 (resolved future 3)
[10:22:31.423] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[10:22:31.424] resolve() on list environment ...
[10:22:31.424]  recursive: 0
[10:22:31.425]  length: 2
[10:22:31.425]  elements: ‘a’, ‘b’
[10:22:31.425]  length: 1 (resolved future 1)
[10:22:31.425]  length: 0 (resolved future 2)
[10:22:31.425] resolve() on list environment ... DONE
[10:22:31.425] getGlobalsAndPackages() ...
[10:22:31.425] Searching for globals...
[10:22:31.426] 
[10:22:31.426] Searching for globals ... DONE
[10:22:31.426] - globals: [0] <none>
[10:22:31.426] getGlobalsAndPackages() ... DONE
[10:22:31.427] run() for ‘Future’ ...
[10:22:31.427] - state: ‘created’
[10:22:31.427] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:31.431] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:31.431] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:31.432]   - Field: ‘label’
[10:22:31.432]   - Field: ‘local’
[10:22:31.432]   - Field: ‘owner’
[10:22:31.432]   - Field: ‘envir’
[10:22:31.432]   - Field: ‘workers’
[10:22:31.432]   - Field: ‘packages’
[10:22:31.433]   - Field: ‘gc’
[10:22:31.433]   - Field: ‘job’
[10:22:31.433]   - Field: ‘conditions’
[10:22:31.433]   - Field: ‘expr’
[10:22:31.433]   - Field: ‘uuid’
[10:22:31.433]   - Field: ‘seed’
[10:22:31.433]   - Field: ‘version’
[10:22:31.433]   - Field: ‘result’
[10:22:31.433]   - Field: ‘asynchronous’
[10:22:31.434]   - Field: ‘calls’
[10:22:31.434]   - Field: ‘globals’
[10:22:31.434]   - Field: ‘stdout’
[10:22:31.434]   - Field: ‘earlySignal’
[10:22:31.434]   - Field: ‘lazy’
[10:22:31.434]   - Field: ‘state’
[10:22:31.434] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:31.434] - Launch lazy future ...
[10:22:31.435] Packages needed by the future expression (n = 0): <none>
[10:22:31.435] Packages needed by future strategies (n = 0): <none>
[10:22:31.435] {
[10:22:31.435]     {
[10:22:31.435]         {
[10:22:31.435]             ...future.startTime <- base::Sys.time()
[10:22:31.435]             {
[10:22:31.435]                 {
[10:22:31.435]                   {
[10:22:31.435]                     {
[10:22:31.435]                       base::local({
[10:22:31.435]                         has_future <- base::requireNamespace("future", 
[10:22:31.435]                           quietly = TRUE)
[10:22:31.435]                         if (has_future) {
[10:22:31.435]                           ns <- base::getNamespace("future")
[10:22:31.435]                           version <- ns[[".package"]][["version"]]
[10:22:31.435]                           if (is.null(version)) 
[10:22:31.435]                             version <- utils::packageVersion("future")
[10:22:31.435]                         }
[10:22:31.435]                         else {
[10:22:31.435]                           version <- NULL
[10:22:31.435]                         }
[10:22:31.435]                         if (!has_future || version < "1.8.0") {
[10:22:31.435]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:31.435]                             "", base::R.version$version.string), 
[10:22:31.435]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:31.435]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:31.435]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:31.435]                               "release", "version")], collapse = " "), 
[10:22:31.435]                             hostname = base::Sys.info()[["nodename"]])
[10:22:31.435]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:31.435]                             info)
[10:22:31.435]                           info <- base::paste(info, collapse = "; ")
[10:22:31.435]                           if (!has_future) {
[10:22:31.435]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:31.435]                               info)
[10:22:31.435]                           }
[10:22:31.435]                           else {
[10:22:31.435]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:31.435]                               info, version)
[10:22:31.435]                           }
[10:22:31.435]                           base::stop(msg)
[10:22:31.435]                         }
[10:22:31.435]                       })
[10:22:31.435]                     }
[10:22:31.435]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:31.435]                     base::options(mc.cores = 1L)
[10:22:31.435]                   }
[10:22:31.435]                   ...future.strategy.old <- future::plan("list")
[10:22:31.435]                   options(future.plan = NULL)
[10:22:31.435]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:31.435]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:31.435]                 }
[10:22:31.435]                 ...future.workdir <- getwd()
[10:22:31.435]             }
[10:22:31.435]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:31.435]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:31.435]         }
[10:22:31.435]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:31.435]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:31.435]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:31.435]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:31.435]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:31.435]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:31.435]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:31.435]             base::names(...future.oldOptions))
[10:22:31.435]     }
[10:22:31.435]     if (FALSE) {
[10:22:31.435]     }
[10:22:31.435]     else {
[10:22:31.435]         if (TRUE) {
[10:22:31.435]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:31.435]                 open = "w")
[10:22:31.435]         }
[10:22:31.435]         else {
[10:22:31.435]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:31.435]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:31.435]         }
[10:22:31.435]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:31.435]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:31.435]             base::sink(type = "output", split = FALSE)
[10:22:31.435]             base::close(...future.stdout)
[10:22:31.435]         }, add = TRUE)
[10:22:31.435]     }
[10:22:31.435]     ...future.frame <- base::sys.nframe()
[10:22:31.435]     ...future.conditions <- base::list()
[10:22:31.435]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:31.435]     if (FALSE) {
[10:22:31.435]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:31.435]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:31.435]     }
[10:22:31.435]     ...future.result <- base::tryCatch({
[10:22:31.435]         base::withCallingHandlers({
[10:22:31.435]             ...future.value <- base::withVisible(base::local({
[10:22:31.435]                 withCallingHandlers({
[10:22:31.435]                   1
[10:22:31.435]                 }, immediateCondition = function(cond) {
[10:22:31.435]                   save_rds <- function (object, pathname, ...) 
[10:22:31.435]                   {
[10:22:31.435]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:31.435]                     if (file_test("-f", pathname_tmp)) {
[10:22:31.435]                       fi_tmp <- file.info(pathname_tmp)
[10:22:31.435]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:31.435]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:31.435]                         fi_tmp[["mtime"]])
[10:22:31.435]                     }
[10:22:31.435]                     tryCatch({
[10:22:31.435]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:31.435]                     }, error = function(ex) {
[10:22:31.435]                       msg <- conditionMessage(ex)
[10:22:31.435]                       fi_tmp <- file.info(pathname_tmp)
[10:22:31.435]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:31.435]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:31.435]                         fi_tmp[["mtime"]], msg)
[10:22:31.435]                       ex$message <- msg
[10:22:31.435]                       stop(ex)
[10:22:31.435]                     })
[10:22:31.435]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:31.435]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:31.435]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:31.435]                       fi_tmp <- file.info(pathname_tmp)
[10:22:31.435]                       fi <- file.info(pathname)
[10:22:31.435]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:31.435]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:31.435]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:31.435]                         fi[["size"]], fi[["mtime"]])
[10:22:31.435]                       stop(msg)
[10:22:31.435]                     }
[10:22:31.435]                     invisible(pathname)
[10:22:31.435]                   }
[10:22:31.435]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:31.435]                     rootPath = tempdir()) 
[10:22:31.435]                   {
[10:22:31.435]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:31.435]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:31.435]                       tmpdir = path, fileext = ".rds")
[10:22:31.435]                     save_rds(obj, file)
[10:22:31.435]                   }
[10:22:31.435]                   saveImmediateCondition(cond, path = "/tmp/RtmpzsJv4f/.future/immediateConditions")
[10:22:31.435]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:31.435]                   {
[10:22:31.435]                     inherits <- base::inherits
[10:22:31.435]                     invokeRestart <- base::invokeRestart
[10:22:31.435]                     is.null <- base::is.null
[10:22:31.435]                     muffled <- FALSE
[10:22:31.435]                     if (inherits(cond, "message")) {
[10:22:31.435]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:31.435]                       if (muffled) 
[10:22:31.435]                         invokeRestart("muffleMessage")
[10:22:31.435]                     }
[10:22:31.435]                     else if (inherits(cond, "warning")) {
[10:22:31.435]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:31.435]                       if (muffled) 
[10:22:31.435]                         invokeRestart("muffleWarning")
[10:22:31.435]                     }
[10:22:31.435]                     else if (inherits(cond, "condition")) {
[10:22:31.435]                       if (!is.null(pattern)) {
[10:22:31.435]                         computeRestarts <- base::computeRestarts
[10:22:31.435]                         grepl <- base::grepl
[10:22:31.435]                         restarts <- computeRestarts(cond)
[10:22:31.435]                         for (restart in restarts) {
[10:22:31.435]                           name <- restart$name
[10:22:31.435]                           if (is.null(name)) 
[10:22:31.435]                             next
[10:22:31.435]                           if (!grepl(pattern, name)) 
[10:22:31.435]                             next
[10:22:31.435]                           invokeRestart(restart)
[10:22:31.435]                           muffled <- TRUE
[10:22:31.435]                           break
[10:22:31.435]                         }
[10:22:31.435]                       }
[10:22:31.435]                     }
[10:22:31.435]                     invisible(muffled)
[10:22:31.435]                   }
[10:22:31.435]                   muffleCondition(cond)
[10:22:31.435]                 })
[10:22:31.435]             }))
[10:22:31.435]             future::FutureResult(value = ...future.value$value, 
[10:22:31.435]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:31.435]                   ...future.rng), globalenv = if (FALSE) 
[10:22:31.435]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:31.435]                     ...future.globalenv.names))
[10:22:31.435]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:31.435]         }, condition = base::local({
[10:22:31.435]             c <- base::c
[10:22:31.435]             inherits <- base::inherits
[10:22:31.435]             invokeRestart <- base::invokeRestart
[10:22:31.435]             length <- base::length
[10:22:31.435]             list <- base::list
[10:22:31.435]             seq.int <- base::seq.int
[10:22:31.435]             signalCondition <- base::signalCondition
[10:22:31.435]             sys.calls <- base::sys.calls
[10:22:31.435]             `[[` <- base::`[[`
[10:22:31.435]             `+` <- base::`+`
[10:22:31.435]             `<<-` <- base::`<<-`
[10:22:31.435]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:31.435]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:31.435]                   3L)]
[10:22:31.435]             }
[10:22:31.435]             function(cond) {
[10:22:31.435]                 is_error <- inherits(cond, "error")
[10:22:31.435]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:31.435]                   NULL)
[10:22:31.435]                 if (is_error) {
[10:22:31.435]                   sessionInformation <- function() {
[10:22:31.435]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:31.435]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:31.435]                       search = base::search(), system = base::Sys.info())
[10:22:31.435]                   }
[10:22:31.435]                   ...future.conditions[[length(...future.conditions) + 
[10:22:31.435]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:31.435]                     cond$call), session = sessionInformation(), 
[10:22:31.435]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:31.435]                   signalCondition(cond)
[10:22:31.435]                 }
[10:22:31.435]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:31.435]                 "immediateCondition"))) {
[10:22:31.435]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:31.435]                   ...future.conditions[[length(...future.conditions) + 
[10:22:31.435]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:31.435]                   if (TRUE && !signal) {
[10:22:31.435]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:31.435]                     {
[10:22:31.435]                       inherits <- base::inherits
[10:22:31.435]                       invokeRestart <- base::invokeRestart
[10:22:31.435]                       is.null <- base::is.null
[10:22:31.435]                       muffled <- FALSE
[10:22:31.435]                       if (inherits(cond, "message")) {
[10:22:31.435]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:31.435]                         if (muffled) 
[10:22:31.435]                           invokeRestart("muffleMessage")
[10:22:31.435]                       }
[10:22:31.435]                       else if (inherits(cond, "warning")) {
[10:22:31.435]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:31.435]                         if (muffled) 
[10:22:31.435]                           invokeRestart("muffleWarning")
[10:22:31.435]                       }
[10:22:31.435]                       else if (inherits(cond, "condition")) {
[10:22:31.435]                         if (!is.null(pattern)) {
[10:22:31.435]                           computeRestarts <- base::computeRestarts
[10:22:31.435]                           grepl <- base::grepl
[10:22:31.435]                           restarts <- computeRestarts(cond)
[10:22:31.435]                           for (restart in restarts) {
[10:22:31.435]                             name <- restart$name
[10:22:31.435]                             if (is.null(name)) 
[10:22:31.435]                               next
[10:22:31.435]                             if (!grepl(pattern, name)) 
[10:22:31.435]                               next
[10:22:31.435]                             invokeRestart(restart)
[10:22:31.435]                             muffled <- TRUE
[10:22:31.435]                             break
[10:22:31.435]                           }
[10:22:31.435]                         }
[10:22:31.435]                       }
[10:22:31.435]                       invisible(muffled)
[10:22:31.435]                     }
[10:22:31.435]                     muffleCondition(cond, pattern = "^muffle")
[10:22:31.435]                   }
[10:22:31.435]                 }
[10:22:31.435]                 else {
[10:22:31.435]                   if (TRUE) {
[10:22:31.435]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:31.435]                     {
[10:22:31.435]                       inherits <- base::inherits
[10:22:31.435]                       invokeRestart <- base::invokeRestart
[10:22:31.435]                       is.null <- base::is.null
[10:22:31.435]                       muffled <- FALSE
[10:22:31.435]                       if (inherits(cond, "message")) {
[10:22:31.435]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:31.435]                         if (muffled) 
[10:22:31.435]                           invokeRestart("muffleMessage")
[10:22:31.435]                       }
[10:22:31.435]                       else if (inherits(cond, "warning")) {
[10:22:31.435]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:31.435]                         if (muffled) 
[10:22:31.435]                           invokeRestart("muffleWarning")
[10:22:31.435]                       }
[10:22:31.435]                       else if (inherits(cond, "condition")) {
[10:22:31.435]                         if (!is.null(pattern)) {
[10:22:31.435]                           computeRestarts <- base::computeRestarts
[10:22:31.435]                           grepl <- base::grepl
[10:22:31.435]                           restarts <- computeRestarts(cond)
[10:22:31.435]                           for (restart in restarts) {
[10:22:31.435]                             name <- restart$name
[10:22:31.435]                             if (is.null(name)) 
[10:22:31.435]                               next
[10:22:31.435]                             if (!grepl(pattern, name)) 
[10:22:31.435]                               next
[10:22:31.435]                             invokeRestart(restart)
[10:22:31.435]                             muffled <- TRUE
[10:22:31.435]                             break
[10:22:31.435]                           }
[10:22:31.435]                         }
[10:22:31.435]                       }
[10:22:31.435]                       invisible(muffled)
[10:22:31.435]                     }
[10:22:31.435]                     muffleCondition(cond, pattern = "^muffle")
[10:22:31.435]                   }
[10:22:31.435]                 }
[10:22:31.435]             }
[10:22:31.435]         }))
[10:22:31.435]     }, error = function(ex) {
[10:22:31.435]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:31.435]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:31.435]                 ...future.rng), started = ...future.startTime, 
[10:22:31.435]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:31.435]             version = "1.8"), class = "FutureResult")
[10:22:31.435]     }, finally = {
[10:22:31.435]         if (!identical(...future.workdir, getwd())) 
[10:22:31.435]             setwd(...future.workdir)
[10:22:31.435]         {
[10:22:31.435]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:31.435]                 ...future.oldOptions$nwarnings <- NULL
[10:22:31.435]             }
[10:22:31.435]             base::options(...future.oldOptions)
[10:22:31.435]             if (.Platform$OS.type == "windows") {
[10:22:31.435]                 old_names <- names(...future.oldEnvVars)
[10:22:31.435]                 envs <- base::Sys.getenv()
[10:22:31.435]                 names <- names(envs)
[10:22:31.435]                 common <- intersect(names, old_names)
[10:22:31.435]                 added <- setdiff(names, old_names)
[10:22:31.435]                 removed <- setdiff(old_names, names)
[10:22:31.435]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:31.435]                   envs[common]]
[10:22:31.435]                 NAMES <- toupper(changed)
[10:22:31.435]                 args <- list()
[10:22:31.435]                 for (kk in seq_along(NAMES)) {
[10:22:31.435]                   name <- changed[[kk]]
[10:22:31.435]                   NAME <- NAMES[[kk]]
[10:22:31.435]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:31.435]                     next
[10:22:31.435]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:31.435]                 }
[10:22:31.435]                 NAMES <- toupper(added)
[10:22:31.435]                 for (kk in seq_along(NAMES)) {
[10:22:31.435]                   name <- added[[kk]]
[10:22:31.435]                   NAME <- NAMES[[kk]]
[10:22:31.435]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:31.435]                     next
[10:22:31.435]                   args[[name]] <- ""
[10:22:31.435]                 }
[10:22:31.435]                 NAMES <- toupper(removed)
[10:22:31.435]                 for (kk in seq_along(NAMES)) {
[10:22:31.435]                   name <- removed[[kk]]
[10:22:31.435]                   NAME <- NAMES[[kk]]
[10:22:31.435]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:31.435]                     next
[10:22:31.435]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:31.435]                 }
[10:22:31.435]                 if (length(args) > 0) 
[10:22:31.435]                   base::do.call(base::Sys.setenv, args = args)
[10:22:31.435]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:31.435]             }
[10:22:31.435]             else {
[10:22:31.435]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:31.435]             }
[10:22:31.435]             {
[10:22:31.435]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:31.435]                   0L) {
[10:22:31.435]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:31.435]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:31.435]                   base::options(opts)
[10:22:31.435]                 }
[10:22:31.435]                 {
[10:22:31.435]                   {
[10:22:31.435]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:31.435]                     NULL
[10:22:31.435]                   }
[10:22:31.435]                   options(future.plan = NULL)
[10:22:31.435]                   if (is.na(NA_character_)) 
[10:22:31.435]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:31.435]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:31.435]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:31.435]                     .init = FALSE)
[10:22:31.435]                 }
[10:22:31.435]             }
[10:22:31.435]         }
[10:22:31.435]     })
[10:22:31.435]     if (TRUE) {
[10:22:31.435]         base::sink(type = "output", split = FALSE)
[10:22:31.435]         if (TRUE) {
[10:22:31.435]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:31.435]         }
[10:22:31.435]         else {
[10:22:31.435]             ...future.result["stdout"] <- base::list(NULL)
[10:22:31.435]         }
[10:22:31.435]         base::close(...future.stdout)
[10:22:31.435]         ...future.stdout <- NULL
[10:22:31.435]     }
[10:22:31.435]     ...future.result$conditions <- ...future.conditions
[10:22:31.435]     ...future.result$finished <- base::Sys.time()
[10:22:31.435]     ...future.result
[10:22:31.435] }
[10:22:31.438] requestCore(): workers = 2
[10:22:31.440] MulticoreFuture started
[10:22:31.440] - Launch lazy future ... done
[10:22:31.440] run() for ‘MulticoreFuture’ ... done
[10:22:31.441] plan(): Setting new future strategy stack:
[10:22:31.441] getGlobalsAndPackages() ...
[10:22:31.441] Searching for globals...
[10:22:31.441] List of future strategies:
[10:22:31.441] 1. sequential:
[10:22:31.441]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:31.441]    - tweaked: FALSE
[10:22:31.441]    - call: NULL
[10:22:31.442] 
[10:22:31.442] plan(): nbrOfWorkers() = 1
[10:22:31.442] Searching for globals ... DONE
[10:22:31.442] - globals: [0] <none>
[10:22:31.442] getGlobalsAndPackages() ... DONE
[10:22:31.443] run() for ‘Future’ ...
[10:22:31.443] - state: ‘created’
[10:22:31.443] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:31.444] plan(): Setting new future strategy stack:
[10:22:31.444] List of future strategies:
[10:22:31.444] 1. multicore:
[10:22:31.444]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:31.444]    - tweaked: FALSE
[10:22:31.444]    - call: plan(strategy)
[10:22:31.446] plan(): nbrOfWorkers() = 2
[10:22:31.446] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:31.447] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:31.447]   - Field: ‘label’
[10:22:31.447]   - Field: ‘local’
[10:22:31.447]   - Field: ‘owner’
[10:22:31.447]   - Field: ‘envir’
[10:22:31.447]   - Field: ‘workers’
[10:22:31.448]   - Field: ‘packages’
[10:22:31.448]   - Field: ‘gc’
[10:22:31.448]   - Field: ‘job’
[10:22:31.448]   - Field: ‘conditions’
[10:22:31.448]   - Field: ‘expr’
[10:22:31.448]   - Field: ‘uuid’
[10:22:31.448]   - Field: ‘seed’
[10:22:31.449]   - Field: ‘version’
[10:22:31.449]   - Field: ‘result’
[10:22:31.449]   - Field: ‘asynchronous’
[10:22:31.449]   - Field: ‘calls’
[10:22:31.449]   - Field: ‘globals’
[10:22:31.449]   - Field: ‘stdout’
[10:22:31.449]   - Field: ‘earlySignal’
[10:22:31.450]   - Field: ‘lazy’
[10:22:31.450]   - Field: ‘state’
[10:22:31.450] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:31.450] - Launch lazy future ...
[10:22:31.450] Packages needed by the future expression (n = 0): <none>
[10:22:31.451] Packages needed by future strategies (n = 0): <none>
[10:22:31.451] {
[10:22:31.451]     {
[10:22:31.451]         {
[10:22:31.451]             ...future.startTime <- base::Sys.time()
[10:22:31.451]             {
[10:22:31.451]                 {
[10:22:31.451]                   {
[10:22:31.451]                     {
[10:22:31.451]                       base::local({
[10:22:31.451]                         has_future <- base::requireNamespace("future", 
[10:22:31.451]                           quietly = TRUE)
[10:22:31.451]                         if (has_future) {
[10:22:31.451]                           ns <- base::getNamespace("future")
[10:22:31.451]                           version <- ns[[".package"]][["version"]]
[10:22:31.451]                           if (is.null(version)) 
[10:22:31.451]                             version <- utils::packageVersion("future")
[10:22:31.451]                         }
[10:22:31.451]                         else {
[10:22:31.451]                           version <- NULL
[10:22:31.451]                         }
[10:22:31.451]                         if (!has_future || version < "1.8.0") {
[10:22:31.451]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:31.451]                             "", base::R.version$version.string), 
[10:22:31.451]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:31.451]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:31.451]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:31.451]                               "release", "version")], collapse = " "), 
[10:22:31.451]                             hostname = base::Sys.info()[["nodename"]])
[10:22:31.451]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:31.451]                             info)
[10:22:31.451]                           info <- base::paste(info, collapse = "; ")
[10:22:31.451]                           if (!has_future) {
[10:22:31.451]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:31.451]                               info)
[10:22:31.451]                           }
[10:22:31.451]                           else {
[10:22:31.451]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:31.451]                               info, version)
[10:22:31.451]                           }
[10:22:31.451]                           base::stop(msg)
[10:22:31.451]                         }
[10:22:31.451]                       })
[10:22:31.451]                     }
[10:22:31.451]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:31.451]                     base::options(mc.cores = 1L)
[10:22:31.451]                   }
[10:22:31.451]                   ...future.strategy.old <- future::plan("list")
[10:22:31.451]                   options(future.plan = NULL)
[10:22:31.451]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:31.451]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:31.451]                 }
[10:22:31.451]                 ...future.workdir <- getwd()
[10:22:31.451]             }
[10:22:31.451]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:31.451]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:31.451]         }
[10:22:31.451]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:31.451]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:31.451]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:31.451]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:31.451]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:31.451]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:31.451]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:31.451]             base::names(...future.oldOptions))
[10:22:31.451]     }
[10:22:31.451]     if (FALSE) {
[10:22:31.451]     }
[10:22:31.451]     else {
[10:22:31.451]         if (TRUE) {
[10:22:31.451]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:31.451]                 open = "w")
[10:22:31.451]         }
[10:22:31.451]         else {
[10:22:31.451]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:31.451]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:31.451]         }
[10:22:31.451]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:31.451]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:31.451]             base::sink(type = "output", split = FALSE)
[10:22:31.451]             base::close(...future.stdout)
[10:22:31.451]         }, add = TRUE)
[10:22:31.451]     }
[10:22:31.451]     ...future.frame <- base::sys.nframe()
[10:22:31.451]     ...future.conditions <- base::list()
[10:22:31.451]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:31.451]     if (FALSE) {
[10:22:31.451]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:31.451]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:31.451]     }
[10:22:31.451]     ...future.result <- base::tryCatch({
[10:22:31.451]         base::withCallingHandlers({
[10:22:31.451]             ...future.value <- base::withVisible(base::local({
[10:22:31.451]                 withCallingHandlers({
[10:22:31.451]                   2
[10:22:31.451]                 }, immediateCondition = function(cond) {
[10:22:31.451]                   save_rds <- function (object, pathname, ...) 
[10:22:31.451]                   {
[10:22:31.451]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:31.451]                     if (file_test("-f", pathname_tmp)) {
[10:22:31.451]                       fi_tmp <- file.info(pathname_tmp)
[10:22:31.451]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:31.451]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:31.451]                         fi_tmp[["mtime"]])
[10:22:31.451]                     }
[10:22:31.451]                     tryCatch({
[10:22:31.451]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:31.451]                     }, error = function(ex) {
[10:22:31.451]                       msg <- conditionMessage(ex)
[10:22:31.451]                       fi_tmp <- file.info(pathname_tmp)
[10:22:31.451]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:31.451]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:31.451]                         fi_tmp[["mtime"]], msg)
[10:22:31.451]                       ex$message <- msg
[10:22:31.451]                       stop(ex)
[10:22:31.451]                     })
[10:22:31.451]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:31.451]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:31.451]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:31.451]                       fi_tmp <- file.info(pathname_tmp)
[10:22:31.451]                       fi <- file.info(pathname)
[10:22:31.451]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:31.451]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:31.451]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:31.451]                         fi[["size"]], fi[["mtime"]])
[10:22:31.451]                       stop(msg)
[10:22:31.451]                     }
[10:22:31.451]                     invisible(pathname)
[10:22:31.451]                   }
[10:22:31.451]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:31.451]                     rootPath = tempdir()) 
[10:22:31.451]                   {
[10:22:31.451]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:31.451]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:31.451]                       tmpdir = path, fileext = ".rds")
[10:22:31.451]                     save_rds(obj, file)
[10:22:31.451]                   }
[10:22:31.451]                   saveImmediateCondition(cond, path = "/tmp/RtmpzsJv4f/.future/immediateConditions")
[10:22:31.451]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:31.451]                   {
[10:22:31.451]                     inherits <- base::inherits
[10:22:31.451]                     invokeRestart <- base::invokeRestart
[10:22:31.451]                     is.null <- base::is.null
[10:22:31.451]                     muffled <- FALSE
[10:22:31.451]                     if (inherits(cond, "message")) {
[10:22:31.451]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:31.451]                       if (muffled) 
[10:22:31.451]                         invokeRestart("muffleMessage")
[10:22:31.451]                     }
[10:22:31.451]                     else if (inherits(cond, "warning")) {
[10:22:31.451]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:31.451]                       if (muffled) 
[10:22:31.451]                         invokeRestart("muffleWarning")
[10:22:31.451]                     }
[10:22:31.451]                     else if (inherits(cond, "condition")) {
[10:22:31.451]                       if (!is.null(pattern)) {
[10:22:31.451]                         computeRestarts <- base::computeRestarts
[10:22:31.451]                         grepl <- base::grepl
[10:22:31.451]                         restarts <- computeRestarts(cond)
[10:22:31.451]                         for (restart in restarts) {
[10:22:31.451]                           name <- restart$name
[10:22:31.451]                           if (is.null(name)) 
[10:22:31.451]                             next
[10:22:31.451]                           if (!grepl(pattern, name)) 
[10:22:31.451]                             next
[10:22:31.451]                           invokeRestart(restart)
[10:22:31.451]                           muffled <- TRUE
[10:22:31.451]                           break
[10:22:31.451]                         }
[10:22:31.451]                       }
[10:22:31.451]                     }
[10:22:31.451]                     invisible(muffled)
[10:22:31.451]                   }
[10:22:31.451]                   muffleCondition(cond)
[10:22:31.451]                 })
[10:22:31.451]             }))
[10:22:31.451]             future::FutureResult(value = ...future.value$value, 
[10:22:31.451]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:31.451]                   ...future.rng), globalenv = if (FALSE) 
[10:22:31.451]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:31.451]                     ...future.globalenv.names))
[10:22:31.451]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:31.451]         }, condition = base::local({
[10:22:31.451]             c <- base::c
[10:22:31.451]             inherits <- base::inherits
[10:22:31.451]             invokeRestart <- base::invokeRestart
[10:22:31.451]             length <- base::length
[10:22:31.451]             list <- base::list
[10:22:31.451]             seq.int <- base::seq.int
[10:22:31.451]             signalCondition <- base::signalCondition
[10:22:31.451]             sys.calls <- base::sys.calls
[10:22:31.451]             `[[` <- base::`[[`
[10:22:31.451]             `+` <- base::`+`
[10:22:31.451]             `<<-` <- base::`<<-`
[10:22:31.451]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:31.451]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:31.451]                   3L)]
[10:22:31.451]             }
[10:22:31.451]             function(cond) {
[10:22:31.451]                 is_error <- inherits(cond, "error")
[10:22:31.451]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:31.451]                   NULL)
[10:22:31.451]                 if (is_error) {
[10:22:31.451]                   sessionInformation <- function() {
[10:22:31.451]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:31.451]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:31.451]                       search = base::search(), system = base::Sys.info())
[10:22:31.451]                   }
[10:22:31.451]                   ...future.conditions[[length(...future.conditions) + 
[10:22:31.451]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:31.451]                     cond$call), session = sessionInformation(), 
[10:22:31.451]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:31.451]                   signalCondition(cond)
[10:22:31.451]                 }
[10:22:31.451]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:31.451]                 "immediateCondition"))) {
[10:22:31.451]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:31.451]                   ...future.conditions[[length(...future.conditions) + 
[10:22:31.451]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:31.451]                   if (TRUE && !signal) {
[10:22:31.451]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:31.451]                     {
[10:22:31.451]                       inherits <- base::inherits
[10:22:31.451]                       invokeRestart <- base::invokeRestart
[10:22:31.451]                       is.null <- base::is.null
[10:22:31.451]                       muffled <- FALSE
[10:22:31.451]                       if (inherits(cond, "message")) {
[10:22:31.451]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:31.451]                         if (muffled) 
[10:22:31.451]                           invokeRestart("muffleMessage")
[10:22:31.451]                       }
[10:22:31.451]                       else if (inherits(cond, "warning")) {
[10:22:31.451]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:31.451]                         if (muffled) 
[10:22:31.451]                           invokeRestart("muffleWarning")
[10:22:31.451]                       }
[10:22:31.451]                       else if (inherits(cond, "condition")) {
[10:22:31.451]                         if (!is.null(pattern)) {
[10:22:31.451]                           computeRestarts <- base::computeRestarts
[10:22:31.451]                           grepl <- base::grepl
[10:22:31.451]                           restarts <- computeRestarts(cond)
[10:22:31.451]                           for (restart in restarts) {
[10:22:31.451]                             name <- restart$name
[10:22:31.451]                             if (is.null(name)) 
[10:22:31.451]                               next
[10:22:31.451]                             if (!grepl(pattern, name)) 
[10:22:31.451]                               next
[10:22:31.451]                             invokeRestart(restart)
[10:22:31.451]                             muffled <- TRUE
[10:22:31.451]                             break
[10:22:31.451]                           }
[10:22:31.451]                         }
[10:22:31.451]                       }
[10:22:31.451]                       invisible(muffled)
[10:22:31.451]                     }
[10:22:31.451]                     muffleCondition(cond, pattern = "^muffle")
[10:22:31.451]                   }
[10:22:31.451]                 }
[10:22:31.451]                 else {
[10:22:31.451]                   if (TRUE) {
[10:22:31.451]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:31.451]                     {
[10:22:31.451]                       inherits <- base::inherits
[10:22:31.451]                       invokeRestart <- base::invokeRestart
[10:22:31.451]                       is.null <- base::is.null
[10:22:31.451]                       muffled <- FALSE
[10:22:31.451]                       if (inherits(cond, "message")) {
[10:22:31.451]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:31.451]                         if (muffled) 
[10:22:31.451]                           invokeRestart("muffleMessage")
[10:22:31.451]                       }
[10:22:31.451]                       else if (inherits(cond, "warning")) {
[10:22:31.451]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:31.451]                         if (muffled) 
[10:22:31.451]                           invokeRestart("muffleWarning")
[10:22:31.451]                       }
[10:22:31.451]                       else if (inherits(cond, "condition")) {
[10:22:31.451]                         if (!is.null(pattern)) {
[10:22:31.451]                           computeRestarts <- base::computeRestarts
[10:22:31.451]                           grepl <- base::grepl
[10:22:31.451]                           restarts <- computeRestarts(cond)
[10:22:31.451]                           for (restart in restarts) {
[10:22:31.451]                             name <- restart$name
[10:22:31.451]                             if (is.null(name)) 
[10:22:31.451]                               next
[10:22:31.451]                             if (!grepl(pattern, name)) 
[10:22:31.451]                               next
[10:22:31.451]                             invokeRestart(restart)
[10:22:31.451]                             muffled <- TRUE
[10:22:31.451]                             break
[10:22:31.451]                           }
[10:22:31.451]                         }
[10:22:31.451]                       }
[10:22:31.451]                       invisible(muffled)
[10:22:31.451]                     }
[10:22:31.451]                     muffleCondition(cond, pattern = "^muffle")
[10:22:31.451]                   }
[10:22:31.451]                 }
[10:22:31.451]             }
[10:22:31.451]         }))
[10:22:31.451]     }, error = function(ex) {
[10:22:31.451]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:31.451]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:31.451]                 ...future.rng), started = ...future.startTime, 
[10:22:31.451]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:31.451]             version = "1.8"), class = "FutureResult")
[10:22:31.451]     }, finally = {
[10:22:31.451]         if (!identical(...future.workdir, getwd())) 
[10:22:31.451]             setwd(...future.workdir)
[10:22:31.451]         {
[10:22:31.451]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:31.451]                 ...future.oldOptions$nwarnings <- NULL
[10:22:31.451]             }
[10:22:31.451]             base::options(...future.oldOptions)
[10:22:31.451]             if (.Platform$OS.type == "windows") {
[10:22:31.451]                 old_names <- names(...future.oldEnvVars)
[10:22:31.451]                 envs <- base::Sys.getenv()
[10:22:31.451]                 names <- names(envs)
[10:22:31.451]                 common <- intersect(names, old_names)
[10:22:31.451]                 added <- setdiff(names, old_names)
[10:22:31.451]                 removed <- setdiff(old_names, names)
[10:22:31.451]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:31.451]                   envs[common]]
[10:22:31.451]                 NAMES <- toupper(changed)
[10:22:31.451]                 args <- list()
[10:22:31.451]                 for (kk in seq_along(NAMES)) {
[10:22:31.451]                   name <- changed[[kk]]
[10:22:31.451]                   NAME <- NAMES[[kk]]
[10:22:31.451]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:31.451]                     next
[10:22:31.451]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:31.451]                 }
[10:22:31.451]                 NAMES <- toupper(added)
[10:22:31.451]                 for (kk in seq_along(NAMES)) {
[10:22:31.451]                   name <- added[[kk]]
[10:22:31.451]                   NAME <- NAMES[[kk]]
[10:22:31.451]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:31.451]                     next
[10:22:31.451]                   args[[name]] <- ""
[10:22:31.451]                 }
[10:22:31.451]                 NAMES <- toupper(removed)
[10:22:31.451]                 for (kk in seq_along(NAMES)) {
[10:22:31.451]                   name <- removed[[kk]]
[10:22:31.451]                   NAME <- NAMES[[kk]]
[10:22:31.451]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:31.451]                     next
[10:22:31.451]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:31.451]                 }
[10:22:31.451]                 if (length(args) > 0) 
[10:22:31.451]                   base::do.call(base::Sys.setenv, args = args)
[10:22:31.451]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:31.451]             }
[10:22:31.451]             else {
[10:22:31.451]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:31.451]             }
[10:22:31.451]             {
[10:22:31.451]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:31.451]                   0L) {
[10:22:31.451]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:31.451]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:31.451]                   base::options(opts)
[10:22:31.451]                 }
[10:22:31.451]                 {
[10:22:31.451]                   {
[10:22:31.451]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:31.451]                     NULL
[10:22:31.451]                   }
[10:22:31.451]                   options(future.plan = NULL)
[10:22:31.451]                   if (is.na(NA_character_)) 
[10:22:31.451]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:31.451]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:31.451]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:31.451]                     .init = FALSE)
[10:22:31.451]                 }
[10:22:31.451]             }
[10:22:31.451]         }
[10:22:31.451]     })
[10:22:31.451]     if (TRUE) {
[10:22:31.451]         base::sink(type = "output", split = FALSE)
[10:22:31.451]         if (TRUE) {
[10:22:31.451]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:31.451]         }
[10:22:31.451]         else {
[10:22:31.451]             ...future.result["stdout"] <- base::list(NULL)
[10:22:31.451]         }
[10:22:31.451]         base::close(...future.stdout)
[10:22:31.451]         ...future.stdout <- NULL
[10:22:31.451]     }
[10:22:31.451]     ...future.result$conditions <- ...future.conditions
[10:22:31.451]     ...future.result$finished <- base::Sys.time()
[10:22:31.451]     ...future.result
[10:22:31.451] }
[10:22:31.455] requestCore(): workers = 2
[10:22:31.457] MulticoreFuture started
[10:22:31.457] - Launch lazy future ... done
[10:22:31.457] run() for ‘MulticoreFuture’ ... done
[10:22:31.458] plan(): Setting new future strategy stack:
[10:22:31.459] resolve() on list environment ...
[10:22:31.459]  recursive: 0
[10:22:31.458] List of future strategies:
[10:22:31.458] 1. sequential:
[10:22:31.458]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:31.458]    - tweaked: FALSE
[10:22:31.458]    - call: NULL
[10:22:31.459] plan(): nbrOfWorkers() = 1
[10:22:31.460]  length: 3
[10:22:31.460]  elements: ‘a’, ‘b’, ‘c’
[10:22:31.461] Future #1
[10:22:31.461]  length: 2 (resolved future 1)
[10:22:31.461] plan(): Setting new future strategy stack:
[10:22:31.462] List of future strategies:
[10:22:31.462] 1. multicore:
[10:22:31.462]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:31.462]    - tweaked: FALSE
[10:22:31.462]    - call: plan(strategy)
[10:22:31.465] plan(): nbrOfWorkers() = 2
[10:22:31.465] Future #2
[10:22:31.465]  length: 1 (resolved future 2)
[10:22:31.465]  length: 0 (resolved future 3)
[10:22:31.466] resolve() on list environment ... DONE
[10:22:31.467] getGlobalsAndPackages() ...
[10:22:31.467] Searching for globals...
[10:22:31.468] - globals found: [1] ‘{’
[10:22:31.468] Searching for globals ... DONE
[10:22:31.468] Resolving globals: FALSE
[10:22:31.469] 
[10:22:31.469] 
[10:22:31.469] getGlobalsAndPackages() ... DONE
[10:22:31.470] run() for ‘Future’ ...
[10:22:31.470] - state: ‘created’
[10:22:31.470] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:31.472] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:31.473] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:31.473]   - Field: ‘label’
[10:22:31.473]   - Field: ‘local’
[10:22:31.473]   - Field: ‘owner’
[10:22:31.473]   - Field: ‘envir’
[10:22:31.473]   - Field: ‘workers’
[10:22:31.473]   - Field: ‘packages’
[10:22:31.474]   - Field: ‘gc’
[10:22:31.474]   - Field: ‘job’
[10:22:31.474]   - Field: ‘conditions’
[10:22:31.474]   - Field: ‘expr’
[10:22:31.474]   - Field: ‘uuid’
[10:22:31.474]   - Field: ‘seed’
[10:22:31.474]   - Field: ‘version’
[10:22:31.475]   - Field: ‘result’
[10:22:31.475]   - Field: ‘asynchronous’
[10:22:31.475]   - Field: ‘calls’
[10:22:31.475]   - Field: ‘globals’
[10:22:31.475]   - Field: ‘stdout’
[10:22:31.475]   - Field: ‘earlySignal’
[10:22:31.475]   - Field: ‘lazy’
[10:22:31.475]   - Field: ‘state’
[10:22:31.476] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:31.476] - Launch lazy future ...
[10:22:31.476] Packages needed by the future expression (n = 0): <none>
[10:22:31.476] Packages needed by future strategies (n = 0): <none>
[10:22:31.477] {
[10:22:31.477]     {
[10:22:31.477]         {
[10:22:31.477]             ...future.startTime <- base::Sys.time()
[10:22:31.477]             {
[10:22:31.477]                 {
[10:22:31.477]                   {
[10:22:31.477]                     {
[10:22:31.477]                       base::local({
[10:22:31.477]                         has_future <- base::requireNamespace("future", 
[10:22:31.477]                           quietly = TRUE)
[10:22:31.477]                         if (has_future) {
[10:22:31.477]                           ns <- base::getNamespace("future")
[10:22:31.477]                           version <- ns[[".package"]][["version"]]
[10:22:31.477]                           if (is.null(version)) 
[10:22:31.477]                             version <- utils::packageVersion("future")
[10:22:31.477]                         }
[10:22:31.477]                         else {
[10:22:31.477]                           version <- NULL
[10:22:31.477]                         }
[10:22:31.477]                         if (!has_future || version < "1.8.0") {
[10:22:31.477]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:31.477]                             "", base::R.version$version.string), 
[10:22:31.477]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:31.477]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:31.477]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:31.477]                               "release", "version")], collapse = " "), 
[10:22:31.477]                             hostname = base::Sys.info()[["nodename"]])
[10:22:31.477]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:31.477]                             info)
[10:22:31.477]                           info <- base::paste(info, collapse = "; ")
[10:22:31.477]                           if (!has_future) {
[10:22:31.477]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:31.477]                               info)
[10:22:31.477]                           }
[10:22:31.477]                           else {
[10:22:31.477]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:31.477]                               info, version)
[10:22:31.477]                           }
[10:22:31.477]                           base::stop(msg)
[10:22:31.477]                         }
[10:22:31.477]                       })
[10:22:31.477]                     }
[10:22:31.477]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:31.477]                     base::options(mc.cores = 1L)
[10:22:31.477]                   }
[10:22:31.477]                   ...future.strategy.old <- future::plan("list")
[10:22:31.477]                   options(future.plan = NULL)
[10:22:31.477]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:31.477]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:31.477]                 }
[10:22:31.477]                 ...future.workdir <- getwd()
[10:22:31.477]             }
[10:22:31.477]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:31.477]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:31.477]         }
[10:22:31.477]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:31.477]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:31.477]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:31.477]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:31.477]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:31.477]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:31.477]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:31.477]             base::names(...future.oldOptions))
[10:22:31.477]     }
[10:22:31.477]     if (FALSE) {
[10:22:31.477]     }
[10:22:31.477]     else {
[10:22:31.477]         if (TRUE) {
[10:22:31.477]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:31.477]                 open = "w")
[10:22:31.477]         }
[10:22:31.477]         else {
[10:22:31.477]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:31.477]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:31.477]         }
[10:22:31.477]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:31.477]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:31.477]             base::sink(type = "output", split = FALSE)
[10:22:31.477]             base::close(...future.stdout)
[10:22:31.477]         }, add = TRUE)
[10:22:31.477]     }
[10:22:31.477]     ...future.frame <- base::sys.nframe()
[10:22:31.477]     ...future.conditions <- base::list()
[10:22:31.477]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:31.477]     if (FALSE) {
[10:22:31.477]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:31.477]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:31.477]     }
[10:22:31.477]     ...future.result <- base::tryCatch({
[10:22:31.477]         base::withCallingHandlers({
[10:22:31.477]             ...future.value <- base::withVisible(base::local({
[10:22:31.477]                 withCallingHandlers({
[10:22:31.477]                   {
[10:22:31.477]                     1
[10:22:31.477]                   }
[10:22:31.477]                 }, immediateCondition = function(cond) {
[10:22:31.477]                   save_rds <- function (object, pathname, ...) 
[10:22:31.477]                   {
[10:22:31.477]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:31.477]                     if (file_test("-f", pathname_tmp)) {
[10:22:31.477]                       fi_tmp <- file.info(pathname_tmp)
[10:22:31.477]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:31.477]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:31.477]                         fi_tmp[["mtime"]])
[10:22:31.477]                     }
[10:22:31.477]                     tryCatch({
[10:22:31.477]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:31.477]                     }, error = function(ex) {
[10:22:31.477]                       msg <- conditionMessage(ex)
[10:22:31.477]                       fi_tmp <- file.info(pathname_tmp)
[10:22:31.477]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:31.477]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:31.477]                         fi_tmp[["mtime"]], msg)
[10:22:31.477]                       ex$message <- msg
[10:22:31.477]                       stop(ex)
[10:22:31.477]                     })
[10:22:31.477]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:31.477]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:31.477]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:31.477]                       fi_tmp <- file.info(pathname_tmp)
[10:22:31.477]                       fi <- file.info(pathname)
[10:22:31.477]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:31.477]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:31.477]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:31.477]                         fi[["size"]], fi[["mtime"]])
[10:22:31.477]                       stop(msg)
[10:22:31.477]                     }
[10:22:31.477]                     invisible(pathname)
[10:22:31.477]                   }
[10:22:31.477]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:31.477]                     rootPath = tempdir()) 
[10:22:31.477]                   {
[10:22:31.477]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:31.477]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:31.477]                       tmpdir = path, fileext = ".rds")
[10:22:31.477]                     save_rds(obj, file)
[10:22:31.477]                   }
[10:22:31.477]                   saveImmediateCondition(cond, path = "/tmp/RtmpzsJv4f/.future/immediateConditions")
[10:22:31.477]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:31.477]                   {
[10:22:31.477]                     inherits <- base::inherits
[10:22:31.477]                     invokeRestart <- base::invokeRestart
[10:22:31.477]                     is.null <- base::is.null
[10:22:31.477]                     muffled <- FALSE
[10:22:31.477]                     if (inherits(cond, "message")) {
[10:22:31.477]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:31.477]                       if (muffled) 
[10:22:31.477]                         invokeRestart("muffleMessage")
[10:22:31.477]                     }
[10:22:31.477]                     else if (inherits(cond, "warning")) {
[10:22:31.477]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:31.477]                       if (muffled) 
[10:22:31.477]                         invokeRestart("muffleWarning")
[10:22:31.477]                     }
[10:22:31.477]                     else if (inherits(cond, "condition")) {
[10:22:31.477]                       if (!is.null(pattern)) {
[10:22:31.477]                         computeRestarts <- base::computeRestarts
[10:22:31.477]                         grepl <- base::grepl
[10:22:31.477]                         restarts <- computeRestarts(cond)
[10:22:31.477]                         for (restart in restarts) {
[10:22:31.477]                           name <- restart$name
[10:22:31.477]                           if (is.null(name)) 
[10:22:31.477]                             next
[10:22:31.477]                           if (!grepl(pattern, name)) 
[10:22:31.477]                             next
[10:22:31.477]                           invokeRestart(restart)
[10:22:31.477]                           muffled <- TRUE
[10:22:31.477]                           break
[10:22:31.477]                         }
[10:22:31.477]                       }
[10:22:31.477]                     }
[10:22:31.477]                     invisible(muffled)
[10:22:31.477]                   }
[10:22:31.477]                   muffleCondition(cond)
[10:22:31.477]                 })
[10:22:31.477]             }))
[10:22:31.477]             future::FutureResult(value = ...future.value$value, 
[10:22:31.477]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:31.477]                   ...future.rng), globalenv = if (FALSE) 
[10:22:31.477]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:31.477]                     ...future.globalenv.names))
[10:22:31.477]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:31.477]         }, condition = base::local({
[10:22:31.477]             c <- base::c
[10:22:31.477]             inherits <- base::inherits
[10:22:31.477]             invokeRestart <- base::invokeRestart
[10:22:31.477]             length <- base::length
[10:22:31.477]             list <- base::list
[10:22:31.477]             seq.int <- base::seq.int
[10:22:31.477]             signalCondition <- base::signalCondition
[10:22:31.477]             sys.calls <- base::sys.calls
[10:22:31.477]             `[[` <- base::`[[`
[10:22:31.477]             `+` <- base::`+`
[10:22:31.477]             `<<-` <- base::`<<-`
[10:22:31.477]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:31.477]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:31.477]                   3L)]
[10:22:31.477]             }
[10:22:31.477]             function(cond) {
[10:22:31.477]                 is_error <- inherits(cond, "error")
[10:22:31.477]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:31.477]                   NULL)
[10:22:31.477]                 if (is_error) {
[10:22:31.477]                   sessionInformation <- function() {
[10:22:31.477]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:31.477]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:31.477]                       search = base::search(), system = base::Sys.info())
[10:22:31.477]                   }
[10:22:31.477]                   ...future.conditions[[length(...future.conditions) + 
[10:22:31.477]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:31.477]                     cond$call), session = sessionInformation(), 
[10:22:31.477]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:31.477]                   signalCondition(cond)
[10:22:31.477]                 }
[10:22:31.477]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:31.477]                 "immediateCondition"))) {
[10:22:31.477]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:31.477]                   ...future.conditions[[length(...future.conditions) + 
[10:22:31.477]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:31.477]                   if (TRUE && !signal) {
[10:22:31.477]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:31.477]                     {
[10:22:31.477]                       inherits <- base::inherits
[10:22:31.477]                       invokeRestart <- base::invokeRestart
[10:22:31.477]                       is.null <- base::is.null
[10:22:31.477]                       muffled <- FALSE
[10:22:31.477]                       if (inherits(cond, "message")) {
[10:22:31.477]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:31.477]                         if (muffled) 
[10:22:31.477]                           invokeRestart("muffleMessage")
[10:22:31.477]                       }
[10:22:31.477]                       else if (inherits(cond, "warning")) {
[10:22:31.477]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:31.477]                         if (muffled) 
[10:22:31.477]                           invokeRestart("muffleWarning")
[10:22:31.477]                       }
[10:22:31.477]                       else if (inherits(cond, "condition")) {
[10:22:31.477]                         if (!is.null(pattern)) {
[10:22:31.477]                           computeRestarts <- base::computeRestarts
[10:22:31.477]                           grepl <- base::grepl
[10:22:31.477]                           restarts <- computeRestarts(cond)
[10:22:31.477]                           for (restart in restarts) {
[10:22:31.477]                             name <- restart$name
[10:22:31.477]                             if (is.null(name)) 
[10:22:31.477]                               next
[10:22:31.477]                             if (!grepl(pattern, name)) 
[10:22:31.477]                               next
[10:22:31.477]                             invokeRestart(restart)
[10:22:31.477]                             muffled <- TRUE
[10:22:31.477]                             break
[10:22:31.477]                           }
[10:22:31.477]                         }
[10:22:31.477]                       }
[10:22:31.477]                       invisible(muffled)
[10:22:31.477]                     }
[10:22:31.477]                     muffleCondition(cond, pattern = "^muffle")
[10:22:31.477]                   }
[10:22:31.477]                 }
[10:22:31.477]                 else {
[10:22:31.477]                   if (TRUE) {
[10:22:31.477]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:31.477]                     {
[10:22:31.477]                       inherits <- base::inherits
[10:22:31.477]                       invokeRestart <- base::invokeRestart
[10:22:31.477]                       is.null <- base::is.null
[10:22:31.477]                       muffled <- FALSE
[10:22:31.477]                       if (inherits(cond, "message")) {
[10:22:31.477]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:31.477]                         if (muffled) 
[10:22:31.477]                           invokeRestart("muffleMessage")
[10:22:31.477]                       }
[10:22:31.477]                       else if (inherits(cond, "warning")) {
[10:22:31.477]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:31.477]                         if (muffled) 
[10:22:31.477]                           invokeRestart("muffleWarning")
[10:22:31.477]                       }
[10:22:31.477]                       else if (inherits(cond, "condition")) {
[10:22:31.477]                         if (!is.null(pattern)) {
[10:22:31.477]                           computeRestarts <- base::computeRestarts
[10:22:31.477]                           grepl <- base::grepl
[10:22:31.477]                           restarts <- computeRestarts(cond)
[10:22:31.477]                           for (restart in restarts) {
[10:22:31.477]                             name <- restart$name
[10:22:31.477]                             if (is.null(name)) 
[10:22:31.477]                               next
[10:22:31.477]                             if (!grepl(pattern, name)) 
[10:22:31.477]                               next
[10:22:31.477]                             invokeRestart(restart)
[10:22:31.477]                             muffled <- TRUE
[10:22:31.477]                             break
[10:22:31.477]                           }
[10:22:31.477]                         }
[10:22:31.477]                       }
[10:22:31.477]                       invisible(muffled)
[10:22:31.477]                     }
[10:22:31.477]                     muffleCondition(cond, pattern = "^muffle")
[10:22:31.477]                   }
[10:22:31.477]                 }
[10:22:31.477]             }
[10:22:31.477]         }))
[10:22:31.477]     }, error = function(ex) {
[10:22:31.477]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:31.477]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:31.477]                 ...future.rng), started = ...future.startTime, 
[10:22:31.477]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:31.477]             version = "1.8"), class = "FutureResult")
[10:22:31.477]     }, finally = {
[10:22:31.477]         if (!identical(...future.workdir, getwd())) 
[10:22:31.477]             setwd(...future.workdir)
[10:22:31.477]         {
[10:22:31.477]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:31.477]                 ...future.oldOptions$nwarnings <- NULL
[10:22:31.477]             }
[10:22:31.477]             base::options(...future.oldOptions)
[10:22:31.477]             if (.Platform$OS.type == "windows") {
[10:22:31.477]                 old_names <- names(...future.oldEnvVars)
[10:22:31.477]                 envs <- base::Sys.getenv()
[10:22:31.477]                 names <- names(envs)
[10:22:31.477]                 common <- intersect(names, old_names)
[10:22:31.477]                 added <- setdiff(names, old_names)
[10:22:31.477]                 removed <- setdiff(old_names, names)
[10:22:31.477]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:31.477]                   envs[common]]
[10:22:31.477]                 NAMES <- toupper(changed)
[10:22:31.477]                 args <- list()
[10:22:31.477]                 for (kk in seq_along(NAMES)) {
[10:22:31.477]                   name <- changed[[kk]]
[10:22:31.477]                   NAME <- NAMES[[kk]]
[10:22:31.477]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:31.477]                     next
[10:22:31.477]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:31.477]                 }
[10:22:31.477]                 NAMES <- toupper(added)
[10:22:31.477]                 for (kk in seq_along(NAMES)) {
[10:22:31.477]                   name <- added[[kk]]
[10:22:31.477]                   NAME <- NAMES[[kk]]
[10:22:31.477]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:31.477]                     next
[10:22:31.477]                   args[[name]] <- ""
[10:22:31.477]                 }
[10:22:31.477]                 NAMES <- toupper(removed)
[10:22:31.477]                 for (kk in seq_along(NAMES)) {
[10:22:31.477]                   name <- removed[[kk]]
[10:22:31.477]                   NAME <- NAMES[[kk]]
[10:22:31.477]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:31.477]                     next
[10:22:31.477]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:31.477]                 }
[10:22:31.477]                 if (length(args) > 0) 
[10:22:31.477]                   base::do.call(base::Sys.setenv, args = args)
[10:22:31.477]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:31.477]             }
[10:22:31.477]             else {
[10:22:31.477]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:31.477]             }
[10:22:31.477]             {
[10:22:31.477]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:31.477]                   0L) {
[10:22:31.477]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:31.477]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:31.477]                   base::options(opts)
[10:22:31.477]                 }
[10:22:31.477]                 {
[10:22:31.477]                   {
[10:22:31.477]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:31.477]                     NULL
[10:22:31.477]                   }
[10:22:31.477]                   options(future.plan = NULL)
[10:22:31.477]                   if (is.na(NA_character_)) 
[10:22:31.477]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:31.477]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:31.477]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:31.477]                     .init = FALSE)
[10:22:31.477]                 }
[10:22:31.477]             }
[10:22:31.477]         }
[10:22:31.477]     })
[10:22:31.477]     if (TRUE) {
[10:22:31.477]         base::sink(type = "output", split = FALSE)
[10:22:31.477]         if (TRUE) {
[10:22:31.477]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:31.477]         }
[10:22:31.477]         else {
[10:22:31.477]             ...future.result["stdout"] <- base::list(NULL)
[10:22:31.477]         }
[10:22:31.477]         base::close(...future.stdout)
[10:22:31.477]         ...future.stdout <- NULL
[10:22:31.477]     }
[10:22:31.477]     ...future.result$conditions <- ...future.conditions
[10:22:31.477]     ...future.result$finished <- base::Sys.time()
[10:22:31.477]     ...future.result
[10:22:31.477] }
[10:22:31.480] requestCore(): workers = 2
[10:22:31.481] Poll #1 (0): usedCores() = 2, workers = 2
[10:22:31.492] result() for MulticoreFuture ...
[10:22:31.492] result() for MulticoreFuture ...
[10:22:31.493] result() for MulticoreFuture ... done
[10:22:31.493] result() for MulticoreFuture ... done
[10:22:31.493] result() for MulticoreFuture ...
[10:22:31.493] result() for MulticoreFuture ... done
[10:22:31.495] MulticoreFuture started
[10:22:31.496] - Launch lazy future ... done
[10:22:31.496] run() for ‘MulticoreFuture’ ... done
[10:22:31.497] plan(): Setting new future strategy stack:
[10:22:31.497] getGlobalsAndPackages() ...
[10:22:31.497] List of future strategies:
[10:22:31.497] 1. sequential:
[10:22:31.497]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:31.497]    - tweaked: FALSE
[10:22:31.497]    - call: NULL
[10:22:31.498] Searching for globals...
[10:22:31.498] plan(): nbrOfWorkers() = 1
[10:22:31.508] - globals found: [1] ‘{’
[10:22:31.508] plan(): Setting new future strategy stack:
[10:22:31.509] Searching for globals ... DONE
[10:22:31.509] Resolving globals: FALSE
[10:22:31.509] List of future strategies:
[10:22:31.509] 1. multicore:
[10:22:31.509]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:31.509]    - tweaked: FALSE
[10:22:31.509]    - call: plan(strategy)
[10:22:31.511] 
[10:22:31.511] 
[10:22:31.512] getGlobalsAndPackages() ... DONE
[10:22:31.512] run() for ‘Future’ ...
[10:22:31.513] - state: ‘created’
[10:22:31.513] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:31.514] plan(): nbrOfWorkers() = 2
[10:22:31.516] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:31.517] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:31.517]   - Field: ‘label’
[10:22:31.517]   - Field: ‘local’
[10:22:31.517]   - Field: ‘owner’
[10:22:31.517]   - Field: ‘envir’
[10:22:31.518]   - Field: ‘workers’
[10:22:31.518]   - Field: ‘packages’
[10:22:31.518]   - Field: ‘gc’
[10:22:31.518]   - Field: ‘job’
[10:22:31.518]   - Field: ‘conditions’
[10:22:31.519]   - Field: ‘expr’
[10:22:31.519]   - Field: ‘uuid’
[10:22:31.519]   - Field: ‘seed’
[10:22:31.519]   - Field: ‘version’
[10:22:31.519]   - Field: ‘result’
[10:22:31.519]   - Field: ‘asynchronous’
[10:22:31.519]   - Field: ‘calls’
[10:22:31.520]   - Field: ‘globals’
[10:22:31.520]   - Field: ‘stdout’
[10:22:31.520]   - Field: ‘earlySignal’
[10:22:31.520]   - Field: ‘lazy’
[10:22:31.520]   - Field: ‘state’
[10:22:31.520] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:31.520] - Launch lazy future ...
[10:22:31.521] Packages needed by the future expression (n = 0): <none>
[10:22:31.521] Packages needed by future strategies (n = 0): <none>
[10:22:31.522] {
[10:22:31.522]     {
[10:22:31.522]         {
[10:22:31.522]             ...future.startTime <- base::Sys.time()
[10:22:31.522]             {
[10:22:31.522]                 {
[10:22:31.522]                   {
[10:22:31.522]                     {
[10:22:31.522]                       base::local({
[10:22:31.522]                         has_future <- base::requireNamespace("future", 
[10:22:31.522]                           quietly = TRUE)
[10:22:31.522]                         if (has_future) {
[10:22:31.522]                           ns <- base::getNamespace("future")
[10:22:31.522]                           version <- ns[[".package"]][["version"]]
[10:22:31.522]                           if (is.null(version)) 
[10:22:31.522]                             version <- utils::packageVersion("future")
[10:22:31.522]                         }
[10:22:31.522]                         else {
[10:22:31.522]                           version <- NULL
[10:22:31.522]                         }
[10:22:31.522]                         if (!has_future || version < "1.8.0") {
[10:22:31.522]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:31.522]                             "", base::R.version$version.string), 
[10:22:31.522]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:31.522]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:31.522]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:31.522]                               "release", "version")], collapse = " "), 
[10:22:31.522]                             hostname = base::Sys.info()[["nodename"]])
[10:22:31.522]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:31.522]                             info)
[10:22:31.522]                           info <- base::paste(info, collapse = "; ")
[10:22:31.522]                           if (!has_future) {
[10:22:31.522]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:31.522]                               info)
[10:22:31.522]                           }
[10:22:31.522]                           else {
[10:22:31.522]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:31.522]                               info, version)
[10:22:31.522]                           }
[10:22:31.522]                           base::stop(msg)
[10:22:31.522]                         }
[10:22:31.522]                       })
[10:22:31.522]                     }
[10:22:31.522]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:31.522]                     base::options(mc.cores = 1L)
[10:22:31.522]                   }
[10:22:31.522]                   ...future.strategy.old <- future::plan("list")
[10:22:31.522]                   options(future.plan = NULL)
[10:22:31.522]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:31.522]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:31.522]                 }
[10:22:31.522]                 ...future.workdir <- getwd()
[10:22:31.522]             }
[10:22:31.522]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:31.522]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:31.522]         }
[10:22:31.522]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:31.522]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:31.522]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:31.522]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:31.522]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:31.522]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:31.522]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:31.522]             base::names(...future.oldOptions))
[10:22:31.522]     }
[10:22:31.522]     if (FALSE) {
[10:22:31.522]     }
[10:22:31.522]     else {
[10:22:31.522]         if (TRUE) {
[10:22:31.522]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:31.522]                 open = "w")
[10:22:31.522]         }
[10:22:31.522]         else {
[10:22:31.522]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:31.522]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:31.522]         }
[10:22:31.522]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:31.522]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:31.522]             base::sink(type = "output", split = FALSE)
[10:22:31.522]             base::close(...future.stdout)
[10:22:31.522]         }, add = TRUE)
[10:22:31.522]     }
[10:22:31.522]     ...future.frame <- base::sys.nframe()
[10:22:31.522]     ...future.conditions <- base::list()
[10:22:31.522]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:31.522]     if (FALSE) {
[10:22:31.522]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:31.522]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:31.522]     }
[10:22:31.522]     ...future.result <- base::tryCatch({
[10:22:31.522]         base::withCallingHandlers({
[10:22:31.522]             ...future.value <- base::withVisible(base::local({
[10:22:31.522]                 withCallingHandlers({
[10:22:31.522]                   {
[10:22:31.522]                     2
[10:22:31.522]                   }
[10:22:31.522]                 }, immediateCondition = function(cond) {
[10:22:31.522]                   save_rds <- function (object, pathname, ...) 
[10:22:31.522]                   {
[10:22:31.522]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:31.522]                     if (file_test("-f", pathname_tmp)) {
[10:22:31.522]                       fi_tmp <- file.info(pathname_tmp)
[10:22:31.522]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:31.522]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:31.522]                         fi_tmp[["mtime"]])
[10:22:31.522]                     }
[10:22:31.522]                     tryCatch({
[10:22:31.522]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:31.522]                     }, error = function(ex) {
[10:22:31.522]                       msg <- conditionMessage(ex)
[10:22:31.522]                       fi_tmp <- file.info(pathname_tmp)
[10:22:31.522]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:31.522]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:31.522]                         fi_tmp[["mtime"]], msg)
[10:22:31.522]                       ex$message <- msg
[10:22:31.522]                       stop(ex)
[10:22:31.522]                     })
[10:22:31.522]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:31.522]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:31.522]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:31.522]                       fi_tmp <- file.info(pathname_tmp)
[10:22:31.522]                       fi <- file.info(pathname)
[10:22:31.522]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:31.522]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:31.522]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:31.522]                         fi[["size"]], fi[["mtime"]])
[10:22:31.522]                       stop(msg)
[10:22:31.522]                     }
[10:22:31.522]                     invisible(pathname)
[10:22:31.522]                   }
[10:22:31.522]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:31.522]                     rootPath = tempdir()) 
[10:22:31.522]                   {
[10:22:31.522]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:31.522]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:31.522]                       tmpdir = path, fileext = ".rds")
[10:22:31.522]                     save_rds(obj, file)
[10:22:31.522]                   }
[10:22:31.522]                   saveImmediateCondition(cond, path = "/tmp/RtmpzsJv4f/.future/immediateConditions")
[10:22:31.522]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:31.522]                   {
[10:22:31.522]                     inherits <- base::inherits
[10:22:31.522]                     invokeRestart <- base::invokeRestart
[10:22:31.522]                     is.null <- base::is.null
[10:22:31.522]                     muffled <- FALSE
[10:22:31.522]                     if (inherits(cond, "message")) {
[10:22:31.522]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:31.522]                       if (muffled) 
[10:22:31.522]                         invokeRestart("muffleMessage")
[10:22:31.522]                     }
[10:22:31.522]                     else if (inherits(cond, "warning")) {
[10:22:31.522]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:31.522]                       if (muffled) 
[10:22:31.522]                         invokeRestart("muffleWarning")
[10:22:31.522]                     }
[10:22:31.522]                     else if (inherits(cond, "condition")) {
[10:22:31.522]                       if (!is.null(pattern)) {
[10:22:31.522]                         computeRestarts <- base::computeRestarts
[10:22:31.522]                         grepl <- base::grepl
[10:22:31.522]                         restarts <- computeRestarts(cond)
[10:22:31.522]                         for (restart in restarts) {
[10:22:31.522]                           name <- restart$name
[10:22:31.522]                           if (is.null(name)) 
[10:22:31.522]                             next
[10:22:31.522]                           if (!grepl(pattern, name)) 
[10:22:31.522]                             next
[10:22:31.522]                           invokeRestart(restart)
[10:22:31.522]                           muffled <- TRUE
[10:22:31.522]                           break
[10:22:31.522]                         }
[10:22:31.522]                       }
[10:22:31.522]                     }
[10:22:31.522]                     invisible(muffled)
[10:22:31.522]                   }
[10:22:31.522]                   muffleCondition(cond)
[10:22:31.522]                 })
[10:22:31.522]             }))
[10:22:31.522]             future::FutureResult(value = ...future.value$value, 
[10:22:31.522]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:31.522]                   ...future.rng), globalenv = if (FALSE) 
[10:22:31.522]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:31.522]                     ...future.globalenv.names))
[10:22:31.522]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:31.522]         }, condition = base::local({
[10:22:31.522]             c <- base::c
[10:22:31.522]             inherits <- base::inherits
[10:22:31.522]             invokeRestart <- base::invokeRestart
[10:22:31.522]             length <- base::length
[10:22:31.522]             list <- base::list
[10:22:31.522]             seq.int <- base::seq.int
[10:22:31.522]             signalCondition <- base::signalCondition
[10:22:31.522]             sys.calls <- base::sys.calls
[10:22:31.522]             `[[` <- base::`[[`
[10:22:31.522]             `+` <- base::`+`
[10:22:31.522]             `<<-` <- base::`<<-`
[10:22:31.522]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:31.522]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:31.522]                   3L)]
[10:22:31.522]             }
[10:22:31.522]             function(cond) {
[10:22:31.522]                 is_error <- inherits(cond, "error")
[10:22:31.522]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:31.522]                   NULL)
[10:22:31.522]                 if (is_error) {
[10:22:31.522]                   sessionInformation <- function() {
[10:22:31.522]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:31.522]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:31.522]                       search = base::search(), system = base::Sys.info())
[10:22:31.522]                   }
[10:22:31.522]                   ...future.conditions[[length(...future.conditions) + 
[10:22:31.522]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:31.522]                     cond$call), session = sessionInformation(), 
[10:22:31.522]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:31.522]                   signalCondition(cond)
[10:22:31.522]                 }
[10:22:31.522]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:31.522]                 "immediateCondition"))) {
[10:22:31.522]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:31.522]                   ...future.conditions[[length(...future.conditions) + 
[10:22:31.522]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:31.522]                   if (TRUE && !signal) {
[10:22:31.522]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:31.522]                     {
[10:22:31.522]                       inherits <- base::inherits
[10:22:31.522]                       invokeRestart <- base::invokeRestart
[10:22:31.522]                       is.null <- base::is.null
[10:22:31.522]                       muffled <- FALSE
[10:22:31.522]                       if (inherits(cond, "message")) {
[10:22:31.522]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:31.522]                         if (muffled) 
[10:22:31.522]                           invokeRestart("muffleMessage")
[10:22:31.522]                       }
[10:22:31.522]                       else if (inherits(cond, "warning")) {
[10:22:31.522]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:31.522]                         if (muffled) 
[10:22:31.522]                           invokeRestart("muffleWarning")
[10:22:31.522]                       }
[10:22:31.522]                       else if (inherits(cond, "condition")) {
[10:22:31.522]                         if (!is.null(pattern)) {
[10:22:31.522]                           computeRestarts <- base::computeRestarts
[10:22:31.522]                           grepl <- base::grepl
[10:22:31.522]                           restarts <- computeRestarts(cond)
[10:22:31.522]                           for (restart in restarts) {
[10:22:31.522]                             name <- restart$name
[10:22:31.522]                             if (is.null(name)) 
[10:22:31.522]                               next
[10:22:31.522]                             if (!grepl(pattern, name)) 
[10:22:31.522]                               next
[10:22:31.522]                             invokeRestart(restart)
[10:22:31.522]                             muffled <- TRUE
[10:22:31.522]                             break
[10:22:31.522]                           }
[10:22:31.522]                         }
[10:22:31.522]                       }
[10:22:31.522]                       invisible(muffled)
[10:22:31.522]                     }
[10:22:31.522]                     muffleCondition(cond, pattern = "^muffle")
[10:22:31.522]                   }
[10:22:31.522]                 }
[10:22:31.522]                 else {
[10:22:31.522]                   if (TRUE) {
[10:22:31.522]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:31.522]                     {
[10:22:31.522]                       inherits <- base::inherits
[10:22:31.522]                       invokeRestart <- base::invokeRestart
[10:22:31.522]                       is.null <- base::is.null
[10:22:31.522]                       muffled <- FALSE
[10:22:31.522]                       if (inherits(cond, "message")) {
[10:22:31.522]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:31.522]                         if (muffled) 
[10:22:31.522]                           invokeRestart("muffleMessage")
[10:22:31.522]                       }
[10:22:31.522]                       else if (inherits(cond, "warning")) {
[10:22:31.522]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:31.522]                         if (muffled) 
[10:22:31.522]                           invokeRestart("muffleWarning")
[10:22:31.522]                       }
[10:22:31.522]                       else if (inherits(cond, "condition")) {
[10:22:31.522]                         if (!is.null(pattern)) {
[10:22:31.522]                           computeRestarts <- base::computeRestarts
[10:22:31.522]                           grepl <- base::grepl
[10:22:31.522]                           restarts <- computeRestarts(cond)
[10:22:31.522]                           for (restart in restarts) {
[10:22:31.522]                             name <- restart$name
[10:22:31.522]                             if (is.null(name)) 
[10:22:31.522]                               next
[10:22:31.522]                             if (!grepl(pattern, name)) 
[10:22:31.522]                               next
[10:22:31.522]                             invokeRestart(restart)
[10:22:31.522]                             muffled <- TRUE
[10:22:31.522]                             break
[10:22:31.522]                           }
[10:22:31.522]                         }
[10:22:31.522]                       }
[10:22:31.522]                       invisible(muffled)
[10:22:31.522]                     }
[10:22:31.522]                     muffleCondition(cond, pattern = "^muffle")
[10:22:31.522]                   }
[10:22:31.522]                 }
[10:22:31.522]             }
[10:22:31.522]         }))
[10:22:31.522]     }, error = function(ex) {
[10:22:31.522]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:31.522]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:31.522]                 ...future.rng), started = ...future.startTime, 
[10:22:31.522]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:31.522]             version = "1.8"), class = "FutureResult")
[10:22:31.522]     }, finally = {
[10:22:31.522]         if (!identical(...future.workdir, getwd())) 
[10:22:31.522]             setwd(...future.workdir)
[10:22:31.522]         {
[10:22:31.522]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:31.522]                 ...future.oldOptions$nwarnings <- NULL
[10:22:31.522]             }
[10:22:31.522]             base::options(...future.oldOptions)
[10:22:31.522]             if (.Platform$OS.type == "windows") {
[10:22:31.522]                 old_names <- names(...future.oldEnvVars)
[10:22:31.522]                 envs <- base::Sys.getenv()
[10:22:31.522]                 names <- names(envs)
[10:22:31.522]                 common <- intersect(names, old_names)
[10:22:31.522]                 added <- setdiff(names, old_names)
[10:22:31.522]                 removed <- setdiff(old_names, names)
[10:22:31.522]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:31.522]                   envs[common]]
[10:22:31.522]                 NAMES <- toupper(changed)
[10:22:31.522]                 args <- list()
[10:22:31.522]                 for (kk in seq_along(NAMES)) {
[10:22:31.522]                   name <- changed[[kk]]
[10:22:31.522]                   NAME <- NAMES[[kk]]
[10:22:31.522]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:31.522]                     next
[10:22:31.522]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:31.522]                 }
[10:22:31.522]                 NAMES <- toupper(added)
[10:22:31.522]                 for (kk in seq_along(NAMES)) {
[10:22:31.522]                   name <- added[[kk]]
[10:22:31.522]                   NAME <- NAMES[[kk]]
[10:22:31.522]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:31.522]                     next
[10:22:31.522]                   args[[name]] <- ""
[10:22:31.522]                 }
[10:22:31.522]                 NAMES <- toupper(removed)
[10:22:31.522]                 for (kk in seq_along(NAMES)) {
[10:22:31.522]                   name <- removed[[kk]]
[10:22:31.522]                   NAME <- NAMES[[kk]]
[10:22:31.522]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:31.522]                     next
[10:22:31.522]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:31.522]                 }
[10:22:31.522]                 if (length(args) > 0) 
[10:22:31.522]                   base::do.call(base::Sys.setenv, args = args)
[10:22:31.522]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:31.522]             }
[10:22:31.522]             else {
[10:22:31.522]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:31.522]             }
[10:22:31.522]             {
[10:22:31.522]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:31.522]                   0L) {
[10:22:31.522]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:31.522]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:31.522]                   base::options(opts)
[10:22:31.522]                 }
[10:22:31.522]                 {
[10:22:31.522]                   {
[10:22:31.522]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:31.522]                     NULL
[10:22:31.522]                   }
[10:22:31.522]                   options(future.plan = NULL)
[10:22:31.522]                   if (is.na(NA_character_)) 
[10:22:31.522]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:31.522]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:31.522]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:31.522]                     .init = FALSE)
[10:22:31.522]                 }
[10:22:31.522]             }
[10:22:31.522]         }
[10:22:31.522]     })
[10:22:31.522]     if (TRUE) {
[10:22:31.522]         base::sink(type = "output", split = FALSE)
[10:22:31.522]         if (TRUE) {
[10:22:31.522]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:31.522]         }
[10:22:31.522]         else {
[10:22:31.522]             ...future.result["stdout"] <- base::list(NULL)
[10:22:31.522]         }
[10:22:31.522]         base::close(...future.stdout)
[10:22:31.522]         ...future.stdout <- NULL
[10:22:31.522]     }
[10:22:31.522]     ...future.result$conditions <- ...future.conditions
[10:22:31.522]     ...future.result$finished <- base::Sys.time()
[10:22:31.522]     ...future.result
[10:22:31.522] }
[10:22:31.524] requestCore(): workers = 2
[10:22:31.525] Poll #1 (0): usedCores() = 2, workers = 2
[10:22:31.535] result() for MulticoreFuture ...
[10:22:31.536] result() for MulticoreFuture ...
[10:22:31.536] result() for MulticoreFuture ... done
[10:22:31.536] result() for MulticoreFuture ... done
[10:22:31.537] result() for MulticoreFuture ...
[10:22:31.537] result() for MulticoreFuture ... done
[10:22:31.539] MulticoreFuture started
[10:22:31.540] - Launch lazy future ... done
[10:22:31.540] run() for ‘MulticoreFuture’ ... done
[10:22:31.540] plan(): Setting new future strategy stack:
[10:22:31.542] resolve() on list environment ...
[10:22:31.541] List of future strategies:
[10:22:31.541] 1. sequential:
[10:22:31.541]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:31.541]    - tweaked: FALSE
[10:22:31.541]    - call: NULL
[10:22:31.542]  recursive: 0
[10:22:31.542] plan(): nbrOfWorkers() = 1
[10:22:31.543]  length: 3
[10:22:31.544]  elements: ‘a’, ‘b’, ‘c’
[10:22:31.544] Future #1
[10:22:31.545]  length: 2 (resolved future 1)
[10:22:31.545] plan(): Setting new future strategy stack:
[10:22:31.545] List of future strategies:
[10:22:31.545] 1. multicore:
[10:22:31.545]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:31.545]    - tweaked: FALSE
[10:22:31.545]    - call: plan(strategy)
[10:22:31.549] plan(): nbrOfWorkers() = 2
[10:22:31.549] Future #2
[10:22:31.549]  length: 1 (resolved future 2)
[10:22:31.549]  length: 0 (resolved future 3)
[10:22:31.550] resolve() on list environment ... DONE
[10:22:31.550] getGlobalsAndPackages() ...
[10:22:31.550] Searching for globals...
[10:22:31.552] - globals found: [1] ‘{’
[10:22:31.552] Searching for globals ... DONE
[10:22:31.552] Resolving globals: FALSE
[10:22:31.553] 
[10:22:31.553] 
[10:22:31.553] getGlobalsAndPackages() ... DONE
[10:22:31.553] run() for ‘Future’ ...
[10:22:31.553] - state: ‘created’
[10:22:31.554] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:31.556] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:31.556] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:31.556]   - Field: ‘label’
[10:22:31.557]   - Field: ‘local’
[10:22:31.557]   - Field: ‘owner’
[10:22:31.557]   - Field: ‘envir’
[10:22:31.557]   - Field: ‘workers’
[10:22:31.557]   - Field: ‘packages’
[10:22:31.557]   - Field: ‘gc’
[10:22:31.557]   - Field: ‘job’
[10:22:31.558]   - Field: ‘conditions’
[10:22:31.558]   - Field: ‘expr’
[10:22:31.558]   - Field: ‘uuid’
[10:22:31.558]   - Field: ‘seed’
[10:22:31.558]   - Field: ‘version’
[10:22:31.558]   - Field: ‘result’
[10:22:31.558]   - Field: ‘asynchronous’
[10:22:31.559]   - Field: ‘calls’
[10:22:31.559]   - Field: ‘globals’
[10:22:31.559]   - Field: ‘stdout’
[10:22:31.559]   - Field: ‘earlySignal’
[10:22:31.559]   - Field: ‘lazy’
[10:22:31.559]   - Field: ‘state’
[10:22:31.559] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:31.560] - Launch lazy future ...
[10:22:31.560] Packages needed by the future expression (n = 0): <none>
[10:22:31.560] Packages needed by future strategies (n = 0): <none>
[10:22:31.561] {
[10:22:31.561]     {
[10:22:31.561]         {
[10:22:31.561]             ...future.startTime <- base::Sys.time()
[10:22:31.561]             {
[10:22:31.561]                 {
[10:22:31.561]                   {
[10:22:31.561]                     {
[10:22:31.561]                       base::local({
[10:22:31.561]                         has_future <- base::requireNamespace("future", 
[10:22:31.561]                           quietly = TRUE)
[10:22:31.561]                         if (has_future) {
[10:22:31.561]                           ns <- base::getNamespace("future")
[10:22:31.561]                           version <- ns[[".package"]][["version"]]
[10:22:31.561]                           if (is.null(version)) 
[10:22:31.561]                             version <- utils::packageVersion("future")
[10:22:31.561]                         }
[10:22:31.561]                         else {
[10:22:31.561]                           version <- NULL
[10:22:31.561]                         }
[10:22:31.561]                         if (!has_future || version < "1.8.0") {
[10:22:31.561]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:31.561]                             "", base::R.version$version.string), 
[10:22:31.561]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:31.561]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:31.561]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:31.561]                               "release", "version")], collapse = " "), 
[10:22:31.561]                             hostname = base::Sys.info()[["nodename"]])
[10:22:31.561]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:31.561]                             info)
[10:22:31.561]                           info <- base::paste(info, collapse = "; ")
[10:22:31.561]                           if (!has_future) {
[10:22:31.561]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:31.561]                               info)
[10:22:31.561]                           }
[10:22:31.561]                           else {
[10:22:31.561]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:31.561]                               info, version)
[10:22:31.561]                           }
[10:22:31.561]                           base::stop(msg)
[10:22:31.561]                         }
[10:22:31.561]                       })
[10:22:31.561]                     }
[10:22:31.561]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:31.561]                     base::options(mc.cores = 1L)
[10:22:31.561]                   }
[10:22:31.561]                   ...future.strategy.old <- future::plan("list")
[10:22:31.561]                   options(future.plan = NULL)
[10:22:31.561]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:31.561]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:31.561]                 }
[10:22:31.561]                 ...future.workdir <- getwd()
[10:22:31.561]             }
[10:22:31.561]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:31.561]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:31.561]         }
[10:22:31.561]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:31.561]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:31.561]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:31.561]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:31.561]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:31.561]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:31.561]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:31.561]             base::names(...future.oldOptions))
[10:22:31.561]     }
[10:22:31.561]     if (FALSE) {
[10:22:31.561]     }
[10:22:31.561]     else {
[10:22:31.561]         if (TRUE) {
[10:22:31.561]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:31.561]                 open = "w")
[10:22:31.561]         }
[10:22:31.561]         else {
[10:22:31.561]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:31.561]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:31.561]         }
[10:22:31.561]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:31.561]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:31.561]             base::sink(type = "output", split = FALSE)
[10:22:31.561]             base::close(...future.stdout)
[10:22:31.561]         }, add = TRUE)
[10:22:31.561]     }
[10:22:31.561]     ...future.frame <- base::sys.nframe()
[10:22:31.561]     ...future.conditions <- base::list()
[10:22:31.561]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:31.561]     if (FALSE) {
[10:22:31.561]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:31.561]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:31.561]     }
[10:22:31.561]     ...future.result <- base::tryCatch({
[10:22:31.561]         base::withCallingHandlers({
[10:22:31.561]             ...future.value <- base::withVisible(base::local({
[10:22:31.561]                 withCallingHandlers({
[10:22:31.561]                   {
[10:22:31.561]                     1
[10:22:31.561]                   }
[10:22:31.561]                 }, immediateCondition = function(cond) {
[10:22:31.561]                   save_rds <- function (object, pathname, ...) 
[10:22:31.561]                   {
[10:22:31.561]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:31.561]                     if (file_test("-f", pathname_tmp)) {
[10:22:31.561]                       fi_tmp <- file.info(pathname_tmp)
[10:22:31.561]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:31.561]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:31.561]                         fi_tmp[["mtime"]])
[10:22:31.561]                     }
[10:22:31.561]                     tryCatch({
[10:22:31.561]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:31.561]                     }, error = function(ex) {
[10:22:31.561]                       msg <- conditionMessage(ex)
[10:22:31.561]                       fi_tmp <- file.info(pathname_tmp)
[10:22:31.561]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:31.561]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:31.561]                         fi_tmp[["mtime"]], msg)
[10:22:31.561]                       ex$message <- msg
[10:22:31.561]                       stop(ex)
[10:22:31.561]                     })
[10:22:31.561]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:31.561]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:31.561]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:31.561]                       fi_tmp <- file.info(pathname_tmp)
[10:22:31.561]                       fi <- file.info(pathname)
[10:22:31.561]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:31.561]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:31.561]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:31.561]                         fi[["size"]], fi[["mtime"]])
[10:22:31.561]                       stop(msg)
[10:22:31.561]                     }
[10:22:31.561]                     invisible(pathname)
[10:22:31.561]                   }
[10:22:31.561]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:31.561]                     rootPath = tempdir()) 
[10:22:31.561]                   {
[10:22:31.561]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:31.561]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:31.561]                       tmpdir = path, fileext = ".rds")
[10:22:31.561]                     save_rds(obj, file)
[10:22:31.561]                   }
[10:22:31.561]                   saveImmediateCondition(cond, path = "/tmp/RtmpzsJv4f/.future/immediateConditions")
[10:22:31.561]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:31.561]                   {
[10:22:31.561]                     inherits <- base::inherits
[10:22:31.561]                     invokeRestart <- base::invokeRestart
[10:22:31.561]                     is.null <- base::is.null
[10:22:31.561]                     muffled <- FALSE
[10:22:31.561]                     if (inherits(cond, "message")) {
[10:22:31.561]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:31.561]                       if (muffled) 
[10:22:31.561]                         invokeRestart("muffleMessage")
[10:22:31.561]                     }
[10:22:31.561]                     else if (inherits(cond, "warning")) {
[10:22:31.561]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:31.561]                       if (muffled) 
[10:22:31.561]                         invokeRestart("muffleWarning")
[10:22:31.561]                     }
[10:22:31.561]                     else if (inherits(cond, "condition")) {
[10:22:31.561]                       if (!is.null(pattern)) {
[10:22:31.561]                         computeRestarts <- base::computeRestarts
[10:22:31.561]                         grepl <- base::grepl
[10:22:31.561]                         restarts <- computeRestarts(cond)
[10:22:31.561]                         for (restart in restarts) {
[10:22:31.561]                           name <- restart$name
[10:22:31.561]                           if (is.null(name)) 
[10:22:31.561]                             next
[10:22:31.561]                           if (!grepl(pattern, name)) 
[10:22:31.561]                             next
[10:22:31.561]                           invokeRestart(restart)
[10:22:31.561]                           muffled <- TRUE
[10:22:31.561]                           break
[10:22:31.561]                         }
[10:22:31.561]                       }
[10:22:31.561]                     }
[10:22:31.561]                     invisible(muffled)
[10:22:31.561]                   }
[10:22:31.561]                   muffleCondition(cond)
[10:22:31.561]                 })
[10:22:31.561]             }))
[10:22:31.561]             future::FutureResult(value = ...future.value$value, 
[10:22:31.561]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:31.561]                   ...future.rng), globalenv = if (FALSE) 
[10:22:31.561]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:31.561]                     ...future.globalenv.names))
[10:22:31.561]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:31.561]         }, condition = base::local({
[10:22:31.561]             c <- base::c
[10:22:31.561]             inherits <- base::inherits
[10:22:31.561]             invokeRestart <- base::invokeRestart
[10:22:31.561]             length <- base::length
[10:22:31.561]             list <- base::list
[10:22:31.561]             seq.int <- base::seq.int
[10:22:31.561]             signalCondition <- base::signalCondition
[10:22:31.561]             sys.calls <- base::sys.calls
[10:22:31.561]             `[[` <- base::`[[`
[10:22:31.561]             `+` <- base::`+`
[10:22:31.561]             `<<-` <- base::`<<-`
[10:22:31.561]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:31.561]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:31.561]                   3L)]
[10:22:31.561]             }
[10:22:31.561]             function(cond) {
[10:22:31.561]                 is_error <- inherits(cond, "error")
[10:22:31.561]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:31.561]                   NULL)
[10:22:31.561]                 if (is_error) {
[10:22:31.561]                   sessionInformation <- function() {
[10:22:31.561]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:31.561]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:31.561]                       search = base::search(), system = base::Sys.info())
[10:22:31.561]                   }
[10:22:31.561]                   ...future.conditions[[length(...future.conditions) + 
[10:22:31.561]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:31.561]                     cond$call), session = sessionInformation(), 
[10:22:31.561]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:31.561]                   signalCondition(cond)
[10:22:31.561]                 }
[10:22:31.561]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:31.561]                 "immediateCondition"))) {
[10:22:31.561]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:31.561]                   ...future.conditions[[length(...future.conditions) + 
[10:22:31.561]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:31.561]                   if (TRUE && !signal) {
[10:22:31.561]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:31.561]                     {
[10:22:31.561]                       inherits <- base::inherits
[10:22:31.561]                       invokeRestart <- base::invokeRestart
[10:22:31.561]                       is.null <- base::is.null
[10:22:31.561]                       muffled <- FALSE
[10:22:31.561]                       if (inherits(cond, "message")) {
[10:22:31.561]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:31.561]                         if (muffled) 
[10:22:31.561]                           invokeRestart("muffleMessage")
[10:22:31.561]                       }
[10:22:31.561]                       else if (inherits(cond, "warning")) {
[10:22:31.561]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:31.561]                         if (muffled) 
[10:22:31.561]                           invokeRestart("muffleWarning")
[10:22:31.561]                       }
[10:22:31.561]                       else if (inherits(cond, "condition")) {
[10:22:31.561]                         if (!is.null(pattern)) {
[10:22:31.561]                           computeRestarts <- base::computeRestarts
[10:22:31.561]                           grepl <- base::grepl
[10:22:31.561]                           restarts <- computeRestarts(cond)
[10:22:31.561]                           for (restart in restarts) {
[10:22:31.561]                             name <- restart$name
[10:22:31.561]                             if (is.null(name)) 
[10:22:31.561]                               next
[10:22:31.561]                             if (!grepl(pattern, name)) 
[10:22:31.561]                               next
[10:22:31.561]                             invokeRestart(restart)
[10:22:31.561]                             muffled <- TRUE
[10:22:31.561]                             break
[10:22:31.561]                           }
[10:22:31.561]                         }
[10:22:31.561]                       }
[10:22:31.561]                       invisible(muffled)
[10:22:31.561]                     }
[10:22:31.561]                     muffleCondition(cond, pattern = "^muffle")
[10:22:31.561]                   }
[10:22:31.561]                 }
[10:22:31.561]                 else {
[10:22:31.561]                   if (TRUE) {
[10:22:31.561]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:31.561]                     {
[10:22:31.561]                       inherits <- base::inherits
[10:22:31.561]                       invokeRestart <- base::invokeRestart
[10:22:31.561]                       is.null <- base::is.null
[10:22:31.561]                       muffled <- FALSE
[10:22:31.561]                       if (inherits(cond, "message")) {
[10:22:31.561]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:31.561]                         if (muffled) 
[10:22:31.561]                           invokeRestart("muffleMessage")
[10:22:31.561]                       }
[10:22:31.561]                       else if (inherits(cond, "warning")) {
[10:22:31.561]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:31.561]                         if (muffled) 
[10:22:31.561]                           invokeRestart("muffleWarning")
[10:22:31.561]                       }
[10:22:31.561]                       else if (inherits(cond, "condition")) {
[10:22:31.561]                         if (!is.null(pattern)) {
[10:22:31.561]                           computeRestarts <- base::computeRestarts
[10:22:31.561]                           grepl <- base::grepl
[10:22:31.561]                           restarts <- computeRestarts(cond)
[10:22:31.561]                           for (restart in restarts) {
[10:22:31.561]                             name <- restart$name
[10:22:31.561]                             if (is.null(name)) 
[10:22:31.561]                               next
[10:22:31.561]                             if (!grepl(pattern, name)) 
[10:22:31.561]                               next
[10:22:31.561]                             invokeRestart(restart)
[10:22:31.561]                             muffled <- TRUE
[10:22:31.561]                             break
[10:22:31.561]                           }
[10:22:31.561]                         }
[10:22:31.561]                       }
[10:22:31.561]                       invisible(muffled)
[10:22:31.561]                     }
[10:22:31.561]                     muffleCondition(cond, pattern = "^muffle")
[10:22:31.561]                   }
[10:22:31.561]                 }
[10:22:31.561]             }
[10:22:31.561]         }))
[10:22:31.561]     }, error = function(ex) {
[10:22:31.561]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:31.561]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:31.561]                 ...future.rng), started = ...future.startTime, 
[10:22:31.561]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:31.561]             version = "1.8"), class = "FutureResult")
[10:22:31.561]     }, finally = {
[10:22:31.561]         if (!identical(...future.workdir, getwd())) 
[10:22:31.561]             setwd(...future.workdir)
[10:22:31.561]         {
[10:22:31.561]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:31.561]                 ...future.oldOptions$nwarnings <- NULL
[10:22:31.561]             }
[10:22:31.561]             base::options(...future.oldOptions)
[10:22:31.561]             if (.Platform$OS.type == "windows") {
[10:22:31.561]                 old_names <- names(...future.oldEnvVars)
[10:22:31.561]                 envs <- base::Sys.getenv()
[10:22:31.561]                 names <- names(envs)
[10:22:31.561]                 common <- intersect(names, old_names)
[10:22:31.561]                 added <- setdiff(names, old_names)
[10:22:31.561]                 removed <- setdiff(old_names, names)
[10:22:31.561]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:31.561]                   envs[common]]
[10:22:31.561]                 NAMES <- toupper(changed)
[10:22:31.561]                 args <- list()
[10:22:31.561]                 for (kk in seq_along(NAMES)) {
[10:22:31.561]                   name <- changed[[kk]]
[10:22:31.561]                   NAME <- NAMES[[kk]]
[10:22:31.561]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:31.561]                     next
[10:22:31.561]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:31.561]                 }
[10:22:31.561]                 NAMES <- toupper(added)
[10:22:31.561]                 for (kk in seq_along(NAMES)) {
[10:22:31.561]                   name <- added[[kk]]
[10:22:31.561]                   NAME <- NAMES[[kk]]
[10:22:31.561]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:31.561]                     next
[10:22:31.561]                   args[[name]] <- ""
[10:22:31.561]                 }
[10:22:31.561]                 NAMES <- toupper(removed)
[10:22:31.561]                 for (kk in seq_along(NAMES)) {
[10:22:31.561]                   name <- removed[[kk]]
[10:22:31.561]                   NAME <- NAMES[[kk]]
[10:22:31.561]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:31.561]                     next
[10:22:31.561]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:31.561]                 }
[10:22:31.561]                 if (length(args) > 0) 
[10:22:31.561]                   base::do.call(base::Sys.setenv, args = args)
[10:22:31.561]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:31.561]             }
[10:22:31.561]             else {
[10:22:31.561]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:31.561]             }
[10:22:31.561]             {
[10:22:31.561]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:31.561]                   0L) {
[10:22:31.561]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:31.561]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:31.561]                   base::options(opts)
[10:22:31.561]                 }
[10:22:31.561]                 {
[10:22:31.561]                   {
[10:22:31.561]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:31.561]                     NULL
[10:22:31.561]                   }
[10:22:31.561]                   options(future.plan = NULL)
[10:22:31.561]                   if (is.na(NA_character_)) 
[10:22:31.561]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:31.561]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:31.561]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:31.561]                     .init = FALSE)
[10:22:31.561]                 }
[10:22:31.561]             }
[10:22:31.561]         }
[10:22:31.561]     })
[10:22:31.561]     if (TRUE) {
[10:22:31.561]         base::sink(type = "output", split = FALSE)
[10:22:31.561]         if (TRUE) {
[10:22:31.561]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:31.561]         }
[10:22:31.561]         else {
[10:22:31.561]             ...future.result["stdout"] <- base::list(NULL)
[10:22:31.561]         }
[10:22:31.561]         base::close(...future.stdout)
[10:22:31.561]         ...future.stdout <- NULL
[10:22:31.561]     }
[10:22:31.561]     ...future.result$conditions <- ...future.conditions
[10:22:31.561]     ...future.result$finished <- base::Sys.time()
[10:22:31.561]     ...future.result
[10:22:31.561] }
[10:22:31.564] requestCore(): workers = 2
[10:22:31.564] Poll #1 (0): usedCores() = 2, workers = 2
[10:22:31.575] result() for MulticoreFuture ...
[10:22:31.576] result() for MulticoreFuture ...
[10:22:31.576] result() for MulticoreFuture ... done
[10:22:31.577] result() for MulticoreFuture ... done
[10:22:31.577] result() for MulticoreFuture ...
[10:22:31.577] result() for MulticoreFuture ... done
[10:22:31.580] MulticoreFuture started
[10:22:31.580] - Launch lazy future ... done
[10:22:31.580] run() for ‘MulticoreFuture’ ... done
[10:22:31.581] plan(): Setting new future strategy stack:
[10:22:31.582] getGlobalsAndPackages() ...
[10:22:31.582] Searching for globals...
[10:22:31.581] List of future strategies:
[10:22:31.581] 1. sequential:
[10:22:31.581]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:31.581]    - tweaked: FALSE
[10:22:31.581]    - call: NULL
[10:22:31.582] plan(): nbrOfWorkers() = 1
[10:22:31.584] - globals found: [2] ‘{’, ‘Sys.sleep’
[10:22:31.584] Searching for globals ... DONE
[10:22:31.584] Resolving globals: FALSE
[10:22:31.585] plan(): Setting new future strategy stack:
[10:22:31.585] 
[10:22:31.585] 
[10:22:31.585] getGlobalsAndPackages() ... DONE
[10:22:31.585] List of future strategies:
[10:22:31.585] 1. multicore:
[10:22:31.585]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:31.585]    - tweaked: FALSE
[10:22:31.585]    - call: plan(strategy)
[10:22:31.586] run() for ‘Future’ ...
[10:22:31.586] - state: ‘created’
[10:22:31.586] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:31.588] plan(): nbrOfWorkers() = 2
[10:22:31.594] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:31.594] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:31.595]   - Field: ‘label’
[10:22:31.595]   - Field: ‘local’
[10:22:31.595]   - Field: ‘owner’
[10:22:31.596]   - Field: ‘envir’
[10:22:31.596]   - Field: ‘workers’
[10:22:31.596]   - Field: ‘packages’
[10:22:31.596]   - Field: ‘gc’
[10:22:31.597]   - Field: ‘job’
[10:22:31.597]   - Field: ‘conditions’
[10:22:31.597]   - Field: ‘expr’
[10:22:31.597]   - Field: ‘uuid’
[10:22:31.597]   - Field: ‘seed’
[10:22:31.598]   - Field: ‘version’
[10:22:31.598]   - Field: ‘result’
[10:22:31.598]   - Field: ‘asynchronous’
[10:22:31.598]   - Field: ‘calls’
[10:22:31.598]   - Field: ‘globals’
[10:22:31.599]   - Field: ‘stdout’
[10:22:31.599]   - Field: ‘earlySignal’
[10:22:31.599]   - Field: ‘lazy’
[10:22:31.599]   - Field: ‘state’
[10:22:31.599] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:31.599] - Launch lazy future ...
[10:22:31.600] Packages needed by the future expression (n = 0): <none>
[10:22:31.600] Packages needed by future strategies (n = 0): <none>
[10:22:31.601] {
[10:22:31.601]     {
[10:22:31.601]         {
[10:22:31.601]             ...future.startTime <- base::Sys.time()
[10:22:31.601]             {
[10:22:31.601]                 {
[10:22:31.601]                   {
[10:22:31.601]                     {
[10:22:31.601]                       base::local({
[10:22:31.601]                         has_future <- base::requireNamespace("future", 
[10:22:31.601]                           quietly = TRUE)
[10:22:31.601]                         if (has_future) {
[10:22:31.601]                           ns <- base::getNamespace("future")
[10:22:31.601]                           version <- ns[[".package"]][["version"]]
[10:22:31.601]                           if (is.null(version)) 
[10:22:31.601]                             version <- utils::packageVersion("future")
[10:22:31.601]                         }
[10:22:31.601]                         else {
[10:22:31.601]                           version <- NULL
[10:22:31.601]                         }
[10:22:31.601]                         if (!has_future || version < "1.8.0") {
[10:22:31.601]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:31.601]                             "", base::R.version$version.string), 
[10:22:31.601]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:31.601]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:31.601]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:31.601]                               "release", "version")], collapse = " "), 
[10:22:31.601]                             hostname = base::Sys.info()[["nodename"]])
[10:22:31.601]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:31.601]                             info)
[10:22:31.601]                           info <- base::paste(info, collapse = "; ")
[10:22:31.601]                           if (!has_future) {
[10:22:31.601]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:31.601]                               info)
[10:22:31.601]                           }
[10:22:31.601]                           else {
[10:22:31.601]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:31.601]                               info, version)
[10:22:31.601]                           }
[10:22:31.601]                           base::stop(msg)
[10:22:31.601]                         }
[10:22:31.601]                       })
[10:22:31.601]                     }
[10:22:31.601]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:31.601]                     base::options(mc.cores = 1L)
[10:22:31.601]                   }
[10:22:31.601]                   ...future.strategy.old <- future::plan("list")
[10:22:31.601]                   options(future.plan = NULL)
[10:22:31.601]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:31.601]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:31.601]                 }
[10:22:31.601]                 ...future.workdir <- getwd()
[10:22:31.601]             }
[10:22:31.601]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:31.601]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:31.601]         }
[10:22:31.601]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:31.601]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:31.601]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:31.601]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:31.601]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:31.601]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:31.601]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:31.601]             base::names(...future.oldOptions))
[10:22:31.601]     }
[10:22:31.601]     if (FALSE) {
[10:22:31.601]     }
[10:22:31.601]     else {
[10:22:31.601]         if (TRUE) {
[10:22:31.601]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:31.601]                 open = "w")
[10:22:31.601]         }
[10:22:31.601]         else {
[10:22:31.601]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:31.601]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:31.601]         }
[10:22:31.601]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:31.601]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:31.601]             base::sink(type = "output", split = FALSE)
[10:22:31.601]             base::close(...future.stdout)
[10:22:31.601]         }, add = TRUE)
[10:22:31.601]     }
[10:22:31.601]     ...future.frame <- base::sys.nframe()
[10:22:31.601]     ...future.conditions <- base::list()
[10:22:31.601]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:31.601]     if (FALSE) {
[10:22:31.601]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:31.601]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:31.601]     }
[10:22:31.601]     ...future.result <- base::tryCatch({
[10:22:31.601]         base::withCallingHandlers({
[10:22:31.601]             ...future.value <- base::withVisible(base::local({
[10:22:31.601]                 withCallingHandlers({
[10:22:31.601]                   {
[10:22:31.601]                     Sys.sleep(0.5)
[10:22:31.601]                     2
[10:22:31.601]                   }
[10:22:31.601]                 }, immediateCondition = function(cond) {
[10:22:31.601]                   save_rds <- function (object, pathname, ...) 
[10:22:31.601]                   {
[10:22:31.601]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:31.601]                     if (file_test("-f", pathname_tmp)) {
[10:22:31.601]                       fi_tmp <- file.info(pathname_tmp)
[10:22:31.601]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:31.601]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:31.601]                         fi_tmp[["mtime"]])
[10:22:31.601]                     }
[10:22:31.601]                     tryCatch({
[10:22:31.601]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:31.601]                     }, error = function(ex) {
[10:22:31.601]                       msg <- conditionMessage(ex)
[10:22:31.601]                       fi_tmp <- file.info(pathname_tmp)
[10:22:31.601]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:31.601]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:31.601]                         fi_tmp[["mtime"]], msg)
[10:22:31.601]                       ex$message <- msg
[10:22:31.601]                       stop(ex)
[10:22:31.601]                     })
[10:22:31.601]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:31.601]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:31.601]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:31.601]                       fi_tmp <- file.info(pathname_tmp)
[10:22:31.601]                       fi <- file.info(pathname)
[10:22:31.601]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:31.601]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:31.601]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:31.601]                         fi[["size"]], fi[["mtime"]])
[10:22:31.601]                       stop(msg)
[10:22:31.601]                     }
[10:22:31.601]                     invisible(pathname)
[10:22:31.601]                   }
[10:22:31.601]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:31.601]                     rootPath = tempdir()) 
[10:22:31.601]                   {
[10:22:31.601]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:31.601]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:31.601]                       tmpdir = path, fileext = ".rds")
[10:22:31.601]                     save_rds(obj, file)
[10:22:31.601]                   }
[10:22:31.601]                   saveImmediateCondition(cond, path = "/tmp/RtmpzsJv4f/.future/immediateConditions")
[10:22:31.601]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:31.601]                   {
[10:22:31.601]                     inherits <- base::inherits
[10:22:31.601]                     invokeRestart <- base::invokeRestart
[10:22:31.601]                     is.null <- base::is.null
[10:22:31.601]                     muffled <- FALSE
[10:22:31.601]                     if (inherits(cond, "message")) {
[10:22:31.601]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:31.601]                       if (muffled) 
[10:22:31.601]                         invokeRestart("muffleMessage")
[10:22:31.601]                     }
[10:22:31.601]                     else if (inherits(cond, "warning")) {
[10:22:31.601]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:31.601]                       if (muffled) 
[10:22:31.601]                         invokeRestart("muffleWarning")
[10:22:31.601]                     }
[10:22:31.601]                     else if (inherits(cond, "condition")) {
[10:22:31.601]                       if (!is.null(pattern)) {
[10:22:31.601]                         computeRestarts <- base::computeRestarts
[10:22:31.601]                         grepl <- base::grepl
[10:22:31.601]                         restarts <- computeRestarts(cond)
[10:22:31.601]                         for (restart in restarts) {
[10:22:31.601]                           name <- restart$name
[10:22:31.601]                           if (is.null(name)) 
[10:22:31.601]                             next
[10:22:31.601]                           if (!grepl(pattern, name)) 
[10:22:31.601]                             next
[10:22:31.601]                           invokeRestart(restart)
[10:22:31.601]                           muffled <- TRUE
[10:22:31.601]                           break
[10:22:31.601]                         }
[10:22:31.601]                       }
[10:22:31.601]                     }
[10:22:31.601]                     invisible(muffled)
[10:22:31.601]                   }
[10:22:31.601]                   muffleCondition(cond)
[10:22:31.601]                 })
[10:22:31.601]             }))
[10:22:31.601]             future::FutureResult(value = ...future.value$value, 
[10:22:31.601]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:31.601]                   ...future.rng), globalenv = if (FALSE) 
[10:22:31.601]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:31.601]                     ...future.globalenv.names))
[10:22:31.601]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:31.601]         }, condition = base::local({
[10:22:31.601]             c <- base::c
[10:22:31.601]             inherits <- base::inherits
[10:22:31.601]             invokeRestart <- base::invokeRestart
[10:22:31.601]             length <- base::length
[10:22:31.601]             list <- base::list
[10:22:31.601]             seq.int <- base::seq.int
[10:22:31.601]             signalCondition <- base::signalCondition
[10:22:31.601]             sys.calls <- base::sys.calls
[10:22:31.601]             `[[` <- base::`[[`
[10:22:31.601]             `+` <- base::`+`
[10:22:31.601]             `<<-` <- base::`<<-`
[10:22:31.601]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:31.601]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:31.601]                   3L)]
[10:22:31.601]             }
[10:22:31.601]             function(cond) {
[10:22:31.601]                 is_error <- inherits(cond, "error")
[10:22:31.601]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:31.601]                   NULL)
[10:22:31.601]                 if (is_error) {
[10:22:31.601]                   sessionInformation <- function() {
[10:22:31.601]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:31.601]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:31.601]                       search = base::search(), system = base::Sys.info())
[10:22:31.601]                   }
[10:22:31.601]                   ...future.conditions[[length(...future.conditions) + 
[10:22:31.601]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:31.601]                     cond$call), session = sessionInformation(), 
[10:22:31.601]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:31.601]                   signalCondition(cond)
[10:22:31.601]                 }
[10:22:31.601]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:31.601]                 "immediateCondition"))) {
[10:22:31.601]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:31.601]                   ...future.conditions[[length(...future.conditions) + 
[10:22:31.601]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:31.601]                   if (TRUE && !signal) {
[10:22:31.601]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:31.601]                     {
[10:22:31.601]                       inherits <- base::inherits
[10:22:31.601]                       invokeRestart <- base::invokeRestart
[10:22:31.601]                       is.null <- base::is.null
[10:22:31.601]                       muffled <- FALSE
[10:22:31.601]                       if (inherits(cond, "message")) {
[10:22:31.601]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:31.601]                         if (muffled) 
[10:22:31.601]                           invokeRestart("muffleMessage")
[10:22:31.601]                       }
[10:22:31.601]                       else if (inherits(cond, "warning")) {
[10:22:31.601]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:31.601]                         if (muffled) 
[10:22:31.601]                           invokeRestart("muffleWarning")
[10:22:31.601]                       }
[10:22:31.601]                       else if (inherits(cond, "condition")) {
[10:22:31.601]                         if (!is.null(pattern)) {
[10:22:31.601]                           computeRestarts <- base::computeRestarts
[10:22:31.601]                           grepl <- base::grepl
[10:22:31.601]                           restarts <- computeRestarts(cond)
[10:22:31.601]                           for (restart in restarts) {
[10:22:31.601]                             name <- restart$name
[10:22:31.601]                             if (is.null(name)) 
[10:22:31.601]                               next
[10:22:31.601]                             if (!grepl(pattern, name)) 
[10:22:31.601]                               next
[10:22:31.601]                             invokeRestart(restart)
[10:22:31.601]                             muffled <- TRUE
[10:22:31.601]                             break
[10:22:31.601]                           }
[10:22:31.601]                         }
[10:22:31.601]                       }
[10:22:31.601]                       invisible(muffled)
[10:22:31.601]                     }
[10:22:31.601]                     muffleCondition(cond, pattern = "^muffle")
[10:22:31.601]                   }
[10:22:31.601]                 }
[10:22:31.601]                 else {
[10:22:31.601]                   if (TRUE) {
[10:22:31.601]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:31.601]                     {
[10:22:31.601]                       inherits <- base::inherits
[10:22:31.601]                       invokeRestart <- base::invokeRestart
[10:22:31.601]                       is.null <- base::is.null
[10:22:31.601]                       muffled <- FALSE
[10:22:31.601]                       if (inherits(cond, "message")) {
[10:22:31.601]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:31.601]                         if (muffled) 
[10:22:31.601]                           invokeRestart("muffleMessage")
[10:22:31.601]                       }
[10:22:31.601]                       else if (inherits(cond, "warning")) {
[10:22:31.601]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:31.601]                         if (muffled) 
[10:22:31.601]                           invokeRestart("muffleWarning")
[10:22:31.601]                       }
[10:22:31.601]                       else if (inherits(cond, "condition")) {
[10:22:31.601]                         if (!is.null(pattern)) {
[10:22:31.601]                           computeRestarts <- base::computeRestarts
[10:22:31.601]                           grepl <- base::grepl
[10:22:31.601]                           restarts <- computeRestarts(cond)
[10:22:31.601]                           for (restart in restarts) {
[10:22:31.601]                             name <- restart$name
[10:22:31.601]                             if (is.null(name)) 
[10:22:31.601]                               next
[10:22:31.601]                             if (!grepl(pattern, name)) 
[10:22:31.601]                               next
[10:22:31.601]                             invokeRestart(restart)
[10:22:31.601]                             muffled <- TRUE
[10:22:31.601]                             break
[10:22:31.601]                           }
[10:22:31.601]                         }
[10:22:31.601]                       }
[10:22:31.601]                       invisible(muffled)
[10:22:31.601]                     }
[10:22:31.601]                     muffleCondition(cond, pattern = "^muffle")
[10:22:31.601]                   }
[10:22:31.601]                 }
[10:22:31.601]             }
[10:22:31.601]         }))
[10:22:31.601]     }, error = function(ex) {
[10:22:31.601]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:31.601]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:31.601]                 ...future.rng), started = ...future.startTime, 
[10:22:31.601]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:31.601]             version = "1.8"), class = "FutureResult")
[10:22:31.601]     }, finally = {
[10:22:31.601]         if (!identical(...future.workdir, getwd())) 
[10:22:31.601]             setwd(...future.workdir)
[10:22:31.601]         {
[10:22:31.601]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:31.601]                 ...future.oldOptions$nwarnings <- NULL
[10:22:31.601]             }
[10:22:31.601]             base::options(...future.oldOptions)
[10:22:31.601]             if (.Platform$OS.type == "windows") {
[10:22:31.601]                 old_names <- names(...future.oldEnvVars)
[10:22:31.601]                 envs <- base::Sys.getenv()
[10:22:31.601]                 names <- names(envs)
[10:22:31.601]                 common <- intersect(names, old_names)
[10:22:31.601]                 added <- setdiff(names, old_names)
[10:22:31.601]                 removed <- setdiff(old_names, names)
[10:22:31.601]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:31.601]                   envs[common]]
[10:22:31.601]                 NAMES <- toupper(changed)
[10:22:31.601]                 args <- list()
[10:22:31.601]                 for (kk in seq_along(NAMES)) {
[10:22:31.601]                   name <- changed[[kk]]
[10:22:31.601]                   NAME <- NAMES[[kk]]
[10:22:31.601]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:31.601]                     next
[10:22:31.601]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:31.601]                 }
[10:22:31.601]                 NAMES <- toupper(added)
[10:22:31.601]                 for (kk in seq_along(NAMES)) {
[10:22:31.601]                   name <- added[[kk]]
[10:22:31.601]                   NAME <- NAMES[[kk]]
[10:22:31.601]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:31.601]                     next
[10:22:31.601]                   args[[name]] <- ""
[10:22:31.601]                 }
[10:22:31.601]                 NAMES <- toupper(removed)
[10:22:31.601]                 for (kk in seq_along(NAMES)) {
[10:22:31.601]                   name <- removed[[kk]]
[10:22:31.601]                   NAME <- NAMES[[kk]]
[10:22:31.601]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:31.601]                     next
[10:22:31.601]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:31.601]                 }
[10:22:31.601]                 if (length(args) > 0) 
[10:22:31.601]                   base::do.call(base::Sys.setenv, args = args)
[10:22:31.601]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:31.601]             }
[10:22:31.601]             else {
[10:22:31.601]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:31.601]             }
[10:22:31.601]             {
[10:22:31.601]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:31.601]                   0L) {
[10:22:31.601]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:31.601]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:31.601]                   base::options(opts)
[10:22:31.601]                 }
[10:22:31.601]                 {
[10:22:31.601]                   {
[10:22:31.601]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:31.601]                     NULL
[10:22:31.601]                   }
[10:22:31.601]                   options(future.plan = NULL)
[10:22:31.601]                   if (is.na(NA_character_)) 
[10:22:31.601]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:31.601]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:31.601]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:31.601]                     .init = FALSE)
[10:22:31.601]                 }
[10:22:31.601]             }
[10:22:31.601]         }
[10:22:31.601]     })
[10:22:31.601]     if (TRUE) {
[10:22:31.601]         base::sink(type = "output", split = FALSE)
[10:22:31.601]         if (TRUE) {
[10:22:31.601]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:31.601]         }
[10:22:31.601]         else {
[10:22:31.601]             ...future.result["stdout"] <- base::list(NULL)
[10:22:31.601]         }
[10:22:31.601]         base::close(...future.stdout)
[10:22:31.601]         ...future.stdout <- NULL
[10:22:31.601]     }
[10:22:31.601]     ...future.result$conditions <- ...future.conditions
[10:22:31.601]     ...future.result$finished <- base::Sys.time()
[10:22:31.601]     ...future.result
[10:22:31.601] }
[10:22:31.604] requestCore(): workers = 2
[10:22:31.604] Poll #1 (0): usedCores() = 2, workers = 2
[10:22:31.615] result() for MulticoreFuture ...
[10:22:31.616] result() for MulticoreFuture ...
[10:22:31.616] result() for MulticoreFuture ... done
[10:22:31.616] result() for MulticoreFuture ... done
[10:22:31.616] result() for MulticoreFuture ...
[10:22:31.616] result() for MulticoreFuture ... done
[10:22:31.619] MulticoreFuture started
[10:22:31.620] - Launch lazy future ... done
[10:22:31.620] run() for ‘MulticoreFuture’ ... done
[10:22:31.620] plan(): Setting new future strategy stack:
[10:22:31.621] getGlobalsAndPackages() ...
[10:22:31.621] Searching for globals...
[10:22:31.621] List of future strategies:
[10:22:31.621] 1. sequential:
[10:22:31.621]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:31.621]    - tweaked: FALSE
[10:22:31.621]    - call: NULL
[10:22:31.622] plan(): nbrOfWorkers() = 1
[10:22:31.623] - globals found: [1] ‘{’
[10:22:31.623] Searching for globals ... DONE
[10:22:31.623] Resolving globals: FALSE
[10:22:31.624] 
[10:22:31.624] 
[10:22:31.624] getGlobalsAndPackages() ... DONE
[10:22:31.625] run() for ‘Future’ ...
[10:22:31.625] - state: ‘created’
[10:22:31.625] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:31.628] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:31.628] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:31.629]   - Field: ‘label’
[10:22:31.629]   - Field: ‘local’
[10:22:31.629]   - Field: ‘owner’
[10:22:31.629]   - Field: ‘envir’
[10:22:31.629]   - Field: ‘workers’
[10:22:31.629]   - Field: ‘packages’
[10:22:31.630]   - Field: ‘gc’
[10:22:31.630]   - Field: ‘job’
[10:22:31.630]   - Field: ‘conditions’
[10:22:31.630]   - Field: ‘expr’
[10:22:31.630]   - Field: ‘uuid’
[10:22:31.630]   - Field: ‘seed’
[10:22:31.630]   - Field: ‘version’
[10:22:31.631]   - Field: ‘result’
[10:22:31.631]   - Field: ‘asynchronous’
[10:22:31.631]   - Field: ‘calls’
[10:22:31.631]   - Field: ‘globals’
[10:22:31.631]   - Field: ‘stdout’
[10:22:31.631]   - Field: ‘earlySignal’
[10:22:31.631]   - Field: ‘lazy’
[10:22:31.632]   - Field: ‘state’
[10:22:31.632] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:31.632] - Launch lazy future ...
[10:22:31.632] Packages needed by the future expression (n = 0): <none>
[10:22:31.633] Packages needed by future strategies (n = 0): <none>
[10:22:31.633] {
[10:22:31.633]     {
[10:22:31.633]         {
[10:22:31.633]             ...future.startTime <- base::Sys.time()
[10:22:31.633]             {
[10:22:31.633]                 {
[10:22:31.633]                   {
[10:22:31.633]                     {
[10:22:31.633]                       base::local({
[10:22:31.633]                         has_future <- base::requireNamespace("future", 
[10:22:31.633]                           quietly = TRUE)
[10:22:31.633]                         if (has_future) {
[10:22:31.633]                           ns <- base::getNamespace("future")
[10:22:31.633]                           version <- ns[[".package"]][["version"]]
[10:22:31.633]                           if (is.null(version)) 
[10:22:31.633]                             version <- utils::packageVersion("future")
[10:22:31.633]                         }
[10:22:31.633]                         else {
[10:22:31.633]                           version <- NULL
[10:22:31.633]                         }
[10:22:31.633]                         if (!has_future || version < "1.8.0") {
[10:22:31.633]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:31.633]                             "", base::R.version$version.string), 
[10:22:31.633]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:31.633]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:31.633]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:31.633]                               "release", "version")], collapse = " "), 
[10:22:31.633]                             hostname = base::Sys.info()[["nodename"]])
[10:22:31.633]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:31.633]                             info)
[10:22:31.633]                           info <- base::paste(info, collapse = "; ")
[10:22:31.633]                           if (!has_future) {
[10:22:31.633]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:31.633]                               info)
[10:22:31.633]                           }
[10:22:31.633]                           else {
[10:22:31.633]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:31.633]                               info, version)
[10:22:31.633]                           }
[10:22:31.633]                           base::stop(msg)
[10:22:31.633]                         }
[10:22:31.633]                       })
[10:22:31.633]                     }
[10:22:31.633]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:31.633]                     base::options(mc.cores = 1L)
[10:22:31.633]                   }
[10:22:31.633]                   ...future.strategy.old <- future::plan("list")
[10:22:31.633]                   options(future.plan = NULL)
[10:22:31.633]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:31.633]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:31.633]                 }
[10:22:31.633]                 ...future.workdir <- getwd()
[10:22:31.633]             }
[10:22:31.633]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:31.633]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:31.633]         }
[10:22:31.633]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:31.633]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:31.633]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:31.633]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:31.633]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:31.633]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:31.633]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:31.633]             base::names(...future.oldOptions))
[10:22:31.633]     }
[10:22:31.633]     if (FALSE) {
[10:22:31.633]     }
[10:22:31.633]     else {
[10:22:31.633]         if (TRUE) {
[10:22:31.633]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:31.633]                 open = "w")
[10:22:31.633]         }
[10:22:31.633]         else {
[10:22:31.633]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:31.633]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:31.633]         }
[10:22:31.633]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:31.633]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:31.633]             base::sink(type = "output", split = FALSE)
[10:22:31.633]             base::close(...future.stdout)
[10:22:31.633]         }, add = TRUE)
[10:22:31.633]     }
[10:22:31.633]     ...future.frame <- base::sys.nframe()
[10:22:31.633]     ...future.conditions <- base::list()
[10:22:31.633]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:31.633]     if (FALSE) {
[10:22:31.633]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:31.633]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:31.633]     }
[10:22:31.633]     ...future.result <- base::tryCatch({
[10:22:31.633]         base::withCallingHandlers({
[10:22:31.633]             ...future.value <- base::withVisible(base::local({
[10:22:31.633]                 withCallingHandlers({
[10:22:31.633]                   {
[10:22:31.633]                     3
[10:22:31.633]                   }
[10:22:31.633]                 }, immediateCondition = function(cond) {
[10:22:31.633]                   save_rds <- function (object, pathname, ...) 
[10:22:31.633]                   {
[10:22:31.633]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:31.633]                     if (file_test("-f", pathname_tmp)) {
[10:22:31.633]                       fi_tmp <- file.info(pathname_tmp)
[10:22:31.633]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:31.633]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:31.633]                         fi_tmp[["mtime"]])
[10:22:31.633]                     }
[10:22:31.633]                     tryCatch({
[10:22:31.633]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:31.633]                     }, error = function(ex) {
[10:22:31.633]                       msg <- conditionMessage(ex)
[10:22:31.633]                       fi_tmp <- file.info(pathname_tmp)
[10:22:31.633]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:31.633]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:31.633]                         fi_tmp[["mtime"]], msg)
[10:22:31.633]                       ex$message <- msg
[10:22:31.633]                       stop(ex)
[10:22:31.633]                     })
[10:22:31.633]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:31.633]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:31.633]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:31.633]                       fi_tmp <- file.info(pathname_tmp)
[10:22:31.633]                       fi <- file.info(pathname)
[10:22:31.633]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:31.633]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:31.633]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:31.633]                         fi[["size"]], fi[["mtime"]])
[10:22:31.633]                       stop(msg)
[10:22:31.633]                     }
[10:22:31.633]                     invisible(pathname)
[10:22:31.633]                   }
[10:22:31.633]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:31.633]                     rootPath = tempdir()) 
[10:22:31.633]                   {
[10:22:31.633]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:31.633]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:31.633]                       tmpdir = path, fileext = ".rds")
[10:22:31.633]                     save_rds(obj, file)
[10:22:31.633]                   }
[10:22:31.633]                   saveImmediateCondition(cond, path = "/tmp/RtmpzsJv4f/.future/immediateConditions")
[10:22:31.633]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:31.633]                   {
[10:22:31.633]                     inherits <- base::inherits
[10:22:31.633]                     invokeRestart <- base::invokeRestart
[10:22:31.633]                     is.null <- base::is.null
[10:22:31.633]                     muffled <- FALSE
[10:22:31.633]                     if (inherits(cond, "message")) {
[10:22:31.633]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:31.633]                       if (muffled) 
[10:22:31.633]                         invokeRestart("muffleMessage")
[10:22:31.633]                     }
[10:22:31.633]                     else if (inherits(cond, "warning")) {
[10:22:31.633]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:31.633]                       if (muffled) 
[10:22:31.633]                         invokeRestart("muffleWarning")
[10:22:31.633]                     }
[10:22:31.633]                     else if (inherits(cond, "condition")) {
[10:22:31.633]                       if (!is.null(pattern)) {
[10:22:31.633]                         computeRestarts <- base::computeRestarts
[10:22:31.633]                         grepl <- base::grepl
[10:22:31.633]                         restarts <- computeRestarts(cond)
[10:22:31.633]                         for (restart in restarts) {
[10:22:31.633]                           name <- restart$name
[10:22:31.633]                           if (is.null(name)) 
[10:22:31.633]                             next
[10:22:31.633]                           if (!grepl(pattern, name)) 
[10:22:31.633]                             next
[10:22:31.633]                           invokeRestart(restart)
[10:22:31.633]                           muffled <- TRUE
[10:22:31.633]                           break
[10:22:31.633]                         }
[10:22:31.633]                       }
[10:22:31.633]                     }
[10:22:31.633]                     invisible(muffled)
[10:22:31.633]                   }
[10:22:31.633]                   muffleCondition(cond)
[10:22:31.633]                 })
[10:22:31.633]             }))
[10:22:31.633]             future::FutureResult(value = ...future.value$value, 
[10:22:31.633]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:31.633]                   ...future.rng), globalenv = if (FALSE) 
[10:22:31.633]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:31.633]                     ...future.globalenv.names))
[10:22:31.633]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:31.633]         }, condition = base::local({
[10:22:31.633]             c <- base::c
[10:22:31.633]             inherits <- base::inherits
[10:22:31.633]             invokeRestart <- base::invokeRestart
[10:22:31.633]             length <- base::length
[10:22:31.633]             list <- base::list
[10:22:31.633]             seq.int <- base::seq.int
[10:22:31.633]             signalCondition <- base::signalCondition
[10:22:31.633]             sys.calls <- base::sys.calls
[10:22:31.633]             `[[` <- base::`[[`
[10:22:31.633]             `+` <- base::`+`
[10:22:31.633]             `<<-` <- base::`<<-`
[10:22:31.633]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:31.633]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:31.633]                   3L)]
[10:22:31.633]             }
[10:22:31.633]             function(cond) {
[10:22:31.633]                 is_error <- inherits(cond, "error")
[10:22:31.633]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:31.633]                   NULL)
[10:22:31.633]                 if (is_error) {
[10:22:31.633]                   sessionInformation <- function() {
[10:22:31.633]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:31.633]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:31.633]                       search = base::search(), system = base::Sys.info())
[10:22:31.633]                   }
[10:22:31.633]                   ...future.conditions[[length(...future.conditions) + 
[10:22:31.633]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:31.633]                     cond$call), session = sessionInformation(), 
[10:22:31.633]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:31.633]                   signalCondition(cond)
[10:22:31.633]                 }
[10:22:31.633]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:31.633]                 "immediateCondition"))) {
[10:22:31.633]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:31.633]                   ...future.conditions[[length(...future.conditions) + 
[10:22:31.633]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:31.633]                   if (TRUE && !signal) {
[10:22:31.633]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:31.633]                     {
[10:22:31.633]                       inherits <- base::inherits
[10:22:31.633]                       invokeRestart <- base::invokeRestart
[10:22:31.633]                       is.null <- base::is.null
[10:22:31.633]                       muffled <- FALSE
[10:22:31.633]                       if (inherits(cond, "message")) {
[10:22:31.633]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:31.633]                         if (muffled) 
[10:22:31.633]                           invokeRestart("muffleMessage")
[10:22:31.633]                       }
[10:22:31.633]                       else if (inherits(cond, "warning")) {
[10:22:31.633]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:31.633]                         if (muffled) 
[10:22:31.633]                           invokeRestart("muffleWarning")
[10:22:31.633]                       }
[10:22:31.633]                       else if (inherits(cond, "condition")) {
[10:22:31.633]                         if (!is.null(pattern)) {
[10:22:31.633]                           computeRestarts <- base::computeRestarts
[10:22:31.633]                           grepl <- base::grepl
[10:22:31.633]                           restarts <- computeRestarts(cond)
[10:22:31.633]                           for (restart in restarts) {
[10:22:31.633]                             name <- restart$name
[10:22:31.633]                             if (is.null(name)) 
[10:22:31.633]                               next
[10:22:31.633]                             if (!grepl(pattern, name)) 
[10:22:31.633]                               next
[10:22:31.633]                             invokeRestart(restart)
[10:22:31.633]                             muffled <- TRUE
[10:22:31.633]                             break
[10:22:31.633]                           }
[10:22:31.633]                         }
[10:22:31.633]                       }
[10:22:31.633]                       invisible(muffled)
[10:22:31.633]                     }
[10:22:31.633]                     muffleCondition(cond, pattern = "^muffle")
[10:22:31.633]                   }
[10:22:31.633]                 }
[10:22:31.633]                 else {
[10:22:31.633]                   if (TRUE) {
[10:22:31.633]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:31.633]                     {
[10:22:31.633]                       inherits <- base::inherits
[10:22:31.633]                       invokeRestart <- base::invokeRestart
[10:22:31.633]                       is.null <- base::is.null
[10:22:31.633]                       muffled <- FALSE
[10:22:31.633]                       if (inherits(cond, "message")) {
[10:22:31.633]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:31.633]                         if (muffled) 
[10:22:31.633]                           invokeRestart("muffleMessage")
[10:22:31.633]                       }
[10:22:31.633]                       else if (inherits(cond, "warning")) {
[10:22:31.633]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:31.633]                         if (muffled) 
[10:22:31.633]                           invokeRestart("muffleWarning")
[10:22:31.633]                       }
[10:22:31.633]                       else if (inherits(cond, "condition")) {
[10:22:31.633]                         if (!is.null(pattern)) {
[10:22:31.633]                           computeRestarts <- base::computeRestarts
[10:22:31.633]                           grepl <- base::grepl
[10:22:31.633]                           restarts <- computeRestarts(cond)
[10:22:31.633]                           for (restart in restarts) {
[10:22:31.633]                             name <- restart$name
[10:22:31.633]                             if (is.null(name)) 
[10:22:31.633]                               next
[10:22:31.633]                             if (!grepl(pattern, name)) 
[10:22:31.633]                               next
[10:22:31.633]                             invokeRestart(restart)
[10:22:31.633]                             muffled <- TRUE
[10:22:31.633]                             break
[10:22:31.633]                           }
[10:22:31.633]                         }
[10:22:31.633]                       }
[10:22:31.633]                       invisible(muffled)
[10:22:31.633]                     }
[10:22:31.633]                     muffleCondition(cond, pattern = "^muffle")
[10:22:31.633]                   }
[10:22:31.633]                 }
[10:22:31.633]             }
[10:22:31.633]         }))
[10:22:31.633]     }, error = function(ex) {
[10:22:31.633]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:31.633]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:31.633]                 ...future.rng), started = ...future.startTime, 
[10:22:31.633]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:31.633]             version = "1.8"), class = "FutureResult")
[10:22:31.633]     }, finally = {
[10:22:31.633]         if (!identical(...future.workdir, getwd())) 
[10:22:31.633]             setwd(...future.workdir)
[10:22:31.633]         {
[10:22:31.633]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:31.633]                 ...future.oldOptions$nwarnings <- NULL
[10:22:31.633]             }
[10:22:31.633]             base::options(...future.oldOptions)
[10:22:31.633]             if (.Platform$OS.type == "windows") {
[10:22:31.633]                 old_names <- names(...future.oldEnvVars)
[10:22:31.633]                 envs <- base::Sys.getenv()
[10:22:31.633]                 names <- names(envs)
[10:22:31.633]                 common <- intersect(names, old_names)
[10:22:31.633]                 added <- setdiff(names, old_names)
[10:22:31.633]                 removed <- setdiff(old_names, names)
[10:22:31.633]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:31.633]                   envs[common]]
[10:22:31.633]                 NAMES <- toupper(changed)
[10:22:31.633]                 args <- list()
[10:22:31.633]                 for (kk in seq_along(NAMES)) {
[10:22:31.633]                   name <- changed[[kk]]
[10:22:31.633]                   NAME <- NAMES[[kk]]
[10:22:31.633]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:31.633]                     next
[10:22:31.633]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:31.633]                 }
[10:22:31.633]                 NAMES <- toupper(added)
[10:22:31.633]                 for (kk in seq_along(NAMES)) {
[10:22:31.633]                   name <- added[[kk]]
[10:22:31.633]                   NAME <- NAMES[[kk]]
[10:22:31.633]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:31.633]                     next
[10:22:31.633]                   args[[name]] <- ""
[10:22:31.633]                 }
[10:22:31.633]                 NAMES <- toupper(removed)
[10:22:31.633]                 for (kk in seq_along(NAMES)) {
[10:22:31.633]                   name <- removed[[kk]]
[10:22:31.633]                   NAME <- NAMES[[kk]]
[10:22:31.633]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:31.633]                     next
[10:22:31.633]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:31.633]                 }
[10:22:31.633]                 if (length(args) > 0) 
[10:22:31.633]                   base::do.call(base::Sys.setenv, args = args)
[10:22:31.633]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:31.633]             }
[10:22:31.633]             else {
[10:22:31.633]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:31.633]             }
[10:22:31.633]             {
[10:22:31.633]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:31.633]                   0L) {
[10:22:31.633]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:31.633]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:31.633]                   base::options(opts)
[10:22:31.633]                 }
[10:22:31.633]                 {
[10:22:31.633]                   {
[10:22:31.633]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:31.633]                     NULL
[10:22:31.633]                   }
[10:22:31.633]                   options(future.plan = NULL)
[10:22:31.633]                   if (is.na(NA_character_)) 
[10:22:31.633]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:31.633]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:31.633]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:31.633]                     .init = FALSE)
[10:22:31.633]                 }
[10:22:31.633]             }
[10:22:31.633]         }
[10:22:31.633]     })
[10:22:31.633]     if (TRUE) {
[10:22:31.633]         base::sink(type = "output", split = FALSE)
[10:22:31.633]         if (TRUE) {
[10:22:31.633]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:31.633]         }
[10:22:31.633]         else {
[10:22:31.633]             ...future.result["stdout"] <- base::list(NULL)
[10:22:31.633]         }
[10:22:31.633]         base::close(...future.stdout)
[10:22:31.633]         ...future.stdout <- NULL
[10:22:31.633]     }
[10:22:31.633]     ...future.result$conditions <- ...future.conditions
[10:22:31.633]     ...future.result$finished <- base::Sys.time()
[10:22:31.633]     ...future.result
[10:22:31.633] }
[10:22:31.637] requestCore(): workers = 2
[10:22:31.637] Poll #1 (0): usedCores() = 2, workers = 2
[10:22:31.648] result() for MulticoreFuture ...
[10:22:31.649] result() for MulticoreFuture ...
[10:22:31.649] result() for MulticoreFuture ... done
[10:22:31.649] result() for MulticoreFuture ... done
[10:22:31.649] result() for MulticoreFuture ...
[10:22:31.649] result() for MulticoreFuture ... done
[10:22:31.651] MulticoreFuture started
[10:22:31.652] - Launch lazy future ... done
[10:22:31.652] run() for ‘MulticoreFuture’ ... done
[10:22:31.653] plan(): Setting new future strategy stack:
[10:22:31.653] List of future strategies:
[10:22:31.653] 1. sequential:
[10:22:31.653]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:31.653]    - tweaked: FALSE
[10:22:31.653]    - call: NULL
[10:22:31.654] resolve() on list environment ...
[10:22:31.654] plan(): nbrOfWorkers() = 1
[10:22:31.654]  recursive: 0
[10:22:31.656]  length: 4
[10:22:31.656]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:22:31.657] Future #1
[10:22:31.657]  length: 3 (resolved future 1)
[10:22:31.657] plan(): Setting new future strategy stack:
[10:22:31.657] List of future strategies:
[10:22:31.657] 1. multicore:
[10:22:31.657]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:31.657]    - tweaked: FALSE
[10:22:31.657]    - call: plan(strategy)
[10:22:31.660] plan(): nbrOfWorkers() = 2
[10:22:31.668] Future #3
[10:22:31.668]  length: 2 (resolved future 3)
[10:22:31.668]  length: 1 (resolved future 4)
[10:22:32.125] plan(): Setting new future strategy stack:
[10:22:32.125] List of future strategies:
[10:22:32.125] 1. multicore:
[10:22:32.125]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:32.125]    - tweaked: FALSE
[10:22:32.125]    - call: plan(strategy)
[10:22:32.127] plan(): nbrOfWorkers() = 2
[10:22:32.128] Future #2
[10:22:32.128]  length: 0 (resolved future 2)
[10:22:32.128] resolve() on list environment ... DONE
[10:22:32.129] resolve() on list environment ...
[10:22:32.129]  recursive: 0
[10:22:32.130]  length: 4
[10:22:32.130]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:22:32.131] Future #1
[10:22:32.131]  length: 3 (resolved future 1)
[10:22:32.131] Future #2
[10:22:32.131]  length: 2 (resolved future 2)
[10:22:32.132] Future #3
[10:22:32.132]  length: 1 (resolved future 3)
[10:22:32.132]  length: 0 (resolved future 4)
[10:22:32.132] resolve() on list environment ... DONE
[10:22:32.137] resolve() on list environment ...
[10:22:32.137]  recursive: 0
[10:22:32.140]  length: 4
[10:22:32.140]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:22:32.140] Future #1
[10:22:32.141]  length: 3 (resolved future 1)
[10:22:32.141] Future #2
[10:22:32.141]  length: 2 (resolved future 2)
[10:22:32.142] Future #3
[10:22:32.142]  length: 1 (resolved future 3)
[10:22:32.142]  length: 0 (resolved future 4)
[10:22:32.142] resolve() on list environment ... DONE
[10:22:32.143] resolve() on list environment ...
[10:22:32.143]  recursive: 0
[10:22:32.144]  length: 4
[10:22:32.145]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:22:32.145] Future #1
[10:22:32.145]  length: 3 (resolved future 1)
[10:22:32.145] Future #2
[10:22:32.145]  length: 2 (resolved future 2)
[10:22:32.146] Future #3
[10:22:32.146]  length: 1 (resolved future 3)
[10:22:32.146]  length: 0 (resolved future 4)
[10:22:32.146] resolve() on list environment ... DONE
[10:22:32.147] resolve() on list environment ...
[10:22:32.147]  recursive: 0
[10:22:32.148]  length: 4
[10:22:32.148]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:22:32.148] Future #1
[10:22:32.148] result() for MulticoreFuture ...
[10:22:32.149] result() for MulticoreFuture ... done
[10:22:32.149] result() for MulticoreFuture ...
[10:22:32.149] result() for MulticoreFuture ... done
[10:22:32.149]  length: 3 (resolved future 1)
[10:22:32.149] Future #2
[10:22:32.149] result() for MulticoreFuture ...
[10:22:32.150] result() for MulticoreFuture ...
[10:22:32.150] result() for MulticoreFuture ... done
[10:22:32.150] result() for MulticoreFuture ... done
[10:22:32.151] result() for MulticoreFuture ...
[10:22:32.151] result() for MulticoreFuture ... done
[10:22:32.151]  length: 2 (resolved future 2)
[10:22:32.151] Future #3
[10:22:32.151] result() for MulticoreFuture ...
[10:22:32.152] result() for MulticoreFuture ...
[10:22:32.152] result() for MulticoreFuture ... done
[10:22:32.152] result() for MulticoreFuture ... done
[10:22:32.152] result() for MulticoreFuture ...
[10:22:32.153] result() for MulticoreFuture ... done
[10:22:32.153]  length: 1 (resolved future 3)
[10:22:32.153]  length: 0 (resolved future 4)
[10:22:32.153] resolve() on list environment ... DONE
[10:22:32.154] resolve() on list environment ...
[10:22:32.154]  recursive: 99
[10:22:32.155]  length: 4
[10:22:32.155]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:22:32.156] Future #1
[10:22:32.156] result() for MulticoreFuture ...
[10:22:32.156] result() for MulticoreFuture ... done
[10:22:32.156] result() for MulticoreFuture ...
[10:22:32.156] result() for MulticoreFuture ... done
[10:22:32.156] A MulticoreFuture was resolved
[10:22:32.157]  length: 3 (resolved future 1)
[10:22:32.157] Future #2
[10:22:32.157] result() for MulticoreFuture ...
[10:22:32.157] result() for MulticoreFuture ... done
[10:22:32.157] result() for MulticoreFuture ...
[10:22:32.157] result() for MulticoreFuture ... done
[10:22:32.157] A MulticoreFuture was resolved
[10:22:32.157]  length: 2 (resolved future 2)
[10:22:32.158] Future #3
[10:22:32.158] result() for MulticoreFuture ...
[10:22:32.158] result() for MulticoreFuture ... done
[10:22:32.158] result() for MulticoreFuture ...
[10:22:32.158] result() for MulticoreFuture ... done
[10:22:32.158] A MulticoreFuture was resolved
[10:22:32.158]  length: 1 (resolved future 3)
[10:22:32.158]  length: 0 (resolved future 4)
[10:22:32.158] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('multicore') ...
- plan('multisession') ...
[10:22:32.159] plan(): Setting new future strategy stack:
[10:22:32.159] List of future strategies:
[10:22:32.159] 1. multisession:
[10:22:32.159]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:22:32.159]    - tweaked: FALSE
[10:22:32.159]    - call: plan(strategy)
[10:22:32.160] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:22:32.160] multisession:
[10:22:32.160] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:22:32.160] - tweaked: FALSE
[10:22:32.160] - call: plan(strategy)
[10:22:32.164] getGlobalsAndPackages() ...
[10:22:32.164] Not searching for globals
[10:22:32.164] - globals: [0] <none>
[10:22:32.164] getGlobalsAndPackages() ... DONE
[10:22:32.647] Packages needed by the future expression (n = 0): <none>
[10:22:32.647] Packages needed by future strategies (n = 0): <none>
[10:22:32.647] {
[10:22:32.647]     {
[10:22:32.647]         {
[10:22:32.647]             ...future.startTime <- base::Sys.time()
[10:22:32.647]             {
[10:22:32.647]                 {
[10:22:32.647]                   {
[10:22:32.647]                     {
[10:22:32.647]                       base::local({
[10:22:32.647]                         has_future <- base::requireNamespace("future", 
[10:22:32.647]                           quietly = TRUE)
[10:22:32.647]                         if (has_future) {
[10:22:32.647]                           ns <- base::getNamespace("future")
[10:22:32.647]                           version <- ns[[".package"]][["version"]]
[10:22:32.647]                           if (is.null(version)) 
[10:22:32.647]                             version <- utils::packageVersion("future")
[10:22:32.647]                         }
[10:22:32.647]                         else {
[10:22:32.647]                           version <- NULL
[10:22:32.647]                         }
[10:22:32.647]                         if (!has_future || version < "1.8.0") {
[10:22:32.647]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:32.647]                             "", base::R.version$version.string), 
[10:22:32.647]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:32.647]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:32.647]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:32.647]                               "release", "version")], collapse = " "), 
[10:22:32.647]                             hostname = base::Sys.info()[["nodename"]])
[10:22:32.647]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:32.647]                             info)
[10:22:32.647]                           info <- base::paste(info, collapse = "; ")
[10:22:32.647]                           if (!has_future) {
[10:22:32.647]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:32.647]                               info)
[10:22:32.647]                           }
[10:22:32.647]                           else {
[10:22:32.647]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:32.647]                               info, version)
[10:22:32.647]                           }
[10:22:32.647]                           base::stop(msg)
[10:22:32.647]                         }
[10:22:32.647]                       })
[10:22:32.647]                     }
[10:22:32.647]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:32.647]                     base::options(mc.cores = 1L)
[10:22:32.647]                   }
[10:22:32.647]                   ...future.strategy.old <- future::plan("list")
[10:22:32.647]                   options(future.plan = NULL)
[10:22:32.647]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:32.647]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:32.647]                 }
[10:22:32.647]                 ...future.workdir <- getwd()
[10:22:32.647]             }
[10:22:32.647]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:32.647]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:32.647]         }
[10:22:32.647]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:32.647]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:32.647]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:32.647]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:32.647]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:32.647]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:32.647]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:32.647]             base::names(...future.oldOptions))
[10:22:32.647]     }
[10:22:32.647]     if (FALSE) {
[10:22:32.647]     }
[10:22:32.647]     else {
[10:22:32.647]         if (TRUE) {
[10:22:32.647]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:32.647]                 open = "w")
[10:22:32.647]         }
[10:22:32.647]         else {
[10:22:32.647]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:32.647]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:32.647]         }
[10:22:32.647]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:32.647]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:32.647]             base::sink(type = "output", split = FALSE)
[10:22:32.647]             base::close(...future.stdout)
[10:22:32.647]         }, add = TRUE)
[10:22:32.647]     }
[10:22:32.647]     ...future.frame <- base::sys.nframe()
[10:22:32.647]     ...future.conditions <- base::list()
[10:22:32.647]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:32.647]     if (FALSE) {
[10:22:32.647]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:32.647]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:32.647]     }
[10:22:32.647]     ...future.result <- base::tryCatch({
[10:22:32.647]         base::withCallingHandlers({
[10:22:32.647]             ...future.value <- base::withVisible(base::local({
[10:22:32.647]                 ...future.makeSendCondition <- base::local({
[10:22:32.647]                   sendCondition <- NULL
[10:22:32.647]                   function(frame = 1L) {
[10:22:32.647]                     if (is.function(sendCondition)) 
[10:22:32.647]                       return(sendCondition)
[10:22:32.647]                     ns <- getNamespace("parallel")
[10:22:32.647]                     if (exists("sendData", mode = "function", 
[10:22:32.647]                       envir = ns)) {
[10:22:32.647]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:32.647]                         envir = ns)
[10:22:32.647]                       envir <- sys.frame(frame)
[10:22:32.647]                       master <- NULL
[10:22:32.647]                       while (!identical(envir, .GlobalEnv) && 
[10:22:32.647]                         !identical(envir, emptyenv())) {
[10:22:32.647]                         if (exists("master", mode = "list", envir = envir, 
[10:22:32.647]                           inherits = FALSE)) {
[10:22:32.647]                           master <- get("master", mode = "list", 
[10:22:32.647]                             envir = envir, inherits = FALSE)
[10:22:32.647]                           if (inherits(master, c("SOCKnode", 
[10:22:32.647]                             "SOCK0node"))) {
[10:22:32.647]                             sendCondition <<- function(cond) {
[10:22:32.647]                               data <- list(type = "VALUE", value = cond, 
[10:22:32.647]                                 success = TRUE)
[10:22:32.647]                               parallel_sendData(master, data)
[10:22:32.647]                             }
[10:22:32.647]                             return(sendCondition)
[10:22:32.647]                           }
[10:22:32.647]                         }
[10:22:32.647]                         frame <- frame + 1L
[10:22:32.647]                         envir <- sys.frame(frame)
[10:22:32.647]                       }
[10:22:32.647]                     }
[10:22:32.647]                     sendCondition <<- function(cond) NULL
[10:22:32.647]                   }
[10:22:32.647]                 })
[10:22:32.647]                 withCallingHandlers({
[10:22:32.647]                   NA
[10:22:32.647]                 }, immediateCondition = function(cond) {
[10:22:32.647]                   sendCondition <- ...future.makeSendCondition()
[10:22:32.647]                   sendCondition(cond)
[10:22:32.647]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:32.647]                   {
[10:22:32.647]                     inherits <- base::inherits
[10:22:32.647]                     invokeRestart <- base::invokeRestart
[10:22:32.647]                     is.null <- base::is.null
[10:22:32.647]                     muffled <- FALSE
[10:22:32.647]                     if (inherits(cond, "message")) {
[10:22:32.647]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:32.647]                       if (muffled) 
[10:22:32.647]                         invokeRestart("muffleMessage")
[10:22:32.647]                     }
[10:22:32.647]                     else if (inherits(cond, "warning")) {
[10:22:32.647]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:32.647]                       if (muffled) 
[10:22:32.647]                         invokeRestart("muffleWarning")
[10:22:32.647]                     }
[10:22:32.647]                     else if (inherits(cond, "condition")) {
[10:22:32.647]                       if (!is.null(pattern)) {
[10:22:32.647]                         computeRestarts <- base::computeRestarts
[10:22:32.647]                         grepl <- base::grepl
[10:22:32.647]                         restarts <- computeRestarts(cond)
[10:22:32.647]                         for (restart in restarts) {
[10:22:32.647]                           name <- restart$name
[10:22:32.647]                           if (is.null(name)) 
[10:22:32.647]                             next
[10:22:32.647]                           if (!grepl(pattern, name)) 
[10:22:32.647]                             next
[10:22:32.647]                           invokeRestart(restart)
[10:22:32.647]                           muffled <- TRUE
[10:22:32.647]                           break
[10:22:32.647]                         }
[10:22:32.647]                       }
[10:22:32.647]                     }
[10:22:32.647]                     invisible(muffled)
[10:22:32.647]                   }
[10:22:32.647]                   muffleCondition(cond)
[10:22:32.647]                 })
[10:22:32.647]             }))
[10:22:32.647]             future::FutureResult(value = ...future.value$value, 
[10:22:32.647]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:32.647]                   ...future.rng), globalenv = if (FALSE) 
[10:22:32.647]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:32.647]                     ...future.globalenv.names))
[10:22:32.647]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:32.647]         }, condition = base::local({
[10:22:32.647]             c <- base::c
[10:22:32.647]             inherits <- base::inherits
[10:22:32.647]             invokeRestart <- base::invokeRestart
[10:22:32.647]             length <- base::length
[10:22:32.647]             list <- base::list
[10:22:32.647]             seq.int <- base::seq.int
[10:22:32.647]             signalCondition <- base::signalCondition
[10:22:32.647]             sys.calls <- base::sys.calls
[10:22:32.647]             `[[` <- base::`[[`
[10:22:32.647]             `+` <- base::`+`
[10:22:32.647]             `<<-` <- base::`<<-`
[10:22:32.647]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:32.647]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:32.647]                   3L)]
[10:22:32.647]             }
[10:22:32.647]             function(cond) {
[10:22:32.647]                 is_error <- inherits(cond, "error")
[10:22:32.647]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:32.647]                   NULL)
[10:22:32.647]                 if (is_error) {
[10:22:32.647]                   sessionInformation <- function() {
[10:22:32.647]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:32.647]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:32.647]                       search = base::search(), system = base::Sys.info())
[10:22:32.647]                   }
[10:22:32.647]                   ...future.conditions[[length(...future.conditions) + 
[10:22:32.647]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:32.647]                     cond$call), session = sessionInformation(), 
[10:22:32.647]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:32.647]                   signalCondition(cond)
[10:22:32.647]                 }
[10:22:32.647]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:32.647]                 "immediateCondition"))) {
[10:22:32.647]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:32.647]                   ...future.conditions[[length(...future.conditions) + 
[10:22:32.647]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:32.647]                   if (TRUE && !signal) {
[10:22:32.647]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:32.647]                     {
[10:22:32.647]                       inherits <- base::inherits
[10:22:32.647]                       invokeRestart <- base::invokeRestart
[10:22:32.647]                       is.null <- base::is.null
[10:22:32.647]                       muffled <- FALSE
[10:22:32.647]                       if (inherits(cond, "message")) {
[10:22:32.647]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:32.647]                         if (muffled) 
[10:22:32.647]                           invokeRestart("muffleMessage")
[10:22:32.647]                       }
[10:22:32.647]                       else if (inherits(cond, "warning")) {
[10:22:32.647]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:32.647]                         if (muffled) 
[10:22:32.647]                           invokeRestart("muffleWarning")
[10:22:32.647]                       }
[10:22:32.647]                       else if (inherits(cond, "condition")) {
[10:22:32.647]                         if (!is.null(pattern)) {
[10:22:32.647]                           computeRestarts <- base::computeRestarts
[10:22:32.647]                           grepl <- base::grepl
[10:22:32.647]                           restarts <- computeRestarts(cond)
[10:22:32.647]                           for (restart in restarts) {
[10:22:32.647]                             name <- restart$name
[10:22:32.647]                             if (is.null(name)) 
[10:22:32.647]                               next
[10:22:32.647]                             if (!grepl(pattern, name)) 
[10:22:32.647]                               next
[10:22:32.647]                             invokeRestart(restart)
[10:22:32.647]                             muffled <- TRUE
[10:22:32.647]                             break
[10:22:32.647]                           }
[10:22:32.647]                         }
[10:22:32.647]                       }
[10:22:32.647]                       invisible(muffled)
[10:22:32.647]                     }
[10:22:32.647]                     muffleCondition(cond, pattern = "^muffle")
[10:22:32.647]                   }
[10:22:32.647]                 }
[10:22:32.647]                 else {
[10:22:32.647]                   if (TRUE) {
[10:22:32.647]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:32.647]                     {
[10:22:32.647]                       inherits <- base::inherits
[10:22:32.647]                       invokeRestart <- base::invokeRestart
[10:22:32.647]                       is.null <- base::is.null
[10:22:32.647]                       muffled <- FALSE
[10:22:32.647]                       if (inherits(cond, "message")) {
[10:22:32.647]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:32.647]                         if (muffled) 
[10:22:32.647]                           invokeRestart("muffleMessage")
[10:22:32.647]                       }
[10:22:32.647]                       else if (inherits(cond, "warning")) {
[10:22:32.647]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:32.647]                         if (muffled) 
[10:22:32.647]                           invokeRestart("muffleWarning")
[10:22:32.647]                       }
[10:22:32.647]                       else if (inherits(cond, "condition")) {
[10:22:32.647]                         if (!is.null(pattern)) {
[10:22:32.647]                           computeRestarts <- base::computeRestarts
[10:22:32.647]                           grepl <- base::grepl
[10:22:32.647]                           restarts <- computeRestarts(cond)
[10:22:32.647]                           for (restart in restarts) {
[10:22:32.647]                             name <- restart$name
[10:22:32.647]                             if (is.null(name)) 
[10:22:32.647]                               next
[10:22:32.647]                             if (!grepl(pattern, name)) 
[10:22:32.647]                               next
[10:22:32.647]                             invokeRestart(restart)
[10:22:32.647]                             muffled <- TRUE
[10:22:32.647]                             break
[10:22:32.647]                           }
[10:22:32.647]                         }
[10:22:32.647]                       }
[10:22:32.647]                       invisible(muffled)
[10:22:32.647]                     }
[10:22:32.647]                     muffleCondition(cond, pattern = "^muffle")
[10:22:32.647]                   }
[10:22:32.647]                 }
[10:22:32.647]             }
[10:22:32.647]         }))
[10:22:32.647]     }, error = function(ex) {
[10:22:32.647]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:32.647]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:32.647]                 ...future.rng), started = ...future.startTime, 
[10:22:32.647]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:32.647]             version = "1.8"), class = "FutureResult")
[10:22:32.647]     }, finally = {
[10:22:32.647]         if (!identical(...future.workdir, getwd())) 
[10:22:32.647]             setwd(...future.workdir)
[10:22:32.647]         {
[10:22:32.647]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:32.647]                 ...future.oldOptions$nwarnings <- NULL
[10:22:32.647]             }
[10:22:32.647]             base::options(...future.oldOptions)
[10:22:32.647]             if (.Platform$OS.type == "windows") {
[10:22:32.647]                 old_names <- names(...future.oldEnvVars)
[10:22:32.647]                 envs <- base::Sys.getenv()
[10:22:32.647]                 names <- names(envs)
[10:22:32.647]                 common <- intersect(names, old_names)
[10:22:32.647]                 added <- setdiff(names, old_names)
[10:22:32.647]                 removed <- setdiff(old_names, names)
[10:22:32.647]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:32.647]                   envs[common]]
[10:22:32.647]                 NAMES <- toupper(changed)
[10:22:32.647]                 args <- list()
[10:22:32.647]                 for (kk in seq_along(NAMES)) {
[10:22:32.647]                   name <- changed[[kk]]
[10:22:32.647]                   NAME <- NAMES[[kk]]
[10:22:32.647]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:32.647]                     next
[10:22:32.647]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:32.647]                 }
[10:22:32.647]                 NAMES <- toupper(added)
[10:22:32.647]                 for (kk in seq_along(NAMES)) {
[10:22:32.647]                   name <- added[[kk]]
[10:22:32.647]                   NAME <- NAMES[[kk]]
[10:22:32.647]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:32.647]                     next
[10:22:32.647]                   args[[name]] <- ""
[10:22:32.647]                 }
[10:22:32.647]                 NAMES <- toupper(removed)
[10:22:32.647]                 for (kk in seq_along(NAMES)) {
[10:22:32.647]                   name <- removed[[kk]]
[10:22:32.647]                   NAME <- NAMES[[kk]]
[10:22:32.647]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:32.647]                     next
[10:22:32.647]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:32.647]                 }
[10:22:32.647]                 if (length(args) > 0) 
[10:22:32.647]                   base::do.call(base::Sys.setenv, args = args)
[10:22:32.647]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:32.647]             }
[10:22:32.647]             else {
[10:22:32.647]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:32.647]             }
[10:22:32.647]             {
[10:22:32.647]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:32.647]                   0L) {
[10:22:32.647]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:32.647]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:32.647]                   base::options(opts)
[10:22:32.647]                 }
[10:22:32.647]                 {
[10:22:32.647]                   {
[10:22:32.647]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:32.647]                     NULL
[10:22:32.647]                   }
[10:22:32.647]                   options(future.plan = NULL)
[10:22:32.647]                   if (is.na(NA_character_)) 
[10:22:32.647]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:32.647]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:32.647]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:32.647]                     .init = FALSE)
[10:22:32.647]                 }
[10:22:32.647]             }
[10:22:32.647]         }
[10:22:32.647]     })
[10:22:32.647]     if (TRUE) {
[10:22:32.647]         base::sink(type = "output", split = FALSE)
[10:22:32.647]         if (TRUE) {
[10:22:32.647]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:32.647]         }
[10:22:32.647]         else {
[10:22:32.647]             ...future.result["stdout"] <- base::list(NULL)
[10:22:32.647]         }
[10:22:32.647]         base::close(...future.stdout)
[10:22:32.647]         ...future.stdout <- NULL
[10:22:32.647]     }
[10:22:32.647]     ...future.result$conditions <- ...future.conditions
[10:22:32.647]     ...future.result$finished <- base::Sys.time()
[10:22:32.647]     ...future.result
[10:22:32.647] }
[10:22:32.699] MultisessionFuture started
[10:22:32.699] result() for ClusterFuture ...
[10:22:32.700] receiveMessageFromWorker() for ClusterFuture ...
[10:22:32.700] - Validating connection of MultisessionFuture
[10:22:32.730] - received message: FutureResult
[10:22:32.730] - Received FutureResult
[10:22:32.731] - Erased future from FutureRegistry
[10:22:32.731] result() for ClusterFuture ...
[10:22:32.731] - result already collected: FutureResult
[10:22:32.731] result() for ClusterFuture ... done
[10:22:32.731] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:32.731] result() for ClusterFuture ... done
[10:22:32.731] result() for ClusterFuture ...
[10:22:32.731] - result already collected: FutureResult
[10:22:32.731] result() for ClusterFuture ... done
[10:22:32.731] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:22:32.733] plan(): nbrOfWorkers() = 2
*** resolve() for Future objects ...
- result = FALSE, recursive = FALSE ...
[10:22:32.734] getGlobalsAndPackages() ...
[10:22:32.734] Searching for globals...
[10:22:32.736] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:22:32.736] Searching for globals ... DONE
[10:22:32.736] Resolving globals: FALSE
[10:22:32.736] 
[10:22:32.736] 
[10:22:32.736] getGlobalsAndPackages() ... DONE
[10:22:32.737] run() for ‘Future’ ...
[10:22:32.737] - state: ‘created’
[10:22:32.737] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:32.750] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:32.751] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:32.751]   - Field: ‘node’
[10:22:32.751]   - Field: ‘label’
[10:22:32.751]   - Field: ‘local’
[10:22:32.751]   - Field: ‘owner’
[10:22:32.751]   - Field: ‘envir’
[10:22:32.751]   - Field: ‘workers’
[10:22:32.751]   - Field: ‘packages’
[10:22:32.751]   - Field: ‘gc’
[10:22:32.751]   - Field: ‘conditions’
[10:22:32.752]   - Field: ‘persistent’
[10:22:32.752]   - Field: ‘expr’
[10:22:32.752]   - Field: ‘uuid’
[10:22:32.752]   - Field: ‘seed’
[10:22:32.752]   - Field: ‘version’
[10:22:32.752]   - Field: ‘result’
[10:22:32.752]   - Field: ‘asynchronous’
[10:22:32.752]   - Field: ‘calls’
[10:22:32.752]   - Field: ‘globals’
[10:22:32.752]   - Field: ‘stdout’
[10:22:32.752]   - Field: ‘earlySignal’
[10:22:32.752]   - Field: ‘lazy’
[10:22:32.753]   - Field: ‘state’
[10:22:32.753] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:32.753] - Launch lazy future ...
[10:22:32.753] Packages needed by the future expression (n = 0): <none>
[10:22:32.753] Packages needed by future strategies (n = 0): <none>
[10:22:32.754] {
[10:22:32.754]     {
[10:22:32.754]         {
[10:22:32.754]             ...future.startTime <- base::Sys.time()
[10:22:32.754]             {
[10:22:32.754]                 {
[10:22:32.754]                   {
[10:22:32.754]                     {
[10:22:32.754]                       base::local({
[10:22:32.754]                         has_future <- base::requireNamespace("future", 
[10:22:32.754]                           quietly = TRUE)
[10:22:32.754]                         if (has_future) {
[10:22:32.754]                           ns <- base::getNamespace("future")
[10:22:32.754]                           version <- ns[[".package"]][["version"]]
[10:22:32.754]                           if (is.null(version)) 
[10:22:32.754]                             version <- utils::packageVersion("future")
[10:22:32.754]                         }
[10:22:32.754]                         else {
[10:22:32.754]                           version <- NULL
[10:22:32.754]                         }
[10:22:32.754]                         if (!has_future || version < "1.8.0") {
[10:22:32.754]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:32.754]                             "", base::R.version$version.string), 
[10:22:32.754]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:32.754]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:32.754]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:32.754]                               "release", "version")], collapse = " "), 
[10:22:32.754]                             hostname = base::Sys.info()[["nodename"]])
[10:22:32.754]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:32.754]                             info)
[10:22:32.754]                           info <- base::paste(info, collapse = "; ")
[10:22:32.754]                           if (!has_future) {
[10:22:32.754]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:32.754]                               info)
[10:22:32.754]                           }
[10:22:32.754]                           else {
[10:22:32.754]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:32.754]                               info, version)
[10:22:32.754]                           }
[10:22:32.754]                           base::stop(msg)
[10:22:32.754]                         }
[10:22:32.754]                       })
[10:22:32.754]                     }
[10:22:32.754]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:32.754]                     base::options(mc.cores = 1L)
[10:22:32.754]                   }
[10:22:32.754]                   ...future.strategy.old <- future::plan("list")
[10:22:32.754]                   options(future.plan = NULL)
[10:22:32.754]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:32.754]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:32.754]                 }
[10:22:32.754]                 ...future.workdir <- getwd()
[10:22:32.754]             }
[10:22:32.754]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:32.754]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:32.754]         }
[10:22:32.754]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:32.754]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:32.754]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:32.754]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:32.754]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:32.754]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:32.754]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:32.754]             base::names(...future.oldOptions))
[10:22:32.754]     }
[10:22:32.754]     if (FALSE) {
[10:22:32.754]     }
[10:22:32.754]     else {
[10:22:32.754]         if (TRUE) {
[10:22:32.754]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:32.754]                 open = "w")
[10:22:32.754]         }
[10:22:32.754]         else {
[10:22:32.754]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:32.754]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:32.754]         }
[10:22:32.754]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:32.754]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:32.754]             base::sink(type = "output", split = FALSE)
[10:22:32.754]             base::close(...future.stdout)
[10:22:32.754]         }, add = TRUE)
[10:22:32.754]     }
[10:22:32.754]     ...future.frame <- base::sys.nframe()
[10:22:32.754]     ...future.conditions <- base::list()
[10:22:32.754]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:32.754]     if (FALSE) {
[10:22:32.754]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:32.754]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:32.754]     }
[10:22:32.754]     ...future.result <- base::tryCatch({
[10:22:32.754]         base::withCallingHandlers({
[10:22:32.754]             ...future.value <- base::withVisible(base::local({
[10:22:32.754]                 ...future.makeSendCondition <- base::local({
[10:22:32.754]                   sendCondition <- NULL
[10:22:32.754]                   function(frame = 1L) {
[10:22:32.754]                     if (is.function(sendCondition)) 
[10:22:32.754]                       return(sendCondition)
[10:22:32.754]                     ns <- getNamespace("parallel")
[10:22:32.754]                     if (exists("sendData", mode = "function", 
[10:22:32.754]                       envir = ns)) {
[10:22:32.754]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:32.754]                         envir = ns)
[10:22:32.754]                       envir <- sys.frame(frame)
[10:22:32.754]                       master <- NULL
[10:22:32.754]                       while (!identical(envir, .GlobalEnv) && 
[10:22:32.754]                         !identical(envir, emptyenv())) {
[10:22:32.754]                         if (exists("master", mode = "list", envir = envir, 
[10:22:32.754]                           inherits = FALSE)) {
[10:22:32.754]                           master <- get("master", mode = "list", 
[10:22:32.754]                             envir = envir, inherits = FALSE)
[10:22:32.754]                           if (inherits(master, c("SOCKnode", 
[10:22:32.754]                             "SOCK0node"))) {
[10:22:32.754]                             sendCondition <<- function(cond) {
[10:22:32.754]                               data <- list(type = "VALUE", value = cond, 
[10:22:32.754]                                 success = TRUE)
[10:22:32.754]                               parallel_sendData(master, data)
[10:22:32.754]                             }
[10:22:32.754]                             return(sendCondition)
[10:22:32.754]                           }
[10:22:32.754]                         }
[10:22:32.754]                         frame <- frame + 1L
[10:22:32.754]                         envir <- sys.frame(frame)
[10:22:32.754]                       }
[10:22:32.754]                     }
[10:22:32.754]                     sendCondition <<- function(cond) NULL
[10:22:32.754]                   }
[10:22:32.754]                 })
[10:22:32.754]                 withCallingHandlers({
[10:22:32.754]                   {
[10:22:32.754]                     Sys.sleep(0.5)
[10:22:32.754]                     list(a = 1, b = 42L)
[10:22:32.754]                   }
[10:22:32.754]                 }, immediateCondition = function(cond) {
[10:22:32.754]                   sendCondition <- ...future.makeSendCondition()
[10:22:32.754]                   sendCondition(cond)
[10:22:32.754]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:32.754]                   {
[10:22:32.754]                     inherits <- base::inherits
[10:22:32.754]                     invokeRestart <- base::invokeRestart
[10:22:32.754]                     is.null <- base::is.null
[10:22:32.754]                     muffled <- FALSE
[10:22:32.754]                     if (inherits(cond, "message")) {
[10:22:32.754]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:32.754]                       if (muffled) 
[10:22:32.754]                         invokeRestart("muffleMessage")
[10:22:32.754]                     }
[10:22:32.754]                     else if (inherits(cond, "warning")) {
[10:22:32.754]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:32.754]                       if (muffled) 
[10:22:32.754]                         invokeRestart("muffleWarning")
[10:22:32.754]                     }
[10:22:32.754]                     else if (inherits(cond, "condition")) {
[10:22:32.754]                       if (!is.null(pattern)) {
[10:22:32.754]                         computeRestarts <- base::computeRestarts
[10:22:32.754]                         grepl <- base::grepl
[10:22:32.754]                         restarts <- computeRestarts(cond)
[10:22:32.754]                         for (restart in restarts) {
[10:22:32.754]                           name <- restart$name
[10:22:32.754]                           if (is.null(name)) 
[10:22:32.754]                             next
[10:22:32.754]                           if (!grepl(pattern, name)) 
[10:22:32.754]                             next
[10:22:32.754]                           invokeRestart(restart)
[10:22:32.754]                           muffled <- TRUE
[10:22:32.754]                           break
[10:22:32.754]                         }
[10:22:32.754]                       }
[10:22:32.754]                     }
[10:22:32.754]                     invisible(muffled)
[10:22:32.754]                   }
[10:22:32.754]                   muffleCondition(cond)
[10:22:32.754]                 })
[10:22:32.754]             }))
[10:22:32.754]             future::FutureResult(value = ...future.value$value, 
[10:22:32.754]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:32.754]                   ...future.rng), globalenv = if (FALSE) 
[10:22:32.754]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:32.754]                     ...future.globalenv.names))
[10:22:32.754]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:32.754]         }, condition = base::local({
[10:22:32.754]             c <- base::c
[10:22:32.754]             inherits <- base::inherits
[10:22:32.754]             invokeRestart <- base::invokeRestart
[10:22:32.754]             length <- base::length
[10:22:32.754]             list <- base::list
[10:22:32.754]             seq.int <- base::seq.int
[10:22:32.754]             signalCondition <- base::signalCondition
[10:22:32.754]             sys.calls <- base::sys.calls
[10:22:32.754]             `[[` <- base::`[[`
[10:22:32.754]             `+` <- base::`+`
[10:22:32.754]             `<<-` <- base::`<<-`
[10:22:32.754]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:32.754]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:32.754]                   3L)]
[10:22:32.754]             }
[10:22:32.754]             function(cond) {
[10:22:32.754]                 is_error <- inherits(cond, "error")
[10:22:32.754]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:32.754]                   NULL)
[10:22:32.754]                 if (is_error) {
[10:22:32.754]                   sessionInformation <- function() {
[10:22:32.754]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:32.754]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:32.754]                       search = base::search(), system = base::Sys.info())
[10:22:32.754]                   }
[10:22:32.754]                   ...future.conditions[[length(...future.conditions) + 
[10:22:32.754]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:32.754]                     cond$call), session = sessionInformation(), 
[10:22:32.754]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:32.754]                   signalCondition(cond)
[10:22:32.754]                 }
[10:22:32.754]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:32.754]                 "immediateCondition"))) {
[10:22:32.754]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:32.754]                   ...future.conditions[[length(...future.conditions) + 
[10:22:32.754]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:32.754]                   if (TRUE && !signal) {
[10:22:32.754]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:32.754]                     {
[10:22:32.754]                       inherits <- base::inherits
[10:22:32.754]                       invokeRestart <- base::invokeRestart
[10:22:32.754]                       is.null <- base::is.null
[10:22:32.754]                       muffled <- FALSE
[10:22:32.754]                       if (inherits(cond, "message")) {
[10:22:32.754]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:32.754]                         if (muffled) 
[10:22:32.754]                           invokeRestart("muffleMessage")
[10:22:32.754]                       }
[10:22:32.754]                       else if (inherits(cond, "warning")) {
[10:22:32.754]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:32.754]                         if (muffled) 
[10:22:32.754]                           invokeRestart("muffleWarning")
[10:22:32.754]                       }
[10:22:32.754]                       else if (inherits(cond, "condition")) {
[10:22:32.754]                         if (!is.null(pattern)) {
[10:22:32.754]                           computeRestarts <- base::computeRestarts
[10:22:32.754]                           grepl <- base::grepl
[10:22:32.754]                           restarts <- computeRestarts(cond)
[10:22:32.754]                           for (restart in restarts) {
[10:22:32.754]                             name <- restart$name
[10:22:32.754]                             if (is.null(name)) 
[10:22:32.754]                               next
[10:22:32.754]                             if (!grepl(pattern, name)) 
[10:22:32.754]                               next
[10:22:32.754]                             invokeRestart(restart)
[10:22:32.754]                             muffled <- TRUE
[10:22:32.754]                             break
[10:22:32.754]                           }
[10:22:32.754]                         }
[10:22:32.754]                       }
[10:22:32.754]                       invisible(muffled)
[10:22:32.754]                     }
[10:22:32.754]                     muffleCondition(cond, pattern = "^muffle")
[10:22:32.754]                   }
[10:22:32.754]                 }
[10:22:32.754]                 else {
[10:22:32.754]                   if (TRUE) {
[10:22:32.754]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:32.754]                     {
[10:22:32.754]                       inherits <- base::inherits
[10:22:32.754]                       invokeRestart <- base::invokeRestart
[10:22:32.754]                       is.null <- base::is.null
[10:22:32.754]                       muffled <- FALSE
[10:22:32.754]                       if (inherits(cond, "message")) {
[10:22:32.754]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:32.754]                         if (muffled) 
[10:22:32.754]                           invokeRestart("muffleMessage")
[10:22:32.754]                       }
[10:22:32.754]                       else if (inherits(cond, "warning")) {
[10:22:32.754]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:32.754]                         if (muffled) 
[10:22:32.754]                           invokeRestart("muffleWarning")
[10:22:32.754]                       }
[10:22:32.754]                       else if (inherits(cond, "condition")) {
[10:22:32.754]                         if (!is.null(pattern)) {
[10:22:32.754]                           computeRestarts <- base::computeRestarts
[10:22:32.754]                           grepl <- base::grepl
[10:22:32.754]                           restarts <- computeRestarts(cond)
[10:22:32.754]                           for (restart in restarts) {
[10:22:32.754]                             name <- restart$name
[10:22:32.754]                             if (is.null(name)) 
[10:22:32.754]                               next
[10:22:32.754]                             if (!grepl(pattern, name)) 
[10:22:32.754]                               next
[10:22:32.754]                             invokeRestart(restart)
[10:22:32.754]                             muffled <- TRUE
[10:22:32.754]                             break
[10:22:32.754]                           }
[10:22:32.754]                         }
[10:22:32.754]                       }
[10:22:32.754]                       invisible(muffled)
[10:22:32.754]                     }
[10:22:32.754]                     muffleCondition(cond, pattern = "^muffle")
[10:22:32.754]                   }
[10:22:32.754]                 }
[10:22:32.754]             }
[10:22:32.754]         }))
[10:22:32.754]     }, error = function(ex) {
[10:22:32.754]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:32.754]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:32.754]                 ...future.rng), started = ...future.startTime, 
[10:22:32.754]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:32.754]             version = "1.8"), class = "FutureResult")
[10:22:32.754]     }, finally = {
[10:22:32.754]         if (!identical(...future.workdir, getwd())) 
[10:22:32.754]             setwd(...future.workdir)
[10:22:32.754]         {
[10:22:32.754]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:32.754]                 ...future.oldOptions$nwarnings <- NULL
[10:22:32.754]             }
[10:22:32.754]             base::options(...future.oldOptions)
[10:22:32.754]             if (.Platform$OS.type == "windows") {
[10:22:32.754]                 old_names <- names(...future.oldEnvVars)
[10:22:32.754]                 envs <- base::Sys.getenv()
[10:22:32.754]                 names <- names(envs)
[10:22:32.754]                 common <- intersect(names, old_names)
[10:22:32.754]                 added <- setdiff(names, old_names)
[10:22:32.754]                 removed <- setdiff(old_names, names)
[10:22:32.754]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:32.754]                   envs[common]]
[10:22:32.754]                 NAMES <- toupper(changed)
[10:22:32.754]                 args <- list()
[10:22:32.754]                 for (kk in seq_along(NAMES)) {
[10:22:32.754]                   name <- changed[[kk]]
[10:22:32.754]                   NAME <- NAMES[[kk]]
[10:22:32.754]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:32.754]                     next
[10:22:32.754]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:32.754]                 }
[10:22:32.754]                 NAMES <- toupper(added)
[10:22:32.754]                 for (kk in seq_along(NAMES)) {
[10:22:32.754]                   name <- added[[kk]]
[10:22:32.754]                   NAME <- NAMES[[kk]]
[10:22:32.754]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:32.754]                     next
[10:22:32.754]                   args[[name]] <- ""
[10:22:32.754]                 }
[10:22:32.754]                 NAMES <- toupper(removed)
[10:22:32.754]                 for (kk in seq_along(NAMES)) {
[10:22:32.754]                   name <- removed[[kk]]
[10:22:32.754]                   NAME <- NAMES[[kk]]
[10:22:32.754]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:32.754]                     next
[10:22:32.754]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:32.754]                 }
[10:22:32.754]                 if (length(args) > 0) 
[10:22:32.754]                   base::do.call(base::Sys.setenv, args = args)
[10:22:32.754]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:32.754]             }
[10:22:32.754]             else {
[10:22:32.754]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:32.754]             }
[10:22:32.754]             {
[10:22:32.754]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:32.754]                   0L) {
[10:22:32.754]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:32.754]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:32.754]                   base::options(opts)
[10:22:32.754]                 }
[10:22:32.754]                 {
[10:22:32.754]                   {
[10:22:32.754]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:32.754]                     NULL
[10:22:32.754]                   }
[10:22:32.754]                   options(future.plan = NULL)
[10:22:32.754]                   if (is.na(NA_character_)) 
[10:22:32.754]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:32.754]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:32.754]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:32.754]                     .init = FALSE)
[10:22:32.754]                 }
[10:22:32.754]             }
[10:22:32.754]         }
[10:22:32.754]     })
[10:22:32.754]     if (TRUE) {
[10:22:32.754]         base::sink(type = "output", split = FALSE)
[10:22:32.754]         if (TRUE) {
[10:22:32.754]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:32.754]         }
[10:22:32.754]         else {
[10:22:32.754]             ...future.result["stdout"] <- base::list(NULL)
[10:22:32.754]         }
[10:22:32.754]         base::close(...future.stdout)
[10:22:32.754]         ...future.stdout <- NULL
[10:22:32.754]     }
[10:22:32.754]     ...future.result$conditions <- ...future.conditions
[10:22:32.754]     ...future.result$finished <- base::Sys.time()
[10:22:32.754]     ...future.result
[10:22:32.754] }
[10:22:32.757] MultisessionFuture started
[10:22:32.757] - Launch lazy future ... done
[10:22:32.757] run() for ‘MultisessionFuture’ ... done
[10:22:33.300] receiveMessageFromWorker() for ClusterFuture ...
[10:22:33.300] - Validating connection of MultisessionFuture
[10:22:33.300] - received message: FutureResult
[10:22:33.301] - Received FutureResult
[10:22:33.301] - Erased future from FutureRegistry
[10:22:33.301] result() for ClusterFuture ...
[10:22:33.301] - result already collected: FutureResult
[10:22:33.301] result() for ClusterFuture ... done
[10:22:33.301] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:33.301] A MultisessionFuture was resolved (result was not collected)
[10:22:33.301] getGlobalsAndPackages() ...
[10:22:33.301] Searching for globals...
[10:22:33.303] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:22:33.303] Searching for globals ... DONE
[10:22:33.303] Resolving globals: FALSE
[10:22:33.304] 
[10:22:33.304] 
[10:22:33.304] getGlobalsAndPackages() ... DONE
[10:22:33.304] run() for ‘Future’ ...
[10:22:33.304] - state: ‘created’
[10:22:33.304] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:33.319] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:33.319] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:33.319]   - Field: ‘node’
[10:22:33.320]   - Field: ‘label’
[10:22:33.320]   - Field: ‘local’
[10:22:33.320]   - Field: ‘owner’
[10:22:33.320]   - Field: ‘envir’
[10:22:33.320]   - Field: ‘workers’
[10:22:33.320]   - Field: ‘packages’
[10:22:33.320]   - Field: ‘gc’
[10:22:33.320]   - Field: ‘conditions’
[10:22:33.320]   - Field: ‘persistent’
[10:22:33.320]   - Field: ‘expr’
[10:22:33.321]   - Field: ‘uuid’
[10:22:33.321]   - Field: ‘seed’
[10:22:33.321]   - Field: ‘version’
[10:22:33.321]   - Field: ‘result’
[10:22:33.321]   - Field: ‘asynchronous’
[10:22:33.321]   - Field: ‘calls’
[10:22:33.321]   - Field: ‘globals’
[10:22:33.321]   - Field: ‘stdout’
[10:22:33.321]   - Field: ‘earlySignal’
[10:22:33.322]   - Field: ‘lazy’
[10:22:33.322]   - Field: ‘state’
[10:22:33.322] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:33.322] - Launch lazy future ...
[10:22:33.322] Packages needed by the future expression (n = 0): <none>
[10:22:33.322] Packages needed by future strategies (n = 0): <none>
[10:22:33.323] {
[10:22:33.323]     {
[10:22:33.323]         {
[10:22:33.323]             ...future.startTime <- base::Sys.time()
[10:22:33.323]             {
[10:22:33.323]                 {
[10:22:33.323]                   {
[10:22:33.323]                     {
[10:22:33.323]                       base::local({
[10:22:33.323]                         has_future <- base::requireNamespace("future", 
[10:22:33.323]                           quietly = TRUE)
[10:22:33.323]                         if (has_future) {
[10:22:33.323]                           ns <- base::getNamespace("future")
[10:22:33.323]                           version <- ns[[".package"]][["version"]]
[10:22:33.323]                           if (is.null(version)) 
[10:22:33.323]                             version <- utils::packageVersion("future")
[10:22:33.323]                         }
[10:22:33.323]                         else {
[10:22:33.323]                           version <- NULL
[10:22:33.323]                         }
[10:22:33.323]                         if (!has_future || version < "1.8.0") {
[10:22:33.323]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:33.323]                             "", base::R.version$version.string), 
[10:22:33.323]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:33.323]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:33.323]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:33.323]                               "release", "version")], collapse = " "), 
[10:22:33.323]                             hostname = base::Sys.info()[["nodename"]])
[10:22:33.323]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:33.323]                             info)
[10:22:33.323]                           info <- base::paste(info, collapse = "; ")
[10:22:33.323]                           if (!has_future) {
[10:22:33.323]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:33.323]                               info)
[10:22:33.323]                           }
[10:22:33.323]                           else {
[10:22:33.323]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:33.323]                               info, version)
[10:22:33.323]                           }
[10:22:33.323]                           base::stop(msg)
[10:22:33.323]                         }
[10:22:33.323]                       })
[10:22:33.323]                     }
[10:22:33.323]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:33.323]                     base::options(mc.cores = 1L)
[10:22:33.323]                   }
[10:22:33.323]                   ...future.strategy.old <- future::plan("list")
[10:22:33.323]                   options(future.plan = NULL)
[10:22:33.323]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:33.323]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:33.323]                 }
[10:22:33.323]                 ...future.workdir <- getwd()
[10:22:33.323]             }
[10:22:33.323]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:33.323]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:33.323]         }
[10:22:33.323]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:33.323]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:33.323]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:33.323]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:33.323]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:33.323]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:33.323]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:33.323]             base::names(...future.oldOptions))
[10:22:33.323]     }
[10:22:33.323]     if (FALSE) {
[10:22:33.323]     }
[10:22:33.323]     else {
[10:22:33.323]         if (TRUE) {
[10:22:33.323]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:33.323]                 open = "w")
[10:22:33.323]         }
[10:22:33.323]         else {
[10:22:33.323]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:33.323]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:33.323]         }
[10:22:33.323]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:33.323]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:33.323]             base::sink(type = "output", split = FALSE)
[10:22:33.323]             base::close(...future.stdout)
[10:22:33.323]         }, add = TRUE)
[10:22:33.323]     }
[10:22:33.323]     ...future.frame <- base::sys.nframe()
[10:22:33.323]     ...future.conditions <- base::list()
[10:22:33.323]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:33.323]     if (FALSE) {
[10:22:33.323]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:33.323]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:33.323]     }
[10:22:33.323]     ...future.result <- base::tryCatch({
[10:22:33.323]         base::withCallingHandlers({
[10:22:33.323]             ...future.value <- base::withVisible(base::local({
[10:22:33.323]                 ...future.makeSendCondition <- base::local({
[10:22:33.323]                   sendCondition <- NULL
[10:22:33.323]                   function(frame = 1L) {
[10:22:33.323]                     if (is.function(sendCondition)) 
[10:22:33.323]                       return(sendCondition)
[10:22:33.323]                     ns <- getNamespace("parallel")
[10:22:33.323]                     if (exists("sendData", mode = "function", 
[10:22:33.323]                       envir = ns)) {
[10:22:33.323]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:33.323]                         envir = ns)
[10:22:33.323]                       envir <- sys.frame(frame)
[10:22:33.323]                       master <- NULL
[10:22:33.323]                       while (!identical(envir, .GlobalEnv) && 
[10:22:33.323]                         !identical(envir, emptyenv())) {
[10:22:33.323]                         if (exists("master", mode = "list", envir = envir, 
[10:22:33.323]                           inherits = FALSE)) {
[10:22:33.323]                           master <- get("master", mode = "list", 
[10:22:33.323]                             envir = envir, inherits = FALSE)
[10:22:33.323]                           if (inherits(master, c("SOCKnode", 
[10:22:33.323]                             "SOCK0node"))) {
[10:22:33.323]                             sendCondition <<- function(cond) {
[10:22:33.323]                               data <- list(type = "VALUE", value = cond, 
[10:22:33.323]                                 success = TRUE)
[10:22:33.323]                               parallel_sendData(master, data)
[10:22:33.323]                             }
[10:22:33.323]                             return(sendCondition)
[10:22:33.323]                           }
[10:22:33.323]                         }
[10:22:33.323]                         frame <- frame + 1L
[10:22:33.323]                         envir <- sys.frame(frame)
[10:22:33.323]                       }
[10:22:33.323]                     }
[10:22:33.323]                     sendCondition <<- function(cond) NULL
[10:22:33.323]                   }
[10:22:33.323]                 })
[10:22:33.323]                 withCallingHandlers({
[10:22:33.323]                   {
[10:22:33.323]                     Sys.sleep(0.5)
[10:22:33.323]                     list(a = 1, b = 42L)
[10:22:33.323]                   }
[10:22:33.323]                 }, immediateCondition = function(cond) {
[10:22:33.323]                   sendCondition <- ...future.makeSendCondition()
[10:22:33.323]                   sendCondition(cond)
[10:22:33.323]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:33.323]                   {
[10:22:33.323]                     inherits <- base::inherits
[10:22:33.323]                     invokeRestart <- base::invokeRestart
[10:22:33.323]                     is.null <- base::is.null
[10:22:33.323]                     muffled <- FALSE
[10:22:33.323]                     if (inherits(cond, "message")) {
[10:22:33.323]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:33.323]                       if (muffled) 
[10:22:33.323]                         invokeRestart("muffleMessage")
[10:22:33.323]                     }
[10:22:33.323]                     else if (inherits(cond, "warning")) {
[10:22:33.323]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:33.323]                       if (muffled) 
[10:22:33.323]                         invokeRestart("muffleWarning")
[10:22:33.323]                     }
[10:22:33.323]                     else if (inherits(cond, "condition")) {
[10:22:33.323]                       if (!is.null(pattern)) {
[10:22:33.323]                         computeRestarts <- base::computeRestarts
[10:22:33.323]                         grepl <- base::grepl
[10:22:33.323]                         restarts <- computeRestarts(cond)
[10:22:33.323]                         for (restart in restarts) {
[10:22:33.323]                           name <- restart$name
[10:22:33.323]                           if (is.null(name)) 
[10:22:33.323]                             next
[10:22:33.323]                           if (!grepl(pattern, name)) 
[10:22:33.323]                             next
[10:22:33.323]                           invokeRestart(restart)
[10:22:33.323]                           muffled <- TRUE
[10:22:33.323]                           break
[10:22:33.323]                         }
[10:22:33.323]                       }
[10:22:33.323]                     }
[10:22:33.323]                     invisible(muffled)
[10:22:33.323]                   }
[10:22:33.323]                   muffleCondition(cond)
[10:22:33.323]                 })
[10:22:33.323]             }))
[10:22:33.323]             future::FutureResult(value = ...future.value$value, 
[10:22:33.323]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:33.323]                   ...future.rng), globalenv = if (FALSE) 
[10:22:33.323]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:33.323]                     ...future.globalenv.names))
[10:22:33.323]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:33.323]         }, condition = base::local({
[10:22:33.323]             c <- base::c
[10:22:33.323]             inherits <- base::inherits
[10:22:33.323]             invokeRestart <- base::invokeRestart
[10:22:33.323]             length <- base::length
[10:22:33.323]             list <- base::list
[10:22:33.323]             seq.int <- base::seq.int
[10:22:33.323]             signalCondition <- base::signalCondition
[10:22:33.323]             sys.calls <- base::sys.calls
[10:22:33.323]             `[[` <- base::`[[`
[10:22:33.323]             `+` <- base::`+`
[10:22:33.323]             `<<-` <- base::`<<-`
[10:22:33.323]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:33.323]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:33.323]                   3L)]
[10:22:33.323]             }
[10:22:33.323]             function(cond) {
[10:22:33.323]                 is_error <- inherits(cond, "error")
[10:22:33.323]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:33.323]                   NULL)
[10:22:33.323]                 if (is_error) {
[10:22:33.323]                   sessionInformation <- function() {
[10:22:33.323]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:33.323]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:33.323]                       search = base::search(), system = base::Sys.info())
[10:22:33.323]                   }
[10:22:33.323]                   ...future.conditions[[length(...future.conditions) + 
[10:22:33.323]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:33.323]                     cond$call), session = sessionInformation(), 
[10:22:33.323]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:33.323]                   signalCondition(cond)
[10:22:33.323]                 }
[10:22:33.323]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:33.323]                 "immediateCondition"))) {
[10:22:33.323]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:33.323]                   ...future.conditions[[length(...future.conditions) + 
[10:22:33.323]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:33.323]                   if (TRUE && !signal) {
[10:22:33.323]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:33.323]                     {
[10:22:33.323]                       inherits <- base::inherits
[10:22:33.323]                       invokeRestart <- base::invokeRestart
[10:22:33.323]                       is.null <- base::is.null
[10:22:33.323]                       muffled <- FALSE
[10:22:33.323]                       if (inherits(cond, "message")) {
[10:22:33.323]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:33.323]                         if (muffled) 
[10:22:33.323]                           invokeRestart("muffleMessage")
[10:22:33.323]                       }
[10:22:33.323]                       else if (inherits(cond, "warning")) {
[10:22:33.323]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:33.323]                         if (muffled) 
[10:22:33.323]                           invokeRestart("muffleWarning")
[10:22:33.323]                       }
[10:22:33.323]                       else if (inherits(cond, "condition")) {
[10:22:33.323]                         if (!is.null(pattern)) {
[10:22:33.323]                           computeRestarts <- base::computeRestarts
[10:22:33.323]                           grepl <- base::grepl
[10:22:33.323]                           restarts <- computeRestarts(cond)
[10:22:33.323]                           for (restart in restarts) {
[10:22:33.323]                             name <- restart$name
[10:22:33.323]                             if (is.null(name)) 
[10:22:33.323]                               next
[10:22:33.323]                             if (!grepl(pattern, name)) 
[10:22:33.323]                               next
[10:22:33.323]                             invokeRestart(restart)
[10:22:33.323]                             muffled <- TRUE
[10:22:33.323]                             break
[10:22:33.323]                           }
[10:22:33.323]                         }
[10:22:33.323]                       }
[10:22:33.323]                       invisible(muffled)
[10:22:33.323]                     }
[10:22:33.323]                     muffleCondition(cond, pattern = "^muffle")
[10:22:33.323]                   }
[10:22:33.323]                 }
[10:22:33.323]                 else {
[10:22:33.323]                   if (TRUE) {
[10:22:33.323]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:33.323]                     {
[10:22:33.323]                       inherits <- base::inherits
[10:22:33.323]                       invokeRestart <- base::invokeRestart
[10:22:33.323]                       is.null <- base::is.null
[10:22:33.323]                       muffled <- FALSE
[10:22:33.323]                       if (inherits(cond, "message")) {
[10:22:33.323]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:33.323]                         if (muffled) 
[10:22:33.323]                           invokeRestart("muffleMessage")
[10:22:33.323]                       }
[10:22:33.323]                       else if (inherits(cond, "warning")) {
[10:22:33.323]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:33.323]                         if (muffled) 
[10:22:33.323]                           invokeRestart("muffleWarning")
[10:22:33.323]                       }
[10:22:33.323]                       else if (inherits(cond, "condition")) {
[10:22:33.323]                         if (!is.null(pattern)) {
[10:22:33.323]                           computeRestarts <- base::computeRestarts
[10:22:33.323]                           grepl <- base::grepl
[10:22:33.323]                           restarts <- computeRestarts(cond)
[10:22:33.323]                           for (restart in restarts) {
[10:22:33.323]                             name <- restart$name
[10:22:33.323]                             if (is.null(name)) 
[10:22:33.323]                               next
[10:22:33.323]                             if (!grepl(pattern, name)) 
[10:22:33.323]                               next
[10:22:33.323]                             invokeRestart(restart)
[10:22:33.323]                             muffled <- TRUE
[10:22:33.323]                             break
[10:22:33.323]                           }
[10:22:33.323]                         }
[10:22:33.323]                       }
[10:22:33.323]                       invisible(muffled)
[10:22:33.323]                     }
[10:22:33.323]                     muffleCondition(cond, pattern = "^muffle")
[10:22:33.323]                   }
[10:22:33.323]                 }
[10:22:33.323]             }
[10:22:33.323]         }))
[10:22:33.323]     }, error = function(ex) {
[10:22:33.323]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:33.323]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:33.323]                 ...future.rng), started = ...future.startTime, 
[10:22:33.323]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:33.323]             version = "1.8"), class = "FutureResult")
[10:22:33.323]     }, finally = {
[10:22:33.323]         if (!identical(...future.workdir, getwd())) 
[10:22:33.323]             setwd(...future.workdir)
[10:22:33.323]         {
[10:22:33.323]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:33.323]                 ...future.oldOptions$nwarnings <- NULL
[10:22:33.323]             }
[10:22:33.323]             base::options(...future.oldOptions)
[10:22:33.323]             if (.Platform$OS.type == "windows") {
[10:22:33.323]                 old_names <- names(...future.oldEnvVars)
[10:22:33.323]                 envs <- base::Sys.getenv()
[10:22:33.323]                 names <- names(envs)
[10:22:33.323]                 common <- intersect(names, old_names)
[10:22:33.323]                 added <- setdiff(names, old_names)
[10:22:33.323]                 removed <- setdiff(old_names, names)
[10:22:33.323]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:33.323]                   envs[common]]
[10:22:33.323]                 NAMES <- toupper(changed)
[10:22:33.323]                 args <- list()
[10:22:33.323]                 for (kk in seq_along(NAMES)) {
[10:22:33.323]                   name <- changed[[kk]]
[10:22:33.323]                   NAME <- NAMES[[kk]]
[10:22:33.323]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:33.323]                     next
[10:22:33.323]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:33.323]                 }
[10:22:33.323]                 NAMES <- toupper(added)
[10:22:33.323]                 for (kk in seq_along(NAMES)) {
[10:22:33.323]                   name <- added[[kk]]
[10:22:33.323]                   NAME <- NAMES[[kk]]
[10:22:33.323]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:33.323]                     next
[10:22:33.323]                   args[[name]] <- ""
[10:22:33.323]                 }
[10:22:33.323]                 NAMES <- toupper(removed)
[10:22:33.323]                 for (kk in seq_along(NAMES)) {
[10:22:33.323]                   name <- removed[[kk]]
[10:22:33.323]                   NAME <- NAMES[[kk]]
[10:22:33.323]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:33.323]                     next
[10:22:33.323]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:33.323]                 }
[10:22:33.323]                 if (length(args) > 0) 
[10:22:33.323]                   base::do.call(base::Sys.setenv, args = args)
[10:22:33.323]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:33.323]             }
[10:22:33.323]             else {
[10:22:33.323]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:33.323]             }
[10:22:33.323]             {
[10:22:33.323]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:33.323]                   0L) {
[10:22:33.323]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:33.323]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:33.323]                   base::options(opts)
[10:22:33.323]                 }
[10:22:33.323]                 {
[10:22:33.323]                   {
[10:22:33.323]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:33.323]                     NULL
[10:22:33.323]                   }
[10:22:33.323]                   options(future.plan = NULL)
[10:22:33.323]                   if (is.na(NA_character_)) 
[10:22:33.323]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:33.323]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:33.323]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:33.323]                     .init = FALSE)
[10:22:33.323]                 }
[10:22:33.323]             }
[10:22:33.323]         }
[10:22:33.323]     })
[10:22:33.323]     if (TRUE) {
[10:22:33.323]         base::sink(type = "output", split = FALSE)
[10:22:33.323]         if (TRUE) {
[10:22:33.323]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:33.323]         }
[10:22:33.323]         else {
[10:22:33.323]             ...future.result["stdout"] <- base::list(NULL)
[10:22:33.323]         }
[10:22:33.323]         base::close(...future.stdout)
[10:22:33.323]         ...future.stdout <- NULL
[10:22:33.323]     }
[10:22:33.323]     ...future.result$conditions <- ...future.conditions
[10:22:33.323]     ...future.result$finished <- base::Sys.time()
[10:22:33.323]     ...future.result
[10:22:33.323] }
[10:22:33.326] MultisessionFuture started
[10:22:33.326] - Launch lazy future ... done
[10:22:33.327] run() for ‘MultisessionFuture’ ... done
[10:22:33.869] receiveMessageFromWorker() for ClusterFuture ...
[10:22:33.869] - Validating connection of MultisessionFuture
[10:22:33.870] - received message: FutureResult
[10:22:33.870] - Received FutureResult
[10:22:33.870] - Erased future from FutureRegistry
[10:22:33.870] result() for ClusterFuture ...
[10:22:33.870] - result already collected: FutureResult
[10:22:33.870] result() for ClusterFuture ... done
[10:22:33.870] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:33.870] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[10:22:33.871] getGlobalsAndPackages() ...
[10:22:33.871] Searching for globals...
[10:22:33.872] - globals found: [2] ‘list’, ‘stop’
[10:22:33.872] Searching for globals ... DONE
[10:22:33.872] Resolving globals: FALSE
[10:22:33.872] 
[10:22:33.872] 
[10:22:33.872] getGlobalsAndPackages() ... DONE
[10:22:33.873] run() for ‘Future’ ...
[10:22:33.873] - state: ‘created’
[10:22:33.873] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:33.888] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:33.888] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:33.888]   - Field: ‘node’
[10:22:33.888]   - Field: ‘label’
[10:22:33.888]   - Field: ‘local’
[10:22:33.888]   - Field: ‘owner’
[10:22:33.888]   - Field: ‘envir’
[10:22:33.888]   - Field: ‘workers’
[10:22:33.888]   - Field: ‘packages’
[10:22:33.888]   - Field: ‘gc’
[10:22:33.889]   - Field: ‘conditions’
[10:22:33.889]   - Field: ‘persistent’
[10:22:33.889]   - Field: ‘expr’
[10:22:33.889]   - Field: ‘uuid’
[10:22:33.889]   - Field: ‘seed’
[10:22:33.889]   - Field: ‘version’
[10:22:33.889]   - Field: ‘result’
[10:22:33.889]   - Field: ‘asynchronous’
[10:22:33.889]   - Field: ‘calls’
[10:22:33.889]   - Field: ‘globals’
[10:22:33.890]   - Field: ‘stdout’
[10:22:33.890]   - Field: ‘earlySignal’
[10:22:33.890]   - Field: ‘lazy’
[10:22:33.890]   - Field: ‘state’
[10:22:33.890] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:33.890] - Launch lazy future ...
[10:22:33.890] Packages needed by the future expression (n = 0): <none>
[10:22:33.891] Packages needed by future strategies (n = 0): <none>
[10:22:33.891] {
[10:22:33.891]     {
[10:22:33.891]         {
[10:22:33.891]             ...future.startTime <- base::Sys.time()
[10:22:33.891]             {
[10:22:33.891]                 {
[10:22:33.891]                   {
[10:22:33.891]                     {
[10:22:33.891]                       base::local({
[10:22:33.891]                         has_future <- base::requireNamespace("future", 
[10:22:33.891]                           quietly = TRUE)
[10:22:33.891]                         if (has_future) {
[10:22:33.891]                           ns <- base::getNamespace("future")
[10:22:33.891]                           version <- ns[[".package"]][["version"]]
[10:22:33.891]                           if (is.null(version)) 
[10:22:33.891]                             version <- utils::packageVersion("future")
[10:22:33.891]                         }
[10:22:33.891]                         else {
[10:22:33.891]                           version <- NULL
[10:22:33.891]                         }
[10:22:33.891]                         if (!has_future || version < "1.8.0") {
[10:22:33.891]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:33.891]                             "", base::R.version$version.string), 
[10:22:33.891]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:33.891]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:33.891]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:33.891]                               "release", "version")], collapse = " "), 
[10:22:33.891]                             hostname = base::Sys.info()[["nodename"]])
[10:22:33.891]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:33.891]                             info)
[10:22:33.891]                           info <- base::paste(info, collapse = "; ")
[10:22:33.891]                           if (!has_future) {
[10:22:33.891]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:33.891]                               info)
[10:22:33.891]                           }
[10:22:33.891]                           else {
[10:22:33.891]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:33.891]                               info, version)
[10:22:33.891]                           }
[10:22:33.891]                           base::stop(msg)
[10:22:33.891]                         }
[10:22:33.891]                       })
[10:22:33.891]                     }
[10:22:33.891]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:33.891]                     base::options(mc.cores = 1L)
[10:22:33.891]                   }
[10:22:33.891]                   ...future.strategy.old <- future::plan("list")
[10:22:33.891]                   options(future.plan = NULL)
[10:22:33.891]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:33.891]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:33.891]                 }
[10:22:33.891]                 ...future.workdir <- getwd()
[10:22:33.891]             }
[10:22:33.891]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:33.891]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:33.891]         }
[10:22:33.891]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:33.891]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:33.891]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:33.891]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:33.891]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:33.891]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:33.891]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:33.891]             base::names(...future.oldOptions))
[10:22:33.891]     }
[10:22:33.891]     if (FALSE) {
[10:22:33.891]     }
[10:22:33.891]     else {
[10:22:33.891]         if (TRUE) {
[10:22:33.891]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:33.891]                 open = "w")
[10:22:33.891]         }
[10:22:33.891]         else {
[10:22:33.891]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:33.891]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:33.891]         }
[10:22:33.891]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:33.891]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:33.891]             base::sink(type = "output", split = FALSE)
[10:22:33.891]             base::close(...future.stdout)
[10:22:33.891]         }, add = TRUE)
[10:22:33.891]     }
[10:22:33.891]     ...future.frame <- base::sys.nframe()
[10:22:33.891]     ...future.conditions <- base::list()
[10:22:33.891]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:33.891]     if (FALSE) {
[10:22:33.891]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:33.891]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:33.891]     }
[10:22:33.891]     ...future.result <- base::tryCatch({
[10:22:33.891]         base::withCallingHandlers({
[10:22:33.891]             ...future.value <- base::withVisible(base::local({
[10:22:33.891]                 ...future.makeSendCondition <- base::local({
[10:22:33.891]                   sendCondition <- NULL
[10:22:33.891]                   function(frame = 1L) {
[10:22:33.891]                     if (is.function(sendCondition)) 
[10:22:33.891]                       return(sendCondition)
[10:22:33.891]                     ns <- getNamespace("parallel")
[10:22:33.891]                     if (exists("sendData", mode = "function", 
[10:22:33.891]                       envir = ns)) {
[10:22:33.891]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:33.891]                         envir = ns)
[10:22:33.891]                       envir <- sys.frame(frame)
[10:22:33.891]                       master <- NULL
[10:22:33.891]                       while (!identical(envir, .GlobalEnv) && 
[10:22:33.891]                         !identical(envir, emptyenv())) {
[10:22:33.891]                         if (exists("master", mode = "list", envir = envir, 
[10:22:33.891]                           inherits = FALSE)) {
[10:22:33.891]                           master <- get("master", mode = "list", 
[10:22:33.891]                             envir = envir, inherits = FALSE)
[10:22:33.891]                           if (inherits(master, c("SOCKnode", 
[10:22:33.891]                             "SOCK0node"))) {
[10:22:33.891]                             sendCondition <<- function(cond) {
[10:22:33.891]                               data <- list(type = "VALUE", value = cond, 
[10:22:33.891]                                 success = TRUE)
[10:22:33.891]                               parallel_sendData(master, data)
[10:22:33.891]                             }
[10:22:33.891]                             return(sendCondition)
[10:22:33.891]                           }
[10:22:33.891]                         }
[10:22:33.891]                         frame <- frame + 1L
[10:22:33.891]                         envir <- sys.frame(frame)
[10:22:33.891]                       }
[10:22:33.891]                     }
[10:22:33.891]                     sendCondition <<- function(cond) NULL
[10:22:33.891]                   }
[10:22:33.891]                 })
[10:22:33.891]                 withCallingHandlers({
[10:22:33.891]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:22:33.891]                 }, immediateCondition = function(cond) {
[10:22:33.891]                   sendCondition <- ...future.makeSendCondition()
[10:22:33.891]                   sendCondition(cond)
[10:22:33.891]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:33.891]                   {
[10:22:33.891]                     inherits <- base::inherits
[10:22:33.891]                     invokeRestart <- base::invokeRestart
[10:22:33.891]                     is.null <- base::is.null
[10:22:33.891]                     muffled <- FALSE
[10:22:33.891]                     if (inherits(cond, "message")) {
[10:22:33.891]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:33.891]                       if (muffled) 
[10:22:33.891]                         invokeRestart("muffleMessage")
[10:22:33.891]                     }
[10:22:33.891]                     else if (inherits(cond, "warning")) {
[10:22:33.891]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:33.891]                       if (muffled) 
[10:22:33.891]                         invokeRestart("muffleWarning")
[10:22:33.891]                     }
[10:22:33.891]                     else if (inherits(cond, "condition")) {
[10:22:33.891]                       if (!is.null(pattern)) {
[10:22:33.891]                         computeRestarts <- base::computeRestarts
[10:22:33.891]                         grepl <- base::grepl
[10:22:33.891]                         restarts <- computeRestarts(cond)
[10:22:33.891]                         for (restart in restarts) {
[10:22:33.891]                           name <- restart$name
[10:22:33.891]                           if (is.null(name)) 
[10:22:33.891]                             next
[10:22:33.891]                           if (!grepl(pattern, name)) 
[10:22:33.891]                             next
[10:22:33.891]                           invokeRestart(restart)
[10:22:33.891]                           muffled <- TRUE
[10:22:33.891]                           break
[10:22:33.891]                         }
[10:22:33.891]                       }
[10:22:33.891]                     }
[10:22:33.891]                     invisible(muffled)
[10:22:33.891]                   }
[10:22:33.891]                   muffleCondition(cond)
[10:22:33.891]                 })
[10:22:33.891]             }))
[10:22:33.891]             future::FutureResult(value = ...future.value$value, 
[10:22:33.891]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:33.891]                   ...future.rng), globalenv = if (FALSE) 
[10:22:33.891]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:33.891]                     ...future.globalenv.names))
[10:22:33.891]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:33.891]         }, condition = base::local({
[10:22:33.891]             c <- base::c
[10:22:33.891]             inherits <- base::inherits
[10:22:33.891]             invokeRestart <- base::invokeRestart
[10:22:33.891]             length <- base::length
[10:22:33.891]             list <- base::list
[10:22:33.891]             seq.int <- base::seq.int
[10:22:33.891]             signalCondition <- base::signalCondition
[10:22:33.891]             sys.calls <- base::sys.calls
[10:22:33.891]             `[[` <- base::`[[`
[10:22:33.891]             `+` <- base::`+`
[10:22:33.891]             `<<-` <- base::`<<-`
[10:22:33.891]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:33.891]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:33.891]                   3L)]
[10:22:33.891]             }
[10:22:33.891]             function(cond) {
[10:22:33.891]                 is_error <- inherits(cond, "error")
[10:22:33.891]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:33.891]                   NULL)
[10:22:33.891]                 if (is_error) {
[10:22:33.891]                   sessionInformation <- function() {
[10:22:33.891]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:33.891]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:33.891]                       search = base::search(), system = base::Sys.info())
[10:22:33.891]                   }
[10:22:33.891]                   ...future.conditions[[length(...future.conditions) + 
[10:22:33.891]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:33.891]                     cond$call), session = sessionInformation(), 
[10:22:33.891]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:33.891]                   signalCondition(cond)
[10:22:33.891]                 }
[10:22:33.891]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:33.891]                 "immediateCondition"))) {
[10:22:33.891]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:33.891]                   ...future.conditions[[length(...future.conditions) + 
[10:22:33.891]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:33.891]                   if (TRUE && !signal) {
[10:22:33.891]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:33.891]                     {
[10:22:33.891]                       inherits <- base::inherits
[10:22:33.891]                       invokeRestart <- base::invokeRestart
[10:22:33.891]                       is.null <- base::is.null
[10:22:33.891]                       muffled <- FALSE
[10:22:33.891]                       if (inherits(cond, "message")) {
[10:22:33.891]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:33.891]                         if (muffled) 
[10:22:33.891]                           invokeRestart("muffleMessage")
[10:22:33.891]                       }
[10:22:33.891]                       else if (inherits(cond, "warning")) {
[10:22:33.891]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:33.891]                         if (muffled) 
[10:22:33.891]                           invokeRestart("muffleWarning")
[10:22:33.891]                       }
[10:22:33.891]                       else if (inherits(cond, "condition")) {
[10:22:33.891]                         if (!is.null(pattern)) {
[10:22:33.891]                           computeRestarts <- base::computeRestarts
[10:22:33.891]                           grepl <- base::grepl
[10:22:33.891]                           restarts <- computeRestarts(cond)
[10:22:33.891]                           for (restart in restarts) {
[10:22:33.891]                             name <- restart$name
[10:22:33.891]                             if (is.null(name)) 
[10:22:33.891]                               next
[10:22:33.891]                             if (!grepl(pattern, name)) 
[10:22:33.891]                               next
[10:22:33.891]                             invokeRestart(restart)
[10:22:33.891]                             muffled <- TRUE
[10:22:33.891]                             break
[10:22:33.891]                           }
[10:22:33.891]                         }
[10:22:33.891]                       }
[10:22:33.891]                       invisible(muffled)
[10:22:33.891]                     }
[10:22:33.891]                     muffleCondition(cond, pattern = "^muffle")
[10:22:33.891]                   }
[10:22:33.891]                 }
[10:22:33.891]                 else {
[10:22:33.891]                   if (TRUE) {
[10:22:33.891]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:33.891]                     {
[10:22:33.891]                       inherits <- base::inherits
[10:22:33.891]                       invokeRestart <- base::invokeRestart
[10:22:33.891]                       is.null <- base::is.null
[10:22:33.891]                       muffled <- FALSE
[10:22:33.891]                       if (inherits(cond, "message")) {
[10:22:33.891]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:33.891]                         if (muffled) 
[10:22:33.891]                           invokeRestart("muffleMessage")
[10:22:33.891]                       }
[10:22:33.891]                       else if (inherits(cond, "warning")) {
[10:22:33.891]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:33.891]                         if (muffled) 
[10:22:33.891]                           invokeRestart("muffleWarning")
[10:22:33.891]                       }
[10:22:33.891]                       else if (inherits(cond, "condition")) {
[10:22:33.891]                         if (!is.null(pattern)) {
[10:22:33.891]                           computeRestarts <- base::computeRestarts
[10:22:33.891]                           grepl <- base::grepl
[10:22:33.891]                           restarts <- computeRestarts(cond)
[10:22:33.891]                           for (restart in restarts) {
[10:22:33.891]                             name <- restart$name
[10:22:33.891]                             if (is.null(name)) 
[10:22:33.891]                               next
[10:22:33.891]                             if (!grepl(pattern, name)) 
[10:22:33.891]                               next
[10:22:33.891]                             invokeRestart(restart)
[10:22:33.891]                             muffled <- TRUE
[10:22:33.891]                             break
[10:22:33.891]                           }
[10:22:33.891]                         }
[10:22:33.891]                       }
[10:22:33.891]                       invisible(muffled)
[10:22:33.891]                     }
[10:22:33.891]                     muffleCondition(cond, pattern = "^muffle")
[10:22:33.891]                   }
[10:22:33.891]                 }
[10:22:33.891]             }
[10:22:33.891]         }))
[10:22:33.891]     }, error = function(ex) {
[10:22:33.891]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:33.891]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:33.891]                 ...future.rng), started = ...future.startTime, 
[10:22:33.891]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:33.891]             version = "1.8"), class = "FutureResult")
[10:22:33.891]     }, finally = {
[10:22:33.891]         if (!identical(...future.workdir, getwd())) 
[10:22:33.891]             setwd(...future.workdir)
[10:22:33.891]         {
[10:22:33.891]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:33.891]                 ...future.oldOptions$nwarnings <- NULL
[10:22:33.891]             }
[10:22:33.891]             base::options(...future.oldOptions)
[10:22:33.891]             if (.Platform$OS.type == "windows") {
[10:22:33.891]                 old_names <- names(...future.oldEnvVars)
[10:22:33.891]                 envs <- base::Sys.getenv()
[10:22:33.891]                 names <- names(envs)
[10:22:33.891]                 common <- intersect(names, old_names)
[10:22:33.891]                 added <- setdiff(names, old_names)
[10:22:33.891]                 removed <- setdiff(old_names, names)
[10:22:33.891]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:33.891]                   envs[common]]
[10:22:33.891]                 NAMES <- toupper(changed)
[10:22:33.891]                 args <- list()
[10:22:33.891]                 for (kk in seq_along(NAMES)) {
[10:22:33.891]                   name <- changed[[kk]]
[10:22:33.891]                   NAME <- NAMES[[kk]]
[10:22:33.891]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:33.891]                     next
[10:22:33.891]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:33.891]                 }
[10:22:33.891]                 NAMES <- toupper(added)
[10:22:33.891]                 for (kk in seq_along(NAMES)) {
[10:22:33.891]                   name <- added[[kk]]
[10:22:33.891]                   NAME <- NAMES[[kk]]
[10:22:33.891]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:33.891]                     next
[10:22:33.891]                   args[[name]] <- ""
[10:22:33.891]                 }
[10:22:33.891]                 NAMES <- toupper(removed)
[10:22:33.891]                 for (kk in seq_along(NAMES)) {
[10:22:33.891]                   name <- removed[[kk]]
[10:22:33.891]                   NAME <- NAMES[[kk]]
[10:22:33.891]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:33.891]                     next
[10:22:33.891]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:33.891]                 }
[10:22:33.891]                 if (length(args) > 0) 
[10:22:33.891]                   base::do.call(base::Sys.setenv, args = args)
[10:22:33.891]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:33.891]             }
[10:22:33.891]             else {
[10:22:33.891]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:33.891]             }
[10:22:33.891]             {
[10:22:33.891]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:33.891]                   0L) {
[10:22:33.891]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:33.891]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:33.891]                   base::options(opts)
[10:22:33.891]                 }
[10:22:33.891]                 {
[10:22:33.891]                   {
[10:22:33.891]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:33.891]                     NULL
[10:22:33.891]                   }
[10:22:33.891]                   options(future.plan = NULL)
[10:22:33.891]                   if (is.na(NA_character_)) 
[10:22:33.891]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:33.891]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:33.891]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:33.891]                     .init = FALSE)
[10:22:33.891]                 }
[10:22:33.891]             }
[10:22:33.891]         }
[10:22:33.891]     })
[10:22:33.891]     if (TRUE) {
[10:22:33.891]         base::sink(type = "output", split = FALSE)
[10:22:33.891]         if (TRUE) {
[10:22:33.891]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:33.891]         }
[10:22:33.891]         else {
[10:22:33.891]             ...future.result["stdout"] <- base::list(NULL)
[10:22:33.891]         }
[10:22:33.891]         base::close(...future.stdout)
[10:22:33.891]         ...future.stdout <- NULL
[10:22:33.891]     }
[10:22:33.891]     ...future.result$conditions <- ...future.conditions
[10:22:33.891]     ...future.result$finished <- base::Sys.time()
[10:22:33.891]     ...future.result
[10:22:33.891] }
[10:22:33.895] MultisessionFuture started
[10:22:33.895] - Launch lazy future ... done
[10:22:33.895] run() for ‘MultisessionFuture’ ... done
[10:22:33.938] receiveMessageFromWorker() for ClusterFuture ...
[10:22:33.938] - Validating connection of MultisessionFuture
[10:22:33.938] - received message: FutureResult
[10:22:33.938] - Received FutureResult
[10:22:33.939] - Erased future from FutureRegistry
[10:22:33.939] result() for ClusterFuture ...
[10:22:33.939] - result already collected: FutureResult
[10:22:33.939] result() for ClusterFuture ... done
[10:22:33.939] signalConditions() ...
[10:22:33.939]  - include = ‘immediateCondition’
[10:22:33.939]  - exclude = 
[10:22:33.939]  - resignal = FALSE
[10:22:33.939]  - Number of conditions: 1
[10:22:33.940] signalConditions() ... done
[10:22:33.940] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:33.940] A MultisessionFuture was resolved (result was not collected)
[10:22:33.940] getGlobalsAndPackages() ...
[10:22:33.940] Searching for globals...
[10:22:33.941] - globals found: [2] ‘list’, ‘stop’
[10:22:33.941] Searching for globals ... DONE
[10:22:33.941] Resolving globals: FALSE
[10:22:33.941] 
[10:22:33.942] 
[10:22:33.942] getGlobalsAndPackages() ... DONE
[10:22:33.942] run() for ‘Future’ ...
[10:22:33.942] - state: ‘created’
[10:22:33.942] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:33.957] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:33.957] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:33.957]   - Field: ‘node’
[10:22:33.957]   - Field: ‘label’
[10:22:33.957]   - Field: ‘local’
[10:22:33.957]   - Field: ‘owner’
[10:22:33.957]   - Field: ‘envir’
[10:22:33.957]   - Field: ‘workers’
[10:22:33.957]   - Field: ‘packages’
[10:22:33.957]   - Field: ‘gc’
[10:22:33.958]   - Field: ‘conditions’
[10:22:33.958]   - Field: ‘persistent’
[10:22:33.958]   - Field: ‘expr’
[10:22:33.958]   - Field: ‘uuid’
[10:22:33.958]   - Field: ‘seed’
[10:22:33.958]   - Field: ‘version’
[10:22:33.958]   - Field: ‘result’
[10:22:33.958]   - Field: ‘asynchronous’
[10:22:33.958]   - Field: ‘calls’
[10:22:33.959]   - Field: ‘globals’
[10:22:33.959]   - Field: ‘stdout’
[10:22:33.959]   - Field: ‘earlySignal’
[10:22:33.959]   - Field: ‘lazy’
[10:22:33.959]   - Field: ‘state’
[10:22:33.959] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:33.959] - Launch lazy future ...
[10:22:33.959] Packages needed by the future expression (n = 0): <none>
[10:22:33.960] Packages needed by future strategies (n = 0): <none>
[10:22:33.960] {
[10:22:33.960]     {
[10:22:33.960]         {
[10:22:33.960]             ...future.startTime <- base::Sys.time()
[10:22:33.960]             {
[10:22:33.960]                 {
[10:22:33.960]                   {
[10:22:33.960]                     {
[10:22:33.960]                       base::local({
[10:22:33.960]                         has_future <- base::requireNamespace("future", 
[10:22:33.960]                           quietly = TRUE)
[10:22:33.960]                         if (has_future) {
[10:22:33.960]                           ns <- base::getNamespace("future")
[10:22:33.960]                           version <- ns[[".package"]][["version"]]
[10:22:33.960]                           if (is.null(version)) 
[10:22:33.960]                             version <- utils::packageVersion("future")
[10:22:33.960]                         }
[10:22:33.960]                         else {
[10:22:33.960]                           version <- NULL
[10:22:33.960]                         }
[10:22:33.960]                         if (!has_future || version < "1.8.0") {
[10:22:33.960]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:33.960]                             "", base::R.version$version.string), 
[10:22:33.960]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:33.960]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:33.960]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:33.960]                               "release", "version")], collapse = " "), 
[10:22:33.960]                             hostname = base::Sys.info()[["nodename"]])
[10:22:33.960]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:33.960]                             info)
[10:22:33.960]                           info <- base::paste(info, collapse = "; ")
[10:22:33.960]                           if (!has_future) {
[10:22:33.960]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:33.960]                               info)
[10:22:33.960]                           }
[10:22:33.960]                           else {
[10:22:33.960]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:33.960]                               info, version)
[10:22:33.960]                           }
[10:22:33.960]                           base::stop(msg)
[10:22:33.960]                         }
[10:22:33.960]                       })
[10:22:33.960]                     }
[10:22:33.960]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:33.960]                     base::options(mc.cores = 1L)
[10:22:33.960]                   }
[10:22:33.960]                   ...future.strategy.old <- future::plan("list")
[10:22:33.960]                   options(future.plan = NULL)
[10:22:33.960]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:33.960]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:33.960]                 }
[10:22:33.960]                 ...future.workdir <- getwd()
[10:22:33.960]             }
[10:22:33.960]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:33.960]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:33.960]         }
[10:22:33.960]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:33.960]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:33.960]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:33.960]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:33.960]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:33.960]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:33.960]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:33.960]             base::names(...future.oldOptions))
[10:22:33.960]     }
[10:22:33.960]     if (FALSE) {
[10:22:33.960]     }
[10:22:33.960]     else {
[10:22:33.960]         if (TRUE) {
[10:22:33.960]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:33.960]                 open = "w")
[10:22:33.960]         }
[10:22:33.960]         else {
[10:22:33.960]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:33.960]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:33.960]         }
[10:22:33.960]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:33.960]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:33.960]             base::sink(type = "output", split = FALSE)
[10:22:33.960]             base::close(...future.stdout)
[10:22:33.960]         }, add = TRUE)
[10:22:33.960]     }
[10:22:33.960]     ...future.frame <- base::sys.nframe()
[10:22:33.960]     ...future.conditions <- base::list()
[10:22:33.960]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:33.960]     if (FALSE) {
[10:22:33.960]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:33.960]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:33.960]     }
[10:22:33.960]     ...future.result <- base::tryCatch({
[10:22:33.960]         base::withCallingHandlers({
[10:22:33.960]             ...future.value <- base::withVisible(base::local({
[10:22:33.960]                 ...future.makeSendCondition <- base::local({
[10:22:33.960]                   sendCondition <- NULL
[10:22:33.960]                   function(frame = 1L) {
[10:22:33.960]                     if (is.function(sendCondition)) 
[10:22:33.960]                       return(sendCondition)
[10:22:33.960]                     ns <- getNamespace("parallel")
[10:22:33.960]                     if (exists("sendData", mode = "function", 
[10:22:33.960]                       envir = ns)) {
[10:22:33.960]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:33.960]                         envir = ns)
[10:22:33.960]                       envir <- sys.frame(frame)
[10:22:33.960]                       master <- NULL
[10:22:33.960]                       while (!identical(envir, .GlobalEnv) && 
[10:22:33.960]                         !identical(envir, emptyenv())) {
[10:22:33.960]                         if (exists("master", mode = "list", envir = envir, 
[10:22:33.960]                           inherits = FALSE)) {
[10:22:33.960]                           master <- get("master", mode = "list", 
[10:22:33.960]                             envir = envir, inherits = FALSE)
[10:22:33.960]                           if (inherits(master, c("SOCKnode", 
[10:22:33.960]                             "SOCK0node"))) {
[10:22:33.960]                             sendCondition <<- function(cond) {
[10:22:33.960]                               data <- list(type = "VALUE", value = cond, 
[10:22:33.960]                                 success = TRUE)
[10:22:33.960]                               parallel_sendData(master, data)
[10:22:33.960]                             }
[10:22:33.960]                             return(sendCondition)
[10:22:33.960]                           }
[10:22:33.960]                         }
[10:22:33.960]                         frame <- frame + 1L
[10:22:33.960]                         envir <- sys.frame(frame)
[10:22:33.960]                       }
[10:22:33.960]                     }
[10:22:33.960]                     sendCondition <<- function(cond) NULL
[10:22:33.960]                   }
[10:22:33.960]                 })
[10:22:33.960]                 withCallingHandlers({
[10:22:33.960]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:22:33.960]                 }, immediateCondition = function(cond) {
[10:22:33.960]                   sendCondition <- ...future.makeSendCondition()
[10:22:33.960]                   sendCondition(cond)
[10:22:33.960]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:33.960]                   {
[10:22:33.960]                     inherits <- base::inherits
[10:22:33.960]                     invokeRestart <- base::invokeRestart
[10:22:33.960]                     is.null <- base::is.null
[10:22:33.960]                     muffled <- FALSE
[10:22:33.960]                     if (inherits(cond, "message")) {
[10:22:33.960]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:33.960]                       if (muffled) 
[10:22:33.960]                         invokeRestart("muffleMessage")
[10:22:33.960]                     }
[10:22:33.960]                     else if (inherits(cond, "warning")) {
[10:22:33.960]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:33.960]                       if (muffled) 
[10:22:33.960]                         invokeRestart("muffleWarning")
[10:22:33.960]                     }
[10:22:33.960]                     else if (inherits(cond, "condition")) {
[10:22:33.960]                       if (!is.null(pattern)) {
[10:22:33.960]                         computeRestarts <- base::computeRestarts
[10:22:33.960]                         grepl <- base::grepl
[10:22:33.960]                         restarts <- computeRestarts(cond)
[10:22:33.960]                         for (restart in restarts) {
[10:22:33.960]                           name <- restart$name
[10:22:33.960]                           if (is.null(name)) 
[10:22:33.960]                             next
[10:22:33.960]                           if (!grepl(pattern, name)) 
[10:22:33.960]                             next
[10:22:33.960]                           invokeRestart(restart)
[10:22:33.960]                           muffled <- TRUE
[10:22:33.960]                           break
[10:22:33.960]                         }
[10:22:33.960]                       }
[10:22:33.960]                     }
[10:22:33.960]                     invisible(muffled)
[10:22:33.960]                   }
[10:22:33.960]                   muffleCondition(cond)
[10:22:33.960]                 })
[10:22:33.960]             }))
[10:22:33.960]             future::FutureResult(value = ...future.value$value, 
[10:22:33.960]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:33.960]                   ...future.rng), globalenv = if (FALSE) 
[10:22:33.960]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:33.960]                     ...future.globalenv.names))
[10:22:33.960]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:33.960]         }, condition = base::local({
[10:22:33.960]             c <- base::c
[10:22:33.960]             inherits <- base::inherits
[10:22:33.960]             invokeRestart <- base::invokeRestart
[10:22:33.960]             length <- base::length
[10:22:33.960]             list <- base::list
[10:22:33.960]             seq.int <- base::seq.int
[10:22:33.960]             signalCondition <- base::signalCondition
[10:22:33.960]             sys.calls <- base::sys.calls
[10:22:33.960]             `[[` <- base::`[[`
[10:22:33.960]             `+` <- base::`+`
[10:22:33.960]             `<<-` <- base::`<<-`
[10:22:33.960]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:33.960]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:33.960]                   3L)]
[10:22:33.960]             }
[10:22:33.960]             function(cond) {
[10:22:33.960]                 is_error <- inherits(cond, "error")
[10:22:33.960]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:33.960]                   NULL)
[10:22:33.960]                 if (is_error) {
[10:22:33.960]                   sessionInformation <- function() {
[10:22:33.960]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:33.960]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:33.960]                       search = base::search(), system = base::Sys.info())
[10:22:33.960]                   }
[10:22:33.960]                   ...future.conditions[[length(...future.conditions) + 
[10:22:33.960]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:33.960]                     cond$call), session = sessionInformation(), 
[10:22:33.960]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:33.960]                   signalCondition(cond)
[10:22:33.960]                 }
[10:22:33.960]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:33.960]                 "immediateCondition"))) {
[10:22:33.960]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:33.960]                   ...future.conditions[[length(...future.conditions) + 
[10:22:33.960]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:33.960]                   if (TRUE && !signal) {
[10:22:33.960]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:33.960]                     {
[10:22:33.960]                       inherits <- base::inherits
[10:22:33.960]                       invokeRestart <- base::invokeRestart
[10:22:33.960]                       is.null <- base::is.null
[10:22:33.960]                       muffled <- FALSE
[10:22:33.960]                       if (inherits(cond, "message")) {
[10:22:33.960]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:33.960]                         if (muffled) 
[10:22:33.960]                           invokeRestart("muffleMessage")
[10:22:33.960]                       }
[10:22:33.960]                       else if (inherits(cond, "warning")) {
[10:22:33.960]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:33.960]                         if (muffled) 
[10:22:33.960]                           invokeRestart("muffleWarning")
[10:22:33.960]                       }
[10:22:33.960]                       else if (inherits(cond, "condition")) {
[10:22:33.960]                         if (!is.null(pattern)) {
[10:22:33.960]                           computeRestarts <- base::computeRestarts
[10:22:33.960]                           grepl <- base::grepl
[10:22:33.960]                           restarts <- computeRestarts(cond)
[10:22:33.960]                           for (restart in restarts) {
[10:22:33.960]                             name <- restart$name
[10:22:33.960]                             if (is.null(name)) 
[10:22:33.960]                               next
[10:22:33.960]                             if (!grepl(pattern, name)) 
[10:22:33.960]                               next
[10:22:33.960]                             invokeRestart(restart)
[10:22:33.960]                             muffled <- TRUE
[10:22:33.960]                             break
[10:22:33.960]                           }
[10:22:33.960]                         }
[10:22:33.960]                       }
[10:22:33.960]                       invisible(muffled)
[10:22:33.960]                     }
[10:22:33.960]                     muffleCondition(cond, pattern = "^muffle")
[10:22:33.960]                   }
[10:22:33.960]                 }
[10:22:33.960]                 else {
[10:22:33.960]                   if (TRUE) {
[10:22:33.960]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:33.960]                     {
[10:22:33.960]                       inherits <- base::inherits
[10:22:33.960]                       invokeRestart <- base::invokeRestart
[10:22:33.960]                       is.null <- base::is.null
[10:22:33.960]                       muffled <- FALSE
[10:22:33.960]                       if (inherits(cond, "message")) {
[10:22:33.960]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:33.960]                         if (muffled) 
[10:22:33.960]                           invokeRestart("muffleMessage")
[10:22:33.960]                       }
[10:22:33.960]                       else if (inherits(cond, "warning")) {
[10:22:33.960]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:33.960]                         if (muffled) 
[10:22:33.960]                           invokeRestart("muffleWarning")
[10:22:33.960]                       }
[10:22:33.960]                       else if (inherits(cond, "condition")) {
[10:22:33.960]                         if (!is.null(pattern)) {
[10:22:33.960]                           computeRestarts <- base::computeRestarts
[10:22:33.960]                           grepl <- base::grepl
[10:22:33.960]                           restarts <- computeRestarts(cond)
[10:22:33.960]                           for (restart in restarts) {
[10:22:33.960]                             name <- restart$name
[10:22:33.960]                             if (is.null(name)) 
[10:22:33.960]                               next
[10:22:33.960]                             if (!grepl(pattern, name)) 
[10:22:33.960]                               next
[10:22:33.960]                             invokeRestart(restart)
[10:22:33.960]                             muffled <- TRUE
[10:22:33.960]                             break
[10:22:33.960]                           }
[10:22:33.960]                         }
[10:22:33.960]                       }
[10:22:33.960]                       invisible(muffled)
[10:22:33.960]                     }
[10:22:33.960]                     muffleCondition(cond, pattern = "^muffle")
[10:22:33.960]                   }
[10:22:33.960]                 }
[10:22:33.960]             }
[10:22:33.960]         }))
[10:22:33.960]     }, error = function(ex) {
[10:22:33.960]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:33.960]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:33.960]                 ...future.rng), started = ...future.startTime, 
[10:22:33.960]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:33.960]             version = "1.8"), class = "FutureResult")
[10:22:33.960]     }, finally = {
[10:22:33.960]         if (!identical(...future.workdir, getwd())) 
[10:22:33.960]             setwd(...future.workdir)
[10:22:33.960]         {
[10:22:33.960]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:33.960]                 ...future.oldOptions$nwarnings <- NULL
[10:22:33.960]             }
[10:22:33.960]             base::options(...future.oldOptions)
[10:22:33.960]             if (.Platform$OS.type == "windows") {
[10:22:33.960]                 old_names <- names(...future.oldEnvVars)
[10:22:33.960]                 envs <- base::Sys.getenv()
[10:22:33.960]                 names <- names(envs)
[10:22:33.960]                 common <- intersect(names, old_names)
[10:22:33.960]                 added <- setdiff(names, old_names)
[10:22:33.960]                 removed <- setdiff(old_names, names)
[10:22:33.960]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:33.960]                   envs[common]]
[10:22:33.960]                 NAMES <- toupper(changed)
[10:22:33.960]                 args <- list()
[10:22:33.960]                 for (kk in seq_along(NAMES)) {
[10:22:33.960]                   name <- changed[[kk]]
[10:22:33.960]                   NAME <- NAMES[[kk]]
[10:22:33.960]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:33.960]                     next
[10:22:33.960]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:33.960]                 }
[10:22:33.960]                 NAMES <- toupper(added)
[10:22:33.960]                 for (kk in seq_along(NAMES)) {
[10:22:33.960]                   name <- added[[kk]]
[10:22:33.960]                   NAME <- NAMES[[kk]]
[10:22:33.960]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:33.960]                     next
[10:22:33.960]                   args[[name]] <- ""
[10:22:33.960]                 }
[10:22:33.960]                 NAMES <- toupper(removed)
[10:22:33.960]                 for (kk in seq_along(NAMES)) {
[10:22:33.960]                   name <- removed[[kk]]
[10:22:33.960]                   NAME <- NAMES[[kk]]
[10:22:33.960]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:33.960]                     next
[10:22:33.960]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:33.960]                 }
[10:22:33.960]                 if (length(args) > 0) 
[10:22:33.960]                   base::do.call(base::Sys.setenv, args = args)
[10:22:33.960]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:33.960]             }
[10:22:33.960]             else {
[10:22:33.960]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:33.960]             }
[10:22:33.960]             {
[10:22:33.960]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:33.960]                   0L) {
[10:22:33.960]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:33.960]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:33.960]                   base::options(opts)
[10:22:33.960]                 }
[10:22:33.960]                 {
[10:22:33.960]                   {
[10:22:33.960]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:33.960]                     NULL
[10:22:33.960]                   }
[10:22:33.960]                   options(future.plan = NULL)
[10:22:33.960]                   if (is.na(NA_character_)) 
[10:22:33.960]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:33.960]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:33.960]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:33.960]                     .init = FALSE)
[10:22:33.960]                 }
[10:22:33.960]             }
[10:22:33.960]         }
[10:22:33.960]     })
[10:22:33.960]     if (TRUE) {
[10:22:33.960]         base::sink(type = "output", split = FALSE)
[10:22:33.960]         if (TRUE) {
[10:22:33.960]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:33.960]         }
[10:22:33.960]         else {
[10:22:33.960]             ...future.result["stdout"] <- base::list(NULL)
[10:22:33.960]         }
[10:22:33.960]         base::close(...future.stdout)
[10:22:33.960]         ...future.stdout <- NULL
[10:22:33.960]     }
[10:22:33.960]     ...future.result$conditions <- ...future.conditions
[10:22:33.960]     ...future.result$finished <- base::Sys.time()
[10:22:33.960]     ...future.result
[10:22:33.960] }
[10:22:33.963] MultisessionFuture started
[10:22:33.963] - Launch lazy future ... done
[10:22:33.964] run() for ‘MultisessionFuture’ ... done
[10:22:34.006] receiveMessageFromWorker() for ClusterFuture ...
[10:22:34.006] - Validating connection of MultisessionFuture
[10:22:34.006] - received message: FutureResult
[10:22:34.006] - Received FutureResult
[10:22:34.007] - Erased future from FutureRegistry
[10:22:34.007] result() for ClusterFuture ...
[10:22:34.007] - result already collected: FutureResult
[10:22:34.007] result() for ClusterFuture ... done
[10:22:34.007] signalConditions() ...
[10:22:34.007]  - include = ‘immediateCondition’
[10:22:34.007]  - exclude = 
[10:22:34.007]  - resignal = FALSE
[10:22:34.007]  - Number of conditions: 1
[10:22:34.008] signalConditions() ... done
[10:22:34.008] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:34.008] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = FALSE ... DONE
- result = FALSE, recursive = TRUE ...
[10:22:34.008] getGlobalsAndPackages() ...
[10:22:34.008] Searching for globals...
[10:22:34.009] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:22:34.010] Searching for globals ... DONE
[10:22:34.010] Resolving globals: FALSE
[10:22:34.010] 
[10:22:34.010] 
[10:22:34.010] getGlobalsAndPackages() ... DONE
[10:22:34.011] run() for ‘Future’ ...
[10:22:34.011] - state: ‘created’
[10:22:34.011] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:34.025] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:34.025] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:34.028]   - Field: ‘node’
[10:22:34.028]   - Field: ‘label’
[10:22:34.028]   - Field: ‘local’
[10:22:34.028]   - Field: ‘owner’
[10:22:34.028]   - Field: ‘envir’
[10:22:34.028]   - Field: ‘workers’
[10:22:34.028]   - Field: ‘packages’
[10:22:34.028]   - Field: ‘gc’
[10:22:34.028]   - Field: ‘conditions’
[10:22:34.028]   - Field: ‘persistent’
[10:22:34.028]   - Field: ‘expr’
[10:22:34.028]   - Field: ‘uuid’
[10:22:34.029]   - Field: ‘seed’
[10:22:34.029]   - Field: ‘version’
[10:22:34.029]   - Field: ‘result’
[10:22:34.029]   - Field: ‘asynchronous’
[10:22:34.029]   - Field: ‘calls’
[10:22:34.029]   - Field: ‘globals’
[10:22:34.029]   - Field: ‘stdout’
[10:22:34.029]   - Field: ‘earlySignal’
[10:22:34.029]   - Field: ‘lazy’
[10:22:34.029]   - Field: ‘state’
[10:22:34.029] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:34.029] - Launch lazy future ...
[10:22:34.030] Packages needed by the future expression (n = 0): <none>
[10:22:34.030] Packages needed by future strategies (n = 0): <none>
[10:22:34.030] {
[10:22:34.030]     {
[10:22:34.030]         {
[10:22:34.030]             ...future.startTime <- base::Sys.time()
[10:22:34.030]             {
[10:22:34.030]                 {
[10:22:34.030]                   {
[10:22:34.030]                     {
[10:22:34.030]                       base::local({
[10:22:34.030]                         has_future <- base::requireNamespace("future", 
[10:22:34.030]                           quietly = TRUE)
[10:22:34.030]                         if (has_future) {
[10:22:34.030]                           ns <- base::getNamespace("future")
[10:22:34.030]                           version <- ns[[".package"]][["version"]]
[10:22:34.030]                           if (is.null(version)) 
[10:22:34.030]                             version <- utils::packageVersion("future")
[10:22:34.030]                         }
[10:22:34.030]                         else {
[10:22:34.030]                           version <- NULL
[10:22:34.030]                         }
[10:22:34.030]                         if (!has_future || version < "1.8.0") {
[10:22:34.030]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:34.030]                             "", base::R.version$version.string), 
[10:22:34.030]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:34.030]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:34.030]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:34.030]                               "release", "version")], collapse = " "), 
[10:22:34.030]                             hostname = base::Sys.info()[["nodename"]])
[10:22:34.030]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:34.030]                             info)
[10:22:34.030]                           info <- base::paste(info, collapse = "; ")
[10:22:34.030]                           if (!has_future) {
[10:22:34.030]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:34.030]                               info)
[10:22:34.030]                           }
[10:22:34.030]                           else {
[10:22:34.030]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:34.030]                               info, version)
[10:22:34.030]                           }
[10:22:34.030]                           base::stop(msg)
[10:22:34.030]                         }
[10:22:34.030]                       })
[10:22:34.030]                     }
[10:22:34.030]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:34.030]                     base::options(mc.cores = 1L)
[10:22:34.030]                   }
[10:22:34.030]                   ...future.strategy.old <- future::plan("list")
[10:22:34.030]                   options(future.plan = NULL)
[10:22:34.030]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:34.030]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:34.030]                 }
[10:22:34.030]                 ...future.workdir <- getwd()
[10:22:34.030]             }
[10:22:34.030]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:34.030]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:34.030]         }
[10:22:34.030]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:34.030]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:34.030]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:34.030]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:34.030]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:34.030]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:34.030]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:34.030]             base::names(...future.oldOptions))
[10:22:34.030]     }
[10:22:34.030]     if (FALSE) {
[10:22:34.030]     }
[10:22:34.030]     else {
[10:22:34.030]         if (TRUE) {
[10:22:34.030]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:34.030]                 open = "w")
[10:22:34.030]         }
[10:22:34.030]         else {
[10:22:34.030]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:34.030]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:34.030]         }
[10:22:34.030]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:34.030]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:34.030]             base::sink(type = "output", split = FALSE)
[10:22:34.030]             base::close(...future.stdout)
[10:22:34.030]         }, add = TRUE)
[10:22:34.030]     }
[10:22:34.030]     ...future.frame <- base::sys.nframe()
[10:22:34.030]     ...future.conditions <- base::list()
[10:22:34.030]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:34.030]     if (FALSE) {
[10:22:34.030]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:34.030]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:34.030]     }
[10:22:34.030]     ...future.result <- base::tryCatch({
[10:22:34.030]         base::withCallingHandlers({
[10:22:34.030]             ...future.value <- base::withVisible(base::local({
[10:22:34.030]                 ...future.makeSendCondition <- base::local({
[10:22:34.030]                   sendCondition <- NULL
[10:22:34.030]                   function(frame = 1L) {
[10:22:34.030]                     if (is.function(sendCondition)) 
[10:22:34.030]                       return(sendCondition)
[10:22:34.030]                     ns <- getNamespace("parallel")
[10:22:34.030]                     if (exists("sendData", mode = "function", 
[10:22:34.030]                       envir = ns)) {
[10:22:34.030]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:34.030]                         envir = ns)
[10:22:34.030]                       envir <- sys.frame(frame)
[10:22:34.030]                       master <- NULL
[10:22:34.030]                       while (!identical(envir, .GlobalEnv) && 
[10:22:34.030]                         !identical(envir, emptyenv())) {
[10:22:34.030]                         if (exists("master", mode = "list", envir = envir, 
[10:22:34.030]                           inherits = FALSE)) {
[10:22:34.030]                           master <- get("master", mode = "list", 
[10:22:34.030]                             envir = envir, inherits = FALSE)
[10:22:34.030]                           if (inherits(master, c("SOCKnode", 
[10:22:34.030]                             "SOCK0node"))) {
[10:22:34.030]                             sendCondition <<- function(cond) {
[10:22:34.030]                               data <- list(type = "VALUE", value = cond, 
[10:22:34.030]                                 success = TRUE)
[10:22:34.030]                               parallel_sendData(master, data)
[10:22:34.030]                             }
[10:22:34.030]                             return(sendCondition)
[10:22:34.030]                           }
[10:22:34.030]                         }
[10:22:34.030]                         frame <- frame + 1L
[10:22:34.030]                         envir <- sys.frame(frame)
[10:22:34.030]                       }
[10:22:34.030]                     }
[10:22:34.030]                     sendCondition <<- function(cond) NULL
[10:22:34.030]                   }
[10:22:34.030]                 })
[10:22:34.030]                 withCallingHandlers({
[10:22:34.030]                   {
[10:22:34.030]                     Sys.sleep(0.5)
[10:22:34.030]                     list(a = 1, b = 42L)
[10:22:34.030]                   }
[10:22:34.030]                 }, immediateCondition = function(cond) {
[10:22:34.030]                   sendCondition <- ...future.makeSendCondition()
[10:22:34.030]                   sendCondition(cond)
[10:22:34.030]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:34.030]                   {
[10:22:34.030]                     inherits <- base::inherits
[10:22:34.030]                     invokeRestart <- base::invokeRestart
[10:22:34.030]                     is.null <- base::is.null
[10:22:34.030]                     muffled <- FALSE
[10:22:34.030]                     if (inherits(cond, "message")) {
[10:22:34.030]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:34.030]                       if (muffled) 
[10:22:34.030]                         invokeRestart("muffleMessage")
[10:22:34.030]                     }
[10:22:34.030]                     else if (inherits(cond, "warning")) {
[10:22:34.030]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:34.030]                       if (muffled) 
[10:22:34.030]                         invokeRestart("muffleWarning")
[10:22:34.030]                     }
[10:22:34.030]                     else if (inherits(cond, "condition")) {
[10:22:34.030]                       if (!is.null(pattern)) {
[10:22:34.030]                         computeRestarts <- base::computeRestarts
[10:22:34.030]                         grepl <- base::grepl
[10:22:34.030]                         restarts <- computeRestarts(cond)
[10:22:34.030]                         for (restart in restarts) {
[10:22:34.030]                           name <- restart$name
[10:22:34.030]                           if (is.null(name)) 
[10:22:34.030]                             next
[10:22:34.030]                           if (!grepl(pattern, name)) 
[10:22:34.030]                             next
[10:22:34.030]                           invokeRestart(restart)
[10:22:34.030]                           muffled <- TRUE
[10:22:34.030]                           break
[10:22:34.030]                         }
[10:22:34.030]                       }
[10:22:34.030]                     }
[10:22:34.030]                     invisible(muffled)
[10:22:34.030]                   }
[10:22:34.030]                   muffleCondition(cond)
[10:22:34.030]                 })
[10:22:34.030]             }))
[10:22:34.030]             future::FutureResult(value = ...future.value$value, 
[10:22:34.030]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:34.030]                   ...future.rng), globalenv = if (FALSE) 
[10:22:34.030]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:34.030]                     ...future.globalenv.names))
[10:22:34.030]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:34.030]         }, condition = base::local({
[10:22:34.030]             c <- base::c
[10:22:34.030]             inherits <- base::inherits
[10:22:34.030]             invokeRestart <- base::invokeRestart
[10:22:34.030]             length <- base::length
[10:22:34.030]             list <- base::list
[10:22:34.030]             seq.int <- base::seq.int
[10:22:34.030]             signalCondition <- base::signalCondition
[10:22:34.030]             sys.calls <- base::sys.calls
[10:22:34.030]             `[[` <- base::`[[`
[10:22:34.030]             `+` <- base::`+`
[10:22:34.030]             `<<-` <- base::`<<-`
[10:22:34.030]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:34.030]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:34.030]                   3L)]
[10:22:34.030]             }
[10:22:34.030]             function(cond) {
[10:22:34.030]                 is_error <- inherits(cond, "error")
[10:22:34.030]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:34.030]                   NULL)
[10:22:34.030]                 if (is_error) {
[10:22:34.030]                   sessionInformation <- function() {
[10:22:34.030]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:34.030]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:34.030]                       search = base::search(), system = base::Sys.info())
[10:22:34.030]                   }
[10:22:34.030]                   ...future.conditions[[length(...future.conditions) + 
[10:22:34.030]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:34.030]                     cond$call), session = sessionInformation(), 
[10:22:34.030]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:34.030]                   signalCondition(cond)
[10:22:34.030]                 }
[10:22:34.030]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:34.030]                 "immediateCondition"))) {
[10:22:34.030]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:34.030]                   ...future.conditions[[length(...future.conditions) + 
[10:22:34.030]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:34.030]                   if (TRUE && !signal) {
[10:22:34.030]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:34.030]                     {
[10:22:34.030]                       inherits <- base::inherits
[10:22:34.030]                       invokeRestart <- base::invokeRestart
[10:22:34.030]                       is.null <- base::is.null
[10:22:34.030]                       muffled <- FALSE
[10:22:34.030]                       if (inherits(cond, "message")) {
[10:22:34.030]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:34.030]                         if (muffled) 
[10:22:34.030]                           invokeRestart("muffleMessage")
[10:22:34.030]                       }
[10:22:34.030]                       else if (inherits(cond, "warning")) {
[10:22:34.030]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:34.030]                         if (muffled) 
[10:22:34.030]                           invokeRestart("muffleWarning")
[10:22:34.030]                       }
[10:22:34.030]                       else if (inherits(cond, "condition")) {
[10:22:34.030]                         if (!is.null(pattern)) {
[10:22:34.030]                           computeRestarts <- base::computeRestarts
[10:22:34.030]                           grepl <- base::grepl
[10:22:34.030]                           restarts <- computeRestarts(cond)
[10:22:34.030]                           for (restart in restarts) {
[10:22:34.030]                             name <- restart$name
[10:22:34.030]                             if (is.null(name)) 
[10:22:34.030]                               next
[10:22:34.030]                             if (!grepl(pattern, name)) 
[10:22:34.030]                               next
[10:22:34.030]                             invokeRestart(restart)
[10:22:34.030]                             muffled <- TRUE
[10:22:34.030]                             break
[10:22:34.030]                           }
[10:22:34.030]                         }
[10:22:34.030]                       }
[10:22:34.030]                       invisible(muffled)
[10:22:34.030]                     }
[10:22:34.030]                     muffleCondition(cond, pattern = "^muffle")
[10:22:34.030]                   }
[10:22:34.030]                 }
[10:22:34.030]                 else {
[10:22:34.030]                   if (TRUE) {
[10:22:34.030]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:34.030]                     {
[10:22:34.030]                       inherits <- base::inherits
[10:22:34.030]                       invokeRestart <- base::invokeRestart
[10:22:34.030]                       is.null <- base::is.null
[10:22:34.030]                       muffled <- FALSE
[10:22:34.030]                       if (inherits(cond, "message")) {
[10:22:34.030]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:34.030]                         if (muffled) 
[10:22:34.030]                           invokeRestart("muffleMessage")
[10:22:34.030]                       }
[10:22:34.030]                       else if (inherits(cond, "warning")) {
[10:22:34.030]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:34.030]                         if (muffled) 
[10:22:34.030]                           invokeRestart("muffleWarning")
[10:22:34.030]                       }
[10:22:34.030]                       else if (inherits(cond, "condition")) {
[10:22:34.030]                         if (!is.null(pattern)) {
[10:22:34.030]                           computeRestarts <- base::computeRestarts
[10:22:34.030]                           grepl <- base::grepl
[10:22:34.030]                           restarts <- computeRestarts(cond)
[10:22:34.030]                           for (restart in restarts) {
[10:22:34.030]                             name <- restart$name
[10:22:34.030]                             if (is.null(name)) 
[10:22:34.030]                               next
[10:22:34.030]                             if (!grepl(pattern, name)) 
[10:22:34.030]                               next
[10:22:34.030]                             invokeRestart(restart)
[10:22:34.030]                             muffled <- TRUE
[10:22:34.030]                             break
[10:22:34.030]                           }
[10:22:34.030]                         }
[10:22:34.030]                       }
[10:22:34.030]                       invisible(muffled)
[10:22:34.030]                     }
[10:22:34.030]                     muffleCondition(cond, pattern = "^muffle")
[10:22:34.030]                   }
[10:22:34.030]                 }
[10:22:34.030]             }
[10:22:34.030]         }))
[10:22:34.030]     }, error = function(ex) {
[10:22:34.030]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:34.030]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:34.030]                 ...future.rng), started = ...future.startTime, 
[10:22:34.030]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:34.030]             version = "1.8"), class = "FutureResult")
[10:22:34.030]     }, finally = {
[10:22:34.030]         if (!identical(...future.workdir, getwd())) 
[10:22:34.030]             setwd(...future.workdir)
[10:22:34.030]         {
[10:22:34.030]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:34.030]                 ...future.oldOptions$nwarnings <- NULL
[10:22:34.030]             }
[10:22:34.030]             base::options(...future.oldOptions)
[10:22:34.030]             if (.Platform$OS.type == "windows") {
[10:22:34.030]                 old_names <- names(...future.oldEnvVars)
[10:22:34.030]                 envs <- base::Sys.getenv()
[10:22:34.030]                 names <- names(envs)
[10:22:34.030]                 common <- intersect(names, old_names)
[10:22:34.030]                 added <- setdiff(names, old_names)
[10:22:34.030]                 removed <- setdiff(old_names, names)
[10:22:34.030]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:34.030]                   envs[common]]
[10:22:34.030]                 NAMES <- toupper(changed)
[10:22:34.030]                 args <- list()
[10:22:34.030]                 for (kk in seq_along(NAMES)) {
[10:22:34.030]                   name <- changed[[kk]]
[10:22:34.030]                   NAME <- NAMES[[kk]]
[10:22:34.030]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:34.030]                     next
[10:22:34.030]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:34.030]                 }
[10:22:34.030]                 NAMES <- toupper(added)
[10:22:34.030]                 for (kk in seq_along(NAMES)) {
[10:22:34.030]                   name <- added[[kk]]
[10:22:34.030]                   NAME <- NAMES[[kk]]
[10:22:34.030]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:34.030]                     next
[10:22:34.030]                   args[[name]] <- ""
[10:22:34.030]                 }
[10:22:34.030]                 NAMES <- toupper(removed)
[10:22:34.030]                 for (kk in seq_along(NAMES)) {
[10:22:34.030]                   name <- removed[[kk]]
[10:22:34.030]                   NAME <- NAMES[[kk]]
[10:22:34.030]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:34.030]                     next
[10:22:34.030]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:34.030]                 }
[10:22:34.030]                 if (length(args) > 0) 
[10:22:34.030]                   base::do.call(base::Sys.setenv, args = args)
[10:22:34.030]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:34.030]             }
[10:22:34.030]             else {
[10:22:34.030]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:34.030]             }
[10:22:34.030]             {
[10:22:34.030]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:34.030]                   0L) {
[10:22:34.030]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:34.030]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:34.030]                   base::options(opts)
[10:22:34.030]                 }
[10:22:34.030]                 {
[10:22:34.030]                   {
[10:22:34.030]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:34.030]                     NULL
[10:22:34.030]                   }
[10:22:34.030]                   options(future.plan = NULL)
[10:22:34.030]                   if (is.na(NA_character_)) 
[10:22:34.030]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:34.030]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:34.030]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:34.030]                     .init = FALSE)
[10:22:34.030]                 }
[10:22:34.030]             }
[10:22:34.030]         }
[10:22:34.030]     })
[10:22:34.030]     if (TRUE) {
[10:22:34.030]         base::sink(type = "output", split = FALSE)
[10:22:34.030]         if (TRUE) {
[10:22:34.030]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:34.030]         }
[10:22:34.030]         else {
[10:22:34.030]             ...future.result["stdout"] <- base::list(NULL)
[10:22:34.030]         }
[10:22:34.030]         base::close(...future.stdout)
[10:22:34.030]         ...future.stdout <- NULL
[10:22:34.030]     }
[10:22:34.030]     ...future.result$conditions <- ...future.conditions
[10:22:34.030]     ...future.result$finished <- base::Sys.time()
[10:22:34.030]     ...future.result
[10:22:34.030] }
[10:22:34.033] MultisessionFuture started
[10:22:34.033] - Launch lazy future ... done
[10:22:34.033] run() for ‘MultisessionFuture’ ... done
[10:22:34.576] receiveMessageFromWorker() for ClusterFuture ...
[10:22:34.576] - Validating connection of MultisessionFuture
[10:22:34.576] - received message: FutureResult
[10:22:34.576] - Received FutureResult
[10:22:34.577] - Erased future from FutureRegistry
[10:22:34.577] result() for ClusterFuture ...
[10:22:34.577] - result already collected: FutureResult
[10:22:34.577] result() for ClusterFuture ... done
[10:22:34.577] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:34.577] A MultisessionFuture was resolved (result was not collected)
[10:22:34.577] getGlobalsAndPackages() ...
[10:22:34.577] Searching for globals...
[10:22:34.578] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:22:34.578] Searching for globals ... DONE
[10:22:34.579] Resolving globals: FALSE
[10:22:34.579] 
[10:22:34.579] 
[10:22:34.579] getGlobalsAndPackages() ... DONE
[10:22:34.579] run() for ‘Future’ ...
[10:22:34.579] - state: ‘created’
[10:22:34.580] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:34.594] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:34.594] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:34.594]   - Field: ‘node’
[10:22:34.594]   - Field: ‘label’
[10:22:34.594]   - Field: ‘local’
[10:22:34.594]   - Field: ‘owner’
[10:22:34.594]   - Field: ‘envir’
[10:22:34.594]   - Field: ‘workers’
[10:22:34.595]   - Field: ‘packages’
[10:22:34.595]   - Field: ‘gc’
[10:22:34.595]   - Field: ‘conditions’
[10:22:34.595]   - Field: ‘persistent’
[10:22:34.595]   - Field: ‘expr’
[10:22:34.595]   - Field: ‘uuid’
[10:22:34.595]   - Field: ‘seed’
[10:22:34.595]   - Field: ‘version’
[10:22:34.595]   - Field: ‘result’
[10:22:34.595]   - Field: ‘asynchronous’
[10:22:34.595]   - Field: ‘calls’
[10:22:34.595]   - Field: ‘globals’
[10:22:34.596]   - Field: ‘stdout’
[10:22:34.596]   - Field: ‘earlySignal’
[10:22:34.596]   - Field: ‘lazy’
[10:22:34.596]   - Field: ‘state’
[10:22:34.596] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:34.596] - Launch lazy future ...
[10:22:34.596] Packages needed by the future expression (n = 0): <none>
[10:22:34.596] Packages needed by future strategies (n = 0): <none>
[10:22:34.597] {
[10:22:34.597]     {
[10:22:34.597]         {
[10:22:34.597]             ...future.startTime <- base::Sys.time()
[10:22:34.597]             {
[10:22:34.597]                 {
[10:22:34.597]                   {
[10:22:34.597]                     {
[10:22:34.597]                       base::local({
[10:22:34.597]                         has_future <- base::requireNamespace("future", 
[10:22:34.597]                           quietly = TRUE)
[10:22:34.597]                         if (has_future) {
[10:22:34.597]                           ns <- base::getNamespace("future")
[10:22:34.597]                           version <- ns[[".package"]][["version"]]
[10:22:34.597]                           if (is.null(version)) 
[10:22:34.597]                             version <- utils::packageVersion("future")
[10:22:34.597]                         }
[10:22:34.597]                         else {
[10:22:34.597]                           version <- NULL
[10:22:34.597]                         }
[10:22:34.597]                         if (!has_future || version < "1.8.0") {
[10:22:34.597]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:34.597]                             "", base::R.version$version.string), 
[10:22:34.597]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:34.597]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:34.597]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:34.597]                               "release", "version")], collapse = " "), 
[10:22:34.597]                             hostname = base::Sys.info()[["nodename"]])
[10:22:34.597]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:34.597]                             info)
[10:22:34.597]                           info <- base::paste(info, collapse = "; ")
[10:22:34.597]                           if (!has_future) {
[10:22:34.597]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:34.597]                               info)
[10:22:34.597]                           }
[10:22:34.597]                           else {
[10:22:34.597]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:34.597]                               info, version)
[10:22:34.597]                           }
[10:22:34.597]                           base::stop(msg)
[10:22:34.597]                         }
[10:22:34.597]                       })
[10:22:34.597]                     }
[10:22:34.597]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:34.597]                     base::options(mc.cores = 1L)
[10:22:34.597]                   }
[10:22:34.597]                   ...future.strategy.old <- future::plan("list")
[10:22:34.597]                   options(future.plan = NULL)
[10:22:34.597]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:34.597]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:34.597]                 }
[10:22:34.597]                 ...future.workdir <- getwd()
[10:22:34.597]             }
[10:22:34.597]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:34.597]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:34.597]         }
[10:22:34.597]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:34.597]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:34.597]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:34.597]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:34.597]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:34.597]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:34.597]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:34.597]             base::names(...future.oldOptions))
[10:22:34.597]     }
[10:22:34.597]     if (FALSE) {
[10:22:34.597]     }
[10:22:34.597]     else {
[10:22:34.597]         if (TRUE) {
[10:22:34.597]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:34.597]                 open = "w")
[10:22:34.597]         }
[10:22:34.597]         else {
[10:22:34.597]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:34.597]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:34.597]         }
[10:22:34.597]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:34.597]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:34.597]             base::sink(type = "output", split = FALSE)
[10:22:34.597]             base::close(...future.stdout)
[10:22:34.597]         }, add = TRUE)
[10:22:34.597]     }
[10:22:34.597]     ...future.frame <- base::sys.nframe()
[10:22:34.597]     ...future.conditions <- base::list()
[10:22:34.597]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:34.597]     if (FALSE) {
[10:22:34.597]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:34.597]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:34.597]     }
[10:22:34.597]     ...future.result <- base::tryCatch({
[10:22:34.597]         base::withCallingHandlers({
[10:22:34.597]             ...future.value <- base::withVisible(base::local({
[10:22:34.597]                 ...future.makeSendCondition <- base::local({
[10:22:34.597]                   sendCondition <- NULL
[10:22:34.597]                   function(frame = 1L) {
[10:22:34.597]                     if (is.function(sendCondition)) 
[10:22:34.597]                       return(sendCondition)
[10:22:34.597]                     ns <- getNamespace("parallel")
[10:22:34.597]                     if (exists("sendData", mode = "function", 
[10:22:34.597]                       envir = ns)) {
[10:22:34.597]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:34.597]                         envir = ns)
[10:22:34.597]                       envir <- sys.frame(frame)
[10:22:34.597]                       master <- NULL
[10:22:34.597]                       while (!identical(envir, .GlobalEnv) && 
[10:22:34.597]                         !identical(envir, emptyenv())) {
[10:22:34.597]                         if (exists("master", mode = "list", envir = envir, 
[10:22:34.597]                           inherits = FALSE)) {
[10:22:34.597]                           master <- get("master", mode = "list", 
[10:22:34.597]                             envir = envir, inherits = FALSE)
[10:22:34.597]                           if (inherits(master, c("SOCKnode", 
[10:22:34.597]                             "SOCK0node"))) {
[10:22:34.597]                             sendCondition <<- function(cond) {
[10:22:34.597]                               data <- list(type = "VALUE", value = cond, 
[10:22:34.597]                                 success = TRUE)
[10:22:34.597]                               parallel_sendData(master, data)
[10:22:34.597]                             }
[10:22:34.597]                             return(sendCondition)
[10:22:34.597]                           }
[10:22:34.597]                         }
[10:22:34.597]                         frame <- frame + 1L
[10:22:34.597]                         envir <- sys.frame(frame)
[10:22:34.597]                       }
[10:22:34.597]                     }
[10:22:34.597]                     sendCondition <<- function(cond) NULL
[10:22:34.597]                   }
[10:22:34.597]                 })
[10:22:34.597]                 withCallingHandlers({
[10:22:34.597]                   {
[10:22:34.597]                     Sys.sleep(0.5)
[10:22:34.597]                     list(a = 1, b = 42L)
[10:22:34.597]                   }
[10:22:34.597]                 }, immediateCondition = function(cond) {
[10:22:34.597]                   sendCondition <- ...future.makeSendCondition()
[10:22:34.597]                   sendCondition(cond)
[10:22:34.597]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:34.597]                   {
[10:22:34.597]                     inherits <- base::inherits
[10:22:34.597]                     invokeRestart <- base::invokeRestart
[10:22:34.597]                     is.null <- base::is.null
[10:22:34.597]                     muffled <- FALSE
[10:22:34.597]                     if (inherits(cond, "message")) {
[10:22:34.597]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:34.597]                       if (muffled) 
[10:22:34.597]                         invokeRestart("muffleMessage")
[10:22:34.597]                     }
[10:22:34.597]                     else if (inherits(cond, "warning")) {
[10:22:34.597]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:34.597]                       if (muffled) 
[10:22:34.597]                         invokeRestart("muffleWarning")
[10:22:34.597]                     }
[10:22:34.597]                     else if (inherits(cond, "condition")) {
[10:22:34.597]                       if (!is.null(pattern)) {
[10:22:34.597]                         computeRestarts <- base::computeRestarts
[10:22:34.597]                         grepl <- base::grepl
[10:22:34.597]                         restarts <- computeRestarts(cond)
[10:22:34.597]                         for (restart in restarts) {
[10:22:34.597]                           name <- restart$name
[10:22:34.597]                           if (is.null(name)) 
[10:22:34.597]                             next
[10:22:34.597]                           if (!grepl(pattern, name)) 
[10:22:34.597]                             next
[10:22:34.597]                           invokeRestart(restart)
[10:22:34.597]                           muffled <- TRUE
[10:22:34.597]                           break
[10:22:34.597]                         }
[10:22:34.597]                       }
[10:22:34.597]                     }
[10:22:34.597]                     invisible(muffled)
[10:22:34.597]                   }
[10:22:34.597]                   muffleCondition(cond)
[10:22:34.597]                 })
[10:22:34.597]             }))
[10:22:34.597]             future::FutureResult(value = ...future.value$value, 
[10:22:34.597]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:34.597]                   ...future.rng), globalenv = if (FALSE) 
[10:22:34.597]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:34.597]                     ...future.globalenv.names))
[10:22:34.597]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:34.597]         }, condition = base::local({
[10:22:34.597]             c <- base::c
[10:22:34.597]             inherits <- base::inherits
[10:22:34.597]             invokeRestart <- base::invokeRestart
[10:22:34.597]             length <- base::length
[10:22:34.597]             list <- base::list
[10:22:34.597]             seq.int <- base::seq.int
[10:22:34.597]             signalCondition <- base::signalCondition
[10:22:34.597]             sys.calls <- base::sys.calls
[10:22:34.597]             `[[` <- base::`[[`
[10:22:34.597]             `+` <- base::`+`
[10:22:34.597]             `<<-` <- base::`<<-`
[10:22:34.597]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:34.597]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:34.597]                   3L)]
[10:22:34.597]             }
[10:22:34.597]             function(cond) {
[10:22:34.597]                 is_error <- inherits(cond, "error")
[10:22:34.597]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:34.597]                   NULL)
[10:22:34.597]                 if (is_error) {
[10:22:34.597]                   sessionInformation <- function() {
[10:22:34.597]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:34.597]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:34.597]                       search = base::search(), system = base::Sys.info())
[10:22:34.597]                   }
[10:22:34.597]                   ...future.conditions[[length(...future.conditions) + 
[10:22:34.597]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:34.597]                     cond$call), session = sessionInformation(), 
[10:22:34.597]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:34.597]                   signalCondition(cond)
[10:22:34.597]                 }
[10:22:34.597]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:34.597]                 "immediateCondition"))) {
[10:22:34.597]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:34.597]                   ...future.conditions[[length(...future.conditions) + 
[10:22:34.597]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:34.597]                   if (TRUE && !signal) {
[10:22:34.597]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:34.597]                     {
[10:22:34.597]                       inherits <- base::inherits
[10:22:34.597]                       invokeRestart <- base::invokeRestart
[10:22:34.597]                       is.null <- base::is.null
[10:22:34.597]                       muffled <- FALSE
[10:22:34.597]                       if (inherits(cond, "message")) {
[10:22:34.597]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:34.597]                         if (muffled) 
[10:22:34.597]                           invokeRestart("muffleMessage")
[10:22:34.597]                       }
[10:22:34.597]                       else if (inherits(cond, "warning")) {
[10:22:34.597]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:34.597]                         if (muffled) 
[10:22:34.597]                           invokeRestart("muffleWarning")
[10:22:34.597]                       }
[10:22:34.597]                       else if (inherits(cond, "condition")) {
[10:22:34.597]                         if (!is.null(pattern)) {
[10:22:34.597]                           computeRestarts <- base::computeRestarts
[10:22:34.597]                           grepl <- base::grepl
[10:22:34.597]                           restarts <- computeRestarts(cond)
[10:22:34.597]                           for (restart in restarts) {
[10:22:34.597]                             name <- restart$name
[10:22:34.597]                             if (is.null(name)) 
[10:22:34.597]                               next
[10:22:34.597]                             if (!grepl(pattern, name)) 
[10:22:34.597]                               next
[10:22:34.597]                             invokeRestart(restart)
[10:22:34.597]                             muffled <- TRUE
[10:22:34.597]                             break
[10:22:34.597]                           }
[10:22:34.597]                         }
[10:22:34.597]                       }
[10:22:34.597]                       invisible(muffled)
[10:22:34.597]                     }
[10:22:34.597]                     muffleCondition(cond, pattern = "^muffle")
[10:22:34.597]                   }
[10:22:34.597]                 }
[10:22:34.597]                 else {
[10:22:34.597]                   if (TRUE) {
[10:22:34.597]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:34.597]                     {
[10:22:34.597]                       inherits <- base::inherits
[10:22:34.597]                       invokeRestart <- base::invokeRestart
[10:22:34.597]                       is.null <- base::is.null
[10:22:34.597]                       muffled <- FALSE
[10:22:34.597]                       if (inherits(cond, "message")) {
[10:22:34.597]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:34.597]                         if (muffled) 
[10:22:34.597]                           invokeRestart("muffleMessage")
[10:22:34.597]                       }
[10:22:34.597]                       else if (inherits(cond, "warning")) {
[10:22:34.597]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:34.597]                         if (muffled) 
[10:22:34.597]                           invokeRestart("muffleWarning")
[10:22:34.597]                       }
[10:22:34.597]                       else if (inherits(cond, "condition")) {
[10:22:34.597]                         if (!is.null(pattern)) {
[10:22:34.597]                           computeRestarts <- base::computeRestarts
[10:22:34.597]                           grepl <- base::grepl
[10:22:34.597]                           restarts <- computeRestarts(cond)
[10:22:34.597]                           for (restart in restarts) {
[10:22:34.597]                             name <- restart$name
[10:22:34.597]                             if (is.null(name)) 
[10:22:34.597]                               next
[10:22:34.597]                             if (!grepl(pattern, name)) 
[10:22:34.597]                               next
[10:22:34.597]                             invokeRestart(restart)
[10:22:34.597]                             muffled <- TRUE
[10:22:34.597]                             break
[10:22:34.597]                           }
[10:22:34.597]                         }
[10:22:34.597]                       }
[10:22:34.597]                       invisible(muffled)
[10:22:34.597]                     }
[10:22:34.597]                     muffleCondition(cond, pattern = "^muffle")
[10:22:34.597]                   }
[10:22:34.597]                 }
[10:22:34.597]             }
[10:22:34.597]         }))
[10:22:34.597]     }, error = function(ex) {
[10:22:34.597]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:34.597]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:34.597]                 ...future.rng), started = ...future.startTime, 
[10:22:34.597]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:34.597]             version = "1.8"), class = "FutureResult")
[10:22:34.597]     }, finally = {
[10:22:34.597]         if (!identical(...future.workdir, getwd())) 
[10:22:34.597]             setwd(...future.workdir)
[10:22:34.597]         {
[10:22:34.597]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:34.597]                 ...future.oldOptions$nwarnings <- NULL
[10:22:34.597]             }
[10:22:34.597]             base::options(...future.oldOptions)
[10:22:34.597]             if (.Platform$OS.type == "windows") {
[10:22:34.597]                 old_names <- names(...future.oldEnvVars)
[10:22:34.597]                 envs <- base::Sys.getenv()
[10:22:34.597]                 names <- names(envs)
[10:22:34.597]                 common <- intersect(names, old_names)
[10:22:34.597]                 added <- setdiff(names, old_names)
[10:22:34.597]                 removed <- setdiff(old_names, names)
[10:22:34.597]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:34.597]                   envs[common]]
[10:22:34.597]                 NAMES <- toupper(changed)
[10:22:34.597]                 args <- list()
[10:22:34.597]                 for (kk in seq_along(NAMES)) {
[10:22:34.597]                   name <- changed[[kk]]
[10:22:34.597]                   NAME <- NAMES[[kk]]
[10:22:34.597]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:34.597]                     next
[10:22:34.597]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:34.597]                 }
[10:22:34.597]                 NAMES <- toupper(added)
[10:22:34.597]                 for (kk in seq_along(NAMES)) {
[10:22:34.597]                   name <- added[[kk]]
[10:22:34.597]                   NAME <- NAMES[[kk]]
[10:22:34.597]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:34.597]                     next
[10:22:34.597]                   args[[name]] <- ""
[10:22:34.597]                 }
[10:22:34.597]                 NAMES <- toupper(removed)
[10:22:34.597]                 for (kk in seq_along(NAMES)) {
[10:22:34.597]                   name <- removed[[kk]]
[10:22:34.597]                   NAME <- NAMES[[kk]]
[10:22:34.597]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:34.597]                     next
[10:22:34.597]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:34.597]                 }
[10:22:34.597]                 if (length(args) > 0) 
[10:22:34.597]                   base::do.call(base::Sys.setenv, args = args)
[10:22:34.597]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:34.597]             }
[10:22:34.597]             else {
[10:22:34.597]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:34.597]             }
[10:22:34.597]             {
[10:22:34.597]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:34.597]                   0L) {
[10:22:34.597]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:34.597]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:34.597]                   base::options(opts)
[10:22:34.597]                 }
[10:22:34.597]                 {
[10:22:34.597]                   {
[10:22:34.597]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:34.597]                     NULL
[10:22:34.597]                   }
[10:22:34.597]                   options(future.plan = NULL)
[10:22:34.597]                   if (is.na(NA_character_)) 
[10:22:34.597]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:34.597]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:34.597]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:34.597]                     .init = FALSE)
[10:22:34.597]                 }
[10:22:34.597]             }
[10:22:34.597]         }
[10:22:34.597]     })
[10:22:34.597]     if (TRUE) {
[10:22:34.597]         base::sink(type = "output", split = FALSE)
[10:22:34.597]         if (TRUE) {
[10:22:34.597]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:34.597]         }
[10:22:34.597]         else {
[10:22:34.597]             ...future.result["stdout"] <- base::list(NULL)
[10:22:34.597]         }
[10:22:34.597]         base::close(...future.stdout)
[10:22:34.597]         ...future.stdout <- NULL
[10:22:34.597]     }
[10:22:34.597]     ...future.result$conditions <- ...future.conditions
[10:22:34.597]     ...future.result$finished <- base::Sys.time()
[10:22:34.597]     ...future.result
[10:22:34.597] }
[10:22:34.600] MultisessionFuture started
[10:22:34.600] - Launch lazy future ... done
[10:22:34.600] run() for ‘MultisessionFuture’ ... done
[10:22:35.143] receiveMessageFromWorker() for ClusterFuture ...
[10:22:35.143] - Validating connection of MultisessionFuture
[10:22:35.143] - received message: FutureResult
[10:22:35.143] - Received FutureResult
[10:22:35.144] - Erased future from FutureRegistry
[10:22:35.144] result() for ClusterFuture ...
[10:22:35.144] - result already collected: FutureResult
[10:22:35.144] result() for ClusterFuture ... done
[10:22:35.144] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:35.144] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[10:22:35.144] getGlobalsAndPackages() ...
[10:22:35.144] Searching for globals...
[10:22:35.145] - globals found: [2] ‘list’, ‘stop’
[10:22:35.145] Searching for globals ... DONE
[10:22:35.145] Resolving globals: FALSE
[10:22:35.145] 
[10:22:35.146] 
[10:22:35.146] getGlobalsAndPackages() ... DONE
[10:22:35.146] run() for ‘Future’ ...
[10:22:35.146] - state: ‘created’
[10:22:35.146] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:35.160] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:35.160] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:35.160]   - Field: ‘node’
[10:22:35.160]   - Field: ‘label’
[10:22:35.160]   - Field: ‘local’
[10:22:35.160]   - Field: ‘owner’
[10:22:35.161]   - Field: ‘envir’
[10:22:35.161]   - Field: ‘workers’
[10:22:35.161]   - Field: ‘packages’
[10:22:35.161]   - Field: ‘gc’
[10:22:35.161]   - Field: ‘conditions’
[10:22:35.161]   - Field: ‘persistent’
[10:22:35.161]   - Field: ‘expr’
[10:22:35.161]   - Field: ‘uuid’
[10:22:35.161]   - Field: ‘seed’
[10:22:35.161]   - Field: ‘version’
[10:22:35.161]   - Field: ‘result’
[10:22:35.161]   - Field: ‘asynchronous’
[10:22:35.162]   - Field: ‘calls’
[10:22:35.162]   - Field: ‘globals’
[10:22:35.162]   - Field: ‘stdout’
[10:22:35.162]   - Field: ‘earlySignal’
[10:22:35.162]   - Field: ‘lazy’
[10:22:35.162]   - Field: ‘state’
[10:22:35.162] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:35.162] - Launch lazy future ...
[10:22:35.162] Packages needed by the future expression (n = 0): <none>
[10:22:35.163] Packages needed by future strategies (n = 0): <none>
[10:22:35.163] {
[10:22:35.163]     {
[10:22:35.163]         {
[10:22:35.163]             ...future.startTime <- base::Sys.time()
[10:22:35.163]             {
[10:22:35.163]                 {
[10:22:35.163]                   {
[10:22:35.163]                     {
[10:22:35.163]                       base::local({
[10:22:35.163]                         has_future <- base::requireNamespace("future", 
[10:22:35.163]                           quietly = TRUE)
[10:22:35.163]                         if (has_future) {
[10:22:35.163]                           ns <- base::getNamespace("future")
[10:22:35.163]                           version <- ns[[".package"]][["version"]]
[10:22:35.163]                           if (is.null(version)) 
[10:22:35.163]                             version <- utils::packageVersion("future")
[10:22:35.163]                         }
[10:22:35.163]                         else {
[10:22:35.163]                           version <- NULL
[10:22:35.163]                         }
[10:22:35.163]                         if (!has_future || version < "1.8.0") {
[10:22:35.163]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:35.163]                             "", base::R.version$version.string), 
[10:22:35.163]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:35.163]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:35.163]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:35.163]                               "release", "version")], collapse = " "), 
[10:22:35.163]                             hostname = base::Sys.info()[["nodename"]])
[10:22:35.163]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:35.163]                             info)
[10:22:35.163]                           info <- base::paste(info, collapse = "; ")
[10:22:35.163]                           if (!has_future) {
[10:22:35.163]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:35.163]                               info)
[10:22:35.163]                           }
[10:22:35.163]                           else {
[10:22:35.163]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:35.163]                               info, version)
[10:22:35.163]                           }
[10:22:35.163]                           base::stop(msg)
[10:22:35.163]                         }
[10:22:35.163]                       })
[10:22:35.163]                     }
[10:22:35.163]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:35.163]                     base::options(mc.cores = 1L)
[10:22:35.163]                   }
[10:22:35.163]                   ...future.strategy.old <- future::plan("list")
[10:22:35.163]                   options(future.plan = NULL)
[10:22:35.163]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:35.163]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:35.163]                 }
[10:22:35.163]                 ...future.workdir <- getwd()
[10:22:35.163]             }
[10:22:35.163]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:35.163]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:35.163]         }
[10:22:35.163]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:35.163]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:35.163]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:35.163]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:35.163]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:35.163]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:35.163]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:35.163]             base::names(...future.oldOptions))
[10:22:35.163]     }
[10:22:35.163]     if (FALSE) {
[10:22:35.163]     }
[10:22:35.163]     else {
[10:22:35.163]         if (TRUE) {
[10:22:35.163]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:35.163]                 open = "w")
[10:22:35.163]         }
[10:22:35.163]         else {
[10:22:35.163]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:35.163]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:35.163]         }
[10:22:35.163]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:35.163]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:35.163]             base::sink(type = "output", split = FALSE)
[10:22:35.163]             base::close(...future.stdout)
[10:22:35.163]         }, add = TRUE)
[10:22:35.163]     }
[10:22:35.163]     ...future.frame <- base::sys.nframe()
[10:22:35.163]     ...future.conditions <- base::list()
[10:22:35.163]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:35.163]     if (FALSE) {
[10:22:35.163]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:35.163]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:35.163]     }
[10:22:35.163]     ...future.result <- base::tryCatch({
[10:22:35.163]         base::withCallingHandlers({
[10:22:35.163]             ...future.value <- base::withVisible(base::local({
[10:22:35.163]                 ...future.makeSendCondition <- base::local({
[10:22:35.163]                   sendCondition <- NULL
[10:22:35.163]                   function(frame = 1L) {
[10:22:35.163]                     if (is.function(sendCondition)) 
[10:22:35.163]                       return(sendCondition)
[10:22:35.163]                     ns <- getNamespace("parallel")
[10:22:35.163]                     if (exists("sendData", mode = "function", 
[10:22:35.163]                       envir = ns)) {
[10:22:35.163]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:35.163]                         envir = ns)
[10:22:35.163]                       envir <- sys.frame(frame)
[10:22:35.163]                       master <- NULL
[10:22:35.163]                       while (!identical(envir, .GlobalEnv) && 
[10:22:35.163]                         !identical(envir, emptyenv())) {
[10:22:35.163]                         if (exists("master", mode = "list", envir = envir, 
[10:22:35.163]                           inherits = FALSE)) {
[10:22:35.163]                           master <- get("master", mode = "list", 
[10:22:35.163]                             envir = envir, inherits = FALSE)
[10:22:35.163]                           if (inherits(master, c("SOCKnode", 
[10:22:35.163]                             "SOCK0node"))) {
[10:22:35.163]                             sendCondition <<- function(cond) {
[10:22:35.163]                               data <- list(type = "VALUE", value = cond, 
[10:22:35.163]                                 success = TRUE)
[10:22:35.163]                               parallel_sendData(master, data)
[10:22:35.163]                             }
[10:22:35.163]                             return(sendCondition)
[10:22:35.163]                           }
[10:22:35.163]                         }
[10:22:35.163]                         frame <- frame + 1L
[10:22:35.163]                         envir <- sys.frame(frame)
[10:22:35.163]                       }
[10:22:35.163]                     }
[10:22:35.163]                     sendCondition <<- function(cond) NULL
[10:22:35.163]                   }
[10:22:35.163]                 })
[10:22:35.163]                 withCallingHandlers({
[10:22:35.163]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:22:35.163]                 }, immediateCondition = function(cond) {
[10:22:35.163]                   sendCondition <- ...future.makeSendCondition()
[10:22:35.163]                   sendCondition(cond)
[10:22:35.163]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:35.163]                   {
[10:22:35.163]                     inherits <- base::inherits
[10:22:35.163]                     invokeRestart <- base::invokeRestart
[10:22:35.163]                     is.null <- base::is.null
[10:22:35.163]                     muffled <- FALSE
[10:22:35.163]                     if (inherits(cond, "message")) {
[10:22:35.163]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:35.163]                       if (muffled) 
[10:22:35.163]                         invokeRestart("muffleMessage")
[10:22:35.163]                     }
[10:22:35.163]                     else if (inherits(cond, "warning")) {
[10:22:35.163]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:35.163]                       if (muffled) 
[10:22:35.163]                         invokeRestart("muffleWarning")
[10:22:35.163]                     }
[10:22:35.163]                     else if (inherits(cond, "condition")) {
[10:22:35.163]                       if (!is.null(pattern)) {
[10:22:35.163]                         computeRestarts <- base::computeRestarts
[10:22:35.163]                         grepl <- base::grepl
[10:22:35.163]                         restarts <- computeRestarts(cond)
[10:22:35.163]                         for (restart in restarts) {
[10:22:35.163]                           name <- restart$name
[10:22:35.163]                           if (is.null(name)) 
[10:22:35.163]                             next
[10:22:35.163]                           if (!grepl(pattern, name)) 
[10:22:35.163]                             next
[10:22:35.163]                           invokeRestart(restart)
[10:22:35.163]                           muffled <- TRUE
[10:22:35.163]                           break
[10:22:35.163]                         }
[10:22:35.163]                       }
[10:22:35.163]                     }
[10:22:35.163]                     invisible(muffled)
[10:22:35.163]                   }
[10:22:35.163]                   muffleCondition(cond)
[10:22:35.163]                 })
[10:22:35.163]             }))
[10:22:35.163]             future::FutureResult(value = ...future.value$value, 
[10:22:35.163]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:35.163]                   ...future.rng), globalenv = if (FALSE) 
[10:22:35.163]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:35.163]                     ...future.globalenv.names))
[10:22:35.163]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:35.163]         }, condition = base::local({
[10:22:35.163]             c <- base::c
[10:22:35.163]             inherits <- base::inherits
[10:22:35.163]             invokeRestart <- base::invokeRestart
[10:22:35.163]             length <- base::length
[10:22:35.163]             list <- base::list
[10:22:35.163]             seq.int <- base::seq.int
[10:22:35.163]             signalCondition <- base::signalCondition
[10:22:35.163]             sys.calls <- base::sys.calls
[10:22:35.163]             `[[` <- base::`[[`
[10:22:35.163]             `+` <- base::`+`
[10:22:35.163]             `<<-` <- base::`<<-`
[10:22:35.163]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:35.163]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:35.163]                   3L)]
[10:22:35.163]             }
[10:22:35.163]             function(cond) {
[10:22:35.163]                 is_error <- inherits(cond, "error")
[10:22:35.163]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:35.163]                   NULL)
[10:22:35.163]                 if (is_error) {
[10:22:35.163]                   sessionInformation <- function() {
[10:22:35.163]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:35.163]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:35.163]                       search = base::search(), system = base::Sys.info())
[10:22:35.163]                   }
[10:22:35.163]                   ...future.conditions[[length(...future.conditions) + 
[10:22:35.163]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:35.163]                     cond$call), session = sessionInformation(), 
[10:22:35.163]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:35.163]                   signalCondition(cond)
[10:22:35.163]                 }
[10:22:35.163]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:35.163]                 "immediateCondition"))) {
[10:22:35.163]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:35.163]                   ...future.conditions[[length(...future.conditions) + 
[10:22:35.163]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:35.163]                   if (TRUE && !signal) {
[10:22:35.163]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:35.163]                     {
[10:22:35.163]                       inherits <- base::inherits
[10:22:35.163]                       invokeRestart <- base::invokeRestart
[10:22:35.163]                       is.null <- base::is.null
[10:22:35.163]                       muffled <- FALSE
[10:22:35.163]                       if (inherits(cond, "message")) {
[10:22:35.163]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:35.163]                         if (muffled) 
[10:22:35.163]                           invokeRestart("muffleMessage")
[10:22:35.163]                       }
[10:22:35.163]                       else if (inherits(cond, "warning")) {
[10:22:35.163]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:35.163]                         if (muffled) 
[10:22:35.163]                           invokeRestart("muffleWarning")
[10:22:35.163]                       }
[10:22:35.163]                       else if (inherits(cond, "condition")) {
[10:22:35.163]                         if (!is.null(pattern)) {
[10:22:35.163]                           computeRestarts <- base::computeRestarts
[10:22:35.163]                           grepl <- base::grepl
[10:22:35.163]                           restarts <- computeRestarts(cond)
[10:22:35.163]                           for (restart in restarts) {
[10:22:35.163]                             name <- restart$name
[10:22:35.163]                             if (is.null(name)) 
[10:22:35.163]                               next
[10:22:35.163]                             if (!grepl(pattern, name)) 
[10:22:35.163]                               next
[10:22:35.163]                             invokeRestart(restart)
[10:22:35.163]                             muffled <- TRUE
[10:22:35.163]                             break
[10:22:35.163]                           }
[10:22:35.163]                         }
[10:22:35.163]                       }
[10:22:35.163]                       invisible(muffled)
[10:22:35.163]                     }
[10:22:35.163]                     muffleCondition(cond, pattern = "^muffle")
[10:22:35.163]                   }
[10:22:35.163]                 }
[10:22:35.163]                 else {
[10:22:35.163]                   if (TRUE) {
[10:22:35.163]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:35.163]                     {
[10:22:35.163]                       inherits <- base::inherits
[10:22:35.163]                       invokeRestart <- base::invokeRestart
[10:22:35.163]                       is.null <- base::is.null
[10:22:35.163]                       muffled <- FALSE
[10:22:35.163]                       if (inherits(cond, "message")) {
[10:22:35.163]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:35.163]                         if (muffled) 
[10:22:35.163]                           invokeRestart("muffleMessage")
[10:22:35.163]                       }
[10:22:35.163]                       else if (inherits(cond, "warning")) {
[10:22:35.163]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:35.163]                         if (muffled) 
[10:22:35.163]                           invokeRestart("muffleWarning")
[10:22:35.163]                       }
[10:22:35.163]                       else if (inherits(cond, "condition")) {
[10:22:35.163]                         if (!is.null(pattern)) {
[10:22:35.163]                           computeRestarts <- base::computeRestarts
[10:22:35.163]                           grepl <- base::grepl
[10:22:35.163]                           restarts <- computeRestarts(cond)
[10:22:35.163]                           for (restart in restarts) {
[10:22:35.163]                             name <- restart$name
[10:22:35.163]                             if (is.null(name)) 
[10:22:35.163]                               next
[10:22:35.163]                             if (!grepl(pattern, name)) 
[10:22:35.163]                               next
[10:22:35.163]                             invokeRestart(restart)
[10:22:35.163]                             muffled <- TRUE
[10:22:35.163]                             break
[10:22:35.163]                           }
[10:22:35.163]                         }
[10:22:35.163]                       }
[10:22:35.163]                       invisible(muffled)
[10:22:35.163]                     }
[10:22:35.163]                     muffleCondition(cond, pattern = "^muffle")
[10:22:35.163]                   }
[10:22:35.163]                 }
[10:22:35.163]             }
[10:22:35.163]         }))
[10:22:35.163]     }, error = function(ex) {
[10:22:35.163]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:35.163]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:35.163]                 ...future.rng), started = ...future.startTime, 
[10:22:35.163]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:35.163]             version = "1.8"), class = "FutureResult")
[10:22:35.163]     }, finally = {
[10:22:35.163]         if (!identical(...future.workdir, getwd())) 
[10:22:35.163]             setwd(...future.workdir)
[10:22:35.163]         {
[10:22:35.163]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:35.163]                 ...future.oldOptions$nwarnings <- NULL
[10:22:35.163]             }
[10:22:35.163]             base::options(...future.oldOptions)
[10:22:35.163]             if (.Platform$OS.type == "windows") {
[10:22:35.163]                 old_names <- names(...future.oldEnvVars)
[10:22:35.163]                 envs <- base::Sys.getenv()
[10:22:35.163]                 names <- names(envs)
[10:22:35.163]                 common <- intersect(names, old_names)
[10:22:35.163]                 added <- setdiff(names, old_names)
[10:22:35.163]                 removed <- setdiff(old_names, names)
[10:22:35.163]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:35.163]                   envs[common]]
[10:22:35.163]                 NAMES <- toupper(changed)
[10:22:35.163]                 args <- list()
[10:22:35.163]                 for (kk in seq_along(NAMES)) {
[10:22:35.163]                   name <- changed[[kk]]
[10:22:35.163]                   NAME <- NAMES[[kk]]
[10:22:35.163]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:35.163]                     next
[10:22:35.163]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:35.163]                 }
[10:22:35.163]                 NAMES <- toupper(added)
[10:22:35.163]                 for (kk in seq_along(NAMES)) {
[10:22:35.163]                   name <- added[[kk]]
[10:22:35.163]                   NAME <- NAMES[[kk]]
[10:22:35.163]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:35.163]                     next
[10:22:35.163]                   args[[name]] <- ""
[10:22:35.163]                 }
[10:22:35.163]                 NAMES <- toupper(removed)
[10:22:35.163]                 for (kk in seq_along(NAMES)) {
[10:22:35.163]                   name <- removed[[kk]]
[10:22:35.163]                   NAME <- NAMES[[kk]]
[10:22:35.163]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:35.163]                     next
[10:22:35.163]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:35.163]                 }
[10:22:35.163]                 if (length(args) > 0) 
[10:22:35.163]                   base::do.call(base::Sys.setenv, args = args)
[10:22:35.163]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:35.163]             }
[10:22:35.163]             else {
[10:22:35.163]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:35.163]             }
[10:22:35.163]             {
[10:22:35.163]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:35.163]                   0L) {
[10:22:35.163]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:35.163]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:35.163]                   base::options(opts)
[10:22:35.163]                 }
[10:22:35.163]                 {
[10:22:35.163]                   {
[10:22:35.163]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:35.163]                     NULL
[10:22:35.163]                   }
[10:22:35.163]                   options(future.plan = NULL)
[10:22:35.163]                   if (is.na(NA_character_)) 
[10:22:35.163]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:35.163]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:35.163]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:35.163]                     .init = FALSE)
[10:22:35.163]                 }
[10:22:35.163]             }
[10:22:35.163]         }
[10:22:35.163]     })
[10:22:35.163]     if (TRUE) {
[10:22:35.163]         base::sink(type = "output", split = FALSE)
[10:22:35.163]         if (TRUE) {
[10:22:35.163]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:35.163]         }
[10:22:35.163]         else {
[10:22:35.163]             ...future.result["stdout"] <- base::list(NULL)
[10:22:35.163]         }
[10:22:35.163]         base::close(...future.stdout)
[10:22:35.163]         ...future.stdout <- NULL
[10:22:35.163]     }
[10:22:35.163]     ...future.result$conditions <- ...future.conditions
[10:22:35.163]     ...future.result$finished <- base::Sys.time()
[10:22:35.163]     ...future.result
[10:22:35.163] }
[10:22:35.166] MultisessionFuture started
[10:22:35.166] - Launch lazy future ... done
[10:22:35.166] run() for ‘MultisessionFuture’ ... done
[10:22:35.208] receiveMessageFromWorker() for ClusterFuture ...
[10:22:35.208] - Validating connection of MultisessionFuture
[10:22:35.209] - received message: FutureResult
[10:22:35.209] - Received FutureResult
[10:22:35.209] - Erased future from FutureRegistry
[10:22:35.209] result() for ClusterFuture ...
[10:22:35.209] - result already collected: FutureResult
[10:22:35.209] result() for ClusterFuture ... done
[10:22:35.210] signalConditions() ...
[10:22:35.210]  - include = ‘immediateCondition’
[10:22:35.210]  - exclude = 
[10:22:35.210]  - resignal = FALSE
[10:22:35.210]  - Number of conditions: 1
[10:22:35.210] signalConditions() ... done
[10:22:35.210] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:35.210] A MultisessionFuture was resolved (result was not collected)
[10:22:35.210] getGlobalsAndPackages() ...
[10:22:35.210] Searching for globals...
[10:22:35.211] - globals found: [2] ‘list’, ‘stop’
[10:22:35.211] Searching for globals ... DONE
[10:22:35.211] Resolving globals: FALSE
[10:22:35.212] 
[10:22:35.212] 
[10:22:35.212] getGlobalsAndPackages() ... DONE
[10:22:35.212] run() for ‘Future’ ...
[10:22:35.212] - state: ‘created’
[10:22:35.212] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:35.226] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:35.226] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:35.226]   - Field: ‘node’
[10:22:35.226]   - Field: ‘label’
[10:22:35.226]   - Field: ‘local’
[10:22:35.226]   - Field: ‘owner’
[10:22:35.226]   - Field: ‘envir’
[10:22:35.226]   - Field: ‘workers’
[10:22:35.226]   - Field: ‘packages’
[10:22:35.226]   - Field: ‘gc’
[10:22:35.227]   - Field: ‘conditions’
[10:22:35.227]   - Field: ‘persistent’
[10:22:35.227]   - Field: ‘expr’
[10:22:35.227]   - Field: ‘uuid’
[10:22:35.227]   - Field: ‘seed’
[10:22:35.227]   - Field: ‘version’
[10:22:35.227]   - Field: ‘result’
[10:22:35.227]   - Field: ‘asynchronous’
[10:22:35.227]   - Field: ‘calls’
[10:22:35.227]   - Field: ‘globals’
[10:22:35.227]   - Field: ‘stdout’
[10:22:35.228]   - Field: ‘earlySignal’
[10:22:35.228]   - Field: ‘lazy’
[10:22:35.228]   - Field: ‘state’
[10:22:35.228] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:35.228] - Launch lazy future ...
[10:22:35.228] Packages needed by the future expression (n = 0): <none>
[10:22:35.228] Packages needed by future strategies (n = 0): <none>
[10:22:35.229] {
[10:22:35.229]     {
[10:22:35.229]         {
[10:22:35.229]             ...future.startTime <- base::Sys.time()
[10:22:35.229]             {
[10:22:35.229]                 {
[10:22:35.229]                   {
[10:22:35.229]                     {
[10:22:35.229]                       base::local({
[10:22:35.229]                         has_future <- base::requireNamespace("future", 
[10:22:35.229]                           quietly = TRUE)
[10:22:35.229]                         if (has_future) {
[10:22:35.229]                           ns <- base::getNamespace("future")
[10:22:35.229]                           version <- ns[[".package"]][["version"]]
[10:22:35.229]                           if (is.null(version)) 
[10:22:35.229]                             version <- utils::packageVersion("future")
[10:22:35.229]                         }
[10:22:35.229]                         else {
[10:22:35.229]                           version <- NULL
[10:22:35.229]                         }
[10:22:35.229]                         if (!has_future || version < "1.8.0") {
[10:22:35.229]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:35.229]                             "", base::R.version$version.string), 
[10:22:35.229]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:35.229]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:35.229]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:35.229]                               "release", "version")], collapse = " "), 
[10:22:35.229]                             hostname = base::Sys.info()[["nodename"]])
[10:22:35.229]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:35.229]                             info)
[10:22:35.229]                           info <- base::paste(info, collapse = "; ")
[10:22:35.229]                           if (!has_future) {
[10:22:35.229]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:35.229]                               info)
[10:22:35.229]                           }
[10:22:35.229]                           else {
[10:22:35.229]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:35.229]                               info, version)
[10:22:35.229]                           }
[10:22:35.229]                           base::stop(msg)
[10:22:35.229]                         }
[10:22:35.229]                       })
[10:22:35.229]                     }
[10:22:35.229]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:35.229]                     base::options(mc.cores = 1L)
[10:22:35.229]                   }
[10:22:35.229]                   ...future.strategy.old <- future::plan("list")
[10:22:35.229]                   options(future.plan = NULL)
[10:22:35.229]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:35.229]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:35.229]                 }
[10:22:35.229]                 ...future.workdir <- getwd()
[10:22:35.229]             }
[10:22:35.229]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:35.229]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:35.229]         }
[10:22:35.229]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:35.229]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:35.229]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:35.229]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:35.229]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:35.229]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:35.229]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:35.229]             base::names(...future.oldOptions))
[10:22:35.229]     }
[10:22:35.229]     if (FALSE) {
[10:22:35.229]     }
[10:22:35.229]     else {
[10:22:35.229]         if (TRUE) {
[10:22:35.229]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:35.229]                 open = "w")
[10:22:35.229]         }
[10:22:35.229]         else {
[10:22:35.229]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:35.229]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:35.229]         }
[10:22:35.229]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:35.229]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:35.229]             base::sink(type = "output", split = FALSE)
[10:22:35.229]             base::close(...future.stdout)
[10:22:35.229]         }, add = TRUE)
[10:22:35.229]     }
[10:22:35.229]     ...future.frame <- base::sys.nframe()
[10:22:35.229]     ...future.conditions <- base::list()
[10:22:35.229]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:35.229]     if (FALSE) {
[10:22:35.229]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:35.229]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:35.229]     }
[10:22:35.229]     ...future.result <- base::tryCatch({
[10:22:35.229]         base::withCallingHandlers({
[10:22:35.229]             ...future.value <- base::withVisible(base::local({
[10:22:35.229]                 ...future.makeSendCondition <- base::local({
[10:22:35.229]                   sendCondition <- NULL
[10:22:35.229]                   function(frame = 1L) {
[10:22:35.229]                     if (is.function(sendCondition)) 
[10:22:35.229]                       return(sendCondition)
[10:22:35.229]                     ns <- getNamespace("parallel")
[10:22:35.229]                     if (exists("sendData", mode = "function", 
[10:22:35.229]                       envir = ns)) {
[10:22:35.229]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:35.229]                         envir = ns)
[10:22:35.229]                       envir <- sys.frame(frame)
[10:22:35.229]                       master <- NULL
[10:22:35.229]                       while (!identical(envir, .GlobalEnv) && 
[10:22:35.229]                         !identical(envir, emptyenv())) {
[10:22:35.229]                         if (exists("master", mode = "list", envir = envir, 
[10:22:35.229]                           inherits = FALSE)) {
[10:22:35.229]                           master <- get("master", mode = "list", 
[10:22:35.229]                             envir = envir, inherits = FALSE)
[10:22:35.229]                           if (inherits(master, c("SOCKnode", 
[10:22:35.229]                             "SOCK0node"))) {
[10:22:35.229]                             sendCondition <<- function(cond) {
[10:22:35.229]                               data <- list(type = "VALUE", value = cond, 
[10:22:35.229]                                 success = TRUE)
[10:22:35.229]                               parallel_sendData(master, data)
[10:22:35.229]                             }
[10:22:35.229]                             return(sendCondition)
[10:22:35.229]                           }
[10:22:35.229]                         }
[10:22:35.229]                         frame <- frame + 1L
[10:22:35.229]                         envir <- sys.frame(frame)
[10:22:35.229]                       }
[10:22:35.229]                     }
[10:22:35.229]                     sendCondition <<- function(cond) NULL
[10:22:35.229]                   }
[10:22:35.229]                 })
[10:22:35.229]                 withCallingHandlers({
[10:22:35.229]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:22:35.229]                 }, immediateCondition = function(cond) {
[10:22:35.229]                   sendCondition <- ...future.makeSendCondition()
[10:22:35.229]                   sendCondition(cond)
[10:22:35.229]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:35.229]                   {
[10:22:35.229]                     inherits <- base::inherits
[10:22:35.229]                     invokeRestart <- base::invokeRestart
[10:22:35.229]                     is.null <- base::is.null
[10:22:35.229]                     muffled <- FALSE
[10:22:35.229]                     if (inherits(cond, "message")) {
[10:22:35.229]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:35.229]                       if (muffled) 
[10:22:35.229]                         invokeRestart("muffleMessage")
[10:22:35.229]                     }
[10:22:35.229]                     else if (inherits(cond, "warning")) {
[10:22:35.229]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:35.229]                       if (muffled) 
[10:22:35.229]                         invokeRestart("muffleWarning")
[10:22:35.229]                     }
[10:22:35.229]                     else if (inherits(cond, "condition")) {
[10:22:35.229]                       if (!is.null(pattern)) {
[10:22:35.229]                         computeRestarts <- base::computeRestarts
[10:22:35.229]                         grepl <- base::grepl
[10:22:35.229]                         restarts <- computeRestarts(cond)
[10:22:35.229]                         for (restart in restarts) {
[10:22:35.229]                           name <- restart$name
[10:22:35.229]                           if (is.null(name)) 
[10:22:35.229]                             next
[10:22:35.229]                           if (!grepl(pattern, name)) 
[10:22:35.229]                             next
[10:22:35.229]                           invokeRestart(restart)
[10:22:35.229]                           muffled <- TRUE
[10:22:35.229]                           break
[10:22:35.229]                         }
[10:22:35.229]                       }
[10:22:35.229]                     }
[10:22:35.229]                     invisible(muffled)
[10:22:35.229]                   }
[10:22:35.229]                   muffleCondition(cond)
[10:22:35.229]                 })
[10:22:35.229]             }))
[10:22:35.229]             future::FutureResult(value = ...future.value$value, 
[10:22:35.229]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:35.229]                   ...future.rng), globalenv = if (FALSE) 
[10:22:35.229]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:35.229]                     ...future.globalenv.names))
[10:22:35.229]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:35.229]         }, condition = base::local({
[10:22:35.229]             c <- base::c
[10:22:35.229]             inherits <- base::inherits
[10:22:35.229]             invokeRestart <- base::invokeRestart
[10:22:35.229]             length <- base::length
[10:22:35.229]             list <- base::list
[10:22:35.229]             seq.int <- base::seq.int
[10:22:35.229]             signalCondition <- base::signalCondition
[10:22:35.229]             sys.calls <- base::sys.calls
[10:22:35.229]             `[[` <- base::`[[`
[10:22:35.229]             `+` <- base::`+`
[10:22:35.229]             `<<-` <- base::`<<-`
[10:22:35.229]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:35.229]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:35.229]                   3L)]
[10:22:35.229]             }
[10:22:35.229]             function(cond) {
[10:22:35.229]                 is_error <- inherits(cond, "error")
[10:22:35.229]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:35.229]                   NULL)
[10:22:35.229]                 if (is_error) {
[10:22:35.229]                   sessionInformation <- function() {
[10:22:35.229]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:35.229]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:35.229]                       search = base::search(), system = base::Sys.info())
[10:22:35.229]                   }
[10:22:35.229]                   ...future.conditions[[length(...future.conditions) + 
[10:22:35.229]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:35.229]                     cond$call), session = sessionInformation(), 
[10:22:35.229]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:35.229]                   signalCondition(cond)
[10:22:35.229]                 }
[10:22:35.229]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:35.229]                 "immediateCondition"))) {
[10:22:35.229]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:35.229]                   ...future.conditions[[length(...future.conditions) + 
[10:22:35.229]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:35.229]                   if (TRUE && !signal) {
[10:22:35.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:35.229]                     {
[10:22:35.229]                       inherits <- base::inherits
[10:22:35.229]                       invokeRestart <- base::invokeRestart
[10:22:35.229]                       is.null <- base::is.null
[10:22:35.229]                       muffled <- FALSE
[10:22:35.229]                       if (inherits(cond, "message")) {
[10:22:35.229]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:35.229]                         if (muffled) 
[10:22:35.229]                           invokeRestart("muffleMessage")
[10:22:35.229]                       }
[10:22:35.229]                       else if (inherits(cond, "warning")) {
[10:22:35.229]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:35.229]                         if (muffled) 
[10:22:35.229]                           invokeRestart("muffleWarning")
[10:22:35.229]                       }
[10:22:35.229]                       else if (inherits(cond, "condition")) {
[10:22:35.229]                         if (!is.null(pattern)) {
[10:22:35.229]                           computeRestarts <- base::computeRestarts
[10:22:35.229]                           grepl <- base::grepl
[10:22:35.229]                           restarts <- computeRestarts(cond)
[10:22:35.229]                           for (restart in restarts) {
[10:22:35.229]                             name <- restart$name
[10:22:35.229]                             if (is.null(name)) 
[10:22:35.229]                               next
[10:22:35.229]                             if (!grepl(pattern, name)) 
[10:22:35.229]                               next
[10:22:35.229]                             invokeRestart(restart)
[10:22:35.229]                             muffled <- TRUE
[10:22:35.229]                             break
[10:22:35.229]                           }
[10:22:35.229]                         }
[10:22:35.229]                       }
[10:22:35.229]                       invisible(muffled)
[10:22:35.229]                     }
[10:22:35.229]                     muffleCondition(cond, pattern = "^muffle")
[10:22:35.229]                   }
[10:22:35.229]                 }
[10:22:35.229]                 else {
[10:22:35.229]                   if (TRUE) {
[10:22:35.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:35.229]                     {
[10:22:35.229]                       inherits <- base::inherits
[10:22:35.229]                       invokeRestart <- base::invokeRestart
[10:22:35.229]                       is.null <- base::is.null
[10:22:35.229]                       muffled <- FALSE
[10:22:35.229]                       if (inherits(cond, "message")) {
[10:22:35.229]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:35.229]                         if (muffled) 
[10:22:35.229]                           invokeRestart("muffleMessage")
[10:22:35.229]                       }
[10:22:35.229]                       else if (inherits(cond, "warning")) {
[10:22:35.229]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:35.229]                         if (muffled) 
[10:22:35.229]                           invokeRestart("muffleWarning")
[10:22:35.229]                       }
[10:22:35.229]                       else if (inherits(cond, "condition")) {
[10:22:35.229]                         if (!is.null(pattern)) {
[10:22:35.229]                           computeRestarts <- base::computeRestarts
[10:22:35.229]                           grepl <- base::grepl
[10:22:35.229]                           restarts <- computeRestarts(cond)
[10:22:35.229]                           for (restart in restarts) {
[10:22:35.229]                             name <- restart$name
[10:22:35.229]                             if (is.null(name)) 
[10:22:35.229]                               next
[10:22:35.229]                             if (!grepl(pattern, name)) 
[10:22:35.229]                               next
[10:22:35.229]                             invokeRestart(restart)
[10:22:35.229]                             muffled <- TRUE
[10:22:35.229]                             break
[10:22:35.229]                           }
[10:22:35.229]                         }
[10:22:35.229]                       }
[10:22:35.229]                       invisible(muffled)
[10:22:35.229]                     }
[10:22:35.229]                     muffleCondition(cond, pattern = "^muffle")
[10:22:35.229]                   }
[10:22:35.229]                 }
[10:22:35.229]             }
[10:22:35.229]         }))
[10:22:35.229]     }, error = function(ex) {
[10:22:35.229]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:35.229]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:35.229]                 ...future.rng), started = ...future.startTime, 
[10:22:35.229]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:35.229]             version = "1.8"), class = "FutureResult")
[10:22:35.229]     }, finally = {
[10:22:35.229]         if (!identical(...future.workdir, getwd())) 
[10:22:35.229]             setwd(...future.workdir)
[10:22:35.229]         {
[10:22:35.229]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:35.229]                 ...future.oldOptions$nwarnings <- NULL
[10:22:35.229]             }
[10:22:35.229]             base::options(...future.oldOptions)
[10:22:35.229]             if (.Platform$OS.type == "windows") {
[10:22:35.229]                 old_names <- names(...future.oldEnvVars)
[10:22:35.229]                 envs <- base::Sys.getenv()
[10:22:35.229]                 names <- names(envs)
[10:22:35.229]                 common <- intersect(names, old_names)
[10:22:35.229]                 added <- setdiff(names, old_names)
[10:22:35.229]                 removed <- setdiff(old_names, names)
[10:22:35.229]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:35.229]                   envs[common]]
[10:22:35.229]                 NAMES <- toupper(changed)
[10:22:35.229]                 args <- list()
[10:22:35.229]                 for (kk in seq_along(NAMES)) {
[10:22:35.229]                   name <- changed[[kk]]
[10:22:35.229]                   NAME <- NAMES[[kk]]
[10:22:35.229]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:35.229]                     next
[10:22:35.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:35.229]                 }
[10:22:35.229]                 NAMES <- toupper(added)
[10:22:35.229]                 for (kk in seq_along(NAMES)) {
[10:22:35.229]                   name <- added[[kk]]
[10:22:35.229]                   NAME <- NAMES[[kk]]
[10:22:35.229]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:35.229]                     next
[10:22:35.229]                   args[[name]] <- ""
[10:22:35.229]                 }
[10:22:35.229]                 NAMES <- toupper(removed)
[10:22:35.229]                 for (kk in seq_along(NAMES)) {
[10:22:35.229]                   name <- removed[[kk]]
[10:22:35.229]                   NAME <- NAMES[[kk]]
[10:22:35.229]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:35.229]                     next
[10:22:35.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:35.229]                 }
[10:22:35.229]                 if (length(args) > 0) 
[10:22:35.229]                   base::do.call(base::Sys.setenv, args = args)
[10:22:35.229]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:35.229]             }
[10:22:35.229]             else {
[10:22:35.229]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:35.229]             }
[10:22:35.229]             {
[10:22:35.229]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:35.229]                   0L) {
[10:22:35.229]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:35.229]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:35.229]                   base::options(opts)
[10:22:35.229]                 }
[10:22:35.229]                 {
[10:22:35.229]                   {
[10:22:35.229]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:35.229]                     NULL
[10:22:35.229]                   }
[10:22:35.229]                   options(future.plan = NULL)
[10:22:35.229]                   if (is.na(NA_character_)) 
[10:22:35.229]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:35.229]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:35.229]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:35.229]                     .init = FALSE)
[10:22:35.229]                 }
[10:22:35.229]             }
[10:22:35.229]         }
[10:22:35.229]     })
[10:22:35.229]     if (TRUE) {
[10:22:35.229]         base::sink(type = "output", split = FALSE)
[10:22:35.229]         if (TRUE) {
[10:22:35.229]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:35.229]         }
[10:22:35.229]         else {
[10:22:35.229]             ...future.result["stdout"] <- base::list(NULL)
[10:22:35.229]         }
[10:22:35.229]         base::close(...future.stdout)
[10:22:35.229]         ...future.stdout <- NULL
[10:22:35.229]     }
[10:22:35.229]     ...future.result$conditions <- ...future.conditions
[10:22:35.229]     ...future.result$finished <- base::Sys.time()
[10:22:35.229]     ...future.result
[10:22:35.229] }
[10:22:35.231] MultisessionFuture started
[10:22:35.232] - Launch lazy future ... done
[10:22:35.232] run() for ‘MultisessionFuture’ ... done
[10:22:35.274] receiveMessageFromWorker() for ClusterFuture ...
[10:22:35.274] - Validating connection of MultisessionFuture
[10:22:35.275] - received message: FutureResult
[10:22:35.275] - Received FutureResult
[10:22:35.275] - Erased future from FutureRegistry
[10:22:35.275] result() for ClusterFuture ...
[10:22:35.275] - result already collected: FutureResult
[10:22:35.275] result() for ClusterFuture ... done
[10:22:35.275] signalConditions() ...
[10:22:35.275]  - include = ‘immediateCondition’
[10:22:35.275]  - exclude = 
[10:22:35.276]  - resignal = FALSE
[10:22:35.276]  - Number of conditions: 1
[10:22:35.276] signalConditions() ... done
[10:22:35.276] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:35.276] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = TRUE ... DONE
- result = FALSE, recursive = -1 ...
[10:22:35.276] getGlobalsAndPackages() ...
[10:22:35.276] Searching for globals...
[10:22:35.277] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:22:35.277] Searching for globals ... DONE
[10:22:35.277] Resolving globals: FALSE
[10:22:35.278] 
[10:22:35.278] 
[10:22:35.278] getGlobalsAndPackages() ... DONE
[10:22:35.278] run() for ‘Future’ ...
[10:22:35.278] - state: ‘created’
[10:22:35.278] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:35.292] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:35.292] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:35.292]   - Field: ‘node’
[10:22:35.292]   - Field: ‘label’
[10:22:35.292]   - Field: ‘local’
[10:22:35.292]   - Field: ‘owner’
[10:22:35.292]   - Field: ‘envir’
[10:22:35.292]   - Field: ‘workers’
[10:22:35.293]   - Field: ‘packages’
[10:22:35.293]   - Field: ‘gc’
[10:22:35.293]   - Field: ‘conditions’
[10:22:35.293]   - Field: ‘persistent’
[10:22:35.293]   - Field: ‘expr’
[10:22:35.293]   - Field: ‘uuid’
[10:22:35.293]   - Field: ‘seed’
[10:22:35.293]   - Field: ‘version’
[10:22:35.293]   - Field: ‘result’
[10:22:35.293]   - Field: ‘asynchronous’
[10:22:35.293]   - Field: ‘calls’
[10:22:35.293]   - Field: ‘globals’
[10:22:35.294]   - Field: ‘stdout’
[10:22:35.294]   - Field: ‘earlySignal’
[10:22:35.294]   - Field: ‘lazy’
[10:22:35.294]   - Field: ‘state’
[10:22:35.294] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:35.294] - Launch lazy future ...
[10:22:35.294] Packages needed by the future expression (n = 0): <none>
[10:22:35.294] Packages needed by future strategies (n = 0): <none>
[10:22:35.295] {
[10:22:35.295]     {
[10:22:35.295]         {
[10:22:35.295]             ...future.startTime <- base::Sys.time()
[10:22:35.295]             {
[10:22:35.295]                 {
[10:22:35.295]                   {
[10:22:35.295]                     {
[10:22:35.295]                       base::local({
[10:22:35.295]                         has_future <- base::requireNamespace("future", 
[10:22:35.295]                           quietly = TRUE)
[10:22:35.295]                         if (has_future) {
[10:22:35.295]                           ns <- base::getNamespace("future")
[10:22:35.295]                           version <- ns[[".package"]][["version"]]
[10:22:35.295]                           if (is.null(version)) 
[10:22:35.295]                             version <- utils::packageVersion("future")
[10:22:35.295]                         }
[10:22:35.295]                         else {
[10:22:35.295]                           version <- NULL
[10:22:35.295]                         }
[10:22:35.295]                         if (!has_future || version < "1.8.0") {
[10:22:35.295]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:35.295]                             "", base::R.version$version.string), 
[10:22:35.295]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:35.295]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:35.295]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:35.295]                               "release", "version")], collapse = " "), 
[10:22:35.295]                             hostname = base::Sys.info()[["nodename"]])
[10:22:35.295]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:35.295]                             info)
[10:22:35.295]                           info <- base::paste(info, collapse = "; ")
[10:22:35.295]                           if (!has_future) {
[10:22:35.295]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:35.295]                               info)
[10:22:35.295]                           }
[10:22:35.295]                           else {
[10:22:35.295]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:35.295]                               info, version)
[10:22:35.295]                           }
[10:22:35.295]                           base::stop(msg)
[10:22:35.295]                         }
[10:22:35.295]                       })
[10:22:35.295]                     }
[10:22:35.295]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:35.295]                     base::options(mc.cores = 1L)
[10:22:35.295]                   }
[10:22:35.295]                   ...future.strategy.old <- future::plan("list")
[10:22:35.295]                   options(future.plan = NULL)
[10:22:35.295]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:35.295]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:35.295]                 }
[10:22:35.295]                 ...future.workdir <- getwd()
[10:22:35.295]             }
[10:22:35.295]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:35.295]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:35.295]         }
[10:22:35.295]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:35.295]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:35.295]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:35.295]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:35.295]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:35.295]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:35.295]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:35.295]             base::names(...future.oldOptions))
[10:22:35.295]     }
[10:22:35.295]     if (FALSE) {
[10:22:35.295]     }
[10:22:35.295]     else {
[10:22:35.295]         if (TRUE) {
[10:22:35.295]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:35.295]                 open = "w")
[10:22:35.295]         }
[10:22:35.295]         else {
[10:22:35.295]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:35.295]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:35.295]         }
[10:22:35.295]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:35.295]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:35.295]             base::sink(type = "output", split = FALSE)
[10:22:35.295]             base::close(...future.stdout)
[10:22:35.295]         }, add = TRUE)
[10:22:35.295]     }
[10:22:35.295]     ...future.frame <- base::sys.nframe()
[10:22:35.295]     ...future.conditions <- base::list()
[10:22:35.295]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:35.295]     if (FALSE) {
[10:22:35.295]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:35.295]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:35.295]     }
[10:22:35.295]     ...future.result <- base::tryCatch({
[10:22:35.295]         base::withCallingHandlers({
[10:22:35.295]             ...future.value <- base::withVisible(base::local({
[10:22:35.295]                 ...future.makeSendCondition <- base::local({
[10:22:35.295]                   sendCondition <- NULL
[10:22:35.295]                   function(frame = 1L) {
[10:22:35.295]                     if (is.function(sendCondition)) 
[10:22:35.295]                       return(sendCondition)
[10:22:35.295]                     ns <- getNamespace("parallel")
[10:22:35.295]                     if (exists("sendData", mode = "function", 
[10:22:35.295]                       envir = ns)) {
[10:22:35.295]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:35.295]                         envir = ns)
[10:22:35.295]                       envir <- sys.frame(frame)
[10:22:35.295]                       master <- NULL
[10:22:35.295]                       while (!identical(envir, .GlobalEnv) && 
[10:22:35.295]                         !identical(envir, emptyenv())) {
[10:22:35.295]                         if (exists("master", mode = "list", envir = envir, 
[10:22:35.295]                           inherits = FALSE)) {
[10:22:35.295]                           master <- get("master", mode = "list", 
[10:22:35.295]                             envir = envir, inherits = FALSE)
[10:22:35.295]                           if (inherits(master, c("SOCKnode", 
[10:22:35.295]                             "SOCK0node"))) {
[10:22:35.295]                             sendCondition <<- function(cond) {
[10:22:35.295]                               data <- list(type = "VALUE", value = cond, 
[10:22:35.295]                                 success = TRUE)
[10:22:35.295]                               parallel_sendData(master, data)
[10:22:35.295]                             }
[10:22:35.295]                             return(sendCondition)
[10:22:35.295]                           }
[10:22:35.295]                         }
[10:22:35.295]                         frame <- frame + 1L
[10:22:35.295]                         envir <- sys.frame(frame)
[10:22:35.295]                       }
[10:22:35.295]                     }
[10:22:35.295]                     sendCondition <<- function(cond) NULL
[10:22:35.295]                   }
[10:22:35.295]                 })
[10:22:35.295]                 withCallingHandlers({
[10:22:35.295]                   {
[10:22:35.295]                     Sys.sleep(0.5)
[10:22:35.295]                     list(a = 1, b = 42L)
[10:22:35.295]                   }
[10:22:35.295]                 }, immediateCondition = function(cond) {
[10:22:35.295]                   sendCondition <- ...future.makeSendCondition()
[10:22:35.295]                   sendCondition(cond)
[10:22:35.295]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:35.295]                   {
[10:22:35.295]                     inherits <- base::inherits
[10:22:35.295]                     invokeRestart <- base::invokeRestart
[10:22:35.295]                     is.null <- base::is.null
[10:22:35.295]                     muffled <- FALSE
[10:22:35.295]                     if (inherits(cond, "message")) {
[10:22:35.295]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:35.295]                       if (muffled) 
[10:22:35.295]                         invokeRestart("muffleMessage")
[10:22:35.295]                     }
[10:22:35.295]                     else if (inherits(cond, "warning")) {
[10:22:35.295]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:35.295]                       if (muffled) 
[10:22:35.295]                         invokeRestart("muffleWarning")
[10:22:35.295]                     }
[10:22:35.295]                     else if (inherits(cond, "condition")) {
[10:22:35.295]                       if (!is.null(pattern)) {
[10:22:35.295]                         computeRestarts <- base::computeRestarts
[10:22:35.295]                         grepl <- base::grepl
[10:22:35.295]                         restarts <- computeRestarts(cond)
[10:22:35.295]                         for (restart in restarts) {
[10:22:35.295]                           name <- restart$name
[10:22:35.295]                           if (is.null(name)) 
[10:22:35.295]                             next
[10:22:35.295]                           if (!grepl(pattern, name)) 
[10:22:35.295]                             next
[10:22:35.295]                           invokeRestart(restart)
[10:22:35.295]                           muffled <- TRUE
[10:22:35.295]                           break
[10:22:35.295]                         }
[10:22:35.295]                       }
[10:22:35.295]                     }
[10:22:35.295]                     invisible(muffled)
[10:22:35.295]                   }
[10:22:35.295]                   muffleCondition(cond)
[10:22:35.295]                 })
[10:22:35.295]             }))
[10:22:35.295]             future::FutureResult(value = ...future.value$value, 
[10:22:35.295]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:35.295]                   ...future.rng), globalenv = if (FALSE) 
[10:22:35.295]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:35.295]                     ...future.globalenv.names))
[10:22:35.295]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:35.295]         }, condition = base::local({
[10:22:35.295]             c <- base::c
[10:22:35.295]             inherits <- base::inherits
[10:22:35.295]             invokeRestart <- base::invokeRestart
[10:22:35.295]             length <- base::length
[10:22:35.295]             list <- base::list
[10:22:35.295]             seq.int <- base::seq.int
[10:22:35.295]             signalCondition <- base::signalCondition
[10:22:35.295]             sys.calls <- base::sys.calls
[10:22:35.295]             `[[` <- base::`[[`
[10:22:35.295]             `+` <- base::`+`
[10:22:35.295]             `<<-` <- base::`<<-`
[10:22:35.295]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:35.295]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:35.295]                   3L)]
[10:22:35.295]             }
[10:22:35.295]             function(cond) {
[10:22:35.295]                 is_error <- inherits(cond, "error")
[10:22:35.295]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:35.295]                   NULL)
[10:22:35.295]                 if (is_error) {
[10:22:35.295]                   sessionInformation <- function() {
[10:22:35.295]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:35.295]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:35.295]                       search = base::search(), system = base::Sys.info())
[10:22:35.295]                   }
[10:22:35.295]                   ...future.conditions[[length(...future.conditions) + 
[10:22:35.295]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:35.295]                     cond$call), session = sessionInformation(), 
[10:22:35.295]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:35.295]                   signalCondition(cond)
[10:22:35.295]                 }
[10:22:35.295]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:35.295]                 "immediateCondition"))) {
[10:22:35.295]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:35.295]                   ...future.conditions[[length(...future.conditions) + 
[10:22:35.295]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:35.295]                   if (TRUE && !signal) {
[10:22:35.295]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:35.295]                     {
[10:22:35.295]                       inherits <- base::inherits
[10:22:35.295]                       invokeRestart <- base::invokeRestart
[10:22:35.295]                       is.null <- base::is.null
[10:22:35.295]                       muffled <- FALSE
[10:22:35.295]                       if (inherits(cond, "message")) {
[10:22:35.295]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:35.295]                         if (muffled) 
[10:22:35.295]                           invokeRestart("muffleMessage")
[10:22:35.295]                       }
[10:22:35.295]                       else if (inherits(cond, "warning")) {
[10:22:35.295]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:35.295]                         if (muffled) 
[10:22:35.295]                           invokeRestart("muffleWarning")
[10:22:35.295]                       }
[10:22:35.295]                       else if (inherits(cond, "condition")) {
[10:22:35.295]                         if (!is.null(pattern)) {
[10:22:35.295]                           computeRestarts <- base::computeRestarts
[10:22:35.295]                           grepl <- base::grepl
[10:22:35.295]                           restarts <- computeRestarts(cond)
[10:22:35.295]                           for (restart in restarts) {
[10:22:35.295]                             name <- restart$name
[10:22:35.295]                             if (is.null(name)) 
[10:22:35.295]                               next
[10:22:35.295]                             if (!grepl(pattern, name)) 
[10:22:35.295]                               next
[10:22:35.295]                             invokeRestart(restart)
[10:22:35.295]                             muffled <- TRUE
[10:22:35.295]                             break
[10:22:35.295]                           }
[10:22:35.295]                         }
[10:22:35.295]                       }
[10:22:35.295]                       invisible(muffled)
[10:22:35.295]                     }
[10:22:35.295]                     muffleCondition(cond, pattern = "^muffle")
[10:22:35.295]                   }
[10:22:35.295]                 }
[10:22:35.295]                 else {
[10:22:35.295]                   if (TRUE) {
[10:22:35.295]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:35.295]                     {
[10:22:35.295]                       inherits <- base::inherits
[10:22:35.295]                       invokeRestart <- base::invokeRestart
[10:22:35.295]                       is.null <- base::is.null
[10:22:35.295]                       muffled <- FALSE
[10:22:35.295]                       if (inherits(cond, "message")) {
[10:22:35.295]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:35.295]                         if (muffled) 
[10:22:35.295]                           invokeRestart("muffleMessage")
[10:22:35.295]                       }
[10:22:35.295]                       else if (inherits(cond, "warning")) {
[10:22:35.295]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:35.295]                         if (muffled) 
[10:22:35.295]                           invokeRestart("muffleWarning")
[10:22:35.295]                       }
[10:22:35.295]                       else if (inherits(cond, "condition")) {
[10:22:35.295]                         if (!is.null(pattern)) {
[10:22:35.295]                           computeRestarts <- base::computeRestarts
[10:22:35.295]                           grepl <- base::grepl
[10:22:35.295]                           restarts <- computeRestarts(cond)
[10:22:35.295]                           for (restart in restarts) {
[10:22:35.295]                             name <- restart$name
[10:22:35.295]                             if (is.null(name)) 
[10:22:35.295]                               next
[10:22:35.295]                             if (!grepl(pattern, name)) 
[10:22:35.295]                               next
[10:22:35.295]                             invokeRestart(restart)
[10:22:35.295]                             muffled <- TRUE
[10:22:35.295]                             break
[10:22:35.295]                           }
[10:22:35.295]                         }
[10:22:35.295]                       }
[10:22:35.295]                       invisible(muffled)
[10:22:35.295]                     }
[10:22:35.295]                     muffleCondition(cond, pattern = "^muffle")
[10:22:35.295]                   }
[10:22:35.295]                 }
[10:22:35.295]             }
[10:22:35.295]         }))
[10:22:35.295]     }, error = function(ex) {
[10:22:35.295]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:35.295]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:35.295]                 ...future.rng), started = ...future.startTime, 
[10:22:35.295]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:35.295]             version = "1.8"), class = "FutureResult")
[10:22:35.295]     }, finally = {
[10:22:35.295]         if (!identical(...future.workdir, getwd())) 
[10:22:35.295]             setwd(...future.workdir)
[10:22:35.295]         {
[10:22:35.295]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:35.295]                 ...future.oldOptions$nwarnings <- NULL
[10:22:35.295]             }
[10:22:35.295]             base::options(...future.oldOptions)
[10:22:35.295]             if (.Platform$OS.type == "windows") {
[10:22:35.295]                 old_names <- names(...future.oldEnvVars)
[10:22:35.295]                 envs <- base::Sys.getenv()
[10:22:35.295]                 names <- names(envs)
[10:22:35.295]                 common <- intersect(names, old_names)
[10:22:35.295]                 added <- setdiff(names, old_names)
[10:22:35.295]                 removed <- setdiff(old_names, names)
[10:22:35.295]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:35.295]                   envs[common]]
[10:22:35.295]                 NAMES <- toupper(changed)
[10:22:35.295]                 args <- list()
[10:22:35.295]                 for (kk in seq_along(NAMES)) {
[10:22:35.295]                   name <- changed[[kk]]
[10:22:35.295]                   NAME <- NAMES[[kk]]
[10:22:35.295]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:35.295]                     next
[10:22:35.295]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:35.295]                 }
[10:22:35.295]                 NAMES <- toupper(added)
[10:22:35.295]                 for (kk in seq_along(NAMES)) {
[10:22:35.295]                   name <- added[[kk]]
[10:22:35.295]                   NAME <- NAMES[[kk]]
[10:22:35.295]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:35.295]                     next
[10:22:35.295]                   args[[name]] <- ""
[10:22:35.295]                 }
[10:22:35.295]                 NAMES <- toupper(removed)
[10:22:35.295]                 for (kk in seq_along(NAMES)) {
[10:22:35.295]                   name <- removed[[kk]]
[10:22:35.295]                   NAME <- NAMES[[kk]]
[10:22:35.295]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:35.295]                     next
[10:22:35.295]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:35.295]                 }
[10:22:35.295]                 if (length(args) > 0) 
[10:22:35.295]                   base::do.call(base::Sys.setenv, args = args)
[10:22:35.295]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:35.295]             }
[10:22:35.295]             else {
[10:22:35.295]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:35.295]             }
[10:22:35.295]             {
[10:22:35.295]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:35.295]                   0L) {
[10:22:35.295]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:35.295]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:35.295]                   base::options(opts)
[10:22:35.295]                 }
[10:22:35.295]                 {
[10:22:35.295]                   {
[10:22:35.295]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:35.295]                     NULL
[10:22:35.295]                   }
[10:22:35.295]                   options(future.plan = NULL)
[10:22:35.295]                   if (is.na(NA_character_)) 
[10:22:35.295]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:35.295]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:35.295]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:35.295]                     .init = FALSE)
[10:22:35.295]                 }
[10:22:35.295]             }
[10:22:35.295]         }
[10:22:35.295]     })
[10:22:35.295]     if (TRUE) {
[10:22:35.295]         base::sink(type = "output", split = FALSE)
[10:22:35.295]         if (TRUE) {
[10:22:35.295]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:35.295]         }
[10:22:35.295]         else {
[10:22:35.295]             ...future.result["stdout"] <- base::list(NULL)
[10:22:35.295]         }
[10:22:35.295]         base::close(...future.stdout)
[10:22:35.295]         ...future.stdout <- NULL
[10:22:35.295]     }
[10:22:35.295]     ...future.result$conditions <- ...future.conditions
[10:22:35.295]     ...future.result$finished <- base::Sys.time()
[10:22:35.295]     ...future.result
[10:22:35.295] }
[10:22:35.298] MultisessionFuture started
[10:22:35.298] - Launch lazy future ... done
[10:22:35.298] run() for ‘MultisessionFuture’ ... done
[10:22:35.298] getGlobalsAndPackages() ...
[10:22:35.298] Searching for globals...
[10:22:35.299] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:22:35.299] Searching for globals ... DONE
[10:22:35.299] Resolving globals: FALSE
[10:22:35.300] 
[10:22:35.300] 
[10:22:35.300] getGlobalsAndPackages() ... DONE
- w/ exception ...
[10:22:35.300] getGlobalsAndPackages() ...
[10:22:35.300] Searching for globals...
[10:22:35.301] - globals found: [2] ‘list’, ‘stop’
[10:22:35.301] Searching for globals ... DONE
[10:22:35.301] Resolving globals: FALSE
[10:22:35.301] 
[10:22:35.301] 
[10:22:35.301] getGlobalsAndPackages() ... DONE
[10:22:35.302] run() for ‘Future’ ...
[10:22:35.302] - state: ‘created’
[10:22:35.302] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:35.315] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:35.316] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:35.316]   - Field: ‘node’
[10:22:35.316]   - Field: ‘label’
[10:22:35.316]   - Field: ‘local’
[10:22:35.316]   - Field: ‘owner’
[10:22:35.316]   - Field: ‘envir’
[10:22:35.316]   - Field: ‘workers’
[10:22:35.316]   - Field: ‘packages’
[10:22:35.316]   - Field: ‘gc’
[10:22:35.316]   - Field: ‘conditions’
[10:22:35.316]   - Field: ‘persistent’
[10:22:35.316]   - Field: ‘expr’
[10:22:35.317]   - Field: ‘uuid’
[10:22:35.317]   - Field: ‘seed’
[10:22:35.317]   - Field: ‘version’
[10:22:35.317]   - Field: ‘result’
[10:22:35.317]   - Field: ‘asynchronous’
[10:22:35.317]   - Field: ‘calls’
[10:22:35.317]   - Field: ‘globals’
[10:22:35.317]   - Field: ‘stdout’
[10:22:35.317]   - Field: ‘earlySignal’
[10:22:35.317]   - Field: ‘lazy’
[10:22:35.317]   - Field: ‘state’
[10:22:35.317] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:35.318] - Launch lazy future ...
[10:22:35.318] Packages needed by the future expression (n = 0): <none>
[10:22:35.318] Packages needed by future strategies (n = 0): <none>
[10:22:35.318] {
[10:22:35.318]     {
[10:22:35.318]         {
[10:22:35.318]             ...future.startTime <- base::Sys.time()
[10:22:35.318]             {
[10:22:35.318]                 {
[10:22:35.318]                   {
[10:22:35.318]                     {
[10:22:35.318]                       base::local({
[10:22:35.318]                         has_future <- base::requireNamespace("future", 
[10:22:35.318]                           quietly = TRUE)
[10:22:35.318]                         if (has_future) {
[10:22:35.318]                           ns <- base::getNamespace("future")
[10:22:35.318]                           version <- ns[[".package"]][["version"]]
[10:22:35.318]                           if (is.null(version)) 
[10:22:35.318]                             version <- utils::packageVersion("future")
[10:22:35.318]                         }
[10:22:35.318]                         else {
[10:22:35.318]                           version <- NULL
[10:22:35.318]                         }
[10:22:35.318]                         if (!has_future || version < "1.8.0") {
[10:22:35.318]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:35.318]                             "", base::R.version$version.string), 
[10:22:35.318]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:35.318]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:35.318]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:35.318]                               "release", "version")], collapse = " "), 
[10:22:35.318]                             hostname = base::Sys.info()[["nodename"]])
[10:22:35.318]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:35.318]                             info)
[10:22:35.318]                           info <- base::paste(info, collapse = "; ")
[10:22:35.318]                           if (!has_future) {
[10:22:35.318]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:35.318]                               info)
[10:22:35.318]                           }
[10:22:35.318]                           else {
[10:22:35.318]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:35.318]                               info, version)
[10:22:35.318]                           }
[10:22:35.318]                           base::stop(msg)
[10:22:35.318]                         }
[10:22:35.318]                       })
[10:22:35.318]                     }
[10:22:35.318]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:35.318]                     base::options(mc.cores = 1L)
[10:22:35.318]                   }
[10:22:35.318]                   ...future.strategy.old <- future::plan("list")
[10:22:35.318]                   options(future.plan = NULL)
[10:22:35.318]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:35.318]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:35.318]                 }
[10:22:35.318]                 ...future.workdir <- getwd()
[10:22:35.318]             }
[10:22:35.318]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:35.318]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:35.318]         }
[10:22:35.318]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:35.318]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:35.318]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:35.318]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:35.318]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:35.318]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:35.318]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:35.318]             base::names(...future.oldOptions))
[10:22:35.318]     }
[10:22:35.318]     if (FALSE) {
[10:22:35.318]     }
[10:22:35.318]     else {
[10:22:35.318]         if (TRUE) {
[10:22:35.318]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:35.318]                 open = "w")
[10:22:35.318]         }
[10:22:35.318]         else {
[10:22:35.318]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:35.318]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:35.318]         }
[10:22:35.318]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:35.318]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:35.318]             base::sink(type = "output", split = FALSE)
[10:22:35.318]             base::close(...future.stdout)
[10:22:35.318]         }, add = TRUE)
[10:22:35.318]     }
[10:22:35.318]     ...future.frame <- base::sys.nframe()
[10:22:35.318]     ...future.conditions <- base::list()
[10:22:35.318]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:35.318]     if (FALSE) {
[10:22:35.318]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:35.318]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:35.318]     }
[10:22:35.318]     ...future.result <- base::tryCatch({
[10:22:35.318]         base::withCallingHandlers({
[10:22:35.318]             ...future.value <- base::withVisible(base::local({
[10:22:35.318]                 ...future.makeSendCondition <- base::local({
[10:22:35.318]                   sendCondition <- NULL
[10:22:35.318]                   function(frame = 1L) {
[10:22:35.318]                     if (is.function(sendCondition)) 
[10:22:35.318]                       return(sendCondition)
[10:22:35.318]                     ns <- getNamespace("parallel")
[10:22:35.318]                     if (exists("sendData", mode = "function", 
[10:22:35.318]                       envir = ns)) {
[10:22:35.318]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:35.318]                         envir = ns)
[10:22:35.318]                       envir <- sys.frame(frame)
[10:22:35.318]                       master <- NULL
[10:22:35.318]                       while (!identical(envir, .GlobalEnv) && 
[10:22:35.318]                         !identical(envir, emptyenv())) {
[10:22:35.318]                         if (exists("master", mode = "list", envir = envir, 
[10:22:35.318]                           inherits = FALSE)) {
[10:22:35.318]                           master <- get("master", mode = "list", 
[10:22:35.318]                             envir = envir, inherits = FALSE)
[10:22:35.318]                           if (inherits(master, c("SOCKnode", 
[10:22:35.318]                             "SOCK0node"))) {
[10:22:35.318]                             sendCondition <<- function(cond) {
[10:22:35.318]                               data <- list(type = "VALUE", value = cond, 
[10:22:35.318]                                 success = TRUE)
[10:22:35.318]                               parallel_sendData(master, data)
[10:22:35.318]                             }
[10:22:35.318]                             return(sendCondition)
[10:22:35.318]                           }
[10:22:35.318]                         }
[10:22:35.318]                         frame <- frame + 1L
[10:22:35.318]                         envir <- sys.frame(frame)
[10:22:35.318]                       }
[10:22:35.318]                     }
[10:22:35.318]                     sendCondition <<- function(cond) NULL
[10:22:35.318]                   }
[10:22:35.318]                 })
[10:22:35.318]                 withCallingHandlers({
[10:22:35.318]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:22:35.318]                 }, immediateCondition = function(cond) {
[10:22:35.318]                   sendCondition <- ...future.makeSendCondition()
[10:22:35.318]                   sendCondition(cond)
[10:22:35.318]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:35.318]                   {
[10:22:35.318]                     inherits <- base::inherits
[10:22:35.318]                     invokeRestart <- base::invokeRestart
[10:22:35.318]                     is.null <- base::is.null
[10:22:35.318]                     muffled <- FALSE
[10:22:35.318]                     if (inherits(cond, "message")) {
[10:22:35.318]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:35.318]                       if (muffled) 
[10:22:35.318]                         invokeRestart("muffleMessage")
[10:22:35.318]                     }
[10:22:35.318]                     else if (inherits(cond, "warning")) {
[10:22:35.318]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:35.318]                       if (muffled) 
[10:22:35.318]                         invokeRestart("muffleWarning")
[10:22:35.318]                     }
[10:22:35.318]                     else if (inherits(cond, "condition")) {
[10:22:35.318]                       if (!is.null(pattern)) {
[10:22:35.318]                         computeRestarts <- base::computeRestarts
[10:22:35.318]                         grepl <- base::grepl
[10:22:35.318]                         restarts <- computeRestarts(cond)
[10:22:35.318]                         for (restart in restarts) {
[10:22:35.318]                           name <- restart$name
[10:22:35.318]                           if (is.null(name)) 
[10:22:35.318]                             next
[10:22:35.318]                           if (!grepl(pattern, name)) 
[10:22:35.318]                             next
[10:22:35.318]                           invokeRestart(restart)
[10:22:35.318]                           muffled <- TRUE
[10:22:35.318]                           break
[10:22:35.318]                         }
[10:22:35.318]                       }
[10:22:35.318]                     }
[10:22:35.318]                     invisible(muffled)
[10:22:35.318]                   }
[10:22:35.318]                   muffleCondition(cond)
[10:22:35.318]                 })
[10:22:35.318]             }))
[10:22:35.318]             future::FutureResult(value = ...future.value$value, 
[10:22:35.318]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:35.318]                   ...future.rng), globalenv = if (FALSE) 
[10:22:35.318]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:35.318]                     ...future.globalenv.names))
[10:22:35.318]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:35.318]         }, condition = base::local({
[10:22:35.318]             c <- base::c
[10:22:35.318]             inherits <- base::inherits
[10:22:35.318]             invokeRestart <- base::invokeRestart
[10:22:35.318]             length <- base::length
[10:22:35.318]             list <- base::list
[10:22:35.318]             seq.int <- base::seq.int
[10:22:35.318]             signalCondition <- base::signalCondition
[10:22:35.318]             sys.calls <- base::sys.calls
[10:22:35.318]             `[[` <- base::`[[`
[10:22:35.318]             `+` <- base::`+`
[10:22:35.318]             `<<-` <- base::`<<-`
[10:22:35.318]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:35.318]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:35.318]                   3L)]
[10:22:35.318]             }
[10:22:35.318]             function(cond) {
[10:22:35.318]                 is_error <- inherits(cond, "error")
[10:22:35.318]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:35.318]                   NULL)
[10:22:35.318]                 if (is_error) {
[10:22:35.318]                   sessionInformation <- function() {
[10:22:35.318]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:35.318]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:35.318]                       search = base::search(), system = base::Sys.info())
[10:22:35.318]                   }
[10:22:35.318]                   ...future.conditions[[length(...future.conditions) + 
[10:22:35.318]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:35.318]                     cond$call), session = sessionInformation(), 
[10:22:35.318]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:35.318]                   signalCondition(cond)
[10:22:35.318]                 }
[10:22:35.318]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:35.318]                 "immediateCondition"))) {
[10:22:35.318]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:35.318]                   ...future.conditions[[length(...future.conditions) + 
[10:22:35.318]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:35.318]                   if (TRUE && !signal) {
[10:22:35.318]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:35.318]                     {
[10:22:35.318]                       inherits <- base::inherits
[10:22:35.318]                       invokeRestart <- base::invokeRestart
[10:22:35.318]                       is.null <- base::is.null
[10:22:35.318]                       muffled <- FALSE
[10:22:35.318]                       if (inherits(cond, "message")) {
[10:22:35.318]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:35.318]                         if (muffled) 
[10:22:35.318]                           invokeRestart("muffleMessage")
[10:22:35.318]                       }
[10:22:35.318]                       else if (inherits(cond, "warning")) {
[10:22:35.318]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:35.318]                         if (muffled) 
[10:22:35.318]                           invokeRestart("muffleWarning")
[10:22:35.318]                       }
[10:22:35.318]                       else if (inherits(cond, "condition")) {
[10:22:35.318]                         if (!is.null(pattern)) {
[10:22:35.318]                           computeRestarts <- base::computeRestarts
[10:22:35.318]                           grepl <- base::grepl
[10:22:35.318]                           restarts <- computeRestarts(cond)
[10:22:35.318]                           for (restart in restarts) {
[10:22:35.318]                             name <- restart$name
[10:22:35.318]                             if (is.null(name)) 
[10:22:35.318]                               next
[10:22:35.318]                             if (!grepl(pattern, name)) 
[10:22:35.318]                               next
[10:22:35.318]                             invokeRestart(restart)
[10:22:35.318]                             muffled <- TRUE
[10:22:35.318]                             break
[10:22:35.318]                           }
[10:22:35.318]                         }
[10:22:35.318]                       }
[10:22:35.318]                       invisible(muffled)
[10:22:35.318]                     }
[10:22:35.318]                     muffleCondition(cond, pattern = "^muffle")
[10:22:35.318]                   }
[10:22:35.318]                 }
[10:22:35.318]                 else {
[10:22:35.318]                   if (TRUE) {
[10:22:35.318]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:35.318]                     {
[10:22:35.318]                       inherits <- base::inherits
[10:22:35.318]                       invokeRestart <- base::invokeRestart
[10:22:35.318]                       is.null <- base::is.null
[10:22:35.318]                       muffled <- FALSE
[10:22:35.318]                       if (inherits(cond, "message")) {
[10:22:35.318]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:35.318]                         if (muffled) 
[10:22:35.318]                           invokeRestart("muffleMessage")
[10:22:35.318]                       }
[10:22:35.318]                       else if (inherits(cond, "warning")) {
[10:22:35.318]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:35.318]                         if (muffled) 
[10:22:35.318]                           invokeRestart("muffleWarning")
[10:22:35.318]                       }
[10:22:35.318]                       else if (inherits(cond, "condition")) {
[10:22:35.318]                         if (!is.null(pattern)) {
[10:22:35.318]                           computeRestarts <- base::computeRestarts
[10:22:35.318]                           grepl <- base::grepl
[10:22:35.318]                           restarts <- computeRestarts(cond)
[10:22:35.318]                           for (restart in restarts) {
[10:22:35.318]                             name <- restart$name
[10:22:35.318]                             if (is.null(name)) 
[10:22:35.318]                               next
[10:22:35.318]                             if (!grepl(pattern, name)) 
[10:22:35.318]                               next
[10:22:35.318]                             invokeRestart(restart)
[10:22:35.318]                             muffled <- TRUE
[10:22:35.318]                             break
[10:22:35.318]                           }
[10:22:35.318]                         }
[10:22:35.318]                       }
[10:22:35.318]                       invisible(muffled)
[10:22:35.318]                     }
[10:22:35.318]                     muffleCondition(cond, pattern = "^muffle")
[10:22:35.318]                   }
[10:22:35.318]                 }
[10:22:35.318]             }
[10:22:35.318]         }))
[10:22:35.318]     }, error = function(ex) {
[10:22:35.318]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:35.318]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:35.318]                 ...future.rng), started = ...future.startTime, 
[10:22:35.318]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:35.318]             version = "1.8"), class = "FutureResult")
[10:22:35.318]     }, finally = {
[10:22:35.318]         if (!identical(...future.workdir, getwd())) 
[10:22:35.318]             setwd(...future.workdir)
[10:22:35.318]         {
[10:22:35.318]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:35.318]                 ...future.oldOptions$nwarnings <- NULL
[10:22:35.318]             }
[10:22:35.318]             base::options(...future.oldOptions)
[10:22:35.318]             if (.Platform$OS.type == "windows") {
[10:22:35.318]                 old_names <- names(...future.oldEnvVars)
[10:22:35.318]                 envs <- base::Sys.getenv()
[10:22:35.318]                 names <- names(envs)
[10:22:35.318]                 common <- intersect(names, old_names)
[10:22:35.318]                 added <- setdiff(names, old_names)
[10:22:35.318]                 removed <- setdiff(old_names, names)
[10:22:35.318]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:35.318]                   envs[common]]
[10:22:35.318]                 NAMES <- toupper(changed)
[10:22:35.318]                 args <- list()
[10:22:35.318]                 for (kk in seq_along(NAMES)) {
[10:22:35.318]                   name <- changed[[kk]]
[10:22:35.318]                   NAME <- NAMES[[kk]]
[10:22:35.318]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:35.318]                     next
[10:22:35.318]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:35.318]                 }
[10:22:35.318]                 NAMES <- toupper(added)
[10:22:35.318]                 for (kk in seq_along(NAMES)) {
[10:22:35.318]                   name <- added[[kk]]
[10:22:35.318]                   NAME <- NAMES[[kk]]
[10:22:35.318]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:35.318]                     next
[10:22:35.318]                   args[[name]] <- ""
[10:22:35.318]                 }
[10:22:35.318]                 NAMES <- toupper(removed)
[10:22:35.318]                 for (kk in seq_along(NAMES)) {
[10:22:35.318]                   name <- removed[[kk]]
[10:22:35.318]                   NAME <- NAMES[[kk]]
[10:22:35.318]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:35.318]                     next
[10:22:35.318]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:35.318]                 }
[10:22:35.318]                 if (length(args) > 0) 
[10:22:35.318]                   base::do.call(base::Sys.setenv, args = args)
[10:22:35.318]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:35.318]             }
[10:22:35.318]             else {
[10:22:35.318]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:35.318]             }
[10:22:35.318]             {
[10:22:35.318]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:35.318]                   0L) {
[10:22:35.318]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:35.318]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:35.318]                   base::options(opts)
[10:22:35.318]                 }
[10:22:35.318]                 {
[10:22:35.318]                   {
[10:22:35.318]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:35.318]                     NULL
[10:22:35.318]                   }
[10:22:35.318]                   options(future.plan = NULL)
[10:22:35.318]                   if (is.na(NA_character_)) 
[10:22:35.318]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:35.318]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:35.318]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:35.318]                     .init = FALSE)
[10:22:35.318]                 }
[10:22:35.318]             }
[10:22:35.318]         }
[10:22:35.318]     })
[10:22:35.318]     if (TRUE) {
[10:22:35.318]         base::sink(type = "output", split = FALSE)
[10:22:35.318]         if (TRUE) {
[10:22:35.318]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:35.318]         }
[10:22:35.318]         else {
[10:22:35.318]             ...future.result["stdout"] <- base::list(NULL)
[10:22:35.318]         }
[10:22:35.318]         base::close(...future.stdout)
[10:22:35.318]         ...future.stdout <- NULL
[10:22:35.318]     }
[10:22:35.318]     ...future.result$conditions <- ...future.conditions
[10:22:35.318]     ...future.result$finished <- base::Sys.time()
[10:22:35.318]     ...future.result
[10:22:35.318] }
[10:22:35.371] MultisessionFuture started
[10:22:35.371] - Launch lazy future ... done
[10:22:35.371] run() for ‘MultisessionFuture’ ... done
[10:22:35.371] getGlobalsAndPackages() ...
[10:22:35.371] Searching for globals...
[10:22:35.374] - globals found: [2] ‘list’, ‘stop’
[10:22:35.374] Searching for globals ... DONE
[10:22:35.375] Resolving globals: FALSE
[10:22:35.375] 
[10:22:35.375] 
[10:22:35.375] getGlobalsAndPackages() ... DONE
- result = FALSE, recursive = -1 ... DONE
- result = FALSE, recursive = 0 ...
[10:22:35.376] getGlobalsAndPackages() ...
[10:22:35.376] Searching for globals...
[10:22:35.377] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:22:35.377] Searching for globals ... DONE
[10:22:35.377] Resolving globals: FALSE
[10:22:35.377] 
[10:22:35.377] 
[10:22:35.377] getGlobalsAndPackages() ... DONE
[10:22:35.378] run() for ‘Future’ ...
[10:22:35.378] - state: ‘created’
[10:22:35.378] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:35.392] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:35.393] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:35.393]   - Field: ‘node’
[10:22:35.393]   - Field: ‘label’
[10:22:35.393]   - Field: ‘local’
[10:22:35.393]   - Field: ‘owner’
[10:22:35.393]   - Field: ‘envir’
[10:22:35.393]   - Field: ‘workers’
[10:22:35.393]   - Field: ‘packages’
[10:22:35.393]   - Field: ‘gc’
[10:22:35.393]   - Field: ‘conditions’
[10:22:35.394]   - Field: ‘persistent’
[10:22:35.394]   - Field: ‘expr’
[10:22:35.394]   - Field: ‘uuid’
[10:22:35.394]   - Field: ‘seed’
[10:22:35.394]   - Field: ‘version’
[10:22:35.394]   - Field: ‘result’
[10:22:35.394]   - Field: ‘asynchronous’
[10:22:35.394]   - Field: ‘calls’
[10:22:35.394]   - Field: ‘globals’
[10:22:35.394]   - Field: ‘stdout’
[10:22:35.394]   - Field: ‘earlySignal’
[10:22:35.394]   - Field: ‘lazy’
[10:22:35.394]   - Field: ‘state’
[10:22:35.395] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:35.395] - Launch lazy future ...
[10:22:35.395] Packages needed by the future expression (n = 0): <none>
[10:22:35.395] Packages needed by future strategies (n = 0): <none>
[10:22:35.395] {
[10:22:35.395]     {
[10:22:35.395]         {
[10:22:35.395]             ...future.startTime <- base::Sys.time()
[10:22:35.395]             {
[10:22:35.395]                 {
[10:22:35.395]                   {
[10:22:35.395]                     {
[10:22:35.395]                       base::local({
[10:22:35.395]                         has_future <- base::requireNamespace("future", 
[10:22:35.395]                           quietly = TRUE)
[10:22:35.395]                         if (has_future) {
[10:22:35.395]                           ns <- base::getNamespace("future")
[10:22:35.395]                           version <- ns[[".package"]][["version"]]
[10:22:35.395]                           if (is.null(version)) 
[10:22:35.395]                             version <- utils::packageVersion("future")
[10:22:35.395]                         }
[10:22:35.395]                         else {
[10:22:35.395]                           version <- NULL
[10:22:35.395]                         }
[10:22:35.395]                         if (!has_future || version < "1.8.0") {
[10:22:35.395]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:35.395]                             "", base::R.version$version.string), 
[10:22:35.395]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:35.395]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:35.395]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:35.395]                               "release", "version")], collapse = " "), 
[10:22:35.395]                             hostname = base::Sys.info()[["nodename"]])
[10:22:35.395]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:35.395]                             info)
[10:22:35.395]                           info <- base::paste(info, collapse = "; ")
[10:22:35.395]                           if (!has_future) {
[10:22:35.395]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:35.395]                               info)
[10:22:35.395]                           }
[10:22:35.395]                           else {
[10:22:35.395]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:35.395]                               info, version)
[10:22:35.395]                           }
[10:22:35.395]                           base::stop(msg)
[10:22:35.395]                         }
[10:22:35.395]                       })
[10:22:35.395]                     }
[10:22:35.395]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:35.395]                     base::options(mc.cores = 1L)
[10:22:35.395]                   }
[10:22:35.395]                   ...future.strategy.old <- future::plan("list")
[10:22:35.395]                   options(future.plan = NULL)
[10:22:35.395]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:35.395]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:35.395]                 }
[10:22:35.395]                 ...future.workdir <- getwd()
[10:22:35.395]             }
[10:22:35.395]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:35.395]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:35.395]         }
[10:22:35.395]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:35.395]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:35.395]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:35.395]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:35.395]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:35.395]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:35.395]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:35.395]             base::names(...future.oldOptions))
[10:22:35.395]     }
[10:22:35.395]     if (FALSE) {
[10:22:35.395]     }
[10:22:35.395]     else {
[10:22:35.395]         if (TRUE) {
[10:22:35.395]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:35.395]                 open = "w")
[10:22:35.395]         }
[10:22:35.395]         else {
[10:22:35.395]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:35.395]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:35.395]         }
[10:22:35.395]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:35.395]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:35.395]             base::sink(type = "output", split = FALSE)
[10:22:35.395]             base::close(...future.stdout)
[10:22:35.395]         }, add = TRUE)
[10:22:35.395]     }
[10:22:35.395]     ...future.frame <- base::sys.nframe()
[10:22:35.395]     ...future.conditions <- base::list()
[10:22:35.395]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:35.395]     if (FALSE) {
[10:22:35.395]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:35.395]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:35.395]     }
[10:22:35.395]     ...future.result <- base::tryCatch({
[10:22:35.395]         base::withCallingHandlers({
[10:22:35.395]             ...future.value <- base::withVisible(base::local({
[10:22:35.395]                 ...future.makeSendCondition <- base::local({
[10:22:35.395]                   sendCondition <- NULL
[10:22:35.395]                   function(frame = 1L) {
[10:22:35.395]                     if (is.function(sendCondition)) 
[10:22:35.395]                       return(sendCondition)
[10:22:35.395]                     ns <- getNamespace("parallel")
[10:22:35.395]                     if (exists("sendData", mode = "function", 
[10:22:35.395]                       envir = ns)) {
[10:22:35.395]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:35.395]                         envir = ns)
[10:22:35.395]                       envir <- sys.frame(frame)
[10:22:35.395]                       master <- NULL
[10:22:35.395]                       while (!identical(envir, .GlobalEnv) && 
[10:22:35.395]                         !identical(envir, emptyenv())) {
[10:22:35.395]                         if (exists("master", mode = "list", envir = envir, 
[10:22:35.395]                           inherits = FALSE)) {
[10:22:35.395]                           master <- get("master", mode = "list", 
[10:22:35.395]                             envir = envir, inherits = FALSE)
[10:22:35.395]                           if (inherits(master, c("SOCKnode", 
[10:22:35.395]                             "SOCK0node"))) {
[10:22:35.395]                             sendCondition <<- function(cond) {
[10:22:35.395]                               data <- list(type = "VALUE", value = cond, 
[10:22:35.395]                                 success = TRUE)
[10:22:35.395]                               parallel_sendData(master, data)
[10:22:35.395]                             }
[10:22:35.395]                             return(sendCondition)
[10:22:35.395]                           }
[10:22:35.395]                         }
[10:22:35.395]                         frame <- frame + 1L
[10:22:35.395]                         envir <- sys.frame(frame)
[10:22:35.395]                       }
[10:22:35.395]                     }
[10:22:35.395]                     sendCondition <<- function(cond) NULL
[10:22:35.395]                   }
[10:22:35.395]                 })
[10:22:35.395]                 withCallingHandlers({
[10:22:35.395]                   {
[10:22:35.395]                     Sys.sleep(0.5)
[10:22:35.395]                     list(a = 1, b = 42L)
[10:22:35.395]                   }
[10:22:35.395]                 }, immediateCondition = function(cond) {
[10:22:35.395]                   sendCondition <- ...future.makeSendCondition()
[10:22:35.395]                   sendCondition(cond)
[10:22:35.395]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:35.395]                   {
[10:22:35.395]                     inherits <- base::inherits
[10:22:35.395]                     invokeRestart <- base::invokeRestart
[10:22:35.395]                     is.null <- base::is.null
[10:22:35.395]                     muffled <- FALSE
[10:22:35.395]                     if (inherits(cond, "message")) {
[10:22:35.395]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:35.395]                       if (muffled) 
[10:22:35.395]                         invokeRestart("muffleMessage")
[10:22:35.395]                     }
[10:22:35.395]                     else if (inherits(cond, "warning")) {
[10:22:35.395]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:35.395]                       if (muffled) 
[10:22:35.395]                         invokeRestart("muffleWarning")
[10:22:35.395]                     }
[10:22:35.395]                     else if (inherits(cond, "condition")) {
[10:22:35.395]                       if (!is.null(pattern)) {
[10:22:35.395]                         computeRestarts <- base::computeRestarts
[10:22:35.395]                         grepl <- base::grepl
[10:22:35.395]                         restarts <- computeRestarts(cond)
[10:22:35.395]                         for (restart in restarts) {
[10:22:35.395]                           name <- restart$name
[10:22:35.395]                           if (is.null(name)) 
[10:22:35.395]                             next
[10:22:35.395]                           if (!grepl(pattern, name)) 
[10:22:35.395]                             next
[10:22:35.395]                           invokeRestart(restart)
[10:22:35.395]                           muffled <- TRUE
[10:22:35.395]                           break
[10:22:35.395]                         }
[10:22:35.395]                       }
[10:22:35.395]                     }
[10:22:35.395]                     invisible(muffled)
[10:22:35.395]                   }
[10:22:35.395]                   muffleCondition(cond)
[10:22:35.395]                 })
[10:22:35.395]             }))
[10:22:35.395]             future::FutureResult(value = ...future.value$value, 
[10:22:35.395]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:35.395]                   ...future.rng), globalenv = if (FALSE) 
[10:22:35.395]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:35.395]                     ...future.globalenv.names))
[10:22:35.395]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:35.395]         }, condition = base::local({
[10:22:35.395]             c <- base::c
[10:22:35.395]             inherits <- base::inherits
[10:22:35.395]             invokeRestart <- base::invokeRestart
[10:22:35.395]             length <- base::length
[10:22:35.395]             list <- base::list
[10:22:35.395]             seq.int <- base::seq.int
[10:22:35.395]             signalCondition <- base::signalCondition
[10:22:35.395]             sys.calls <- base::sys.calls
[10:22:35.395]             `[[` <- base::`[[`
[10:22:35.395]             `+` <- base::`+`
[10:22:35.395]             `<<-` <- base::`<<-`
[10:22:35.395]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:35.395]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:35.395]                   3L)]
[10:22:35.395]             }
[10:22:35.395]             function(cond) {
[10:22:35.395]                 is_error <- inherits(cond, "error")
[10:22:35.395]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:35.395]                   NULL)
[10:22:35.395]                 if (is_error) {
[10:22:35.395]                   sessionInformation <- function() {
[10:22:35.395]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:35.395]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:35.395]                       search = base::search(), system = base::Sys.info())
[10:22:35.395]                   }
[10:22:35.395]                   ...future.conditions[[length(...future.conditions) + 
[10:22:35.395]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:35.395]                     cond$call), session = sessionInformation(), 
[10:22:35.395]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:35.395]                   signalCondition(cond)
[10:22:35.395]                 }
[10:22:35.395]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:35.395]                 "immediateCondition"))) {
[10:22:35.395]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:35.395]                   ...future.conditions[[length(...future.conditions) + 
[10:22:35.395]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:35.395]                   if (TRUE && !signal) {
[10:22:35.395]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:35.395]                     {
[10:22:35.395]                       inherits <- base::inherits
[10:22:35.395]                       invokeRestart <- base::invokeRestart
[10:22:35.395]                       is.null <- base::is.null
[10:22:35.395]                       muffled <- FALSE
[10:22:35.395]                       if (inherits(cond, "message")) {
[10:22:35.395]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:35.395]                         if (muffled) 
[10:22:35.395]                           invokeRestart("muffleMessage")
[10:22:35.395]                       }
[10:22:35.395]                       else if (inherits(cond, "warning")) {
[10:22:35.395]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:35.395]                         if (muffled) 
[10:22:35.395]                           invokeRestart("muffleWarning")
[10:22:35.395]                       }
[10:22:35.395]                       else if (inherits(cond, "condition")) {
[10:22:35.395]                         if (!is.null(pattern)) {
[10:22:35.395]                           computeRestarts <- base::computeRestarts
[10:22:35.395]                           grepl <- base::grepl
[10:22:35.395]                           restarts <- computeRestarts(cond)
[10:22:35.395]                           for (restart in restarts) {
[10:22:35.395]                             name <- restart$name
[10:22:35.395]                             if (is.null(name)) 
[10:22:35.395]                               next
[10:22:35.395]                             if (!grepl(pattern, name)) 
[10:22:35.395]                               next
[10:22:35.395]                             invokeRestart(restart)
[10:22:35.395]                             muffled <- TRUE
[10:22:35.395]                             break
[10:22:35.395]                           }
[10:22:35.395]                         }
[10:22:35.395]                       }
[10:22:35.395]                       invisible(muffled)
[10:22:35.395]                     }
[10:22:35.395]                     muffleCondition(cond, pattern = "^muffle")
[10:22:35.395]                   }
[10:22:35.395]                 }
[10:22:35.395]                 else {
[10:22:35.395]                   if (TRUE) {
[10:22:35.395]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:35.395]                     {
[10:22:35.395]                       inherits <- base::inherits
[10:22:35.395]                       invokeRestart <- base::invokeRestart
[10:22:35.395]                       is.null <- base::is.null
[10:22:35.395]                       muffled <- FALSE
[10:22:35.395]                       if (inherits(cond, "message")) {
[10:22:35.395]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:35.395]                         if (muffled) 
[10:22:35.395]                           invokeRestart("muffleMessage")
[10:22:35.395]                       }
[10:22:35.395]                       else if (inherits(cond, "warning")) {
[10:22:35.395]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:35.395]                         if (muffled) 
[10:22:35.395]                           invokeRestart("muffleWarning")
[10:22:35.395]                       }
[10:22:35.395]                       else if (inherits(cond, "condition")) {
[10:22:35.395]                         if (!is.null(pattern)) {
[10:22:35.395]                           computeRestarts <- base::computeRestarts
[10:22:35.395]                           grepl <- base::grepl
[10:22:35.395]                           restarts <- computeRestarts(cond)
[10:22:35.395]                           for (restart in restarts) {
[10:22:35.395]                             name <- restart$name
[10:22:35.395]                             if (is.null(name)) 
[10:22:35.395]                               next
[10:22:35.395]                             if (!grepl(pattern, name)) 
[10:22:35.395]                               next
[10:22:35.395]                             invokeRestart(restart)
[10:22:35.395]                             muffled <- TRUE
[10:22:35.395]                             break
[10:22:35.395]                           }
[10:22:35.395]                         }
[10:22:35.395]                       }
[10:22:35.395]                       invisible(muffled)
[10:22:35.395]                     }
[10:22:35.395]                     muffleCondition(cond, pattern = "^muffle")
[10:22:35.395]                   }
[10:22:35.395]                 }
[10:22:35.395]             }
[10:22:35.395]         }))
[10:22:35.395]     }, error = function(ex) {
[10:22:35.395]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:35.395]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:35.395]                 ...future.rng), started = ...future.startTime, 
[10:22:35.395]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:35.395]             version = "1.8"), class = "FutureResult")
[10:22:35.395]     }, finally = {
[10:22:35.395]         if (!identical(...future.workdir, getwd())) 
[10:22:35.395]             setwd(...future.workdir)
[10:22:35.395]         {
[10:22:35.395]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:35.395]                 ...future.oldOptions$nwarnings <- NULL
[10:22:35.395]             }
[10:22:35.395]             base::options(...future.oldOptions)
[10:22:35.395]             if (.Platform$OS.type == "windows") {
[10:22:35.395]                 old_names <- names(...future.oldEnvVars)
[10:22:35.395]                 envs <- base::Sys.getenv()
[10:22:35.395]                 names <- names(envs)
[10:22:35.395]                 common <- intersect(names, old_names)
[10:22:35.395]                 added <- setdiff(names, old_names)
[10:22:35.395]                 removed <- setdiff(old_names, names)
[10:22:35.395]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:35.395]                   envs[common]]
[10:22:35.395]                 NAMES <- toupper(changed)
[10:22:35.395]                 args <- list()
[10:22:35.395]                 for (kk in seq_along(NAMES)) {
[10:22:35.395]                   name <- changed[[kk]]
[10:22:35.395]                   NAME <- NAMES[[kk]]
[10:22:35.395]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:35.395]                     next
[10:22:35.395]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:35.395]                 }
[10:22:35.395]                 NAMES <- toupper(added)
[10:22:35.395]                 for (kk in seq_along(NAMES)) {
[10:22:35.395]                   name <- added[[kk]]
[10:22:35.395]                   NAME <- NAMES[[kk]]
[10:22:35.395]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:35.395]                     next
[10:22:35.395]                   args[[name]] <- ""
[10:22:35.395]                 }
[10:22:35.395]                 NAMES <- toupper(removed)
[10:22:35.395]                 for (kk in seq_along(NAMES)) {
[10:22:35.395]                   name <- removed[[kk]]
[10:22:35.395]                   NAME <- NAMES[[kk]]
[10:22:35.395]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:35.395]                     next
[10:22:35.395]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:35.395]                 }
[10:22:35.395]                 if (length(args) > 0) 
[10:22:35.395]                   base::do.call(base::Sys.setenv, args = args)
[10:22:35.395]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:35.395]             }
[10:22:35.395]             else {
[10:22:35.395]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:35.395]             }
[10:22:35.395]             {
[10:22:35.395]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:35.395]                   0L) {
[10:22:35.395]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:35.395]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:35.395]                   base::options(opts)
[10:22:35.395]                 }
[10:22:35.395]                 {
[10:22:35.395]                   {
[10:22:35.395]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:35.395]                     NULL
[10:22:35.395]                   }
[10:22:35.395]                   options(future.plan = NULL)
[10:22:35.395]                   if (is.na(NA_character_)) 
[10:22:35.395]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:35.395]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:35.395]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:35.395]                     .init = FALSE)
[10:22:35.395]                 }
[10:22:35.395]             }
[10:22:35.395]         }
[10:22:35.395]     })
[10:22:35.395]     if (TRUE) {
[10:22:35.395]         base::sink(type = "output", split = FALSE)
[10:22:35.395]         if (TRUE) {
[10:22:35.395]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:35.395]         }
[10:22:35.395]         else {
[10:22:35.395]             ...future.result["stdout"] <- base::list(NULL)
[10:22:35.395]         }
[10:22:35.395]         base::close(...future.stdout)
[10:22:35.395]         ...future.stdout <- NULL
[10:22:35.395]     }
[10:22:35.395]     ...future.result$conditions <- ...future.conditions
[10:22:35.395]     ...future.result$finished <- base::Sys.time()
[10:22:35.395]     ...future.result
[10:22:35.395] }
[10:22:35.398] Poll #1 (0): usedNodes() = 2, workers = 2
[10:22:35.419] receiveMessageFromWorker() for ClusterFuture ...
[10:22:35.419] - Validating connection of MultisessionFuture
[10:22:35.420] - received message: FutureResult
[10:22:35.420] - Received FutureResult
[10:22:35.420] - Erased future from FutureRegistry
[10:22:35.420] result() for ClusterFuture ...
[10:22:35.420] - result already collected: FutureResult
[10:22:35.420] result() for ClusterFuture ... done
[10:22:35.420] signalConditions() ...
[10:22:35.420]  - include = ‘immediateCondition’
[10:22:35.420]  - exclude = 
[10:22:35.420]  - resignal = FALSE
[10:22:35.420]  - Number of conditions: 1
[10:22:35.421] signalConditions() ... done
[10:22:35.421] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:35.421] result() for ClusterFuture ...
[10:22:35.421] - result already collected: FutureResult
[10:22:35.421] result() for ClusterFuture ... done
[10:22:35.421] result() for ClusterFuture ...
[10:22:35.421] - result already collected: FutureResult
[10:22:35.421] result() for ClusterFuture ... done
[10:22:35.421] signalConditions() ...
[10:22:35.421]  - include = ‘immediateCondition’
[10:22:35.421]  - exclude = 
[10:22:35.421]  - resignal = FALSE
[10:22:35.421]  - Number of conditions: 1
[10:22:35.422] signalConditions() ... done
[10:22:35.422] MultisessionFuture started
[10:22:35.423] - Launch lazy future ... done
[10:22:35.423] run() for ‘MultisessionFuture’ ... done
[10:22:35.969] receiveMessageFromWorker() for ClusterFuture ...
[10:22:35.970] - Validating connection of MultisessionFuture
[10:22:35.970] - received message: FutureResult
[10:22:35.970] - Received FutureResult
[10:22:35.970] - Erased future from FutureRegistry
[10:22:35.970] result() for ClusterFuture ...
[10:22:35.970] - result already collected: FutureResult
[10:22:35.970] result() for ClusterFuture ... done
[10:22:35.970] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:35.971] A MultisessionFuture was resolved (result was not collected)
[10:22:35.971] getGlobalsAndPackages() ...
[10:22:35.971] Searching for globals...
[10:22:35.972] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:22:35.972] Searching for globals ... DONE
[10:22:35.972] Resolving globals: FALSE
[10:22:35.972] 
[10:22:35.973] 
[10:22:35.973] getGlobalsAndPackages() ... DONE
[10:22:35.973] run() for ‘Future’ ...
[10:22:35.973] - state: ‘created’
[10:22:35.973] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:35.987] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:35.987] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:35.987]   - Field: ‘node’
[10:22:35.987]   - Field: ‘label’
[10:22:35.987]   - Field: ‘local’
[10:22:35.987]   - Field: ‘owner’
[10:22:35.987]   - Field: ‘envir’
[10:22:35.988]   - Field: ‘workers’
[10:22:35.988]   - Field: ‘packages’
[10:22:35.988]   - Field: ‘gc’
[10:22:35.988]   - Field: ‘conditions’
[10:22:35.988]   - Field: ‘persistent’
[10:22:35.988]   - Field: ‘expr’
[10:22:35.988]   - Field: ‘uuid’
[10:22:35.988]   - Field: ‘seed’
[10:22:35.988]   - Field: ‘version’
[10:22:35.988]   - Field: ‘result’
[10:22:35.988]   - Field: ‘asynchronous’
[10:22:35.988]   - Field: ‘calls’
[10:22:35.989]   - Field: ‘globals’
[10:22:35.989]   - Field: ‘stdout’
[10:22:35.989]   - Field: ‘earlySignal’
[10:22:35.989]   - Field: ‘lazy’
[10:22:35.989]   - Field: ‘state’
[10:22:35.989] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:35.989] - Launch lazy future ...
[10:22:35.989] Packages needed by the future expression (n = 0): <none>
[10:22:35.989] Packages needed by future strategies (n = 0): <none>
[10:22:35.990] {
[10:22:35.990]     {
[10:22:35.990]         {
[10:22:35.990]             ...future.startTime <- base::Sys.time()
[10:22:35.990]             {
[10:22:35.990]                 {
[10:22:35.990]                   {
[10:22:35.990]                     {
[10:22:35.990]                       base::local({
[10:22:35.990]                         has_future <- base::requireNamespace("future", 
[10:22:35.990]                           quietly = TRUE)
[10:22:35.990]                         if (has_future) {
[10:22:35.990]                           ns <- base::getNamespace("future")
[10:22:35.990]                           version <- ns[[".package"]][["version"]]
[10:22:35.990]                           if (is.null(version)) 
[10:22:35.990]                             version <- utils::packageVersion("future")
[10:22:35.990]                         }
[10:22:35.990]                         else {
[10:22:35.990]                           version <- NULL
[10:22:35.990]                         }
[10:22:35.990]                         if (!has_future || version < "1.8.0") {
[10:22:35.990]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:35.990]                             "", base::R.version$version.string), 
[10:22:35.990]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:35.990]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:35.990]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:35.990]                               "release", "version")], collapse = " "), 
[10:22:35.990]                             hostname = base::Sys.info()[["nodename"]])
[10:22:35.990]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:35.990]                             info)
[10:22:35.990]                           info <- base::paste(info, collapse = "; ")
[10:22:35.990]                           if (!has_future) {
[10:22:35.990]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:35.990]                               info)
[10:22:35.990]                           }
[10:22:35.990]                           else {
[10:22:35.990]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:35.990]                               info, version)
[10:22:35.990]                           }
[10:22:35.990]                           base::stop(msg)
[10:22:35.990]                         }
[10:22:35.990]                       })
[10:22:35.990]                     }
[10:22:35.990]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:35.990]                     base::options(mc.cores = 1L)
[10:22:35.990]                   }
[10:22:35.990]                   ...future.strategy.old <- future::plan("list")
[10:22:35.990]                   options(future.plan = NULL)
[10:22:35.990]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:35.990]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:35.990]                 }
[10:22:35.990]                 ...future.workdir <- getwd()
[10:22:35.990]             }
[10:22:35.990]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:35.990]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:35.990]         }
[10:22:35.990]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:35.990]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:35.990]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:35.990]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:35.990]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:35.990]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:35.990]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:35.990]             base::names(...future.oldOptions))
[10:22:35.990]     }
[10:22:35.990]     if (FALSE) {
[10:22:35.990]     }
[10:22:35.990]     else {
[10:22:35.990]         if (TRUE) {
[10:22:35.990]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:35.990]                 open = "w")
[10:22:35.990]         }
[10:22:35.990]         else {
[10:22:35.990]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:35.990]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:35.990]         }
[10:22:35.990]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:35.990]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:35.990]             base::sink(type = "output", split = FALSE)
[10:22:35.990]             base::close(...future.stdout)
[10:22:35.990]         }, add = TRUE)
[10:22:35.990]     }
[10:22:35.990]     ...future.frame <- base::sys.nframe()
[10:22:35.990]     ...future.conditions <- base::list()
[10:22:35.990]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:35.990]     if (FALSE) {
[10:22:35.990]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:35.990]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:35.990]     }
[10:22:35.990]     ...future.result <- base::tryCatch({
[10:22:35.990]         base::withCallingHandlers({
[10:22:35.990]             ...future.value <- base::withVisible(base::local({
[10:22:35.990]                 ...future.makeSendCondition <- base::local({
[10:22:35.990]                   sendCondition <- NULL
[10:22:35.990]                   function(frame = 1L) {
[10:22:35.990]                     if (is.function(sendCondition)) 
[10:22:35.990]                       return(sendCondition)
[10:22:35.990]                     ns <- getNamespace("parallel")
[10:22:35.990]                     if (exists("sendData", mode = "function", 
[10:22:35.990]                       envir = ns)) {
[10:22:35.990]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:35.990]                         envir = ns)
[10:22:35.990]                       envir <- sys.frame(frame)
[10:22:35.990]                       master <- NULL
[10:22:35.990]                       while (!identical(envir, .GlobalEnv) && 
[10:22:35.990]                         !identical(envir, emptyenv())) {
[10:22:35.990]                         if (exists("master", mode = "list", envir = envir, 
[10:22:35.990]                           inherits = FALSE)) {
[10:22:35.990]                           master <- get("master", mode = "list", 
[10:22:35.990]                             envir = envir, inherits = FALSE)
[10:22:35.990]                           if (inherits(master, c("SOCKnode", 
[10:22:35.990]                             "SOCK0node"))) {
[10:22:35.990]                             sendCondition <<- function(cond) {
[10:22:35.990]                               data <- list(type = "VALUE", value = cond, 
[10:22:35.990]                                 success = TRUE)
[10:22:35.990]                               parallel_sendData(master, data)
[10:22:35.990]                             }
[10:22:35.990]                             return(sendCondition)
[10:22:35.990]                           }
[10:22:35.990]                         }
[10:22:35.990]                         frame <- frame + 1L
[10:22:35.990]                         envir <- sys.frame(frame)
[10:22:35.990]                       }
[10:22:35.990]                     }
[10:22:35.990]                     sendCondition <<- function(cond) NULL
[10:22:35.990]                   }
[10:22:35.990]                 })
[10:22:35.990]                 withCallingHandlers({
[10:22:35.990]                   {
[10:22:35.990]                     Sys.sleep(0.5)
[10:22:35.990]                     list(a = 1, b = 42L)
[10:22:35.990]                   }
[10:22:35.990]                 }, immediateCondition = function(cond) {
[10:22:35.990]                   sendCondition <- ...future.makeSendCondition()
[10:22:35.990]                   sendCondition(cond)
[10:22:35.990]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:35.990]                   {
[10:22:35.990]                     inherits <- base::inherits
[10:22:35.990]                     invokeRestart <- base::invokeRestart
[10:22:35.990]                     is.null <- base::is.null
[10:22:35.990]                     muffled <- FALSE
[10:22:35.990]                     if (inherits(cond, "message")) {
[10:22:35.990]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:35.990]                       if (muffled) 
[10:22:35.990]                         invokeRestart("muffleMessage")
[10:22:35.990]                     }
[10:22:35.990]                     else if (inherits(cond, "warning")) {
[10:22:35.990]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:35.990]                       if (muffled) 
[10:22:35.990]                         invokeRestart("muffleWarning")
[10:22:35.990]                     }
[10:22:35.990]                     else if (inherits(cond, "condition")) {
[10:22:35.990]                       if (!is.null(pattern)) {
[10:22:35.990]                         computeRestarts <- base::computeRestarts
[10:22:35.990]                         grepl <- base::grepl
[10:22:35.990]                         restarts <- computeRestarts(cond)
[10:22:35.990]                         for (restart in restarts) {
[10:22:35.990]                           name <- restart$name
[10:22:35.990]                           if (is.null(name)) 
[10:22:35.990]                             next
[10:22:35.990]                           if (!grepl(pattern, name)) 
[10:22:35.990]                             next
[10:22:35.990]                           invokeRestart(restart)
[10:22:35.990]                           muffled <- TRUE
[10:22:35.990]                           break
[10:22:35.990]                         }
[10:22:35.990]                       }
[10:22:35.990]                     }
[10:22:35.990]                     invisible(muffled)
[10:22:35.990]                   }
[10:22:35.990]                   muffleCondition(cond)
[10:22:35.990]                 })
[10:22:35.990]             }))
[10:22:35.990]             future::FutureResult(value = ...future.value$value, 
[10:22:35.990]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:35.990]                   ...future.rng), globalenv = if (FALSE) 
[10:22:35.990]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:35.990]                     ...future.globalenv.names))
[10:22:35.990]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:35.990]         }, condition = base::local({
[10:22:35.990]             c <- base::c
[10:22:35.990]             inherits <- base::inherits
[10:22:35.990]             invokeRestart <- base::invokeRestart
[10:22:35.990]             length <- base::length
[10:22:35.990]             list <- base::list
[10:22:35.990]             seq.int <- base::seq.int
[10:22:35.990]             signalCondition <- base::signalCondition
[10:22:35.990]             sys.calls <- base::sys.calls
[10:22:35.990]             `[[` <- base::`[[`
[10:22:35.990]             `+` <- base::`+`
[10:22:35.990]             `<<-` <- base::`<<-`
[10:22:35.990]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:35.990]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:35.990]                   3L)]
[10:22:35.990]             }
[10:22:35.990]             function(cond) {
[10:22:35.990]                 is_error <- inherits(cond, "error")
[10:22:35.990]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:35.990]                   NULL)
[10:22:35.990]                 if (is_error) {
[10:22:35.990]                   sessionInformation <- function() {
[10:22:35.990]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:35.990]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:35.990]                       search = base::search(), system = base::Sys.info())
[10:22:35.990]                   }
[10:22:35.990]                   ...future.conditions[[length(...future.conditions) + 
[10:22:35.990]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:35.990]                     cond$call), session = sessionInformation(), 
[10:22:35.990]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:35.990]                   signalCondition(cond)
[10:22:35.990]                 }
[10:22:35.990]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:35.990]                 "immediateCondition"))) {
[10:22:35.990]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:35.990]                   ...future.conditions[[length(...future.conditions) + 
[10:22:35.990]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:35.990]                   if (TRUE && !signal) {
[10:22:35.990]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:35.990]                     {
[10:22:35.990]                       inherits <- base::inherits
[10:22:35.990]                       invokeRestart <- base::invokeRestart
[10:22:35.990]                       is.null <- base::is.null
[10:22:35.990]                       muffled <- FALSE
[10:22:35.990]                       if (inherits(cond, "message")) {
[10:22:35.990]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:35.990]                         if (muffled) 
[10:22:35.990]                           invokeRestart("muffleMessage")
[10:22:35.990]                       }
[10:22:35.990]                       else if (inherits(cond, "warning")) {
[10:22:35.990]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:35.990]                         if (muffled) 
[10:22:35.990]                           invokeRestart("muffleWarning")
[10:22:35.990]                       }
[10:22:35.990]                       else if (inherits(cond, "condition")) {
[10:22:35.990]                         if (!is.null(pattern)) {
[10:22:35.990]                           computeRestarts <- base::computeRestarts
[10:22:35.990]                           grepl <- base::grepl
[10:22:35.990]                           restarts <- computeRestarts(cond)
[10:22:35.990]                           for (restart in restarts) {
[10:22:35.990]                             name <- restart$name
[10:22:35.990]                             if (is.null(name)) 
[10:22:35.990]                               next
[10:22:35.990]                             if (!grepl(pattern, name)) 
[10:22:35.990]                               next
[10:22:35.990]                             invokeRestart(restart)
[10:22:35.990]                             muffled <- TRUE
[10:22:35.990]                             break
[10:22:35.990]                           }
[10:22:35.990]                         }
[10:22:35.990]                       }
[10:22:35.990]                       invisible(muffled)
[10:22:35.990]                     }
[10:22:35.990]                     muffleCondition(cond, pattern = "^muffle")
[10:22:35.990]                   }
[10:22:35.990]                 }
[10:22:35.990]                 else {
[10:22:35.990]                   if (TRUE) {
[10:22:35.990]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:35.990]                     {
[10:22:35.990]                       inherits <- base::inherits
[10:22:35.990]                       invokeRestart <- base::invokeRestart
[10:22:35.990]                       is.null <- base::is.null
[10:22:35.990]                       muffled <- FALSE
[10:22:35.990]                       if (inherits(cond, "message")) {
[10:22:35.990]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:35.990]                         if (muffled) 
[10:22:35.990]                           invokeRestart("muffleMessage")
[10:22:35.990]                       }
[10:22:35.990]                       else if (inherits(cond, "warning")) {
[10:22:35.990]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:35.990]                         if (muffled) 
[10:22:35.990]                           invokeRestart("muffleWarning")
[10:22:35.990]                       }
[10:22:35.990]                       else if (inherits(cond, "condition")) {
[10:22:35.990]                         if (!is.null(pattern)) {
[10:22:35.990]                           computeRestarts <- base::computeRestarts
[10:22:35.990]                           grepl <- base::grepl
[10:22:35.990]                           restarts <- computeRestarts(cond)
[10:22:35.990]                           for (restart in restarts) {
[10:22:35.990]                             name <- restart$name
[10:22:35.990]                             if (is.null(name)) 
[10:22:35.990]                               next
[10:22:35.990]                             if (!grepl(pattern, name)) 
[10:22:35.990]                               next
[10:22:35.990]                             invokeRestart(restart)
[10:22:35.990]                             muffled <- TRUE
[10:22:35.990]                             break
[10:22:35.990]                           }
[10:22:35.990]                         }
[10:22:35.990]                       }
[10:22:35.990]                       invisible(muffled)
[10:22:35.990]                     }
[10:22:35.990]                     muffleCondition(cond, pattern = "^muffle")
[10:22:35.990]                   }
[10:22:35.990]                 }
[10:22:35.990]             }
[10:22:35.990]         }))
[10:22:35.990]     }, error = function(ex) {
[10:22:35.990]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:35.990]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:35.990]                 ...future.rng), started = ...future.startTime, 
[10:22:35.990]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:35.990]             version = "1.8"), class = "FutureResult")
[10:22:35.990]     }, finally = {
[10:22:35.990]         if (!identical(...future.workdir, getwd())) 
[10:22:35.990]             setwd(...future.workdir)
[10:22:35.990]         {
[10:22:35.990]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:35.990]                 ...future.oldOptions$nwarnings <- NULL
[10:22:35.990]             }
[10:22:35.990]             base::options(...future.oldOptions)
[10:22:35.990]             if (.Platform$OS.type == "windows") {
[10:22:35.990]                 old_names <- names(...future.oldEnvVars)
[10:22:35.990]                 envs <- base::Sys.getenv()
[10:22:35.990]                 names <- names(envs)
[10:22:35.990]                 common <- intersect(names, old_names)
[10:22:35.990]                 added <- setdiff(names, old_names)
[10:22:35.990]                 removed <- setdiff(old_names, names)
[10:22:35.990]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:35.990]                   envs[common]]
[10:22:35.990]                 NAMES <- toupper(changed)
[10:22:35.990]                 args <- list()
[10:22:35.990]                 for (kk in seq_along(NAMES)) {
[10:22:35.990]                   name <- changed[[kk]]
[10:22:35.990]                   NAME <- NAMES[[kk]]
[10:22:35.990]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:35.990]                     next
[10:22:35.990]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:35.990]                 }
[10:22:35.990]                 NAMES <- toupper(added)
[10:22:35.990]                 for (kk in seq_along(NAMES)) {
[10:22:35.990]                   name <- added[[kk]]
[10:22:35.990]                   NAME <- NAMES[[kk]]
[10:22:35.990]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:35.990]                     next
[10:22:35.990]                   args[[name]] <- ""
[10:22:35.990]                 }
[10:22:35.990]                 NAMES <- toupper(removed)
[10:22:35.990]                 for (kk in seq_along(NAMES)) {
[10:22:35.990]                   name <- removed[[kk]]
[10:22:35.990]                   NAME <- NAMES[[kk]]
[10:22:35.990]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:35.990]                     next
[10:22:35.990]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:35.990]                 }
[10:22:35.990]                 if (length(args) > 0) 
[10:22:35.990]                   base::do.call(base::Sys.setenv, args = args)
[10:22:35.990]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:35.990]             }
[10:22:35.990]             else {
[10:22:35.990]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:35.990]             }
[10:22:35.990]             {
[10:22:35.990]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:35.990]                   0L) {
[10:22:35.990]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:35.990]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:35.990]                   base::options(opts)
[10:22:35.990]                 }
[10:22:35.990]                 {
[10:22:35.990]                   {
[10:22:35.990]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:35.990]                     NULL
[10:22:35.990]                   }
[10:22:35.990]                   options(future.plan = NULL)
[10:22:35.990]                   if (is.na(NA_character_)) 
[10:22:35.990]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:35.990]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:35.990]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:35.990]                     .init = FALSE)
[10:22:35.990]                 }
[10:22:35.990]             }
[10:22:35.990]         }
[10:22:35.990]     })
[10:22:35.990]     if (TRUE) {
[10:22:35.990]         base::sink(type = "output", split = FALSE)
[10:22:35.990]         if (TRUE) {
[10:22:35.990]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:35.990]         }
[10:22:35.990]         else {
[10:22:35.990]             ...future.result["stdout"] <- base::list(NULL)
[10:22:35.990]         }
[10:22:35.990]         base::close(...future.stdout)
[10:22:35.990]         ...future.stdout <- NULL
[10:22:35.990]     }
[10:22:35.990]     ...future.result$conditions <- ...future.conditions
[10:22:35.990]     ...future.result$finished <- base::Sys.time()
[10:22:35.990]     ...future.result
[10:22:35.990] }
[10:22:35.993] MultisessionFuture started
[10:22:35.993] - Launch lazy future ... done
[10:22:35.993] run() for ‘MultisessionFuture’ ... done
[10:22:36.536] receiveMessageFromWorker() for ClusterFuture ...
[10:22:36.536] - Validating connection of MultisessionFuture
[10:22:36.537] - received message: FutureResult
[10:22:36.537] - Received FutureResult
[10:22:36.537] - Erased future from FutureRegistry
[10:22:36.537] result() for ClusterFuture ...
[10:22:36.537] - result already collected: FutureResult
[10:22:36.537] result() for ClusterFuture ... done
[10:22:36.537] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:36.537] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[10:22:36.537] getGlobalsAndPackages() ...
[10:22:36.537] Searching for globals...
[10:22:36.538] - globals found: [2] ‘list’, ‘stop’
[10:22:36.538] Searching for globals ... DONE
[10:22:36.538] Resolving globals: FALSE
[10:22:36.539] 
[10:22:36.539] 
[10:22:36.539] getGlobalsAndPackages() ... DONE
[10:22:36.539] run() for ‘Future’ ...
[10:22:36.539] - state: ‘created’
[10:22:36.539] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:36.553] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:36.553] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:36.553]   - Field: ‘node’
[10:22:36.554]   - Field: ‘label’
[10:22:36.554]   - Field: ‘local’
[10:22:36.554]   - Field: ‘owner’
[10:22:36.554]   - Field: ‘envir’
[10:22:36.554]   - Field: ‘workers’
[10:22:36.554]   - Field: ‘packages’
[10:22:36.554]   - Field: ‘gc’
[10:22:36.554]   - Field: ‘conditions’
[10:22:36.554]   - Field: ‘persistent’
[10:22:36.554]   - Field: ‘expr’
[10:22:36.554]   - Field: ‘uuid’
[10:22:36.554]   - Field: ‘seed’
[10:22:36.555]   - Field: ‘version’
[10:22:36.555]   - Field: ‘result’
[10:22:36.555]   - Field: ‘asynchronous’
[10:22:36.555]   - Field: ‘calls’
[10:22:36.555]   - Field: ‘globals’
[10:22:36.555]   - Field: ‘stdout’
[10:22:36.555]   - Field: ‘earlySignal’
[10:22:36.555]   - Field: ‘lazy’
[10:22:36.555]   - Field: ‘state’
[10:22:36.555] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:36.555] - Launch lazy future ...
[10:22:36.556] Packages needed by the future expression (n = 0): <none>
[10:22:36.556] Packages needed by future strategies (n = 0): <none>
[10:22:36.556] {
[10:22:36.556]     {
[10:22:36.556]         {
[10:22:36.556]             ...future.startTime <- base::Sys.time()
[10:22:36.556]             {
[10:22:36.556]                 {
[10:22:36.556]                   {
[10:22:36.556]                     {
[10:22:36.556]                       base::local({
[10:22:36.556]                         has_future <- base::requireNamespace("future", 
[10:22:36.556]                           quietly = TRUE)
[10:22:36.556]                         if (has_future) {
[10:22:36.556]                           ns <- base::getNamespace("future")
[10:22:36.556]                           version <- ns[[".package"]][["version"]]
[10:22:36.556]                           if (is.null(version)) 
[10:22:36.556]                             version <- utils::packageVersion("future")
[10:22:36.556]                         }
[10:22:36.556]                         else {
[10:22:36.556]                           version <- NULL
[10:22:36.556]                         }
[10:22:36.556]                         if (!has_future || version < "1.8.0") {
[10:22:36.556]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:36.556]                             "", base::R.version$version.string), 
[10:22:36.556]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:36.556]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:36.556]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:36.556]                               "release", "version")], collapse = " "), 
[10:22:36.556]                             hostname = base::Sys.info()[["nodename"]])
[10:22:36.556]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:36.556]                             info)
[10:22:36.556]                           info <- base::paste(info, collapse = "; ")
[10:22:36.556]                           if (!has_future) {
[10:22:36.556]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:36.556]                               info)
[10:22:36.556]                           }
[10:22:36.556]                           else {
[10:22:36.556]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:36.556]                               info, version)
[10:22:36.556]                           }
[10:22:36.556]                           base::stop(msg)
[10:22:36.556]                         }
[10:22:36.556]                       })
[10:22:36.556]                     }
[10:22:36.556]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:36.556]                     base::options(mc.cores = 1L)
[10:22:36.556]                   }
[10:22:36.556]                   ...future.strategy.old <- future::plan("list")
[10:22:36.556]                   options(future.plan = NULL)
[10:22:36.556]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:36.556]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:36.556]                 }
[10:22:36.556]                 ...future.workdir <- getwd()
[10:22:36.556]             }
[10:22:36.556]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:36.556]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:36.556]         }
[10:22:36.556]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:36.556]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:36.556]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:36.556]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:36.556]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:36.556]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:36.556]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:36.556]             base::names(...future.oldOptions))
[10:22:36.556]     }
[10:22:36.556]     if (FALSE) {
[10:22:36.556]     }
[10:22:36.556]     else {
[10:22:36.556]         if (TRUE) {
[10:22:36.556]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:36.556]                 open = "w")
[10:22:36.556]         }
[10:22:36.556]         else {
[10:22:36.556]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:36.556]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:36.556]         }
[10:22:36.556]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:36.556]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:36.556]             base::sink(type = "output", split = FALSE)
[10:22:36.556]             base::close(...future.stdout)
[10:22:36.556]         }, add = TRUE)
[10:22:36.556]     }
[10:22:36.556]     ...future.frame <- base::sys.nframe()
[10:22:36.556]     ...future.conditions <- base::list()
[10:22:36.556]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:36.556]     if (FALSE) {
[10:22:36.556]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:36.556]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:36.556]     }
[10:22:36.556]     ...future.result <- base::tryCatch({
[10:22:36.556]         base::withCallingHandlers({
[10:22:36.556]             ...future.value <- base::withVisible(base::local({
[10:22:36.556]                 ...future.makeSendCondition <- base::local({
[10:22:36.556]                   sendCondition <- NULL
[10:22:36.556]                   function(frame = 1L) {
[10:22:36.556]                     if (is.function(sendCondition)) 
[10:22:36.556]                       return(sendCondition)
[10:22:36.556]                     ns <- getNamespace("parallel")
[10:22:36.556]                     if (exists("sendData", mode = "function", 
[10:22:36.556]                       envir = ns)) {
[10:22:36.556]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:36.556]                         envir = ns)
[10:22:36.556]                       envir <- sys.frame(frame)
[10:22:36.556]                       master <- NULL
[10:22:36.556]                       while (!identical(envir, .GlobalEnv) && 
[10:22:36.556]                         !identical(envir, emptyenv())) {
[10:22:36.556]                         if (exists("master", mode = "list", envir = envir, 
[10:22:36.556]                           inherits = FALSE)) {
[10:22:36.556]                           master <- get("master", mode = "list", 
[10:22:36.556]                             envir = envir, inherits = FALSE)
[10:22:36.556]                           if (inherits(master, c("SOCKnode", 
[10:22:36.556]                             "SOCK0node"))) {
[10:22:36.556]                             sendCondition <<- function(cond) {
[10:22:36.556]                               data <- list(type = "VALUE", value = cond, 
[10:22:36.556]                                 success = TRUE)
[10:22:36.556]                               parallel_sendData(master, data)
[10:22:36.556]                             }
[10:22:36.556]                             return(sendCondition)
[10:22:36.556]                           }
[10:22:36.556]                         }
[10:22:36.556]                         frame <- frame + 1L
[10:22:36.556]                         envir <- sys.frame(frame)
[10:22:36.556]                       }
[10:22:36.556]                     }
[10:22:36.556]                     sendCondition <<- function(cond) NULL
[10:22:36.556]                   }
[10:22:36.556]                 })
[10:22:36.556]                 withCallingHandlers({
[10:22:36.556]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:22:36.556]                 }, immediateCondition = function(cond) {
[10:22:36.556]                   sendCondition <- ...future.makeSendCondition()
[10:22:36.556]                   sendCondition(cond)
[10:22:36.556]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:36.556]                   {
[10:22:36.556]                     inherits <- base::inherits
[10:22:36.556]                     invokeRestart <- base::invokeRestart
[10:22:36.556]                     is.null <- base::is.null
[10:22:36.556]                     muffled <- FALSE
[10:22:36.556]                     if (inherits(cond, "message")) {
[10:22:36.556]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:36.556]                       if (muffled) 
[10:22:36.556]                         invokeRestart("muffleMessage")
[10:22:36.556]                     }
[10:22:36.556]                     else if (inherits(cond, "warning")) {
[10:22:36.556]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:36.556]                       if (muffled) 
[10:22:36.556]                         invokeRestart("muffleWarning")
[10:22:36.556]                     }
[10:22:36.556]                     else if (inherits(cond, "condition")) {
[10:22:36.556]                       if (!is.null(pattern)) {
[10:22:36.556]                         computeRestarts <- base::computeRestarts
[10:22:36.556]                         grepl <- base::grepl
[10:22:36.556]                         restarts <- computeRestarts(cond)
[10:22:36.556]                         for (restart in restarts) {
[10:22:36.556]                           name <- restart$name
[10:22:36.556]                           if (is.null(name)) 
[10:22:36.556]                             next
[10:22:36.556]                           if (!grepl(pattern, name)) 
[10:22:36.556]                             next
[10:22:36.556]                           invokeRestart(restart)
[10:22:36.556]                           muffled <- TRUE
[10:22:36.556]                           break
[10:22:36.556]                         }
[10:22:36.556]                       }
[10:22:36.556]                     }
[10:22:36.556]                     invisible(muffled)
[10:22:36.556]                   }
[10:22:36.556]                   muffleCondition(cond)
[10:22:36.556]                 })
[10:22:36.556]             }))
[10:22:36.556]             future::FutureResult(value = ...future.value$value, 
[10:22:36.556]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:36.556]                   ...future.rng), globalenv = if (FALSE) 
[10:22:36.556]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:36.556]                     ...future.globalenv.names))
[10:22:36.556]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:36.556]         }, condition = base::local({
[10:22:36.556]             c <- base::c
[10:22:36.556]             inherits <- base::inherits
[10:22:36.556]             invokeRestart <- base::invokeRestart
[10:22:36.556]             length <- base::length
[10:22:36.556]             list <- base::list
[10:22:36.556]             seq.int <- base::seq.int
[10:22:36.556]             signalCondition <- base::signalCondition
[10:22:36.556]             sys.calls <- base::sys.calls
[10:22:36.556]             `[[` <- base::`[[`
[10:22:36.556]             `+` <- base::`+`
[10:22:36.556]             `<<-` <- base::`<<-`
[10:22:36.556]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:36.556]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:36.556]                   3L)]
[10:22:36.556]             }
[10:22:36.556]             function(cond) {
[10:22:36.556]                 is_error <- inherits(cond, "error")
[10:22:36.556]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:36.556]                   NULL)
[10:22:36.556]                 if (is_error) {
[10:22:36.556]                   sessionInformation <- function() {
[10:22:36.556]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:36.556]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:36.556]                       search = base::search(), system = base::Sys.info())
[10:22:36.556]                   }
[10:22:36.556]                   ...future.conditions[[length(...future.conditions) + 
[10:22:36.556]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:36.556]                     cond$call), session = sessionInformation(), 
[10:22:36.556]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:36.556]                   signalCondition(cond)
[10:22:36.556]                 }
[10:22:36.556]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:36.556]                 "immediateCondition"))) {
[10:22:36.556]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:36.556]                   ...future.conditions[[length(...future.conditions) + 
[10:22:36.556]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:36.556]                   if (TRUE && !signal) {
[10:22:36.556]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:36.556]                     {
[10:22:36.556]                       inherits <- base::inherits
[10:22:36.556]                       invokeRestart <- base::invokeRestart
[10:22:36.556]                       is.null <- base::is.null
[10:22:36.556]                       muffled <- FALSE
[10:22:36.556]                       if (inherits(cond, "message")) {
[10:22:36.556]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:36.556]                         if (muffled) 
[10:22:36.556]                           invokeRestart("muffleMessage")
[10:22:36.556]                       }
[10:22:36.556]                       else if (inherits(cond, "warning")) {
[10:22:36.556]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:36.556]                         if (muffled) 
[10:22:36.556]                           invokeRestart("muffleWarning")
[10:22:36.556]                       }
[10:22:36.556]                       else if (inherits(cond, "condition")) {
[10:22:36.556]                         if (!is.null(pattern)) {
[10:22:36.556]                           computeRestarts <- base::computeRestarts
[10:22:36.556]                           grepl <- base::grepl
[10:22:36.556]                           restarts <- computeRestarts(cond)
[10:22:36.556]                           for (restart in restarts) {
[10:22:36.556]                             name <- restart$name
[10:22:36.556]                             if (is.null(name)) 
[10:22:36.556]                               next
[10:22:36.556]                             if (!grepl(pattern, name)) 
[10:22:36.556]                               next
[10:22:36.556]                             invokeRestart(restart)
[10:22:36.556]                             muffled <- TRUE
[10:22:36.556]                             break
[10:22:36.556]                           }
[10:22:36.556]                         }
[10:22:36.556]                       }
[10:22:36.556]                       invisible(muffled)
[10:22:36.556]                     }
[10:22:36.556]                     muffleCondition(cond, pattern = "^muffle")
[10:22:36.556]                   }
[10:22:36.556]                 }
[10:22:36.556]                 else {
[10:22:36.556]                   if (TRUE) {
[10:22:36.556]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:36.556]                     {
[10:22:36.556]                       inherits <- base::inherits
[10:22:36.556]                       invokeRestart <- base::invokeRestart
[10:22:36.556]                       is.null <- base::is.null
[10:22:36.556]                       muffled <- FALSE
[10:22:36.556]                       if (inherits(cond, "message")) {
[10:22:36.556]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:36.556]                         if (muffled) 
[10:22:36.556]                           invokeRestart("muffleMessage")
[10:22:36.556]                       }
[10:22:36.556]                       else if (inherits(cond, "warning")) {
[10:22:36.556]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:36.556]                         if (muffled) 
[10:22:36.556]                           invokeRestart("muffleWarning")
[10:22:36.556]                       }
[10:22:36.556]                       else if (inherits(cond, "condition")) {
[10:22:36.556]                         if (!is.null(pattern)) {
[10:22:36.556]                           computeRestarts <- base::computeRestarts
[10:22:36.556]                           grepl <- base::grepl
[10:22:36.556]                           restarts <- computeRestarts(cond)
[10:22:36.556]                           for (restart in restarts) {
[10:22:36.556]                             name <- restart$name
[10:22:36.556]                             if (is.null(name)) 
[10:22:36.556]                               next
[10:22:36.556]                             if (!grepl(pattern, name)) 
[10:22:36.556]                               next
[10:22:36.556]                             invokeRestart(restart)
[10:22:36.556]                             muffled <- TRUE
[10:22:36.556]                             break
[10:22:36.556]                           }
[10:22:36.556]                         }
[10:22:36.556]                       }
[10:22:36.556]                       invisible(muffled)
[10:22:36.556]                     }
[10:22:36.556]                     muffleCondition(cond, pattern = "^muffle")
[10:22:36.556]                   }
[10:22:36.556]                 }
[10:22:36.556]             }
[10:22:36.556]         }))
[10:22:36.556]     }, error = function(ex) {
[10:22:36.556]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:36.556]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:36.556]                 ...future.rng), started = ...future.startTime, 
[10:22:36.556]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:36.556]             version = "1.8"), class = "FutureResult")
[10:22:36.556]     }, finally = {
[10:22:36.556]         if (!identical(...future.workdir, getwd())) 
[10:22:36.556]             setwd(...future.workdir)
[10:22:36.556]         {
[10:22:36.556]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:36.556]                 ...future.oldOptions$nwarnings <- NULL
[10:22:36.556]             }
[10:22:36.556]             base::options(...future.oldOptions)
[10:22:36.556]             if (.Platform$OS.type == "windows") {
[10:22:36.556]                 old_names <- names(...future.oldEnvVars)
[10:22:36.556]                 envs <- base::Sys.getenv()
[10:22:36.556]                 names <- names(envs)
[10:22:36.556]                 common <- intersect(names, old_names)
[10:22:36.556]                 added <- setdiff(names, old_names)
[10:22:36.556]                 removed <- setdiff(old_names, names)
[10:22:36.556]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:36.556]                   envs[common]]
[10:22:36.556]                 NAMES <- toupper(changed)
[10:22:36.556]                 args <- list()
[10:22:36.556]                 for (kk in seq_along(NAMES)) {
[10:22:36.556]                   name <- changed[[kk]]
[10:22:36.556]                   NAME <- NAMES[[kk]]
[10:22:36.556]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:36.556]                     next
[10:22:36.556]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:36.556]                 }
[10:22:36.556]                 NAMES <- toupper(added)
[10:22:36.556]                 for (kk in seq_along(NAMES)) {
[10:22:36.556]                   name <- added[[kk]]
[10:22:36.556]                   NAME <- NAMES[[kk]]
[10:22:36.556]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:36.556]                     next
[10:22:36.556]                   args[[name]] <- ""
[10:22:36.556]                 }
[10:22:36.556]                 NAMES <- toupper(removed)
[10:22:36.556]                 for (kk in seq_along(NAMES)) {
[10:22:36.556]                   name <- removed[[kk]]
[10:22:36.556]                   NAME <- NAMES[[kk]]
[10:22:36.556]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:36.556]                     next
[10:22:36.556]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:36.556]                 }
[10:22:36.556]                 if (length(args) > 0) 
[10:22:36.556]                   base::do.call(base::Sys.setenv, args = args)
[10:22:36.556]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:36.556]             }
[10:22:36.556]             else {
[10:22:36.556]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:36.556]             }
[10:22:36.556]             {
[10:22:36.556]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:36.556]                   0L) {
[10:22:36.556]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:36.556]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:36.556]                   base::options(opts)
[10:22:36.556]                 }
[10:22:36.556]                 {
[10:22:36.556]                   {
[10:22:36.556]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:36.556]                     NULL
[10:22:36.556]                   }
[10:22:36.556]                   options(future.plan = NULL)
[10:22:36.556]                   if (is.na(NA_character_)) 
[10:22:36.556]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:36.556]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:36.556]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:36.556]                     .init = FALSE)
[10:22:36.556]                 }
[10:22:36.556]             }
[10:22:36.556]         }
[10:22:36.556]     })
[10:22:36.556]     if (TRUE) {
[10:22:36.556]         base::sink(type = "output", split = FALSE)
[10:22:36.556]         if (TRUE) {
[10:22:36.556]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:36.556]         }
[10:22:36.556]         else {
[10:22:36.556]             ...future.result["stdout"] <- base::list(NULL)
[10:22:36.556]         }
[10:22:36.556]         base::close(...future.stdout)
[10:22:36.556]         ...future.stdout <- NULL
[10:22:36.556]     }
[10:22:36.556]     ...future.result$conditions <- ...future.conditions
[10:22:36.556]     ...future.result$finished <- base::Sys.time()
[10:22:36.556]     ...future.result
[10:22:36.556] }
[10:22:36.560] MultisessionFuture started
[10:22:36.561] - Launch lazy future ... done
[10:22:36.561] run() for ‘MultisessionFuture’ ... done
[10:22:36.603] receiveMessageFromWorker() for ClusterFuture ...
[10:22:36.603] - Validating connection of MultisessionFuture
[10:22:36.604] - received message: FutureResult
[10:22:36.604] - Received FutureResult
[10:22:36.604] - Erased future from FutureRegistry
[10:22:36.604] result() for ClusterFuture ...
[10:22:36.604] - result already collected: FutureResult
[10:22:36.605] result() for ClusterFuture ... done
[10:22:36.605] signalConditions() ...
[10:22:36.605]  - include = ‘immediateCondition’
[10:22:36.605]  - exclude = 
[10:22:36.605]  - resignal = FALSE
[10:22:36.605]  - Number of conditions: 1
[10:22:36.605] signalConditions() ... done
[10:22:36.605] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:36.605] A MultisessionFuture was resolved (result was not collected)
[10:22:36.605] getGlobalsAndPackages() ...
[10:22:36.605] Searching for globals...
[10:22:36.606] - globals found: [2] ‘list’, ‘stop’
[10:22:36.606] Searching for globals ... DONE
[10:22:36.606] Resolving globals: FALSE
[10:22:36.607] 
[10:22:36.607] 
[10:22:36.607] getGlobalsAndPackages() ... DONE
[10:22:36.607] run() for ‘Future’ ...
[10:22:36.607] - state: ‘created’
[10:22:36.607] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:36.621] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:36.621] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:36.621]   - Field: ‘node’
[10:22:36.622]   - Field: ‘label’
[10:22:36.622]   - Field: ‘local’
[10:22:36.622]   - Field: ‘owner’
[10:22:36.622]   - Field: ‘envir’
[10:22:36.622]   - Field: ‘workers’
[10:22:36.622]   - Field: ‘packages’
[10:22:36.622]   - Field: ‘gc’
[10:22:36.622]   - Field: ‘conditions’
[10:22:36.622]   - Field: ‘persistent’
[10:22:36.622]   - Field: ‘expr’
[10:22:36.622]   - Field: ‘uuid’
[10:22:36.623]   - Field: ‘seed’
[10:22:36.623]   - Field: ‘version’
[10:22:36.623]   - Field: ‘result’
[10:22:36.623]   - Field: ‘asynchronous’
[10:22:36.623]   - Field: ‘calls’
[10:22:36.623]   - Field: ‘globals’
[10:22:36.623]   - Field: ‘stdout’
[10:22:36.623]   - Field: ‘earlySignal’
[10:22:36.623]   - Field: ‘lazy’
[10:22:36.623]   - Field: ‘state’
[10:22:36.623] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:36.623] - Launch lazy future ...
[10:22:36.624] Packages needed by the future expression (n = 0): <none>
[10:22:36.624] Packages needed by future strategies (n = 0): <none>
[10:22:36.624] {
[10:22:36.624]     {
[10:22:36.624]         {
[10:22:36.624]             ...future.startTime <- base::Sys.time()
[10:22:36.624]             {
[10:22:36.624]                 {
[10:22:36.624]                   {
[10:22:36.624]                     {
[10:22:36.624]                       base::local({
[10:22:36.624]                         has_future <- base::requireNamespace("future", 
[10:22:36.624]                           quietly = TRUE)
[10:22:36.624]                         if (has_future) {
[10:22:36.624]                           ns <- base::getNamespace("future")
[10:22:36.624]                           version <- ns[[".package"]][["version"]]
[10:22:36.624]                           if (is.null(version)) 
[10:22:36.624]                             version <- utils::packageVersion("future")
[10:22:36.624]                         }
[10:22:36.624]                         else {
[10:22:36.624]                           version <- NULL
[10:22:36.624]                         }
[10:22:36.624]                         if (!has_future || version < "1.8.0") {
[10:22:36.624]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:36.624]                             "", base::R.version$version.string), 
[10:22:36.624]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:36.624]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:36.624]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:36.624]                               "release", "version")], collapse = " "), 
[10:22:36.624]                             hostname = base::Sys.info()[["nodename"]])
[10:22:36.624]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:36.624]                             info)
[10:22:36.624]                           info <- base::paste(info, collapse = "; ")
[10:22:36.624]                           if (!has_future) {
[10:22:36.624]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:36.624]                               info)
[10:22:36.624]                           }
[10:22:36.624]                           else {
[10:22:36.624]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:36.624]                               info, version)
[10:22:36.624]                           }
[10:22:36.624]                           base::stop(msg)
[10:22:36.624]                         }
[10:22:36.624]                       })
[10:22:36.624]                     }
[10:22:36.624]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:36.624]                     base::options(mc.cores = 1L)
[10:22:36.624]                   }
[10:22:36.624]                   ...future.strategy.old <- future::plan("list")
[10:22:36.624]                   options(future.plan = NULL)
[10:22:36.624]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:36.624]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:36.624]                 }
[10:22:36.624]                 ...future.workdir <- getwd()
[10:22:36.624]             }
[10:22:36.624]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:36.624]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:36.624]         }
[10:22:36.624]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:36.624]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:36.624]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:36.624]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:36.624]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:36.624]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:36.624]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:36.624]             base::names(...future.oldOptions))
[10:22:36.624]     }
[10:22:36.624]     if (FALSE) {
[10:22:36.624]     }
[10:22:36.624]     else {
[10:22:36.624]         if (TRUE) {
[10:22:36.624]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:36.624]                 open = "w")
[10:22:36.624]         }
[10:22:36.624]         else {
[10:22:36.624]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:36.624]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:36.624]         }
[10:22:36.624]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:36.624]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:36.624]             base::sink(type = "output", split = FALSE)
[10:22:36.624]             base::close(...future.stdout)
[10:22:36.624]         }, add = TRUE)
[10:22:36.624]     }
[10:22:36.624]     ...future.frame <- base::sys.nframe()
[10:22:36.624]     ...future.conditions <- base::list()
[10:22:36.624]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:36.624]     if (FALSE) {
[10:22:36.624]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:36.624]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:36.624]     }
[10:22:36.624]     ...future.result <- base::tryCatch({
[10:22:36.624]         base::withCallingHandlers({
[10:22:36.624]             ...future.value <- base::withVisible(base::local({
[10:22:36.624]                 ...future.makeSendCondition <- base::local({
[10:22:36.624]                   sendCondition <- NULL
[10:22:36.624]                   function(frame = 1L) {
[10:22:36.624]                     if (is.function(sendCondition)) 
[10:22:36.624]                       return(sendCondition)
[10:22:36.624]                     ns <- getNamespace("parallel")
[10:22:36.624]                     if (exists("sendData", mode = "function", 
[10:22:36.624]                       envir = ns)) {
[10:22:36.624]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:36.624]                         envir = ns)
[10:22:36.624]                       envir <- sys.frame(frame)
[10:22:36.624]                       master <- NULL
[10:22:36.624]                       while (!identical(envir, .GlobalEnv) && 
[10:22:36.624]                         !identical(envir, emptyenv())) {
[10:22:36.624]                         if (exists("master", mode = "list", envir = envir, 
[10:22:36.624]                           inherits = FALSE)) {
[10:22:36.624]                           master <- get("master", mode = "list", 
[10:22:36.624]                             envir = envir, inherits = FALSE)
[10:22:36.624]                           if (inherits(master, c("SOCKnode", 
[10:22:36.624]                             "SOCK0node"))) {
[10:22:36.624]                             sendCondition <<- function(cond) {
[10:22:36.624]                               data <- list(type = "VALUE", value = cond, 
[10:22:36.624]                                 success = TRUE)
[10:22:36.624]                               parallel_sendData(master, data)
[10:22:36.624]                             }
[10:22:36.624]                             return(sendCondition)
[10:22:36.624]                           }
[10:22:36.624]                         }
[10:22:36.624]                         frame <- frame + 1L
[10:22:36.624]                         envir <- sys.frame(frame)
[10:22:36.624]                       }
[10:22:36.624]                     }
[10:22:36.624]                     sendCondition <<- function(cond) NULL
[10:22:36.624]                   }
[10:22:36.624]                 })
[10:22:36.624]                 withCallingHandlers({
[10:22:36.624]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:22:36.624]                 }, immediateCondition = function(cond) {
[10:22:36.624]                   sendCondition <- ...future.makeSendCondition()
[10:22:36.624]                   sendCondition(cond)
[10:22:36.624]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:36.624]                   {
[10:22:36.624]                     inherits <- base::inherits
[10:22:36.624]                     invokeRestart <- base::invokeRestart
[10:22:36.624]                     is.null <- base::is.null
[10:22:36.624]                     muffled <- FALSE
[10:22:36.624]                     if (inherits(cond, "message")) {
[10:22:36.624]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:36.624]                       if (muffled) 
[10:22:36.624]                         invokeRestart("muffleMessage")
[10:22:36.624]                     }
[10:22:36.624]                     else if (inherits(cond, "warning")) {
[10:22:36.624]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:36.624]                       if (muffled) 
[10:22:36.624]                         invokeRestart("muffleWarning")
[10:22:36.624]                     }
[10:22:36.624]                     else if (inherits(cond, "condition")) {
[10:22:36.624]                       if (!is.null(pattern)) {
[10:22:36.624]                         computeRestarts <- base::computeRestarts
[10:22:36.624]                         grepl <- base::grepl
[10:22:36.624]                         restarts <- computeRestarts(cond)
[10:22:36.624]                         for (restart in restarts) {
[10:22:36.624]                           name <- restart$name
[10:22:36.624]                           if (is.null(name)) 
[10:22:36.624]                             next
[10:22:36.624]                           if (!grepl(pattern, name)) 
[10:22:36.624]                             next
[10:22:36.624]                           invokeRestart(restart)
[10:22:36.624]                           muffled <- TRUE
[10:22:36.624]                           break
[10:22:36.624]                         }
[10:22:36.624]                       }
[10:22:36.624]                     }
[10:22:36.624]                     invisible(muffled)
[10:22:36.624]                   }
[10:22:36.624]                   muffleCondition(cond)
[10:22:36.624]                 })
[10:22:36.624]             }))
[10:22:36.624]             future::FutureResult(value = ...future.value$value, 
[10:22:36.624]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:36.624]                   ...future.rng), globalenv = if (FALSE) 
[10:22:36.624]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:36.624]                     ...future.globalenv.names))
[10:22:36.624]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:36.624]         }, condition = base::local({
[10:22:36.624]             c <- base::c
[10:22:36.624]             inherits <- base::inherits
[10:22:36.624]             invokeRestart <- base::invokeRestart
[10:22:36.624]             length <- base::length
[10:22:36.624]             list <- base::list
[10:22:36.624]             seq.int <- base::seq.int
[10:22:36.624]             signalCondition <- base::signalCondition
[10:22:36.624]             sys.calls <- base::sys.calls
[10:22:36.624]             `[[` <- base::`[[`
[10:22:36.624]             `+` <- base::`+`
[10:22:36.624]             `<<-` <- base::`<<-`
[10:22:36.624]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:36.624]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:36.624]                   3L)]
[10:22:36.624]             }
[10:22:36.624]             function(cond) {
[10:22:36.624]                 is_error <- inherits(cond, "error")
[10:22:36.624]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:36.624]                   NULL)
[10:22:36.624]                 if (is_error) {
[10:22:36.624]                   sessionInformation <- function() {
[10:22:36.624]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:36.624]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:36.624]                       search = base::search(), system = base::Sys.info())
[10:22:36.624]                   }
[10:22:36.624]                   ...future.conditions[[length(...future.conditions) + 
[10:22:36.624]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:36.624]                     cond$call), session = sessionInformation(), 
[10:22:36.624]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:36.624]                   signalCondition(cond)
[10:22:36.624]                 }
[10:22:36.624]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:36.624]                 "immediateCondition"))) {
[10:22:36.624]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:36.624]                   ...future.conditions[[length(...future.conditions) + 
[10:22:36.624]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:36.624]                   if (TRUE && !signal) {
[10:22:36.624]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:36.624]                     {
[10:22:36.624]                       inherits <- base::inherits
[10:22:36.624]                       invokeRestart <- base::invokeRestart
[10:22:36.624]                       is.null <- base::is.null
[10:22:36.624]                       muffled <- FALSE
[10:22:36.624]                       if (inherits(cond, "message")) {
[10:22:36.624]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:36.624]                         if (muffled) 
[10:22:36.624]                           invokeRestart("muffleMessage")
[10:22:36.624]                       }
[10:22:36.624]                       else if (inherits(cond, "warning")) {
[10:22:36.624]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:36.624]                         if (muffled) 
[10:22:36.624]                           invokeRestart("muffleWarning")
[10:22:36.624]                       }
[10:22:36.624]                       else if (inherits(cond, "condition")) {
[10:22:36.624]                         if (!is.null(pattern)) {
[10:22:36.624]                           computeRestarts <- base::computeRestarts
[10:22:36.624]                           grepl <- base::grepl
[10:22:36.624]                           restarts <- computeRestarts(cond)
[10:22:36.624]                           for (restart in restarts) {
[10:22:36.624]                             name <- restart$name
[10:22:36.624]                             if (is.null(name)) 
[10:22:36.624]                               next
[10:22:36.624]                             if (!grepl(pattern, name)) 
[10:22:36.624]                               next
[10:22:36.624]                             invokeRestart(restart)
[10:22:36.624]                             muffled <- TRUE
[10:22:36.624]                             break
[10:22:36.624]                           }
[10:22:36.624]                         }
[10:22:36.624]                       }
[10:22:36.624]                       invisible(muffled)
[10:22:36.624]                     }
[10:22:36.624]                     muffleCondition(cond, pattern = "^muffle")
[10:22:36.624]                   }
[10:22:36.624]                 }
[10:22:36.624]                 else {
[10:22:36.624]                   if (TRUE) {
[10:22:36.624]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:36.624]                     {
[10:22:36.624]                       inherits <- base::inherits
[10:22:36.624]                       invokeRestart <- base::invokeRestart
[10:22:36.624]                       is.null <- base::is.null
[10:22:36.624]                       muffled <- FALSE
[10:22:36.624]                       if (inherits(cond, "message")) {
[10:22:36.624]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:36.624]                         if (muffled) 
[10:22:36.624]                           invokeRestart("muffleMessage")
[10:22:36.624]                       }
[10:22:36.624]                       else if (inherits(cond, "warning")) {
[10:22:36.624]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:36.624]                         if (muffled) 
[10:22:36.624]                           invokeRestart("muffleWarning")
[10:22:36.624]                       }
[10:22:36.624]                       else if (inherits(cond, "condition")) {
[10:22:36.624]                         if (!is.null(pattern)) {
[10:22:36.624]                           computeRestarts <- base::computeRestarts
[10:22:36.624]                           grepl <- base::grepl
[10:22:36.624]                           restarts <- computeRestarts(cond)
[10:22:36.624]                           for (restart in restarts) {
[10:22:36.624]                             name <- restart$name
[10:22:36.624]                             if (is.null(name)) 
[10:22:36.624]                               next
[10:22:36.624]                             if (!grepl(pattern, name)) 
[10:22:36.624]                               next
[10:22:36.624]                             invokeRestart(restart)
[10:22:36.624]                             muffled <- TRUE
[10:22:36.624]                             break
[10:22:36.624]                           }
[10:22:36.624]                         }
[10:22:36.624]                       }
[10:22:36.624]                       invisible(muffled)
[10:22:36.624]                     }
[10:22:36.624]                     muffleCondition(cond, pattern = "^muffle")
[10:22:36.624]                   }
[10:22:36.624]                 }
[10:22:36.624]             }
[10:22:36.624]         }))
[10:22:36.624]     }, error = function(ex) {
[10:22:36.624]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:36.624]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:36.624]                 ...future.rng), started = ...future.startTime, 
[10:22:36.624]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:36.624]             version = "1.8"), class = "FutureResult")
[10:22:36.624]     }, finally = {
[10:22:36.624]         if (!identical(...future.workdir, getwd())) 
[10:22:36.624]             setwd(...future.workdir)
[10:22:36.624]         {
[10:22:36.624]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:36.624]                 ...future.oldOptions$nwarnings <- NULL
[10:22:36.624]             }
[10:22:36.624]             base::options(...future.oldOptions)
[10:22:36.624]             if (.Platform$OS.type == "windows") {
[10:22:36.624]                 old_names <- names(...future.oldEnvVars)
[10:22:36.624]                 envs <- base::Sys.getenv()
[10:22:36.624]                 names <- names(envs)
[10:22:36.624]                 common <- intersect(names, old_names)
[10:22:36.624]                 added <- setdiff(names, old_names)
[10:22:36.624]                 removed <- setdiff(old_names, names)
[10:22:36.624]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:36.624]                   envs[common]]
[10:22:36.624]                 NAMES <- toupper(changed)
[10:22:36.624]                 args <- list()
[10:22:36.624]                 for (kk in seq_along(NAMES)) {
[10:22:36.624]                   name <- changed[[kk]]
[10:22:36.624]                   NAME <- NAMES[[kk]]
[10:22:36.624]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:36.624]                     next
[10:22:36.624]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:36.624]                 }
[10:22:36.624]                 NAMES <- toupper(added)
[10:22:36.624]                 for (kk in seq_along(NAMES)) {
[10:22:36.624]                   name <- added[[kk]]
[10:22:36.624]                   NAME <- NAMES[[kk]]
[10:22:36.624]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:36.624]                     next
[10:22:36.624]                   args[[name]] <- ""
[10:22:36.624]                 }
[10:22:36.624]                 NAMES <- toupper(removed)
[10:22:36.624]                 for (kk in seq_along(NAMES)) {
[10:22:36.624]                   name <- removed[[kk]]
[10:22:36.624]                   NAME <- NAMES[[kk]]
[10:22:36.624]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:36.624]                     next
[10:22:36.624]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:36.624]                 }
[10:22:36.624]                 if (length(args) > 0) 
[10:22:36.624]                   base::do.call(base::Sys.setenv, args = args)
[10:22:36.624]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:36.624]             }
[10:22:36.624]             else {
[10:22:36.624]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:36.624]             }
[10:22:36.624]             {
[10:22:36.624]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:36.624]                   0L) {
[10:22:36.624]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:36.624]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:36.624]                   base::options(opts)
[10:22:36.624]                 }
[10:22:36.624]                 {
[10:22:36.624]                   {
[10:22:36.624]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:36.624]                     NULL
[10:22:36.624]                   }
[10:22:36.624]                   options(future.plan = NULL)
[10:22:36.624]                   if (is.na(NA_character_)) 
[10:22:36.624]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:36.624]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:36.624]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:36.624]                     .init = FALSE)
[10:22:36.624]                 }
[10:22:36.624]             }
[10:22:36.624]         }
[10:22:36.624]     })
[10:22:36.624]     if (TRUE) {
[10:22:36.624]         base::sink(type = "output", split = FALSE)
[10:22:36.624]         if (TRUE) {
[10:22:36.624]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:36.624]         }
[10:22:36.624]         else {
[10:22:36.624]             ...future.result["stdout"] <- base::list(NULL)
[10:22:36.624]         }
[10:22:36.624]         base::close(...future.stdout)
[10:22:36.624]         ...future.stdout <- NULL
[10:22:36.624]     }
[10:22:36.624]     ...future.result$conditions <- ...future.conditions
[10:22:36.624]     ...future.result$finished <- base::Sys.time()
[10:22:36.624]     ...future.result
[10:22:36.624] }
[10:22:36.627] MultisessionFuture started
[10:22:36.627] - Launch lazy future ... done
[10:22:36.628] run() for ‘MultisessionFuture’ ... done
[10:22:36.669] receiveMessageFromWorker() for ClusterFuture ...
[10:22:36.669] - Validating connection of MultisessionFuture
[10:22:36.670] - received message: FutureResult
[10:22:36.670] - Received FutureResult
[10:22:36.670] - Erased future from FutureRegistry
[10:22:36.670] result() for ClusterFuture ...
[10:22:36.670] - result already collected: FutureResult
[10:22:36.670] result() for ClusterFuture ... done
[10:22:36.671] signalConditions() ...
[10:22:36.671]  - include = ‘immediateCondition’
[10:22:36.671]  - exclude = 
[10:22:36.671]  - resignal = FALSE
[10:22:36.671]  - Number of conditions: 1
[10:22:36.671] signalConditions() ... done
[10:22:36.671] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:36.671] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 0 ... DONE
- result = FALSE, recursive = 1 ...
[10:22:36.671] getGlobalsAndPackages() ...
[10:22:36.671] Searching for globals...
[10:22:36.673] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:22:36.673] Searching for globals ... DONE
[10:22:36.673] Resolving globals: FALSE
[10:22:36.673] 
[10:22:36.673] 
[10:22:36.673] getGlobalsAndPackages() ... DONE
[10:22:36.674] run() for ‘Future’ ...
[10:22:36.674] - state: ‘created’
[10:22:36.674] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:36.687] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:36.688] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:36.688]   - Field: ‘node’
[10:22:36.688]   - Field: ‘label’
[10:22:36.688]   - Field: ‘local’
[10:22:36.688]   - Field: ‘owner’
[10:22:36.688]   - Field: ‘envir’
[10:22:36.688]   - Field: ‘workers’
[10:22:36.688]   - Field: ‘packages’
[10:22:36.688]   - Field: ‘gc’
[10:22:36.688]   - Field: ‘conditions’
[10:22:36.688]   - Field: ‘persistent’
[10:22:36.689]   - Field: ‘expr’
[10:22:36.689]   - Field: ‘uuid’
[10:22:36.689]   - Field: ‘seed’
[10:22:36.689]   - Field: ‘version’
[10:22:36.689]   - Field: ‘result’
[10:22:36.689]   - Field: ‘asynchronous’
[10:22:36.689]   - Field: ‘calls’
[10:22:36.689]   - Field: ‘globals’
[10:22:36.689]   - Field: ‘stdout’
[10:22:36.689]   - Field: ‘earlySignal’
[10:22:36.689]   - Field: ‘lazy’
[10:22:36.689]   - Field: ‘state’
[10:22:36.690] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:36.690] - Launch lazy future ...
[10:22:36.690] Packages needed by the future expression (n = 0): <none>
[10:22:36.690] Packages needed by future strategies (n = 0): <none>
[10:22:36.690] {
[10:22:36.690]     {
[10:22:36.690]         {
[10:22:36.690]             ...future.startTime <- base::Sys.time()
[10:22:36.690]             {
[10:22:36.690]                 {
[10:22:36.690]                   {
[10:22:36.690]                     {
[10:22:36.690]                       base::local({
[10:22:36.690]                         has_future <- base::requireNamespace("future", 
[10:22:36.690]                           quietly = TRUE)
[10:22:36.690]                         if (has_future) {
[10:22:36.690]                           ns <- base::getNamespace("future")
[10:22:36.690]                           version <- ns[[".package"]][["version"]]
[10:22:36.690]                           if (is.null(version)) 
[10:22:36.690]                             version <- utils::packageVersion("future")
[10:22:36.690]                         }
[10:22:36.690]                         else {
[10:22:36.690]                           version <- NULL
[10:22:36.690]                         }
[10:22:36.690]                         if (!has_future || version < "1.8.0") {
[10:22:36.690]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:36.690]                             "", base::R.version$version.string), 
[10:22:36.690]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:36.690]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:36.690]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:36.690]                               "release", "version")], collapse = " "), 
[10:22:36.690]                             hostname = base::Sys.info()[["nodename"]])
[10:22:36.690]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:36.690]                             info)
[10:22:36.690]                           info <- base::paste(info, collapse = "; ")
[10:22:36.690]                           if (!has_future) {
[10:22:36.690]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:36.690]                               info)
[10:22:36.690]                           }
[10:22:36.690]                           else {
[10:22:36.690]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:36.690]                               info, version)
[10:22:36.690]                           }
[10:22:36.690]                           base::stop(msg)
[10:22:36.690]                         }
[10:22:36.690]                       })
[10:22:36.690]                     }
[10:22:36.690]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:36.690]                     base::options(mc.cores = 1L)
[10:22:36.690]                   }
[10:22:36.690]                   ...future.strategy.old <- future::plan("list")
[10:22:36.690]                   options(future.plan = NULL)
[10:22:36.690]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:36.690]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:36.690]                 }
[10:22:36.690]                 ...future.workdir <- getwd()
[10:22:36.690]             }
[10:22:36.690]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:36.690]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:36.690]         }
[10:22:36.690]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:36.690]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:36.690]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:36.690]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:36.690]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:36.690]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:36.690]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:36.690]             base::names(...future.oldOptions))
[10:22:36.690]     }
[10:22:36.690]     if (FALSE) {
[10:22:36.690]     }
[10:22:36.690]     else {
[10:22:36.690]         if (TRUE) {
[10:22:36.690]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:36.690]                 open = "w")
[10:22:36.690]         }
[10:22:36.690]         else {
[10:22:36.690]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:36.690]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:36.690]         }
[10:22:36.690]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:36.690]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:36.690]             base::sink(type = "output", split = FALSE)
[10:22:36.690]             base::close(...future.stdout)
[10:22:36.690]         }, add = TRUE)
[10:22:36.690]     }
[10:22:36.690]     ...future.frame <- base::sys.nframe()
[10:22:36.690]     ...future.conditions <- base::list()
[10:22:36.690]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:36.690]     if (FALSE) {
[10:22:36.690]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:36.690]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:36.690]     }
[10:22:36.690]     ...future.result <- base::tryCatch({
[10:22:36.690]         base::withCallingHandlers({
[10:22:36.690]             ...future.value <- base::withVisible(base::local({
[10:22:36.690]                 ...future.makeSendCondition <- base::local({
[10:22:36.690]                   sendCondition <- NULL
[10:22:36.690]                   function(frame = 1L) {
[10:22:36.690]                     if (is.function(sendCondition)) 
[10:22:36.690]                       return(sendCondition)
[10:22:36.690]                     ns <- getNamespace("parallel")
[10:22:36.690]                     if (exists("sendData", mode = "function", 
[10:22:36.690]                       envir = ns)) {
[10:22:36.690]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:36.690]                         envir = ns)
[10:22:36.690]                       envir <- sys.frame(frame)
[10:22:36.690]                       master <- NULL
[10:22:36.690]                       while (!identical(envir, .GlobalEnv) && 
[10:22:36.690]                         !identical(envir, emptyenv())) {
[10:22:36.690]                         if (exists("master", mode = "list", envir = envir, 
[10:22:36.690]                           inherits = FALSE)) {
[10:22:36.690]                           master <- get("master", mode = "list", 
[10:22:36.690]                             envir = envir, inherits = FALSE)
[10:22:36.690]                           if (inherits(master, c("SOCKnode", 
[10:22:36.690]                             "SOCK0node"))) {
[10:22:36.690]                             sendCondition <<- function(cond) {
[10:22:36.690]                               data <- list(type = "VALUE", value = cond, 
[10:22:36.690]                                 success = TRUE)
[10:22:36.690]                               parallel_sendData(master, data)
[10:22:36.690]                             }
[10:22:36.690]                             return(sendCondition)
[10:22:36.690]                           }
[10:22:36.690]                         }
[10:22:36.690]                         frame <- frame + 1L
[10:22:36.690]                         envir <- sys.frame(frame)
[10:22:36.690]                       }
[10:22:36.690]                     }
[10:22:36.690]                     sendCondition <<- function(cond) NULL
[10:22:36.690]                   }
[10:22:36.690]                 })
[10:22:36.690]                 withCallingHandlers({
[10:22:36.690]                   {
[10:22:36.690]                     Sys.sleep(0.5)
[10:22:36.690]                     list(a = 1, b = 42L)
[10:22:36.690]                   }
[10:22:36.690]                 }, immediateCondition = function(cond) {
[10:22:36.690]                   sendCondition <- ...future.makeSendCondition()
[10:22:36.690]                   sendCondition(cond)
[10:22:36.690]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:36.690]                   {
[10:22:36.690]                     inherits <- base::inherits
[10:22:36.690]                     invokeRestart <- base::invokeRestart
[10:22:36.690]                     is.null <- base::is.null
[10:22:36.690]                     muffled <- FALSE
[10:22:36.690]                     if (inherits(cond, "message")) {
[10:22:36.690]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:36.690]                       if (muffled) 
[10:22:36.690]                         invokeRestart("muffleMessage")
[10:22:36.690]                     }
[10:22:36.690]                     else if (inherits(cond, "warning")) {
[10:22:36.690]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:36.690]                       if (muffled) 
[10:22:36.690]                         invokeRestart("muffleWarning")
[10:22:36.690]                     }
[10:22:36.690]                     else if (inherits(cond, "condition")) {
[10:22:36.690]                       if (!is.null(pattern)) {
[10:22:36.690]                         computeRestarts <- base::computeRestarts
[10:22:36.690]                         grepl <- base::grepl
[10:22:36.690]                         restarts <- computeRestarts(cond)
[10:22:36.690]                         for (restart in restarts) {
[10:22:36.690]                           name <- restart$name
[10:22:36.690]                           if (is.null(name)) 
[10:22:36.690]                             next
[10:22:36.690]                           if (!grepl(pattern, name)) 
[10:22:36.690]                             next
[10:22:36.690]                           invokeRestart(restart)
[10:22:36.690]                           muffled <- TRUE
[10:22:36.690]                           break
[10:22:36.690]                         }
[10:22:36.690]                       }
[10:22:36.690]                     }
[10:22:36.690]                     invisible(muffled)
[10:22:36.690]                   }
[10:22:36.690]                   muffleCondition(cond)
[10:22:36.690]                 })
[10:22:36.690]             }))
[10:22:36.690]             future::FutureResult(value = ...future.value$value, 
[10:22:36.690]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:36.690]                   ...future.rng), globalenv = if (FALSE) 
[10:22:36.690]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:36.690]                     ...future.globalenv.names))
[10:22:36.690]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:36.690]         }, condition = base::local({
[10:22:36.690]             c <- base::c
[10:22:36.690]             inherits <- base::inherits
[10:22:36.690]             invokeRestart <- base::invokeRestart
[10:22:36.690]             length <- base::length
[10:22:36.690]             list <- base::list
[10:22:36.690]             seq.int <- base::seq.int
[10:22:36.690]             signalCondition <- base::signalCondition
[10:22:36.690]             sys.calls <- base::sys.calls
[10:22:36.690]             `[[` <- base::`[[`
[10:22:36.690]             `+` <- base::`+`
[10:22:36.690]             `<<-` <- base::`<<-`
[10:22:36.690]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:36.690]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:36.690]                   3L)]
[10:22:36.690]             }
[10:22:36.690]             function(cond) {
[10:22:36.690]                 is_error <- inherits(cond, "error")
[10:22:36.690]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:36.690]                   NULL)
[10:22:36.690]                 if (is_error) {
[10:22:36.690]                   sessionInformation <- function() {
[10:22:36.690]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:36.690]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:36.690]                       search = base::search(), system = base::Sys.info())
[10:22:36.690]                   }
[10:22:36.690]                   ...future.conditions[[length(...future.conditions) + 
[10:22:36.690]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:36.690]                     cond$call), session = sessionInformation(), 
[10:22:36.690]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:36.690]                   signalCondition(cond)
[10:22:36.690]                 }
[10:22:36.690]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:36.690]                 "immediateCondition"))) {
[10:22:36.690]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:36.690]                   ...future.conditions[[length(...future.conditions) + 
[10:22:36.690]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:36.690]                   if (TRUE && !signal) {
[10:22:36.690]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:36.690]                     {
[10:22:36.690]                       inherits <- base::inherits
[10:22:36.690]                       invokeRestart <- base::invokeRestart
[10:22:36.690]                       is.null <- base::is.null
[10:22:36.690]                       muffled <- FALSE
[10:22:36.690]                       if (inherits(cond, "message")) {
[10:22:36.690]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:36.690]                         if (muffled) 
[10:22:36.690]                           invokeRestart("muffleMessage")
[10:22:36.690]                       }
[10:22:36.690]                       else if (inherits(cond, "warning")) {
[10:22:36.690]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:36.690]                         if (muffled) 
[10:22:36.690]                           invokeRestart("muffleWarning")
[10:22:36.690]                       }
[10:22:36.690]                       else if (inherits(cond, "condition")) {
[10:22:36.690]                         if (!is.null(pattern)) {
[10:22:36.690]                           computeRestarts <- base::computeRestarts
[10:22:36.690]                           grepl <- base::grepl
[10:22:36.690]                           restarts <- computeRestarts(cond)
[10:22:36.690]                           for (restart in restarts) {
[10:22:36.690]                             name <- restart$name
[10:22:36.690]                             if (is.null(name)) 
[10:22:36.690]                               next
[10:22:36.690]                             if (!grepl(pattern, name)) 
[10:22:36.690]                               next
[10:22:36.690]                             invokeRestart(restart)
[10:22:36.690]                             muffled <- TRUE
[10:22:36.690]                             break
[10:22:36.690]                           }
[10:22:36.690]                         }
[10:22:36.690]                       }
[10:22:36.690]                       invisible(muffled)
[10:22:36.690]                     }
[10:22:36.690]                     muffleCondition(cond, pattern = "^muffle")
[10:22:36.690]                   }
[10:22:36.690]                 }
[10:22:36.690]                 else {
[10:22:36.690]                   if (TRUE) {
[10:22:36.690]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:36.690]                     {
[10:22:36.690]                       inherits <- base::inherits
[10:22:36.690]                       invokeRestart <- base::invokeRestart
[10:22:36.690]                       is.null <- base::is.null
[10:22:36.690]                       muffled <- FALSE
[10:22:36.690]                       if (inherits(cond, "message")) {
[10:22:36.690]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:36.690]                         if (muffled) 
[10:22:36.690]                           invokeRestart("muffleMessage")
[10:22:36.690]                       }
[10:22:36.690]                       else if (inherits(cond, "warning")) {
[10:22:36.690]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:36.690]                         if (muffled) 
[10:22:36.690]                           invokeRestart("muffleWarning")
[10:22:36.690]                       }
[10:22:36.690]                       else if (inherits(cond, "condition")) {
[10:22:36.690]                         if (!is.null(pattern)) {
[10:22:36.690]                           computeRestarts <- base::computeRestarts
[10:22:36.690]                           grepl <- base::grepl
[10:22:36.690]                           restarts <- computeRestarts(cond)
[10:22:36.690]                           for (restart in restarts) {
[10:22:36.690]                             name <- restart$name
[10:22:36.690]                             if (is.null(name)) 
[10:22:36.690]                               next
[10:22:36.690]                             if (!grepl(pattern, name)) 
[10:22:36.690]                               next
[10:22:36.690]                             invokeRestart(restart)
[10:22:36.690]                             muffled <- TRUE
[10:22:36.690]                             break
[10:22:36.690]                           }
[10:22:36.690]                         }
[10:22:36.690]                       }
[10:22:36.690]                       invisible(muffled)
[10:22:36.690]                     }
[10:22:36.690]                     muffleCondition(cond, pattern = "^muffle")
[10:22:36.690]                   }
[10:22:36.690]                 }
[10:22:36.690]             }
[10:22:36.690]         }))
[10:22:36.690]     }, error = function(ex) {
[10:22:36.690]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:36.690]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:36.690]                 ...future.rng), started = ...future.startTime, 
[10:22:36.690]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:36.690]             version = "1.8"), class = "FutureResult")
[10:22:36.690]     }, finally = {
[10:22:36.690]         if (!identical(...future.workdir, getwd())) 
[10:22:36.690]             setwd(...future.workdir)
[10:22:36.690]         {
[10:22:36.690]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:36.690]                 ...future.oldOptions$nwarnings <- NULL
[10:22:36.690]             }
[10:22:36.690]             base::options(...future.oldOptions)
[10:22:36.690]             if (.Platform$OS.type == "windows") {
[10:22:36.690]                 old_names <- names(...future.oldEnvVars)
[10:22:36.690]                 envs <- base::Sys.getenv()
[10:22:36.690]                 names <- names(envs)
[10:22:36.690]                 common <- intersect(names, old_names)
[10:22:36.690]                 added <- setdiff(names, old_names)
[10:22:36.690]                 removed <- setdiff(old_names, names)
[10:22:36.690]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:36.690]                   envs[common]]
[10:22:36.690]                 NAMES <- toupper(changed)
[10:22:36.690]                 args <- list()
[10:22:36.690]                 for (kk in seq_along(NAMES)) {
[10:22:36.690]                   name <- changed[[kk]]
[10:22:36.690]                   NAME <- NAMES[[kk]]
[10:22:36.690]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:36.690]                     next
[10:22:36.690]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:36.690]                 }
[10:22:36.690]                 NAMES <- toupper(added)
[10:22:36.690]                 for (kk in seq_along(NAMES)) {
[10:22:36.690]                   name <- added[[kk]]
[10:22:36.690]                   NAME <- NAMES[[kk]]
[10:22:36.690]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:36.690]                     next
[10:22:36.690]                   args[[name]] <- ""
[10:22:36.690]                 }
[10:22:36.690]                 NAMES <- toupper(removed)
[10:22:36.690]                 for (kk in seq_along(NAMES)) {
[10:22:36.690]                   name <- removed[[kk]]
[10:22:36.690]                   NAME <- NAMES[[kk]]
[10:22:36.690]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:36.690]                     next
[10:22:36.690]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:36.690]                 }
[10:22:36.690]                 if (length(args) > 0) 
[10:22:36.690]                   base::do.call(base::Sys.setenv, args = args)
[10:22:36.690]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:36.690]             }
[10:22:36.690]             else {
[10:22:36.690]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:36.690]             }
[10:22:36.690]             {
[10:22:36.690]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:36.690]                   0L) {
[10:22:36.690]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:36.690]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:36.690]                   base::options(opts)
[10:22:36.690]                 }
[10:22:36.690]                 {
[10:22:36.690]                   {
[10:22:36.690]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:36.690]                     NULL
[10:22:36.690]                   }
[10:22:36.690]                   options(future.plan = NULL)
[10:22:36.690]                   if (is.na(NA_character_)) 
[10:22:36.690]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:36.690]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:36.690]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:36.690]                     .init = FALSE)
[10:22:36.690]                 }
[10:22:36.690]             }
[10:22:36.690]         }
[10:22:36.690]     })
[10:22:36.690]     if (TRUE) {
[10:22:36.690]         base::sink(type = "output", split = FALSE)
[10:22:36.690]         if (TRUE) {
[10:22:36.690]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:36.690]         }
[10:22:36.690]         else {
[10:22:36.690]             ...future.result["stdout"] <- base::list(NULL)
[10:22:36.690]         }
[10:22:36.690]         base::close(...future.stdout)
[10:22:36.690]         ...future.stdout <- NULL
[10:22:36.690]     }
[10:22:36.690]     ...future.result$conditions <- ...future.conditions
[10:22:36.690]     ...future.result$finished <- base::Sys.time()
[10:22:36.690]     ...future.result
[10:22:36.690] }
[10:22:36.693] MultisessionFuture started
[10:22:36.693] - Launch lazy future ... done
[10:22:36.694] run() for ‘MultisessionFuture’ ... done
[10:22:37.237] receiveMessageFromWorker() for ClusterFuture ...
[10:22:37.237] - Validating connection of MultisessionFuture
[10:22:37.237] - received message: FutureResult
[10:22:37.237] - Received FutureResult
[10:22:37.237] - Erased future from FutureRegistry
[10:22:37.238] result() for ClusterFuture ...
[10:22:37.238] - result already collected: FutureResult
[10:22:37.238] result() for ClusterFuture ... done
[10:22:37.238] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:37.238] A MultisessionFuture was resolved (result was not collected)
[10:22:37.238] getGlobalsAndPackages() ...
[10:22:37.238] Searching for globals...
[10:22:37.239] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:22:37.239] Searching for globals ... DONE
[10:22:37.240] Resolving globals: FALSE
[10:22:37.240] 
[10:22:37.240] 
[10:22:37.240] getGlobalsAndPackages() ... DONE
[10:22:37.240] run() for ‘Future’ ...
[10:22:37.240] - state: ‘created’
[10:22:37.241] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:37.254] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:37.254] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:37.255]   - Field: ‘node’
[10:22:37.255]   - Field: ‘label’
[10:22:37.255]   - Field: ‘local’
[10:22:37.255]   - Field: ‘owner’
[10:22:37.255]   - Field: ‘envir’
[10:22:37.255]   - Field: ‘workers’
[10:22:37.255]   - Field: ‘packages’
[10:22:37.255]   - Field: ‘gc’
[10:22:37.255]   - Field: ‘conditions’
[10:22:37.255]   - Field: ‘persistent’
[10:22:37.255]   - Field: ‘expr’
[10:22:37.256]   - Field: ‘uuid’
[10:22:37.256]   - Field: ‘seed’
[10:22:37.256]   - Field: ‘version’
[10:22:37.256]   - Field: ‘result’
[10:22:37.256]   - Field: ‘asynchronous’
[10:22:37.256]   - Field: ‘calls’
[10:22:37.256]   - Field: ‘globals’
[10:22:37.256]   - Field: ‘stdout’
[10:22:37.257]   - Field: ‘earlySignal’
[10:22:37.257]   - Field: ‘lazy’
[10:22:37.257]   - Field: ‘state’
[10:22:37.257] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:37.257] - Launch lazy future ...
[10:22:37.258] Packages needed by the future expression (n = 0): <none>
[10:22:37.258] Packages needed by future strategies (n = 0): <none>
[10:22:37.259] {
[10:22:37.259]     {
[10:22:37.259]         {
[10:22:37.259]             ...future.startTime <- base::Sys.time()
[10:22:37.259]             {
[10:22:37.259]                 {
[10:22:37.259]                   {
[10:22:37.259]                     {
[10:22:37.259]                       base::local({
[10:22:37.259]                         has_future <- base::requireNamespace("future", 
[10:22:37.259]                           quietly = TRUE)
[10:22:37.259]                         if (has_future) {
[10:22:37.259]                           ns <- base::getNamespace("future")
[10:22:37.259]                           version <- ns[[".package"]][["version"]]
[10:22:37.259]                           if (is.null(version)) 
[10:22:37.259]                             version <- utils::packageVersion("future")
[10:22:37.259]                         }
[10:22:37.259]                         else {
[10:22:37.259]                           version <- NULL
[10:22:37.259]                         }
[10:22:37.259]                         if (!has_future || version < "1.8.0") {
[10:22:37.259]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:37.259]                             "", base::R.version$version.string), 
[10:22:37.259]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:37.259]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:37.259]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:37.259]                               "release", "version")], collapse = " "), 
[10:22:37.259]                             hostname = base::Sys.info()[["nodename"]])
[10:22:37.259]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:37.259]                             info)
[10:22:37.259]                           info <- base::paste(info, collapse = "; ")
[10:22:37.259]                           if (!has_future) {
[10:22:37.259]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:37.259]                               info)
[10:22:37.259]                           }
[10:22:37.259]                           else {
[10:22:37.259]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:37.259]                               info, version)
[10:22:37.259]                           }
[10:22:37.259]                           base::stop(msg)
[10:22:37.259]                         }
[10:22:37.259]                       })
[10:22:37.259]                     }
[10:22:37.259]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:37.259]                     base::options(mc.cores = 1L)
[10:22:37.259]                   }
[10:22:37.259]                   ...future.strategy.old <- future::plan("list")
[10:22:37.259]                   options(future.plan = NULL)
[10:22:37.259]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:37.259]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:37.259]                 }
[10:22:37.259]                 ...future.workdir <- getwd()
[10:22:37.259]             }
[10:22:37.259]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:37.259]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:37.259]         }
[10:22:37.259]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:37.259]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:37.259]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:37.259]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:37.259]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:37.259]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:37.259]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:37.259]             base::names(...future.oldOptions))
[10:22:37.259]     }
[10:22:37.259]     if (FALSE) {
[10:22:37.259]     }
[10:22:37.259]     else {
[10:22:37.259]         if (TRUE) {
[10:22:37.259]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:37.259]                 open = "w")
[10:22:37.259]         }
[10:22:37.259]         else {
[10:22:37.259]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:37.259]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:37.259]         }
[10:22:37.259]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:37.259]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:37.259]             base::sink(type = "output", split = FALSE)
[10:22:37.259]             base::close(...future.stdout)
[10:22:37.259]         }, add = TRUE)
[10:22:37.259]     }
[10:22:37.259]     ...future.frame <- base::sys.nframe()
[10:22:37.259]     ...future.conditions <- base::list()
[10:22:37.259]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:37.259]     if (FALSE) {
[10:22:37.259]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:37.259]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:37.259]     }
[10:22:37.259]     ...future.result <- base::tryCatch({
[10:22:37.259]         base::withCallingHandlers({
[10:22:37.259]             ...future.value <- base::withVisible(base::local({
[10:22:37.259]                 ...future.makeSendCondition <- base::local({
[10:22:37.259]                   sendCondition <- NULL
[10:22:37.259]                   function(frame = 1L) {
[10:22:37.259]                     if (is.function(sendCondition)) 
[10:22:37.259]                       return(sendCondition)
[10:22:37.259]                     ns <- getNamespace("parallel")
[10:22:37.259]                     if (exists("sendData", mode = "function", 
[10:22:37.259]                       envir = ns)) {
[10:22:37.259]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:37.259]                         envir = ns)
[10:22:37.259]                       envir <- sys.frame(frame)
[10:22:37.259]                       master <- NULL
[10:22:37.259]                       while (!identical(envir, .GlobalEnv) && 
[10:22:37.259]                         !identical(envir, emptyenv())) {
[10:22:37.259]                         if (exists("master", mode = "list", envir = envir, 
[10:22:37.259]                           inherits = FALSE)) {
[10:22:37.259]                           master <- get("master", mode = "list", 
[10:22:37.259]                             envir = envir, inherits = FALSE)
[10:22:37.259]                           if (inherits(master, c("SOCKnode", 
[10:22:37.259]                             "SOCK0node"))) {
[10:22:37.259]                             sendCondition <<- function(cond) {
[10:22:37.259]                               data <- list(type = "VALUE", value = cond, 
[10:22:37.259]                                 success = TRUE)
[10:22:37.259]                               parallel_sendData(master, data)
[10:22:37.259]                             }
[10:22:37.259]                             return(sendCondition)
[10:22:37.259]                           }
[10:22:37.259]                         }
[10:22:37.259]                         frame <- frame + 1L
[10:22:37.259]                         envir <- sys.frame(frame)
[10:22:37.259]                       }
[10:22:37.259]                     }
[10:22:37.259]                     sendCondition <<- function(cond) NULL
[10:22:37.259]                   }
[10:22:37.259]                 })
[10:22:37.259]                 withCallingHandlers({
[10:22:37.259]                   {
[10:22:37.259]                     Sys.sleep(0.5)
[10:22:37.259]                     list(a = 1, b = 42L)
[10:22:37.259]                   }
[10:22:37.259]                 }, immediateCondition = function(cond) {
[10:22:37.259]                   sendCondition <- ...future.makeSendCondition()
[10:22:37.259]                   sendCondition(cond)
[10:22:37.259]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:37.259]                   {
[10:22:37.259]                     inherits <- base::inherits
[10:22:37.259]                     invokeRestart <- base::invokeRestart
[10:22:37.259]                     is.null <- base::is.null
[10:22:37.259]                     muffled <- FALSE
[10:22:37.259]                     if (inherits(cond, "message")) {
[10:22:37.259]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:37.259]                       if (muffled) 
[10:22:37.259]                         invokeRestart("muffleMessage")
[10:22:37.259]                     }
[10:22:37.259]                     else if (inherits(cond, "warning")) {
[10:22:37.259]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:37.259]                       if (muffled) 
[10:22:37.259]                         invokeRestart("muffleWarning")
[10:22:37.259]                     }
[10:22:37.259]                     else if (inherits(cond, "condition")) {
[10:22:37.259]                       if (!is.null(pattern)) {
[10:22:37.259]                         computeRestarts <- base::computeRestarts
[10:22:37.259]                         grepl <- base::grepl
[10:22:37.259]                         restarts <- computeRestarts(cond)
[10:22:37.259]                         for (restart in restarts) {
[10:22:37.259]                           name <- restart$name
[10:22:37.259]                           if (is.null(name)) 
[10:22:37.259]                             next
[10:22:37.259]                           if (!grepl(pattern, name)) 
[10:22:37.259]                             next
[10:22:37.259]                           invokeRestart(restart)
[10:22:37.259]                           muffled <- TRUE
[10:22:37.259]                           break
[10:22:37.259]                         }
[10:22:37.259]                       }
[10:22:37.259]                     }
[10:22:37.259]                     invisible(muffled)
[10:22:37.259]                   }
[10:22:37.259]                   muffleCondition(cond)
[10:22:37.259]                 })
[10:22:37.259]             }))
[10:22:37.259]             future::FutureResult(value = ...future.value$value, 
[10:22:37.259]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:37.259]                   ...future.rng), globalenv = if (FALSE) 
[10:22:37.259]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:37.259]                     ...future.globalenv.names))
[10:22:37.259]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:37.259]         }, condition = base::local({
[10:22:37.259]             c <- base::c
[10:22:37.259]             inherits <- base::inherits
[10:22:37.259]             invokeRestart <- base::invokeRestart
[10:22:37.259]             length <- base::length
[10:22:37.259]             list <- base::list
[10:22:37.259]             seq.int <- base::seq.int
[10:22:37.259]             signalCondition <- base::signalCondition
[10:22:37.259]             sys.calls <- base::sys.calls
[10:22:37.259]             `[[` <- base::`[[`
[10:22:37.259]             `+` <- base::`+`
[10:22:37.259]             `<<-` <- base::`<<-`
[10:22:37.259]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:37.259]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:37.259]                   3L)]
[10:22:37.259]             }
[10:22:37.259]             function(cond) {
[10:22:37.259]                 is_error <- inherits(cond, "error")
[10:22:37.259]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:37.259]                   NULL)
[10:22:37.259]                 if (is_error) {
[10:22:37.259]                   sessionInformation <- function() {
[10:22:37.259]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:37.259]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:37.259]                       search = base::search(), system = base::Sys.info())
[10:22:37.259]                   }
[10:22:37.259]                   ...future.conditions[[length(...future.conditions) + 
[10:22:37.259]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:37.259]                     cond$call), session = sessionInformation(), 
[10:22:37.259]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:37.259]                   signalCondition(cond)
[10:22:37.259]                 }
[10:22:37.259]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:37.259]                 "immediateCondition"))) {
[10:22:37.259]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:37.259]                   ...future.conditions[[length(...future.conditions) + 
[10:22:37.259]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:37.259]                   if (TRUE && !signal) {
[10:22:37.259]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:37.259]                     {
[10:22:37.259]                       inherits <- base::inherits
[10:22:37.259]                       invokeRestart <- base::invokeRestart
[10:22:37.259]                       is.null <- base::is.null
[10:22:37.259]                       muffled <- FALSE
[10:22:37.259]                       if (inherits(cond, "message")) {
[10:22:37.259]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:37.259]                         if (muffled) 
[10:22:37.259]                           invokeRestart("muffleMessage")
[10:22:37.259]                       }
[10:22:37.259]                       else if (inherits(cond, "warning")) {
[10:22:37.259]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:37.259]                         if (muffled) 
[10:22:37.259]                           invokeRestart("muffleWarning")
[10:22:37.259]                       }
[10:22:37.259]                       else if (inherits(cond, "condition")) {
[10:22:37.259]                         if (!is.null(pattern)) {
[10:22:37.259]                           computeRestarts <- base::computeRestarts
[10:22:37.259]                           grepl <- base::grepl
[10:22:37.259]                           restarts <- computeRestarts(cond)
[10:22:37.259]                           for (restart in restarts) {
[10:22:37.259]                             name <- restart$name
[10:22:37.259]                             if (is.null(name)) 
[10:22:37.259]                               next
[10:22:37.259]                             if (!grepl(pattern, name)) 
[10:22:37.259]                               next
[10:22:37.259]                             invokeRestart(restart)
[10:22:37.259]                             muffled <- TRUE
[10:22:37.259]                             break
[10:22:37.259]                           }
[10:22:37.259]                         }
[10:22:37.259]                       }
[10:22:37.259]                       invisible(muffled)
[10:22:37.259]                     }
[10:22:37.259]                     muffleCondition(cond, pattern = "^muffle")
[10:22:37.259]                   }
[10:22:37.259]                 }
[10:22:37.259]                 else {
[10:22:37.259]                   if (TRUE) {
[10:22:37.259]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:37.259]                     {
[10:22:37.259]                       inherits <- base::inherits
[10:22:37.259]                       invokeRestart <- base::invokeRestart
[10:22:37.259]                       is.null <- base::is.null
[10:22:37.259]                       muffled <- FALSE
[10:22:37.259]                       if (inherits(cond, "message")) {
[10:22:37.259]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:37.259]                         if (muffled) 
[10:22:37.259]                           invokeRestart("muffleMessage")
[10:22:37.259]                       }
[10:22:37.259]                       else if (inherits(cond, "warning")) {
[10:22:37.259]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:37.259]                         if (muffled) 
[10:22:37.259]                           invokeRestart("muffleWarning")
[10:22:37.259]                       }
[10:22:37.259]                       else if (inherits(cond, "condition")) {
[10:22:37.259]                         if (!is.null(pattern)) {
[10:22:37.259]                           computeRestarts <- base::computeRestarts
[10:22:37.259]                           grepl <- base::grepl
[10:22:37.259]                           restarts <- computeRestarts(cond)
[10:22:37.259]                           for (restart in restarts) {
[10:22:37.259]                             name <- restart$name
[10:22:37.259]                             if (is.null(name)) 
[10:22:37.259]                               next
[10:22:37.259]                             if (!grepl(pattern, name)) 
[10:22:37.259]                               next
[10:22:37.259]                             invokeRestart(restart)
[10:22:37.259]                             muffled <- TRUE
[10:22:37.259]                             break
[10:22:37.259]                           }
[10:22:37.259]                         }
[10:22:37.259]                       }
[10:22:37.259]                       invisible(muffled)
[10:22:37.259]                     }
[10:22:37.259]                     muffleCondition(cond, pattern = "^muffle")
[10:22:37.259]                   }
[10:22:37.259]                 }
[10:22:37.259]             }
[10:22:37.259]         }))
[10:22:37.259]     }, error = function(ex) {
[10:22:37.259]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:37.259]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:37.259]                 ...future.rng), started = ...future.startTime, 
[10:22:37.259]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:37.259]             version = "1.8"), class = "FutureResult")
[10:22:37.259]     }, finally = {
[10:22:37.259]         if (!identical(...future.workdir, getwd())) 
[10:22:37.259]             setwd(...future.workdir)
[10:22:37.259]         {
[10:22:37.259]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:37.259]                 ...future.oldOptions$nwarnings <- NULL
[10:22:37.259]             }
[10:22:37.259]             base::options(...future.oldOptions)
[10:22:37.259]             if (.Platform$OS.type == "windows") {
[10:22:37.259]                 old_names <- names(...future.oldEnvVars)
[10:22:37.259]                 envs <- base::Sys.getenv()
[10:22:37.259]                 names <- names(envs)
[10:22:37.259]                 common <- intersect(names, old_names)
[10:22:37.259]                 added <- setdiff(names, old_names)
[10:22:37.259]                 removed <- setdiff(old_names, names)
[10:22:37.259]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:37.259]                   envs[common]]
[10:22:37.259]                 NAMES <- toupper(changed)
[10:22:37.259]                 args <- list()
[10:22:37.259]                 for (kk in seq_along(NAMES)) {
[10:22:37.259]                   name <- changed[[kk]]
[10:22:37.259]                   NAME <- NAMES[[kk]]
[10:22:37.259]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:37.259]                     next
[10:22:37.259]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:37.259]                 }
[10:22:37.259]                 NAMES <- toupper(added)
[10:22:37.259]                 for (kk in seq_along(NAMES)) {
[10:22:37.259]                   name <- added[[kk]]
[10:22:37.259]                   NAME <- NAMES[[kk]]
[10:22:37.259]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:37.259]                     next
[10:22:37.259]                   args[[name]] <- ""
[10:22:37.259]                 }
[10:22:37.259]                 NAMES <- toupper(removed)
[10:22:37.259]                 for (kk in seq_along(NAMES)) {
[10:22:37.259]                   name <- removed[[kk]]
[10:22:37.259]                   NAME <- NAMES[[kk]]
[10:22:37.259]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:37.259]                     next
[10:22:37.259]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:37.259]                 }
[10:22:37.259]                 if (length(args) > 0) 
[10:22:37.259]                   base::do.call(base::Sys.setenv, args = args)
[10:22:37.259]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:37.259]             }
[10:22:37.259]             else {
[10:22:37.259]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:37.259]             }
[10:22:37.259]             {
[10:22:37.259]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:37.259]                   0L) {
[10:22:37.259]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:37.259]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:37.259]                   base::options(opts)
[10:22:37.259]                 }
[10:22:37.259]                 {
[10:22:37.259]                   {
[10:22:37.259]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:37.259]                     NULL
[10:22:37.259]                   }
[10:22:37.259]                   options(future.plan = NULL)
[10:22:37.259]                   if (is.na(NA_character_)) 
[10:22:37.259]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:37.259]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:37.259]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:37.259]                     .init = FALSE)
[10:22:37.259]                 }
[10:22:37.259]             }
[10:22:37.259]         }
[10:22:37.259]     })
[10:22:37.259]     if (TRUE) {
[10:22:37.259]         base::sink(type = "output", split = FALSE)
[10:22:37.259]         if (TRUE) {
[10:22:37.259]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:37.259]         }
[10:22:37.259]         else {
[10:22:37.259]             ...future.result["stdout"] <- base::list(NULL)
[10:22:37.259]         }
[10:22:37.259]         base::close(...future.stdout)
[10:22:37.259]         ...future.stdout <- NULL
[10:22:37.259]     }
[10:22:37.259]     ...future.result$conditions <- ...future.conditions
[10:22:37.259]     ...future.result$finished <- base::Sys.time()
[10:22:37.259]     ...future.result
[10:22:37.259] }
[10:22:37.264] MultisessionFuture started
[10:22:37.264] - Launch lazy future ... done
[10:22:37.264] run() for ‘MultisessionFuture’ ... done
[10:22:37.807] receiveMessageFromWorker() for ClusterFuture ...
[10:22:37.807] - Validating connection of MultisessionFuture
[10:22:37.808] - received message: FutureResult
[10:22:37.808] - Received FutureResult
[10:22:37.808] - Erased future from FutureRegistry
[10:22:37.808] result() for ClusterFuture ...
[10:22:37.808] - result already collected: FutureResult
[10:22:37.808] result() for ClusterFuture ... done
[10:22:37.808] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:37.808] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[10:22:37.809] getGlobalsAndPackages() ...
[10:22:37.809] Searching for globals...
[10:22:37.809] - globals found: [2] ‘list’, ‘stop’
[10:22:37.809] Searching for globals ... DONE
[10:22:37.810] Resolving globals: FALSE
[10:22:37.810] 
[10:22:37.810] 
[10:22:37.810] getGlobalsAndPackages() ... DONE
[10:22:37.810] run() for ‘Future’ ...
[10:22:37.810] - state: ‘created’
[10:22:37.811] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:37.824] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:37.824] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:37.824]   - Field: ‘node’
[10:22:37.825]   - Field: ‘label’
[10:22:37.825]   - Field: ‘local’
[10:22:37.825]   - Field: ‘owner’
[10:22:37.825]   - Field: ‘envir’
[10:22:37.825]   - Field: ‘workers’
[10:22:37.825]   - Field: ‘packages’
[10:22:37.825]   - Field: ‘gc’
[10:22:37.825]   - Field: ‘conditions’
[10:22:37.825]   - Field: ‘persistent’
[10:22:37.825]   - Field: ‘expr’
[10:22:37.825]   - Field: ‘uuid’
[10:22:37.826]   - Field: ‘seed’
[10:22:37.826]   - Field: ‘version’
[10:22:37.826]   - Field: ‘result’
[10:22:37.826]   - Field: ‘asynchronous’
[10:22:37.826]   - Field: ‘calls’
[10:22:37.826]   - Field: ‘globals’
[10:22:37.826]   - Field: ‘stdout’
[10:22:37.826]   - Field: ‘earlySignal’
[10:22:37.826]   - Field: ‘lazy’
[10:22:37.826]   - Field: ‘state’
[10:22:37.826] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:37.827] - Launch lazy future ...
[10:22:37.827] Packages needed by the future expression (n = 0): <none>
[10:22:37.827] Packages needed by future strategies (n = 0): <none>
[10:22:37.827] {
[10:22:37.827]     {
[10:22:37.827]         {
[10:22:37.827]             ...future.startTime <- base::Sys.time()
[10:22:37.827]             {
[10:22:37.827]                 {
[10:22:37.827]                   {
[10:22:37.827]                     {
[10:22:37.827]                       base::local({
[10:22:37.827]                         has_future <- base::requireNamespace("future", 
[10:22:37.827]                           quietly = TRUE)
[10:22:37.827]                         if (has_future) {
[10:22:37.827]                           ns <- base::getNamespace("future")
[10:22:37.827]                           version <- ns[[".package"]][["version"]]
[10:22:37.827]                           if (is.null(version)) 
[10:22:37.827]                             version <- utils::packageVersion("future")
[10:22:37.827]                         }
[10:22:37.827]                         else {
[10:22:37.827]                           version <- NULL
[10:22:37.827]                         }
[10:22:37.827]                         if (!has_future || version < "1.8.0") {
[10:22:37.827]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:37.827]                             "", base::R.version$version.string), 
[10:22:37.827]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:37.827]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:37.827]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:37.827]                               "release", "version")], collapse = " "), 
[10:22:37.827]                             hostname = base::Sys.info()[["nodename"]])
[10:22:37.827]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:37.827]                             info)
[10:22:37.827]                           info <- base::paste(info, collapse = "; ")
[10:22:37.827]                           if (!has_future) {
[10:22:37.827]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:37.827]                               info)
[10:22:37.827]                           }
[10:22:37.827]                           else {
[10:22:37.827]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:37.827]                               info, version)
[10:22:37.827]                           }
[10:22:37.827]                           base::stop(msg)
[10:22:37.827]                         }
[10:22:37.827]                       })
[10:22:37.827]                     }
[10:22:37.827]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:37.827]                     base::options(mc.cores = 1L)
[10:22:37.827]                   }
[10:22:37.827]                   ...future.strategy.old <- future::plan("list")
[10:22:37.827]                   options(future.plan = NULL)
[10:22:37.827]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:37.827]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:37.827]                 }
[10:22:37.827]                 ...future.workdir <- getwd()
[10:22:37.827]             }
[10:22:37.827]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:37.827]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:37.827]         }
[10:22:37.827]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:37.827]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:37.827]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:37.827]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:37.827]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:37.827]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:37.827]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:37.827]             base::names(...future.oldOptions))
[10:22:37.827]     }
[10:22:37.827]     if (FALSE) {
[10:22:37.827]     }
[10:22:37.827]     else {
[10:22:37.827]         if (TRUE) {
[10:22:37.827]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:37.827]                 open = "w")
[10:22:37.827]         }
[10:22:37.827]         else {
[10:22:37.827]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:37.827]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:37.827]         }
[10:22:37.827]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:37.827]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:37.827]             base::sink(type = "output", split = FALSE)
[10:22:37.827]             base::close(...future.stdout)
[10:22:37.827]         }, add = TRUE)
[10:22:37.827]     }
[10:22:37.827]     ...future.frame <- base::sys.nframe()
[10:22:37.827]     ...future.conditions <- base::list()
[10:22:37.827]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:37.827]     if (FALSE) {
[10:22:37.827]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:37.827]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:37.827]     }
[10:22:37.827]     ...future.result <- base::tryCatch({
[10:22:37.827]         base::withCallingHandlers({
[10:22:37.827]             ...future.value <- base::withVisible(base::local({
[10:22:37.827]                 ...future.makeSendCondition <- base::local({
[10:22:37.827]                   sendCondition <- NULL
[10:22:37.827]                   function(frame = 1L) {
[10:22:37.827]                     if (is.function(sendCondition)) 
[10:22:37.827]                       return(sendCondition)
[10:22:37.827]                     ns <- getNamespace("parallel")
[10:22:37.827]                     if (exists("sendData", mode = "function", 
[10:22:37.827]                       envir = ns)) {
[10:22:37.827]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:37.827]                         envir = ns)
[10:22:37.827]                       envir <- sys.frame(frame)
[10:22:37.827]                       master <- NULL
[10:22:37.827]                       while (!identical(envir, .GlobalEnv) && 
[10:22:37.827]                         !identical(envir, emptyenv())) {
[10:22:37.827]                         if (exists("master", mode = "list", envir = envir, 
[10:22:37.827]                           inherits = FALSE)) {
[10:22:37.827]                           master <- get("master", mode = "list", 
[10:22:37.827]                             envir = envir, inherits = FALSE)
[10:22:37.827]                           if (inherits(master, c("SOCKnode", 
[10:22:37.827]                             "SOCK0node"))) {
[10:22:37.827]                             sendCondition <<- function(cond) {
[10:22:37.827]                               data <- list(type = "VALUE", value = cond, 
[10:22:37.827]                                 success = TRUE)
[10:22:37.827]                               parallel_sendData(master, data)
[10:22:37.827]                             }
[10:22:37.827]                             return(sendCondition)
[10:22:37.827]                           }
[10:22:37.827]                         }
[10:22:37.827]                         frame <- frame + 1L
[10:22:37.827]                         envir <- sys.frame(frame)
[10:22:37.827]                       }
[10:22:37.827]                     }
[10:22:37.827]                     sendCondition <<- function(cond) NULL
[10:22:37.827]                   }
[10:22:37.827]                 })
[10:22:37.827]                 withCallingHandlers({
[10:22:37.827]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:22:37.827]                 }, immediateCondition = function(cond) {
[10:22:37.827]                   sendCondition <- ...future.makeSendCondition()
[10:22:37.827]                   sendCondition(cond)
[10:22:37.827]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:37.827]                   {
[10:22:37.827]                     inherits <- base::inherits
[10:22:37.827]                     invokeRestart <- base::invokeRestart
[10:22:37.827]                     is.null <- base::is.null
[10:22:37.827]                     muffled <- FALSE
[10:22:37.827]                     if (inherits(cond, "message")) {
[10:22:37.827]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:37.827]                       if (muffled) 
[10:22:37.827]                         invokeRestart("muffleMessage")
[10:22:37.827]                     }
[10:22:37.827]                     else if (inherits(cond, "warning")) {
[10:22:37.827]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:37.827]                       if (muffled) 
[10:22:37.827]                         invokeRestart("muffleWarning")
[10:22:37.827]                     }
[10:22:37.827]                     else if (inherits(cond, "condition")) {
[10:22:37.827]                       if (!is.null(pattern)) {
[10:22:37.827]                         computeRestarts <- base::computeRestarts
[10:22:37.827]                         grepl <- base::grepl
[10:22:37.827]                         restarts <- computeRestarts(cond)
[10:22:37.827]                         for (restart in restarts) {
[10:22:37.827]                           name <- restart$name
[10:22:37.827]                           if (is.null(name)) 
[10:22:37.827]                             next
[10:22:37.827]                           if (!grepl(pattern, name)) 
[10:22:37.827]                             next
[10:22:37.827]                           invokeRestart(restart)
[10:22:37.827]                           muffled <- TRUE
[10:22:37.827]                           break
[10:22:37.827]                         }
[10:22:37.827]                       }
[10:22:37.827]                     }
[10:22:37.827]                     invisible(muffled)
[10:22:37.827]                   }
[10:22:37.827]                   muffleCondition(cond)
[10:22:37.827]                 })
[10:22:37.827]             }))
[10:22:37.827]             future::FutureResult(value = ...future.value$value, 
[10:22:37.827]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:37.827]                   ...future.rng), globalenv = if (FALSE) 
[10:22:37.827]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:37.827]                     ...future.globalenv.names))
[10:22:37.827]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:37.827]         }, condition = base::local({
[10:22:37.827]             c <- base::c
[10:22:37.827]             inherits <- base::inherits
[10:22:37.827]             invokeRestart <- base::invokeRestart
[10:22:37.827]             length <- base::length
[10:22:37.827]             list <- base::list
[10:22:37.827]             seq.int <- base::seq.int
[10:22:37.827]             signalCondition <- base::signalCondition
[10:22:37.827]             sys.calls <- base::sys.calls
[10:22:37.827]             `[[` <- base::`[[`
[10:22:37.827]             `+` <- base::`+`
[10:22:37.827]             `<<-` <- base::`<<-`
[10:22:37.827]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:37.827]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:37.827]                   3L)]
[10:22:37.827]             }
[10:22:37.827]             function(cond) {
[10:22:37.827]                 is_error <- inherits(cond, "error")
[10:22:37.827]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:37.827]                   NULL)
[10:22:37.827]                 if (is_error) {
[10:22:37.827]                   sessionInformation <- function() {
[10:22:37.827]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:37.827]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:37.827]                       search = base::search(), system = base::Sys.info())
[10:22:37.827]                   }
[10:22:37.827]                   ...future.conditions[[length(...future.conditions) + 
[10:22:37.827]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:37.827]                     cond$call), session = sessionInformation(), 
[10:22:37.827]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:37.827]                   signalCondition(cond)
[10:22:37.827]                 }
[10:22:37.827]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:37.827]                 "immediateCondition"))) {
[10:22:37.827]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:37.827]                   ...future.conditions[[length(...future.conditions) + 
[10:22:37.827]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:37.827]                   if (TRUE && !signal) {
[10:22:37.827]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:37.827]                     {
[10:22:37.827]                       inherits <- base::inherits
[10:22:37.827]                       invokeRestart <- base::invokeRestart
[10:22:37.827]                       is.null <- base::is.null
[10:22:37.827]                       muffled <- FALSE
[10:22:37.827]                       if (inherits(cond, "message")) {
[10:22:37.827]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:37.827]                         if (muffled) 
[10:22:37.827]                           invokeRestart("muffleMessage")
[10:22:37.827]                       }
[10:22:37.827]                       else if (inherits(cond, "warning")) {
[10:22:37.827]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:37.827]                         if (muffled) 
[10:22:37.827]                           invokeRestart("muffleWarning")
[10:22:37.827]                       }
[10:22:37.827]                       else if (inherits(cond, "condition")) {
[10:22:37.827]                         if (!is.null(pattern)) {
[10:22:37.827]                           computeRestarts <- base::computeRestarts
[10:22:37.827]                           grepl <- base::grepl
[10:22:37.827]                           restarts <- computeRestarts(cond)
[10:22:37.827]                           for (restart in restarts) {
[10:22:37.827]                             name <- restart$name
[10:22:37.827]                             if (is.null(name)) 
[10:22:37.827]                               next
[10:22:37.827]                             if (!grepl(pattern, name)) 
[10:22:37.827]                               next
[10:22:37.827]                             invokeRestart(restart)
[10:22:37.827]                             muffled <- TRUE
[10:22:37.827]                             break
[10:22:37.827]                           }
[10:22:37.827]                         }
[10:22:37.827]                       }
[10:22:37.827]                       invisible(muffled)
[10:22:37.827]                     }
[10:22:37.827]                     muffleCondition(cond, pattern = "^muffle")
[10:22:37.827]                   }
[10:22:37.827]                 }
[10:22:37.827]                 else {
[10:22:37.827]                   if (TRUE) {
[10:22:37.827]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:37.827]                     {
[10:22:37.827]                       inherits <- base::inherits
[10:22:37.827]                       invokeRestart <- base::invokeRestart
[10:22:37.827]                       is.null <- base::is.null
[10:22:37.827]                       muffled <- FALSE
[10:22:37.827]                       if (inherits(cond, "message")) {
[10:22:37.827]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:37.827]                         if (muffled) 
[10:22:37.827]                           invokeRestart("muffleMessage")
[10:22:37.827]                       }
[10:22:37.827]                       else if (inherits(cond, "warning")) {
[10:22:37.827]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:37.827]                         if (muffled) 
[10:22:37.827]                           invokeRestart("muffleWarning")
[10:22:37.827]                       }
[10:22:37.827]                       else if (inherits(cond, "condition")) {
[10:22:37.827]                         if (!is.null(pattern)) {
[10:22:37.827]                           computeRestarts <- base::computeRestarts
[10:22:37.827]                           grepl <- base::grepl
[10:22:37.827]                           restarts <- computeRestarts(cond)
[10:22:37.827]                           for (restart in restarts) {
[10:22:37.827]                             name <- restart$name
[10:22:37.827]                             if (is.null(name)) 
[10:22:37.827]                               next
[10:22:37.827]                             if (!grepl(pattern, name)) 
[10:22:37.827]                               next
[10:22:37.827]                             invokeRestart(restart)
[10:22:37.827]                             muffled <- TRUE
[10:22:37.827]                             break
[10:22:37.827]                           }
[10:22:37.827]                         }
[10:22:37.827]                       }
[10:22:37.827]                       invisible(muffled)
[10:22:37.827]                     }
[10:22:37.827]                     muffleCondition(cond, pattern = "^muffle")
[10:22:37.827]                   }
[10:22:37.827]                 }
[10:22:37.827]             }
[10:22:37.827]         }))
[10:22:37.827]     }, error = function(ex) {
[10:22:37.827]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:37.827]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:37.827]                 ...future.rng), started = ...future.startTime, 
[10:22:37.827]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:37.827]             version = "1.8"), class = "FutureResult")
[10:22:37.827]     }, finally = {
[10:22:37.827]         if (!identical(...future.workdir, getwd())) 
[10:22:37.827]             setwd(...future.workdir)
[10:22:37.827]         {
[10:22:37.827]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:37.827]                 ...future.oldOptions$nwarnings <- NULL
[10:22:37.827]             }
[10:22:37.827]             base::options(...future.oldOptions)
[10:22:37.827]             if (.Platform$OS.type == "windows") {
[10:22:37.827]                 old_names <- names(...future.oldEnvVars)
[10:22:37.827]                 envs <- base::Sys.getenv()
[10:22:37.827]                 names <- names(envs)
[10:22:37.827]                 common <- intersect(names, old_names)
[10:22:37.827]                 added <- setdiff(names, old_names)
[10:22:37.827]                 removed <- setdiff(old_names, names)
[10:22:37.827]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:37.827]                   envs[common]]
[10:22:37.827]                 NAMES <- toupper(changed)
[10:22:37.827]                 args <- list()
[10:22:37.827]                 for (kk in seq_along(NAMES)) {
[10:22:37.827]                   name <- changed[[kk]]
[10:22:37.827]                   NAME <- NAMES[[kk]]
[10:22:37.827]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:37.827]                     next
[10:22:37.827]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:37.827]                 }
[10:22:37.827]                 NAMES <- toupper(added)
[10:22:37.827]                 for (kk in seq_along(NAMES)) {
[10:22:37.827]                   name <- added[[kk]]
[10:22:37.827]                   NAME <- NAMES[[kk]]
[10:22:37.827]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:37.827]                     next
[10:22:37.827]                   args[[name]] <- ""
[10:22:37.827]                 }
[10:22:37.827]                 NAMES <- toupper(removed)
[10:22:37.827]                 for (kk in seq_along(NAMES)) {
[10:22:37.827]                   name <- removed[[kk]]
[10:22:37.827]                   NAME <- NAMES[[kk]]
[10:22:37.827]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:37.827]                     next
[10:22:37.827]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:37.827]                 }
[10:22:37.827]                 if (length(args) > 0) 
[10:22:37.827]                   base::do.call(base::Sys.setenv, args = args)
[10:22:37.827]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:37.827]             }
[10:22:37.827]             else {
[10:22:37.827]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:37.827]             }
[10:22:37.827]             {
[10:22:37.827]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:37.827]                   0L) {
[10:22:37.827]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:37.827]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:37.827]                   base::options(opts)
[10:22:37.827]                 }
[10:22:37.827]                 {
[10:22:37.827]                   {
[10:22:37.827]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:37.827]                     NULL
[10:22:37.827]                   }
[10:22:37.827]                   options(future.plan = NULL)
[10:22:37.827]                   if (is.na(NA_character_)) 
[10:22:37.827]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:37.827]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:37.827]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:37.827]                     .init = FALSE)
[10:22:37.827]                 }
[10:22:37.827]             }
[10:22:37.827]         }
[10:22:37.827]     })
[10:22:37.827]     if (TRUE) {
[10:22:37.827]         base::sink(type = "output", split = FALSE)
[10:22:37.827]         if (TRUE) {
[10:22:37.827]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:37.827]         }
[10:22:37.827]         else {
[10:22:37.827]             ...future.result["stdout"] <- base::list(NULL)
[10:22:37.827]         }
[10:22:37.827]         base::close(...future.stdout)
[10:22:37.827]         ...future.stdout <- NULL
[10:22:37.827]     }
[10:22:37.827]     ...future.result$conditions <- ...future.conditions
[10:22:37.827]     ...future.result$finished <- base::Sys.time()
[10:22:37.827]     ...future.result
[10:22:37.827] }
[10:22:37.830] MultisessionFuture started
[10:22:37.830] - Launch lazy future ... done
[10:22:37.831] run() for ‘MultisessionFuture’ ... done
[10:22:37.872] receiveMessageFromWorker() for ClusterFuture ...
[10:22:37.872] - Validating connection of MultisessionFuture
[10:22:37.873] - received message: FutureResult
[10:22:37.873] - Received FutureResult
[10:22:37.873] - Erased future from FutureRegistry
[10:22:37.873] result() for ClusterFuture ...
[10:22:37.873] - result already collected: FutureResult
[10:22:37.873] result() for ClusterFuture ... done
[10:22:37.873] signalConditions() ...
[10:22:37.873]  - include = ‘immediateCondition’
[10:22:37.873]  - exclude = 
[10:22:37.874]  - resignal = FALSE
[10:22:37.874]  - Number of conditions: 1
[10:22:37.874] signalConditions() ... done
[10:22:37.874] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:37.874] A MultisessionFuture was resolved (result was not collected)
[10:22:37.874] getGlobalsAndPackages() ...
[10:22:37.874] Searching for globals...
[10:22:37.875] - globals found: [2] ‘list’, ‘stop’
[10:22:37.875] Searching for globals ... DONE
[10:22:37.875] Resolving globals: FALSE
[10:22:37.875] 
[10:22:37.875] 
[10:22:37.875] getGlobalsAndPackages() ... DONE
[10:22:37.876] run() for ‘Future’ ...
[10:22:37.876] - state: ‘created’
[10:22:37.876] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:37.889] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:37.890] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:37.890]   - Field: ‘node’
[10:22:37.890]   - Field: ‘label’
[10:22:37.890]   - Field: ‘local’
[10:22:37.890]   - Field: ‘owner’
[10:22:37.890]   - Field: ‘envir’
[10:22:37.890]   - Field: ‘workers’
[10:22:37.890]   - Field: ‘packages’
[10:22:37.890]   - Field: ‘gc’
[10:22:37.890]   - Field: ‘conditions’
[10:22:37.890]   - Field: ‘persistent’
[10:22:37.891]   - Field: ‘expr’
[10:22:37.891]   - Field: ‘uuid’
[10:22:37.891]   - Field: ‘seed’
[10:22:37.891]   - Field: ‘version’
[10:22:37.891]   - Field: ‘result’
[10:22:37.891]   - Field: ‘asynchronous’
[10:22:37.891]   - Field: ‘calls’
[10:22:37.891]   - Field: ‘globals’
[10:22:37.891]   - Field: ‘stdout’
[10:22:37.891]   - Field: ‘earlySignal’
[10:22:37.891]   - Field: ‘lazy’
[10:22:37.891]   - Field: ‘state’
[10:22:37.892] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:37.892] - Launch lazy future ...
[10:22:37.892] Packages needed by the future expression (n = 0): <none>
[10:22:37.892] Packages needed by future strategies (n = 0): <none>
[10:22:37.892] {
[10:22:37.892]     {
[10:22:37.892]         {
[10:22:37.892]             ...future.startTime <- base::Sys.time()
[10:22:37.892]             {
[10:22:37.892]                 {
[10:22:37.892]                   {
[10:22:37.892]                     {
[10:22:37.892]                       base::local({
[10:22:37.892]                         has_future <- base::requireNamespace("future", 
[10:22:37.892]                           quietly = TRUE)
[10:22:37.892]                         if (has_future) {
[10:22:37.892]                           ns <- base::getNamespace("future")
[10:22:37.892]                           version <- ns[[".package"]][["version"]]
[10:22:37.892]                           if (is.null(version)) 
[10:22:37.892]                             version <- utils::packageVersion("future")
[10:22:37.892]                         }
[10:22:37.892]                         else {
[10:22:37.892]                           version <- NULL
[10:22:37.892]                         }
[10:22:37.892]                         if (!has_future || version < "1.8.0") {
[10:22:37.892]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:37.892]                             "", base::R.version$version.string), 
[10:22:37.892]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:37.892]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:37.892]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:37.892]                               "release", "version")], collapse = " "), 
[10:22:37.892]                             hostname = base::Sys.info()[["nodename"]])
[10:22:37.892]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:37.892]                             info)
[10:22:37.892]                           info <- base::paste(info, collapse = "; ")
[10:22:37.892]                           if (!has_future) {
[10:22:37.892]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:37.892]                               info)
[10:22:37.892]                           }
[10:22:37.892]                           else {
[10:22:37.892]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:37.892]                               info, version)
[10:22:37.892]                           }
[10:22:37.892]                           base::stop(msg)
[10:22:37.892]                         }
[10:22:37.892]                       })
[10:22:37.892]                     }
[10:22:37.892]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:37.892]                     base::options(mc.cores = 1L)
[10:22:37.892]                   }
[10:22:37.892]                   ...future.strategy.old <- future::plan("list")
[10:22:37.892]                   options(future.plan = NULL)
[10:22:37.892]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:37.892]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:37.892]                 }
[10:22:37.892]                 ...future.workdir <- getwd()
[10:22:37.892]             }
[10:22:37.892]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:37.892]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:37.892]         }
[10:22:37.892]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:37.892]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:37.892]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:37.892]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:37.892]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:37.892]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:37.892]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:37.892]             base::names(...future.oldOptions))
[10:22:37.892]     }
[10:22:37.892]     if (FALSE) {
[10:22:37.892]     }
[10:22:37.892]     else {
[10:22:37.892]         if (TRUE) {
[10:22:37.892]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:37.892]                 open = "w")
[10:22:37.892]         }
[10:22:37.892]         else {
[10:22:37.892]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:37.892]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:37.892]         }
[10:22:37.892]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:37.892]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:37.892]             base::sink(type = "output", split = FALSE)
[10:22:37.892]             base::close(...future.stdout)
[10:22:37.892]         }, add = TRUE)
[10:22:37.892]     }
[10:22:37.892]     ...future.frame <- base::sys.nframe()
[10:22:37.892]     ...future.conditions <- base::list()
[10:22:37.892]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:37.892]     if (FALSE) {
[10:22:37.892]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:37.892]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:37.892]     }
[10:22:37.892]     ...future.result <- base::tryCatch({
[10:22:37.892]         base::withCallingHandlers({
[10:22:37.892]             ...future.value <- base::withVisible(base::local({
[10:22:37.892]                 ...future.makeSendCondition <- base::local({
[10:22:37.892]                   sendCondition <- NULL
[10:22:37.892]                   function(frame = 1L) {
[10:22:37.892]                     if (is.function(sendCondition)) 
[10:22:37.892]                       return(sendCondition)
[10:22:37.892]                     ns <- getNamespace("parallel")
[10:22:37.892]                     if (exists("sendData", mode = "function", 
[10:22:37.892]                       envir = ns)) {
[10:22:37.892]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:37.892]                         envir = ns)
[10:22:37.892]                       envir <- sys.frame(frame)
[10:22:37.892]                       master <- NULL
[10:22:37.892]                       while (!identical(envir, .GlobalEnv) && 
[10:22:37.892]                         !identical(envir, emptyenv())) {
[10:22:37.892]                         if (exists("master", mode = "list", envir = envir, 
[10:22:37.892]                           inherits = FALSE)) {
[10:22:37.892]                           master <- get("master", mode = "list", 
[10:22:37.892]                             envir = envir, inherits = FALSE)
[10:22:37.892]                           if (inherits(master, c("SOCKnode", 
[10:22:37.892]                             "SOCK0node"))) {
[10:22:37.892]                             sendCondition <<- function(cond) {
[10:22:37.892]                               data <- list(type = "VALUE", value = cond, 
[10:22:37.892]                                 success = TRUE)
[10:22:37.892]                               parallel_sendData(master, data)
[10:22:37.892]                             }
[10:22:37.892]                             return(sendCondition)
[10:22:37.892]                           }
[10:22:37.892]                         }
[10:22:37.892]                         frame <- frame + 1L
[10:22:37.892]                         envir <- sys.frame(frame)
[10:22:37.892]                       }
[10:22:37.892]                     }
[10:22:37.892]                     sendCondition <<- function(cond) NULL
[10:22:37.892]                   }
[10:22:37.892]                 })
[10:22:37.892]                 withCallingHandlers({
[10:22:37.892]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:22:37.892]                 }, immediateCondition = function(cond) {
[10:22:37.892]                   sendCondition <- ...future.makeSendCondition()
[10:22:37.892]                   sendCondition(cond)
[10:22:37.892]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:37.892]                   {
[10:22:37.892]                     inherits <- base::inherits
[10:22:37.892]                     invokeRestart <- base::invokeRestart
[10:22:37.892]                     is.null <- base::is.null
[10:22:37.892]                     muffled <- FALSE
[10:22:37.892]                     if (inherits(cond, "message")) {
[10:22:37.892]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:37.892]                       if (muffled) 
[10:22:37.892]                         invokeRestart("muffleMessage")
[10:22:37.892]                     }
[10:22:37.892]                     else if (inherits(cond, "warning")) {
[10:22:37.892]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:37.892]                       if (muffled) 
[10:22:37.892]                         invokeRestart("muffleWarning")
[10:22:37.892]                     }
[10:22:37.892]                     else if (inherits(cond, "condition")) {
[10:22:37.892]                       if (!is.null(pattern)) {
[10:22:37.892]                         computeRestarts <- base::computeRestarts
[10:22:37.892]                         grepl <- base::grepl
[10:22:37.892]                         restarts <- computeRestarts(cond)
[10:22:37.892]                         for (restart in restarts) {
[10:22:37.892]                           name <- restart$name
[10:22:37.892]                           if (is.null(name)) 
[10:22:37.892]                             next
[10:22:37.892]                           if (!grepl(pattern, name)) 
[10:22:37.892]                             next
[10:22:37.892]                           invokeRestart(restart)
[10:22:37.892]                           muffled <- TRUE
[10:22:37.892]                           break
[10:22:37.892]                         }
[10:22:37.892]                       }
[10:22:37.892]                     }
[10:22:37.892]                     invisible(muffled)
[10:22:37.892]                   }
[10:22:37.892]                   muffleCondition(cond)
[10:22:37.892]                 })
[10:22:37.892]             }))
[10:22:37.892]             future::FutureResult(value = ...future.value$value, 
[10:22:37.892]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:37.892]                   ...future.rng), globalenv = if (FALSE) 
[10:22:37.892]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:37.892]                     ...future.globalenv.names))
[10:22:37.892]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:37.892]         }, condition = base::local({
[10:22:37.892]             c <- base::c
[10:22:37.892]             inherits <- base::inherits
[10:22:37.892]             invokeRestart <- base::invokeRestart
[10:22:37.892]             length <- base::length
[10:22:37.892]             list <- base::list
[10:22:37.892]             seq.int <- base::seq.int
[10:22:37.892]             signalCondition <- base::signalCondition
[10:22:37.892]             sys.calls <- base::sys.calls
[10:22:37.892]             `[[` <- base::`[[`
[10:22:37.892]             `+` <- base::`+`
[10:22:37.892]             `<<-` <- base::`<<-`
[10:22:37.892]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:37.892]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:37.892]                   3L)]
[10:22:37.892]             }
[10:22:37.892]             function(cond) {
[10:22:37.892]                 is_error <- inherits(cond, "error")
[10:22:37.892]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:37.892]                   NULL)
[10:22:37.892]                 if (is_error) {
[10:22:37.892]                   sessionInformation <- function() {
[10:22:37.892]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:37.892]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:37.892]                       search = base::search(), system = base::Sys.info())
[10:22:37.892]                   }
[10:22:37.892]                   ...future.conditions[[length(...future.conditions) + 
[10:22:37.892]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:37.892]                     cond$call), session = sessionInformation(), 
[10:22:37.892]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:37.892]                   signalCondition(cond)
[10:22:37.892]                 }
[10:22:37.892]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:37.892]                 "immediateCondition"))) {
[10:22:37.892]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:37.892]                   ...future.conditions[[length(...future.conditions) + 
[10:22:37.892]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:37.892]                   if (TRUE && !signal) {
[10:22:37.892]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:37.892]                     {
[10:22:37.892]                       inherits <- base::inherits
[10:22:37.892]                       invokeRestart <- base::invokeRestart
[10:22:37.892]                       is.null <- base::is.null
[10:22:37.892]                       muffled <- FALSE
[10:22:37.892]                       if (inherits(cond, "message")) {
[10:22:37.892]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:37.892]                         if (muffled) 
[10:22:37.892]                           invokeRestart("muffleMessage")
[10:22:37.892]                       }
[10:22:37.892]                       else if (inherits(cond, "warning")) {
[10:22:37.892]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:37.892]                         if (muffled) 
[10:22:37.892]                           invokeRestart("muffleWarning")
[10:22:37.892]                       }
[10:22:37.892]                       else if (inherits(cond, "condition")) {
[10:22:37.892]                         if (!is.null(pattern)) {
[10:22:37.892]                           computeRestarts <- base::computeRestarts
[10:22:37.892]                           grepl <- base::grepl
[10:22:37.892]                           restarts <- computeRestarts(cond)
[10:22:37.892]                           for (restart in restarts) {
[10:22:37.892]                             name <- restart$name
[10:22:37.892]                             if (is.null(name)) 
[10:22:37.892]                               next
[10:22:37.892]                             if (!grepl(pattern, name)) 
[10:22:37.892]                               next
[10:22:37.892]                             invokeRestart(restart)
[10:22:37.892]                             muffled <- TRUE
[10:22:37.892]                             break
[10:22:37.892]                           }
[10:22:37.892]                         }
[10:22:37.892]                       }
[10:22:37.892]                       invisible(muffled)
[10:22:37.892]                     }
[10:22:37.892]                     muffleCondition(cond, pattern = "^muffle")
[10:22:37.892]                   }
[10:22:37.892]                 }
[10:22:37.892]                 else {
[10:22:37.892]                   if (TRUE) {
[10:22:37.892]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:37.892]                     {
[10:22:37.892]                       inherits <- base::inherits
[10:22:37.892]                       invokeRestart <- base::invokeRestart
[10:22:37.892]                       is.null <- base::is.null
[10:22:37.892]                       muffled <- FALSE
[10:22:37.892]                       if (inherits(cond, "message")) {
[10:22:37.892]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:37.892]                         if (muffled) 
[10:22:37.892]                           invokeRestart("muffleMessage")
[10:22:37.892]                       }
[10:22:37.892]                       else if (inherits(cond, "warning")) {
[10:22:37.892]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:37.892]                         if (muffled) 
[10:22:37.892]                           invokeRestart("muffleWarning")
[10:22:37.892]                       }
[10:22:37.892]                       else if (inherits(cond, "condition")) {
[10:22:37.892]                         if (!is.null(pattern)) {
[10:22:37.892]                           computeRestarts <- base::computeRestarts
[10:22:37.892]                           grepl <- base::grepl
[10:22:37.892]                           restarts <- computeRestarts(cond)
[10:22:37.892]                           for (restart in restarts) {
[10:22:37.892]                             name <- restart$name
[10:22:37.892]                             if (is.null(name)) 
[10:22:37.892]                               next
[10:22:37.892]                             if (!grepl(pattern, name)) 
[10:22:37.892]                               next
[10:22:37.892]                             invokeRestart(restart)
[10:22:37.892]                             muffled <- TRUE
[10:22:37.892]                             break
[10:22:37.892]                           }
[10:22:37.892]                         }
[10:22:37.892]                       }
[10:22:37.892]                       invisible(muffled)
[10:22:37.892]                     }
[10:22:37.892]                     muffleCondition(cond, pattern = "^muffle")
[10:22:37.892]                   }
[10:22:37.892]                 }
[10:22:37.892]             }
[10:22:37.892]         }))
[10:22:37.892]     }, error = function(ex) {
[10:22:37.892]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:37.892]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:37.892]                 ...future.rng), started = ...future.startTime, 
[10:22:37.892]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:37.892]             version = "1.8"), class = "FutureResult")
[10:22:37.892]     }, finally = {
[10:22:37.892]         if (!identical(...future.workdir, getwd())) 
[10:22:37.892]             setwd(...future.workdir)
[10:22:37.892]         {
[10:22:37.892]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:37.892]                 ...future.oldOptions$nwarnings <- NULL
[10:22:37.892]             }
[10:22:37.892]             base::options(...future.oldOptions)
[10:22:37.892]             if (.Platform$OS.type == "windows") {
[10:22:37.892]                 old_names <- names(...future.oldEnvVars)
[10:22:37.892]                 envs <- base::Sys.getenv()
[10:22:37.892]                 names <- names(envs)
[10:22:37.892]                 common <- intersect(names, old_names)
[10:22:37.892]                 added <- setdiff(names, old_names)
[10:22:37.892]                 removed <- setdiff(old_names, names)
[10:22:37.892]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:37.892]                   envs[common]]
[10:22:37.892]                 NAMES <- toupper(changed)
[10:22:37.892]                 args <- list()
[10:22:37.892]                 for (kk in seq_along(NAMES)) {
[10:22:37.892]                   name <- changed[[kk]]
[10:22:37.892]                   NAME <- NAMES[[kk]]
[10:22:37.892]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:37.892]                     next
[10:22:37.892]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:37.892]                 }
[10:22:37.892]                 NAMES <- toupper(added)
[10:22:37.892]                 for (kk in seq_along(NAMES)) {
[10:22:37.892]                   name <- added[[kk]]
[10:22:37.892]                   NAME <- NAMES[[kk]]
[10:22:37.892]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:37.892]                     next
[10:22:37.892]                   args[[name]] <- ""
[10:22:37.892]                 }
[10:22:37.892]                 NAMES <- toupper(removed)
[10:22:37.892]                 for (kk in seq_along(NAMES)) {
[10:22:37.892]                   name <- removed[[kk]]
[10:22:37.892]                   NAME <- NAMES[[kk]]
[10:22:37.892]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:37.892]                     next
[10:22:37.892]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:37.892]                 }
[10:22:37.892]                 if (length(args) > 0) 
[10:22:37.892]                   base::do.call(base::Sys.setenv, args = args)
[10:22:37.892]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:37.892]             }
[10:22:37.892]             else {
[10:22:37.892]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:37.892]             }
[10:22:37.892]             {
[10:22:37.892]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:37.892]                   0L) {
[10:22:37.892]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:37.892]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:37.892]                   base::options(opts)
[10:22:37.892]                 }
[10:22:37.892]                 {
[10:22:37.892]                   {
[10:22:37.892]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:37.892]                     NULL
[10:22:37.892]                   }
[10:22:37.892]                   options(future.plan = NULL)
[10:22:37.892]                   if (is.na(NA_character_)) 
[10:22:37.892]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:37.892]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:37.892]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:37.892]                     .init = FALSE)
[10:22:37.892]                 }
[10:22:37.892]             }
[10:22:37.892]         }
[10:22:37.892]     })
[10:22:37.892]     if (TRUE) {
[10:22:37.892]         base::sink(type = "output", split = FALSE)
[10:22:37.892]         if (TRUE) {
[10:22:37.892]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:37.892]         }
[10:22:37.892]         else {
[10:22:37.892]             ...future.result["stdout"] <- base::list(NULL)
[10:22:37.892]         }
[10:22:37.892]         base::close(...future.stdout)
[10:22:37.892]         ...future.stdout <- NULL
[10:22:37.892]     }
[10:22:37.892]     ...future.result$conditions <- ...future.conditions
[10:22:37.892]     ...future.result$finished <- base::Sys.time()
[10:22:37.892]     ...future.result
[10:22:37.892] }
[10:22:37.895] MultisessionFuture started
[10:22:37.895] - Launch lazy future ... done
[10:22:37.895] run() for ‘MultisessionFuture’ ... done
[10:22:37.937] receiveMessageFromWorker() for ClusterFuture ...
[10:22:37.937] - Validating connection of MultisessionFuture
[10:22:37.938] - received message: FutureResult
[10:22:37.938] - Received FutureResult
[10:22:37.938] - Erased future from FutureRegistry
[10:22:37.938] result() for ClusterFuture ...
[10:22:37.938] - result already collected: FutureResult
[10:22:37.938] result() for ClusterFuture ... done
[10:22:37.938] signalConditions() ...
[10:22:37.938]  - include = ‘immediateCondition’
[10:22:37.938]  - exclude = 
[10:22:37.939]  - resignal = FALSE
[10:22:37.939]  - Number of conditions: 1
[10:22:37.939] signalConditions() ... done
[10:22:37.939] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:37.939] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 1 ... DONE
- result = FALSE, recursive = 2 ...
[10:22:37.939] getGlobalsAndPackages() ...
[10:22:37.939] Searching for globals...
[10:22:37.940] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:22:37.940] Searching for globals ... DONE
[10:22:37.940] Resolving globals: FALSE
[10:22:37.941] 
[10:22:37.941] 
[10:22:37.941] getGlobalsAndPackages() ... DONE
[10:22:37.941] run() for ‘Future’ ...
[10:22:37.941] - state: ‘created’
[10:22:37.941] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:37.955] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:37.955] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:37.955]   - Field: ‘node’
[10:22:37.955]   - Field: ‘label’
[10:22:37.955]   - Field: ‘local’
[10:22:37.956]   - Field: ‘owner’
[10:22:37.956]   - Field: ‘envir’
[10:22:37.956]   - Field: ‘workers’
[10:22:37.956]   - Field: ‘packages’
[10:22:37.956]   - Field: ‘gc’
[10:22:37.956]   - Field: ‘conditions’
[10:22:37.956]   - Field: ‘persistent’
[10:22:37.956]   - Field: ‘expr’
[10:22:37.956]   - Field: ‘uuid’
[10:22:37.956]   - Field: ‘seed’
[10:22:37.956]   - Field: ‘version’
[10:22:37.956]   - Field: ‘result’
[10:22:37.957]   - Field: ‘asynchronous’
[10:22:37.957]   - Field: ‘calls’
[10:22:37.957]   - Field: ‘globals’
[10:22:37.957]   - Field: ‘stdout’
[10:22:37.957]   - Field: ‘earlySignal’
[10:22:37.957]   - Field: ‘lazy’
[10:22:37.957]   - Field: ‘state’
[10:22:37.957] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:37.957] - Launch lazy future ...
[10:22:37.957] Packages needed by the future expression (n = 0): <none>
[10:22:37.958] Packages needed by future strategies (n = 0): <none>
[10:22:37.958] {
[10:22:37.958]     {
[10:22:37.958]         {
[10:22:37.958]             ...future.startTime <- base::Sys.time()
[10:22:37.958]             {
[10:22:37.958]                 {
[10:22:37.958]                   {
[10:22:37.958]                     {
[10:22:37.958]                       base::local({
[10:22:37.958]                         has_future <- base::requireNamespace("future", 
[10:22:37.958]                           quietly = TRUE)
[10:22:37.958]                         if (has_future) {
[10:22:37.958]                           ns <- base::getNamespace("future")
[10:22:37.958]                           version <- ns[[".package"]][["version"]]
[10:22:37.958]                           if (is.null(version)) 
[10:22:37.958]                             version <- utils::packageVersion("future")
[10:22:37.958]                         }
[10:22:37.958]                         else {
[10:22:37.958]                           version <- NULL
[10:22:37.958]                         }
[10:22:37.958]                         if (!has_future || version < "1.8.0") {
[10:22:37.958]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:37.958]                             "", base::R.version$version.string), 
[10:22:37.958]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:37.958]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:37.958]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:37.958]                               "release", "version")], collapse = " "), 
[10:22:37.958]                             hostname = base::Sys.info()[["nodename"]])
[10:22:37.958]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:37.958]                             info)
[10:22:37.958]                           info <- base::paste(info, collapse = "; ")
[10:22:37.958]                           if (!has_future) {
[10:22:37.958]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:37.958]                               info)
[10:22:37.958]                           }
[10:22:37.958]                           else {
[10:22:37.958]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:37.958]                               info, version)
[10:22:37.958]                           }
[10:22:37.958]                           base::stop(msg)
[10:22:37.958]                         }
[10:22:37.958]                       })
[10:22:37.958]                     }
[10:22:37.958]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:37.958]                     base::options(mc.cores = 1L)
[10:22:37.958]                   }
[10:22:37.958]                   ...future.strategy.old <- future::plan("list")
[10:22:37.958]                   options(future.plan = NULL)
[10:22:37.958]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:37.958]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:37.958]                 }
[10:22:37.958]                 ...future.workdir <- getwd()
[10:22:37.958]             }
[10:22:37.958]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:37.958]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:37.958]         }
[10:22:37.958]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:37.958]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:37.958]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:37.958]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:37.958]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:37.958]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:37.958]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:37.958]             base::names(...future.oldOptions))
[10:22:37.958]     }
[10:22:37.958]     if (FALSE) {
[10:22:37.958]     }
[10:22:37.958]     else {
[10:22:37.958]         if (TRUE) {
[10:22:37.958]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:37.958]                 open = "w")
[10:22:37.958]         }
[10:22:37.958]         else {
[10:22:37.958]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:37.958]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:37.958]         }
[10:22:37.958]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:37.958]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:37.958]             base::sink(type = "output", split = FALSE)
[10:22:37.958]             base::close(...future.stdout)
[10:22:37.958]         }, add = TRUE)
[10:22:37.958]     }
[10:22:37.958]     ...future.frame <- base::sys.nframe()
[10:22:37.958]     ...future.conditions <- base::list()
[10:22:37.958]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:37.958]     if (FALSE) {
[10:22:37.958]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:37.958]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:37.958]     }
[10:22:37.958]     ...future.result <- base::tryCatch({
[10:22:37.958]         base::withCallingHandlers({
[10:22:37.958]             ...future.value <- base::withVisible(base::local({
[10:22:37.958]                 ...future.makeSendCondition <- base::local({
[10:22:37.958]                   sendCondition <- NULL
[10:22:37.958]                   function(frame = 1L) {
[10:22:37.958]                     if (is.function(sendCondition)) 
[10:22:37.958]                       return(sendCondition)
[10:22:37.958]                     ns <- getNamespace("parallel")
[10:22:37.958]                     if (exists("sendData", mode = "function", 
[10:22:37.958]                       envir = ns)) {
[10:22:37.958]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:37.958]                         envir = ns)
[10:22:37.958]                       envir <- sys.frame(frame)
[10:22:37.958]                       master <- NULL
[10:22:37.958]                       while (!identical(envir, .GlobalEnv) && 
[10:22:37.958]                         !identical(envir, emptyenv())) {
[10:22:37.958]                         if (exists("master", mode = "list", envir = envir, 
[10:22:37.958]                           inherits = FALSE)) {
[10:22:37.958]                           master <- get("master", mode = "list", 
[10:22:37.958]                             envir = envir, inherits = FALSE)
[10:22:37.958]                           if (inherits(master, c("SOCKnode", 
[10:22:37.958]                             "SOCK0node"))) {
[10:22:37.958]                             sendCondition <<- function(cond) {
[10:22:37.958]                               data <- list(type = "VALUE", value = cond, 
[10:22:37.958]                                 success = TRUE)
[10:22:37.958]                               parallel_sendData(master, data)
[10:22:37.958]                             }
[10:22:37.958]                             return(sendCondition)
[10:22:37.958]                           }
[10:22:37.958]                         }
[10:22:37.958]                         frame <- frame + 1L
[10:22:37.958]                         envir <- sys.frame(frame)
[10:22:37.958]                       }
[10:22:37.958]                     }
[10:22:37.958]                     sendCondition <<- function(cond) NULL
[10:22:37.958]                   }
[10:22:37.958]                 })
[10:22:37.958]                 withCallingHandlers({
[10:22:37.958]                   {
[10:22:37.958]                     Sys.sleep(0.5)
[10:22:37.958]                     list(a = 1, b = 42L)
[10:22:37.958]                   }
[10:22:37.958]                 }, immediateCondition = function(cond) {
[10:22:37.958]                   sendCondition <- ...future.makeSendCondition()
[10:22:37.958]                   sendCondition(cond)
[10:22:37.958]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:37.958]                   {
[10:22:37.958]                     inherits <- base::inherits
[10:22:37.958]                     invokeRestart <- base::invokeRestart
[10:22:37.958]                     is.null <- base::is.null
[10:22:37.958]                     muffled <- FALSE
[10:22:37.958]                     if (inherits(cond, "message")) {
[10:22:37.958]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:37.958]                       if (muffled) 
[10:22:37.958]                         invokeRestart("muffleMessage")
[10:22:37.958]                     }
[10:22:37.958]                     else if (inherits(cond, "warning")) {
[10:22:37.958]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:37.958]                       if (muffled) 
[10:22:37.958]                         invokeRestart("muffleWarning")
[10:22:37.958]                     }
[10:22:37.958]                     else if (inherits(cond, "condition")) {
[10:22:37.958]                       if (!is.null(pattern)) {
[10:22:37.958]                         computeRestarts <- base::computeRestarts
[10:22:37.958]                         grepl <- base::grepl
[10:22:37.958]                         restarts <- computeRestarts(cond)
[10:22:37.958]                         for (restart in restarts) {
[10:22:37.958]                           name <- restart$name
[10:22:37.958]                           if (is.null(name)) 
[10:22:37.958]                             next
[10:22:37.958]                           if (!grepl(pattern, name)) 
[10:22:37.958]                             next
[10:22:37.958]                           invokeRestart(restart)
[10:22:37.958]                           muffled <- TRUE
[10:22:37.958]                           break
[10:22:37.958]                         }
[10:22:37.958]                       }
[10:22:37.958]                     }
[10:22:37.958]                     invisible(muffled)
[10:22:37.958]                   }
[10:22:37.958]                   muffleCondition(cond)
[10:22:37.958]                 })
[10:22:37.958]             }))
[10:22:37.958]             future::FutureResult(value = ...future.value$value, 
[10:22:37.958]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:37.958]                   ...future.rng), globalenv = if (FALSE) 
[10:22:37.958]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:37.958]                     ...future.globalenv.names))
[10:22:37.958]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:37.958]         }, condition = base::local({
[10:22:37.958]             c <- base::c
[10:22:37.958]             inherits <- base::inherits
[10:22:37.958]             invokeRestart <- base::invokeRestart
[10:22:37.958]             length <- base::length
[10:22:37.958]             list <- base::list
[10:22:37.958]             seq.int <- base::seq.int
[10:22:37.958]             signalCondition <- base::signalCondition
[10:22:37.958]             sys.calls <- base::sys.calls
[10:22:37.958]             `[[` <- base::`[[`
[10:22:37.958]             `+` <- base::`+`
[10:22:37.958]             `<<-` <- base::`<<-`
[10:22:37.958]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:37.958]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:37.958]                   3L)]
[10:22:37.958]             }
[10:22:37.958]             function(cond) {
[10:22:37.958]                 is_error <- inherits(cond, "error")
[10:22:37.958]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:37.958]                   NULL)
[10:22:37.958]                 if (is_error) {
[10:22:37.958]                   sessionInformation <- function() {
[10:22:37.958]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:37.958]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:37.958]                       search = base::search(), system = base::Sys.info())
[10:22:37.958]                   }
[10:22:37.958]                   ...future.conditions[[length(...future.conditions) + 
[10:22:37.958]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:37.958]                     cond$call), session = sessionInformation(), 
[10:22:37.958]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:37.958]                   signalCondition(cond)
[10:22:37.958]                 }
[10:22:37.958]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:37.958]                 "immediateCondition"))) {
[10:22:37.958]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:37.958]                   ...future.conditions[[length(...future.conditions) + 
[10:22:37.958]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:37.958]                   if (TRUE && !signal) {
[10:22:37.958]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:37.958]                     {
[10:22:37.958]                       inherits <- base::inherits
[10:22:37.958]                       invokeRestart <- base::invokeRestart
[10:22:37.958]                       is.null <- base::is.null
[10:22:37.958]                       muffled <- FALSE
[10:22:37.958]                       if (inherits(cond, "message")) {
[10:22:37.958]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:37.958]                         if (muffled) 
[10:22:37.958]                           invokeRestart("muffleMessage")
[10:22:37.958]                       }
[10:22:37.958]                       else if (inherits(cond, "warning")) {
[10:22:37.958]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:37.958]                         if (muffled) 
[10:22:37.958]                           invokeRestart("muffleWarning")
[10:22:37.958]                       }
[10:22:37.958]                       else if (inherits(cond, "condition")) {
[10:22:37.958]                         if (!is.null(pattern)) {
[10:22:37.958]                           computeRestarts <- base::computeRestarts
[10:22:37.958]                           grepl <- base::grepl
[10:22:37.958]                           restarts <- computeRestarts(cond)
[10:22:37.958]                           for (restart in restarts) {
[10:22:37.958]                             name <- restart$name
[10:22:37.958]                             if (is.null(name)) 
[10:22:37.958]                               next
[10:22:37.958]                             if (!grepl(pattern, name)) 
[10:22:37.958]                               next
[10:22:37.958]                             invokeRestart(restart)
[10:22:37.958]                             muffled <- TRUE
[10:22:37.958]                             break
[10:22:37.958]                           }
[10:22:37.958]                         }
[10:22:37.958]                       }
[10:22:37.958]                       invisible(muffled)
[10:22:37.958]                     }
[10:22:37.958]                     muffleCondition(cond, pattern = "^muffle")
[10:22:37.958]                   }
[10:22:37.958]                 }
[10:22:37.958]                 else {
[10:22:37.958]                   if (TRUE) {
[10:22:37.958]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:37.958]                     {
[10:22:37.958]                       inherits <- base::inherits
[10:22:37.958]                       invokeRestart <- base::invokeRestart
[10:22:37.958]                       is.null <- base::is.null
[10:22:37.958]                       muffled <- FALSE
[10:22:37.958]                       if (inherits(cond, "message")) {
[10:22:37.958]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:37.958]                         if (muffled) 
[10:22:37.958]                           invokeRestart("muffleMessage")
[10:22:37.958]                       }
[10:22:37.958]                       else if (inherits(cond, "warning")) {
[10:22:37.958]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:37.958]                         if (muffled) 
[10:22:37.958]                           invokeRestart("muffleWarning")
[10:22:37.958]                       }
[10:22:37.958]                       else if (inherits(cond, "condition")) {
[10:22:37.958]                         if (!is.null(pattern)) {
[10:22:37.958]                           computeRestarts <- base::computeRestarts
[10:22:37.958]                           grepl <- base::grepl
[10:22:37.958]                           restarts <- computeRestarts(cond)
[10:22:37.958]                           for (restart in restarts) {
[10:22:37.958]                             name <- restart$name
[10:22:37.958]                             if (is.null(name)) 
[10:22:37.958]                               next
[10:22:37.958]                             if (!grepl(pattern, name)) 
[10:22:37.958]                               next
[10:22:37.958]                             invokeRestart(restart)
[10:22:37.958]                             muffled <- TRUE
[10:22:37.958]                             break
[10:22:37.958]                           }
[10:22:37.958]                         }
[10:22:37.958]                       }
[10:22:37.958]                       invisible(muffled)
[10:22:37.958]                     }
[10:22:37.958]                     muffleCondition(cond, pattern = "^muffle")
[10:22:37.958]                   }
[10:22:37.958]                 }
[10:22:37.958]             }
[10:22:37.958]         }))
[10:22:37.958]     }, error = function(ex) {
[10:22:37.958]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:37.958]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:37.958]                 ...future.rng), started = ...future.startTime, 
[10:22:37.958]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:37.958]             version = "1.8"), class = "FutureResult")
[10:22:37.958]     }, finally = {
[10:22:37.958]         if (!identical(...future.workdir, getwd())) 
[10:22:37.958]             setwd(...future.workdir)
[10:22:37.958]         {
[10:22:37.958]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:37.958]                 ...future.oldOptions$nwarnings <- NULL
[10:22:37.958]             }
[10:22:37.958]             base::options(...future.oldOptions)
[10:22:37.958]             if (.Platform$OS.type == "windows") {
[10:22:37.958]                 old_names <- names(...future.oldEnvVars)
[10:22:37.958]                 envs <- base::Sys.getenv()
[10:22:37.958]                 names <- names(envs)
[10:22:37.958]                 common <- intersect(names, old_names)
[10:22:37.958]                 added <- setdiff(names, old_names)
[10:22:37.958]                 removed <- setdiff(old_names, names)
[10:22:37.958]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:37.958]                   envs[common]]
[10:22:37.958]                 NAMES <- toupper(changed)
[10:22:37.958]                 args <- list()
[10:22:37.958]                 for (kk in seq_along(NAMES)) {
[10:22:37.958]                   name <- changed[[kk]]
[10:22:37.958]                   NAME <- NAMES[[kk]]
[10:22:37.958]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:37.958]                     next
[10:22:37.958]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:37.958]                 }
[10:22:37.958]                 NAMES <- toupper(added)
[10:22:37.958]                 for (kk in seq_along(NAMES)) {
[10:22:37.958]                   name <- added[[kk]]
[10:22:37.958]                   NAME <- NAMES[[kk]]
[10:22:37.958]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:37.958]                     next
[10:22:37.958]                   args[[name]] <- ""
[10:22:37.958]                 }
[10:22:37.958]                 NAMES <- toupper(removed)
[10:22:37.958]                 for (kk in seq_along(NAMES)) {
[10:22:37.958]                   name <- removed[[kk]]
[10:22:37.958]                   NAME <- NAMES[[kk]]
[10:22:37.958]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:37.958]                     next
[10:22:37.958]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:37.958]                 }
[10:22:37.958]                 if (length(args) > 0) 
[10:22:37.958]                   base::do.call(base::Sys.setenv, args = args)
[10:22:37.958]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:37.958]             }
[10:22:37.958]             else {
[10:22:37.958]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:37.958]             }
[10:22:37.958]             {
[10:22:37.958]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:37.958]                   0L) {
[10:22:37.958]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:37.958]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:37.958]                   base::options(opts)
[10:22:37.958]                 }
[10:22:37.958]                 {
[10:22:37.958]                   {
[10:22:37.958]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:37.958]                     NULL
[10:22:37.958]                   }
[10:22:37.958]                   options(future.plan = NULL)
[10:22:37.958]                   if (is.na(NA_character_)) 
[10:22:37.958]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:37.958]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:37.958]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:37.958]                     .init = FALSE)
[10:22:37.958]                 }
[10:22:37.958]             }
[10:22:37.958]         }
[10:22:37.958]     })
[10:22:37.958]     if (TRUE) {
[10:22:37.958]         base::sink(type = "output", split = FALSE)
[10:22:37.958]         if (TRUE) {
[10:22:37.958]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:37.958]         }
[10:22:37.958]         else {
[10:22:37.958]             ...future.result["stdout"] <- base::list(NULL)
[10:22:37.958]         }
[10:22:37.958]         base::close(...future.stdout)
[10:22:37.958]         ...future.stdout <- NULL
[10:22:37.958]     }
[10:22:37.958]     ...future.result$conditions <- ...future.conditions
[10:22:37.958]     ...future.result$finished <- base::Sys.time()
[10:22:37.958]     ...future.result
[10:22:37.958] }
[10:22:37.961] MultisessionFuture started
[10:22:37.961] - Launch lazy future ... done
[10:22:37.961] run() for ‘MultisessionFuture’ ... done
[10:22:38.504] receiveMessageFromWorker() for ClusterFuture ...
[10:22:38.504] - Validating connection of MultisessionFuture
[10:22:38.504] - received message: FutureResult
[10:22:38.505] - Received FutureResult
[10:22:38.505] - Erased future from FutureRegistry
[10:22:38.505] result() for ClusterFuture ...
[10:22:38.505] - result already collected: FutureResult
[10:22:38.505] result() for ClusterFuture ... done
[10:22:38.505] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:38.505] A MultisessionFuture was resolved (result was not collected)
[10:22:38.505] getGlobalsAndPackages() ...
[10:22:38.505] Searching for globals...
[10:22:38.506] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:22:38.507] Searching for globals ... DONE
[10:22:38.507] Resolving globals: FALSE
[10:22:38.507] 
[10:22:38.507] 
[10:22:38.507] getGlobalsAndPackages() ... DONE
[10:22:38.507] run() for ‘Future’ ...
[10:22:38.508] - state: ‘created’
[10:22:38.508] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:38.521] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:38.522] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:38.522]   - Field: ‘node’
[10:22:38.522]   - Field: ‘label’
[10:22:38.522]   - Field: ‘local’
[10:22:38.522]   - Field: ‘owner’
[10:22:38.522]   - Field: ‘envir’
[10:22:38.522]   - Field: ‘workers’
[10:22:38.522]   - Field: ‘packages’
[10:22:38.522]   - Field: ‘gc’
[10:22:38.522]   - Field: ‘conditions’
[10:22:38.523]   - Field: ‘persistent’
[10:22:38.523]   - Field: ‘expr’
[10:22:38.523]   - Field: ‘uuid’
[10:22:38.523]   - Field: ‘seed’
[10:22:38.523]   - Field: ‘version’
[10:22:38.523]   - Field: ‘result’
[10:22:38.523]   - Field: ‘asynchronous’
[10:22:38.523]   - Field: ‘calls’
[10:22:38.523]   - Field: ‘globals’
[10:22:38.523]   - Field: ‘stdout’
[10:22:38.523]   - Field: ‘earlySignal’
[10:22:38.523]   - Field: ‘lazy’
[10:22:38.524]   - Field: ‘state’
[10:22:38.524] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:38.524] - Launch lazy future ...
[10:22:38.524] Packages needed by the future expression (n = 0): <none>
[10:22:38.524] Packages needed by future strategies (n = 0): <none>
[10:22:38.524] {
[10:22:38.524]     {
[10:22:38.524]         {
[10:22:38.524]             ...future.startTime <- base::Sys.time()
[10:22:38.524]             {
[10:22:38.524]                 {
[10:22:38.524]                   {
[10:22:38.524]                     {
[10:22:38.524]                       base::local({
[10:22:38.524]                         has_future <- base::requireNamespace("future", 
[10:22:38.524]                           quietly = TRUE)
[10:22:38.524]                         if (has_future) {
[10:22:38.524]                           ns <- base::getNamespace("future")
[10:22:38.524]                           version <- ns[[".package"]][["version"]]
[10:22:38.524]                           if (is.null(version)) 
[10:22:38.524]                             version <- utils::packageVersion("future")
[10:22:38.524]                         }
[10:22:38.524]                         else {
[10:22:38.524]                           version <- NULL
[10:22:38.524]                         }
[10:22:38.524]                         if (!has_future || version < "1.8.0") {
[10:22:38.524]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:38.524]                             "", base::R.version$version.string), 
[10:22:38.524]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:38.524]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:38.524]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:38.524]                               "release", "version")], collapse = " "), 
[10:22:38.524]                             hostname = base::Sys.info()[["nodename"]])
[10:22:38.524]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:38.524]                             info)
[10:22:38.524]                           info <- base::paste(info, collapse = "; ")
[10:22:38.524]                           if (!has_future) {
[10:22:38.524]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:38.524]                               info)
[10:22:38.524]                           }
[10:22:38.524]                           else {
[10:22:38.524]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:38.524]                               info, version)
[10:22:38.524]                           }
[10:22:38.524]                           base::stop(msg)
[10:22:38.524]                         }
[10:22:38.524]                       })
[10:22:38.524]                     }
[10:22:38.524]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:38.524]                     base::options(mc.cores = 1L)
[10:22:38.524]                   }
[10:22:38.524]                   ...future.strategy.old <- future::plan("list")
[10:22:38.524]                   options(future.plan = NULL)
[10:22:38.524]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:38.524]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:38.524]                 }
[10:22:38.524]                 ...future.workdir <- getwd()
[10:22:38.524]             }
[10:22:38.524]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:38.524]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:38.524]         }
[10:22:38.524]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:38.524]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:38.524]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:38.524]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:38.524]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:38.524]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:38.524]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:38.524]             base::names(...future.oldOptions))
[10:22:38.524]     }
[10:22:38.524]     if (FALSE) {
[10:22:38.524]     }
[10:22:38.524]     else {
[10:22:38.524]         if (TRUE) {
[10:22:38.524]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:38.524]                 open = "w")
[10:22:38.524]         }
[10:22:38.524]         else {
[10:22:38.524]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:38.524]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:38.524]         }
[10:22:38.524]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:38.524]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:38.524]             base::sink(type = "output", split = FALSE)
[10:22:38.524]             base::close(...future.stdout)
[10:22:38.524]         }, add = TRUE)
[10:22:38.524]     }
[10:22:38.524]     ...future.frame <- base::sys.nframe()
[10:22:38.524]     ...future.conditions <- base::list()
[10:22:38.524]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:38.524]     if (FALSE) {
[10:22:38.524]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:38.524]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:38.524]     }
[10:22:38.524]     ...future.result <- base::tryCatch({
[10:22:38.524]         base::withCallingHandlers({
[10:22:38.524]             ...future.value <- base::withVisible(base::local({
[10:22:38.524]                 ...future.makeSendCondition <- base::local({
[10:22:38.524]                   sendCondition <- NULL
[10:22:38.524]                   function(frame = 1L) {
[10:22:38.524]                     if (is.function(sendCondition)) 
[10:22:38.524]                       return(sendCondition)
[10:22:38.524]                     ns <- getNamespace("parallel")
[10:22:38.524]                     if (exists("sendData", mode = "function", 
[10:22:38.524]                       envir = ns)) {
[10:22:38.524]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:38.524]                         envir = ns)
[10:22:38.524]                       envir <- sys.frame(frame)
[10:22:38.524]                       master <- NULL
[10:22:38.524]                       while (!identical(envir, .GlobalEnv) && 
[10:22:38.524]                         !identical(envir, emptyenv())) {
[10:22:38.524]                         if (exists("master", mode = "list", envir = envir, 
[10:22:38.524]                           inherits = FALSE)) {
[10:22:38.524]                           master <- get("master", mode = "list", 
[10:22:38.524]                             envir = envir, inherits = FALSE)
[10:22:38.524]                           if (inherits(master, c("SOCKnode", 
[10:22:38.524]                             "SOCK0node"))) {
[10:22:38.524]                             sendCondition <<- function(cond) {
[10:22:38.524]                               data <- list(type = "VALUE", value = cond, 
[10:22:38.524]                                 success = TRUE)
[10:22:38.524]                               parallel_sendData(master, data)
[10:22:38.524]                             }
[10:22:38.524]                             return(sendCondition)
[10:22:38.524]                           }
[10:22:38.524]                         }
[10:22:38.524]                         frame <- frame + 1L
[10:22:38.524]                         envir <- sys.frame(frame)
[10:22:38.524]                       }
[10:22:38.524]                     }
[10:22:38.524]                     sendCondition <<- function(cond) NULL
[10:22:38.524]                   }
[10:22:38.524]                 })
[10:22:38.524]                 withCallingHandlers({
[10:22:38.524]                   {
[10:22:38.524]                     Sys.sleep(0.5)
[10:22:38.524]                     list(a = 1, b = 42L)
[10:22:38.524]                   }
[10:22:38.524]                 }, immediateCondition = function(cond) {
[10:22:38.524]                   sendCondition <- ...future.makeSendCondition()
[10:22:38.524]                   sendCondition(cond)
[10:22:38.524]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:38.524]                   {
[10:22:38.524]                     inherits <- base::inherits
[10:22:38.524]                     invokeRestart <- base::invokeRestart
[10:22:38.524]                     is.null <- base::is.null
[10:22:38.524]                     muffled <- FALSE
[10:22:38.524]                     if (inherits(cond, "message")) {
[10:22:38.524]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:38.524]                       if (muffled) 
[10:22:38.524]                         invokeRestart("muffleMessage")
[10:22:38.524]                     }
[10:22:38.524]                     else if (inherits(cond, "warning")) {
[10:22:38.524]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:38.524]                       if (muffled) 
[10:22:38.524]                         invokeRestart("muffleWarning")
[10:22:38.524]                     }
[10:22:38.524]                     else if (inherits(cond, "condition")) {
[10:22:38.524]                       if (!is.null(pattern)) {
[10:22:38.524]                         computeRestarts <- base::computeRestarts
[10:22:38.524]                         grepl <- base::grepl
[10:22:38.524]                         restarts <- computeRestarts(cond)
[10:22:38.524]                         for (restart in restarts) {
[10:22:38.524]                           name <- restart$name
[10:22:38.524]                           if (is.null(name)) 
[10:22:38.524]                             next
[10:22:38.524]                           if (!grepl(pattern, name)) 
[10:22:38.524]                             next
[10:22:38.524]                           invokeRestart(restart)
[10:22:38.524]                           muffled <- TRUE
[10:22:38.524]                           break
[10:22:38.524]                         }
[10:22:38.524]                       }
[10:22:38.524]                     }
[10:22:38.524]                     invisible(muffled)
[10:22:38.524]                   }
[10:22:38.524]                   muffleCondition(cond)
[10:22:38.524]                 })
[10:22:38.524]             }))
[10:22:38.524]             future::FutureResult(value = ...future.value$value, 
[10:22:38.524]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:38.524]                   ...future.rng), globalenv = if (FALSE) 
[10:22:38.524]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:38.524]                     ...future.globalenv.names))
[10:22:38.524]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:38.524]         }, condition = base::local({
[10:22:38.524]             c <- base::c
[10:22:38.524]             inherits <- base::inherits
[10:22:38.524]             invokeRestart <- base::invokeRestart
[10:22:38.524]             length <- base::length
[10:22:38.524]             list <- base::list
[10:22:38.524]             seq.int <- base::seq.int
[10:22:38.524]             signalCondition <- base::signalCondition
[10:22:38.524]             sys.calls <- base::sys.calls
[10:22:38.524]             `[[` <- base::`[[`
[10:22:38.524]             `+` <- base::`+`
[10:22:38.524]             `<<-` <- base::`<<-`
[10:22:38.524]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:38.524]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:38.524]                   3L)]
[10:22:38.524]             }
[10:22:38.524]             function(cond) {
[10:22:38.524]                 is_error <- inherits(cond, "error")
[10:22:38.524]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:38.524]                   NULL)
[10:22:38.524]                 if (is_error) {
[10:22:38.524]                   sessionInformation <- function() {
[10:22:38.524]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:38.524]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:38.524]                       search = base::search(), system = base::Sys.info())
[10:22:38.524]                   }
[10:22:38.524]                   ...future.conditions[[length(...future.conditions) + 
[10:22:38.524]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:38.524]                     cond$call), session = sessionInformation(), 
[10:22:38.524]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:38.524]                   signalCondition(cond)
[10:22:38.524]                 }
[10:22:38.524]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:38.524]                 "immediateCondition"))) {
[10:22:38.524]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:38.524]                   ...future.conditions[[length(...future.conditions) + 
[10:22:38.524]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:38.524]                   if (TRUE && !signal) {
[10:22:38.524]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:38.524]                     {
[10:22:38.524]                       inherits <- base::inherits
[10:22:38.524]                       invokeRestart <- base::invokeRestart
[10:22:38.524]                       is.null <- base::is.null
[10:22:38.524]                       muffled <- FALSE
[10:22:38.524]                       if (inherits(cond, "message")) {
[10:22:38.524]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:38.524]                         if (muffled) 
[10:22:38.524]                           invokeRestart("muffleMessage")
[10:22:38.524]                       }
[10:22:38.524]                       else if (inherits(cond, "warning")) {
[10:22:38.524]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:38.524]                         if (muffled) 
[10:22:38.524]                           invokeRestart("muffleWarning")
[10:22:38.524]                       }
[10:22:38.524]                       else if (inherits(cond, "condition")) {
[10:22:38.524]                         if (!is.null(pattern)) {
[10:22:38.524]                           computeRestarts <- base::computeRestarts
[10:22:38.524]                           grepl <- base::grepl
[10:22:38.524]                           restarts <- computeRestarts(cond)
[10:22:38.524]                           for (restart in restarts) {
[10:22:38.524]                             name <- restart$name
[10:22:38.524]                             if (is.null(name)) 
[10:22:38.524]                               next
[10:22:38.524]                             if (!grepl(pattern, name)) 
[10:22:38.524]                               next
[10:22:38.524]                             invokeRestart(restart)
[10:22:38.524]                             muffled <- TRUE
[10:22:38.524]                             break
[10:22:38.524]                           }
[10:22:38.524]                         }
[10:22:38.524]                       }
[10:22:38.524]                       invisible(muffled)
[10:22:38.524]                     }
[10:22:38.524]                     muffleCondition(cond, pattern = "^muffle")
[10:22:38.524]                   }
[10:22:38.524]                 }
[10:22:38.524]                 else {
[10:22:38.524]                   if (TRUE) {
[10:22:38.524]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:38.524]                     {
[10:22:38.524]                       inherits <- base::inherits
[10:22:38.524]                       invokeRestart <- base::invokeRestart
[10:22:38.524]                       is.null <- base::is.null
[10:22:38.524]                       muffled <- FALSE
[10:22:38.524]                       if (inherits(cond, "message")) {
[10:22:38.524]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:38.524]                         if (muffled) 
[10:22:38.524]                           invokeRestart("muffleMessage")
[10:22:38.524]                       }
[10:22:38.524]                       else if (inherits(cond, "warning")) {
[10:22:38.524]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:38.524]                         if (muffled) 
[10:22:38.524]                           invokeRestart("muffleWarning")
[10:22:38.524]                       }
[10:22:38.524]                       else if (inherits(cond, "condition")) {
[10:22:38.524]                         if (!is.null(pattern)) {
[10:22:38.524]                           computeRestarts <- base::computeRestarts
[10:22:38.524]                           grepl <- base::grepl
[10:22:38.524]                           restarts <- computeRestarts(cond)
[10:22:38.524]                           for (restart in restarts) {
[10:22:38.524]                             name <- restart$name
[10:22:38.524]                             if (is.null(name)) 
[10:22:38.524]                               next
[10:22:38.524]                             if (!grepl(pattern, name)) 
[10:22:38.524]                               next
[10:22:38.524]                             invokeRestart(restart)
[10:22:38.524]                             muffled <- TRUE
[10:22:38.524]                             break
[10:22:38.524]                           }
[10:22:38.524]                         }
[10:22:38.524]                       }
[10:22:38.524]                       invisible(muffled)
[10:22:38.524]                     }
[10:22:38.524]                     muffleCondition(cond, pattern = "^muffle")
[10:22:38.524]                   }
[10:22:38.524]                 }
[10:22:38.524]             }
[10:22:38.524]         }))
[10:22:38.524]     }, error = function(ex) {
[10:22:38.524]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:38.524]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:38.524]                 ...future.rng), started = ...future.startTime, 
[10:22:38.524]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:38.524]             version = "1.8"), class = "FutureResult")
[10:22:38.524]     }, finally = {
[10:22:38.524]         if (!identical(...future.workdir, getwd())) 
[10:22:38.524]             setwd(...future.workdir)
[10:22:38.524]         {
[10:22:38.524]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:38.524]                 ...future.oldOptions$nwarnings <- NULL
[10:22:38.524]             }
[10:22:38.524]             base::options(...future.oldOptions)
[10:22:38.524]             if (.Platform$OS.type == "windows") {
[10:22:38.524]                 old_names <- names(...future.oldEnvVars)
[10:22:38.524]                 envs <- base::Sys.getenv()
[10:22:38.524]                 names <- names(envs)
[10:22:38.524]                 common <- intersect(names, old_names)
[10:22:38.524]                 added <- setdiff(names, old_names)
[10:22:38.524]                 removed <- setdiff(old_names, names)
[10:22:38.524]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:38.524]                   envs[common]]
[10:22:38.524]                 NAMES <- toupper(changed)
[10:22:38.524]                 args <- list()
[10:22:38.524]                 for (kk in seq_along(NAMES)) {
[10:22:38.524]                   name <- changed[[kk]]
[10:22:38.524]                   NAME <- NAMES[[kk]]
[10:22:38.524]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:38.524]                     next
[10:22:38.524]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:38.524]                 }
[10:22:38.524]                 NAMES <- toupper(added)
[10:22:38.524]                 for (kk in seq_along(NAMES)) {
[10:22:38.524]                   name <- added[[kk]]
[10:22:38.524]                   NAME <- NAMES[[kk]]
[10:22:38.524]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:38.524]                     next
[10:22:38.524]                   args[[name]] <- ""
[10:22:38.524]                 }
[10:22:38.524]                 NAMES <- toupper(removed)
[10:22:38.524]                 for (kk in seq_along(NAMES)) {
[10:22:38.524]                   name <- removed[[kk]]
[10:22:38.524]                   NAME <- NAMES[[kk]]
[10:22:38.524]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:38.524]                     next
[10:22:38.524]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:38.524]                 }
[10:22:38.524]                 if (length(args) > 0) 
[10:22:38.524]                   base::do.call(base::Sys.setenv, args = args)
[10:22:38.524]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:38.524]             }
[10:22:38.524]             else {
[10:22:38.524]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:38.524]             }
[10:22:38.524]             {
[10:22:38.524]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:38.524]                   0L) {
[10:22:38.524]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:38.524]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:38.524]                   base::options(opts)
[10:22:38.524]                 }
[10:22:38.524]                 {
[10:22:38.524]                   {
[10:22:38.524]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:38.524]                     NULL
[10:22:38.524]                   }
[10:22:38.524]                   options(future.plan = NULL)
[10:22:38.524]                   if (is.na(NA_character_)) 
[10:22:38.524]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:38.524]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:38.524]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:38.524]                     .init = FALSE)
[10:22:38.524]                 }
[10:22:38.524]             }
[10:22:38.524]         }
[10:22:38.524]     })
[10:22:38.524]     if (TRUE) {
[10:22:38.524]         base::sink(type = "output", split = FALSE)
[10:22:38.524]         if (TRUE) {
[10:22:38.524]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:38.524]         }
[10:22:38.524]         else {
[10:22:38.524]             ...future.result["stdout"] <- base::list(NULL)
[10:22:38.524]         }
[10:22:38.524]         base::close(...future.stdout)
[10:22:38.524]         ...future.stdout <- NULL
[10:22:38.524]     }
[10:22:38.524]     ...future.result$conditions <- ...future.conditions
[10:22:38.524]     ...future.result$finished <- base::Sys.time()
[10:22:38.524]     ...future.result
[10:22:38.524] }
[10:22:38.530] MultisessionFuture started
[10:22:38.530] - Launch lazy future ... done
[10:22:38.530] run() for ‘MultisessionFuture’ ... done
[10:22:39.073] receiveMessageFromWorker() for ClusterFuture ...
[10:22:39.073] - Validating connection of MultisessionFuture
[10:22:39.073] - received message: FutureResult
[10:22:39.074] - Received FutureResult
[10:22:39.074] - Erased future from FutureRegistry
[10:22:39.074] result() for ClusterFuture ...
[10:22:39.074] - result already collected: FutureResult
[10:22:39.074] result() for ClusterFuture ... done
[10:22:39.074] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:39.074] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[10:22:39.074] getGlobalsAndPackages() ...
[10:22:39.074] Searching for globals...
[10:22:39.075] - globals found: [2] ‘list’, ‘stop’
[10:22:39.075] Searching for globals ... DONE
[10:22:39.075] Resolving globals: FALSE
[10:22:39.076] 
[10:22:39.076] 
[10:22:39.076] getGlobalsAndPackages() ... DONE
[10:22:39.076] run() for ‘Future’ ...
[10:22:39.076] - state: ‘created’
[10:22:39.076] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:39.090] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:39.090] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:39.090]   - Field: ‘node’
[10:22:39.090]   - Field: ‘label’
[10:22:39.090]   - Field: ‘local’
[10:22:39.090]   - Field: ‘owner’
[10:22:39.090]   - Field: ‘envir’
[10:22:39.091]   - Field: ‘workers’
[10:22:39.091]   - Field: ‘packages’
[10:22:39.091]   - Field: ‘gc’
[10:22:39.091]   - Field: ‘conditions’
[10:22:39.091]   - Field: ‘persistent’
[10:22:39.091]   - Field: ‘expr’
[10:22:39.091]   - Field: ‘uuid’
[10:22:39.091]   - Field: ‘seed’
[10:22:39.091]   - Field: ‘version’
[10:22:39.091]   - Field: ‘result’
[10:22:39.091]   - Field: ‘asynchronous’
[10:22:39.091]   - Field: ‘calls’
[10:22:39.092]   - Field: ‘globals’
[10:22:39.092]   - Field: ‘stdout’
[10:22:39.092]   - Field: ‘earlySignal’
[10:22:39.092]   - Field: ‘lazy’
[10:22:39.092]   - Field: ‘state’
[10:22:39.092] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:39.092] - Launch lazy future ...
[10:22:39.092] Packages needed by the future expression (n = 0): <none>
[10:22:39.092] Packages needed by future strategies (n = 0): <none>
[10:22:39.093] {
[10:22:39.093]     {
[10:22:39.093]         {
[10:22:39.093]             ...future.startTime <- base::Sys.time()
[10:22:39.093]             {
[10:22:39.093]                 {
[10:22:39.093]                   {
[10:22:39.093]                     {
[10:22:39.093]                       base::local({
[10:22:39.093]                         has_future <- base::requireNamespace("future", 
[10:22:39.093]                           quietly = TRUE)
[10:22:39.093]                         if (has_future) {
[10:22:39.093]                           ns <- base::getNamespace("future")
[10:22:39.093]                           version <- ns[[".package"]][["version"]]
[10:22:39.093]                           if (is.null(version)) 
[10:22:39.093]                             version <- utils::packageVersion("future")
[10:22:39.093]                         }
[10:22:39.093]                         else {
[10:22:39.093]                           version <- NULL
[10:22:39.093]                         }
[10:22:39.093]                         if (!has_future || version < "1.8.0") {
[10:22:39.093]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:39.093]                             "", base::R.version$version.string), 
[10:22:39.093]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:39.093]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:39.093]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:39.093]                               "release", "version")], collapse = " "), 
[10:22:39.093]                             hostname = base::Sys.info()[["nodename"]])
[10:22:39.093]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:39.093]                             info)
[10:22:39.093]                           info <- base::paste(info, collapse = "; ")
[10:22:39.093]                           if (!has_future) {
[10:22:39.093]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:39.093]                               info)
[10:22:39.093]                           }
[10:22:39.093]                           else {
[10:22:39.093]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:39.093]                               info, version)
[10:22:39.093]                           }
[10:22:39.093]                           base::stop(msg)
[10:22:39.093]                         }
[10:22:39.093]                       })
[10:22:39.093]                     }
[10:22:39.093]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:39.093]                     base::options(mc.cores = 1L)
[10:22:39.093]                   }
[10:22:39.093]                   ...future.strategy.old <- future::plan("list")
[10:22:39.093]                   options(future.plan = NULL)
[10:22:39.093]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:39.093]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:39.093]                 }
[10:22:39.093]                 ...future.workdir <- getwd()
[10:22:39.093]             }
[10:22:39.093]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:39.093]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:39.093]         }
[10:22:39.093]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:39.093]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:39.093]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:39.093]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:39.093]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:39.093]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:39.093]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:39.093]             base::names(...future.oldOptions))
[10:22:39.093]     }
[10:22:39.093]     if (FALSE) {
[10:22:39.093]     }
[10:22:39.093]     else {
[10:22:39.093]         if (TRUE) {
[10:22:39.093]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:39.093]                 open = "w")
[10:22:39.093]         }
[10:22:39.093]         else {
[10:22:39.093]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:39.093]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:39.093]         }
[10:22:39.093]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:39.093]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:39.093]             base::sink(type = "output", split = FALSE)
[10:22:39.093]             base::close(...future.stdout)
[10:22:39.093]         }, add = TRUE)
[10:22:39.093]     }
[10:22:39.093]     ...future.frame <- base::sys.nframe()
[10:22:39.093]     ...future.conditions <- base::list()
[10:22:39.093]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:39.093]     if (FALSE) {
[10:22:39.093]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:39.093]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:39.093]     }
[10:22:39.093]     ...future.result <- base::tryCatch({
[10:22:39.093]         base::withCallingHandlers({
[10:22:39.093]             ...future.value <- base::withVisible(base::local({
[10:22:39.093]                 ...future.makeSendCondition <- base::local({
[10:22:39.093]                   sendCondition <- NULL
[10:22:39.093]                   function(frame = 1L) {
[10:22:39.093]                     if (is.function(sendCondition)) 
[10:22:39.093]                       return(sendCondition)
[10:22:39.093]                     ns <- getNamespace("parallel")
[10:22:39.093]                     if (exists("sendData", mode = "function", 
[10:22:39.093]                       envir = ns)) {
[10:22:39.093]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:39.093]                         envir = ns)
[10:22:39.093]                       envir <- sys.frame(frame)
[10:22:39.093]                       master <- NULL
[10:22:39.093]                       while (!identical(envir, .GlobalEnv) && 
[10:22:39.093]                         !identical(envir, emptyenv())) {
[10:22:39.093]                         if (exists("master", mode = "list", envir = envir, 
[10:22:39.093]                           inherits = FALSE)) {
[10:22:39.093]                           master <- get("master", mode = "list", 
[10:22:39.093]                             envir = envir, inherits = FALSE)
[10:22:39.093]                           if (inherits(master, c("SOCKnode", 
[10:22:39.093]                             "SOCK0node"))) {
[10:22:39.093]                             sendCondition <<- function(cond) {
[10:22:39.093]                               data <- list(type = "VALUE", value = cond, 
[10:22:39.093]                                 success = TRUE)
[10:22:39.093]                               parallel_sendData(master, data)
[10:22:39.093]                             }
[10:22:39.093]                             return(sendCondition)
[10:22:39.093]                           }
[10:22:39.093]                         }
[10:22:39.093]                         frame <- frame + 1L
[10:22:39.093]                         envir <- sys.frame(frame)
[10:22:39.093]                       }
[10:22:39.093]                     }
[10:22:39.093]                     sendCondition <<- function(cond) NULL
[10:22:39.093]                   }
[10:22:39.093]                 })
[10:22:39.093]                 withCallingHandlers({
[10:22:39.093]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:22:39.093]                 }, immediateCondition = function(cond) {
[10:22:39.093]                   sendCondition <- ...future.makeSendCondition()
[10:22:39.093]                   sendCondition(cond)
[10:22:39.093]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:39.093]                   {
[10:22:39.093]                     inherits <- base::inherits
[10:22:39.093]                     invokeRestart <- base::invokeRestart
[10:22:39.093]                     is.null <- base::is.null
[10:22:39.093]                     muffled <- FALSE
[10:22:39.093]                     if (inherits(cond, "message")) {
[10:22:39.093]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:39.093]                       if (muffled) 
[10:22:39.093]                         invokeRestart("muffleMessage")
[10:22:39.093]                     }
[10:22:39.093]                     else if (inherits(cond, "warning")) {
[10:22:39.093]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:39.093]                       if (muffled) 
[10:22:39.093]                         invokeRestart("muffleWarning")
[10:22:39.093]                     }
[10:22:39.093]                     else if (inherits(cond, "condition")) {
[10:22:39.093]                       if (!is.null(pattern)) {
[10:22:39.093]                         computeRestarts <- base::computeRestarts
[10:22:39.093]                         grepl <- base::grepl
[10:22:39.093]                         restarts <- computeRestarts(cond)
[10:22:39.093]                         for (restart in restarts) {
[10:22:39.093]                           name <- restart$name
[10:22:39.093]                           if (is.null(name)) 
[10:22:39.093]                             next
[10:22:39.093]                           if (!grepl(pattern, name)) 
[10:22:39.093]                             next
[10:22:39.093]                           invokeRestart(restart)
[10:22:39.093]                           muffled <- TRUE
[10:22:39.093]                           break
[10:22:39.093]                         }
[10:22:39.093]                       }
[10:22:39.093]                     }
[10:22:39.093]                     invisible(muffled)
[10:22:39.093]                   }
[10:22:39.093]                   muffleCondition(cond)
[10:22:39.093]                 })
[10:22:39.093]             }))
[10:22:39.093]             future::FutureResult(value = ...future.value$value, 
[10:22:39.093]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:39.093]                   ...future.rng), globalenv = if (FALSE) 
[10:22:39.093]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:39.093]                     ...future.globalenv.names))
[10:22:39.093]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:39.093]         }, condition = base::local({
[10:22:39.093]             c <- base::c
[10:22:39.093]             inherits <- base::inherits
[10:22:39.093]             invokeRestart <- base::invokeRestart
[10:22:39.093]             length <- base::length
[10:22:39.093]             list <- base::list
[10:22:39.093]             seq.int <- base::seq.int
[10:22:39.093]             signalCondition <- base::signalCondition
[10:22:39.093]             sys.calls <- base::sys.calls
[10:22:39.093]             `[[` <- base::`[[`
[10:22:39.093]             `+` <- base::`+`
[10:22:39.093]             `<<-` <- base::`<<-`
[10:22:39.093]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:39.093]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:39.093]                   3L)]
[10:22:39.093]             }
[10:22:39.093]             function(cond) {
[10:22:39.093]                 is_error <- inherits(cond, "error")
[10:22:39.093]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:39.093]                   NULL)
[10:22:39.093]                 if (is_error) {
[10:22:39.093]                   sessionInformation <- function() {
[10:22:39.093]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:39.093]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:39.093]                       search = base::search(), system = base::Sys.info())
[10:22:39.093]                   }
[10:22:39.093]                   ...future.conditions[[length(...future.conditions) + 
[10:22:39.093]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:39.093]                     cond$call), session = sessionInformation(), 
[10:22:39.093]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:39.093]                   signalCondition(cond)
[10:22:39.093]                 }
[10:22:39.093]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:39.093]                 "immediateCondition"))) {
[10:22:39.093]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:39.093]                   ...future.conditions[[length(...future.conditions) + 
[10:22:39.093]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:39.093]                   if (TRUE && !signal) {
[10:22:39.093]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:39.093]                     {
[10:22:39.093]                       inherits <- base::inherits
[10:22:39.093]                       invokeRestart <- base::invokeRestart
[10:22:39.093]                       is.null <- base::is.null
[10:22:39.093]                       muffled <- FALSE
[10:22:39.093]                       if (inherits(cond, "message")) {
[10:22:39.093]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:39.093]                         if (muffled) 
[10:22:39.093]                           invokeRestart("muffleMessage")
[10:22:39.093]                       }
[10:22:39.093]                       else if (inherits(cond, "warning")) {
[10:22:39.093]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:39.093]                         if (muffled) 
[10:22:39.093]                           invokeRestart("muffleWarning")
[10:22:39.093]                       }
[10:22:39.093]                       else if (inherits(cond, "condition")) {
[10:22:39.093]                         if (!is.null(pattern)) {
[10:22:39.093]                           computeRestarts <- base::computeRestarts
[10:22:39.093]                           grepl <- base::grepl
[10:22:39.093]                           restarts <- computeRestarts(cond)
[10:22:39.093]                           for (restart in restarts) {
[10:22:39.093]                             name <- restart$name
[10:22:39.093]                             if (is.null(name)) 
[10:22:39.093]                               next
[10:22:39.093]                             if (!grepl(pattern, name)) 
[10:22:39.093]                               next
[10:22:39.093]                             invokeRestart(restart)
[10:22:39.093]                             muffled <- TRUE
[10:22:39.093]                             break
[10:22:39.093]                           }
[10:22:39.093]                         }
[10:22:39.093]                       }
[10:22:39.093]                       invisible(muffled)
[10:22:39.093]                     }
[10:22:39.093]                     muffleCondition(cond, pattern = "^muffle")
[10:22:39.093]                   }
[10:22:39.093]                 }
[10:22:39.093]                 else {
[10:22:39.093]                   if (TRUE) {
[10:22:39.093]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:39.093]                     {
[10:22:39.093]                       inherits <- base::inherits
[10:22:39.093]                       invokeRestart <- base::invokeRestart
[10:22:39.093]                       is.null <- base::is.null
[10:22:39.093]                       muffled <- FALSE
[10:22:39.093]                       if (inherits(cond, "message")) {
[10:22:39.093]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:39.093]                         if (muffled) 
[10:22:39.093]                           invokeRestart("muffleMessage")
[10:22:39.093]                       }
[10:22:39.093]                       else if (inherits(cond, "warning")) {
[10:22:39.093]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:39.093]                         if (muffled) 
[10:22:39.093]                           invokeRestart("muffleWarning")
[10:22:39.093]                       }
[10:22:39.093]                       else if (inherits(cond, "condition")) {
[10:22:39.093]                         if (!is.null(pattern)) {
[10:22:39.093]                           computeRestarts <- base::computeRestarts
[10:22:39.093]                           grepl <- base::grepl
[10:22:39.093]                           restarts <- computeRestarts(cond)
[10:22:39.093]                           for (restart in restarts) {
[10:22:39.093]                             name <- restart$name
[10:22:39.093]                             if (is.null(name)) 
[10:22:39.093]                               next
[10:22:39.093]                             if (!grepl(pattern, name)) 
[10:22:39.093]                               next
[10:22:39.093]                             invokeRestart(restart)
[10:22:39.093]                             muffled <- TRUE
[10:22:39.093]                             break
[10:22:39.093]                           }
[10:22:39.093]                         }
[10:22:39.093]                       }
[10:22:39.093]                       invisible(muffled)
[10:22:39.093]                     }
[10:22:39.093]                     muffleCondition(cond, pattern = "^muffle")
[10:22:39.093]                   }
[10:22:39.093]                 }
[10:22:39.093]             }
[10:22:39.093]         }))
[10:22:39.093]     }, error = function(ex) {
[10:22:39.093]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:39.093]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:39.093]                 ...future.rng), started = ...future.startTime, 
[10:22:39.093]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:39.093]             version = "1.8"), class = "FutureResult")
[10:22:39.093]     }, finally = {
[10:22:39.093]         if (!identical(...future.workdir, getwd())) 
[10:22:39.093]             setwd(...future.workdir)
[10:22:39.093]         {
[10:22:39.093]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:39.093]                 ...future.oldOptions$nwarnings <- NULL
[10:22:39.093]             }
[10:22:39.093]             base::options(...future.oldOptions)
[10:22:39.093]             if (.Platform$OS.type == "windows") {
[10:22:39.093]                 old_names <- names(...future.oldEnvVars)
[10:22:39.093]                 envs <- base::Sys.getenv()
[10:22:39.093]                 names <- names(envs)
[10:22:39.093]                 common <- intersect(names, old_names)
[10:22:39.093]                 added <- setdiff(names, old_names)
[10:22:39.093]                 removed <- setdiff(old_names, names)
[10:22:39.093]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:39.093]                   envs[common]]
[10:22:39.093]                 NAMES <- toupper(changed)
[10:22:39.093]                 args <- list()
[10:22:39.093]                 for (kk in seq_along(NAMES)) {
[10:22:39.093]                   name <- changed[[kk]]
[10:22:39.093]                   NAME <- NAMES[[kk]]
[10:22:39.093]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:39.093]                     next
[10:22:39.093]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:39.093]                 }
[10:22:39.093]                 NAMES <- toupper(added)
[10:22:39.093]                 for (kk in seq_along(NAMES)) {
[10:22:39.093]                   name <- added[[kk]]
[10:22:39.093]                   NAME <- NAMES[[kk]]
[10:22:39.093]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:39.093]                     next
[10:22:39.093]                   args[[name]] <- ""
[10:22:39.093]                 }
[10:22:39.093]                 NAMES <- toupper(removed)
[10:22:39.093]                 for (kk in seq_along(NAMES)) {
[10:22:39.093]                   name <- removed[[kk]]
[10:22:39.093]                   NAME <- NAMES[[kk]]
[10:22:39.093]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:39.093]                     next
[10:22:39.093]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:39.093]                 }
[10:22:39.093]                 if (length(args) > 0) 
[10:22:39.093]                   base::do.call(base::Sys.setenv, args = args)
[10:22:39.093]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:39.093]             }
[10:22:39.093]             else {
[10:22:39.093]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:39.093]             }
[10:22:39.093]             {
[10:22:39.093]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:39.093]                   0L) {
[10:22:39.093]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:39.093]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:39.093]                   base::options(opts)
[10:22:39.093]                 }
[10:22:39.093]                 {
[10:22:39.093]                   {
[10:22:39.093]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:39.093]                     NULL
[10:22:39.093]                   }
[10:22:39.093]                   options(future.plan = NULL)
[10:22:39.093]                   if (is.na(NA_character_)) 
[10:22:39.093]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:39.093]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:39.093]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:39.093]                     .init = FALSE)
[10:22:39.093]                 }
[10:22:39.093]             }
[10:22:39.093]         }
[10:22:39.093]     })
[10:22:39.093]     if (TRUE) {
[10:22:39.093]         base::sink(type = "output", split = FALSE)
[10:22:39.093]         if (TRUE) {
[10:22:39.093]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:39.093]         }
[10:22:39.093]         else {
[10:22:39.093]             ...future.result["stdout"] <- base::list(NULL)
[10:22:39.093]         }
[10:22:39.093]         base::close(...future.stdout)
[10:22:39.093]         ...future.stdout <- NULL
[10:22:39.093]     }
[10:22:39.093]     ...future.result$conditions <- ...future.conditions
[10:22:39.093]     ...future.result$finished <- base::Sys.time()
[10:22:39.093]     ...future.result
[10:22:39.093] }
[10:22:39.096] MultisessionFuture started
[10:22:39.096] - Launch lazy future ... done
[10:22:39.096] run() for ‘MultisessionFuture’ ... done
[10:22:39.138] receiveMessageFromWorker() for ClusterFuture ...
[10:22:39.138] - Validating connection of MultisessionFuture
[10:22:39.139] - received message: FutureResult
[10:22:39.139] - Received FutureResult
[10:22:39.139] - Erased future from FutureRegistry
[10:22:39.139] result() for ClusterFuture ...
[10:22:39.139] - result already collected: FutureResult
[10:22:39.139] result() for ClusterFuture ... done
[10:22:39.139] signalConditions() ...
[10:22:39.139]  - include = ‘immediateCondition’
[10:22:39.139]  - exclude = 
[10:22:39.139]  - resignal = FALSE
[10:22:39.140]  - Number of conditions: 1
[10:22:39.140] signalConditions() ... done
[10:22:39.140] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:39.140] A MultisessionFuture was resolved (result was not collected)
[10:22:39.140] getGlobalsAndPackages() ...
[10:22:39.140] Searching for globals...
[10:22:39.141] - globals found: [2] ‘list’, ‘stop’
[10:22:39.141] Searching for globals ... DONE
[10:22:39.141] Resolving globals: FALSE
[10:22:39.141] 
[10:22:39.141] 
[10:22:39.141] getGlobalsAndPackages() ... DONE
[10:22:39.142] run() for ‘Future’ ...
[10:22:39.142] - state: ‘created’
[10:22:39.142] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:39.156] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:39.156] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:39.156]   - Field: ‘node’
[10:22:39.156]   - Field: ‘label’
[10:22:39.157]   - Field: ‘local’
[10:22:39.157]   - Field: ‘owner’
[10:22:39.157]   - Field: ‘envir’
[10:22:39.157]   - Field: ‘workers’
[10:22:39.157]   - Field: ‘packages’
[10:22:39.157]   - Field: ‘gc’
[10:22:39.157]   - Field: ‘conditions’
[10:22:39.157]   - Field: ‘persistent’
[10:22:39.157]   - Field: ‘expr’
[10:22:39.157]   - Field: ‘uuid’
[10:22:39.157]   - Field: ‘seed’
[10:22:39.158]   - Field: ‘version’
[10:22:39.158]   - Field: ‘result’
[10:22:39.158]   - Field: ‘asynchronous’
[10:22:39.158]   - Field: ‘calls’
[10:22:39.158]   - Field: ‘globals’
[10:22:39.158]   - Field: ‘stdout’
[10:22:39.158]   - Field: ‘earlySignal’
[10:22:39.158]   - Field: ‘lazy’
[10:22:39.158]   - Field: ‘state’
[10:22:39.158] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:39.158] - Launch lazy future ...
[10:22:39.159] Packages needed by the future expression (n = 0): <none>
[10:22:39.159] Packages needed by future strategies (n = 0): <none>
[10:22:39.159] {
[10:22:39.159]     {
[10:22:39.159]         {
[10:22:39.159]             ...future.startTime <- base::Sys.time()
[10:22:39.159]             {
[10:22:39.159]                 {
[10:22:39.159]                   {
[10:22:39.159]                     {
[10:22:39.159]                       base::local({
[10:22:39.159]                         has_future <- base::requireNamespace("future", 
[10:22:39.159]                           quietly = TRUE)
[10:22:39.159]                         if (has_future) {
[10:22:39.159]                           ns <- base::getNamespace("future")
[10:22:39.159]                           version <- ns[[".package"]][["version"]]
[10:22:39.159]                           if (is.null(version)) 
[10:22:39.159]                             version <- utils::packageVersion("future")
[10:22:39.159]                         }
[10:22:39.159]                         else {
[10:22:39.159]                           version <- NULL
[10:22:39.159]                         }
[10:22:39.159]                         if (!has_future || version < "1.8.0") {
[10:22:39.159]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:39.159]                             "", base::R.version$version.string), 
[10:22:39.159]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:39.159]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:39.159]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:39.159]                               "release", "version")], collapse = " "), 
[10:22:39.159]                             hostname = base::Sys.info()[["nodename"]])
[10:22:39.159]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:39.159]                             info)
[10:22:39.159]                           info <- base::paste(info, collapse = "; ")
[10:22:39.159]                           if (!has_future) {
[10:22:39.159]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:39.159]                               info)
[10:22:39.159]                           }
[10:22:39.159]                           else {
[10:22:39.159]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:39.159]                               info, version)
[10:22:39.159]                           }
[10:22:39.159]                           base::stop(msg)
[10:22:39.159]                         }
[10:22:39.159]                       })
[10:22:39.159]                     }
[10:22:39.159]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:39.159]                     base::options(mc.cores = 1L)
[10:22:39.159]                   }
[10:22:39.159]                   ...future.strategy.old <- future::plan("list")
[10:22:39.159]                   options(future.plan = NULL)
[10:22:39.159]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:39.159]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:39.159]                 }
[10:22:39.159]                 ...future.workdir <- getwd()
[10:22:39.159]             }
[10:22:39.159]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:39.159]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:39.159]         }
[10:22:39.159]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:39.159]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:39.159]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:39.159]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:39.159]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:39.159]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:39.159]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:39.159]             base::names(...future.oldOptions))
[10:22:39.159]     }
[10:22:39.159]     if (FALSE) {
[10:22:39.159]     }
[10:22:39.159]     else {
[10:22:39.159]         if (TRUE) {
[10:22:39.159]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:39.159]                 open = "w")
[10:22:39.159]         }
[10:22:39.159]         else {
[10:22:39.159]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:39.159]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:39.159]         }
[10:22:39.159]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:39.159]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:39.159]             base::sink(type = "output", split = FALSE)
[10:22:39.159]             base::close(...future.stdout)
[10:22:39.159]         }, add = TRUE)
[10:22:39.159]     }
[10:22:39.159]     ...future.frame <- base::sys.nframe()
[10:22:39.159]     ...future.conditions <- base::list()
[10:22:39.159]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:39.159]     if (FALSE) {
[10:22:39.159]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:39.159]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:39.159]     }
[10:22:39.159]     ...future.result <- base::tryCatch({
[10:22:39.159]         base::withCallingHandlers({
[10:22:39.159]             ...future.value <- base::withVisible(base::local({
[10:22:39.159]                 ...future.makeSendCondition <- base::local({
[10:22:39.159]                   sendCondition <- NULL
[10:22:39.159]                   function(frame = 1L) {
[10:22:39.159]                     if (is.function(sendCondition)) 
[10:22:39.159]                       return(sendCondition)
[10:22:39.159]                     ns <- getNamespace("parallel")
[10:22:39.159]                     if (exists("sendData", mode = "function", 
[10:22:39.159]                       envir = ns)) {
[10:22:39.159]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:39.159]                         envir = ns)
[10:22:39.159]                       envir <- sys.frame(frame)
[10:22:39.159]                       master <- NULL
[10:22:39.159]                       while (!identical(envir, .GlobalEnv) && 
[10:22:39.159]                         !identical(envir, emptyenv())) {
[10:22:39.159]                         if (exists("master", mode = "list", envir = envir, 
[10:22:39.159]                           inherits = FALSE)) {
[10:22:39.159]                           master <- get("master", mode = "list", 
[10:22:39.159]                             envir = envir, inherits = FALSE)
[10:22:39.159]                           if (inherits(master, c("SOCKnode", 
[10:22:39.159]                             "SOCK0node"))) {
[10:22:39.159]                             sendCondition <<- function(cond) {
[10:22:39.159]                               data <- list(type = "VALUE", value = cond, 
[10:22:39.159]                                 success = TRUE)
[10:22:39.159]                               parallel_sendData(master, data)
[10:22:39.159]                             }
[10:22:39.159]                             return(sendCondition)
[10:22:39.159]                           }
[10:22:39.159]                         }
[10:22:39.159]                         frame <- frame + 1L
[10:22:39.159]                         envir <- sys.frame(frame)
[10:22:39.159]                       }
[10:22:39.159]                     }
[10:22:39.159]                     sendCondition <<- function(cond) NULL
[10:22:39.159]                   }
[10:22:39.159]                 })
[10:22:39.159]                 withCallingHandlers({
[10:22:39.159]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:22:39.159]                 }, immediateCondition = function(cond) {
[10:22:39.159]                   sendCondition <- ...future.makeSendCondition()
[10:22:39.159]                   sendCondition(cond)
[10:22:39.159]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:39.159]                   {
[10:22:39.159]                     inherits <- base::inherits
[10:22:39.159]                     invokeRestart <- base::invokeRestart
[10:22:39.159]                     is.null <- base::is.null
[10:22:39.159]                     muffled <- FALSE
[10:22:39.159]                     if (inherits(cond, "message")) {
[10:22:39.159]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:39.159]                       if (muffled) 
[10:22:39.159]                         invokeRestart("muffleMessage")
[10:22:39.159]                     }
[10:22:39.159]                     else if (inherits(cond, "warning")) {
[10:22:39.159]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:39.159]                       if (muffled) 
[10:22:39.159]                         invokeRestart("muffleWarning")
[10:22:39.159]                     }
[10:22:39.159]                     else if (inherits(cond, "condition")) {
[10:22:39.159]                       if (!is.null(pattern)) {
[10:22:39.159]                         computeRestarts <- base::computeRestarts
[10:22:39.159]                         grepl <- base::grepl
[10:22:39.159]                         restarts <- computeRestarts(cond)
[10:22:39.159]                         for (restart in restarts) {
[10:22:39.159]                           name <- restart$name
[10:22:39.159]                           if (is.null(name)) 
[10:22:39.159]                             next
[10:22:39.159]                           if (!grepl(pattern, name)) 
[10:22:39.159]                             next
[10:22:39.159]                           invokeRestart(restart)
[10:22:39.159]                           muffled <- TRUE
[10:22:39.159]                           break
[10:22:39.159]                         }
[10:22:39.159]                       }
[10:22:39.159]                     }
[10:22:39.159]                     invisible(muffled)
[10:22:39.159]                   }
[10:22:39.159]                   muffleCondition(cond)
[10:22:39.159]                 })
[10:22:39.159]             }))
[10:22:39.159]             future::FutureResult(value = ...future.value$value, 
[10:22:39.159]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:39.159]                   ...future.rng), globalenv = if (FALSE) 
[10:22:39.159]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:39.159]                     ...future.globalenv.names))
[10:22:39.159]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:39.159]         }, condition = base::local({
[10:22:39.159]             c <- base::c
[10:22:39.159]             inherits <- base::inherits
[10:22:39.159]             invokeRestart <- base::invokeRestart
[10:22:39.159]             length <- base::length
[10:22:39.159]             list <- base::list
[10:22:39.159]             seq.int <- base::seq.int
[10:22:39.159]             signalCondition <- base::signalCondition
[10:22:39.159]             sys.calls <- base::sys.calls
[10:22:39.159]             `[[` <- base::`[[`
[10:22:39.159]             `+` <- base::`+`
[10:22:39.159]             `<<-` <- base::`<<-`
[10:22:39.159]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:39.159]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:39.159]                   3L)]
[10:22:39.159]             }
[10:22:39.159]             function(cond) {
[10:22:39.159]                 is_error <- inherits(cond, "error")
[10:22:39.159]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:39.159]                   NULL)
[10:22:39.159]                 if (is_error) {
[10:22:39.159]                   sessionInformation <- function() {
[10:22:39.159]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:39.159]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:39.159]                       search = base::search(), system = base::Sys.info())
[10:22:39.159]                   }
[10:22:39.159]                   ...future.conditions[[length(...future.conditions) + 
[10:22:39.159]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:39.159]                     cond$call), session = sessionInformation(), 
[10:22:39.159]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:39.159]                   signalCondition(cond)
[10:22:39.159]                 }
[10:22:39.159]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:39.159]                 "immediateCondition"))) {
[10:22:39.159]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:39.159]                   ...future.conditions[[length(...future.conditions) + 
[10:22:39.159]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:39.159]                   if (TRUE && !signal) {
[10:22:39.159]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:39.159]                     {
[10:22:39.159]                       inherits <- base::inherits
[10:22:39.159]                       invokeRestart <- base::invokeRestart
[10:22:39.159]                       is.null <- base::is.null
[10:22:39.159]                       muffled <- FALSE
[10:22:39.159]                       if (inherits(cond, "message")) {
[10:22:39.159]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:39.159]                         if (muffled) 
[10:22:39.159]                           invokeRestart("muffleMessage")
[10:22:39.159]                       }
[10:22:39.159]                       else if (inherits(cond, "warning")) {
[10:22:39.159]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:39.159]                         if (muffled) 
[10:22:39.159]                           invokeRestart("muffleWarning")
[10:22:39.159]                       }
[10:22:39.159]                       else if (inherits(cond, "condition")) {
[10:22:39.159]                         if (!is.null(pattern)) {
[10:22:39.159]                           computeRestarts <- base::computeRestarts
[10:22:39.159]                           grepl <- base::grepl
[10:22:39.159]                           restarts <- computeRestarts(cond)
[10:22:39.159]                           for (restart in restarts) {
[10:22:39.159]                             name <- restart$name
[10:22:39.159]                             if (is.null(name)) 
[10:22:39.159]                               next
[10:22:39.159]                             if (!grepl(pattern, name)) 
[10:22:39.159]                               next
[10:22:39.159]                             invokeRestart(restart)
[10:22:39.159]                             muffled <- TRUE
[10:22:39.159]                             break
[10:22:39.159]                           }
[10:22:39.159]                         }
[10:22:39.159]                       }
[10:22:39.159]                       invisible(muffled)
[10:22:39.159]                     }
[10:22:39.159]                     muffleCondition(cond, pattern = "^muffle")
[10:22:39.159]                   }
[10:22:39.159]                 }
[10:22:39.159]                 else {
[10:22:39.159]                   if (TRUE) {
[10:22:39.159]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:39.159]                     {
[10:22:39.159]                       inherits <- base::inherits
[10:22:39.159]                       invokeRestart <- base::invokeRestart
[10:22:39.159]                       is.null <- base::is.null
[10:22:39.159]                       muffled <- FALSE
[10:22:39.159]                       if (inherits(cond, "message")) {
[10:22:39.159]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:39.159]                         if (muffled) 
[10:22:39.159]                           invokeRestart("muffleMessage")
[10:22:39.159]                       }
[10:22:39.159]                       else if (inherits(cond, "warning")) {
[10:22:39.159]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:39.159]                         if (muffled) 
[10:22:39.159]                           invokeRestart("muffleWarning")
[10:22:39.159]                       }
[10:22:39.159]                       else if (inherits(cond, "condition")) {
[10:22:39.159]                         if (!is.null(pattern)) {
[10:22:39.159]                           computeRestarts <- base::computeRestarts
[10:22:39.159]                           grepl <- base::grepl
[10:22:39.159]                           restarts <- computeRestarts(cond)
[10:22:39.159]                           for (restart in restarts) {
[10:22:39.159]                             name <- restart$name
[10:22:39.159]                             if (is.null(name)) 
[10:22:39.159]                               next
[10:22:39.159]                             if (!grepl(pattern, name)) 
[10:22:39.159]                               next
[10:22:39.159]                             invokeRestart(restart)
[10:22:39.159]                             muffled <- TRUE
[10:22:39.159]                             break
[10:22:39.159]                           }
[10:22:39.159]                         }
[10:22:39.159]                       }
[10:22:39.159]                       invisible(muffled)
[10:22:39.159]                     }
[10:22:39.159]                     muffleCondition(cond, pattern = "^muffle")
[10:22:39.159]                   }
[10:22:39.159]                 }
[10:22:39.159]             }
[10:22:39.159]         }))
[10:22:39.159]     }, error = function(ex) {
[10:22:39.159]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:39.159]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:39.159]                 ...future.rng), started = ...future.startTime, 
[10:22:39.159]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:39.159]             version = "1.8"), class = "FutureResult")
[10:22:39.159]     }, finally = {
[10:22:39.159]         if (!identical(...future.workdir, getwd())) 
[10:22:39.159]             setwd(...future.workdir)
[10:22:39.159]         {
[10:22:39.159]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:39.159]                 ...future.oldOptions$nwarnings <- NULL
[10:22:39.159]             }
[10:22:39.159]             base::options(...future.oldOptions)
[10:22:39.159]             if (.Platform$OS.type == "windows") {
[10:22:39.159]                 old_names <- names(...future.oldEnvVars)
[10:22:39.159]                 envs <- base::Sys.getenv()
[10:22:39.159]                 names <- names(envs)
[10:22:39.159]                 common <- intersect(names, old_names)
[10:22:39.159]                 added <- setdiff(names, old_names)
[10:22:39.159]                 removed <- setdiff(old_names, names)
[10:22:39.159]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:39.159]                   envs[common]]
[10:22:39.159]                 NAMES <- toupper(changed)
[10:22:39.159]                 args <- list()
[10:22:39.159]                 for (kk in seq_along(NAMES)) {
[10:22:39.159]                   name <- changed[[kk]]
[10:22:39.159]                   NAME <- NAMES[[kk]]
[10:22:39.159]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:39.159]                     next
[10:22:39.159]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:39.159]                 }
[10:22:39.159]                 NAMES <- toupper(added)
[10:22:39.159]                 for (kk in seq_along(NAMES)) {
[10:22:39.159]                   name <- added[[kk]]
[10:22:39.159]                   NAME <- NAMES[[kk]]
[10:22:39.159]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:39.159]                     next
[10:22:39.159]                   args[[name]] <- ""
[10:22:39.159]                 }
[10:22:39.159]                 NAMES <- toupper(removed)
[10:22:39.159]                 for (kk in seq_along(NAMES)) {
[10:22:39.159]                   name <- removed[[kk]]
[10:22:39.159]                   NAME <- NAMES[[kk]]
[10:22:39.159]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:39.159]                     next
[10:22:39.159]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:39.159]                 }
[10:22:39.159]                 if (length(args) > 0) 
[10:22:39.159]                   base::do.call(base::Sys.setenv, args = args)
[10:22:39.159]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:39.159]             }
[10:22:39.159]             else {
[10:22:39.159]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:39.159]             }
[10:22:39.159]             {
[10:22:39.159]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:39.159]                   0L) {
[10:22:39.159]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:39.159]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:39.159]                   base::options(opts)
[10:22:39.159]                 }
[10:22:39.159]                 {
[10:22:39.159]                   {
[10:22:39.159]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:39.159]                     NULL
[10:22:39.159]                   }
[10:22:39.159]                   options(future.plan = NULL)
[10:22:39.159]                   if (is.na(NA_character_)) 
[10:22:39.159]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:39.159]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:39.159]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:39.159]                     .init = FALSE)
[10:22:39.159]                 }
[10:22:39.159]             }
[10:22:39.159]         }
[10:22:39.159]     })
[10:22:39.159]     if (TRUE) {
[10:22:39.159]         base::sink(type = "output", split = FALSE)
[10:22:39.159]         if (TRUE) {
[10:22:39.159]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:39.159]         }
[10:22:39.159]         else {
[10:22:39.159]             ...future.result["stdout"] <- base::list(NULL)
[10:22:39.159]         }
[10:22:39.159]         base::close(...future.stdout)
[10:22:39.159]         ...future.stdout <- NULL
[10:22:39.159]     }
[10:22:39.159]     ...future.result$conditions <- ...future.conditions
[10:22:39.159]     ...future.result$finished <- base::Sys.time()
[10:22:39.159]     ...future.result
[10:22:39.159] }
[10:22:39.162] MultisessionFuture started
[10:22:39.162] - Launch lazy future ... done
[10:22:39.162] run() for ‘MultisessionFuture’ ... done
[10:22:39.204] receiveMessageFromWorker() for ClusterFuture ...
[10:22:39.204] - Validating connection of MultisessionFuture
[10:22:39.205] - received message: FutureResult
[10:22:39.205] - Received FutureResult
[10:22:39.205] - Erased future from FutureRegistry
[10:22:39.205] result() for ClusterFuture ...
[10:22:39.205] - result already collected: FutureResult
[10:22:39.205] result() for ClusterFuture ... done
[10:22:39.205] signalConditions() ...
[10:22:39.205]  - include = ‘immediateCondition’
[10:22:39.205]  - exclude = 
[10:22:39.205]  - resignal = FALSE
[10:22:39.205]  - Number of conditions: 1
[10:22:39.206] signalConditions() ... done
[10:22:39.206] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:39.206] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 2 ... DONE
- result = FALSE, recursive = Inf ...
[10:22:39.206] getGlobalsAndPackages() ...
[10:22:39.206] Searching for globals...
[10:22:39.207] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:22:39.207] Searching for globals ... DONE
[10:22:39.207] Resolving globals: FALSE
[10:22:39.208] 
[10:22:39.208] 
[10:22:39.208] getGlobalsAndPackages() ... DONE
[10:22:39.208] run() for ‘Future’ ...
[10:22:39.208] - state: ‘created’
[10:22:39.208] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:39.222] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:39.222] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:39.222]   - Field: ‘node’
[10:22:39.222]   - Field: ‘label’
[10:22:39.222]   - Field: ‘local’
[10:22:39.222]   - Field: ‘owner’
[10:22:39.222]   - Field: ‘envir’
[10:22:39.223]   - Field: ‘workers’
[10:22:39.223]   - Field: ‘packages’
[10:22:39.223]   - Field: ‘gc’
[10:22:39.223]   - Field: ‘conditions’
[10:22:39.223]   - Field: ‘persistent’
[10:22:39.223]   - Field: ‘expr’
[10:22:39.223]   - Field: ‘uuid’
[10:22:39.223]   - Field: ‘seed’
[10:22:39.223]   - Field: ‘version’
[10:22:39.223]   - Field: ‘result’
[10:22:39.223]   - Field: ‘asynchronous’
[10:22:39.223]   - Field: ‘calls’
[10:22:39.224]   - Field: ‘globals’
[10:22:39.224]   - Field: ‘stdout’
[10:22:39.224]   - Field: ‘earlySignal’
[10:22:39.224]   - Field: ‘lazy’
[10:22:39.224]   - Field: ‘state’
[10:22:39.224] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:39.224] - Launch lazy future ...
[10:22:39.224] Packages needed by the future expression (n = 0): <none>
[10:22:39.224] Packages needed by future strategies (n = 0): <none>
[10:22:39.225] {
[10:22:39.225]     {
[10:22:39.225]         {
[10:22:39.225]             ...future.startTime <- base::Sys.time()
[10:22:39.225]             {
[10:22:39.225]                 {
[10:22:39.225]                   {
[10:22:39.225]                     {
[10:22:39.225]                       base::local({
[10:22:39.225]                         has_future <- base::requireNamespace("future", 
[10:22:39.225]                           quietly = TRUE)
[10:22:39.225]                         if (has_future) {
[10:22:39.225]                           ns <- base::getNamespace("future")
[10:22:39.225]                           version <- ns[[".package"]][["version"]]
[10:22:39.225]                           if (is.null(version)) 
[10:22:39.225]                             version <- utils::packageVersion("future")
[10:22:39.225]                         }
[10:22:39.225]                         else {
[10:22:39.225]                           version <- NULL
[10:22:39.225]                         }
[10:22:39.225]                         if (!has_future || version < "1.8.0") {
[10:22:39.225]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:39.225]                             "", base::R.version$version.string), 
[10:22:39.225]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:39.225]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:39.225]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:39.225]                               "release", "version")], collapse = " "), 
[10:22:39.225]                             hostname = base::Sys.info()[["nodename"]])
[10:22:39.225]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:39.225]                             info)
[10:22:39.225]                           info <- base::paste(info, collapse = "; ")
[10:22:39.225]                           if (!has_future) {
[10:22:39.225]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:39.225]                               info)
[10:22:39.225]                           }
[10:22:39.225]                           else {
[10:22:39.225]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:39.225]                               info, version)
[10:22:39.225]                           }
[10:22:39.225]                           base::stop(msg)
[10:22:39.225]                         }
[10:22:39.225]                       })
[10:22:39.225]                     }
[10:22:39.225]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:39.225]                     base::options(mc.cores = 1L)
[10:22:39.225]                   }
[10:22:39.225]                   ...future.strategy.old <- future::plan("list")
[10:22:39.225]                   options(future.plan = NULL)
[10:22:39.225]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:39.225]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:39.225]                 }
[10:22:39.225]                 ...future.workdir <- getwd()
[10:22:39.225]             }
[10:22:39.225]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:39.225]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:39.225]         }
[10:22:39.225]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:39.225]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:39.225]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:39.225]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:39.225]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:39.225]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:39.225]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:39.225]             base::names(...future.oldOptions))
[10:22:39.225]     }
[10:22:39.225]     if (FALSE) {
[10:22:39.225]     }
[10:22:39.225]     else {
[10:22:39.225]         if (TRUE) {
[10:22:39.225]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:39.225]                 open = "w")
[10:22:39.225]         }
[10:22:39.225]         else {
[10:22:39.225]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:39.225]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:39.225]         }
[10:22:39.225]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:39.225]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:39.225]             base::sink(type = "output", split = FALSE)
[10:22:39.225]             base::close(...future.stdout)
[10:22:39.225]         }, add = TRUE)
[10:22:39.225]     }
[10:22:39.225]     ...future.frame <- base::sys.nframe()
[10:22:39.225]     ...future.conditions <- base::list()
[10:22:39.225]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:39.225]     if (FALSE) {
[10:22:39.225]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:39.225]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:39.225]     }
[10:22:39.225]     ...future.result <- base::tryCatch({
[10:22:39.225]         base::withCallingHandlers({
[10:22:39.225]             ...future.value <- base::withVisible(base::local({
[10:22:39.225]                 ...future.makeSendCondition <- base::local({
[10:22:39.225]                   sendCondition <- NULL
[10:22:39.225]                   function(frame = 1L) {
[10:22:39.225]                     if (is.function(sendCondition)) 
[10:22:39.225]                       return(sendCondition)
[10:22:39.225]                     ns <- getNamespace("parallel")
[10:22:39.225]                     if (exists("sendData", mode = "function", 
[10:22:39.225]                       envir = ns)) {
[10:22:39.225]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:39.225]                         envir = ns)
[10:22:39.225]                       envir <- sys.frame(frame)
[10:22:39.225]                       master <- NULL
[10:22:39.225]                       while (!identical(envir, .GlobalEnv) && 
[10:22:39.225]                         !identical(envir, emptyenv())) {
[10:22:39.225]                         if (exists("master", mode = "list", envir = envir, 
[10:22:39.225]                           inherits = FALSE)) {
[10:22:39.225]                           master <- get("master", mode = "list", 
[10:22:39.225]                             envir = envir, inherits = FALSE)
[10:22:39.225]                           if (inherits(master, c("SOCKnode", 
[10:22:39.225]                             "SOCK0node"))) {
[10:22:39.225]                             sendCondition <<- function(cond) {
[10:22:39.225]                               data <- list(type = "VALUE", value = cond, 
[10:22:39.225]                                 success = TRUE)
[10:22:39.225]                               parallel_sendData(master, data)
[10:22:39.225]                             }
[10:22:39.225]                             return(sendCondition)
[10:22:39.225]                           }
[10:22:39.225]                         }
[10:22:39.225]                         frame <- frame + 1L
[10:22:39.225]                         envir <- sys.frame(frame)
[10:22:39.225]                       }
[10:22:39.225]                     }
[10:22:39.225]                     sendCondition <<- function(cond) NULL
[10:22:39.225]                   }
[10:22:39.225]                 })
[10:22:39.225]                 withCallingHandlers({
[10:22:39.225]                   {
[10:22:39.225]                     Sys.sleep(0.5)
[10:22:39.225]                     list(a = 1, b = 42L)
[10:22:39.225]                   }
[10:22:39.225]                 }, immediateCondition = function(cond) {
[10:22:39.225]                   sendCondition <- ...future.makeSendCondition()
[10:22:39.225]                   sendCondition(cond)
[10:22:39.225]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:39.225]                   {
[10:22:39.225]                     inherits <- base::inherits
[10:22:39.225]                     invokeRestart <- base::invokeRestart
[10:22:39.225]                     is.null <- base::is.null
[10:22:39.225]                     muffled <- FALSE
[10:22:39.225]                     if (inherits(cond, "message")) {
[10:22:39.225]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:39.225]                       if (muffled) 
[10:22:39.225]                         invokeRestart("muffleMessage")
[10:22:39.225]                     }
[10:22:39.225]                     else if (inherits(cond, "warning")) {
[10:22:39.225]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:39.225]                       if (muffled) 
[10:22:39.225]                         invokeRestart("muffleWarning")
[10:22:39.225]                     }
[10:22:39.225]                     else if (inherits(cond, "condition")) {
[10:22:39.225]                       if (!is.null(pattern)) {
[10:22:39.225]                         computeRestarts <- base::computeRestarts
[10:22:39.225]                         grepl <- base::grepl
[10:22:39.225]                         restarts <- computeRestarts(cond)
[10:22:39.225]                         for (restart in restarts) {
[10:22:39.225]                           name <- restart$name
[10:22:39.225]                           if (is.null(name)) 
[10:22:39.225]                             next
[10:22:39.225]                           if (!grepl(pattern, name)) 
[10:22:39.225]                             next
[10:22:39.225]                           invokeRestart(restart)
[10:22:39.225]                           muffled <- TRUE
[10:22:39.225]                           break
[10:22:39.225]                         }
[10:22:39.225]                       }
[10:22:39.225]                     }
[10:22:39.225]                     invisible(muffled)
[10:22:39.225]                   }
[10:22:39.225]                   muffleCondition(cond)
[10:22:39.225]                 })
[10:22:39.225]             }))
[10:22:39.225]             future::FutureResult(value = ...future.value$value, 
[10:22:39.225]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:39.225]                   ...future.rng), globalenv = if (FALSE) 
[10:22:39.225]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:39.225]                     ...future.globalenv.names))
[10:22:39.225]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:39.225]         }, condition = base::local({
[10:22:39.225]             c <- base::c
[10:22:39.225]             inherits <- base::inherits
[10:22:39.225]             invokeRestart <- base::invokeRestart
[10:22:39.225]             length <- base::length
[10:22:39.225]             list <- base::list
[10:22:39.225]             seq.int <- base::seq.int
[10:22:39.225]             signalCondition <- base::signalCondition
[10:22:39.225]             sys.calls <- base::sys.calls
[10:22:39.225]             `[[` <- base::`[[`
[10:22:39.225]             `+` <- base::`+`
[10:22:39.225]             `<<-` <- base::`<<-`
[10:22:39.225]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:39.225]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:39.225]                   3L)]
[10:22:39.225]             }
[10:22:39.225]             function(cond) {
[10:22:39.225]                 is_error <- inherits(cond, "error")
[10:22:39.225]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:39.225]                   NULL)
[10:22:39.225]                 if (is_error) {
[10:22:39.225]                   sessionInformation <- function() {
[10:22:39.225]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:39.225]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:39.225]                       search = base::search(), system = base::Sys.info())
[10:22:39.225]                   }
[10:22:39.225]                   ...future.conditions[[length(...future.conditions) + 
[10:22:39.225]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:39.225]                     cond$call), session = sessionInformation(), 
[10:22:39.225]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:39.225]                   signalCondition(cond)
[10:22:39.225]                 }
[10:22:39.225]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:39.225]                 "immediateCondition"))) {
[10:22:39.225]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:39.225]                   ...future.conditions[[length(...future.conditions) + 
[10:22:39.225]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:39.225]                   if (TRUE && !signal) {
[10:22:39.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:39.225]                     {
[10:22:39.225]                       inherits <- base::inherits
[10:22:39.225]                       invokeRestart <- base::invokeRestart
[10:22:39.225]                       is.null <- base::is.null
[10:22:39.225]                       muffled <- FALSE
[10:22:39.225]                       if (inherits(cond, "message")) {
[10:22:39.225]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:39.225]                         if (muffled) 
[10:22:39.225]                           invokeRestart("muffleMessage")
[10:22:39.225]                       }
[10:22:39.225]                       else if (inherits(cond, "warning")) {
[10:22:39.225]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:39.225]                         if (muffled) 
[10:22:39.225]                           invokeRestart("muffleWarning")
[10:22:39.225]                       }
[10:22:39.225]                       else if (inherits(cond, "condition")) {
[10:22:39.225]                         if (!is.null(pattern)) {
[10:22:39.225]                           computeRestarts <- base::computeRestarts
[10:22:39.225]                           grepl <- base::grepl
[10:22:39.225]                           restarts <- computeRestarts(cond)
[10:22:39.225]                           for (restart in restarts) {
[10:22:39.225]                             name <- restart$name
[10:22:39.225]                             if (is.null(name)) 
[10:22:39.225]                               next
[10:22:39.225]                             if (!grepl(pattern, name)) 
[10:22:39.225]                               next
[10:22:39.225]                             invokeRestart(restart)
[10:22:39.225]                             muffled <- TRUE
[10:22:39.225]                             break
[10:22:39.225]                           }
[10:22:39.225]                         }
[10:22:39.225]                       }
[10:22:39.225]                       invisible(muffled)
[10:22:39.225]                     }
[10:22:39.225]                     muffleCondition(cond, pattern = "^muffle")
[10:22:39.225]                   }
[10:22:39.225]                 }
[10:22:39.225]                 else {
[10:22:39.225]                   if (TRUE) {
[10:22:39.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:39.225]                     {
[10:22:39.225]                       inherits <- base::inherits
[10:22:39.225]                       invokeRestart <- base::invokeRestart
[10:22:39.225]                       is.null <- base::is.null
[10:22:39.225]                       muffled <- FALSE
[10:22:39.225]                       if (inherits(cond, "message")) {
[10:22:39.225]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:39.225]                         if (muffled) 
[10:22:39.225]                           invokeRestart("muffleMessage")
[10:22:39.225]                       }
[10:22:39.225]                       else if (inherits(cond, "warning")) {
[10:22:39.225]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:39.225]                         if (muffled) 
[10:22:39.225]                           invokeRestart("muffleWarning")
[10:22:39.225]                       }
[10:22:39.225]                       else if (inherits(cond, "condition")) {
[10:22:39.225]                         if (!is.null(pattern)) {
[10:22:39.225]                           computeRestarts <- base::computeRestarts
[10:22:39.225]                           grepl <- base::grepl
[10:22:39.225]                           restarts <- computeRestarts(cond)
[10:22:39.225]                           for (restart in restarts) {
[10:22:39.225]                             name <- restart$name
[10:22:39.225]                             if (is.null(name)) 
[10:22:39.225]                               next
[10:22:39.225]                             if (!grepl(pattern, name)) 
[10:22:39.225]                               next
[10:22:39.225]                             invokeRestart(restart)
[10:22:39.225]                             muffled <- TRUE
[10:22:39.225]                             break
[10:22:39.225]                           }
[10:22:39.225]                         }
[10:22:39.225]                       }
[10:22:39.225]                       invisible(muffled)
[10:22:39.225]                     }
[10:22:39.225]                     muffleCondition(cond, pattern = "^muffle")
[10:22:39.225]                   }
[10:22:39.225]                 }
[10:22:39.225]             }
[10:22:39.225]         }))
[10:22:39.225]     }, error = function(ex) {
[10:22:39.225]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:39.225]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:39.225]                 ...future.rng), started = ...future.startTime, 
[10:22:39.225]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:39.225]             version = "1.8"), class = "FutureResult")
[10:22:39.225]     }, finally = {
[10:22:39.225]         if (!identical(...future.workdir, getwd())) 
[10:22:39.225]             setwd(...future.workdir)
[10:22:39.225]         {
[10:22:39.225]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:39.225]                 ...future.oldOptions$nwarnings <- NULL
[10:22:39.225]             }
[10:22:39.225]             base::options(...future.oldOptions)
[10:22:39.225]             if (.Platform$OS.type == "windows") {
[10:22:39.225]                 old_names <- names(...future.oldEnvVars)
[10:22:39.225]                 envs <- base::Sys.getenv()
[10:22:39.225]                 names <- names(envs)
[10:22:39.225]                 common <- intersect(names, old_names)
[10:22:39.225]                 added <- setdiff(names, old_names)
[10:22:39.225]                 removed <- setdiff(old_names, names)
[10:22:39.225]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:39.225]                   envs[common]]
[10:22:39.225]                 NAMES <- toupper(changed)
[10:22:39.225]                 args <- list()
[10:22:39.225]                 for (kk in seq_along(NAMES)) {
[10:22:39.225]                   name <- changed[[kk]]
[10:22:39.225]                   NAME <- NAMES[[kk]]
[10:22:39.225]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:39.225]                     next
[10:22:39.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:39.225]                 }
[10:22:39.225]                 NAMES <- toupper(added)
[10:22:39.225]                 for (kk in seq_along(NAMES)) {
[10:22:39.225]                   name <- added[[kk]]
[10:22:39.225]                   NAME <- NAMES[[kk]]
[10:22:39.225]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:39.225]                     next
[10:22:39.225]                   args[[name]] <- ""
[10:22:39.225]                 }
[10:22:39.225]                 NAMES <- toupper(removed)
[10:22:39.225]                 for (kk in seq_along(NAMES)) {
[10:22:39.225]                   name <- removed[[kk]]
[10:22:39.225]                   NAME <- NAMES[[kk]]
[10:22:39.225]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:39.225]                     next
[10:22:39.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:39.225]                 }
[10:22:39.225]                 if (length(args) > 0) 
[10:22:39.225]                   base::do.call(base::Sys.setenv, args = args)
[10:22:39.225]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:39.225]             }
[10:22:39.225]             else {
[10:22:39.225]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:39.225]             }
[10:22:39.225]             {
[10:22:39.225]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:39.225]                   0L) {
[10:22:39.225]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:39.225]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:39.225]                   base::options(opts)
[10:22:39.225]                 }
[10:22:39.225]                 {
[10:22:39.225]                   {
[10:22:39.225]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:39.225]                     NULL
[10:22:39.225]                   }
[10:22:39.225]                   options(future.plan = NULL)
[10:22:39.225]                   if (is.na(NA_character_)) 
[10:22:39.225]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:39.225]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:39.225]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:39.225]                     .init = FALSE)
[10:22:39.225]                 }
[10:22:39.225]             }
[10:22:39.225]         }
[10:22:39.225]     })
[10:22:39.225]     if (TRUE) {
[10:22:39.225]         base::sink(type = "output", split = FALSE)
[10:22:39.225]         if (TRUE) {
[10:22:39.225]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:39.225]         }
[10:22:39.225]         else {
[10:22:39.225]             ...future.result["stdout"] <- base::list(NULL)
[10:22:39.225]         }
[10:22:39.225]         base::close(...future.stdout)
[10:22:39.225]         ...future.stdout <- NULL
[10:22:39.225]     }
[10:22:39.225]     ...future.result$conditions <- ...future.conditions
[10:22:39.225]     ...future.result$finished <- base::Sys.time()
[10:22:39.225]     ...future.result
[10:22:39.225] }
[10:22:39.228] MultisessionFuture started
[10:22:39.228] - Launch lazy future ... done
[10:22:39.228] run() for ‘MultisessionFuture’ ... done
[10:22:39.771] receiveMessageFromWorker() for ClusterFuture ...
[10:22:39.771] - Validating connection of MultisessionFuture
[10:22:39.771] - received message: FutureResult
[10:22:39.772] - Received FutureResult
[10:22:39.772] - Erased future from FutureRegistry
[10:22:39.772] result() for ClusterFuture ...
[10:22:39.772] - result already collected: FutureResult
[10:22:39.772] result() for ClusterFuture ... done
[10:22:39.772] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:39.772] A MultisessionFuture was resolved (result was not collected)
[10:22:39.772] getGlobalsAndPackages() ...
[10:22:39.772] Searching for globals...
[10:22:39.773] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:22:39.774] Searching for globals ... DONE
[10:22:39.774] Resolving globals: FALSE
[10:22:39.774] 
[10:22:39.774] 
[10:22:39.774] getGlobalsAndPackages() ... DONE
[10:22:39.774] run() for ‘Future’ ...
[10:22:39.775] - state: ‘created’
[10:22:39.775] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:39.788] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:39.789] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:39.789]   - Field: ‘node’
[10:22:39.789]   - Field: ‘label’
[10:22:39.789]   - Field: ‘local’
[10:22:39.789]   - Field: ‘owner’
[10:22:39.789]   - Field: ‘envir’
[10:22:39.789]   - Field: ‘workers’
[10:22:39.789]   - Field: ‘packages’
[10:22:39.789]   - Field: ‘gc’
[10:22:39.789]   - Field: ‘conditions’
[10:22:39.789]   - Field: ‘persistent’
[10:22:39.790]   - Field: ‘expr’
[10:22:39.790]   - Field: ‘uuid’
[10:22:39.790]   - Field: ‘seed’
[10:22:39.790]   - Field: ‘version’
[10:22:39.790]   - Field: ‘result’
[10:22:39.790]   - Field: ‘asynchronous’
[10:22:39.790]   - Field: ‘calls’
[10:22:39.790]   - Field: ‘globals’
[10:22:39.790]   - Field: ‘stdout’
[10:22:39.790]   - Field: ‘earlySignal’
[10:22:39.790]   - Field: ‘lazy’
[10:22:39.790]   - Field: ‘state’
[10:22:39.791] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:39.791] - Launch lazy future ...
[10:22:39.791] Packages needed by the future expression (n = 0): <none>
[10:22:39.791] Packages needed by future strategies (n = 0): <none>
[10:22:39.791] {
[10:22:39.791]     {
[10:22:39.791]         {
[10:22:39.791]             ...future.startTime <- base::Sys.time()
[10:22:39.791]             {
[10:22:39.791]                 {
[10:22:39.791]                   {
[10:22:39.791]                     {
[10:22:39.791]                       base::local({
[10:22:39.791]                         has_future <- base::requireNamespace("future", 
[10:22:39.791]                           quietly = TRUE)
[10:22:39.791]                         if (has_future) {
[10:22:39.791]                           ns <- base::getNamespace("future")
[10:22:39.791]                           version <- ns[[".package"]][["version"]]
[10:22:39.791]                           if (is.null(version)) 
[10:22:39.791]                             version <- utils::packageVersion("future")
[10:22:39.791]                         }
[10:22:39.791]                         else {
[10:22:39.791]                           version <- NULL
[10:22:39.791]                         }
[10:22:39.791]                         if (!has_future || version < "1.8.0") {
[10:22:39.791]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:39.791]                             "", base::R.version$version.string), 
[10:22:39.791]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:39.791]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:39.791]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:39.791]                               "release", "version")], collapse = " "), 
[10:22:39.791]                             hostname = base::Sys.info()[["nodename"]])
[10:22:39.791]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:39.791]                             info)
[10:22:39.791]                           info <- base::paste(info, collapse = "; ")
[10:22:39.791]                           if (!has_future) {
[10:22:39.791]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:39.791]                               info)
[10:22:39.791]                           }
[10:22:39.791]                           else {
[10:22:39.791]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:39.791]                               info, version)
[10:22:39.791]                           }
[10:22:39.791]                           base::stop(msg)
[10:22:39.791]                         }
[10:22:39.791]                       })
[10:22:39.791]                     }
[10:22:39.791]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:39.791]                     base::options(mc.cores = 1L)
[10:22:39.791]                   }
[10:22:39.791]                   ...future.strategy.old <- future::plan("list")
[10:22:39.791]                   options(future.plan = NULL)
[10:22:39.791]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:39.791]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:39.791]                 }
[10:22:39.791]                 ...future.workdir <- getwd()
[10:22:39.791]             }
[10:22:39.791]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:39.791]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:39.791]         }
[10:22:39.791]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:39.791]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:39.791]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:39.791]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:39.791]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:39.791]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:39.791]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:39.791]             base::names(...future.oldOptions))
[10:22:39.791]     }
[10:22:39.791]     if (FALSE) {
[10:22:39.791]     }
[10:22:39.791]     else {
[10:22:39.791]         if (TRUE) {
[10:22:39.791]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:39.791]                 open = "w")
[10:22:39.791]         }
[10:22:39.791]         else {
[10:22:39.791]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:39.791]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:39.791]         }
[10:22:39.791]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:39.791]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:39.791]             base::sink(type = "output", split = FALSE)
[10:22:39.791]             base::close(...future.stdout)
[10:22:39.791]         }, add = TRUE)
[10:22:39.791]     }
[10:22:39.791]     ...future.frame <- base::sys.nframe()
[10:22:39.791]     ...future.conditions <- base::list()
[10:22:39.791]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:39.791]     if (FALSE) {
[10:22:39.791]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:39.791]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:39.791]     }
[10:22:39.791]     ...future.result <- base::tryCatch({
[10:22:39.791]         base::withCallingHandlers({
[10:22:39.791]             ...future.value <- base::withVisible(base::local({
[10:22:39.791]                 ...future.makeSendCondition <- base::local({
[10:22:39.791]                   sendCondition <- NULL
[10:22:39.791]                   function(frame = 1L) {
[10:22:39.791]                     if (is.function(sendCondition)) 
[10:22:39.791]                       return(sendCondition)
[10:22:39.791]                     ns <- getNamespace("parallel")
[10:22:39.791]                     if (exists("sendData", mode = "function", 
[10:22:39.791]                       envir = ns)) {
[10:22:39.791]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:39.791]                         envir = ns)
[10:22:39.791]                       envir <- sys.frame(frame)
[10:22:39.791]                       master <- NULL
[10:22:39.791]                       while (!identical(envir, .GlobalEnv) && 
[10:22:39.791]                         !identical(envir, emptyenv())) {
[10:22:39.791]                         if (exists("master", mode = "list", envir = envir, 
[10:22:39.791]                           inherits = FALSE)) {
[10:22:39.791]                           master <- get("master", mode = "list", 
[10:22:39.791]                             envir = envir, inherits = FALSE)
[10:22:39.791]                           if (inherits(master, c("SOCKnode", 
[10:22:39.791]                             "SOCK0node"))) {
[10:22:39.791]                             sendCondition <<- function(cond) {
[10:22:39.791]                               data <- list(type = "VALUE", value = cond, 
[10:22:39.791]                                 success = TRUE)
[10:22:39.791]                               parallel_sendData(master, data)
[10:22:39.791]                             }
[10:22:39.791]                             return(sendCondition)
[10:22:39.791]                           }
[10:22:39.791]                         }
[10:22:39.791]                         frame <- frame + 1L
[10:22:39.791]                         envir <- sys.frame(frame)
[10:22:39.791]                       }
[10:22:39.791]                     }
[10:22:39.791]                     sendCondition <<- function(cond) NULL
[10:22:39.791]                   }
[10:22:39.791]                 })
[10:22:39.791]                 withCallingHandlers({
[10:22:39.791]                   {
[10:22:39.791]                     Sys.sleep(0.5)
[10:22:39.791]                     list(a = 1, b = 42L)
[10:22:39.791]                   }
[10:22:39.791]                 }, immediateCondition = function(cond) {
[10:22:39.791]                   sendCondition <- ...future.makeSendCondition()
[10:22:39.791]                   sendCondition(cond)
[10:22:39.791]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:39.791]                   {
[10:22:39.791]                     inherits <- base::inherits
[10:22:39.791]                     invokeRestart <- base::invokeRestart
[10:22:39.791]                     is.null <- base::is.null
[10:22:39.791]                     muffled <- FALSE
[10:22:39.791]                     if (inherits(cond, "message")) {
[10:22:39.791]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:39.791]                       if (muffled) 
[10:22:39.791]                         invokeRestart("muffleMessage")
[10:22:39.791]                     }
[10:22:39.791]                     else if (inherits(cond, "warning")) {
[10:22:39.791]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:39.791]                       if (muffled) 
[10:22:39.791]                         invokeRestart("muffleWarning")
[10:22:39.791]                     }
[10:22:39.791]                     else if (inherits(cond, "condition")) {
[10:22:39.791]                       if (!is.null(pattern)) {
[10:22:39.791]                         computeRestarts <- base::computeRestarts
[10:22:39.791]                         grepl <- base::grepl
[10:22:39.791]                         restarts <- computeRestarts(cond)
[10:22:39.791]                         for (restart in restarts) {
[10:22:39.791]                           name <- restart$name
[10:22:39.791]                           if (is.null(name)) 
[10:22:39.791]                             next
[10:22:39.791]                           if (!grepl(pattern, name)) 
[10:22:39.791]                             next
[10:22:39.791]                           invokeRestart(restart)
[10:22:39.791]                           muffled <- TRUE
[10:22:39.791]                           break
[10:22:39.791]                         }
[10:22:39.791]                       }
[10:22:39.791]                     }
[10:22:39.791]                     invisible(muffled)
[10:22:39.791]                   }
[10:22:39.791]                   muffleCondition(cond)
[10:22:39.791]                 })
[10:22:39.791]             }))
[10:22:39.791]             future::FutureResult(value = ...future.value$value, 
[10:22:39.791]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:39.791]                   ...future.rng), globalenv = if (FALSE) 
[10:22:39.791]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:39.791]                     ...future.globalenv.names))
[10:22:39.791]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:39.791]         }, condition = base::local({
[10:22:39.791]             c <- base::c
[10:22:39.791]             inherits <- base::inherits
[10:22:39.791]             invokeRestart <- base::invokeRestart
[10:22:39.791]             length <- base::length
[10:22:39.791]             list <- base::list
[10:22:39.791]             seq.int <- base::seq.int
[10:22:39.791]             signalCondition <- base::signalCondition
[10:22:39.791]             sys.calls <- base::sys.calls
[10:22:39.791]             `[[` <- base::`[[`
[10:22:39.791]             `+` <- base::`+`
[10:22:39.791]             `<<-` <- base::`<<-`
[10:22:39.791]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:39.791]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:39.791]                   3L)]
[10:22:39.791]             }
[10:22:39.791]             function(cond) {
[10:22:39.791]                 is_error <- inherits(cond, "error")
[10:22:39.791]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:39.791]                   NULL)
[10:22:39.791]                 if (is_error) {
[10:22:39.791]                   sessionInformation <- function() {
[10:22:39.791]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:39.791]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:39.791]                       search = base::search(), system = base::Sys.info())
[10:22:39.791]                   }
[10:22:39.791]                   ...future.conditions[[length(...future.conditions) + 
[10:22:39.791]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:39.791]                     cond$call), session = sessionInformation(), 
[10:22:39.791]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:39.791]                   signalCondition(cond)
[10:22:39.791]                 }
[10:22:39.791]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:39.791]                 "immediateCondition"))) {
[10:22:39.791]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:39.791]                   ...future.conditions[[length(...future.conditions) + 
[10:22:39.791]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:39.791]                   if (TRUE && !signal) {
[10:22:39.791]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:39.791]                     {
[10:22:39.791]                       inherits <- base::inherits
[10:22:39.791]                       invokeRestart <- base::invokeRestart
[10:22:39.791]                       is.null <- base::is.null
[10:22:39.791]                       muffled <- FALSE
[10:22:39.791]                       if (inherits(cond, "message")) {
[10:22:39.791]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:39.791]                         if (muffled) 
[10:22:39.791]                           invokeRestart("muffleMessage")
[10:22:39.791]                       }
[10:22:39.791]                       else if (inherits(cond, "warning")) {
[10:22:39.791]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:39.791]                         if (muffled) 
[10:22:39.791]                           invokeRestart("muffleWarning")
[10:22:39.791]                       }
[10:22:39.791]                       else if (inherits(cond, "condition")) {
[10:22:39.791]                         if (!is.null(pattern)) {
[10:22:39.791]                           computeRestarts <- base::computeRestarts
[10:22:39.791]                           grepl <- base::grepl
[10:22:39.791]                           restarts <- computeRestarts(cond)
[10:22:39.791]                           for (restart in restarts) {
[10:22:39.791]                             name <- restart$name
[10:22:39.791]                             if (is.null(name)) 
[10:22:39.791]                               next
[10:22:39.791]                             if (!grepl(pattern, name)) 
[10:22:39.791]                               next
[10:22:39.791]                             invokeRestart(restart)
[10:22:39.791]                             muffled <- TRUE
[10:22:39.791]                             break
[10:22:39.791]                           }
[10:22:39.791]                         }
[10:22:39.791]                       }
[10:22:39.791]                       invisible(muffled)
[10:22:39.791]                     }
[10:22:39.791]                     muffleCondition(cond, pattern = "^muffle")
[10:22:39.791]                   }
[10:22:39.791]                 }
[10:22:39.791]                 else {
[10:22:39.791]                   if (TRUE) {
[10:22:39.791]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:39.791]                     {
[10:22:39.791]                       inherits <- base::inherits
[10:22:39.791]                       invokeRestart <- base::invokeRestart
[10:22:39.791]                       is.null <- base::is.null
[10:22:39.791]                       muffled <- FALSE
[10:22:39.791]                       if (inherits(cond, "message")) {
[10:22:39.791]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:39.791]                         if (muffled) 
[10:22:39.791]                           invokeRestart("muffleMessage")
[10:22:39.791]                       }
[10:22:39.791]                       else if (inherits(cond, "warning")) {
[10:22:39.791]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:39.791]                         if (muffled) 
[10:22:39.791]                           invokeRestart("muffleWarning")
[10:22:39.791]                       }
[10:22:39.791]                       else if (inherits(cond, "condition")) {
[10:22:39.791]                         if (!is.null(pattern)) {
[10:22:39.791]                           computeRestarts <- base::computeRestarts
[10:22:39.791]                           grepl <- base::grepl
[10:22:39.791]                           restarts <- computeRestarts(cond)
[10:22:39.791]                           for (restart in restarts) {
[10:22:39.791]                             name <- restart$name
[10:22:39.791]                             if (is.null(name)) 
[10:22:39.791]                               next
[10:22:39.791]                             if (!grepl(pattern, name)) 
[10:22:39.791]                               next
[10:22:39.791]                             invokeRestart(restart)
[10:22:39.791]                             muffled <- TRUE
[10:22:39.791]                             break
[10:22:39.791]                           }
[10:22:39.791]                         }
[10:22:39.791]                       }
[10:22:39.791]                       invisible(muffled)
[10:22:39.791]                     }
[10:22:39.791]                     muffleCondition(cond, pattern = "^muffle")
[10:22:39.791]                   }
[10:22:39.791]                 }
[10:22:39.791]             }
[10:22:39.791]         }))
[10:22:39.791]     }, error = function(ex) {
[10:22:39.791]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:39.791]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:39.791]                 ...future.rng), started = ...future.startTime, 
[10:22:39.791]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:39.791]             version = "1.8"), class = "FutureResult")
[10:22:39.791]     }, finally = {
[10:22:39.791]         if (!identical(...future.workdir, getwd())) 
[10:22:39.791]             setwd(...future.workdir)
[10:22:39.791]         {
[10:22:39.791]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:39.791]                 ...future.oldOptions$nwarnings <- NULL
[10:22:39.791]             }
[10:22:39.791]             base::options(...future.oldOptions)
[10:22:39.791]             if (.Platform$OS.type == "windows") {
[10:22:39.791]                 old_names <- names(...future.oldEnvVars)
[10:22:39.791]                 envs <- base::Sys.getenv()
[10:22:39.791]                 names <- names(envs)
[10:22:39.791]                 common <- intersect(names, old_names)
[10:22:39.791]                 added <- setdiff(names, old_names)
[10:22:39.791]                 removed <- setdiff(old_names, names)
[10:22:39.791]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:39.791]                   envs[common]]
[10:22:39.791]                 NAMES <- toupper(changed)
[10:22:39.791]                 args <- list()
[10:22:39.791]                 for (kk in seq_along(NAMES)) {
[10:22:39.791]                   name <- changed[[kk]]
[10:22:39.791]                   NAME <- NAMES[[kk]]
[10:22:39.791]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:39.791]                     next
[10:22:39.791]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:39.791]                 }
[10:22:39.791]                 NAMES <- toupper(added)
[10:22:39.791]                 for (kk in seq_along(NAMES)) {
[10:22:39.791]                   name <- added[[kk]]
[10:22:39.791]                   NAME <- NAMES[[kk]]
[10:22:39.791]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:39.791]                     next
[10:22:39.791]                   args[[name]] <- ""
[10:22:39.791]                 }
[10:22:39.791]                 NAMES <- toupper(removed)
[10:22:39.791]                 for (kk in seq_along(NAMES)) {
[10:22:39.791]                   name <- removed[[kk]]
[10:22:39.791]                   NAME <- NAMES[[kk]]
[10:22:39.791]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:39.791]                     next
[10:22:39.791]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:39.791]                 }
[10:22:39.791]                 if (length(args) > 0) 
[10:22:39.791]                   base::do.call(base::Sys.setenv, args = args)
[10:22:39.791]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:39.791]             }
[10:22:39.791]             else {
[10:22:39.791]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:39.791]             }
[10:22:39.791]             {
[10:22:39.791]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:39.791]                   0L) {
[10:22:39.791]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:39.791]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:39.791]                   base::options(opts)
[10:22:39.791]                 }
[10:22:39.791]                 {
[10:22:39.791]                   {
[10:22:39.791]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:39.791]                     NULL
[10:22:39.791]                   }
[10:22:39.791]                   options(future.plan = NULL)
[10:22:39.791]                   if (is.na(NA_character_)) 
[10:22:39.791]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:39.791]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:39.791]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:39.791]                     .init = FALSE)
[10:22:39.791]                 }
[10:22:39.791]             }
[10:22:39.791]         }
[10:22:39.791]     })
[10:22:39.791]     if (TRUE) {
[10:22:39.791]         base::sink(type = "output", split = FALSE)
[10:22:39.791]         if (TRUE) {
[10:22:39.791]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:39.791]         }
[10:22:39.791]         else {
[10:22:39.791]             ...future.result["stdout"] <- base::list(NULL)
[10:22:39.791]         }
[10:22:39.791]         base::close(...future.stdout)
[10:22:39.791]         ...future.stdout <- NULL
[10:22:39.791]     }
[10:22:39.791]     ...future.result$conditions <- ...future.conditions
[10:22:39.791]     ...future.result$finished <- base::Sys.time()
[10:22:39.791]     ...future.result
[10:22:39.791] }
[10:22:39.794] MultisessionFuture started
[10:22:39.795] - Launch lazy future ... done
[10:22:39.795] run() for ‘MultisessionFuture’ ... done
[10:22:40.338] receiveMessageFromWorker() for ClusterFuture ...
[10:22:40.338] - Validating connection of MultisessionFuture
[10:22:40.339] - received message: FutureResult
[10:22:40.339] - Received FutureResult
[10:22:40.339] - Erased future from FutureRegistry
[10:22:40.339] result() for ClusterFuture ...
[10:22:40.339] - result already collected: FutureResult
[10:22:40.339] result() for ClusterFuture ... done
[10:22:40.339] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:40.339] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[10:22:40.340] getGlobalsAndPackages() ...
[10:22:40.340] Searching for globals...
[10:22:40.340] - globals found: [2] ‘list’, ‘stop’
[10:22:40.340] Searching for globals ... DONE
[10:22:40.341] Resolving globals: FALSE
[10:22:40.341] 
[10:22:40.341] 
[10:22:40.341] getGlobalsAndPackages() ... DONE
[10:22:40.341] run() for ‘Future’ ...
[10:22:40.341] - state: ‘created’
[10:22:40.341] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:40.355] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:40.355] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:40.355]   - Field: ‘node’
[10:22:40.356]   - Field: ‘label’
[10:22:40.356]   - Field: ‘local’
[10:22:40.356]   - Field: ‘owner’
[10:22:40.356]   - Field: ‘envir’
[10:22:40.356]   - Field: ‘workers’
[10:22:40.356]   - Field: ‘packages’
[10:22:40.356]   - Field: ‘gc’
[10:22:40.356]   - Field: ‘conditions’
[10:22:40.356]   - Field: ‘persistent’
[10:22:40.356]   - Field: ‘expr’
[10:22:40.356]   - Field: ‘uuid’
[10:22:40.359]   - Field: ‘seed’
[10:22:40.359]   - Field: ‘version’
[10:22:40.359]   - Field: ‘result’
[10:22:40.359]   - Field: ‘asynchronous’
[10:22:40.359]   - Field: ‘calls’
[10:22:40.359]   - Field: ‘globals’
[10:22:40.359]   - Field: ‘stdout’
[10:22:40.359]   - Field: ‘earlySignal’
[10:22:40.359]   - Field: ‘lazy’
[10:22:40.359]   - Field: ‘state’
[10:22:40.359] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:40.360] - Launch lazy future ...
[10:22:40.360] Packages needed by the future expression (n = 0): <none>
[10:22:40.360] Packages needed by future strategies (n = 0): <none>
[10:22:40.360] {
[10:22:40.360]     {
[10:22:40.360]         {
[10:22:40.360]             ...future.startTime <- base::Sys.time()
[10:22:40.360]             {
[10:22:40.360]                 {
[10:22:40.360]                   {
[10:22:40.360]                     {
[10:22:40.360]                       base::local({
[10:22:40.360]                         has_future <- base::requireNamespace("future", 
[10:22:40.360]                           quietly = TRUE)
[10:22:40.360]                         if (has_future) {
[10:22:40.360]                           ns <- base::getNamespace("future")
[10:22:40.360]                           version <- ns[[".package"]][["version"]]
[10:22:40.360]                           if (is.null(version)) 
[10:22:40.360]                             version <- utils::packageVersion("future")
[10:22:40.360]                         }
[10:22:40.360]                         else {
[10:22:40.360]                           version <- NULL
[10:22:40.360]                         }
[10:22:40.360]                         if (!has_future || version < "1.8.0") {
[10:22:40.360]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:40.360]                             "", base::R.version$version.string), 
[10:22:40.360]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:40.360]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:40.360]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:40.360]                               "release", "version")], collapse = " "), 
[10:22:40.360]                             hostname = base::Sys.info()[["nodename"]])
[10:22:40.360]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:40.360]                             info)
[10:22:40.360]                           info <- base::paste(info, collapse = "; ")
[10:22:40.360]                           if (!has_future) {
[10:22:40.360]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:40.360]                               info)
[10:22:40.360]                           }
[10:22:40.360]                           else {
[10:22:40.360]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:40.360]                               info, version)
[10:22:40.360]                           }
[10:22:40.360]                           base::stop(msg)
[10:22:40.360]                         }
[10:22:40.360]                       })
[10:22:40.360]                     }
[10:22:40.360]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:40.360]                     base::options(mc.cores = 1L)
[10:22:40.360]                   }
[10:22:40.360]                   ...future.strategy.old <- future::plan("list")
[10:22:40.360]                   options(future.plan = NULL)
[10:22:40.360]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:40.360]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:40.360]                 }
[10:22:40.360]                 ...future.workdir <- getwd()
[10:22:40.360]             }
[10:22:40.360]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:40.360]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:40.360]         }
[10:22:40.360]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:40.360]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:40.360]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:40.360]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:40.360]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:40.360]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:40.360]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:40.360]             base::names(...future.oldOptions))
[10:22:40.360]     }
[10:22:40.360]     if (FALSE) {
[10:22:40.360]     }
[10:22:40.360]     else {
[10:22:40.360]         if (TRUE) {
[10:22:40.360]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:40.360]                 open = "w")
[10:22:40.360]         }
[10:22:40.360]         else {
[10:22:40.360]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:40.360]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:40.360]         }
[10:22:40.360]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:40.360]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:40.360]             base::sink(type = "output", split = FALSE)
[10:22:40.360]             base::close(...future.stdout)
[10:22:40.360]         }, add = TRUE)
[10:22:40.360]     }
[10:22:40.360]     ...future.frame <- base::sys.nframe()
[10:22:40.360]     ...future.conditions <- base::list()
[10:22:40.360]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:40.360]     if (FALSE) {
[10:22:40.360]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:40.360]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:40.360]     }
[10:22:40.360]     ...future.result <- base::tryCatch({
[10:22:40.360]         base::withCallingHandlers({
[10:22:40.360]             ...future.value <- base::withVisible(base::local({
[10:22:40.360]                 ...future.makeSendCondition <- base::local({
[10:22:40.360]                   sendCondition <- NULL
[10:22:40.360]                   function(frame = 1L) {
[10:22:40.360]                     if (is.function(sendCondition)) 
[10:22:40.360]                       return(sendCondition)
[10:22:40.360]                     ns <- getNamespace("parallel")
[10:22:40.360]                     if (exists("sendData", mode = "function", 
[10:22:40.360]                       envir = ns)) {
[10:22:40.360]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:40.360]                         envir = ns)
[10:22:40.360]                       envir <- sys.frame(frame)
[10:22:40.360]                       master <- NULL
[10:22:40.360]                       while (!identical(envir, .GlobalEnv) && 
[10:22:40.360]                         !identical(envir, emptyenv())) {
[10:22:40.360]                         if (exists("master", mode = "list", envir = envir, 
[10:22:40.360]                           inherits = FALSE)) {
[10:22:40.360]                           master <- get("master", mode = "list", 
[10:22:40.360]                             envir = envir, inherits = FALSE)
[10:22:40.360]                           if (inherits(master, c("SOCKnode", 
[10:22:40.360]                             "SOCK0node"))) {
[10:22:40.360]                             sendCondition <<- function(cond) {
[10:22:40.360]                               data <- list(type = "VALUE", value = cond, 
[10:22:40.360]                                 success = TRUE)
[10:22:40.360]                               parallel_sendData(master, data)
[10:22:40.360]                             }
[10:22:40.360]                             return(sendCondition)
[10:22:40.360]                           }
[10:22:40.360]                         }
[10:22:40.360]                         frame <- frame + 1L
[10:22:40.360]                         envir <- sys.frame(frame)
[10:22:40.360]                       }
[10:22:40.360]                     }
[10:22:40.360]                     sendCondition <<- function(cond) NULL
[10:22:40.360]                   }
[10:22:40.360]                 })
[10:22:40.360]                 withCallingHandlers({
[10:22:40.360]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:22:40.360]                 }, immediateCondition = function(cond) {
[10:22:40.360]                   sendCondition <- ...future.makeSendCondition()
[10:22:40.360]                   sendCondition(cond)
[10:22:40.360]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:40.360]                   {
[10:22:40.360]                     inherits <- base::inherits
[10:22:40.360]                     invokeRestart <- base::invokeRestart
[10:22:40.360]                     is.null <- base::is.null
[10:22:40.360]                     muffled <- FALSE
[10:22:40.360]                     if (inherits(cond, "message")) {
[10:22:40.360]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:40.360]                       if (muffled) 
[10:22:40.360]                         invokeRestart("muffleMessage")
[10:22:40.360]                     }
[10:22:40.360]                     else if (inherits(cond, "warning")) {
[10:22:40.360]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:40.360]                       if (muffled) 
[10:22:40.360]                         invokeRestart("muffleWarning")
[10:22:40.360]                     }
[10:22:40.360]                     else if (inherits(cond, "condition")) {
[10:22:40.360]                       if (!is.null(pattern)) {
[10:22:40.360]                         computeRestarts <- base::computeRestarts
[10:22:40.360]                         grepl <- base::grepl
[10:22:40.360]                         restarts <- computeRestarts(cond)
[10:22:40.360]                         for (restart in restarts) {
[10:22:40.360]                           name <- restart$name
[10:22:40.360]                           if (is.null(name)) 
[10:22:40.360]                             next
[10:22:40.360]                           if (!grepl(pattern, name)) 
[10:22:40.360]                             next
[10:22:40.360]                           invokeRestart(restart)
[10:22:40.360]                           muffled <- TRUE
[10:22:40.360]                           break
[10:22:40.360]                         }
[10:22:40.360]                       }
[10:22:40.360]                     }
[10:22:40.360]                     invisible(muffled)
[10:22:40.360]                   }
[10:22:40.360]                   muffleCondition(cond)
[10:22:40.360]                 })
[10:22:40.360]             }))
[10:22:40.360]             future::FutureResult(value = ...future.value$value, 
[10:22:40.360]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:40.360]                   ...future.rng), globalenv = if (FALSE) 
[10:22:40.360]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:40.360]                     ...future.globalenv.names))
[10:22:40.360]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:40.360]         }, condition = base::local({
[10:22:40.360]             c <- base::c
[10:22:40.360]             inherits <- base::inherits
[10:22:40.360]             invokeRestart <- base::invokeRestart
[10:22:40.360]             length <- base::length
[10:22:40.360]             list <- base::list
[10:22:40.360]             seq.int <- base::seq.int
[10:22:40.360]             signalCondition <- base::signalCondition
[10:22:40.360]             sys.calls <- base::sys.calls
[10:22:40.360]             `[[` <- base::`[[`
[10:22:40.360]             `+` <- base::`+`
[10:22:40.360]             `<<-` <- base::`<<-`
[10:22:40.360]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:40.360]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:40.360]                   3L)]
[10:22:40.360]             }
[10:22:40.360]             function(cond) {
[10:22:40.360]                 is_error <- inherits(cond, "error")
[10:22:40.360]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:40.360]                   NULL)
[10:22:40.360]                 if (is_error) {
[10:22:40.360]                   sessionInformation <- function() {
[10:22:40.360]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:40.360]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:40.360]                       search = base::search(), system = base::Sys.info())
[10:22:40.360]                   }
[10:22:40.360]                   ...future.conditions[[length(...future.conditions) + 
[10:22:40.360]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:40.360]                     cond$call), session = sessionInformation(), 
[10:22:40.360]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:40.360]                   signalCondition(cond)
[10:22:40.360]                 }
[10:22:40.360]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:40.360]                 "immediateCondition"))) {
[10:22:40.360]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:40.360]                   ...future.conditions[[length(...future.conditions) + 
[10:22:40.360]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:40.360]                   if (TRUE && !signal) {
[10:22:40.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:40.360]                     {
[10:22:40.360]                       inherits <- base::inherits
[10:22:40.360]                       invokeRestart <- base::invokeRestart
[10:22:40.360]                       is.null <- base::is.null
[10:22:40.360]                       muffled <- FALSE
[10:22:40.360]                       if (inherits(cond, "message")) {
[10:22:40.360]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:40.360]                         if (muffled) 
[10:22:40.360]                           invokeRestart("muffleMessage")
[10:22:40.360]                       }
[10:22:40.360]                       else if (inherits(cond, "warning")) {
[10:22:40.360]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:40.360]                         if (muffled) 
[10:22:40.360]                           invokeRestart("muffleWarning")
[10:22:40.360]                       }
[10:22:40.360]                       else if (inherits(cond, "condition")) {
[10:22:40.360]                         if (!is.null(pattern)) {
[10:22:40.360]                           computeRestarts <- base::computeRestarts
[10:22:40.360]                           grepl <- base::grepl
[10:22:40.360]                           restarts <- computeRestarts(cond)
[10:22:40.360]                           for (restart in restarts) {
[10:22:40.360]                             name <- restart$name
[10:22:40.360]                             if (is.null(name)) 
[10:22:40.360]                               next
[10:22:40.360]                             if (!grepl(pattern, name)) 
[10:22:40.360]                               next
[10:22:40.360]                             invokeRestart(restart)
[10:22:40.360]                             muffled <- TRUE
[10:22:40.360]                             break
[10:22:40.360]                           }
[10:22:40.360]                         }
[10:22:40.360]                       }
[10:22:40.360]                       invisible(muffled)
[10:22:40.360]                     }
[10:22:40.360]                     muffleCondition(cond, pattern = "^muffle")
[10:22:40.360]                   }
[10:22:40.360]                 }
[10:22:40.360]                 else {
[10:22:40.360]                   if (TRUE) {
[10:22:40.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:40.360]                     {
[10:22:40.360]                       inherits <- base::inherits
[10:22:40.360]                       invokeRestart <- base::invokeRestart
[10:22:40.360]                       is.null <- base::is.null
[10:22:40.360]                       muffled <- FALSE
[10:22:40.360]                       if (inherits(cond, "message")) {
[10:22:40.360]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:40.360]                         if (muffled) 
[10:22:40.360]                           invokeRestart("muffleMessage")
[10:22:40.360]                       }
[10:22:40.360]                       else if (inherits(cond, "warning")) {
[10:22:40.360]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:40.360]                         if (muffled) 
[10:22:40.360]                           invokeRestart("muffleWarning")
[10:22:40.360]                       }
[10:22:40.360]                       else if (inherits(cond, "condition")) {
[10:22:40.360]                         if (!is.null(pattern)) {
[10:22:40.360]                           computeRestarts <- base::computeRestarts
[10:22:40.360]                           grepl <- base::grepl
[10:22:40.360]                           restarts <- computeRestarts(cond)
[10:22:40.360]                           for (restart in restarts) {
[10:22:40.360]                             name <- restart$name
[10:22:40.360]                             if (is.null(name)) 
[10:22:40.360]                               next
[10:22:40.360]                             if (!grepl(pattern, name)) 
[10:22:40.360]                               next
[10:22:40.360]                             invokeRestart(restart)
[10:22:40.360]                             muffled <- TRUE
[10:22:40.360]                             break
[10:22:40.360]                           }
[10:22:40.360]                         }
[10:22:40.360]                       }
[10:22:40.360]                       invisible(muffled)
[10:22:40.360]                     }
[10:22:40.360]                     muffleCondition(cond, pattern = "^muffle")
[10:22:40.360]                   }
[10:22:40.360]                 }
[10:22:40.360]             }
[10:22:40.360]         }))
[10:22:40.360]     }, error = function(ex) {
[10:22:40.360]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:40.360]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:40.360]                 ...future.rng), started = ...future.startTime, 
[10:22:40.360]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:40.360]             version = "1.8"), class = "FutureResult")
[10:22:40.360]     }, finally = {
[10:22:40.360]         if (!identical(...future.workdir, getwd())) 
[10:22:40.360]             setwd(...future.workdir)
[10:22:40.360]         {
[10:22:40.360]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:40.360]                 ...future.oldOptions$nwarnings <- NULL
[10:22:40.360]             }
[10:22:40.360]             base::options(...future.oldOptions)
[10:22:40.360]             if (.Platform$OS.type == "windows") {
[10:22:40.360]                 old_names <- names(...future.oldEnvVars)
[10:22:40.360]                 envs <- base::Sys.getenv()
[10:22:40.360]                 names <- names(envs)
[10:22:40.360]                 common <- intersect(names, old_names)
[10:22:40.360]                 added <- setdiff(names, old_names)
[10:22:40.360]                 removed <- setdiff(old_names, names)
[10:22:40.360]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:40.360]                   envs[common]]
[10:22:40.360]                 NAMES <- toupper(changed)
[10:22:40.360]                 args <- list()
[10:22:40.360]                 for (kk in seq_along(NAMES)) {
[10:22:40.360]                   name <- changed[[kk]]
[10:22:40.360]                   NAME <- NAMES[[kk]]
[10:22:40.360]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:40.360]                     next
[10:22:40.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:40.360]                 }
[10:22:40.360]                 NAMES <- toupper(added)
[10:22:40.360]                 for (kk in seq_along(NAMES)) {
[10:22:40.360]                   name <- added[[kk]]
[10:22:40.360]                   NAME <- NAMES[[kk]]
[10:22:40.360]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:40.360]                     next
[10:22:40.360]                   args[[name]] <- ""
[10:22:40.360]                 }
[10:22:40.360]                 NAMES <- toupper(removed)
[10:22:40.360]                 for (kk in seq_along(NAMES)) {
[10:22:40.360]                   name <- removed[[kk]]
[10:22:40.360]                   NAME <- NAMES[[kk]]
[10:22:40.360]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:40.360]                     next
[10:22:40.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:40.360]                 }
[10:22:40.360]                 if (length(args) > 0) 
[10:22:40.360]                   base::do.call(base::Sys.setenv, args = args)
[10:22:40.360]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:40.360]             }
[10:22:40.360]             else {
[10:22:40.360]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:40.360]             }
[10:22:40.360]             {
[10:22:40.360]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:40.360]                   0L) {
[10:22:40.360]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:40.360]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:40.360]                   base::options(opts)
[10:22:40.360]                 }
[10:22:40.360]                 {
[10:22:40.360]                   {
[10:22:40.360]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:40.360]                     NULL
[10:22:40.360]                   }
[10:22:40.360]                   options(future.plan = NULL)
[10:22:40.360]                   if (is.na(NA_character_)) 
[10:22:40.360]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:40.360]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:40.360]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:40.360]                     .init = FALSE)
[10:22:40.360]                 }
[10:22:40.360]             }
[10:22:40.360]         }
[10:22:40.360]     })
[10:22:40.360]     if (TRUE) {
[10:22:40.360]         base::sink(type = "output", split = FALSE)
[10:22:40.360]         if (TRUE) {
[10:22:40.360]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:40.360]         }
[10:22:40.360]         else {
[10:22:40.360]             ...future.result["stdout"] <- base::list(NULL)
[10:22:40.360]         }
[10:22:40.360]         base::close(...future.stdout)
[10:22:40.360]         ...future.stdout <- NULL
[10:22:40.360]     }
[10:22:40.360]     ...future.result$conditions <- ...future.conditions
[10:22:40.360]     ...future.result$finished <- base::Sys.time()
[10:22:40.360]     ...future.result
[10:22:40.360] }
[10:22:40.363] MultisessionFuture started
[10:22:40.363] - Launch lazy future ... done
[10:22:40.364] run() for ‘MultisessionFuture’ ... done
[10:22:40.405] receiveMessageFromWorker() for ClusterFuture ...
[10:22:40.406] - Validating connection of MultisessionFuture
[10:22:40.406] - received message: FutureResult
[10:22:40.406] - Received FutureResult
[10:22:40.406] - Erased future from FutureRegistry
[10:22:40.407] result() for ClusterFuture ...
[10:22:40.407] - result already collected: FutureResult
[10:22:40.407] result() for ClusterFuture ... done
[10:22:40.407] signalConditions() ...
[10:22:40.407]  - include = ‘immediateCondition’
[10:22:40.407]  - exclude = 
[10:22:40.407]  - resignal = FALSE
[10:22:40.407]  - Number of conditions: 1
[10:22:40.407] signalConditions() ... done
[10:22:40.407] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:40.407] A MultisessionFuture was resolved (result was not collected)
[10:22:40.407] getGlobalsAndPackages() ...
[10:22:40.408] Searching for globals...
[10:22:40.408] - globals found: [2] ‘list’, ‘stop’
[10:22:40.408] Searching for globals ... DONE
[10:22:40.408] Resolving globals: FALSE
[10:22:40.409] 
[10:22:40.409] 
[10:22:40.409] getGlobalsAndPackages() ... DONE
[10:22:40.409] run() for ‘Future’ ...
[10:22:40.409] - state: ‘created’
[10:22:40.409] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:40.423] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:40.423] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:40.423]   - Field: ‘node’
[10:22:40.423]   - Field: ‘label’
[10:22:40.423]   - Field: ‘local’
[10:22:40.424]   - Field: ‘owner’
[10:22:40.424]   - Field: ‘envir’
[10:22:40.424]   - Field: ‘workers’
[10:22:40.424]   - Field: ‘packages’
[10:22:40.424]   - Field: ‘gc’
[10:22:40.424]   - Field: ‘conditions’
[10:22:40.424]   - Field: ‘persistent’
[10:22:40.424]   - Field: ‘expr’
[10:22:40.424]   - Field: ‘uuid’
[10:22:40.424]   - Field: ‘seed’
[10:22:40.424]   - Field: ‘version’
[10:22:40.425]   - Field: ‘result’
[10:22:40.425]   - Field: ‘asynchronous’
[10:22:40.425]   - Field: ‘calls’
[10:22:40.425]   - Field: ‘globals’
[10:22:40.425]   - Field: ‘stdout’
[10:22:40.425]   - Field: ‘earlySignal’
[10:22:40.425]   - Field: ‘lazy’
[10:22:40.425]   - Field: ‘state’
[10:22:40.425] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:40.425] - Launch lazy future ...
[10:22:40.426] Packages needed by the future expression (n = 0): <none>
[10:22:40.426] Packages needed by future strategies (n = 0): <none>
[10:22:40.426] {
[10:22:40.426]     {
[10:22:40.426]         {
[10:22:40.426]             ...future.startTime <- base::Sys.time()
[10:22:40.426]             {
[10:22:40.426]                 {
[10:22:40.426]                   {
[10:22:40.426]                     {
[10:22:40.426]                       base::local({
[10:22:40.426]                         has_future <- base::requireNamespace("future", 
[10:22:40.426]                           quietly = TRUE)
[10:22:40.426]                         if (has_future) {
[10:22:40.426]                           ns <- base::getNamespace("future")
[10:22:40.426]                           version <- ns[[".package"]][["version"]]
[10:22:40.426]                           if (is.null(version)) 
[10:22:40.426]                             version <- utils::packageVersion("future")
[10:22:40.426]                         }
[10:22:40.426]                         else {
[10:22:40.426]                           version <- NULL
[10:22:40.426]                         }
[10:22:40.426]                         if (!has_future || version < "1.8.0") {
[10:22:40.426]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:40.426]                             "", base::R.version$version.string), 
[10:22:40.426]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:40.426]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:40.426]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:40.426]                               "release", "version")], collapse = " "), 
[10:22:40.426]                             hostname = base::Sys.info()[["nodename"]])
[10:22:40.426]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:40.426]                             info)
[10:22:40.426]                           info <- base::paste(info, collapse = "; ")
[10:22:40.426]                           if (!has_future) {
[10:22:40.426]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:40.426]                               info)
[10:22:40.426]                           }
[10:22:40.426]                           else {
[10:22:40.426]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:40.426]                               info, version)
[10:22:40.426]                           }
[10:22:40.426]                           base::stop(msg)
[10:22:40.426]                         }
[10:22:40.426]                       })
[10:22:40.426]                     }
[10:22:40.426]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:40.426]                     base::options(mc.cores = 1L)
[10:22:40.426]                   }
[10:22:40.426]                   ...future.strategy.old <- future::plan("list")
[10:22:40.426]                   options(future.plan = NULL)
[10:22:40.426]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:40.426]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:40.426]                 }
[10:22:40.426]                 ...future.workdir <- getwd()
[10:22:40.426]             }
[10:22:40.426]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:40.426]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:40.426]         }
[10:22:40.426]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:40.426]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:40.426]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:40.426]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:40.426]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:40.426]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:40.426]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:40.426]             base::names(...future.oldOptions))
[10:22:40.426]     }
[10:22:40.426]     if (FALSE) {
[10:22:40.426]     }
[10:22:40.426]     else {
[10:22:40.426]         if (TRUE) {
[10:22:40.426]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:40.426]                 open = "w")
[10:22:40.426]         }
[10:22:40.426]         else {
[10:22:40.426]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:40.426]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:40.426]         }
[10:22:40.426]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:40.426]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:40.426]             base::sink(type = "output", split = FALSE)
[10:22:40.426]             base::close(...future.stdout)
[10:22:40.426]         }, add = TRUE)
[10:22:40.426]     }
[10:22:40.426]     ...future.frame <- base::sys.nframe()
[10:22:40.426]     ...future.conditions <- base::list()
[10:22:40.426]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:40.426]     if (FALSE) {
[10:22:40.426]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:40.426]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:40.426]     }
[10:22:40.426]     ...future.result <- base::tryCatch({
[10:22:40.426]         base::withCallingHandlers({
[10:22:40.426]             ...future.value <- base::withVisible(base::local({
[10:22:40.426]                 ...future.makeSendCondition <- base::local({
[10:22:40.426]                   sendCondition <- NULL
[10:22:40.426]                   function(frame = 1L) {
[10:22:40.426]                     if (is.function(sendCondition)) 
[10:22:40.426]                       return(sendCondition)
[10:22:40.426]                     ns <- getNamespace("parallel")
[10:22:40.426]                     if (exists("sendData", mode = "function", 
[10:22:40.426]                       envir = ns)) {
[10:22:40.426]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:40.426]                         envir = ns)
[10:22:40.426]                       envir <- sys.frame(frame)
[10:22:40.426]                       master <- NULL
[10:22:40.426]                       while (!identical(envir, .GlobalEnv) && 
[10:22:40.426]                         !identical(envir, emptyenv())) {
[10:22:40.426]                         if (exists("master", mode = "list", envir = envir, 
[10:22:40.426]                           inherits = FALSE)) {
[10:22:40.426]                           master <- get("master", mode = "list", 
[10:22:40.426]                             envir = envir, inherits = FALSE)
[10:22:40.426]                           if (inherits(master, c("SOCKnode", 
[10:22:40.426]                             "SOCK0node"))) {
[10:22:40.426]                             sendCondition <<- function(cond) {
[10:22:40.426]                               data <- list(type = "VALUE", value = cond, 
[10:22:40.426]                                 success = TRUE)
[10:22:40.426]                               parallel_sendData(master, data)
[10:22:40.426]                             }
[10:22:40.426]                             return(sendCondition)
[10:22:40.426]                           }
[10:22:40.426]                         }
[10:22:40.426]                         frame <- frame + 1L
[10:22:40.426]                         envir <- sys.frame(frame)
[10:22:40.426]                       }
[10:22:40.426]                     }
[10:22:40.426]                     sendCondition <<- function(cond) NULL
[10:22:40.426]                   }
[10:22:40.426]                 })
[10:22:40.426]                 withCallingHandlers({
[10:22:40.426]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:22:40.426]                 }, immediateCondition = function(cond) {
[10:22:40.426]                   sendCondition <- ...future.makeSendCondition()
[10:22:40.426]                   sendCondition(cond)
[10:22:40.426]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:40.426]                   {
[10:22:40.426]                     inherits <- base::inherits
[10:22:40.426]                     invokeRestart <- base::invokeRestart
[10:22:40.426]                     is.null <- base::is.null
[10:22:40.426]                     muffled <- FALSE
[10:22:40.426]                     if (inherits(cond, "message")) {
[10:22:40.426]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:40.426]                       if (muffled) 
[10:22:40.426]                         invokeRestart("muffleMessage")
[10:22:40.426]                     }
[10:22:40.426]                     else if (inherits(cond, "warning")) {
[10:22:40.426]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:40.426]                       if (muffled) 
[10:22:40.426]                         invokeRestart("muffleWarning")
[10:22:40.426]                     }
[10:22:40.426]                     else if (inherits(cond, "condition")) {
[10:22:40.426]                       if (!is.null(pattern)) {
[10:22:40.426]                         computeRestarts <- base::computeRestarts
[10:22:40.426]                         grepl <- base::grepl
[10:22:40.426]                         restarts <- computeRestarts(cond)
[10:22:40.426]                         for (restart in restarts) {
[10:22:40.426]                           name <- restart$name
[10:22:40.426]                           if (is.null(name)) 
[10:22:40.426]                             next
[10:22:40.426]                           if (!grepl(pattern, name)) 
[10:22:40.426]                             next
[10:22:40.426]                           invokeRestart(restart)
[10:22:40.426]                           muffled <- TRUE
[10:22:40.426]                           break
[10:22:40.426]                         }
[10:22:40.426]                       }
[10:22:40.426]                     }
[10:22:40.426]                     invisible(muffled)
[10:22:40.426]                   }
[10:22:40.426]                   muffleCondition(cond)
[10:22:40.426]                 })
[10:22:40.426]             }))
[10:22:40.426]             future::FutureResult(value = ...future.value$value, 
[10:22:40.426]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:40.426]                   ...future.rng), globalenv = if (FALSE) 
[10:22:40.426]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:40.426]                     ...future.globalenv.names))
[10:22:40.426]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:40.426]         }, condition = base::local({
[10:22:40.426]             c <- base::c
[10:22:40.426]             inherits <- base::inherits
[10:22:40.426]             invokeRestart <- base::invokeRestart
[10:22:40.426]             length <- base::length
[10:22:40.426]             list <- base::list
[10:22:40.426]             seq.int <- base::seq.int
[10:22:40.426]             signalCondition <- base::signalCondition
[10:22:40.426]             sys.calls <- base::sys.calls
[10:22:40.426]             `[[` <- base::`[[`
[10:22:40.426]             `+` <- base::`+`
[10:22:40.426]             `<<-` <- base::`<<-`
[10:22:40.426]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:40.426]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:40.426]                   3L)]
[10:22:40.426]             }
[10:22:40.426]             function(cond) {
[10:22:40.426]                 is_error <- inherits(cond, "error")
[10:22:40.426]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:40.426]                   NULL)
[10:22:40.426]                 if (is_error) {
[10:22:40.426]                   sessionInformation <- function() {
[10:22:40.426]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:40.426]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:40.426]                       search = base::search(), system = base::Sys.info())
[10:22:40.426]                   }
[10:22:40.426]                   ...future.conditions[[length(...future.conditions) + 
[10:22:40.426]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:40.426]                     cond$call), session = sessionInformation(), 
[10:22:40.426]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:40.426]                   signalCondition(cond)
[10:22:40.426]                 }
[10:22:40.426]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:40.426]                 "immediateCondition"))) {
[10:22:40.426]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:40.426]                   ...future.conditions[[length(...future.conditions) + 
[10:22:40.426]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:40.426]                   if (TRUE && !signal) {
[10:22:40.426]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:40.426]                     {
[10:22:40.426]                       inherits <- base::inherits
[10:22:40.426]                       invokeRestart <- base::invokeRestart
[10:22:40.426]                       is.null <- base::is.null
[10:22:40.426]                       muffled <- FALSE
[10:22:40.426]                       if (inherits(cond, "message")) {
[10:22:40.426]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:40.426]                         if (muffled) 
[10:22:40.426]                           invokeRestart("muffleMessage")
[10:22:40.426]                       }
[10:22:40.426]                       else if (inherits(cond, "warning")) {
[10:22:40.426]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:40.426]                         if (muffled) 
[10:22:40.426]                           invokeRestart("muffleWarning")
[10:22:40.426]                       }
[10:22:40.426]                       else if (inherits(cond, "condition")) {
[10:22:40.426]                         if (!is.null(pattern)) {
[10:22:40.426]                           computeRestarts <- base::computeRestarts
[10:22:40.426]                           grepl <- base::grepl
[10:22:40.426]                           restarts <- computeRestarts(cond)
[10:22:40.426]                           for (restart in restarts) {
[10:22:40.426]                             name <- restart$name
[10:22:40.426]                             if (is.null(name)) 
[10:22:40.426]                               next
[10:22:40.426]                             if (!grepl(pattern, name)) 
[10:22:40.426]                               next
[10:22:40.426]                             invokeRestart(restart)
[10:22:40.426]                             muffled <- TRUE
[10:22:40.426]                             break
[10:22:40.426]                           }
[10:22:40.426]                         }
[10:22:40.426]                       }
[10:22:40.426]                       invisible(muffled)
[10:22:40.426]                     }
[10:22:40.426]                     muffleCondition(cond, pattern = "^muffle")
[10:22:40.426]                   }
[10:22:40.426]                 }
[10:22:40.426]                 else {
[10:22:40.426]                   if (TRUE) {
[10:22:40.426]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:40.426]                     {
[10:22:40.426]                       inherits <- base::inherits
[10:22:40.426]                       invokeRestart <- base::invokeRestart
[10:22:40.426]                       is.null <- base::is.null
[10:22:40.426]                       muffled <- FALSE
[10:22:40.426]                       if (inherits(cond, "message")) {
[10:22:40.426]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:40.426]                         if (muffled) 
[10:22:40.426]                           invokeRestart("muffleMessage")
[10:22:40.426]                       }
[10:22:40.426]                       else if (inherits(cond, "warning")) {
[10:22:40.426]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:40.426]                         if (muffled) 
[10:22:40.426]                           invokeRestart("muffleWarning")
[10:22:40.426]                       }
[10:22:40.426]                       else if (inherits(cond, "condition")) {
[10:22:40.426]                         if (!is.null(pattern)) {
[10:22:40.426]                           computeRestarts <- base::computeRestarts
[10:22:40.426]                           grepl <- base::grepl
[10:22:40.426]                           restarts <- computeRestarts(cond)
[10:22:40.426]                           for (restart in restarts) {
[10:22:40.426]                             name <- restart$name
[10:22:40.426]                             if (is.null(name)) 
[10:22:40.426]                               next
[10:22:40.426]                             if (!grepl(pattern, name)) 
[10:22:40.426]                               next
[10:22:40.426]                             invokeRestart(restart)
[10:22:40.426]                             muffled <- TRUE
[10:22:40.426]                             break
[10:22:40.426]                           }
[10:22:40.426]                         }
[10:22:40.426]                       }
[10:22:40.426]                       invisible(muffled)
[10:22:40.426]                     }
[10:22:40.426]                     muffleCondition(cond, pattern = "^muffle")
[10:22:40.426]                   }
[10:22:40.426]                 }
[10:22:40.426]             }
[10:22:40.426]         }))
[10:22:40.426]     }, error = function(ex) {
[10:22:40.426]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:40.426]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:40.426]                 ...future.rng), started = ...future.startTime, 
[10:22:40.426]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:40.426]             version = "1.8"), class = "FutureResult")
[10:22:40.426]     }, finally = {
[10:22:40.426]         if (!identical(...future.workdir, getwd())) 
[10:22:40.426]             setwd(...future.workdir)
[10:22:40.426]         {
[10:22:40.426]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:40.426]                 ...future.oldOptions$nwarnings <- NULL
[10:22:40.426]             }
[10:22:40.426]             base::options(...future.oldOptions)
[10:22:40.426]             if (.Platform$OS.type == "windows") {
[10:22:40.426]                 old_names <- names(...future.oldEnvVars)
[10:22:40.426]                 envs <- base::Sys.getenv()
[10:22:40.426]                 names <- names(envs)
[10:22:40.426]                 common <- intersect(names, old_names)
[10:22:40.426]                 added <- setdiff(names, old_names)
[10:22:40.426]                 removed <- setdiff(old_names, names)
[10:22:40.426]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:40.426]                   envs[common]]
[10:22:40.426]                 NAMES <- toupper(changed)
[10:22:40.426]                 args <- list()
[10:22:40.426]                 for (kk in seq_along(NAMES)) {
[10:22:40.426]                   name <- changed[[kk]]
[10:22:40.426]                   NAME <- NAMES[[kk]]
[10:22:40.426]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:40.426]                     next
[10:22:40.426]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:40.426]                 }
[10:22:40.426]                 NAMES <- toupper(added)
[10:22:40.426]                 for (kk in seq_along(NAMES)) {
[10:22:40.426]                   name <- added[[kk]]
[10:22:40.426]                   NAME <- NAMES[[kk]]
[10:22:40.426]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:40.426]                     next
[10:22:40.426]                   args[[name]] <- ""
[10:22:40.426]                 }
[10:22:40.426]                 NAMES <- toupper(removed)
[10:22:40.426]                 for (kk in seq_along(NAMES)) {
[10:22:40.426]                   name <- removed[[kk]]
[10:22:40.426]                   NAME <- NAMES[[kk]]
[10:22:40.426]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:40.426]                     next
[10:22:40.426]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:40.426]                 }
[10:22:40.426]                 if (length(args) > 0) 
[10:22:40.426]                   base::do.call(base::Sys.setenv, args = args)
[10:22:40.426]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:40.426]             }
[10:22:40.426]             else {
[10:22:40.426]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:40.426]             }
[10:22:40.426]             {
[10:22:40.426]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:40.426]                   0L) {
[10:22:40.426]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:40.426]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:40.426]                   base::options(opts)
[10:22:40.426]                 }
[10:22:40.426]                 {
[10:22:40.426]                   {
[10:22:40.426]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:40.426]                     NULL
[10:22:40.426]                   }
[10:22:40.426]                   options(future.plan = NULL)
[10:22:40.426]                   if (is.na(NA_character_)) 
[10:22:40.426]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:40.426]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:40.426]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:40.426]                     .init = FALSE)
[10:22:40.426]                 }
[10:22:40.426]             }
[10:22:40.426]         }
[10:22:40.426]     })
[10:22:40.426]     if (TRUE) {
[10:22:40.426]         base::sink(type = "output", split = FALSE)
[10:22:40.426]         if (TRUE) {
[10:22:40.426]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:40.426]         }
[10:22:40.426]         else {
[10:22:40.426]             ...future.result["stdout"] <- base::list(NULL)
[10:22:40.426]         }
[10:22:40.426]         base::close(...future.stdout)
[10:22:40.426]         ...future.stdout <- NULL
[10:22:40.426]     }
[10:22:40.426]     ...future.result$conditions <- ...future.conditions
[10:22:40.426]     ...future.result$finished <- base::Sys.time()
[10:22:40.426]     ...future.result
[10:22:40.426] }
[10:22:40.429] MultisessionFuture started
[10:22:40.429] - Launch lazy future ... done
[10:22:40.429] run() for ‘MultisessionFuture’ ... done
[10:22:40.471] receiveMessageFromWorker() for ClusterFuture ...
[10:22:40.471] - Validating connection of MultisessionFuture
[10:22:40.472] - received message: FutureResult
[10:22:40.472] - Received FutureResult
[10:22:40.472] - Erased future from FutureRegistry
[10:22:40.472] result() for ClusterFuture ...
[10:22:40.472] - result already collected: FutureResult
[10:22:40.472] result() for ClusterFuture ... done
[10:22:40.473] signalConditions() ...
[10:22:40.473]  - include = ‘immediateCondition’
[10:22:40.473]  - exclude = 
[10:22:40.473]  - resignal = FALSE
[10:22:40.473]  - Number of conditions: 1
[10:22:40.473] signalConditions() ... done
[10:22:40.473] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:40.473] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = Inf ... DONE
- result = TRUE, recursive = FALSE ...
[10:22:40.473] getGlobalsAndPackages() ...
[10:22:40.473] Searching for globals...
[10:22:40.475] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:22:40.475] Searching for globals ... DONE
[10:22:40.475] Resolving globals: FALSE
[10:22:40.475] 
[10:22:40.475] 
[10:22:40.475] getGlobalsAndPackages() ... DONE
[10:22:40.475] run() for ‘Future’ ...
[10:22:40.476] - state: ‘created’
[10:22:40.476] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:40.490] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:40.490] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:40.491]   - Field: ‘node’
[10:22:40.491]   - Field: ‘label’
[10:22:40.491]   - Field: ‘local’
[10:22:40.491]   - Field: ‘owner’
[10:22:40.491]   - Field: ‘envir’
[10:22:40.491]   - Field: ‘workers’
[10:22:40.491]   - Field: ‘packages’
[10:22:40.491]   - Field: ‘gc’
[10:22:40.491]   - Field: ‘conditions’
[10:22:40.491]   - Field: ‘persistent’
[10:22:40.491]   - Field: ‘expr’
[10:22:40.491]   - Field: ‘uuid’
[10:22:40.492]   - Field: ‘seed’
[10:22:40.492]   - Field: ‘version’
[10:22:40.492]   - Field: ‘result’
[10:22:40.492]   - Field: ‘asynchronous’
[10:22:40.492]   - Field: ‘calls’
[10:22:40.492]   - Field: ‘globals’
[10:22:40.492]   - Field: ‘stdout’
[10:22:40.492]   - Field: ‘earlySignal’
[10:22:40.492]   - Field: ‘lazy’
[10:22:40.492]   - Field: ‘state’
[10:22:40.492] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:40.493] - Launch lazy future ...
[10:22:40.493] Packages needed by the future expression (n = 0): <none>
[10:22:40.493] Packages needed by future strategies (n = 0): <none>
[10:22:40.493] {
[10:22:40.493]     {
[10:22:40.493]         {
[10:22:40.493]             ...future.startTime <- base::Sys.time()
[10:22:40.493]             {
[10:22:40.493]                 {
[10:22:40.493]                   {
[10:22:40.493]                     {
[10:22:40.493]                       base::local({
[10:22:40.493]                         has_future <- base::requireNamespace("future", 
[10:22:40.493]                           quietly = TRUE)
[10:22:40.493]                         if (has_future) {
[10:22:40.493]                           ns <- base::getNamespace("future")
[10:22:40.493]                           version <- ns[[".package"]][["version"]]
[10:22:40.493]                           if (is.null(version)) 
[10:22:40.493]                             version <- utils::packageVersion("future")
[10:22:40.493]                         }
[10:22:40.493]                         else {
[10:22:40.493]                           version <- NULL
[10:22:40.493]                         }
[10:22:40.493]                         if (!has_future || version < "1.8.0") {
[10:22:40.493]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:40.493]                             "", base::R.version$version.string), 
[10:22:40.493]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:40.493]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:40.493]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:40.493]                               "release", "version")], collapse = " "), 
[10:22:40.493]                             hostname = base::Sys.info()[["nodename"]])
[10:22:40.493]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:40.493]                             info)
[10:22:40.493]                           info <- base::paste(info, collapse = "; ")
[10:22:40.493]                           if (!has_future) {
[10:22:40.493]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:40.493]                               info)
[10:22:40.493]                           }
[10:22:40.493]                           else {
[10:22:40.493]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:40.493]                               info, version)
[10:22:40.493]                           }
[10:22:40.493]                           base::stop(msg)
[10:22:40.493]                         }
[10:22:40.493]                       })
[10:22:40.493]                     }
[10:22:40.493]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:40.493]                     base::options(mc.cores = 1L)
[10:22:40.493]                   }
[10:22:40.493]                   ...future.strategy.old <- future::plan("list")
[10:22:40.493]                   options(future.plan = NULL)
[10:22:40.493]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:40.493]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:40.493]                 }
[10:22:40.493]                 ...future.workdir <- getwd()
[10:22:40.493]             }
[10:22:40.493]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:40.493]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:40.493]         }
[10:22:40.493]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:40.493]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:40.493]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:40.493]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:40.493]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:40.493]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:40.493]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:40.493]             base::names(...future.oldOptions))
[10:22:40.493]     }
[10:22:40.493]     if (FALSE) {
[10:22:40.493]     }
[10:22:40.493]     else {
[10:22:40.493]         if (TRUE) {
[10:22:40.493]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:40.493]                 open = "w")
[10:22:40.493]         }
[10:22:40.493]         else {
[10:22:40.493]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:40.493]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:40.493]         }
[10:22:40.493]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:40.493]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:40.493]             base::sink(type = "output", split = FALSE)
[10:22:40.493]             base::close(...future.stdout)
[10:22:40.493]         }, add = TRUE)
[10:22:40.493]     }
[10:22:40.493]     ...future.frame <- base::sys.nframe()
[10:22:40.493]     ...future.conditions <- base::list()
[10:22:40.493]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:40.493]     if (FALSE) {
[10:22:40.493]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:40.493]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:40.493]     }
[10:22:40.493]     ...future.result <- base::tryCatch({
[10:22:40.493]         base::withCallingHandlers({
[10:22:40.493]             ...future.value <- base::withVisible(base::local({
[10:22:40.493]                 ...future.makeSendCondition <- base::local({
[10:22:40.493]                   sendCondition <- NULL
[10:22:40.493]                   function(frame = 1L) {
[10:22:40.493]                     if (is.function(sendCondition)) 
[10:22:40.493]                       return(sendCondition)
[10:22:40.493]                     ns <- getNamespace("parallel")
[10:22:40.493]                     if (exists("sendData", mode = "function", 
[10:22:40.493]                       envir = ns)) {
[10:22:40.493]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:40.493]                         envir = ns)
[10:22:40.493]                       envir <- sys.frame(frame)
[10:22:40.493]                       master <- NULL
[10:22:40.493]                       while (!identical(envir, .GlobalEnv) && 
[10:22:40.493]                         !identical(envir, emptyenv())) {
[10:22:40.493]                         if (exists("master", mode = "list", envir = envir, 
[10:22:40.493]                           inherits = FALSE)) {
[10:22:40.493]                           master <- get("master", mode = "list", 
[10:22:40.493]                             envir = envir, inherits = FALSE)
[10:22:40.493]                           if (inherits(master, c("SOCKnode", 
[10:22:40.493]                             "SOCK0node"))) {
[10:22:40.493]                             sendCondition <<- function(cond) {
[10:22:40.493]                               data <- list(type = "VALUE", value = cond, 
[10:22:40.493]                                 success = TRUE)
[10:22:40.493]                               parallel_sendData(master, data)
[10:22:40.493]                             }
[10:22:40.493]                             return(sendCondition)
[10:22:40.493]                           }
[10:22:40.493]                         }
[10:22:40.493]                         frame <- frame + 1L
[10:22:40.493]                         envir <- sys.frame(frame)
[10:22:40.493]                       }
[10:22:40.493]                     }
[10:22:40.493]                     sendCondition <<- function(cond) NULL
[10:22:40.493]                   }
[10:22:40.493]                 })
[10:22:40.493]                 withCallingHandlers({
[10:22:40.493]                   {
[10:22:40.493]                     Sys.sleep(0.5)
[10:22:40.493]                     list(a = 1, b = 42L)
[10:22:40.493]                   }
[10:22:40.493]                 }, immediateCondition = function(cond) {
[10:22:40.493]                   sendCondition <- ...future.makeSendCondition()
[10:22:40.493]                   sendCondition(cond)
[10:22:40.493]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:40.493]                   {
[10:22:40.493]                     inherits <- base::inherits
[10:22:40.493]                     invokeRestart <- base::invokeRestart
[10:22:40.493]                     is.null <- base::is.null
[10:22:40.493]                     muffled <- FALSE
[10:22:40.493]                     if (inherits(cond, "message")) {
[10:22:40.493]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:40.493]                       if (muffled) 
[10:22:40.493]                         invokeRestart("muffleMessage")
[10:22:40.493]                     }
[10:22:40.493]                     else if (inherits(cond, "warning")) {
[10:22:40.493]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:40.493]                       if (muffled) 
[10:22:40.493]                         invokeRestart("muffleWarning")
[10:22:40.493]                     }
[10:22:40.493]                     else if (inherits(cond, "condition")) {
[10:22:40.493]                       if (!is.null(pattern)) {
[10:22:40.493]                         computeRestarts <- base::computeRestarts
[10:22:40.493]                         grepl <- base::grepl
[10:22:40.493]                         restarts <- computeRestarts(cond)
[10:22:40.493]                         for (restart in restarts) {
[10:22:40.493]                           name <- restart$name
[10:22:40.493]                           if (is.null(name)) 
[10:22:40.493]                             next
[10:22:40.493]                           if (!grepl(pattern, name)) 
[10:22:40.493]                             next
[10:22:40.493]                           invokeRestart(restart)
[10:22:40.493]                           muffled <- TRUE
[10:22:40.493]                           break
[10:22:40.493]                         }
[10:22:40.493]                       }
[10:22:40.493]                     }
[10:22:40.493]                     invisible(muffled)
[10:22:40.493]                   }
[10:22:40.493]                   muffleCondition(cond)
[10:22:40.493]                 })
[10:22:40.493]             }))
[10:22:40.493]             future::FutureResult(value = ...future.value$value, 
[10:22:40.493]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:40.493]                   ...future.rng), globalenv = if (FALSE) 
[10:22:40.493]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:40.493]                     ...future.globalenv.names))
[10:22:40.493]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:40.493]         }, condition = base::local({
[10:22:40.493]             c <- base::c
[10:22:40.493]             inherits <- base::inherits
[10:22:40.493]             invokeRestart <- base::invokeRestart
[10:22:40.493]             length <- base::length
[10:22:40.493]             list <- base::list
[10:22:40.493]             seq.int <- base::seq.int
[10:22:40.493]             signalCondition <- base::signalCondition
[10:22:40.493]             sys.calls <- base::sys.calls
[10:22:40.493]             `[[` <- base::`[[`
[10:22:40.493]             `+` <- base::`+`
[10:22:40.493]             `<<-` <- base::`<<-`
[10:22:40.493]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:40.493]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:40.493]                   3L)]
[10:22:40.493]             }
[10:22:40.493]             function(cond) {
[10:22:40.493]                 is_error <- inherits(cond, "error")
[10:22:40.493]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:40.493]                   NULL)
[10:22:40.493]                 if (is_error) {
[10:22:40.493]                   sessionInformation <- function() {
[10:22:40.493]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:40.493]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:40.493]                       search = base::search(), system = base::Sys.info())
[10:22:40.493]                   }
[10:22:40.493]                   ...future.conditions[[length(...future.conditions) + 
[10:22:40.493]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:40.493]                     cond$call), session = sessionInformation(), 
[10:22:40.493]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:40.493]                   signalCondition(cond)
[10:22:40.493]                 }
[10:22:40.493]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:40.493]                 "immediateCondition"))) {
[10:22:40.493]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:40.493]                   ...future.conditions[[length(...future.conditions) + 
[10:22:40.493]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:40.493]                   if (TRUE && !signal) {
[10:22:40.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:40.493]                     {
[10:22:40.493]                       inherits <- base::inherits
[10:22:40.493]                       invokeRestart <- base::invokeRestart
[10:22:40.493]                       is.null <- base::is.null
[10:22:40.493]                       muffled <- FALSE
[10:22:40.493]                       if (inherits(cond, "message")) {
[10:22:40.493]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:40.493]                         if (muffled) 
[10:22:40.493]                           invokeRestart("muffleMessage")
[10:22:40.493]                       }
[10:22:40.493]                       else if (inherits(cond, "warning")) {
[10:22:40.493]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:40.493]                         if (muffled) 
[10:22:40.493]                           invokeRestart("muffleWarning")
[10:22:40.493]                       }
[10:22:40.493]                       else if (inherits(cond, "condition")) {
[10:22:40.493]                         if (!is.null(pattern)) {
[10:22:40.493]                           computeRestarts <- base::computeRestarts
[10:22:40.493]                           grepl <- base::grepl
[10:22:40.493]                           restarts <- computeRestarts(cond)
[10:22:40.493]                           for (restart in restarts) {
[10:22:40.493]                             name <- restart$name
[10:22:40.493]                             if (is.null(name)) 
[10:22:40.493]                               next
[10:22:40.493]                             if (!grepl(pattern, name)) 
[10:22:40.493]                               next
[10:22:40.493]                             invokeRestart(restart)
[10:22:40.493]                             muffled <- TRUE
[10:22:40.493]                             break
[10:22:40.493]                           }
[10:22:40.493]                         }
[10:22:40.493]                       }
[10:22:40.493]                       invisible(muffled)
[10:22:40.493]                     }
[10:22:40.493]                     muffleCondition(cond, pattern = "^muffle")
[10:22:40.493]                   }
[10:22:40.493]                 }
[10:22:40.493]                 else {
[10:22:40.493]                   if (TRUE) {
[10:22:40.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:40.493]                     {
[10:22:40.493]                       inherits <- base::inherits
[10:22:40.493]                       invokeRestart <- base::invokeRestart
[10:22:40.493]                       is.null <- base::is.null
[10:22:40.493]                       muffled <- FALSE
[10:22:40.493]                       if (inherits(cond, "message")) {
[10:22:40.493]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:40.493]                         if (muffled) 
[10:22:40.493]                           invokeRestart("muffleMessage")
[10:22:40.493]                       }
[10:22:40.493]                       else if (inherits(cond, "warning")) {
[10:22:40.493]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:40.493]                         if (muffled) 
[10:22:40.493]                           invokeRestart("muffleWarning")
[10:22:40.493]                       }
[10:22:40.493]                       else if (inherits(cond, "condition")) {
[10:22:40.493]                         if (!is.null(pattern)) {
[10:22:40.493]                           computeRestarts <- base::computeRestarts
[10:22:40.493]                           grepl <- base::grepl
[10:22:40.493]                           restarts <- computeRestarts(cond)
[10:22:40.493]                           for (restart in restarts) {
[10:22:40.493]                             name <- restart$name
[10:22:40.493]                             if (is.null(name)) 
[10:22:40.493]                               next
[10:22:40.493]                             if (!grepl(pattern, name)) 
[10:22:40.493]                               next
[10:22:40.493]                             invokeRestart(restart)
[10:22:40.493]                             muffled <- TRUE
[10:22:40.493]                             break
[10:22:40.493]                           }
[10:22:40.493]                         }
[10:22:40.493]                       }
[10:22:40.493]                       invisible(muffled)
[10:22:40.493]                     }
[10:22:40.493]                     muffleCondition(cond, pattern = "^muffle")
[10:22:40.493]                   }
[10:22:40.493]                 }
[10:22:40.493]             }
[10:22:40.493]         }))
[10:22:40.493]     }, error = function(ex) {
[10:22:40.493]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:40.493]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:40.493]                 ...future.rng), started = ...future.startTime, 
[10:22:40.493]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:40.493]             version = "1.8"), class = "FutureResult")
[10:22:40.493]     }, finally = {
[10:22:40.493]         if (!identical(...future.workdir, getwd())) 
[10:22:40.493]             setwd(...future.workdir)
[10:22:40.493]         {
[10:22:40.493]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:40.493]                 ...future.oldOptions$nwarnings <- NULL
[10:22:40.493]             }
[10:22:40.493]             base::options(...future.oldOptions)
[10:22:40.493]             if (.Platform$OS.type == "windows") {
[10:22:40.493]                 old_names <- names(...future.oldEnvVars)
[10:22:40.493]                 envs <- base::Sys.getenv()
[10:22:40.493]                 names <- names(envs)
[10:22:40.493]                 common <- intersect(names, old_names)
[10:22:40.493]                 added <- setdiff(names, old_names)
[10:22:40.493]                 removed <- setdiff(old_names, names)
[10:22:40.493]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:40.493]                   envs[common]]
[10:22:40.493]                 NAMES <- toupper(changed)
[10:22:40.493]                 args <- list()
[10:22:40.493]                 for (kk in seq_along(NAMES)) {
[10:22:40.493]                   name <- changed[[kk]]
[10:22:40.493]                   NAME <- NAMES[[kk]]
[10:22:40.493]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:40.493]                     next
[10:22:40.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:40.493]                 }
[10:22:40.493]                 NAMES <- toupper(added)
[10:22:40.493]                 for (kk in seq_along(NAMES)) {
[10:22:40.493]                   name <- added[[kk]]
[10:22:40.493]                   NAME <- NAMES[[kk]]
[10:22:40.493]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:40.493]                     next
[10:22:40.493]                   args[[name]] <- ""
[10:22:40.493]                 }
[10:22:40.493]                 NAMES <- toupper(removed)
[10:22:40.493]                 for (kk in seq_along(NAMES)) {
[10:22:40.493]                   name <- removed[[kk]]
[10:22:40.493]                   NAME <- NAMES[[kk]]
[10:22:40.493]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:40.493]                     next
[10:22:40.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:40.493]                 }
[10:22:40.493]                 if (length(args) > 0) 
[10:22:40.493]                   base::do.call(base::Sys.setenv, args = args)
[10:22:40.493]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:40.493]             }
[10:22:40.493]             else {
[10:22:40.493]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:40.493]             }
[10:22:40.493]             {
[10:22:40.493]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:40.493]                   0L) {
[10:22:40.493]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:40.493]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:40.493]                   base::options(opts)
[10:22:40.493]                 }
[10:22:40.493]                 {
[10:22:40.493]                   {
[10:22:40.493]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:40.493]                     NULL
[10:22:40.493]                   }
[10:22:40.493]                   options(future.plan = NULL)
[10:22:40.493]                   if (is.na(NA_character_)) 
[10:22:40.493]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:40.493]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:40.493]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:40.493]                     .init = FALSE)
[10:22:40.493]                 }
[10:22:40.493]             }
[10:22:40.493]         }
[10:22:40.493]     })
[10:22:40.493]     if (TRUE) {
[10:22:40.493]         base::sink(type = "output", split = FALSE)
[10:22:40.493]         if (TRUE) {
[10:22:40.493]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:40.493]         }
[10:22:40.493]         else {
[10:22:40.493]             ...future.result["stdout"] <- base::list(NULL)
[10:22:40.493]         }
[10:22:40.493]         base::close(...future.stdout)
[10:22:40.493]         ...future.stdout <- NULL
[10:22:40.493]     }
[10:22:40.493]     ...future.result$conditions <- ...future.conditions
[10:22:40.493]     ...future.result$finished <- base::Sys.time()
[10:22:40.493]     ...future.result
[10:22:40.493] }
[10:22:40.496] MultisessionFuture started
[10:22:40.496] - Launch lazy future ... done
[10:22:40.496] run() for ‘MultisessionFuture’ ... done
[10:22:41.039] receiveMessageFromWorker() for ClusterFuture ...
[10:22:41.039] - Validating connection of MultisessionFuture
[10:22:41.039] - received message: FutureResult
[10:22:41.039] - Received FutureResult
[10:22:41.040] - Erased future from FutureRegistry
[10:22:41.040] result() for ClusterFuture ...
[10:22:41.040] - result already collected: FutureResult
[10:22:41.040] result() for ClusterFuture ... done
[10:22:41.040] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:41.040] A MultisessionFuture was resolved
[10:22:41.040] getGlobalsAndPackages() ...
[10:22:41.040] Searching for globals...
[10:22:41.041] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:22:41.041] Searching for globals ... DONE
[10:22:41.042] Resolving globals: FALSE
[10:22:41.042] 
[10:22:41.042] 
[10:22:41.042] getGlobalsAndPackages() ... DONE
[10:22:41.042] run() for ‘Future’ ...
[10:22:41.042] - state: ‘created’
[10:22:41.043] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:41.056] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:41.057] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:41.057]   - Field: ‘node’
[10:22:41.057]   - Field: ‘label’
[10:22:41.057]   - Field: ‘local’
[10:22:41.057]   - Field: ‘owner’
[10:22:41.057]   - Field: ‘envir’
[10:22:41.057]   - Field: ‘workers’
[10:22:41.057]   - Field: ‘packages’
[10:22:41.057]   - Field: ‘gc’
[10:22:41.057]   - Field: ‘conditions’
[10:22:41.057]   - Field: ‘persistent’
[10:22:41.058]   - Field: ‘expr’
[10:22:41.058]   - Field: ‘uuid’
[10:22:41.058]   - Field: ‘seed’
[10:22:41.058]   - Field: ‘version’
[10:22:41.058]   - Field: ‘result’
[10:22:41.058]   - Field: ‘asynchronous’
[10:22:41.058]   - Field: ‘calls’
[10:22:41.058]   - Field: ‘globals’
[10:22:41.058]   - Field: ‘stdout’
[10:22:41.058]   - Field: ‘earlySignal’
[10:22:41.058]   - Field: ‘lazy’
[10:22:41.058]   - Field: ‘state’
[10:22:41.059] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:41.059] - Launch lazy future ...
[10:22:41.059] Packages needed by the future expression (n = 0): <none>
[10:22:41.059] Packages needed by future strategies (n = 0): <none>
[10:22:41.059] {
[10:22:41.059]     {
[10:22:41.059]         {
[10:22:41.059]             ...future.startTime <- base::Sys.time()
[10:22:41.059]             {
[10:22:41.059]                 {
[10:22:41.059]                   {
[10:22:41.059]                     {
[10:22:41.059]                       base::local({
[10:22:41.059]                         has_future <- base::requireNamespace("future", 
[10:22:41.059]                           quietly = TRUE)
[10:22:41.059]                         if (has_future) {
[10:22:41.059]                           ns <- base::getNamespace("future")
[10:22:41.059]                           version <- ns[[".package"]][["version"]]
[10:22:41.059]                           if (is.null(version)) 
[10:22:41.059]                             version <- utils::packageVersion("future")
[10:22:41.059]                         }
[10:22:41.059]                         else {
[10:22:41.059]                           version <- NULL
[10:22:41.059]                         }
[10:22:41.059]                         if (!has_future || version < "1.8.0") {
[10:22:41.059]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:41.059]                             "", base::R.version$version.string), 
[10:22:41.059]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:41.059]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:41.059]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:41.059]                               "release", "version")], collapse = " "), 
[10:22:41.059]                             hostname = base::Sys.info()[["nodename"]])
[10:22:41.059]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:41.059]                             info)
[10:22:41.059]                           info <- base::paste(info, collapse = "; ")
[10:22:41.059]                           if (!has_future) {
[10:22:41.059]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:41.059]                               info)
[10:22:41.059]                           }
[10:22:41.059]                           else {
[10:22:41.059]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:41.059]                               info, version)
[10:22:41.059]                           }
[10:22:41.059]                           base::stop(msg)
[10:22:41.059]                         }
[10:22:41.059]                       })
[10:22:41.059]                     }
[10:22:41.059]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:41.059]                     base::options(mc.cores = 1L)
[10:22:41.059]                   }
[10:22:41.059]                   ...future.strategy.old <- future::plan("list")
[10:22:41.059]                   options(future.plan = NULL)
[10:22:41.059]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:41.059]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:41.059]                 }
[10:22:41.059]                 ...future.workdir <- getwd()
[10:22:41.059]             }
[10:22:41.059]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:41.059]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:41.059]         }
[10:22:41.059]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:41.059]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:41.059]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:41.059]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:41.059]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:41.059]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:41.059]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:41.059]             base::names(...future.oldOptions))
[10:22:41.059]     }
[10:22:41.059]     if (FALSE) {
[10:22:41.059]     }
[10:22:41.059]     else {
[10:22:41.059]         if (TRUE) {
[10:22:41.059]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:41.059]                 open = "w")
[10:22:41.059]         }
[10:22:41.059]         else {
[10:22:41.059]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:41.059]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:41.059]         }
[10:22:41.059]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:41.059]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:41.059]             base::sink(type = "output", split = FALSE)
[10:22:41.059]             base::close(...future.stdout)
[10:22:41.059]         }, add = TRUE)
[10:22:41.059]     }
[10:22:41.059]     ...future.frame <- base::sys.nframe()
[10:22:41.059]     ...future.conditions <- base::list()
[10:22:41.059]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:41.059]     if (FALSE) {
[10:22:41.059]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:41.059]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:41.059]     }
[10:22:41.059]     ...future.result <- base::tryCatch({
[10:22:41.059]         base::withCallingHandlers({
[10:22:41.059]             ...future.value <- base::withVisible(base::local({
[10:22:41.059]                 ...future.makeSendCondition <- base::local({
[10:22:41.059]                   sendCondition <- NULL
[10:22:41.059]                   function(frame = 1L) {
[10:22:41.059]                     if (is.function(sendCondition)) 
[10:22:41.059]                       return(sendCondition)
[10:22:41.059]                     ns <- getNamespace("parallel")
[10:22:41.059]                     if (exists("sendData", mode = "function", 
[10:22:41.059]                       envir = ns)) {
[10:22:41.059]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:41.059]                         envir = ns)
[10:22:41.059]                       envir <- sys.frame(frame)
[10:22:41.059]                       master <- NULL
[10:22:41.059]                       while (!identical(envir, .GlobalEnv) && 
[10:22:41.059]                         !identical(envir, emptyenv())) {
[10:22:41.059]                         if (exists("master", mode = "list", envir = envir, 
[10:22:41.059]                           inherits = FALSE)) {
[10:22:41.059]                           master <- get("master", mode = "list", 
[10:22:41.059]                             envir = envir, inherits = FALSE)
[10:22:41.059]                           if (inherits(master, c("SOCKnode", 
[10:22:41.059]                             "SOCK0node"))) {
[10:22:41.059]                             sendCondition <<- function(cond) {
[10:22:41.059]                               data <- list(type = "VALUE", value = cond, 
[10:22:41.059]                                 success = TRUE)
[10:22:41.059]                               parallel_sendData(master, data)
[10:22:41.059]                             }
[10:22:41.059]                             return(sendCondition)
[10:22:41.059]                           }
[10:22:41.059]                         }
[10:22:41.059]                         frame <- frame + 1L
[10:22:41.059]                         envir <- sys.frame(frame)
[10:22:41.059]                       }
[10:22:41.059]                     }
[10:22:41.059]                     sendCondition <<- function(cond) NULL
[10:22:41.059]                   }
[10:22:41.059]                 })
[10:22:41.059]                 withCallingHandlers({
[10:22:41.059]                   {
[10:22:41.059]                     Sys.sleep(0.5)
[10:22:41.059]                     list(a = 1, b = 42L)
[10:22:41.059]                   }
[10:22:41.059]                 }, immediateCondition = function(cond) {
[10:22:41.059]                   sendCondition <- ...future.makeSendCondition()
[10:22:41.059]                   sendCondition(cond)
[10:22:41.059]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:41.059]                   {
[10:22:41.059]                     inherits <- base::inherits
[10:22:41.059]                     invokeRestart <- base::invokeRestart
[10:22:41.059]                     is.null <- base::is.null
[10:22:41.059]                     muffled <- FALSE
[10:22:41.059]                     if (inherits(cond, "message")) {
[10:22:41.059]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:41.059]                       if (muffled) 
[10:22:41.059]                         invokeRestart("muffleMessage")
[10:22:41.059]                     }
[10:22:41.059]                     else if (inherits(cond, "warning")) {
[10:22:41.059]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:41.059]                       if (muffled) 
[10:22:41.059]                         invokeRestart("muffleWarning")
[10:22:41.059]                     }
[10:22:41.059]                     else if (inherits(cond, "condition")) {
[10:22:41.059]                       if (!is.null(pattern)) {
[10:22:41.059]                         computeRestarts <- base::computeRestarts
[10:22:41.059]                         grepl <- base::grepl
[10:22:41.059]                         restarts <- computeRestarts(cond)
[10:22:41.059]                         for (restart in restarts) {
[10:22:41.059]                           name <- restart$name
[10:22:41.059]                           if (is.null(name)) 
[10:22:41.059]                             next
[10:22:41.059]                           if (!grepl(pattern, name)) 
[10:22:41.059]                             next
[10:22:41.059]                           invokeRestart(restart)
[10:22:41.059]                           muffled <- TRUE
[10:22:41.059]                           break
[10:22:41.059]                         }
[10:22:41.059]                       }
[10:22:41.059]                     }
[10:22:41.059]                     invisible(muffled)
[10:22:41.059]                   }
[10:22:41.059]                   muffleCondition(cond)
[10:22:41.059]                 })
[10:22:41.059]             }))
[10:22:41.059]             future::FutureResult(value = ...future.value$value, 
[10:22:41.059]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:41.059]                   ...future.rng), globalenv = if (FALSE) 
[10:22:41.059]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:41.059]                     ...future.globalenv.names))
[10:22:41.059]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:41.059]         }, condition = base::local({
[10:22:41.059]             c <- base::c
[10:22:41.059]             inherits <- base::inherits
[10:22:41.059]             invokeRestart <- base::invokeRestart
[10:22:41.059]             length <- base::length
[10:22:41.059]             list <- base::list
[10:22:41.059]             seq.int <- base::seq.int
[10:22:41.059]             signalCondition <- base::signalCondition
[10:22:41.059]             sys.calls <- base::sys.calls
[10:22:41.059]             `[[` <- base::`[[`
[10:22:41.059]             `+` <- base::`+`
[10:22:41.059]             `<<-` <- base::`<<-`
[10:22:41.059]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:41.059]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:41.059]                   3L)]
[10:22:41.059]             }
[10:22:41.059]             function(cond) {
[10:22:41.059]                 is_error <- inherits(cond, "error")
[10:22:41.059]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:41.059]                   NULL)
[10:22:41.059]                 if (is_error) {
[10:22:41.059]                   sessionInformation <- function() {
[10:22:41.059]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:41.059]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:41.059]                       search = base::search(), system = base::Sys.info())
[10:22:41.059]                   }
[10:22:41.059]                   ...future.conditions[[length(...future.conditions) + 
[10:22:41.059]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:41.059]                     cond$call), session = sessionInformation(), 
[10:22:41.059]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:41.059]                   signalCondition(cond)
[10:22:41.059]                 }
[10:22:41.059]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:41.059]                 "immediateCondition"))) {
[10:22:41.059]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:41.059]                   ...future.conditions[[length(...future.conditions) + 
[10:22:41.059]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:41.059]                   if (TRUE && !signal) {
[10:22:41.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:41.059]                     {
[10:22:41.059]                       inherits <- base::inherits
[10:22:41.059]                       invokeRestart <- base::invokeRestart
[10:22:41.059]                       is.null <- base::is.null
[10:22:41.059]                       muffled <- FALSE
[10:22:41.059]                       if (inherits(cond, "message")) {
[10:22:41.059]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:41.059]                         if (muffled) 
[10:22:41.059]                           invokeRestart("muffleMessage")
[10:22:41.059]                       }
[10:22:41.059]                       else if (inherits(cond, "warning")) {
[10:22:41.059]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:41.059]                         if (muffled) 
[10:22:41.059]                           invokeRestart("muffleWarning")
[10:22:41.059]                       }
[10:22:41.059]                       else if (inherits(cond, "condition")) {
[10:22:41.059]                         if (!is.null(pattern)) {
[10:22:41.059]                           computeRestarts <- base::computeRestarts
[10:22:41.059]                           grepl <- base::grepl
[10:22:41.059]                           restarts <- computeRestarts(cond)
[10:22:41.059]                           for (restart in restarts) {
[10:22:41.059]                             name <- restart$name
[10:22:41.059]                             if (is.null(name)) 
[10:22:41.059]                               next
[10:22:41.059]                             if (!grepl(pattern, name)) 
[10:22:41.059]                               next
[10:22:41.059]                             invokeRestart(restart)
[10:22:41.059]                             muffled <- TRUE
[10:22:41.059]                             break
[10:22:41.059]                           }
[10:22:41.059]                         }
[10:22:41.059]                       }
[10:22:41.059]                       invisible(muffled)
[10:22:41.059]                     }
[10:22:41.059]                     muffleCondition(cond, pattern = "^muffle")
[10:22:41.059]                   }
[10:22:41.059]                 }
[10:22:41.059]                 else {
[10:22:41.059]                   if (TRUE) {
[10:22:41.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:41.059]                     {
[10:22:41.059]                       inherits <- base::inherits
[10:22:41.059]                       invokeRestart <- base::invokeRestart
[10:22:41.059]                       is.null <- base::is.null
[10:22:41.059]                       muffled <- FALSE
[10:22:41.059]                       if (inherits(cond, "message")) {
[10:22:41.059]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:41.059]                         if (muffled) 
[10:22:41.059]                           invokeRestart("muffleMessage")
[10:22:41.059]                       }
[10:22:41.059]                       else if (inherits(cond, "warning")) {
[10:22:41.059]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:41.059]                         if (muffled) 
[10:22:41.059]                           invokeRestart("muffleWarning")
[10:22:41.059]                       }
[10:22:41.059]                       else if (inherits(cond, "condition")) {
[10:22:41.059]                         if (!is.null(pattern)) {
[10:22:41.059]                           computeRestarts <- base::computeRestarts
[10:22:41.059]                           grepl <- base::grepl
[10:22:41.059]                           restarts <- computeRestarts(cond)
[10:22:41.059]                           for (restart in restarts) {
[10:22:41.059]                             name <- restart$name
[10:22:41.059]                             if (is.null(name)) 
[10:22:41.059]                               next
[10:22:41.059]                             if (!grepl(pattern, name)) 
[10:22:41.059]                               next
[10:22:41.059]                             invokeRestart(restart)
[10:22:41.059]                             muffled <- TRUE
[10:22:41.059]                             break
[10:22:41.059]                           }
[10:22:41.059]                         }
[10:22:41.059]                       }
[10:22:41.059]                       invisible(muffled)
[10:22:41.059]                     }
[10:22:41.059]                     muffleCondition(cond, pattern = "^muffle")
[10:22:41.059]                   }
[10:22:41.059]                 }
[10:22:41.059]             }
[10:22:41.059]         }))
[10:22:41.059]     }, error = function(ex) {
[10:22:41.059]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:41.059]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:41.059]                 ...future.rng), started = ...future.startTime, 
[10:22:41.059]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:41.059]             version = "1.8"), class = "FutureResult")
[10:22:41.059]     }, finally = {
[10:22:41.059]         if (!identical(...future.workdir, getwd())) 
[10:22:41.059]             setwd(...future.workdir)
[10:22:41.059]         {
[10:22:41.059]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:41.059]                 ...future.oldOptions$nwarnings <- NULL
[10:22:41.059]             }
[10:22:41.059]             base::options(...future.oldOptions)
[10:22:41.059]             if (.Platform$OS.type == "windows") {
[10:22:41.059]                 old_names <- names(...future.oldEnvVars)
[10:22:41.059]                 envs <- base::Sys.getenv()
[10:22:41.059]                 names <- names(envs)
[10:22:41.059]                 common <- intersect(names, old_names)
[10:22:41.059]                 added <- setdiff(names, old_names)
[10:22:41.059]                 removed <- setdiff(old_names, names)
[10:22:41.059]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:41.059]                   envs[common]]
[10:22:41.059]                 NAMES <- toupper(changed)
[10:22:41.059]                 args <- list()
[10:22:41.059]                 for (kk in seq_along(NAMES)) {
[10:22:41.059]                   name <- changed[[kk]]
[10:22:41.059]                   NAME <- NAMES[[kk]]
[10:22:41.059]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:41.059]                     next
[10:22:41.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:41.059]                 }
[10:22:41.059]                 NAMES <- toupper(added)
[10:22:41.059]                 for (kk in seq_along(NAMES)) {
[10:22:41.059]                   name <- added[[kk]]
[10:22:41.059]                   NAME <- NAMES[[kk]]
[10:22:41.059]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:41.059]                     next
[10:22:41.059]                   args[[name]] <- ""
[10:22:41.059]                 }
[10:22:41.059]                 NAMES <- toupper(removed)
[10:22:41.059]                 for (kk in seq_along(NAMES)) {
[10:22:41.059]                   name <- removed[[kk]]
[10:22:41.059]                   NAME <- NAMES[[kk]]
[10:22:41.059]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:41.059]                     next
[10:22:41.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:41.059]                 }
[10:22:41.059]                 if (length(args) > 0) 
[10:22:41.059]                   base::do.call(base::Sys.setenv, args = args)
[10:22:41.059]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:41.059]             }
[10:22:41.059]             else {
[10:22:41.059]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:41.059]             }
[10:22:41.059]             {
[10:22:41.059]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:41.059]                   0L) {
[10:22:41.059]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:41.059]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:41.059]                   base::options(opts)
[10:22:41.059]                 }
[10:22:41.059]                 {
[10:22:41.059]                   {
[10:22:41.059]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:41.059]                     NULL
[10:22:41.059]                   }
[10:22:41.059]                   options(future.plan = NULL)
[10:22:41.059]                   if (is.na(NA_character_)) 
[10:22:41.059]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:41.059]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:41.059]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:41.059]                     .init = FALSE)
[10:22:41.059]                 }
[10:22:41.059]             }
[10:22:41.059]         }
[10:22:41.059]     })
[10:22:41.059]     if (TRUE) {
[10:22:41.059]         base::sink(type = "output", split = FALSE)
[10:22:41.059]         if (TRUE) {
[10:22:41.059]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:41.059]         }
[10:22:41.059]         else {
[10:22:41.059]             ...future.result["stdout"] <- base::list(NULL)
[10:22:41.059]         }
[10:22:41.059]         base::close(...future.stdout)
[10:22:41.059]         ...future.stdout <- NULL
[10:22:41.059]     }
[10:22:41.059]     ...future.result$conditions <- ...future.conditions
[10:22:41.059]     ...future.result$finished <- base::Sys.time()
[10:22:41.059]     ...future.result
[10:22:41.059] }
[10:22:41.063] MultisessionFuture started
[10:22:41.063] - Launch lazy future ... done
[10:22:41.063] run() for ‘MultisessionFuture’ ... done
[10:22:41.606] receiveMessageFromWorker() for ClusterFuture ...
[10:22:41.606] - Validating connection of MultisessionFuture
[10:22:41.606] - received message: FutureResult
[10:22:41.607] - Received FutureResult
[10:22:41.607] - Erased future from FutureRegistry
[10:22:41.607] result() for ClusterFuture ...
[10:22:41.607] - result already collected: FutureResult
[10:22:41.607] result() for ClusterFuture ... done
[10:22:41.607] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:41.607] A MultisessionFuture was resolved
- w/ exception ...
[10:22:41.607] getGlobalsAndPackages() ...
[10:22:41.607] Searching for globals...
[10:22:41.608] - globals found: [2] ‘list’, ‘stop’
[10:22:41.608] Searching for globals ... DONE
[10:22:41.608] Resolving globals: FALSE
[10:22:41.609] 
[10:22:41.609] 
[10:22:41.609] getGlobalsAndPackages() ... DONE
[10:22:41.609] run() for ‘Future’ ...
[10:22:41.609] - state: ‘created’
[10:22:41.609] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:41.623] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:41.623] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:41.623]   - Field: ‘node’
[10:22:41.623]   - Field: ‘label’
[10:22:41.623]   - Field: ‘local’
[10:22:41.624]   - Field: ‘owner’
[10:22:41.624]   - Field: ‘envir’
[10:22:41.624]   - Field: ‘workers’
[10:22:41.624]   - Field: ‘packages’
[10:22:41.624]   - Field: ‘gc’
[10:22:41.624]   - Field: ‘conditions’
[10:22:41.624]   - Field: ‘persistent’
[10:22:41.624]   - Field: ‘expr’
[10:22:41.624]   - Field: ‘uuid’
[10:22:41.624]   - Field: ‘seed’
[10:22:41.624]   - Field: ‘version’
[10:22:41.624]   - Field: ‘result’
[10:22:41.625]   - Field: ‘asynchronous’
[10:22:41.625]   - Field: ‘calls’
[10:22:41.625]   - Field: ‘globals’
[10:22:41.625]   - Field: ‘stdout’
[10:22:41.625]   - Field: ‘earlySignal’
[10:22:41.625]   - Field: ‘lazy’
[10:22:41.625]   - Field: ‘state’
[10:22:41.625] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:41.625] - Launch lazy future ...
[10:22:41.626] Packages needed by the future expression (n = 0): <none>
[10:22:41.626] Packages needed by future strategies (n = 0): <none>
[10:22:41.626] {
[10:22:41.626]     {
[10:22:41.626]         {
[10:22:41.626]             ...future.startTime <- base::Sys.time()
[10:22:41.626]             {
[10:22:41.626]                 {
[10:22:41.626]                   {
[10:22:41.626]                     {
[10:22:41.626]                       base::local({
[10:22:41.626]                         has_future <- base::requireNamespace("future", 
[10:22:41.626]                           quietly = TRUE)
[10:22:41.626]                         if (has_future) {
[10:22:41.626]                           ns <- base::getNamespace("future")
[10:22:41.626]                           version <- ns[[".package"]][["version"]]
[10:22:41.626]                           if (is.null(version)) 
[10:22:41.626]                             version <- utils::packageVersion("future")
[10:22:41.626]                         }
[10:22:41.626]                         else {
[10:22:41.626]                           version <- NULL
[10:22:41.626]                         }
[10:22:41.626]                         if (!has_future || version < "1.8.0") {
[10:22:41.626]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:41.626]                             "", base::R.version$version.string), 
[10:22:41.626]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:41.626]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:41.626]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:41.626]                               "release", "version")], collapse = " "), 
[10:22:41.626]                             hostname = base::Sys.info()[["nodename"]])
[10:22:41.626]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:41.626]                             info)
[10:22:41.626]                           info <- base::paste(info, collapse = "; ")
[10:22:41.626]                           if (!has_future) {
[10:22:41.626]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:41.626]                               info)
[10:22:41.626]                           }
[10:22:41.626]                           else {
[10:22:41.626]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:41.626]                               info, version)
[10:22:41.626]                           }
[10:22:41.626]                           base::stop(msg)
[10:22:41.626]                         }
[10:22:41.626]                       })
[10:22:41.626]                     }
[10:22:41.626]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:41.626]                     base::options(mc.cores = 1L)
[10:22:41.626]                   }
[10:22:41.626]                   ...future.strategy.old <- future::plan("list")
[10:22:41.626]                   options(future.plan = NULL)
[10:22:41.626]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:41.626]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:41.626]                 }
[10:22:41.626]                 ...future.workdir <- getwd()
[10:22:41.626]             }
[10:22:41.626]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:41.626]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:41.626]         }
[10:22:41.626]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:41.626]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:41.626]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:41.626]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:41.626]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:41.626]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:41.626]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:41.626]             base::names(...future.oldOptions))
[10:22:41.626]     }
[10:22:41.626]     if (FALSE) {
[10:22:41.626]     }
[10:22:41.626]     else {
[10:22:41.626]         if (TRUE) {
[10:22:41.626]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:41.626]                 open = "w")
[10:22:41.626]         }
[10:22:41.626]         else {
[10:22:41.626]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:41.626]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:41.626]         }
[10:22:41.626]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:41.626]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:41.626]             base::sink(type = "output", split = FALSE)
[10:22:41.626]             base::close(...future.stdout)
[10:22:41.626]         }, add = TRUE)
[10:22:41.626]     }
[10:22:41.626]     ...future.frame <- base::sys.nframe()
[10:22:41.626]     ...future.conditions <- base::list()
[10:22:41.626]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:41.626]     if (FALSE) {
[10:22:41.626]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:41.626]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:41.626]     }
[10:22:41.626]     ...future.result <- base::tryCatch({
[10:22:41.626]         base::withCallingHandlers({
[10:22:41.626]             ...future.value <- base::withVisible(base::local({
[10:22:41.626]                 ...future.makeSendCondition <- base::local({
[10:22:41.626]                   sendCondition <- NULL
[10:22:41.626]                   function(frame = 1L) {
[10:22:41.626]                     if (is.function(sendCondition)) 
[10:22:41.626]                       return(sendCondition)
[10:22:41.626]                     ns <- getNamespace("parallel")
[10:22:41.626]                     if (exists("sendData", mode = "function", 
[10:22:41.626]                       envir = ns)) {
[10:22:41.626]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:41.626]                         envir = ns)
[10:22:41.626]                       envir <- sys.frame(frame)
[10:22:41.626]                       master <- NULL
[10:22:41.626]                       while (!identical(envir, .GlobalEnv) && 
[10:22:41.626]                         !identical(envir, emptyenv())) {
[10:22:41.626]                         if (exists("master", mode = "list", envir = envir, 
[10:22:41.626]                           inherits = FALSE)) {
[10:22:41.626]                           master <- get("master", mode = "list", 
[10:22:41.626]                             envir = envir, inherits = FALSE)
[10:22:41.626]                           if (inherits(master, c("SOCKnode", 
[10:22:41.626]                             "SOCK0node"))) {
[10:22:41.626]                             sendCondition <<- function(cond) {
[10:22:41.626]                               data <- list(type = "VALUE", value = cond, 
[10:22:41.626]                                 success = TRUE)
[10:22:41.626]                               parallel_sendData(master, data)
[10:22:41.626]                             }
[10:22:41.626]                             return(sendCondition)
[10:22:41.626]                           }
[10:22:41.626]                         }
[10:22:41.626]                         frame <- frame + 1L
[10:22:41.626]                         envir <- sys.frame(frame)
[10:22:41.626]                       }
[10:22:41.626]                     }
[10:22:41.626]                     sendCondition <<- function(cond) NULL
[10:22:41.626]                   }
[10:22:41.626]                 })
[10:22:41.626]                 withCallingHandlers({
[10:22:41.626]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:22:41.626]                 }, immediateCondition = function(cond) {
[10:22:41.626]                   sendCondition <- ...future.makeSendCondition()
[10:22:41.626]                   sendCondition(cond)
[10:22:41.626]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:41.626]                   {
[10:22:41.626]                     inherits <- base::inherits
[10:22:41.626]                     invokeRestart <- base::invokeRestart
[10:22:41.626]                     is.null <- base::is.null
[10:22:41.626]                     muffled <- FALSE
[10:22:41.626]                     if (inherits(cond, "message")) {
[10:22:41.626]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:41.626]                       if (muffled) 
[10:22:41.626]                         invokeRestart("muffleMessage")
[10:22:41.626]                     }
[10:22:41.626]                     else if (inherits(cond, "warning")) {
[10:22:41.626]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:41.626]                       if (muffled) 
[10:22:41.626]                         invokeRestart("muffleWarning")
[10:22:41.626]                     }
[10:22:41.626]                     else if (inherits(cond, "condition")) {
[10:22:41.626]                       if (!is.null(pattern)) {
[10:22:41.626]                         computeRestarts <- base::computeRestarts
[10:22:41.626]                         grepl <- base::grepl
[10:22:41.626]                         restarts <- computeRestarts(cond)
[10:22:41.626]                         for (restart in restarts) {
[10:22:41.626]                           name <- restart$name
[10:22:41.626]                           if (is.null(name)) 
[10:22:41.626]                             next
[10:22:41.626]                           if (!grepl(pattern, name)) 
[10:22:41.626]                             next
[10:22:41.626]                           invokeRestart(restart)
[10:22:41.626]                           muffled <- TRUE
[10:22:41.626]                           break
[10:22:41.626]                         }
[10:22:41.626]                       }
[10:22:41.626]                     }
[10:22:41.626]                     invisible(muffled)
[10:22:41.626]                   }
[10:22:41.626]                   muffleCondition(cond)
[10:22:41.626]                 })
[10:22:41.626]             }))
[10:22:41.626]             future::FutureResult(value = ...future.value$value, 
[10:22:41.626]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:41.626]                   ...future.rng), globalenv = if (FALSE) 
[10:22:41.626]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:41.626]                     ...future.globalenv.names))
[10:22:41.626]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:41.626]         }, condition = base::local({
[10:22:41.626]             c <- base::c
[10:22:41.626]             inherits <- base::inherits
[10:22:41.626]             invokeRestart <- base::invokeRestart
[10:22:41.626]             length <- base::length
[10:22:41.626]             list <- base::list
[10:22:41.626]             seq.int <- base::seq.int
[10:22:41.626]             signalCondition <- base::signalCondition
[10:22:41.626]             sys.calls <- base::sys.calls
[10:22:41.626]             `[[` <- base::`[[`
[10:22:41.626]             `+` <- base::`+`
[10:22:41.626]             `<<-` <- base::`<<-`
[10:22:41.626]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:41.626]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:41.626]                   3L)]
[10:22:41.626]             }
[10:22:41.626]             function(cond) {
[10:22:41.626]                 is_error <- inherits(cond, "error")
[10:22:41.626]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:41.626]                   NULL)
[10:22:41.626]                 if (is_error) {
[10:22:41.626]                   sessionInformation <- function() {
[10:22:41.626]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:41.626]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:41.626]                       search = base::search(), system = base::Sys.info())
[10:22:41.626]                   }
[10:22:41.626]                   ...future.conditions[[length(...future.conditions) + 
[10:22:41.626]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:41.626]                     cond$call), session = sessionInformation(), 
[10:22:41.626]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:41.626]                   signalCondition(cond)
[10:22:41.626]                 }
[10:22:41.626]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:41.626]                 "immediateCondition"))) {
[10:22:41.626]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:41.626]                   ...future.conditions[[length(...future.conditions) + 
[10:22:41.626]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:41.626]                   if (TRUE && !signal) {
[10:22:41.626]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:41.626]                     {
[10:22:41.626]                       inherits <- base::inherits
[10:22:41.626]                       invokeRestart <- base::invokeRestart
[10:22:41.626]                       is.null <- base::is.null
[10:22:41.626]                       muffled <- FALSE
[10:22:41.626]                       if (inherits(cond, "message")) {
[10:22:41.626]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:41.626]                         if (muffled) 
[10:22:41.626]                           invokeRestart("muffleMessage")
[10:22:41.626]                       }
[10:22:41.626]                       else if (inherits(cond, "warning")) {
[10:22:41.626]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:41.626]                         if (muffled) 
[10:22:41.626]                           invokeRestart("muffleWarning")
[10:22:41.626]                       }
[10:22:41.626]                       else if (inherits(cond, "condition")) {
[10:22:41.626]                         if (!is.null(pattern)) {
[10:22:41.626]                           computeRestarts <- base::computeRestarts
[10:22:41.626]                           grepl <- base::grepl
[10:22:41.626]                           restarts <- computeRestarts(cond)
[10:22:41.626]                           for (restart in restarts) {
[10:22:41.626]                             name <- restart$name
[10:22:41.626]                             if (is.null(name)) 
[10:22:41.626]                               next
[10:22:41.626]                             if (!grepl(pattern, name)) 
[10:22:41.626]                               next
[10:22:41.626]                             invokeRestart(restart)
[10:22:41.626]                             muffled <- TRUE
[10:22:41.626]                             break
[10:22:41.626]                           }
[10:22:41.626]                         }
[10:22:41.626]                       }
[10:22:41.626]                       invisible(muffled)
[10:22:41.626]                     }
[10:22:41.626]                     muffleCondition(cond, pattern = "^muffle")
[10:22:41.626]                   }
[10:22:41.626]                 }
[10:22:41.626]                 else {
[10:22:41.626]                   if (TRUE) {
[10:22:41.626]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:41.626]                     {
[10:22:41.626]                       inherits <- base::inherits
[10:22:41.626]                       invokeRestart <- base::invokeRestart
[10:22:41.626]                       is.null <- base::is.null
[10:22:41.626]                       muffled <- FALSE
[10:22:41.626]                       if (inherits(cond, "message")) {
[10:22:41.626]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:41.626]                         if (muffled) 
[10:22:41.626]                           invokeRestart("muffleMessage")
[10:22:41.626]                       }
[10:22:41.626]                       else if (inherits(cond, "warning")) {
[10:22:41.626]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:41.626]                         if (muffled) 
[10:22:41.626]                           invokeRestart("muffleWarning")
[10:22:41.626]                       }
[10:22:41.626]                       else if (inherits(cond, "condition")) {
[10:22:41.626]                         if (!is.null(pattern)) {
[10:22:41.626]                           computeRestarts <- base::computeRestarts
[10:22:41.626]                           grepl <- base::grepl
[10:22:41.626]                           restarts <- computeRestarts(cond)
[10:22:41.626]                           for (restart in restarts) {
[10:22:41.626]                             name <- restart$name
[10:22:41.626]                             if (is.null(name)) 
[10:22:41.626]                               next
[10:22:41.626]                             if (!grepl(pattern, name)) 
[10:22:41.626]                               next
[10:22:41.626]                             invokeRestart(restart)
[10:22:41.626]                             muffled <- TRUE
[10:22:41.626]                             break
[10:22:41.626]                           }
[10:22:41.626]                         }
[10:22:41.626]                       }
[10:22:41.626]                       invisible(muffled)
[10:22:41.626]                     }
[10:22:41.626]                     muffleCondition(cond, pattern = "^muffle")
[10:22:41.626]                   }
[10:22:41.626]                 }
[10:22:41.626]             }
[10:22:41.626]         }))
[10:22:41.626]     }, error = function(ex) {
[10:22:41.626]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:41.626]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:41.626]                 ...future.rng), started = ...future.startTime, 
[10:22:41.626]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:41.626]             version = "1.8"), class = "FutureResult")
[10:22:41.626]     }, finally = {
[10:22:41.626]         if (!identical(...future.workdir, getwd())) 
[10:22:41.626]             setwd(...future.workdir)
[10:22:41.626]         {
[10:22:41.626]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:41.626]                 ...future.oldOptions$nwarnings <- NULL
[10:22:41.626]             }
[10:22:41.626]             base::options(...future.oldOptions)
[10:22:41.626]             if (.Platform$OS.type == "windows") {
[10:22:41.626]                 old_names <- names(...future.oldEnvVars)
[10:22:41.626]                 envs <- base::Sys.getenv()
[10:22:41.626]                 names <- names(envs)
[10:22:41.626]                 common <- intersect(names, old_names)
[10:22:41.626]                 added <- setdiff(names, old_names)
[10:22:41.626]                 removed <- setdiff(old_names, names)
[10:22:41.626]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:41.626]                   envs[common]]
[10:22:41.626]                 NAMES <- toupper(changed)
[10:22:41.626]                 args <- list()
[10:22:41.626]                 for (kk in seq_along(NAMES)) {
[10:22:41.626]                   name <- changed[[kk]]
[10:22:41.626]                   NAME <- NAMES[[kk]]
[10:22:41.626]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:41.626]                     next
[10:22:41.626]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:41.626]                 }
[10:22:41.626]                 NAMES <- toupper(added)
[10:22:41.626]                 for (kk in seq_along(NAMES)) {
[10:22:41.626]                   name <- added[[kk]]
[10:22:41.626]                   NAME <- NAMES[[kk]]
[10:22:41.626]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:41.626]                     next
[10:22:41.626]                   args[[name]] <- ""
[10:22:41.626]                 }
[10:22:41.626]                 NAMES <- toupper(removed)
[10:22:41.626]                 for (kk in seq_along(NAMES)) {
[10:22:41.626]                   name <- removed[[kk]]
[10:22:41.626]                   NAME <- NAMES[[kk]]
[10:22:41.626]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:41.626]                     next
[10:22:41.626]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:41.626]                 }
[10:22:41.626]                 if (length(args) > 0) 
[10:22:41.626]                   base::do.call(base::Sys.setenv, args = args)
[10:22:41.626]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:41.626]             }
[10:22:41.626]             else {
[10:22:41.626]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:41.626]             }
[10:22:41.626]             {
[10:22:41.626]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:41.626]                   0L) {
[10:22:41.626]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:41.626]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:41.626]                   base::options(opts)
[10:22:41.626]                 }
[10:22:41.626]                 {
[10:22:41.626]                   {
[10:22:41.626]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:41.626]                     NULL
[10:22:41.626]                   }
[10:22:41.626]                   options(future.plan = NULL)
[10:22:41.626]                   if (is.na(NA_character_)) 
[10:22:41.626]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:41.626]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:41.626]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:41.626]                     .init = FALSE)
[10:22:41.626]                 }
[10:22:41.626]             }
[10:22:41.626]         }
[10:22:41.626]     })
[10:22:41.626]     if (TRUE) {
[10:22:41.626]         base::sink(type = "output", split = FALSE)
[10:22:41.626]         if (TRUE) {
[10:22:41.626]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:41.626]         }
[10:22:41.626]         else {
[10:22:41.626]             ...future.result["stdout"] <- base::list(NULL)
[10:22:41.626]         }
[10:22:41.626]         base::close(...future.stdout)
[10:22:41.626]         ...future.stdout <- NULL
[10:22:41.626]     }
[10:22:41.626]     ...future.result$conditions <- ...future.conditions
[10:22:41.626]     ...future.result$finished <- base::Sys.time()
[10:22:41.626]     ...future.result
[10:22:41.626] }
[10:22:41.629] MultisessionFuture started
[10:22:41.629] - Launch lazy future ... done
[10:22:41.629] run() for ‘MultisessionFuture’ ... done
[10:22:41.671] receiveMessageFromWorker() for ClusterFuture ...
[10:22:41.672] - Validating connection of MultisessionFuture
[10:22:41.672] - received message: FutureResult
[10:22:41.672] - Received FutureResult
[10:22:41.672] - Erased future from FutureRegistry
[10:22:41.672] result() for ClusterFuture ...
[10:22:41.672] - result already collected: FutureResult
[10:22:41.673] result() for ClusterFuture ... done
[10:22:41.673] signalConditions() ...
[10:22:41.673]  - include = ‘immediateCondition’
[10:22:41.673]  - exclude = 
[10:22:41.673]  - resignal = FALSE
[10:22:41.673]  - Number of conditions: 1
[10:22:41.673] signalConditions() ... done
[10:22:41.673] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:41.673] A MultisessionFuture was resolved
[10:22:41.673] getGlobalsAndPackages() ...
[10:22:41.673] Searching for globals...
[10:22:41.674] - globals found: [2] ‘list’, ‘stop’
[10:22:41.674] Searching for globals ... DONE
[10:22:41.674] Resolving globals: FALSE
[10:22:41.675] 
[10:22:41.675] 
[10:22:41.675] getGlobalsAndPackages() ... DONE
[10:22:41.675] run() for ‘Future’ ...
[10:22:41.675] - state: ‘created’
[10:22:41.675] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:41.689] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:41.689] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:41.689]   - Field: ‘node’
[10:22:41.689]   - Field: ‘label’
[10:22:41.690]   - Field: ‘local’
[10:22:41.690]   - Field: ‘owner’
[10:22:41.690]   - Field: ‘envir’
[10:22:41.690]   - Field: ‘workers’
[10:22:41.690]   - Field: ‘packages’
[10:22:41.690]   - Field: ‘gc’
[10:22:41.690]   - Field: ‘conditions’
[10:22:41.690]   - Field: ‘persistent’
[10:22:41.690]   - Field: ‘expr’
[10:22:41.690]   - Field: ‘uuid’
[10:22:41.690]   - Field: ‘seed’
[10:22:41.690]   - Field: ‘version’
[10:22:41.691]   - Field: ‘result’
[10:22:41.691]   - Field: ‘asynchronous’
[10:22:41.691]   - Field: ‘calls’
[10:22:41.691]   - Field: ‘globals’
[10:22:41.691]   - Field: ‘stdout’
[10:22:41.691]   - Field: ‘earlySignal’
[10:22:41.691]   - Field: ‘lazy’
[10:22:41.691]   - Field: ‘state’
[10:22:41.691] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:41.691] - Launch lazy future ...
[10:22:41.692] Packages needed by the future expression (n = 0): <none>
[10:22:41.692] Packages needed by future strategies (n = 0): <none>
[10:22:41.692] {
[10:22:41.692]     {
[10:22:41.692]         {
[10:22:41.692]             ...future.startTime <- base::Sys.time()
[10:22:41.692]             {
[10:22:41.692]                 {
[10:22:41.692]                   {
[10:22:41.692]                     {
[10:22:41.692]                       base::local({
[10:22:41.692]                         has_future <- base::requireNamespace("future", 
[10:22:41.692]                           quietly = TRUE)
[10:22:41.692]                         if (has_future) {
[10:22:41.692]                           ns <- base::getNamespace("future")
[10:22:41.692]                           version <- ns[[".package"]][["version"]]
[10:22:41.692]                           if (is.null(version)) 
[10:22:41.692]                             version <- utils::packageVersion("future")
[10:22:41.692]                         }
[10:22:41.692]                         else {
[10:22:41.692]                           version <- NULL
[10:22:41.692]                         }
[10:22:41.692]                         if (!has_future || version < "1.8.0") {
[10:22:41.692]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:41.692]                             "", base::R.version$version.string), 
[10:22:41.692]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:41.692]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:41.692]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:41.692]                               "release", "version")], collapse = " "), 
[10:22:41.692]                             hostname = base::Sys.info()[["nodename"]])
[10:22:41.692]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:41.692]                             info)
[10:22:41.692]                           info <- base::paste(info, collapse = "; ")
[10:22:41.692]                           if (!has_future) {
[10:22:41.692]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:41.692]                               info)
[10:22:41.692]                           }
[10:22:41.692]                           else {
[10:22:41.692]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:41.692]                               info, version)
[10:22:41.692]                           }
[10:22:41.692]                           base::stop(msg)
[10:22:41.692]                         }
[10:22:41.692]                       })
[10:22:41.692]                     }
[10:22:41.692]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:41.692]                     base::options(mc.cores = 1L)
[10:22:41.692]                   }
[10:22:41.692]                   ...future.strategy.old <- future::plan("list")
[10:22:41.692]                   options(future.plan = NULL)
[10:22:41.692]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:41.692]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:41.692]                 }
[10:22:41.692]                 ...future.workdir <- getwd()
[10:22:41.692]             }
[10:22:41.692]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:41.692]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:41.692]         }
[10:22:41.692]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:41.692]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:41.692]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:41.692]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:41.692]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:41.692]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:41.692]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:41.692]             base::names(...future.oldOptions))
[10:22:41.692]     }
[10:22:41.692]     if (FALSE) {
[10:22:41.692]     }
[10:22:41.692]     else {
[10:22:41.692]         if (TRUE) {
[10:22:41.692]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:41.692]                 open = "w")
[10:22:41.692]         }
[10:22:41.692]         else {
[10:22:41.692]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:41.692]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:41.692]         }
[10:22:41.692]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:41.692]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:41.692]             base::sink(type = "output", split = FALSE)
[10:22:41.692]             base::close(...future.stdout)
[10:22:41.692]         }, add = TRUE)
[10:22:41.692]     }
[10:22:41.692]     ...future.frame <- base::sys.nframe()
[10:22:41.692]     ...future.conditions <- base::list()
[10:22:41.692]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:41.692]     if (FALSE) {
[10:22:41.692]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:41.692]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:41.692]     }
[10:22:41.692]     ...future.result <- base::tryCatch({
[10:22:41.692]         base::withCallingHandlers({
[10:22:41.692]             ...future.value <- base::withVisible(base::local({
[10:22:41.692]                 ...future.makeSendCondition <- base::local({
[10:22:41.692]                   sendCondition <- NULL
[10:22:41.692]                   function(frame = 1L) {
[10:22:41.692]                     if (is.function(sendCondition)) 
[10:22:41.692]                       return(sendCondition)
[10:22:41.692]                     ns <- getNamespace("parallel")
[10:22:41.692]                     if (exists("sendData", mode = "function", 
[10:22:41.692]                       envir = ns)) {
[10:22:41.692]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:41.692]                         envir = ns)
[10:22:41.692]                       envir <- sys.frame(frame)
[10:22:41.692]                       master <- NULL
[10:22:41.692]                       while (!identical(envir, .GlobalEnv) && 
[10:22:41.692]                         !identical(envir, emptyenv())) {
[10:22:41.692]                         if (exists("master", mode = "list", envir = envir, 
[10:22:41.692]                           inherits = FALSE)) {
[10:22:41.692]                           master <- get("master", mode = "list", 
[10:22:41.692]                             envir = envir, inherits = FALSE)
[10:22:41.692]                           if (inherits(master, c("SOCKnode", 
[10:22:41.692]                             "SOCK0node"))) {
[10:22:41.692]                             sendCondition <<- function(cond) {
[10:22:41.692]                               data <- list(type = "VALUE", value = cond, 
[10:22:41.692]                                 success = TRUE)
[10:22:41.692]                               parallel_sendData(master, data)
[10:22:41.692]                             }
[10:22:41.692]                             return(sendCondition)
[10:22:41.692]                           }
[10:22:41.692]                         }
[10:22:41.692]                         frame <- frame + 1L
[10:22:41.692]                         envir <- sys.frame(frame)
[10:22:41.692]                       }
[10:22:41.692]                     }
[10:22:41.692]                     sendCondition <<- function(cond) NULL
[10:22:41.692]                   }
[10:22:41.692]                 })
[10:22:41.692]                 withCallingHandlers({
[10:22:41.692]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:22:41.692]                 }, immediateCondition = function(cond) {
[10:22:41.692]                   sendCondition <- ...future.makeSendCondition()
[10:22:41.692]                   sendCondition(cond)
[10:22:41.692]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:41.692]                   {
[10:22:41.692]                     inherits <- base::inherits
[10:22:41.692]                     invokeRestart <- base::invokeRestart
[10:22:41.692]                     is.null <- base::is.null
[10:22:41.692]                     muffled <- FALSE
[10:22:41.692]                     if (inherits(cond, "message")) {
[10:22:41.692]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:41.692]                       if (muffled) 
[10:22:41.692]                         invokeRestart("muffleMessage")
[10:22:41.692]                     }
[10:22:41.692]                     else if (inherits(cond, "warning")) {
[10:22:41.692]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:41.692]                       if (muffled) 
[10:22:41.692]                         invokeRestart("muffleWarning")
[10:22:41.692]                     }
[10:22:41.692]                     else if (inherits(cond, "condition")) {
[10:22:41.692]                       if (!is.null(pattern)) {
[10:22:41.692]                         computeRestarts <- base::computeRestarts
[10:22:41.692]                         grepl <- base::grepl
[10:22:41.692]                         restarts <- computeRestarts(cond)
[10:22:41.692]                         for (restart in restarts) {
[10:22:41.692]                           name <- restart$name
[10:22:41.692]                           if (is.null(name)) 
[10:22:41.692]                             next
[10:22:41.692]                           if (!grepl(pattern, name)) 
[10:22:41.692]                             next
[10:22:41.692]                           invokeRestart(restart)
[10:22:41.692]                           muffled <- TRUE
[10:22:41.692]                           break
[10:22:41.692]                         }
[10:22:41.692]                       }
[10:22:41.692]                     }
[10:22:41.692]                     invisible(muffled)
[10:22:41.692]                   }
[10:22:41.692]                   muffleCondition(cond)
[10:22:41.692]                 })
[10:22:41.692]             }))
[10:22:41.692]             future::FutureResult(value = ...future.value$value, 
[10:22:41.692]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:41.692]                   ...future.rng), globalenv = if (FALSE) 
[10:22:41.692]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:41.692]                     ...future.globalenv.names))
[10:22:41.692]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:41.692]         }, condition = base::local({
[10:22:41.692]             c <- base::c
[10:22:41.692]             inherits <- base::inherits
[10:22:41.692]             invokeRestart <- base::invokeRestart
[10:22:41.692]             length <- base::length
[10:22:41.692]             list <- base::list
[10:22:41.692]             seq.int <- base::seq.int
[10:22:41.692]             signalCondition <- base::signalCondition
[10:22:41.692]             sys.calls <- base::sys.calls
[10:22:41.692]             `[[` <- base::`[[`
[10:22:41.692]             `+` <- base::`+`
[10:22:41.692]             `<<-` <- base::`<<-`
[10:22:41.692]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:41.692]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:41.692]                   3L)]
[10:22:41.692]             }
[10:22:41.692]             function(cond) {
[10:22:41.692]                 is_error <- inherits(cond, "error")
[10:22:41.692]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:41.692]                   NULL)
[10:22:41.692]                 if (is_error) {
[10:22:41.692]                   sessionInformation <- function() {
[10:22:41.692]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:41.692]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:41.692]                       search = base::search(), system = base::Sys.info())
[10:22:41.692]                   }
[10:22:41.692]                   ...future.conditions[[length(...future.conditions) + 
[10:22:41.692]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:41.692]                     cond$call), session = sessionInformation(), 
[10:22:41.692]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:41.692]                   signalCondition(cond)
[10:22:41.692]                 }
[10:22:41.692]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:41.692]                 "immediateCondition"))) {
[10:22:41.692]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:41.692]                   ...future.conditions[[length(...future.conditions) + 
[10:22:41.692]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:41.692]                   if (TRUE && !signal) {
[10:22:41.692]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:41.692]                     {
[10:22:41.692]                       inherits <- base::inherits
[10:22:41.692]                       invokeRestart <- base::invokeRestart
[10:22:41.692]                       is.null <- base::is.null
[10:22:41.692]                       muffled <- FALSE
[10:22:41.692]                       if (inherits(cond, "message")) {
[10:22:41.692]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:41.692]                         if (muffled) 
[10:22:41.692]                           invokeRestart("muffleMessage")
[10:22:41.692]                       }
[10:22:41.692]                       else if (inherits(cond, "warning")) {
[10:22:41.692]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:41.692]                         if (muffled) 
[10:22:41.692]                           invokeRestart("muffleWarning")
[10:22:41.692]                       }
[10:22:41.692]                       else if (inherits(cond, "condition")) {
[10:22:41.692]                         if (!is.null(pattern)) {
[10:22:41.692]                           computeRestarts <- base::computeRestarts
[10:22:41.692]                           grepl <- base::grepl
[10:22:41.692]                           restarts <- computeRestarts(cond)
[10:22:41.692]                           for (restart in restarts) {
[10:22:41.692]                             name <- restart$name
[10:22:41.692]                             if (is.null(name)) 
[10:22:41.692]                               next
[10:22:41.692]                             if (!grepl(pattern, name)) 
[10:22:41.692]                               next
[10:22:41.692]                             invokeRestart(restart)
[10:22:41.692]                             muffled <- TRUE
[10:22:41.692]                             break
[10:22:41.692]                           }
[10:22:41.692]                         }
[10:22:41.692]                       }
[10:22:41.692]                       invisible(muffled)
[10:22:41.692]                     }
[10:22:41.692]                     muffleCondition(cond, pattern = "^muffle")
[10:22:41.692]                   }
[10:22:41.692]                 }
[10:22:41.692]                 else {
[10:22:41.692]                   if (TRUE) {
[10:22:41.692]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:41.692]                     {
[10:22:41.692]                       inherits <- base::inherits
[10:22:41.692]                       invokeRestart <- base::invokeRestart
[10:22:41.692]                       is.null <- base::is.null
[10:22:41.692]                       muffled <- FALSE
[10:22:41.692]                       if (inherits(cond, "message")) {
[10:22:41.692]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:41.692]                         if (muffled) 
[10:22:41.692]                           invokeRestart("muffleMessage")
[10:22:41.692]                       }
[10:22:41.692]                       else if (inherits(cond, "warning")) {
[10:22:41.692]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:41.692]                         if (muffled) 
[10:22:41.692]                           invokeRestart("muffleWarning")
[10:22:41.692]                       }
[10:22:41.692]                       else if (inherits(cond, "condition")) {
[10:22:41.692]                         if (!is.null(pattern)) {
[10:22:41.692]                           computeRestarts <- base::computeRestarts
[10:22:41.692]                           grepl <- base::grepl
[10:22:41.692]                           restarts <- computeRestarts(cond)
[10:22:41.692]                           for (restart in restarts) {
[10:22:41.692]                             name <- restart$name
[10:22:41.692]                             if (is.null(name)) 
[10:22:41.692]                               next
[10:22:41.692]                             if (!grepl(pattern, name)) 
[10:22:41.692]                               next
[10:22:41.692]                             invokeRestart(restart)
[10:22:41.692]                             muffled <- TRUE
[10:22:41.692]                             break
[10:22:41.692]                           }
[10:22:41.692]                         }
[10:22:41.692]                       }
[10:22:41.692]                       invisible(muffled)
[10:22:41.692]                     }
[10:22:41.692]                     muffleCondition(cond, pattern = "^muffle")
[10:22:41.692]                   }
[10:22:41.692]                 }
[10:22:41.692]             }
[10:22:41.692]         }))
[10:22:41.692]     }, error = function(ex) {
[10:22:41.692]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:41.692]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:41.692]                 ...future.rng), started = ...future.startTime, 
[10:22:41.692]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:41.692]             version = "1.8"), class = "FutureResult")
[10:22:41.692]     }, finally = {
[10:22:41.692]         if (!identical(...future.workdir, getwd())) 
[10:22:41.692]             setwd(...future.workdir)
[10:22:41.692]         {
[10:22:41.692]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:41.692]                 ...future.oldOptions$nwarnings <- NULL
[10:22:41.692]             }
[10:22:41.692]             base::options(...future.oldOptions)
[10:22:41.692]             if (.Platform$OS.type == "windows") {
[10:22:41.692]                 old_names <- names(...future.oldEnvVars)
[10:22:41.692]                 envs <- base::Sys.getenv()
[10:22:41.692]                 names <- names(envs)
[10:22:41.692]                 common <- intersect(names, old_names)
[10:22:41.692]                 added <- setdiff(names, old_names)
[10:22:41.692]                 removed <- setdiff(old_names, names)
[10:22:41.692]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:41.692]                   envs[common]]
[10:22:41.692]                 NAMES <- toupper(changed)
[10:22:41.692]                 args <- list()
[10:22:41.692]                 for (kk in seq_along(NAMES)) {
[10:22:41.692]                   name <- changed[[kk]]
[10:22:41.692]                   NAME <- NAMES[[kk]]
[10:22:41.692]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:41.692]                     next
[10:22:41.692]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:41.692]                 }
[10:22:41.692]                 NAMES <- toupper(added)
[10:22:41.692]                 for (kk in seq_along(NAMES)) {
[10:22:41.692]                   name <- added[[kk]]
[10:22:41.692]                   NAME <- NAMES[[kk]]
[10:22:41.692]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:41.692]                     next
[10:22:41.692]                   args[[name]] <- ""
[10:22:41.692]                 }
[10:22:41.692]                 NAMES <- toupper(removed)
[10:22:41.692]                 for (kk in seq_along(NAMES)) {
[10:22:41.692]                   name <- removed[[kk]]
[10:22:41.692]                   NAME <- NAMES[[kk]]
[10:22:41.692]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:41.692]                     next
[10:22:41.692]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:41.692]                 }
[10:22:41.692]                 if (length(args) > 0) 
[10:22:41.692]                   base::do.call(base::Sys.setenv, args = args)
[10:22:41.692]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:41.692]             }
[10:22:41.692]             else {
[10:22:41.692]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:41.692]             }
[10:22:41.692]             {
[10:22:41.692]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:41.692]                   0L) {
[10:22:41.692]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:41.692]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:41.692]                   base::options(opts)
[10:22:41.692]                 }
[10:22:41.692]                 {
[10:22:41.692]                   {
[10:22:41.692]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:41.692]                     NULL
[10:22:41.692]                   }
[10:22:41.692]                   options(future.plan = NULL)
[10:22:41.692]                   if (is.na(NA_character_)) 
[10:22:41.692]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:41.692]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:41.692]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:41.692]                     .init = FALSE)
[10:22:41.692]                 }
[10:22:41.692]             }
[10:22:41.692]         }
[10:22:41.692]     })
[10:22:41.692]     if (TRUE) {
[10:22:41.692]         base::sink(type = "output", split = FALSE)
[10:22:41.692]         if (TRUE) {
[10:22:41.692]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:41.692]         }
[10:22:41.692]         else {
[10:22:41.692]             ...future.result["stdout"] <- base::list(NULL)
[10:22:41.692]         }
[10:22:41.692]         base::close(...future.stdout)
[10:22:41.692]         ...future.stdout <- NULL
[10:22:41.692]     }
[10:22:41.692]     ...future.result$conditions <- ...future.conditions
[10:22:41.692]     ...future.result$finished <- base::Sys.time()
[10:22:41.692]     ...future.result
[10:22:41.692] }
[10:22:41.695] MultisessionFuture started
[10:22:41.695] - Launch lazy future ... done
[10:22:41.695] run() for ‘MultisessionFuture’ ... done
[10:22:41.739] receiveMessageFromWorker() for ClusterFuture ...
[10:22:41.739] - Validating connection of MultisessionFuture
[10:22:41.740] - received message: FutureResult
[10:22:41.740] - Received FutureResult
[10:22:41.740] - Erased future from FutureRegistry
[10:22:41.740] result() for ClusterFuture ...
[10:22:41.740] - result already collected: FutureResult
[10:22:41.740] result() for ClusterFuture ... done
[10:22:41.740] signalConditions() ...
[10:22:41.740]  - include = ‘immediateCondition’
[10:22:41.741]  - exclude = 
[10:22:41.741]  - resignal = FALSE
[10:22:41.741]  - Number of conditions: 1
[10:22:41.741] signalConditions() ... done
[10:22:41.741] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:41.741] A MultisessionFuture was resolved
- result = TRUE, recursive = FALSE ... DONE
- result = TRUE, recursive = TRUE ...
[10:22:41.741] getGlobalsAndPackages() ...
[10:22:41.741] Searching for globals...
[10:22:41.742] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:22:41.742] Searching for globals ... DONE
[10:22:41.743] Resolving globals: FALSE
[10:22:41.743] 
[10:22:41.743] 
[10:22:41.743] getGlobalsAndPackages() ... DONE
[10:22:41.743] run() for ‘Future’ ...
[10:22:41.743] - state: ‘created’
[10:22:41.744] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:41.757] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:41.758] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:41.758]   - Field: ‘node’
[10:22:41.758]   - Field: ‘label’
[10:22:41.758]   - Field: ‘local’
[10:22:41.758]   - Field: ‘owner’
[10:22:41.758]   - Field: ‘envir’
[10:22:41.758]   - Field: ‘workers’
[10:22:41.758]   - Field: ‘packages’
[10:22:41.758]   - Field: ‘gc’
[10:22:41.758]   - Field: ‘conditions’
[10:22:41.758]   - Field: ‘persistent’
[10:22:41.759]   - Field: ‘expr’
[10:22:41.759]   - Field: ‘uuid’
[10:22:41.759]   - Field: ‘seed’
[10:22:41.759]   - Field: ‘version’
[10:22:41.759]   - Field: ‘result’
[10:22:41.759]   - Field: ‘asynchronous’
[10:22:41.759]   - Field: ‘calls’
[10:22:41.759]   - Field: ‘globals’
[10:22:41.759]   - Field: ‘stdout’
[10:22:41.759]   - Field: ‘earlySignal’
[10:22:41.759]   - Field: ‘lazy’
[10:22:41.759]   - Field: ‘state’
[10:22:41.760] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:41.760] - Launch lazy future ...
[10:22:41.760] Packages needed by the future expression (n = 0): <none>
[10:22:41.760] Packages needed by future strategies (n = 0): <none>
[10:22:41.760] {
[10:22:41.760]     {
[10:22:41.760]         {
[10:22:41.760]             ...future.startTime <- base::Sys.time()
[10:22:41.760]             {
[10:22:41.760]                 {
[10:22:41.760]                   {
[10:22:41.760]                     {
[10:22:41.760]                       base::local({
[10:22:41.760]                         has_future <- base::requireNamespace("future", 
[10:22:41.760]                           quietly = TRUE)
[10:22:41.760]                         if (has_future) {
[10:22:41.760]                           ns <- base::getNamespace("future")
[10:22:41.760]                           version <- ns[[".package"]][["version"]]
[10:22:41.760]                           if (is.null(version)) 
[10:22:41.760]                             version <- utils::packageVersion("future")
[10:22:41.760]                         }
[10:22:41.760]                         else {
[10:22:41.760]                           version <- NULL
[10:22:41.760]                         }
[10:22:41.760]                         if (!has_future || version < "1.8.0") {
[10:22:41.760]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:41.760]                             "", base::R.version$version.string), 
[10:22:41.760]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:41.760]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:41.760]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:41.760]                               "release", "version")], collapse = " "), 
[10:22:41.760]                             hostname = base::Sys.info()[["nodename"]])
[10:22:41.760]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:41.760]                             info)
[10:22:41.760]                           info <- base::paste(info, collapse = "; ")
[10:22:41.760]                           if (!has_future) {
[10:22:41.760]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:41.760]                               info)
[10:22:41.760]                           }
[10:22:41.760]                           else {
[10:22:41.760]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:41.760]                               info, version)
[10:22:41.760]                           }
[10:22:41.760]                           base::stop(msg)
[10:22:41.760]                         }
[10:22:41.760]                       })
[10:22:41.760]                     }
[10:22:41.760]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:41.760]                     base::options(mc.cores = 1L)
[10:22:41.760]                   }
[10:22:41.760]                   ...future.strategy.old <- future::plan("list")
[10:22:41.760]                   options(future.plan = NULL)
[10:22:41.760]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:41.760]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:41.760]                 }
[10:22:41.760]                 ...future.workdir <- getwd()
[10:22:41.760]             }
[10:22:41.760]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:41.760]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:41.760]         }
[10:22:41.760]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:41.760]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:41.760]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:41.760]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:41.760]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:41.760]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:41.760]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:41.760]             base::names(...future.oldOptions))
[10:22:41.760]     }
[10:22:41.760]     if (FALSE) {
[10:22:41.760]     }
[10:22:41.760]     else {
[10:22:41.760]         if (TRUE) {
[10:22:41.760]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:41.760]                 open = "w")
[10:22:41.760]         }
[10:22:41.760]         else {
[10:22:41.760]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:41.760]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:41.760]         }
[10:22:41.760]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:41.760]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:41.760]             base::sink(type = "output", split = FALSE)
[10:22:41.760]             base::close(...future.stdout)
[10:22:41.760]         }, add = TRUE)
[10:22:41.760]     }
[10:22:41.760]     ...future.frame <- base::sys.nframe()
[10:22:41.760]     ...future.conditions <- base::list()
[10:22:41.760]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:41.760]     if (FALSE) {
[10:22:41.760]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:41.760]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:41.760]     }
[10:22:41.760]     ...future.result <- base::tryCatch({
[10:22:41.760]         base::withCallingHandlers({
[10:22:41.760]             ...future.value <- base::withVisible(base::local({
[10:22:41.760]                 ...future.makeSendCondition <- base::local({
[10:22:41.760]                   sendCondition <- NULL
[10:22:41.760]                   function(frame = 1L) {
[10:22:41.760]                     if (is.function(sendCondition)) 
[10:22:41.760]                       return(sendCondition)
[10:22:41.760]                     ns <- getNamespace("parallel")
[10:22:41.760]                     if (exists("sendData", mode = "function", 
[10:22:41.760]                       envir = ns)) {
[10:22:41.760]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:41.760]                         envir = ns)
[10:22:41.760]                       envir <- sys.frame(frame)
[10:22:41.760]                       master <- NULL
[10:22:41.760]                       while (!identical(envir, .GlobalEnv) && 
[10:22:41.760]                         !identical(envir, emptyenv())) {
[10:22:41.760]                         if (exists("master", mode = "list", envir = envir, 
[10:22:41.760]                           inherits = FALSE)) {
[10:22:41.760]                           master <- get("master", mode = "list", 
[10:22:41.760]                             envir = envir, inherits = FALSE)
[10:22:41.760]                           if (inherits(master, c("SOCKnode", 
[10:22:41.760]                             "SOCK0node"))) {
[10:22:41.760]                             sendCondition <<- function(cond) {
[10:22:41.760]                               data <- list(type = "VALUE", value = cond, 
[10:22:41.760]                                 success = TRUE)
[10:22:41.760]                               parallel_sendData(master, data)
[10:22:41.760]                             }
[10:22:41.760]                             return(sendCondition)
[10:22:41.760]                           }
[10:22:41.760]                         }
[10:22:41.760]                         frame <- frame + 1L
[10:22:41.760]                         envir <- sys.frame(frame)
[10:22:41.760]                       }
[10:22:41.760]                     }
[10:22:41.760]                     sendCondition <<- function(cond) NULL
[10:22:41.760]                   }
[10:22:41.760]                 })
[10:22:41.760]                 withCallingHandlers({
[10:22:41.760]                   {
[10:22:41.760]                     Sys.sleep(0.5)
[10:22:41.760]                     list(a = 1, b = 42L)
[10:22:41.760]                   }
[10:22:41.760]                 }, immediateCondition = function(cond) {
[10:22:41.760]                   sendCondition <- ...future.makeSendCondition()
[10:22:41.760]                   sendCondition(cond)
[10:22:41.760]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:41.760]                   {
[10:22:41.760]                     inherits <- base::inherits
[10:22:41.760]                     invokeRestart <- base::invokeRestart
[10:22:41.760]                     is.null <- base::is.null
[10:22:41.760]                     muffled <- FALSE
[10:22:41.760]                     if (inherits(cond, "message")) {
[10:22:41.760]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:41.760]                       if (muffled) 
[10:22:41.760]                         invokeRestart("muffleMessage")
[10:22:41.760]                     }
[10:22:41.760]                     else if (inherits(cond, "warning")) {
[10:22:41.760]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:41.760]                       if (muffled) 
[10:22:41.760]                         invokeRestart("muffleWarning")
[10:22:41.760]                     }
[10:22:41.760]                     else if (inherits(cond, "condition")) {
[10:22:41.760]                       if (!is.null(pattern)) {
[10:22:41.760]                         computeRestarts <- base::computeRestarts
[10:22:41.760]                         grepl <- base::grepl
[10:22:41.760]                         restarts <- computeRestarts(cond)
[10:22:41.760]                         for (restart in restarts) {
[10:22:41.760]                           name <- restart$name
[10:22:41.760]                           if (is.null(name)) 
[10:22:41.760]                             next
[10:22:41.760]                           if (!grepl(pattern, name)) 
[10:22:41.760]                             next
[10:22:41.760]                           invokeRestart(restart)
[10:22:41.760]                           muffled <- TRUE
[10:22:41.760]                           break
[10:22:41.760]                         }
[10:22:41.760]                       }
[10:22:41.760]                     }
[10:22:41.760]                     invisible(muffled)
[10:22:41.760]                   }
[10:22:41.760]                   muffleCondition(cond)
[10:22:41.760]                 })
[10:22:41.760]             }))
[10:22:41.760]             future::FutureResult(value = ...future.value$value, 
[10:22:41.760]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:41.760]                   ...future.rng), globalenv = if (FALSE) 
[10:22:41.760]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:41.760]                     ...future.globalenv.names))
[10:22:41.760]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:41.760]         }, condition = base::local({
[10:22:41.760]             c <- base::c
[10:22:41.760]             inherits <- base::inherits
[10:22:41.760]             invokeRestart <- base::invokeRestart
[10:22:41.760]             length <- base::length
[10:22:41.760]             list <- base::list
[10:22:41.760]             seq.int <- base::seq.int
[10:22:41.760]             signalCondition <- base::signalCondition
[10:22:41.760]             sys.calls <- base::sys.calls
[10:22:41.760]             `[[` <- base::`[[`
[10:22:41.760]             `+` <- base::`+`
[10:22:41.760]             `<<-` <- base::`<<-`
[10:22:41.760]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:41.760]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:41.760]                   3L)]
[10:22:41.760]             }
[10:22:41.760]             function(cond) {
[10:22:41.760]                 is_error <- inherits(cond, "error")
[10:22:41.760]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:41.760]                   NULL)
[10:22:41.760]                 if (is_error) {
[10:22:41.760]                   sessionInformation <- function() {
[10:22:41.760]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:41.760]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:41.760]                       search = base::search(), system = base::Sys.info())
[10:22:41.760]                   }
[10:22:41.760]                   ...future.conditions[[length(...future.conditions) + 
[10:22:41.760]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:41.760]                     cond$call), session = sessionInformation(), 
[10:22:41.760]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:41.760]                   signalCondition(cond)
[10:22:41.760]                 }
[10:22:41.760]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:41.760]                 "immediateCondition"))) {
[10:22:41.760]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:41.760]                   ...future.conditions[[length(...future.conditions) + 
[10:22:41.760]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:41.760]                   if (TRUE && !signal) {
[10:22:41.760]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:41.760]                     {
[10:22:41.760]                       inherits <- base::inherits
[10:22:41.760]                       invokeRestart <- base::invokeRestart
[10:22:41.760]                       is.null <- base::is.null
[10:22:41.760]                       muffled <- FALSE
[10:22:41.760]                       if (inherits(cond, "message")) {
[10:22:41.760]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:41.760]                         if (muffled) 
[10:22:41.760]                           invokeRestart("muffleMessage")
[10:22:41.760]                       }
[10:22:41.760]                       else if (inherits(cond, "warning")) {
[10:22:41.760]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:41.760]                         if (muffled) 
[10:22:41.760]                           invokeRestart("muffleWarning")
[10:22:41.760]                       }
[10:22:41.760]                       else if (inherits(cond, "condition")) {
[10:22:41.760]                         if (!is.null(pattern)) {
[10:22:41.760]                           computeRestarts <- base::computeRestarts
[10:22:41.760]                           grepl <- base::grepl
[10:22:41.760]                           restarts <- computeRestarts(cond)
[10:22:41.760]                           for (restart in restarts) {
[10:22:41.760]                             name <- restart$name
[10:22:41.760]                             if (is.null(name)) 
[10:22:41.760]                               next
[10:22:41.760]                             if (!grepl(pattern, name)) 
[10:22:41.760]                               next
[10:22:41.760]                             invokeRestart(restart)
[10:22:41.760]                             muffled <- TRUE
[10:22:41.760]                             break
[10:22:41.760]                           }
[10:22:41.760]                         }
[10:22:41.760]                       }
[10:22:41.760]                       invisible(muffled)
[10:22:41.760]                     }
[10:22:41.760]                     muffleCondition(cond, pattern = "^muffle")
[10:22:41.760]                   }
[10:22:41.760]                 }
[10:22:41.760]                 else {
[10:22:41.760]                   if (TRUE) {
[10:22:41.760]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:41.760]                     {
[10:22:41.760]                       inherits <- base::inherits
[10:22:41.760]                       invokeRestart <- base::invokeRestart
[10:22:41.760]                       is.null <- base::is.null
[10:22:41.760]                       muffled <- FALSE
[10:22:41.760]                       if (inherits(cond, "message")) {
[10:22:41.760]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:41.760]                         if (muffled) 
[10:22:41.760]                           invokeRestart("muffleMessage")
[10:22:41.760]                       }
[10:22:41.760]                       else if (inherits(cond, "warning")) {
[10:22:41.760]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:41.760]                         if (muffled) 
[10:22:41.760]                           invokeRestart("muffleWarning")
[10:22:41.760]                       }
[10:22:41.760]                       else if (inherits(cond, "condition")) {
[10:22:41.760]                         if (!is.null(pattern)) {
[10:22:41.760]                           computeRestarts <- base::computeRestarts
[10:22:41.760]                           grepl <- base::grepl
[10:22:41.760]                           restarts <- computeRestarts(cond)
[10:22:41.760]                           for (restart in restarts) {
[10:22:41.760]                             name <- restart$name
[10:22:41.760]                             if (is.null(name)) 
[10:22:41.760]                               next
[10:22:41.760]                             if (!grepl(pattern, name)) 
[10:22:41.760]                               next
[10:22:41.760]                             invokeRestart(restart)
[10:22:41.760]                             muffled <- TRUE
[10:22:41.760]                             break
[10:22:41.760]                           }
[10:22:41.760]                         }
[10:22:41.760]                       }
[10:22:41.760]                       invisible(muffled)
[10:22:41.760]                     }
[10:22:41.760]                     muffleCondition(cond, pattern = "^muffle")
[10:22:41.760]                   }
[10:22:41.760]                 }
[10:22:41.760]             }
[10:22:41.760]         }))
[10:22:41.760]     }, error = function(ex) {
[10:22:41.760]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:41.760]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:41.760]                 ...future.rng), started = ...future.startTime, 
[10:22:41.760]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:41.760]             version = "1.8"), class = "FutureResult")
[10:22:41.760]     }, finally = {
[10:22:41.760]         if (!identical(...future.workdir, getwd())) 
[10:22:41.760]             setwd(...future.workdir)
[10:22:41.760]         {
[10:22:41.760]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:41.760]                 ...future.oldOptions$nwarnings <- NULL
[10:22:41.760]             }
[10:22:41.760]             base::options(...future.oldOptions)
[10:22:41.760]             if (.Platform$OS.type == "windows") {
[10:22:41.760]                 old_names <- names(...future.oldEnvVars)
[10:22:41.760]                 envs <- base::Sys.getenv()
[10:22:41.760]                 names <- names(envs)
[10:22:41.760]                 common <- intersect(names, old_names)
[10:22:41.760]                 added <- setdiff(names, old_names)
[10:22:41.760]                 removed <- setdiff(old_names, names)
[10:22:41.760]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:41.760]                   envs[common]]
[10:22:41.760]                 NAMES <- toupper(changed)
[10:22:41.760]                 args <- list()
[10:22:41.760]                 for (kk in seq_along(NAMES)) {
[10:22:41.760]                   name <- changed[[kk]]
[10:22:41.760]                   NAME <- NAMES[[kk]]
[10:22:41.760]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:41.760]                     next
[10:22:41.760]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:41.760]                 }
[10:22:41.760]                 NAMES <- toupper(added)
[10:22:41.760]                 for (kk in seq_along(NAMES)) {
[10:22:41.760]                   name <- added[[kk]]
[10:22:41.760]                   NAME <- NAMES[[kk]]
[10:22:41.760]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:41.760]                     next
[10:22:41.760]                   args[[name]] <- ""
[10:22:41.760]                 }
[10:22:41.760]                 NAMES <- toupper(removed)
[10:22:41.760]                 for (kk in seq_along(NAMES)) {
[10:22:41.760]                   name <- removed[[kk]]
[10:22:41.760]                   NAME <- NAMES[[kk]]
[10:22:41.760]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:41.760]                     next
[10:22:41.760]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:41.760]                 }
[10:22:41.760]                 if (length(args) > 0) 
[10:22:41.760]                   base::do.call(base::Sys.setenv, args = args)
[10:22:41.760]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:41.760]             }
[10:22:41.760]             else {
[10:22:41.760]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:41.760]             }
[10:22:41.760]             {
[10:22:41.760]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:41.760]                   0L) {
[10:22:41.760]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:41.760]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:41.760]                   base::options(opts)
[10:22:41.760]                 }
[10:22:41.760]                 {
[10:22:41.760]                   {
[10:22:41.760]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:41.760]                     NULL
[10:22:41.760]                   }
[10:22:41.760]                   options(future.plan = NULL)
[10:22:41.760]                   if (is.na(NA_character_)) 
[10:22:41.760]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:41.760]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:41.760]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:41.760]                     .init = FALSE)
[10:22:41.760]                 }
[10:22:41.760]             }
[10:22:41.760]         }
[10:22:41.760]     })
[10:22:41.760]     if (TRUE) {
[10:22:41.760]         base::sink(type = "output", split = FALSE)
[10:22:41.760]         if (TRUE) {
[10:22:41.760]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:41.760]         }
[10:22:41.760]         else {
[10:22:41.760]             ...future.result["stdout"] <- base::list(NULL)
[10:22:41.760]         }
[10:22:41.760]         base::close(...future.stdout)
[10:22:41.760]         ...future.stdout <- NULL
[10:22:41.760]     }
[10:22:41.760]     ...future.result$conditions <- ...future.conditions
[10:22:41.760]     ...future.result$finished <- base::Sys.time()
[10:22:41.760]     ...future.result
[10:22:41.760] }
[10:22:41.763] MultisessionFuture started
[10:22:41.763] - Launch lazy future ... done
[10:22:41.764] run() for ‘MultisessionFuture’ ... done
[10:22:42.306] receiveMessageFromWorker() for ClusterFuture ...
[10:22:42.306] - Validating connection of MultisessionFuture
[10:22:42.306] - received message: FutureResult
[10:22:42.306] - Received FutureResult
[10:22:42.307] - Erased future from FutureRegistry
[10:22:42.307] result() for ClusterFuture ...
[10:22:42.307] - result already collected: FutureResult
[10:22:42.307] result() for ClusterFuture ... done
[10:22:42.307] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:42.307] resolve() on list ...
[10:22:42.307]  recursive: 98
[10:22:42.307]  length: 2
[10:22:42.307]  elements: ‘a’, ‘b’
[10:22:42.308]  length: 1 (resolved future 1)
[10:22:42.308]  length: 0 (resolved future 2)
[10:22:42.308] resolve() on list ... DONE
[10:22:42.308] A MultisessionFuture was resolved (and resolved itself)
[10:22:42.308] getGlobalsAndPackages() ...
[10:22:42.308] Searching for globals...
[10:22:42.309] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:22:42.309] Searching for globals ... DONE
[10:22:42.309] Resolving globals: FALSE
[10:22:42.310] 
[10:22:42.310] 
[10:22:42.310] getGlobalsAndPackages() ... DONE
[10:22:42.310] run() for ‘Future’ ...
[10:22:42.310] - state: ‘created’
[10:22:42.310] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:42.325] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:42.325] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:42.325]   - Field: ‘node’
[10:22:42.325]   - Field: ‘label’
[10:22:42.325]   - Field: ‘local’
[10:22:42.325]   - Field: ‘owner’
[10:22:42.325]   - Field: ‘envir’
[10:22:42.326]   - Field: ‘workers’
[10:22:42.326]   - Field: ‘packages’
[10:22:42.326]   - Field: ‘gc’
[10:22:42.326]   - Field: ‘conditions’
[10:22:42.326]   - Field: ‘persistent’
[10:22:42.326]   - Field: ‘expr’
[10:22:42.326]   - Field: ‘uuid’
[10:22:42.326]   - Field: ‘seed’
[10:22:42.326]   - Field: ‘version’
[10:22:42.326]   - Field: ‘result’
[10:22:42.326]   - Field: ‘asynchronous’
[10:22:42.327]   - Field: ‘calls’
[10:22:42.327]   - Field: ‘globals’
[10:22:42.327]   - Field: ‘stdout’
[10:22:42.327]   - Field: ‘earlySignal’
[10:22:42.327]   - Field: ‘lazy’
[10:22:42.327]   - Field: ‘state’
[10:22:42.327] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:42.327] - Launch lazy future ...
[10:22:42.327] Packages needed by the future expression (n = 0): <none>
[10:22:42.328] Packages needed by future strategies (n = 0): <none>
[10:22:42.328] {
[10:22:42.328]     {
[10:22:42.328]         {
[10:22:42.328]             ...future.startTime <- base::Sys.time()
[10:22:42.328]             {
[10:22:42.328]                 {
[10:22:42.328]                   {
[10:22:42.328]                     {
[10:22:42.328]                       base::local({
[10:22:42.328]                         has_future <- base::requireNamespace("future", 
[10:22:42.328]                           quietly = TRUE)
[10:22:42.328]                         if (has_future) {
[10:22:42.328]                           ns <- base::getNamespace("future")
[10:22:42.328]                           version <- ns[[".package"]][["version"]]
[10:22:42.328]                           if (is.null(version)) 
[10:22:42.328]                             version <- utils::packageVersion("future")
[10:22:42.328]                         }
[10:22:42.328]                         else {
[10:22:42.328]                           version <- NULL
[10:22:42.328]                         }
[10:22:42.328]                         if (!has_future || version < "1.8.0") {
[10:22:42.328]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:42.328]                             "", base::R.version$version.string), 
[10:22:42.328]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:42.328]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:42.328]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:42.328]                               "release", "version")], collapse = " "), 
[10:22:42.328]                             hostname = base::Sys.info()[["nodename"]])
[10:22:42.328]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:42.328]                             info)
[10:22:42.328]                           info <- base::paste(info, collapse = "; ")
[10:22:42.328]                           if (!has_future) {
[10:22:42.328]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:42.328]                               info)
[10:22:42.328]                           }
[10:22:42.328]                           else {
[10:22:42.328]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:42.328]                               info, version)
[10:22:42.328]                           }
[10:22:42.328]                           base::stop(msg)
[10:22:42.328]                         }
[10:22:42.328]                       })
[10:22:42.328]                     }
[10:22:42.328]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:42.328]                     base::options(mc.cores = 1L)
[10:22:42.328]                   }
[10:22:42.328]                   ...future.strategy.old <- future::plan("list")
[10:22:42.328]                   options(future.plan = NULL)
[10:22:42.328]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:42.328]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:42.328]                 }
[10:22:42.328]                 ...future.workdir <- getwd()
[10:22:42.328]             }
[10:22:42.328]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:42.328]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:42.328]         }
[10:22:42.328]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:42.328]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:42.328]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:42.328]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:42.328]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:42.328]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:42.328]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:42.328]             base::names(...future.oldOptions))
[10:22:42.328]     }
[10:22:42.328]     if (FALSE) {
[10:22:42.328]     }
[10:22:42.328]     else {
[10:22:42.328]         if (TRUE) {
[10:22:42.328]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:42.328]                 open = "w")
[10:22:42.328]         }
[10:22:42.328]         else {
[10:22:42.328]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:42.328]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:42.328]         }
[10:22:42.328]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:42.328]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:42.328]             base::sink(type = "output", split = FALSE)
[10:22:42.328]             base::close(...future.stdout)
[10:22:42.328]         }, add = TRUE)
[10:22:42.328]     }
[10:22:42.328]     ...future.frame <- base::sys.nframe()
[10:22:42.328]     ...future.conditions <- base::list()
[10:22:42.328]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:42.328]     if (FALSE) {
[10:22:42.328]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:42.328]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:42.328]     }
[10:22:42.328]     ...future.result <- base::tryCatch({
[10:22:42.328]         base::withCallingHandlers({
[10:22:42.328]             ...future.value <- base::withVisible(base::local({
[10:22:42.328]                 ...future.makeSendCondition <- base::local({
[10:22:42.328]                   sendCondition <- NULL
[10:22:42.328]                   function(frame = 1L) {
[10:22:42.328]                     if (is.function(sendCondition)) 
[10:22:42.328]                       return(sendCondition)
[10:22:42.328]                     ns <- getNamespace("parallel")
[10:22:42.328]                     if (exists("sendData", mode = "function", 
[10:22:42.328]                       envir = ns)) {
[10:22:42.328]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:42.328]                         envir = ns)
[10:22:42.328]                       envir <- sys.frame(frame)
[10:22:42.328]                       master <- NULL
[10:22:42.328]                       while (!identical(envir, .GlobalEnv) && 
[10:22:42.328]                         !identical(envir, emptyenv())) {
[10:22:42.328]                         if (exists("master", mode = "list", envir = envir, 
[10:22:42.328]                           inherits = FALSE)) {
[10:22:42.328]                           master <- get("master", mode = "list", 
[10:22:42.328]                             envir = envir, inherits = FALSE)
[10:22:42.328]                           if (inherits(master, c("SOCKnode", 
[10:22:42.328]                             "SOCK0node"))) {
[10:22:42.328]                             sendCondition <<- function(cond) {
[10:22:42.328]                               data <- list(type = "VALUE", value = cond, 
[10:22:42.328]                                 success = TRUE)
[10:22:42.328]                               parallel_sendData(master, data)
[10:22:42.328]                             }
[10:22:42.328]                             return(sendCondition)
[10:22:42.328]                           }
[10:22:42.328]                         }
[10:22:42.328]                         frame <- frame + 1L
[10:22:42.328]                         envir <- sys.frame(frame)
[10:22:42.328]                       }
[10:22:42.328]                     }
[10:22:42.328]                     sendCondition <<- function(cond) NULL
[10:22:42.328]                   }
[10:22:42.328]                 })
[10:22:42.328]                 withCallingHandlers({
[10:22:42.328]                   {
[10:22:42.328]                     Sys.sleep(0.5)
[10:22:42.328]                     list(a = 1, b = 42L)
[10:22:42.328]                   }
[10:22:42.328]                 }, immediateCondition = function(cond) {
[10:22:42.328]                   sendCondition <- ...future.makeSendCondition()
[10:22:42.328]                   sendCondition(cond)
[10:22:42.328]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:42.328]                   {
[10:22:42.328]                     inherits <- base::inherits
[10:22:42.328]                     invokeRestart <- base::invokeRestart
[10:22:42.328]                     is.null <- base::is.null
[10:22:42.328]                     muffled <- FALSE
[10:22:42.328]                     if (inherits(cond, "message")) {
[10:22:42.328]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:42.328]                       if (muffled) 
[10:22:42.328]                         invokeRestart("muffleMessage")
[10:22:42.328]                     }
[10:22:42.328]                     else if (inherits(cond, "warning")) {
[10:22:42.328]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:42.328]                       if (muffled) 
[10:22:42.328]                         invokeRestart("muffleWarning")
[10:22:42.328]                     }
[10:22:42.328]                     else if (inherits(cond, "condition")) {
[10:22:42.328]                       if (!is.null(pattern)) {
[10:22:42.328]                         computeRestarts <- base::computeRestarts
[10:22:42.328]                         grepl <- base::grepl
[10:22:42.328]                         restarts <- computeRestarts(cond)
[10:22:42.328]                         for (restart in restarts) {
[10:22:42.328]                           name <- restart$name
[10:22:42.328]                           if (is.null(name)) 
[10:22:42.328]                             next
[10:22:42.328]                           if (!grepl(pattern, name)) 
[10:22:42.328]                             next
[10:22:42.328]                           invokeRestart(restart)
[10:22:42.328]                           muffled <- TRUE
[10:22:42.328]                           break
[10:22:42.328]                         }
[10:22:42.328]                       }
[10:22:42.328]                     }
[10:22:42.328]                     invisible(muffled)
[10:22:42.328]                   }
[10:22:42.328]                   muffleCondition(cond)
[10:22:42.328]                 })
[10:22:42.328]             }))
[10:22:42.328]             future::FutureResult(value = ...future.value$value, 
[10:22:42.328]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:42.328]                   ...future.rng), globalenv = if (FALSE) 
[10:22:42.328]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:42.328]                     ...future.globalenv.names))
[10:22:42.328]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:42.328]         }, condition = base::local({
[10:22:42.328]             c <- base::c
[10:22:42.328]             inherits <- base::inherits
[10:22:42.328]             invokeRestart <- base::invokeRestart
[10:22:42.328]             length <- base::length
[10:22:42.328]             list <- base::list
[10:22:42.328]             seq.int <- base::seq.int
[10:22:42.328]             signalCondition <- base::signalCondition
[10:22:42.328]             sys.calls <- base::sys.calls
[10:22:42.328]             `[[` <- base::`[[`
[10:22:42.328]             `+` <- base::`+`
[10:22:42.328]             `<<-` <- base::`<<-`
[10:22:42.328]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:42.328]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:42.328]                   3L)]
[10:22:42.328]             }
[10:22:42.328]             function(cond) {
[10:22:42.328]                 is_error <- inherits(cond, "error")
[10:22:42.328]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:42.328]                   NULL)
[10:22:42.328]                 if (is_error) {
[10:22:42.328]                   sessionInformation <- function() {
[10:22:42.328]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:42.328]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:42.328]                       search = base::search(), system = base::Sys.info())
[10:22:42.328]                   }
[10:22:42.328]                   ...future.conditions[[length(...future.conditions) + 
[10:22:42.328]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:42.328]                     cond$call), session = sessionInformation(), 
[10:22:42.328]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:42.328]                   signalCondition(cond)
[10:22:42.328]                 }
[10:22:42.328]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:42.328]                 "immediateCondition"))) {
[10:22:42.328]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:42.328]                   ...future.conditions[[length(...future.conditions) + 
[10:22:42.328]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:42.328]                   if (TRUE && !signal) {
[10:22:42.328]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:42.328]                     {
[10:22:42.328]                       inherits <- base::inherits
[10:22:42.328]                       invokeRestart <- base::invokeRestart
[10:22:42.328]                       is.null <- base::is.null
[10:22:42.328]                       muffled <- FALSE
[10:22:42.328]                       if (inherits(cond, "message")) {
[10:22:42.328]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:42.328]                         if (muffled) 
[10:22:42.328]                           invokeRestart("muffleMessage")
[10:22:42.328]                       }
[10:22:42.328]                       else if (inherits(cond, "warning")) {
[10:22:42.328]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:42.328]                         if (muffled) 
[10:22:42.328]                           invokeRestart("muffleWarning")
[10:22:42.328]                       }
[10:22:42.328]                       else if (inherits(cond, "condition")) {
[10:22:42.328]                         if (!is.null(pattern)) {
[10:22:42.328]                           computeRestarts <- base::computeRestarts
[10:22:42.328]                           grepl <- base::grepl
[10:22:42.328]                           restarts <- computeRestarts(cond)
[10:22:42.328]                           for (restart in restarts) {
[10:22:42.328]                             name <- restart$name
[10:22:42.328]                             if (is.null(name)) 
[10:22:42.328]                               next
[10:22:42.328]                             if (!grepl(pattern, name)) 
[10:22:42.328]                               next
[10:22:42.328]                             invokeRestart(restart)
[10:22:42.328]                             muffled <- TRUE
[10:22:42.328]                             break
[10:22:42.328]                           }
[10:22:42.328]                         }
[10:22:42.328]                       }
[10:22:42.328]                       invisible(muffled)
[10:22:42.328]                     }
[10:22:42.328]                     muffleCondition(cond, pattern = "^muffle")
[10:22:42.328]                   }
[10:22:42.328]                 }
[10:22:42.328]                 else {
[10:22:42.328]                   if (TRUE) {
[10:22:42.328]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:42.328]                     {
[10:22:42.328]                       inherits <- base::inherits
[10:22:42.328]                       invokeRestart <- base::invokeRestart
[10:22:42.328]                       is.null <- base::is.null
[10:22:42.328]                       muffled <- FALSE
[10:22:42.328]                       if (inherits(cond, "message")) {
[10:22:42.328]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:42.328]                         if (muffled) 
[10:22:42.328]                           invokeRestart("muffleMessage")
[10:22:42.328]                       }
[10:22:42.328]                       else if (inherits(cond, "warning")) {
[10:22:42.328]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:42.328]                         if (muffled) 
[10:22:42.328]                           invokeRestart("muffleWarning")
[10:22:42.328]                       }
[10:22:42.328]                       else if (inherits(cond, "condition")) {
[10:22:42.328]                         if (!is.null(pattern)) {
[10:22:42.328]                           computeRestarts <- base::computeRestarts
[10:22:42.328]                           grepl <- base::grepl
[10:22:42.328]                           restarts <- computeRestarts(cond)
[10:22:42.328]                           for (restart in restarts) {
[10:22:42.328]                             name <- restart$name
[10:22:42.328]                             if (is.null(name)) 
[10:22:42.328]                               next
[10:22:42.328]                             if (!grepl(pattern, name)) 
[10:22:42.328]                               next
[10:22:42.328]                             invokeRestart(restart)
[10:22:42.328]                             muffled <- TRUE
[10:22:42.328]                             break
[10:22:42.328]                           }
[10:22:42.328]                         }
[10:22:42.328]                       }
[10:22:42.328]                       invisible(muffled)
[10:22:42.328]                     }
[10:22:42.328]                     muffleCondition(cond, pattern = "^muffle")
[10:22:42.328]                   }
[10:22:42.328]                 }
[10:22:42.328]             }
[10:22:42.328]         }))
[10:22:42.328]     }, error = function(ex) {
[10:22:42.328]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:42.328]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:42.328]                 ...future.rng), started = ...future.startTime, 
[10:22:42.328]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:42.328]             version = "1.8"), class = "FutureResult")
[10:22:42.328]     }, finally = {
[10:22:42.328]         if (!identical(...future.workdir, getwd())) 
[10:22:42.328]             setwd(...future.workdir)
[10:22:42.328]         {
[10:22:42.328]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:42.328]                 ...future.oldOptions$nwarnings <- NULL
[10:22:42.328]             }
[10:22:42.328]             base::options(...future.oldOptions)
[10:22:42.328]             if (.Platform$OS.type == "windows") {
[10:22:42.328]                 old_names <- names(...future.oldEnvVars)
[10:22:42.328]                 envs <- base::Sys.getenv()
[10:22:42.328]                 names <- names(envs)
[10:22:42.328]                 common <- intersect(names, old_names)
[10:22:42.328]                 added <- setdiff(names, old_names)
[10:22:42.328]                 removed <- setdiff(old_names, names)
[10:22:42.328]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:42.328]                   envs[common]]
[10:22:42.328]                 NAMES <- toupper(changed)
[10:22:42.328]                 args <- list()
[10:22:42.328]                 for (kk in seq_along(NAMES)) {
[10:22:42.328]                   name <- changed[[kk]]
[10:22:42.328]                   NAME <- NAMES[[kk]]
[10:22:42.328]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:42.328]                     next
[10:22:42.328]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:42.328]                 }
[10:22:42.328]                 NAMES <- toupper(added)
[10:22:42.328]                 for (kk in seq_along(NAMES)) {
[10:22:42.328]                   name <- added[[kk]]
[10:22:42.328]                   NAME <- NAMES[[kk]]
[10:22:42.328]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:42.328]                     next
[10:22:42.328]                   args[[name]] <- ""
[10:22:42.328]                 }
[10:22:42.328]                 NAMES <- toupper(removed)
[10:22:42.328]                 for (kk in seq_along(NAMES)) {
[10:22:42.328]                   name <- removed[[kk]]
[10:22:42.328]                   NAME <- NAMES[[kk]]
[10:22:42.328]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:42.328]                     next
[10:22:42.328]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:42.328]                 }
[10:22:42.328]                 if (length(args) > 0) 
[10:22:42.328]                   base::do.call(base::Sys.setenv, args = args)
[10:22:42.328]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:42.328]             }
[10:22:42.328]             else {
[10:22:42.328]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:42.328]             }
[10:22:42.328]             {
[10:22:42.328]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:42.328]                   0L) {
[10:22:42.328]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:42.328]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:42.328]                   base::options(opts)
[10:22:42.328]                 }
[10:22:42.328]                 {
[10:22:42.328]                   {
[10:22:42.328]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:42.328]                     NULL
[10:22:42.328]                   }
[10:22:42.328]                   options(future.plan = NULL)
[10:22:42.328]                   if (is.na(NA_character_)) 
[10:22:42.328]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:42.328]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:42.328]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:42.328]                     .init = FALSE)
[10:22:42.328]                 }
[10:22:42.328]             }
[10:22:42.328]         }
[10:22:42.328]     })
[10:22:42.328]     if (TRUE) {
[10:22:42.328]         base::sink(type = "output", split = FALSE)
[10:22:42.328]         if (TRUE) {
[10:22:42.328]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:42.328]         }
[10:22:42.328]         else {
[10:22:42.328]             ...future.result["stdout"] <- base::list(NULL)
[10:22:42.328]         }
[10:22:42.328]         base::close(...future.stdout)
[10:22:42.328]         ...future.stdout <- NULL
[10:22:42.328]     }
[10:22:42.328]     ...future.result$conditions <- ...future.conditions
[10:22:42.328]     ...future.result$finished <- base::Sys.time()
[10:22:42.328]     ...future.result
[10:22:42.328] }
[10:22:42.331] MultisessionFuture started
[10:22:42.331] - Launch lazy future ... done
[10:22:42.331] run() for ‘MultisessionFuture’ ... done
[10:22:42.874] receiveMessageFromWorker() for ClusterFuture ...
[10:22:42.874] - Validating connection of MultisessionFuture
[10:22:42.874] - received message: FutureResult
[10:22:42.875] - Received FutureResult
[10:22:42.875] - Erased future from FutureRegistry
[10:22:42.875] result() for ClusterFuture ...
[10:22:42.875] - result already collected: FutureResult
[10:22:42.875] result() for ClusterFuture ... done
[10:22:42.875] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:42.875] resolve() on list ...
[10:22:42.875]  recursive: 98
[10:22:42.875]  length: 2
[10:22:42.875]  elements: ‘a’, ‘b’
[10:22:42.876]  length: 1 (resolved future 1)
[10:22:42.876]  length: 0 (resolved future 2)
[10:22:42.876] resolve() on list ... DONE
[10:22:42.876] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[10:22:42.876] getGlobalsAndPackages() ...
[10:22:42.876] Searching for globals...
[10:22:42.877] - globals found: [2] ‘list’, ‘stop’
[10:22:42.877] Searching for globals ... DONE
[10:22:42.877] Resolving globals: FALSE
[10:22:42.877] 
[10:22:42.877] 
[10:22:42.878] getGlobalsAndPackages() ... DONE
[10:22:42.878] run() for ‘Future’ ...
[10:22:42.878] - state: ‘created’
[10:22:42.878] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:42.892] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:42.892] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:42.892]   - Field: ‘node’
[10:22:42.892]   - Field: ‘label’
[10:22:42.892]   - Field: ‘local’
[10:22:42.892]   - Field: ‘owner’
[10:22:42.893]   - Field: ‘envir’
[10:22:42.893]   - Field: ‘workers’
[10:22:42.893]   - Field: ‘packages’
[10:22:42.893]   - Field: ‘gc’
[10:22:42.893]   - Field: ‘conditions’
[10:22:42.893]   - Field: ‘persistent’
[10:22:42.893]   - Field: ‘expr’
[10:22:42.893]   - Field: ‘uuid’
[10:22:42.893]   - Field: ‘seed’
[10:22:42.893]   - Field: ‘version’
[10:22:42.893]   - Field: ‘result’
[10:22:42.894]   - Field: ‘asynchronous’
[10:22:42.894]   - Field: ‘calls’
[10:22:42.894]   - Field: ‘globals’
[10:22:42.894]   - Field: ‘stdout’
[10:22:42.894]   - Field: ‘earlySignal’
[10:22:42.894]   - Field: ‘lazy’
[10:22:42.894]   - Field: ‘state’
[10:22:42.894] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:42.894] - Launch lazy future ...
[10:22:42.895] Packages needed by the future expression (n = 0): <none>
[10:22:42.895] Packages needed by future strategies (n = 0): <none>
[10:22:42.895] {
[10:22:42.895]     {
[10:22:42.895]         {
[10:22:42.895]             ...future.startTime <- base::Sys.time()
[10:22:42.895]             {
[10:22:42.895]                 {
[10:22:42.895]                   {
[10:22:42.895]                     {
[10:22:42.895]                       base::local({
[10:22:42.895]                         has_future <- base::requireNamespace("future", 
[10:22:42.895]                           quietly = TRUE)
[10:22:42.895]                         if (has_future) {
[10:22:42.895]                           ns <- base::getNamespace("future")
[10:22:42.895]                           version <- ns[[".package"]][["version"]]
[10:22:42.895]                           if (is.null(version)) 
[10:22:42.895]                             version <- utils::packageVersion("future")
[10:22:42.895]                         }
[10:22:42.895]                         else {
[10:22:42.895]                           version <- NULL
[10:22:42.895]                         }
[10:22:42.895]                         if (!has_future || version < "1.8.0") {
[10:22:42.895]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:42.895]                             "", base::R.version$version.string), 
[10:22:42.895]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:42.895]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:42.895]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:42.895]                               "release", "version")], collapse = " "), 
[10:22:42.895]                             hostname = base::Sys.info()[["nodename"]])
[10:22:42.895]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:42.895]                             info)
[10:22:42.895]                           info <- base::paste(info, collapse = "; ")
[10:22:42.895]                           if (!has_future) {
[10:22:42.895]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:42.895]                               info)
[10:22:42.895]                           }
[10:22:42.895]                           else {
[10:22:42.895]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:42.895]                               info, version)
[10:22:42.895]                           }
[10:22:42.895]                           base::stop(msg)
[10:22:42.895]                         }
[10:22:42.895]                       })
[10:22:42.895]                     }
[10:22:42.895]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:42.895]                     base::options(mc.cores = 1L)
[10:22:42.895]                   }
[10:22:42.895]                   ...future.strategy.old <- future::plan("list")
[10:22:42.895]                   options(future.plan = NULL)
[10:22:42.895]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:42.895]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:42.895]                 }
[10:22:42.895]                 ...future.workdir <- getwd()
[10:22:42.895]             }
[10:22:42.895]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:42.895]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:42.895]         }
[10:22:42.895]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:42.895]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:42.895]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:42.895]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:42.895]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:42.895]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:42.895]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:42.895]             base::names(...future.oldOptions))
[10:22:42.895]     }
[10:22:42.895]     if (FALSE) {
[10:22:42.895]     }
[10:22:42.895]     else {
[10:22:42.895]         if (TRUE) {
[10:22:42.895]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:42.895]                 open = "w")
[10:22:42.895]         }
[10:22:42.895]         else {
[10:22:42.895]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:42.895]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:42.895]         }
[10:22:42.895]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:42.895]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:42.895]             base::sink(type = "output", split = FALSE)
[10:22:42.895]             base::close(...future.stdout)
[10:22:42.895]         }, add = TRUE)
[10:22:42.895]     }
[10:22:42.895]     ...future.frame <- base::sys.nframe()
[10:22:42.895]     ...future.conditions <- base::list()
[10:22:42.895]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:42.895]     if (FALSE) {
[10:22:42.895]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:42.895]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:42.895]     }
[10:22:42.895]     ...future.result <- base::tryCatch({
[10:22:42.895]         base::withCallingHandlers({
[10:22:42.895]             ...future.value <- base::withVisible(base::local({
[10:22:42.895]                 ...future.makeSendCondition <- base::local({
[10:22:42.895]                   sendCondition <- NULL
[10:22:42.895]                   function(frame = 1L) {
[10:22:42.895]                     if (is.function(sendCondition)) 
[10:22:42.895]                       return(sendCondition)
[10:22:42.895]                     ns <- getNamespace("parallel")
[10:22:42.895]                     if (exists("sendData", mode = "function", 
[10:22:42.895]                       envir = ns)) {
[10:22:42.895]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:42.895]                         envir = ns)
[10:22:42.895]                       envir <- sys.frame(frame)
[10:22:42.895]                       master <- NULL
[10:22:42.895]                       while (!identical(envir, .GlobalEnv) && 
[10:22:42.895]                         !identical(envir, emptyenv())) {
[10:22:42.895]                         if (exists("master", mode = "list", envir = envir, 
[10:22:42.895]                           inherits = FALSE)) {
[10:22:42.895]                           master <- get("master", mode = "list", 
[10:22:42.895]                             envir = envir, inherits = FALSE)
[10:22:42.895]                           if (inherits(master, c("SOCKnode", 
[10:22:42.895]                             "SOCK0node"))) {
[10:22:42.895]                             sendCondition <<- function(cond) {
[10:22:42.895]                               data <- list(type = "VALUE", value = cond, 
[10:22:42.895]                                 success = TRUE)
[10:22:42.895]                               parallel_sendData(master, data)
[10:22:42.895]                             }
[10:22:42.895]                             return(sendCondition)
[10:22:42.895]                           }
[10:22:42.895]                         }
[10:22:42.895]                         frame <- frame + 1L
[10:22:42.895]                         envir <- sys.frame(frame)
[10:22:42.895]                       }
[10:22:42.895]                     }
[10:22:42.895]                     sendCondition <<- function(cond) NULL
[10:22:42.895]                   }
[10:22:42.895]                 })
[10:22:42.895]                 withCallingHandlers({
[10:22:42.895]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:22:42.895]                 }, immediateCondition = function(cond) {
[10:22:42.895]                   sendCondition <- ...future.makeSendCondition()
[10:22:42.895]                   sendCondition(cond)
[10:22:42.895]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:42.895]                   {
[10:22:42.895]                     inherits <- base::inherits
[10:22:42.895]                     invokeRestart <- base::invokeRestart
[10:22:42.895]                     is.null <- base::is.null
[10:22:42.895]                     muffled <- FALSE
[10:22:42.895]                     if (inherits(cond, "message")) {
[10:22:42.895]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:42.895]                       if (muffled) 
[10:22:42.895]                         invokeRestart("muffleMessage")
[10:22:42.895]                     }
[10:22:42.895]                     else if (inherits(cond, "warning")) {
[10:22:42.895]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:42.895]                       if (muffled) 
[10:22:42.895]                         invokeRestart("muffleWarning")
[10:22:42.895]                     }
[10:22:42.895]                     else if (inherits(cond, "condition")) {
[10:22:42.895]                       if (!is.null(pattern)) {
[10:22:42.895]                         computeRestarts <- base::computeRestarts
[10:22:42.895]                         grepl <- base::grepl
[10:22:42.895]                         restarts <- computeRestarts(cond)
[10:22:42.895]                         for (restart in restarts) {
[10:22:42.895]                           name <- restart$name
[10:22:42.895]                           if (is.null(name)) 
[10:22:42.895]                             next
[10:22:42.895]                           if (!grepl(pattern, name)) 
[10:22:42.895]                             next
[10:22:42.895]                           invokeRestart(restart)
[10:22:42.895]                           muffled <- TRUE
[10:22:42.895]                           break
[10:22:42.895]                         }
[10:22:42.895]                       }
[10:22:42.895]                     }
[10:22:42.895]                     invisible(muffled)
[10:22:42.895]                   }
[10:22:42.895]                   muffleCondition(cond)
[10:22:42.895]                 })
[10:22:42.895]             }))
[10:22:42.895]             future::FutureResult(value = ...future.value$value, 
[10:22:42.895]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:42.895]                   ...future.rng), globalenv = if (FALSE) 
[10:22:42.895]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:42.895]                     ...future.globalenv.names))
[10:22:42.895]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:42.895]         }, condition = base::local({
[10:22:42.895]             c <- base::c
[10:22:42.895]             inherits <- base::inherits
[10:22:42.895]             invokeRestart <- base::invokeRestart
[10:22:42.895]             length <- base::length
[10:22:42.895]             list <- base::list
[10:22:42.895]             seq.int <- base::seq.int
[10:22:42.895]             signalCondition <- base::signalCondition
[10:22:42.895]             sys.calls <- base::sys.calls
[10:22:42.895]             `[[` <- base::`[[`
[10:22:42.895]             `+` <- base::`+`
[10:22:42.895]             `<<-` <- base::`<<-`
[10:22:42.895]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:42.895]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:42.895]                   3L)]
[10:22:42.895]             }
[10:22:42.895]             function(cond) {
[10:22:42.895]                 is_error <- inherits(cond, "error")
[10:22:42.895]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:42.895]                   NULL)
[10:22:42.895]                 if (is_error) {
[10:22:42.895]                   sessionInformation <- function() {
[10:22:42.895]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:42.895]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:42.895]                       search = base::search(), system = base::Sys.info())
[10:22:42.895]                   }
[10:22:42.895]                   ...future.conditions[[length(...future.conditions) + 
[10:22:42.895]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:42.895]                     cond$call), session = sessionInformation(), 
[10:22:42.895]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:42.895]                   signalCondition(cond)
[10:22:42.895]                 }
[10:22:42.895]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:42.895]                 "immediateCondition"))) {
[10:22:42.895]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:42.895]                   ...future.conditions[[length(...future.conditions) + 
[10:22:42.895]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:42.895]                   if (TRUE && !signal) {
[10:22:42.895]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:42.895]                     {
[10:22:42.895]                       inherits <- base::inherits
[10:22:42.895]                       invokeRestart <- base::invokeRestart
[10:22:42.895]                       is.null <- base::is.null
[10:22:42.895]                       muffled <- FALSE
[10:22:42.895]                       if (inherits(cond, "message")) {
[10:22:42.895]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:42.895]                         if (muffled) 
[10:22:42.895]                           invokeRestart("muffleMessage")
[10:22:42.895]                       }
[10:22:42.895]                       else if (inherits(cond, "warning")) {
[10:22:42.895]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:42.895]                         if (muffled) 
[10:22:42.895]                           invokeRestart("muffleWarning")
[10:22:42.895]                       }
[10:22:42.895]                       else if (inherits(cond, "condition")) {
[10:22:42.895]                         if (!is.null(pattern)) {
[10:22:42.895]                           computeRestarts <- base::computeRestarts
[10:22:42.895]                           grepl <- base::grepl
[10:22:42.895]                           restarts <- computeRestarts(cond)
[10:22:42.895]                           for (restart in restarts) {
[10:22:42.895]                             name <- restart$name
[10:22:42.895]                             if (is.null(name)) 
[10:22:42.895]                               next
[10:22:42.895]                             if (!grepl(pattern, name)) 
[10:22:42.895]                               next
[10:22:42.895]                             invokeRestart(restart)
[10:22:42.895]                             muffled <- TRUE
[10:22:42.895]                             break
[10:22:42.895]                           }
[10:22:42.895]                         }
[10:22:42.895]                       }
[10:22:42.895]                       invisible(muffled)
[10:22:42.895]                     }
[10:22:42.895]                     muffleCondition(cond, pattern = "^muffle")
[10:22:42.895]                   }
[10:22:42.895]                 }
[10:22:42.895]                 else {
[10:22:42.895]                   if (TRUE) {
[10:22:42.895]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:42.895]                     {
[10:22:42.895]                       inherits <- base::inherits
[10:22:42.895]                       invokeRestart <- base::invokeRestart
[10:22:42.895]                       is.null <- base::is.null
[10:22:42.895]                       muffled <- FALSE
[10:22:42.895]                       if (inherits(cond, "message")) {
[10:22:42.895]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:42.895]                         if (muffled) 
[10:22:42.895]                           invokeRestart("muffleMessage")
[10:22:42.895]                       }
[10:22:42.895]                       else if (inherits(cond, "warning")) {
[10:22:42.895]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:42.895]                         if (muffled) 
[10:22:42.895]                           invokeRestart("muffleWarning")
[10:22:42.895]                       }
[10:22:42.895]                       else if (inherits(cond, "condition")) {
[10:22:42.895]                         if (!is.null(pattern)) {
[10:22:42.895]                           computeRestarts <- base::computeRestarts
[10:22:42.895]                           grepl <- base::grepl
[10:22:42.895]                           restarts <- computeRestarts(cond)
[10:22:42.895]                           for (restart in restarts) {
[10:22:42.895]                             name <- restart$name
[10:22:42.895]                             if (is.null(name)) 
[10:22:42.895]                               next
[10:22:42.895]                             if (!grepl(pattern, name)) 
[10:22:42.895]                               next
[10:22:42.895]                             invokeRestart(restart)
[10:22:42.895]                             muffled <- TRUE
[10:22:42.895]                             break
[10:22:42.895]                           }
[10:22:42.895]                         }
[10:22:42.895]                       }
[10:22:42.895]                       invisible(muffled)
[10:22:42.895]                     }
[10:22:42.895]                     muffleCondition(cond, pattern = "^muffle")
[10:22:42.895]                   }
[10:22:42.895]                 }
[10:22:42.895]             }
[10:22:42.895]         }))
[10:22:42.895]     }, error = function(ex) {
[10:22:42.895]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:42.895]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:42.895]                 ...future.rng), started = ...future.startTime, 
[10:22:42.895]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:42.895]             version = "1.8"), class = "FutureResult")
[10:22:42.895]     }, finally = {
[10:22:42.895]         if (!identical(...future.workdir, getwd())) 
[10:22:42.895]             setwd(...future.workdir)
[10:22:42.895]         {
[10:22:42.895]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:42.895]                 ...future.oldOptions$nwarnings <- NULL
[10:22:42.895]             }
[10:22:42.895]             base::options(...future.oldOptions)
[10:22:42.895]             if (.Platform$OS.type == "windows") {
[10:22:42.895]                 old_names <- names(...future.oldEnvVars)
[10:22:42.895]                 envs <- base::Sys.getenv()
[10:22:42.895]                 names <- names(envs)
[10:22:42.895]                 common <- intersect(names, old_names)
[10:22:42.895]                 added <- setdiff(names, old_names)
[10:22:42.895]                 removed <- setdiff(old_names, names)
[10:22:42.895]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:42.895]                   envs[common]]
[10:22:42.895]                 NAMES <- toupper(changed)
[10:22:42.895]                 args <- list()
[10:22:42.895]                 for (kk in seq_along(NAMES)) {
[10:22:42.895]                   name <- changed[[kk]]
[10:22:42.895]                   NAME <- NAMES[[kk]]
[10:22:42.895]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:42.895]                     next
[10:22:42.895]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:42.895]                 }
[10:22:42.895]                 NAMES <- toupper(added)
[10:22:42.895]                 for (kk in seq_along(NAMES)) {
[10:22:42.895]                   name <- added[[kk]]
[10:22:42.895]                   NAME <- NAMES[[kk]]
[10:22:42.895]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:42.895]                     next
[10:22:42.895]                   args[[name]] <- ""
[10:22:42.895]                 }
[10:22:42.895]                 NAMES <- toupper(removed)
[10:22:42.895]                 for (kk in seq_along(NAMES)) {
[10:22:42.895]                   name <- removed[[kk]]
[10:22:42.895]                   NAME <- NAMES[[kk]]
[10:22:42.895]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:42.895]                     next
[10:22:42.895]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:42.895]                 }
[10:22:42.895]                 if (length(args) > 0) 
[10:22:42.895]                   base::do.call(base::Sys.setenv, args = args)
[10:22:42.895]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:42.895]             }
[10:22:42.895]             else {
[10:22:42.895]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:42.895]             }
[10:22:42.895]             {
[10:22:42.895]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:42.895]                   0L) {
[10:22:42.895]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:42.895]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:42.895]                   base::options(opts)
[10:22:42.895]                 }
[10:22:42.895]                 {
[10:22:42.895]                   {
[10:22:42.895]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:42.895]                     NULL
[10:22:42.895]                   }
[10:22:42.895]                   options(future.plan = NULL)
[10:22:42.895]                   if (is.na(NA_character_)) 
[10:22:42.895]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:42.895]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:42.895]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:42.895]                     .init = FALSE)
[10:22:42.895]                 }
[10:22:42.895]             }
[10:22:42.895]         }
[10:22:42.895]     })
[10:22:42.895]     if (TRUE) {
[10:22:42.895]         base::sink(type = "output", split = FALSE)
[10:22:42.895]         if (TRUE) {
[10:22:42.895]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:42.895]         }
[10:22:42.895]         else {
[10:22:42.895]             ...future.result["stdout"] <- base::list(NULL)
[10:22:42.895]         }
[10:22:42.895]         base::close(...future.stdout)
[10:22:42.895]         ...future.stdout <- NULL
[10:22:42.895]     }
[10:22:42.895]     ...future.result$conditions <- ...future.conditions
[10:22:42.895]     ...future.result$finished <- base::Sys.time()
[10:22:42.895]     ...future.result
[10:22:42.895] }
[10:22:42.898] MultisessionFuture started
[10:22:42.898] - Launch lazy future ... done
[10:22:42.898] run() for ‘MultisessionFuture’ ... done
[10:22:42.940] receiveMessageFromWorker() for ClusterFuture ...
[10:22:42.940] - Validating connection of MultisessionFuture
[10:22:42.941] - received message: FutureResult
[10:22:42.941] - Received FutureResult
[10:22:42.941] - Erased future from FutureRegistry
[10:22:42.941] result() for ClusterFuture ...
[10:22:42.941] - result already collected: FutureResult
[10:22:42.941] result() for ClusterFuture ... done
[10:22:42.941] signalConditions() ...
[10:22:42.941]  - include = ‘immediateCondition’
[10:22:42.941]  - exclude = 
[10:22:42.941]  - resignal = FALSE
[10:22:42.941]  - Number of conditions: 1
[10:22:42.942] signalConditions() ... done
[10:22:42.942] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:42.942] A MultisessionFuture was resolved (and resolved itself)
[10:22:42.942] getGlobalsAndPackages() ...
[10:22:42.942] Searching for globals...
[10:22:42.943] - globals found: [2] ‘list’, ‘stop’
[10:22:42.943] Searching for globals ... DONE
[10:22:42.943] Resolving globals: FALSE
[10:22:42.943] 
[10:22:42.943] 
[10:22:42.943] getGlobalsAndPackages() ... DONE
[10:22:42.944] run() for ‘Future’ ...
[10:22:42.944] - state: ‘created’
[10:22:42.944] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:42.957] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:42.957] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:42.957]   - Field: ‘node’
[10:22:42.958]   - Field: ‘label’
[10:22:42.958]   - Field: ‘local’
[10:22:42.958]   - Field: ‘owner’
[10:22:42.958]   - Field: ‘envir’
[10:22:42.958]   - Field: ‘workers’
[10:22:42.958]   - Field: ‘packages’
[10:22:42.958]   - Field: ‘gc’
[10:22:42.958]   - Field: ‘conditions’
[10:22:42.958]   - Field: ‘persistent’
[10:22:42.958]   - Field: ‘expr’
[10:22:42.958]   - Field: ‘uuid’
[10:22:42.959]   - Field: ‘seed’
[10:22:42.959]   - Field: ‘version’
[10:22:42.959]   - Field: ‘result’
[10:22:42.959]   - Field: ‘asynchronous’
[10:22:42.959]   - Field: ‘calls’
[10:22:42.959]   - Field: ‘globals’
[10:22:42.959]   - Field: ‘stdout’
[10:22:42.959]   - Field: ‘earlySignal’
[10:22:42.959]   - Field: ‘lazy’
[10:22:42.959]   - Field: ‘state’
[10:22:42.959] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:42.959] - Launch lazy future ...
[10:22:42.960] Packages needed by the future expression (n = 0): <none>
[10:22:42.960] Packages needed by future strategies (n = 0): <none>
[10:22:42.960] {
[10:22:42.960]     {
[10:22:42.960]         {
[10:22:42.960]             ...future.startTime <- base::Sys.time()
[10:22:42.960]             {
[10:22:42.960]                 {
[10:22:42.960]                   {
[10:22:42.960]                     {
[10:22:42.960]                       base::local({
[10:22:42.960]                         has_future <- base::requireNamespace("future", 
[10:22:42.960]                           quietly = TRUE)
[10:22:42.960]                         if (has_future) {
[10:22:42.960]                           ns <- base::getNamespace("future")
[10:22:42.960]                           version <- ns[[".package"]][["version"]]
[10:22:42.960]                           if (is.null(version)) 
[10:22:42.960]                             version <- utils::packageVersion("future")
[10:22:42.960]                         }
[10:22:42.960]                         else {
[10:22:42.960]                           version <- NULL
[10:22:42.960]                         }
[10:22:42.960]                         if (!has_future || version < "1.8.0") {
[10:22:42.960]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:42.960]                             "", base::R.version$version.string), 
[10:22:42.960]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:42.960]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:42.960]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:42.960]                               "release", "version")], collapse = " "), 
[10:22:42.960]                             hostname = base::Sys.info()[["nodename"]])
[10:22:42.960]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:42.960]                             info)
[10:22:42.960]                           info <- base::paste(info, collapse = "; ")
[10:22:42.960]                           if (!has_future) {
[10:22:42.960]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:42.960]                               info)
[10:22:42.960]                           }
[10:22:42.960]                           else {
[10:22:42.960]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:42.960]                               info, version)
[10:22:42.960]                           }
[10:22:42.960]                           base::stop(msg)
[10:22:42.960]                         }
[10:22:42.960]                       })
[10:22:42.960]                     }
[10:22:42.960]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:42.960]                     base::options(mc.cores = 1L)
[10:22:42.960]                   }
[10:22:42.960]                   ...future.strategy.old <- future::plan("list")
[10:22:42.960]                   options(future.plan = NULL)
[10:22:42.960]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:42.960]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:42.960]                 }
[10:22:42.960]                 ...future.workdir <- getwd()
[10:22:42.960]             }
[10:22:42.960]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:42.960]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:42.960]         }
[10:22:42.960]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:42.960]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:42.960]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:42.960]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:42.960]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:42.960]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:42.960]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:42.960]             base::names(...future.oldOptions))
[10:22:42.960]     }
[10:22:42.960]     if (FALSE) {
[10:22:42.960]     }
[10:22:42.960]     else {
[10:22:42.960]         if (TRUE) {
[10:22:42.960]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:42.960]                 open = "w")
[10:22:42.960]         }
[10:22:42.960]         else {
[10:22:42.960]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:42.960]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:42.960]         }
[10:22:42.960]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:42.960]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:42.960]             base::sink(type = "output", split = FALSE)
[10:22:42.960]             base::close(...future.stdout)
[10:22:42.960]         }, add = TRUE)
[10:22:42.960]     }
[10:22:42.960]     ...future.frame <- base::sys.nframe()
[10:22:42.960]     ...future.conditions <- base::list()
[10:22:42.960]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:42.960]     if (FALSE) {
[10:22:42.960]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:42.960]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:42.960]     }
[10:22:42.960]     ...future.result <- base::tryCatch({
[10:22:42.960]         base::withCallingHandlers({
[10:22:42.960]             ...future.value <- base::withVisible(base::local({
[10:22:42.960]                 ...future.makeSendCondition <- base::local({
[10:22:42.960]                   sendCondition <- NULL
[10:22:42.960]                   function(frame = 1L) {
[10:22:42.960]                     if (is.function(sendCondition)) 
[10:22:42.960]                       return(sendCondition)
[10:22:42.960]                     ns <- getNamespace("parallel")
[10:22:42.960]                     if (exists("sendData", mode = "function", 
[10:22:42.960]                       envir = ns)) {
[10:22:42.960]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:42.960]                         envir = ns)
[10:22:42.960]                       envir <- sys.frame(frame)
[10:22:42.960]                       master <- NULL
[10:22:42.960]                       while (!identical(envir, .GlobalEnv) && 
[10:22:42.960]                         !identical(envir, emptyenv())) {
[10:22:42.960]                         if (exists("master", mode = "list", envir = envir, 
[10:22:42.960]                           inherits = FALSE)) {
[10:22:42.960]                           master <- get("master", mode = "list", 
[10:22:42.960]                             envir = envir, inherits = FALSE)
[10:22:42.960]                           if (inherits(master, c("SOCKnode", 
[10:22:42.960]                             "SOCK0node"))) {
[10:22:42.960]                             sendCondition <<- function(cond) {
[10:22:42.960]                               data <- list(type = "VALUE", value = cond, 
[10:22:42.960]                                 success = TRUE)
[10:22:42.960]                               parallel_sendData(master, data)
[10:22:42.960]                             }
[10:22:42.960]                             return(sendCondition)
[10:22:42.960]                           }
[10:22:42.960]                         }
[10:22:42.960]                         frame <- frame + 1L
[10:22:42.960]                         envir <- sys.frame(frame)
[10:22:42.960]                       }
[10:22:42.960]                     }
[10:22:42.960]                     sendCondition <<- function(cond) NULL
[10:22:42.960]                   }
[10:22:42.960]                 })
[10:22:42.960]                 withCallingHandlers({
[10:22:42.960]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:22:42.960]                 }, immediateCondition = function(cond) {
[10:22:42.960]                   sendCondition <- ...future.makeSendCondition()
[10:22:42.960]                   sendCondition(cond)
[10:22:42.960]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:42.960]                   {
[10:22:42.960]                     inherits <- base::inherits
[10:22:42.960]                     invokeRestart <- base::invokeRestart
[10:22:42.960]                     is.null <- base::is.null
[10:22:42.960]                     muffled <- FALSE
[10:22:42.960]                     if (inherits(cond, "message")) {
[10:22:42.960]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:42.960]                       if (muffled) 
[10:22:42.960]                         invokeRestart("muffleMessage")
[10:22:42.960]                     }
[10:22:42.960]                     else if (inherits(cond, "warning")) {
[10:22:42.960]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:42.960]                       if (muffled) 
[10:22:42.960]                         invokeRestart("muffleWarning")
[10:22:42.960]                     }
[10:22:42.960]                     else if (inherits(cond, "condition")) {
[10:22:42.960]                       if (!is.null(pattern)) {
[10:22:42.960]                         computeRestarts <- base::computeRestarts
[10:22:42.960]                         grepl <- base::grepl
[10:22:42.960]                         restarts <- computeRestarts(cond)
[10:22:42.960]                         for (restart in restarts) {
[10:22:42.960]                           name <- restart$name
[10:22:42.960]                           if (is.null(name)) 
[10:22:42.960]                             next
[10:22:42.960]                           if (!grepl(pattern, name)) 
[10:22:42.960]                             next
[10:22:42.960]                           invokeRestart(restart)
[10:22:42.960]                           muffled <- TRUE
[10:22:42.960]                           break
[10:22:42.960]                         }
[10:22:42.960]                       }
[10:22:42.960]                     }
[10:22:42.960]                     invisible(muffled)
[10:22:42.960]                   }
[10:22:42.960]                   muffleCondition(cond)
[10:22:42.960]                 })
[10:22:42.960]             }))
[10:22:42.960]             future::FutureResult(value = ...future.value$value, 
[10:22:42.960]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:42.960]                   ...future.rng), globalenv = if (FALSE) 
[10:22:42.960]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:42.960]                     ...future.globalenv.names))
[10:22:42.960]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:42.960]         }, condition = base::local({
[10:22:42.960]             c <- base::c
[10:22:42.960]             inherits <- base::inherits
[10:22:42.960]             invokeRestart <- base::invokeRestart
[10:22:42.960]             length <- base::length
[10:22:42.960]             list <- base::list
[10:22:42.960]             seq.int <- base::seq.int
[10:22:42.960]             signalCondition <- base::signalCondition
[10:22:42.960]             sys.calls <- base::sys.calls
[10:22:42.960]             `[[` <- base::`[[`
[10:22:42.960]             `+` <- base::`+`
[10:22:42.960]             `<<-` <- base::`<<-`
[10:22:42.960]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:42.960]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:42.960]                   3L)]
[10:22:42.960]             }
[10:22:42.960]             function(cond) {
[10:22:42.960]                 is_error <- inherits(cond, "error")
[10:22:42.960]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:42.960]                   NULL)
[10:22:42.960]                 if (is_error) {
[10:22:42.960]                   sessionInformation <- function() {
[10:22:42.960]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:42.960]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:42.960]                       search = base::search(), system = base::Sys.info())
[10:22:42.960]                   }
[10:22:42.960]                   ...future.conditions[[length(...future.conditions) + 
[10:22:42.960]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:42.960]                     cond$call), session = sessionInformation(), 
[10:22:42.960]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:42.960]                   signalCondition(cond)
[10:22:42.960]                 }
[10:22:42.960]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:42.960]                 "immediateCondition"))) {
[10:22:42.960]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:42.960]                   ...future.conditions[[length(...future.conditions) + 
[10:22:42.960]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:42.960]                   if (TRUE && !signal) {
[10:22:42.960]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:42.960]                     {
[10:22:42.960]                       inherits <- base::inherits
[10:22:42.960]                       invokeRestart <- base::invokeRestart
[10:22:42.960]                       is.null <- base::is.null
[10:22:42.960]                       muffled <- FALSE
[10:22:42.960]                       if (inherits(cond, "message")) {
[10:22:42.960]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:42.960]                         if (muffled) 
[10:22:42.960]                           invokeRestart("muffleMessage")
[10:22:42.960]                       }
[10:22:42.960]                       else if (inherits(cond, "warning")) {
[10:22:42.960]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:42.960]                         if (muffled) 
[10:22:42.960]                           invokeRestart("muffleWarning")
[10:22:42.960]                       }
[10:22:42.960]                       else if (inherits(cond, "condition")) {
[10:22:42.960]                         if (!is.null(pattern)) {
[10:22:42.960]                           computeRestarts <- base::computeRestarts
[10:22:42.960]                           grepl <- base::grepl
[10:22:42.960]                           restarts <- computeRestarts(cond)
[10:22:42.960]                           for (restart in restarts) {
[10:22:42.960]                             name <- restart$name
[10:22:42.960]                             if (is.null(name)) 
[10:22:42.960]                               next
[10:22:42.960]                             if (!grepl(pattern, name)) 
[10:22:42.960]                               next
[10:22:42.960]                             invokeRestart(restart)
[10:22:42.960]                             muffled <- TRUE
[10:22:42.960]                             break
[10:22:42.960]                           }
[10:22:42.960]                         }
[10:22:42.960]                       }
[10:22:42.960]                       invisible(muffled)
[10:22:42.960]                     }
[10:22:42.960]                     muffleCondition(cond, pattern = "^muffle")
[10:22:42.960]                   }
[10:22:42.960]                 }
[10:22:42.960]                 else {
[10:22:42.960]                   if (TRUE) {
[10:22:42.960]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:42.960]                     {
[10:22:42.960]                       inherits <- base::inherits
[10:22:42.960]                       invokeRestart <- base::invokeRestart
[10:22:42.960]                       is.null <- base::is.null
[10:22:42.960]                       muffled <- FALSE
[10:22:42.960]                       if (inherits(cond, "message")) {
[10:22:42.960]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:42.960]                         if (muffled) 
[10:22:42.960]                           invokeRestart("muffleMessage")
[10:22:42.960]                       }
[10:22:42.960]                       else if (inherits(cond, "warning")) {
[10:22:42.960]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:42.960]                         if (muffled) 
[10:22:42.960]                           invokeRestart("muffleWarning")
[10:22:42.960]                       }
[10:22:42.960]                       else if (inherits(cond, "condition")) {
[10:22:42.960]                         if (!is.null(pattern)) {
[10:22:42.960]                           computeRestarts <- base::computeRestarts
[10:22:42.960]                           grepl <- base::grepl
[10:22:42.960]                           restarts <- computeRestarts(cond)
[10:22:42.960]                           for (restart in restarts) {
[10:22:42.960]                             name <- restart$name
[10:22:42.960]                             if (is.null(name)) 
[10:22:42.960]                               next
[10:22:42.960]                             if (!grepl(pattern, name)) 
[10:22:42.960]                               next
[10:22:42.960]                             invokeRestart(restart)
[10:22:42.960]                             muffled <- TRUE
[10:22:42.960]                             break
[10:22:42.960]                           }
[10:22:42.960]                         }
[10:22:42.960]                       }
[10:22:42.960]                       invisible(muffled)
[10:22:42.960]                     }
[10:22:42.960]                     muffleCondition(cond, pattern = "^muffle")
[10:22:42.960]                   }
[10:22:42.960]                 }
[10:22:42.960]             }
[10:22:42.960]         }))
[10:22:42.960]     }, error = function(ex) {
[10:22:42.960]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:42.960]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:42.960]                 ...future.rng), started = ...future.startTime, 
[10:22:42.960]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:42.960]             version = "1.8"), class = "FutureResult")
[10:22:42.960]     }, finally = {
[10:22:42.960]         if (!identical(...future.workdir, getwd())) 
[10:22:42.960]             setwd(...future.workdir)
[10:22:42.960]         {
[10:22:42.960]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:42.960]                 ...future.oldOptions$nwarnings <- NULL
[10:22:42.960]             }
[10:22:42.960]             base::options(...future.oldOptions)
[10:22:42.960]             if (.Platform$OS.type == "windows") {
[10:22:42.960]                 old_names <- names(...future.oldEnvVars)
[10:22:42.960]                 envs <- base::Sys.getenv()
[10:22:42.960]                 names <- names(envs)
[10:22:42.960]                 common <- intersect(names, old_names)
[10:22:42.960]                 added <- setdiff(names, old_names)
[10:22:42.960]                 removed <- setdiff(old_names, names)
[10:22:42.960]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:42.960]                   envs[common]]
[10:22:42.960]                 NAMES <- toupper(changed)
[10:22:42.960]                 args <- list()
[10:22:42.960]                 for (kk in seq_along(NAMES)) {
[10:22:42.960]                   name <- changed[[kk]]
[10:22:42.960]                   NAME <- NAMES[[kk]]
[10:22:42.960]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:42.960]                     next
[10:22:42.960]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:42.960]                 }
[10:22:42.960]                 NAMES <- toupper(added)
[10:22:42.960]                 for (kk in seq_along(NAMES)) {
[10:22:42.960]                   name <- added[[kk]]
[10:22:42.960]                   NAME <- NAMES[[kk]]
[10:22:42.960]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:42.960]                     next
[10:22:42.960]                   args[[name]] <- ""
[10:22:42.960]                 }
[10:22:42.960]                 NAMES <- toupper(removed)
[10:22:42.960]                 for (kk in seq_along(NAMES)) {
[10:22:42.960]                   name <- removed[[kk]]
[10:22:42.960]                   NAME <- NAMES[[kk]]
[10:22:42.960]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:42.960]                     next
[10:22:42.960]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:42.960]                 }
[10:22:42.960]                 if (length(args) > 0) 
[10:22:42.960]                   base::do.call(base::Sys.setenv, args = args)
[10:22:42.960]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:42.960]             }
[10:22:42.960]             else {
[10:22:42.960]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:42.960]             }
[10:22:42.960]             {
[10:22:42.960]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:42.960]                   0L) {
[10:22:42.960]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:42.960]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:42.960]                   base::options(opts)
[10:22:42.960]                 }
[10:22:42.960]                 {
[10:22:42.960]                   {
[10:22:42.960]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:42.960]                     NULL
[10:22:42.960]                   }
[10:22:42.960]                   options(future.plan = NULL)
[10:22:42.960]                   if (is.na(NA_character_)) 
[10:22:42.960]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:42.960]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:42.960]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:42.960]                     .init = FALSE)
[10:22:42.960]                 }
[10:22:42.960]             }
[10:22:42.960]         }
[10:22:42.960]     })
[10:22:42.960]     if (TRUE) {
[10:22:42.960]         base::sink(type = "output", split = FALSE)
[10:22:42.960]         if (TRUE) {
[10:22:42.960]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:42.960]         }
[10:22:42.960]         else {
[10:22:42.960]             ...future.result["stdout"] <- base::list(NULL)
[10:22:42.960]         }
[10:22:42.960]         base::close(...future.stdout)
[10:22:42.960]         ...future.stdout <- NULL
[10:22:42.960]     }
[10:22:42.960]     ...future.result$conditions <- ...future.conditions
[10:22:42.960]     ...future.result$finished <- base::Sys.time()
[10:22:42.960]     ...future.result
[10:22:42.960] }
[10:22:42.963] MultisessionFuture started
[10:22:42.963] - Launch lazy future ... done
[10:22:42.963] run() for ‘MultisessionFuture’ ... done
[10:22:43.005] receiveMessageFromWorker() for ClusterFuture ...
[10:22:43.005] - Validating connection of MultisessionFuture
[10:22:43.006] - received message: FutureResult
[10:22:43.006] - Received FutureResult
[10:22:43.006] - Erased future from FutureRegistry
[10:22:43.006] result() for ClusterFuture ...
[10:22:43.006] - result already collected: FutureResult
[10:22:43.006] result() for ClusterFuture ... done
[10:22:43.006] signalConditions() ...
[10:22:43.006]  - include = ‘immediateCondition’
[10:22:43.006]  - exclude = 
[10:22:43.006]  - resignal = FALSE
[10:22:43.006]  - Number of conditions: 1
[10:22:43.007] signalConditions() ... done
[10:22:43.007] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:43.007] A MultisessionFuture was resolved (and resolved itself)
- result = TRUE, recursive = TRUE ... DONE
- result = TRUE, recursive = -1 ...
[10:22:43.007] getGlobalsAndPackages() ...
[10:22:43.007] Searching for globals...
[10:22:43.008] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:22:43.008] Searching for globals ... DONE
[10:22:43.008] Resolving globals: FALSE
[10:22:43.009] 
[10:22:43.009] 
[10:22:43.009] getGlobalsAndPackages() ... DONE
[10:22:43.009] run() for ‘Future’ ...
[10:22:43.009] - state: ‘created’
[10:22:43.009] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:43.023] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:43.023] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:43.023]   - Field: ‘node’
[10:22:43.023]   - Field: ‘label’
[10:22:43.023]   - Field: ‘local’
[10:22:43.023]   - Field: ‘owner’
[10:22:43.023]   - Field: ‘envir’
[10:22:43.023]   - Field: ‘workers’
[10:22:43.023]   - Field: ‘packages’
[10:22:43.023]   - Field: ‘gc’
[10:22:43.024]   - Field: ‘conditions’
[10:22:43.024]   - Field: ‘persistent’
[10:22:43.024]   - Field: ‘expr’
[10:22:43.024]   - Field: ‘uuid’
[10:22:43.024]   - Field: ‘seed’
[10:22:43.024]   - Field: ‘version’
[10:22:43.024]   - Field: ‘result’
[10:22:43.024]   - Field: ‘asynchronous’
[10:22:43.024]   - Field: ‘calls’
[10:22:43.024]   - Field: ‘globals’
[10:22:43.024]   - Field: ‘stdout’
[10:22:43.024]   - Field: ‘earlySignal’
[10:22:43.025]   - Field: ‘lazy’
[10:22:43.025]   - Field: ‘state’
[10:22:43.025] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:43.025] - Launch lazy future ...
[10:22:43.025] Packages needed by the future expression (n = 0): <none>
[10:22:43.025] Packages needed by future strategies (n = 0): <none>
[10:22:43.026] {
[10:22:43.026]     {
[10:22:43.026]         {
[10:22:43.026]             ...future.startTime <- base::Sys.time()
[10:22:43.026]             {
[10:22:43.026]                 {
[10:22:43.026]                   {
[10:22:43.026]                     {
[10:22:43.026]                       base::local({
[10:22:43.026]                         has_future <- base::requireNamespace("future", 
[10:22:43.026]                           quietly = TRUE)
[10:22:43.026]                         if (has_future) {
[10:22:43.026]                           ns <- base::getNamespace("future")
[10:22:43.026]                           version <- ns[[".package"]][["version"]]
[10:22:43.026]                           if (is.null(version)) 
[10:22:43.026]                             version <- utils::packageVersion("future")
[10:22:43.026]                         }
[10:22:43.026]                         else {
[10:22:43.026]                           version <- NULL
[10:22:43.026]                         }
[10:22:43.026]                         if (!has_future || version < "1.8.0") {
[10:22:43.026]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:43.026]                             "", base::R.version$version.string), 
[10:22:43.026]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:43.026]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:43.026]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:43.026]                               "release", "version")], collapse = " "), 
[10:22:43.026]                             hostname = base::Sys.info()[["nodename"]])
[10:22:43.026]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:43.026]                             info)
[10:22:43.026]                           info <- base::paste(info, collapse = "; ")
[10:22:43.026]                           if (!has_future) {
[10:22:43.026]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:43.026]                               info)
[10:22:43.026]                           }
[10:22:43.026]                           else {
[10:22:43.026]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:43.026]                               info, version)
[10:22:43.026]                           }
[10:22:43.026]                           base::stop(msg)
[10:22:43.026]                         }
[10:22:43.026]                       })
[10:22:43.026]                     }
[10:22:43.026]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:43.026]                     base::options(mc.cores = 1L)
[10:22:43.026]                   }
[10:22:43.026]                   ...future.strategy.old <- future::plan("list")
[10:22:43.026]                   options(future.plan = NULL)
[10:22:43.026]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:43.026]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:43.026]                 }
[10:22:43.026]                 ...future.workdir <- getwd()
[10:22:43.026]             }
[10:22:43.026]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:43.026]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:43.026]         }
[10:22:43.026]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:43.026]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:43.026]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:43.026]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:43.026]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:43.026]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:43.026]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:43.026]             base::names(...future.oldOptions))
[10:22:43.026]     }
[10:22:43.026]     if (FALSE) {
[10:22:43.026]     }
[10:22:43.026]     else {
[10:22:43.026]         if (TRUE) {
[10:22:43.026]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:43.026]                 open = "w")
[10:22:43.026]         }
[10:22:43.026]         else {
[10:22:43.026]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:43.026]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:43.026]         }
[10:22:43.026]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:43.026]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:43.026]             base::sink(type = "output", split = FALSE)
[10:22:43.026]             base::close(...future.stdout)
[10:22:43.026]         }, add = TRUE)
[10:22:43.026]     }
[10:22:43.026]     ...future.frame <- base::sys.nframe()
[10:22:43.026]     ...future.conditions <- base::list()
[10:22:43.026]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:43.026]     if (FALSE) {
[10:22:43.026]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:43.026]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:43.026]     }
[10:22:43.026]     ...future.result <- base::tryCatch({
[10:22:43.026]         base::withCallingHandlers({
[10:22:43.026]             ...future.value <- base::withVisible(base::local({
[10:22:43.026]                 ...future.makeSendCondition <- base::local({
[10:22:43.026]                   sendCondition <- NULL
[10:22:43.026]                   function(frame = 1L) {
[10:22:43.026]                     if (is.function(sendCondition)) 
[10:22:43.026]                       return(sendCondition)
[10:22:43.026]                     ns <- getNamespace("parallel")
[10:22:43.026]                     if (exists("sendData", mode = "function", 
[10:22:43.026]                       envir = ns)) {
[10:22:43.026]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:43.026]                         envir = ns)
[10:22:43.026]                       envir <- sys.frame(frame)
[10:22:43.026]                       master <- NULL
[10:22:43.026]                       while (!identical(envir, .GlobalEnv) && 
[10:22:43.026]                         !identical(envir, emptyenv())) {
[10:22:43.026]                         if (exists("master", mode = "list", envir = envir, 
[10:22:43.026]                           inherits = FALSE)) {
[10:22:43.026]                           master <- get("master", mode = "list", 
[10:22:43.026]                             envir = envir, inherits = FALSE)
[10:22:43.026]                           if (inherits(master, c("SOCKnode", 
[10:22:43.026]                             "SOCK0node"))) {
[10:22:43.026]                             sendCondition <<- function(cond) {
[10:22:43.026]                               data <- list(type = "VALUE", value = cond, 
[10:22:43.026]                                 success = TRUE)
[10:22:43.026]                               parallel_sendData(master, data)
[10:22:43.026]                             }
[10:22:43.026]                             return(sendCondition)
[10:22:43.026]                           }
[10:22:43.026]                         }
[10:22:43.026]                         frame <- frame + 1L
[10:22:43.026]                         envir <- sys.frame(frame)
[10:22:43.026]                       }
[10:22:43.026]                     }
[10:22:43.026]                     sendCondition <<- function(cond) NULL
[10:22:43.026]                   }
[10:22:43.026]                 })
[10:22:43.026]                 withCallingHandlers({
[10:22:43.026]                   {
[10:22:43.026]                     Sys.sleep(0.5)
[10:22:43.026]                     list(a = 1, b = 42L)
[10:22:43.026]                   }
[10:22:43.026]                 }, immediateCondition = function(cond) {
[10:22:43.026]                   sendCondition <- ...future.makeSendCondition()
[10:22:43.026]                   sendCondition(cond)
[10:22:43.026]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:43.026]                   {
[10:22:43.026]                     inherits <- base::inherits
[10:22:43.026]                     invokeRestart <- base::invokeRestart
[10:22:43.026]                     is.null <- base::is.null
[10:22:43.026]                     muffled <- FALSE
[10:22:43.026]                     if (inherits(cond, "message")) {
[10:22:43.026]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:43.026]                       if (muffled) 
[10:22:43.026]                         invokeRestart("muffleMessage")
[10:22:43.026]                     }
[10:22:43.026]                     else if (inherits(cond, "warning")) {
[10:22:43.026]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:43.026]                       if (muffled) 
[10:22:43.026]                         invokeRestart("muffleWarning")
[10:22:43.026]                     }
[10:22:43.026]                     else if (inherits(cond, "condition")) {
[10:22:43.026]                       if (!is.null(pattern)) {
[10:22:43.026]                         computeRestarts <- base::computeRestarts
[10:22:43.026]                         grepl <- base::grepl
[10:22:43.026]                         restarts <- computeRestarts(cond)
[10:22:43.026]                         for (restart in restarts) {
[10:22:43.026]                           name <- restart$name
[10:22:43.026]                           if (is.null(name)) 
[10:22:43.026]                             next
[10:22:43.026]                           if (!grepl(pattern, name)) 
[10:22:43.026]                             next
[10:22:43.026]                           invokeRestart(restart)
[10:22:43.026]                           muffled <- TRUE
[10:22:43.026]                           break
[10:22:43.026]                         }
[10:22:43.026]                       }
[10:22:43.026]                     }
[10:22:43.026]                     invisible(muffled)
[10:22:43.026]                   }
[10:22:43.026]                   muffleCondition(cond)
[10:22:43.026]                 })
[10:22:43.026]             }))
[10:22:43.026]             future::FutureResult(value = ...future.value$value, 
[10:22:43.026]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:43.026]                   ...future.rng), globalenv = if (FALSE) 
[10:22:43.026]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:43.026]                     ...future.globalenv.names))
[10:22:43.026]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:43.026]         }, condition = base::local({
[10:22:43.026]             c <- base::c
[10:22:43.026]             inherits <- base::inherits
[10:22:43.026]             invokeRestart <- base::invokeRestart
[10:22:43.026]             length <- base::length
[10:22:43.026]             list <- base::list
[10:22:43.026]             seq.int <- base::seq.int
[10:22:43.026]             signalCondition <- base::signalCondition
[10:22:43.026]             sys.calls <- base::sys.calls
[10:22:43.026]             `[[` <- base::`[[`
[10:22:43.026]             `+` <- base::`+`
[10:22:43.026]             `<<-` <- base::`<<-`
[10:22:43.026]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:43.026]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:43.026]                   3L)]
[10:22:43.026]             }
[10:22:43.026]             function(cond) {
[10:22:43.026]                 is_error <- inherits(cond, "error")
[10:22:43.026]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:43.026]                   NULL)
[10:22:43.026]                 if (is_error) {
[10:22:43.026]                   sessionInformation <- function() {
[10:22:43.026]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:43.026]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:43.026]                       search = base::search(), system = base::Sys.info())
[10:22:43.026]                   }
[10:22:43.026]                   ...future.conditions[[length(...future.conditions) + 
[10:22:43.026]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:43.026]                     cond$call), session = sessionInformation(), 
[10:22:43.026]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:43.026]                   signalCondition(cond)
[10:22:43.026]                 }
[10:22:43.026]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:43.026]                 "immediateCondition"))) {
[10:22:43.026]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:43.026]                   ...future.conditions[[length(...future.conditions) + 
[10:22:43.026]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:43.026]                   if (TRUE && !signal) {
[10:22:43.026]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:43.026]                     {
[10:22:43.026]                       inherits <- base::inherits
[10:22:43.026]                       invokeRestart <- base::invokeRestart
[10:22:43.026]                       is.null <- base::is.null
[10:22:43.026]                       muffled <- FALSE
[10:22:43.026]                       if (inherits(cond, "message")) {
[10:22:43.026]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:43.026]                         if (muffled) 
[10:22:43.026]                           invokeRestart("muffleMessage")
[10:22:43.026]                       }
[10:22:43.026]                       else if (inherits(cond, "warning")) {
[10:22:43.026]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:43.026]                         if (muffled) 
[10:22:43.026]                           invokeRestart("muffleWarning")
[10:22:43.026]                       }
[10:22:43.026]                       else if (inherits(cond, "condition")) {
[10:22:43.026]                         if (!is.null(pattern)) {
[10:22:43.026]                           computeRestarts <- base::computeRestarts
[10:22:43.026]                           grepl <- base::grepl
[10:22:43.026]                           restarts <- computeRestarts(cond)
[10:22:43.026]                           for (restart in restarts) {
[10:22:43.026]                             name <- restart$name
[10:22:43.026]                             if (is.null(name)) 
[10:22:43.026]                               next
[10:22:43.026]                             if (!grepl(pattern, name)) 
[10:22:43.026]                               next
[10:22:43.026]                             invokeRestart(restart)
[10:22:43.026]                             muffled <- TRUE
[10:22:43.026]                             break
[10:22:43.026]                           }
[10:22:43.026]                         }
[10:22:43.026]                       }
[10:22:43.026]                       invisible(muffled)
[10:22:43.026]                     }
[10:22:43.026]                     muffleCondition(cond, pattern = "^muffle")
[10:22:43.026]                   }
[10:22:43.026]                 }
[10:22:43.026]                 else {
[10:22:43.026]                   if (TRUE) {
[10:22:43.026]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:43.026]                     {
[10:22:43.026]                       inherits <- base::inherits
[10:22:43.026]                       invokeRestart <- base::invokeRestart
[10:22:43.026]                       is.null <- base::is.null
[10:22:43.026]                       muffled <- FALSE
[10:22:43.026]                       if (inherits(cond, "message")) {
[10:22:43.026]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:43.026]                         if (muffled) 
[10:22:43.026]                           invokeRestart("muffleMessage")
[10:22:43.026]                       }
[10:22:43.026]                       else if (inherits(cond, "warning")) {
[10:22:43.026]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:43.026]                         if (muffled) 
[10:22:43.026]                           invokeRestart("muffleWarning")
[10:22:43.026]                       }
[10:22:43.026]                       else if (inherits(cond, "condition")) {
[10:22:43.026]                         if (!is.null(pattern)) {
[10:22:43.026]                           computeRestarts <- base::computeRestarts
[10:22:43.026]                           grepl <- base::grepl
[10:22:43.026]                           restarts <- computeRestarts(cond)
[10:22:43.026]                           for (restart in restarts) {
[10:22:43.026]                             name <- restart$name
[10:22:43.026]                             if (is.null(name)) 
[10:22:43.026]                               next
[10:22:43.026]                             if (!grepl(pattern, name)) 
[10:22:43.026]                               next
[10:22:43.026]                             invokeRestart(restart)
[10:22:43.026]                             muffled <- TRUE
[10:22:43.026]                             break
[10:22:43.026]                           }
[10:22:43.026]                         }
[10:22:43.026]                       }
[10:22:43.026]                       invisible(muffled)
[10:22:43.026]                     }
[10:22:43.026]                     muffleCondition(cond, pattern = "^muffle")
[10:22:43.026]                   }
[10:22:43.026]                 }
[10:22:43.026]             }
[10:22:43.026]         }))
[10:22:43.026]     }, error = function(ex) {
[10:22:43.026]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:43.026]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:43.026]                 ...future.rng), started = ...future.startTime, 
[10:22:43.026]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:43.026]             version = "1.8"), class = "FutureResult")
[10:22:43.026]     }, finally = {
[10:22:43.026]         if (!identical(...future.workdir, getwd())) 
[10:22:43.026]             setwd(...future.workdir)
[10:22:43.026]         {
[10:22:43.026]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:43.026]                 ...future.oldOptions$nwarnings <- NULL
[10:22:43.026]             }
[10:22:43.026]             base::options(...future.oldOptions)
[10:22:43.026]             if (.Platform$OS.type == "windows") {
[10:22:43.026]                 old_names <- names(...future.oldEnvVars)
[10:22:43.026]                 envs <- base::Sys.getenv()
[10:22:43.026]                 names <- names(envs)
[10:22:43.026]                 common <- intersect(names, old_names)
[10:22:43.026]                 added <- setdiff(names, old_names)
[10:22:43.026]                 removed <- setdiff(old_names, names)
[10:22:43.026]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:43.026]                   envs[common]]
[10:22:43.026]                 NAMES <- toupper(changed)
[10:22:43.026]                 args <- list()
[10:22:43.026]                 for (kk in seq_along(NAMES)) {
[10:22:43.026]                   name <- changed[[kk]]
[10:22:43.026]                   NAME <- NAMES[[kk]]
[10:22:43.026]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:43.026]                     next
[10:22:43.026]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:43.026]                 }
[10:22:43.026]                 NAMES <- toupper(added)
[10:22:43.026]                 for (kk in seq_along(NAMES)) {
[10:22:43.026]                   name <- added[[kk]]
[10:22:43.026]                   NAME <- NAMES[[kk]]
[10:22:43.026]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:43.026]                     next
[10:22:43.026]                   args[[name]] <- ""
[10:22:43.026]                 }
[10:22:43.026]                 NAMES <- toupper(removed)
[10:22:43.026]                 for (kk in seq_along(NAMES)) {
[10:22:43.026]                   name <- removed[[kk]]
[10:22:43.026]                   NAME <- NAMES[[kk]]
[10:22:43.026]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:43.026]                     next
[10:22:43.026]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:43.026]                 }
[10:22:43.026]                 if (length(args) > 0) 
[10:22:43.026]                   base::do.call(base::Sys.setenv, args = args)
[10:22:43.026]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:43.026]             }
[10:22:43.026]             else {
[10:22:43.026]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:43.026]             }
[10:22:43.026]             {
[10:22:43.026]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:43.026]                   0L) {
[10:22:43.026]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:43.026]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:43.026]                   base::options(opts)
[10:22:43.026]                 }
[10:22:43.026]                 {
[10:22:43.026]                   {
[10:22:43.026]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:43.026]                     NULL
[10:22:43.026]                   }
[10:22:43.026]                   options(future.plan = NULL)
[10:22:43.026]                   if (is.na(NA_character_)) 
[10:22:43.026]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:43.026]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:43.026]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:43.026]                     .init = FALSE)
[10:22:43.026]                 }
[10:22:43.026]             }
[10:22:43.026]         }
[10:22:43.026]     })
[10:22:43.026]     if (TRUE) {
[10:22:43.026]         base::sink(type = "output", split = FALSE)
[10:22:43.026]         if (TRUE) {
[10:22:43.026]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:43.026]         }
[10:22:43.026]         else {
[10:22:43.026]             ...future.result["stdout"] <- base::list(NULL)
[10:22:43.026]         }
[10:22:43.026]         base::close(...future.stdout)
[10:22:43.026]         ...future.stdout <- NULL
[10:22:43.026]     }
[10:22:43.026]     ...future.result$conditions <- ...future.conditions
[10:22:43.026]     ...future.result$finished <- base::Sys.time()
[10:22:43.026]     ...future.result
[10:22:43.026] }
[10:22:43.028] MultisessionFuture started
[10:22:43.029] - Launch lazy future ... done
[10:22:43.029] run() for ‘MultisessionFuture’ ... done
[10:22:43.029] getGlobalsAndPackages() ...
[10:22:43.029] Searching for globals...
[10:22:43.035] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:22:43.035] Searching for globals ... DONE
[10:22:43.035] Resolving globals: FALSE
[10:22:43.035] 
[10:22:43.035] 
[10:22:43.035] getGlobalsAndPackages() ... DONE
- w/ exception ...
[10:22:43.036] getGlobalsAndPackages() ...
[10:22:43.036] Searching for globals...
[10:22:43.036] - globals found: [2] ‘list’, ‘stop’
[10:22:43.036] Searching for globals ... DONE
[10:22:43.036] Resolving globals: FALSE
[10:22:43.037] 
[10:22:43.037] 
[10:22:43.037] getGlobalsAndPackages() ... DONE
[10:22:43.037] run() for ‘Future’ ...
[10:22:43.037] - state: ‘created’
[10:22:43.037] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:43.051] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:43.051] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:43.051]   - Field: ‘node’
[10:22:43.052]   - Field: ‘label’
[10:22:43.052]   - Field: ‘local’
[10:22:43.052]   - Field: ‘owner’
[10:22:43.052]   - Field: ‘envir’
[10:22:43.052]   - Field: ‘workers’
[10:22:43.052]   - Field: ‘packages’
[10:22:43.052]   - Field: ‘gc’
[10:22:43.052]   - Field: ‘conditions’
[10:22:43.052]   - Field: ‘persistent’
[10:22:43.052]   - Field: ‘expr’
[10:22:43.052]   - Field: ‘uuid’
[10:22:43.052]   - Field: ‘seed’
[10:22:43.053]   - Field: ‘version’
[10:22:43.053]   - Field: ‘result’
[10:22:43.053]   - Field: ‘asynchronous’
[10:22:43.053]   - Field: ‘calls’
[10:22:43.053]   - Field: ‘globals’
[10:22:43.053]   - Field: ‘stdout’
[10:22:43.053]   - Field: ‘earlySignal’
[10:22:43.053]   - Field: ‘lazy’
[10:22:43.053]   - Field: ‘state’
[10:22:43.053] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:43.053] - Launch lazy future ...
[10:22:43.054] Packages needed by the future expression (n = 0): <none>
[10:22:43.054] Packages needed by future strategies (n = 0): <none>
[10:22:43.054] {
[10:22:43.054]     {
[10:22:43.054]         {
[10:22:43.054]             ...future.startTime <- base::Sys.time()
[10:22:43.054]             {
[10:22:43.054]                 {
[10:22:43.054]                   {
[10:22:43.054]                     {
[10:22:43.054]                       base::local({
[10:22:43.054]                         has_future <- base::requireNamespace("future", 
[10:22:43.054]                           quietly = TRUE)
[10:22:43.054]                         if (has_future) {
[10:22:43.054]                           ns <- base::getNamespace("future")
[10:22:43.054]                           version <- ns[[".package"]][["version"]]
[10:22:43.054]                           if (is.null(version)) 
[10:22:43.054]                             version <- utils::packageVersion("future")
[10:22:43.054]                         }
[10:22:43.054]                         else {
[10:22:43.054]                           version <- NULL
[10:22:43.054]                         }
[10:22:43.054]                         if (!has_future || version < "1.8.0") {
[10:22:43.054]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:43.054]                             "", base::R.version$version.string), 
[10:22:43.054]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:43.054]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:43.054]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:43.054]                               "release", "version")], collapse = " "), 
[10:22:43.054]                             hostname = base::Sys.info()[["nodename"]])
[10:22:43.054]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:43.054]                             info)
[10:22:43.054]                           info <- base::paste(info, collapse = "; ")
[10:22:43.054]                           if (!has_future) {
[10:22:43.054]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:43.054]                               info)
[10:22:43.054]                           }
[10:22:43.054]                           else {
[10:22:43.054]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:43.054]                               info, version)
[10:22:43.054]                           }
[10:22:43.054]                           base::stop(msg)
[10:22:43.054]                         }
[10:22:43.054]                       })
[10:22:43.054]                     }
[10:22:43.054]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:43.054]                     base::options(mc.cores = 1L)
[10:22:43.054]                   }
[10:22:43.054]                   ...future.strategy.old <- future::plan("list")
[10:22:43.054]                   options(future.plan = NULL)
[10:22:43.054]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:43.054]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:43.054]                 }
[10:22:43.054]                 ...future.workdir <- getwd()
[10:22:43.054]             }
[10:22:43.054]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:43.054]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:43.054]         }
[10:22:43.054]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:43.054]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:43.054]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:43.054]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:43.054]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:43.054]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:43.054]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:43.054]             base::names(...future.oldOptions))
[10:22:43.054]     }
[10:22:43.054]     if (FALSE) {
[10:22:43.054]     }
[10:22:43.054]     else {
[10:22:43.054]         if (TRUE) {
[10:22:43.054]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:43.054]                 open = "w")
[10:22:43.054]         }
[10:22:43.054]         else {
[10:22:43.054]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:43.054]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:43.054]         }
[10:22:43.054]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:43.054]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:43.054]             base::sink(type = "output", split = FALSE)
[10:22:43.054]             base::close(...future.stdout)
[10:22:43.054]         }, add = TRUE)
[10:22:43.054]     }
[10:22:43.054]     ...future.frame <- base::sys.nframe()
[10:22:43.054]     ...future.conditions <- base::list()
[10:22:43.054]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:43.054]     if (FALSE) {
[10:22:43.054]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:43.054]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:43.054]     }
[10:22:43.054]     ...future.result <- base::tryCatch({
[10:22:43.054]         base::withCallingHandlers({
[10:22:43.054]             ...future.value <- base::withVisible(base::local({
[10:22:43.054]                 ...future.makeSendCondition <- base::local({
[10:22:43.054]                   sendCondition <- NULL
[10:22:43.054]                   function(frame = 1L) {
[10:22:43.054]                     if (is.function(sendCondition)) 
[10:22:43.054]                       return(sendCondition)
[10:22:43.054]                     ns <- getNamespace("parallel")
[10:22:43.054]                     if (exists("sendData", mode = "function", 
[10:22:43.054]                       envir = ns)) {
[10:22:43.054]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:43.054]                         envir = ns)
[10:22:43.054]                       envir <- sys.frame(frame)
[10:22:43.054]                       master <- NULL
[10:22:43.054]                       while (!identical(envir, .GlobalEnv) && 
[10:22:43.054]                         !identical(envir, emptyenv())) {
[10:22:43.054]                         if (exists("master", mode = "list", envir = envir, 
[10:22:43.054]                           inherits = FALSE)) {
[10:22:43.054]                           master <- get("master", mode = "list", 
[10:22:43.054]                             envir = envir, inherits = FALSE)
[10:22:43.054]                           if (inherits(master, c("SOCKnode", 
[10:22:43.054]                             "SOCK0node"))) {
[10:22:43.054]                             sendCondition <<- function(cond) {
[10:22:43.054]                               data <- list(type = "VALUE", value = cond, 
[10:22:43.054]                                 success = TRUE)
[10:22:43.054]                               parallel_sendData(master, data)
[10:22:43.054]                             }
[10:22:43.054]                             return(sendCondition)
[10:22:43.054]                           }
[10:22:43.054]                         }
[10:22:43.054]                         frame <- frame + 1L
[10:22:43.054]                         envir <- sys.frame(frame)
[10:22:43.054]                       }
[10:22:43.054]                     }
[10:22:43.054]                     sendCondition <<- function(cond) NULL
[10:22:43.054]                   }
[10:22:43.054]                 })
[10:22:43.054]                 withCallingHandlers({
[10:22:43.054]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:22:43.054]                 }, immediateCondition = function(cond) {
[10:22:43.054]                   sendCondition <- ...future.makeSendCondition()
[10:22:43.054]                   sendCondition(cond)
[10:22:43.054]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:43.054]                   {
[10:22:43.054]                     inherits <- base::inherits
[10:22:43.054]                     invokeRestart <- base::invokeRestart
[10:22:43.054]                     is.null <- base::is.null
[10:22:43.054]                     muffled <- FALSE
[10:22:43.054]                     if (inherits(cond, "message")) {
[10:22:43.054]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:43.054]                       if (muffled) 
[10:22:43.054]                         invokeRestart("muffleMessage")
[10:22:43.054]                     }
[10:22:43.054]                     else if (inherits(cond, "warning")) {
[10:22:43.054]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:43.054]                       if (muffled) 
[10:22:43.054]                         invokeRestart("muffleWarning")
[10:22:43.054]                     }
[10:22:43.054]                     else if (inherits(cond, "condition")) {
[10:22:43.054]                       if (!is.null(pattern)) {
[10:22:43.054]                         computeRestarts <- base::computeRestarts
[10:22:43.054]                         grepl <- base::grepl
[10:22:43.054]                         restarts <- computeRestarts(cond)
[10:22:43.054]                         for (restart in restarts) {
[10:22:43.054]                           name <- restart$name
[10:22:43.054]                           if (is.null(name)) 
[10:22:43.054]                             next
[10:22:43.054]                           if (!grepl(pattern, name)) 
[10:22:43.054]                             next
[10:22:43.054]                           invokeRestart(restart)
[10:22:43.054]                           muffled <- TRUE
[10:22:43.054]                           break
[10:22:43.054]                         }
[10:22:43.054]                       }
[10:22:43.054]                     }
[10:22:43.054]                     invisible(muffled)
[10:22:43.054]                   }
[10:22:43.054]                   muffleCondition(cond)
[10:22:43.054]                 })
[10:22:43.054]             }))
[10:22:43.054]             future::FutureResult(value = ...future.value$value, 
[10:22:43.054]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:43.054]                   ...future.rng), globalenv = if (FALSE) 
[10:22:43.054]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:43.054]                     ...future.globalenv.names))
[10:22:43.054]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:43.054]         }, condition = base::local({
[10:22:43.054]             c <- base::c
[10:22:43.054]             inherits <- base::inherits
[10:22:43.054]             invokeRestart <- base::invokeRestart
[10:22:43.054]             length <- base::length
[10:22:43.054]             list <- base::list
[10:22:43.054]             seq.int <- base::seq.int
[10:22:43.054]             signalCondition <- base::signalCondition
[10:22:43.054]             sys.calls <- base::sys.calls
[10:22:43.054]             `[[` <- base::`[[`
[10:22:43.054]             `+` <- base::`+`
[10:22:43.054]             `<<-` <- base::`<<-`
[10:22:43.054]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:43.054]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:43.054]                   3L)]
[10:22:43.054]             }
[10:22:43.054]             function(cond) {
[10:22:43.054]                 is_error <- inherits(cond, "error")
[10:22:43.054]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:43.054]                   NULL)
[10:22:43.054]                 if (is_error) {
[10:22:43.054]                   sessionInformation <- function() {
[10:22:43.054]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:43.054]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:43.054]                       search = base::search(), system = base::Sys.info())
[10:22:43.054]                   }
[10:22:43.054]                   ...future.conditions[[length(...future.conditions) + 
[10:22:43.054]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:43.054]                     cond$call), session = sessionInformation(), 
[10:22:43.054]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:43.054]                   signalCondition(cond)
[10:22:43.054]                 }
[10:22:43.054]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:43.054]                 "immediateCondition"))) {
[10:22:43.054]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:43.054]                   ...future.conditions[[length(...future.conditions) + 
[10:22:43.054]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:43.054]                   if (TRUE && !signal) {
[10:22:43.054]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:43.054]                     {
[10:22:43.054]                       inherits <- base::inherits
[10:22:43.054]                       invokeRestart <- base::invokeRestart
[10:22:43.054]                       is.null <- base::is.null
[10:22:43.054]                       muffled <- FALSE
[10:22:43.054]                       if (inherits(cond, "message")) {
[10:22:43.054]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:43.054]                         if (muffled) 
[10:22:43.054]                           invokeRestart("muffleMessage")
[10:22:43.054]                       }
[10:22:43.054]                       else if (inherits(cond, "warning")) {
[10:22:43.054]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:43.054]                         if (muffled) 
[10:22:43.054]                           invokeRestart("muffleWarning")
[10:22:43.054]                       }
[10:22:43.054]                       else if (inherits(cond, "condition")) {
[10:22:43.054]                         if (!is.null(pattern)) {
[10:22:43.054]                           computeRestarts <- base::computeRestarts
[10:22:43.054]                           grepl <- base::grepl
[10:22:43.054]                           restarts <- computeRestarts(cond)
[10:22:43.054]                           for (restart in restarts) {
[10:22:43.054]                             name <- restart$name
[10:22:43.054]                             if (is.null(name)) 
[10:22:43.054]                               next
[10:22:43.054]                             if (!grepl(pattern, name)) 
[10:22:43.054]                               next
[10:22:43.054]                             invokeRestart(restart)
[10:22:43.054]                             muffled <- TRUE
[10:22:43.054]                             break
[10:22:43.054]                           }
[10:22:43.054]                         }
[10:22:43.054]                       }
[10:22:43.054]                       invisible(muffled)
[10:22:43.054]                     }
[10:22:43.054]                     muffleCondition(cond, pattern = "^muffle")
[10:22:43.054]                   }
[10:22:43.054]                 }
[10:22:43.054]                 else {
[10:22:43.054]                   if (TRUE) {
[10:22:43.054]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:43.054]                     {
[10:22:43.054]                       inherits <- base::inherits
[10:22:43.054]                       invokeRestart <- base::invokeRestart
[10:22:43.054]                       is.null <- base::is.null
[10:22:43.054]                       muffled <- FALSE
[10:22:43.054]                       if (inherits(cond, "message")) {
[10:22:43.054]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:43.054]                         if (muffled) 
[10:22:43.054]                           invokeRestart("muffleMessage")
[10:22:43.054]                       }
[10:22:43.054]                       else if (inherits(cond, "warning")) {
[10:22:43.054]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:43.054]                         if (muffled) 
[10:22:43.054]                           invokeRestart("muffleWarning")
[10:22:43.054]                       }
[10:22:43.054]                       else if (inherits(cond, "condition")) {
[10:22:43.054]                         if (!is.null(pattern)) {
[10:22:43.054]                           computeRestarts <- base::computeRestarts
[10:22:43.054]                           grepl <- base::grepl
[10:22:43.054]                           restarts <- computeRestarts(cond)
[10:22:43.054]                           for (restart in restarts) {
[10:22:43.054]                             name <- restart$name
[10:22:43.054]                             if (is.null(name)) 
[10:22:43.054]                               next
[10:22:43.054]                             if (!grepl(pattern, name)) 
[10:22:43.054]                               next
[10:22:43.054]                             invokeRestart(restart)
[10:22:43.054]                             muffled <- TRUE
[10:22:43.054]                             break
[10:22:43.054]                           }
[10:22:43.054]                         }
[10:22:43.054]                       }
[10:22:43.054]                       invisible(muffled)
[10:22:43.054]                     }
[10:22:43.054]                     muffleCondition(cond, pattern = "^muffle")
[10:22:43.054]                   }
[10:22:43.054]                 }
[10:22:43.054]             }
[10:22:43.054]         }))
[10:22:43.054]     }, error = function(ex) {
[10:22:43.054]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:43.054]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:43.054]                 ...future.rng), started = ...future.startTime, 
[10:22:43.054]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:43.054]             version = "1.8"), class = "FutureResult")
[10:22:43.054]     }, finally = {
[10:22:43.054]         if (!identical(...future.workdir, getwd())) 
[10:22:43.054]             setwd(...future.workdir)
[10:22:43.054]         {
[10:22:43.054]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:43.054]                 ...future.oldOptions$nwarnings <- NULL
[10:22:43.054]             }
[10:22:43.054]             base::options(...future.oldOptions)
[10:22:43.054]             if (.Platform$OS.type == "windows") {
[10:22:43.054]                 old_names <- names(...future.oldEnvVars)
[10:22:43.054]                 envs <- base::Sys.getenv()
[10:22:43.054]                 names <- names(envs)
[10:22:43.054]                 common <- intersect(names, old_names)
[10:22:43.054]                 added <- setdiff(names, old_names)
[10:22:43.054]                 removed <- setdiff(old_names, names)
[10:22:43.054]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:43.054]                   envs[common]]
[10:22:43.054]                 NAMES <- toupper(changed)
[10:22:43.054]                 args <- list()
[10:22:43.054]                 for (kk in seq_along(NAMES)) {
[10:22:43.054]                   name <- changed[[kk]]
[10:22:43.054]                   NAME <- NAMES[[kk]]
[10:22:43.054]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:43.054]                     next
[10:22:43.054]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:43.054]                 }
[10:22:43.054]                 NAMES <- toupper(added)
[10:22:43.054]                 for (kk in seq_along(NAMES)) {
[10:22:43.054]                   name <- added[[kk]]
[10:22:43.054]                   NAME <- NAMES[[kk]]
[10:22:43.054]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:43.054]                     next
[10:22:43.054]                   args[[name]] <- ""
[10:22:43.054]                 }
[10:22:43.054]                 NAMES <- toupper(removed)
[10:22:43.054]                 for (kk in seq_along(NAMES)) {
[10:22:43.054]                   name <- removed[[kk]]
[10:22:43.054]                   NAME <- NAMES[[kk]]
[10:22:43.054]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:43.054]                     next
[10:22:43.054]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:43.054]                 }
[10:22:43.054]                 if (length(args) > 0) 
[10:22:43.054]                   base::do.call(base::Sys.setenv, args = args)
[10:22:43.054]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:43.054]             }
[10:22:43.054]             else {
[10:22:43.054]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:43.054]             }
[10:22:43.054]             {
[10:22:43.054]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:43.054]                   0L) {
[10:22:43.054]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:43.054]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:43.054]                   base::options(opts)
[10:22:43.054]                 }
[10:22:43.054]                 {
[10:22:43.054]                   {
[10:22:43.054]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:43.054]                     NULL
[10:22:43.054]                   }
[10:22:43.054]                   options(future.plan = NULL)
[10:22:43.054]                   if (is.na(NA_character_)) 
[10:22:43.054]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:43.054]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:43.054]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:43.054]                     .init = FALSE)
[10:22:43.054]                 }
[10:22:43.054]             }
[10:22:43.054]         }
[10:22:43.054]     })
[10:22:43.054]     if (TRUE) {
[10:22:43.054]         base::sink(type = "output", split = FALSE)
[10:22:43.054]         if (TRUE) {
[10:22:43.054]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:43.054]         }
[10:22:43.054]         else {
[10:22:43.054]             ...future.result["stdout"] <- base::list(NULL)
[10:22:43.054]         }
[10:22:43.054]         base::close(...future.stdout)
[10:22:43.054]         ...future.stdout <- NULL
[10:22:43.054]     }
[10:22:43.054]     ...future.result$conditions <- ...future.conditions
[10:22:43.054]     ...future.result$finished <- base::Sys.time()
[10:22:43.054]     ...future.result
[10:22:43.054] }
[10:22:43.056] Poll #1 (0): usedNodes() = 2, workers = 2
[10:22:43.067] receiveMessageFromWorker() for ClusterFuture ...
[10:22:43.067] - Validating connection of MultisessionFuture
[10:22:43.067] - received message: FutureResult
[10:22:43.067] - Received FutureResult
[10:22:43.067] - Erased future from FutureRegistry
[10:22:43.068] result() for ClusterFuture ...
[10:22:43.068] - result already collected: FutureResult
[10:22:43.068] result() for ClusterFuture ... done
[10:22:43.068] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:43.068] result() for ClusterFuture ...
[10:22:43.068] - result already collected: FutureResult
[10:22:43.068] result() for ClusterFuture ... done
[10:22:43.068] result() for ClusterFuture ...
[10:22:43.068] - result already collected: FutureResult
[10:22:43.068] result() for ClusterFuture ... done
[10:22:43.069] MultisessionFuture started
[10:22:43.070] - Launch lazy future ... done
[10:22:43.070] run() for ‘MultisessionFuture’ ... done
[10:22:43.070] getGlobalsAndPackages() ...
[10:22:43.070] Searching for globals...
[10:22:43.071] - globals found: [2] ‘list’, ‘stop’
[10:22:43.071] Searching for globals ... DONE
[10:22:43.071] Resolving globals: FALSE
[10:22:43.071] 
[10:22:43.071] 
[10:22:43.071] getGlobalsAndPackages() ... DONE
- result = TRUE, recursive = -1 ... DONE
- result = TRUE, recursive = 0 ...
[10:22:43.072] getGlobalsAndPackages() ...
[10:22:43.072] Searching for globals...
[10:22:43.073] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:22:43.073] Searching for globals ... DONE
[10:22:43.073] Resolving globals: FALSE
[10:22:43.073] 
[10:22:43.073] 
[10:22:43.073] getGlobalsAndPackages() ... DONE
[10:22:43.074] run() for ‘Future’ ...
[10:22:43.074] - state: ‘created’
[10:22:43.074] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:43.087] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:43.088] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:43.088]   - Field: ‘node’
[10:22:43.088]   - Field: ‘label’
[10:22:43.088]   - Field: ‘local’
[10:22:43.088]   - Field: ‘owner’
[10:22:43.088]   - Field: ‘envir’
[10:22:43.088]   - Field: ‘workers’
[10:22:43.088]   - Field: ‘packages’
[10:22:43.088]   - Field: ‘gc’
[10:22:43.088]   - Field: ‘conditions’
[10:22:43.088]   - Field: ‘persistent’
[10:22:43.089]   - Field: ‘expr’
[10:22:43.089]   - Field: ‘uuid’
[10:22:43.089]   - Field: ‘seed’
[10:22:43.089]   - Field: ‘version’
[10:22:43.089]   - Field: ‘result’
[10:22:43.089]   - Field: ‘asynchronous’
[10:22:43.089]   - Field: ‘calls’
[10:22:43.089]   - Field: ‘globals’
[10:22:43.089]   - Field: ‘stdout’
[10:22:43.089]   - Field: ‘earlySignal’
[10:22:43.089]   - Field: ‘lazy’
[10:22:43.089]   - Field: ‘state’
[10:22:43.090] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:43.090] - Launch lazy future ...
[10:22:43.090] Packages needed by the future expression (n = 0): <none>
[10:22:43.090] Packages needed by future strategies (n = 0): <none>
[10:22:43.090] {
[10:22:43.090]     {
[10:22:43.090]         {
[10:22:43.090]             ...future.startTime <- base::Sys.time()
[10:22:43.090]             {
[10:22:43.090]                 {
[10:22:43.090]                   {
[10:22:43.090]                     {
[10:22:43.090]                       base::local({
[10:22:43.090]                         has_future <- base::requireNamespace("future", 
[10:22:43.090]                           quietly = TRUE)
[10:22:43.090]                         if (has_future) {
[10:22:43.090]                           ns <- base::getNamespace("future")
[10:22:43.090]                           version <- ns[[".package"]][["version"]]
[10:22:43.090]                           if (is.null(version)) 
[10:22:43.090]                             version <- utils::packageVersion("future")
[10:22:43.090]                         }
[10:22:43.090]                         else {
[10:22:43.090]                           version <- NULL
[10:22:43.090]                         }
[10:22:43.090]                         if (!has_future || version < "1.8.0") {
[10:22:43.090]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:43.090]                             "", base::R.version$version.string), 
[10:22:43.090]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:43.090]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:43.090]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:43.090]                               "release", "version")], collapse = " "), 
[10:22:43.090]                             hostname = base::Sys.info()[["nodename"]])
[10:22:43.090]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:43.090]                             info)
[10:22:43.090]                           info <- base::paste(info, collapse = "; ")
[10:22:43.090]                           if (!has_future) {
[10:22:43.090]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:43.090]                               info)
[10:22:43.090]                           }
[10:22:43.090]                           else {
[10:22:43.090]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:43.090]                               info, version)
[10:22:43.090]                           }
[10:22:43.090]                           base::stop(msg)
[10:22:43.090]                         }
[10:22:43.090]                       })
[10:22:43.090]                     }
[10:22:43.090]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:43.090]                     base::options(mc.cores = 1L)
[10:22:43.090]                   }
[10:22:43.090]                   ...future.strategy.old <- future::plan("list")
[10:22:43.090]                   options(future.plan = NULL)
[10:22:43.090]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:43.090]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:43.090]                 }
[10:22:43.090]                 ...future.workdir <- getwd()
[10:22:43.090]             }
[10:22:43.090]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:43.090]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:43.090]         }
[10:22:43.090]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:43.090]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:43.090]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:43.090]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:43.090]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:43.090]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:43.090]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:43.090]             base::names(...future.oldOptions))
[10:22:43.090]     }
[10:22:43.090]     if (FALSE) {
[10:22:43.090]     }
[10:22:43.090]     else {
[10:22:43.090]         if (TRUE) {
[10:22:43.090]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:43.090]                 open = "w")
[10:22:43.090]         }
[10:22:43.090]         else {
[10:22:43.090]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:43.090]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:43.090]         }
[10:22:43.090]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:43.090]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:43.090]             base::sink(type = "output", split = FALSE)
[10:22:43.090]             base::close(...future.stdout)
[10:22:43.090]         }, add = TRUE)
[10:22:43.090]     }
[10:22:43.090]     ...future.frame <- base::sys.nframe()
[10:22:43.090]     ...future.conditions <- base::list()
[10:22:43.090]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:43.090]     if (FALSE) {
[10:22:43.090]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:43.090]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:43.090]     }
[10:22:43.090]     ...future.result <- base::tryCatch({
[10:22:43.090]         base::withCallingHandlers({
[10:22:43.090]             ...future.value <- base::withVisible(base::local({
[10:22:43.090]                 ...future.makeSendCondition <- base::local({
[10:22:43.090]                   sendCondition <- NULL
[10:22:43.090]                   function(frame = 1L) {
[10:22:43.090]                     if (is.function(sendCondition)) 
[10:22:43.090]                       return(sendCondition)
[10:22:43.090]                     ns <- getNamespace("parallel")
[10:22:43.090]                     if (exists("sendData", mode = "function", 
[10:22:43.090]                       envir = ns)) {
[10:22:43.090]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:43.090]                         envir = ns)
[10:22:43.090]                       envir <- sys.frame(frame)
[10:22:43.090]                       master <- NULL
[10:22:43.090]                       while (!identical(envir, .GlobalEnv) && 
[10:22:43.090]                         !identical(envir, emptyenv())) {
[10:22:43.090]                         if (exists("master", mode = "list", envir = envir, 
[10:22:43.090]                           inherits = FALSE)) {
[10:22:43.090]                           master <- get("master", mode = "list", 
[10:22:43.090]                             envir = envir, inherits = FALSE)
[10:22:43.090]                           if (inherits(master, c("SOCKnode", 
[10:22:43.090]                             "SOCK0node"))) {
[10:22:43.090]                             sendCondition <<- function(cond) {
[10:22:43.090]                               data <- list(type = "VALUE", value = cond, 
[10:22:43.090]                                 success = TRUE)
[10:22:43.090]                               parallel_sendData(master, data)
[10:22:43.090]                             }
[10:22:43.090]                             return(sendCondition)
[10:22:43.090]                           }
[10:22:43.090]                         }
[10:22:43.090]                         frame <- frame + 1L
[10:22:43.090]                         envir <- sys.frame(frame)
[10:22:43.090]                       }
[10:22:43.090]                     }
[10:22:43.090]                     sendCondition <<- function(cond) NULL
[10:22:43.090]                   }
[10:22:43.090]                 })
[10:22:43.090]                 withCallingHandlers({
[10:22:43.090]                   {
[10:22:43.090]                     Sys.sleep(0.5)
[10:22:43.090]                     list(a = 1, b = 42L)
[10:22:43.090]                   }
[10:22:43.090]                 }, immediateCondition = function(cond) {
[10:22:43.090]                   sendCondition <- ...future.makeSendCondition()
[10:22:43.090]                   sendCondition(cond)
[10:22:43.090]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:43.090]                   {
[10:22:43.090]                     inherits <- base::inherits
[10:22:43.090]                     invokeRestart <- base::invokeRestart
[10:22:43.090]                     is.null <- base::is.null
[10:22:43.090]                     muffled <- FALSE
[10:22:43.090]                     if (inherits(cond, "message")) {
[10:22:43.090]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:43.090]                       if (muffled) 
[10:22:43.090]                         invokeRestart("muffleMessage")
[10:22:43.090]                     }
[10:22:43.090]                     else if (inherits(cond, "warning")) {
[10:22:43.090]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:43.090]                       if (muffled) 
[10:22:43.090]                         invokeRestart("muffleWarning")
[10:22:43.090]                     }
[10:22:43.090]                     else if (inherits(cond, "condition")) {
[10:22:43.090]                       if (!is.null(pattern)) {
[10:22:43.090]                         computeRestarts <- base::computeRestarts
[10:22:43.090]                         grepl <- base::grepl
[10:22:43.090]                         restarts <- computeRestarts(cond)
[10:22:43.090]                         for (restart in restarts) {
[10:22:43.090]                           name <- restart$name
[10:22:43.090]                           if (is.null(name)) 
[10:22:43.090]                             next
[10:22:43.090]                           if (!grepl(pattern, name)) 
[10:22:43.090]                             next
[10:22:43.090]                           invokeRestart(restart)
[10:22:43.090]                           muffled <- TRUE
[10:22:43.090]                           break
[10:22:43.090]                         }
[10:22:43.090]                       }
[10:22:43.090]                     }
[10:22:43.090]                     invisible(muffled)
[10:22:43.090]                   }
[10:22:43.090]                   muffleCondition(cond)
[10:22:43.090]                 })
[10:22:43.090]             }))
[10:22:43.090]             future::FutureResult(value = ...future.value$value, 
[10:22:43.090]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:43.090]                   ...future.rng), globalenv = if (FALSE) 
[10:22:43.090]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:43.090]                     ...future.globalenv.names))
[10:22:43.090]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:43.090]         }, condition = base::local({
[10:22:43.090]             c <- base::c
[10:22:43.090]             inherits <- base::inherits
[10:22:43.090]             invokeRestart <- base::invokeRestart
[10:22:43.090]             length <- base::length
[10:22:43.090]             list <- base::list
[10:22:43.090]             seq.int <- base::seq.int
[10:22:43.090]             signalCondition <- base::signalCondition
[10:22:43.090]             sys.calls <- base::sys.calls
[10:22:43.090]             `[[` <- base::`[[`
[10:22:43.090]             `+` <- base::`+`
[10:22:43.090]             `<<-` <- base::`<<-`
[10:22:43.090]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:43.090]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:43.090]                   3L)]
[10:22:43.090]             }
[10:22:43.090]             function(cond) {
[10:22:43.090]                 is_error <- inherits(cond, "error")
[10:22:43.090]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:43.090]                   NULL)
[10:22:43.090]                 if (is_error) {
[10:22:43.090]                   sessionInformation <- function() {
[10:22:43.090]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:43.090]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:43.090]                       search = base::search(), system = base::Sys.info())
[10:22:43.090]                   }
[10:22:43.090]                   ...future.conditions[[length(...future.conditions) + 
[10:22:43.090]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:43.090]                     cond$call), session = sessionInformation(), 
[10:22:43.090]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:43.090]                   signalCondition(cond)
[10:22:43.090]                 }
[10:22:43.090]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:43.090]                 "immediateCondition"))) {
[10:22:43.090]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:43.090]                   ...future.conditions[[length(...future.conditions) + 
[10:22:43.090]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:43.090]                   if (TRUE && !signal) {
[10:22:43.090]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:43.090]                     {
[10:22:43.090]                       inherits <- base::inherits
[10:22:43.090]                       invokeRestart <- base::invokeRestart
[10:22:43.090]                       is.null <- base::is.null
[10:22:43.090]                       muffled <- FALSE
[10:22:43.090]                       if (inherits(cond, "message")) {
[10:22:43.090]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:43.090]                         if (muffled) 
[10:22:43.090]                           invokeRestart("muffleMessage")
[10:22:43.090]                       }
[10:22:43.090]                       else if (inherits(cond, "warning")) {
[10:22:43.090]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:43.090]                         if (muffled) 
[10:22:43.090]                           invokeRestart("muffleWarning")
[10:22:43.090]                       }
[10:22:43.090]                       else if (inherits(cond, "condition")) {
[10:22:43.090]                         if (!is.null(pattern)) {
[10:22:43.090]                           computeRestarts <- base::computeRestarts
[10:22:43.090]                           grepl <- base::grepl
[10:22:43.090]                           restarts <- computeRestarts(cond)
[10:22:43.090]                           for (restart in restarts) {
[10:22:43.090]                             name <- restart$name
[10:22:43.090]                             if (is.null(name)) 
[10:22:43.090]                               next
[10:22:43.090]                             if (!grepl(pattern, name)) 
[10:22:43.090]                               next
[10:22:43.090]                             invokeRestart(restart)
[10:22:43.090]                             muffled <- TRUE
[10:22:43.090]                             break
[10:22:43.090]                           }
[10:22:43.090]                         }
[10:22:43.090]                       }
[10:22:43.090]                       invisible(muffled)
[10:22:43.090]                     }
[10:22:43.090]                     muffleCondition(cond, pattern = "^muffle")
[10:22:43.090]                   }
[10:22:43.090]                 }
[10:22:43.090]                 else {
[10:22:43.090]                   if (TRUE) {
[10:22:43.090]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:43.090]                     {
[10:22:43.090]                       inherits <- base::inherits
[10:22:43.090]                       invokeRestart <- base::invokeRestart
[10:22:43.090]                       is.null <- base::is.null
[10:22:43.090]                       muffled <- FALSE
[10:22:43.090]                       if (inherits(cond, "message")) {
[10:22:43.090]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:43.090]                         if (muffled) 
[10:22:43.090]                           invokeRestart("muffleMessage")
[10:22:43.090]                       }
[10:22:43.090]                       else if (inherits(cond, "warning")) {
[10:22:43.090]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:43.090]                         if (muffled) 
[10:22:43.090]                           invokeRestart("muffleWarning")
[10:22:43.090]                       }
[10:22:43.090]                       else if (inherits(cond, "condition")) {
[10:22:43.090]                         if (!is.null(pattern)) {
[10:22:43.090]                           computeRestarts <- base::computeRestarts
[10:22:43.090]                           grepl <- base::grepl
[10:22:43.090]                           restarts <- computeRestarts(cond)
[10:22:43.090]                           for (restart in restarts) {
[10:22:43.090]                             name <- restart$name
[10:22:43.090]                             if (is.null(name)) 
[10:22:43.090]                               next
[10:22:43.090]                             if (!grepl(pattern, name)) 
[10:22:43.090]                               next
[10:22:43.090]                             invokeRestart(restart)
[10:22:43.090]                             muffled <- TRUE
[10:22:43.090]                             break
[10:22:43.090]                           }
[10:22:43.090]                         }
[10:22:43.090]                       }
[10:22:43.090]                       invisible(muffled)
[10:22:43.090]                     }
[10:22:43.090]                     muffleCondition(cond, pattern = "^muffle")
[10:22:43.090]                   }
[10:22:43.090]                 }
[10:22:43.090]             }
[10:22:43.090]         }))
[10:22:43.090]     }, error = function(ex) {
[10:22:43.090]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:43.090]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:43.090]                 ...future.rng), started = ...future.startTime, 
[10:22:43.090]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:43.090]             version = "1.8"), class = "FutureResult")
[10:22:43.090]     }, finally = {
[10:22:43.090]         if (!identical(...future.workdir, getwd())) 
[10:22:43.090]             setwd(...future.workdir)
[10:22:43.090]         {
[10:22:43.090]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:43.090]                 ...future.oldOptions$nwarnings <- NULL
[10:22:43.090]             }
[10:22:43.090]             base::options(...future.oldOptions)
[10:22:43.090]             if (.Platform$OS.type == "windows") {
[10:22:43.090]                 old_names <- names(...future.oldEnvVars)
[10:22:43.090]                 envs <- base::Sys.getenv()
[10:22:43.090]                 names <- names(envs)
[10:22:43.090]                 common <- intersect(names, old_names)
[10:22:43.090]                 added <- setdiff(names, old_names)
[10:22:43.090]                 removed <- setdiff(old_names, names)
[10:22:43.090]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:43.090]                   envs[common]]
[10:22:43.090]                 NAMES <- toupper(changed)
[10:22:43.090]                 args <- list()
[10:22:43.090]                 for (kk in seq_along(NAMES)) {
[10:22:43.090]                   name <- changed[[kk]]
[10:22:43.090]                   NAME <- NAMES[[kk]]
[10:22:43.090]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:43.090]                     next
[10:22:43.090]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:43.090]                 }
[10:22:43.090]                 NAMES <- toupper(added)
[10:22:43.090]                 for (kk in seq_along(NAMES)) {
[10:22:43.090]                   name <- added[[kk]]
[10:22:43.090]                   NAME <- NAMES[[kk]]
[10:22:43.090]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:43.090]                     next
[10:22:43.090]                   args[[name]] <- ""
[10:22:43.090]                 }
[10:22:43.090]                 NAMES <- toupper(removed)
[10:22:43.090]                 for (kk in seq_along(NAMES)) {
[10:22:43.090]                   name <- removed[[kk]]
[10:22:43.090]                   NAME <- NAMES[[kk]]
[10:22:43.090]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:43.090]                     next
[10:22:43.090]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:43.090]                 }
[10:22:43.090]                 if (length(args) > 0) 
[10:22:43.090]                   base::do.call(base::Sys.setenv, args = args)
[10:22:43.090]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:43.090]             }
[10:22:43.090]             else {
[10:22:43.090]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:43.090]             }
[10:22:43.090]             {
[10:22:43.090]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:43.090]                   0L) {
[10:22:43.090]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:43.090]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:43.090]                   base::options(opts)
[10:22:43.090]                 }
[10:22:43.090]                 {
[10:22:43.090]                   {
[10:22:43.090]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:43.090]                     NULL
[10:22:43.090]                   }
[10:22:43.090]                   options(future.plan = NULL)
[10:22:43.090]                   if (is.na(NA_character_)) 
[10:22:43.090]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:43.090]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:43.090]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:43.090]                     .init = FALSE)
[10:22:43.090]                 }
[10:22:43.090]             }
[10:22:43.090]         }
[10:22:43.090]     })
[10:22:43.090]     if (TRUE) {
[10:22:43.090]         base::sink(type = "output", split = FALSE)
[10:22:43.090]         if (TRUE) {
[10:22:43.090]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:43.090]         }
[10:22:43.090]         else {
[10:22:43.090]             ...future.result["stdout"] <- base::list(NULL)
[10:22:43.090]         }
[10:22:43.090]         base::close(...future.stdout)
[10:22:43.090]         ...future.stdout <- NULL
[10:22:43.090]     }
[10:22:43.090]     ...future.result$conditions <- ...future.conditions
[10:22:43.090]     ...future.result$finished <- base::Sys.time()
[10:22:43.090]     ...future.result
[10:22:43.090] }
[10:22:43.093] Poll #1 (0): usedNodes() = 2, workers = 2
[10:22:43.114] receiveMessageFromWorker() for ClusterFuture ...
[10:22:43.114] - Validating connection of MultisessionFuture
[10:22:43.114] - received message: FutureResult
[10:22:43.115] - Received FutureResult
[10:22:43.115] - Erased future from FutureRegistry
[10:22:43.115] result() for ClusterFuture ...
[10:22:43.115] - result already collected: FutureResult
[10:22:43.115] result() for ClusterFuture ... done
[10:22:43.115] signalConditions() ...
[10:22:43.115]  - include = ‘immediateCondition’
[10:22:43.115]  - exclude = 
[10:22:43.115]  - resignal = FALSE
[10:22:43.115]  - Number of conditions: 1
[10:22:43.115] signalConditions() ... done
[10:22:43.116] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:43.116] result() for ClusterFuture ...
[10:22:43.116] - result already collected: FutureResult
[10:22:43.116] result() for ClusterFuture ... done
[10:22:43.116] result() for ClusterFuture ...
[10:22:43.116] - result already collected: FutureResult
[10:22:43.116] result() for ClusterFuture ... done
[10:22:43.116] signalConditions() ...
[10:22:43.116]  - include = ‘immediateCondition’
[10:22:43.116]  - exclude = 
[10:22:43.116]  - resignal = FALSE
[10:22:43.116]  - Number of conditions: 1
[10:22:43.117] signalConditions() ... done
[10:22:43.118] MultisessionFuture started
[10:22:43.118] - Launch lazy future ... done
[10:22:43.118] run() for ‘MultisessionFuture’ ... done
[10:22:43.661] receiveMessageFromWorker() for ClusterFuture ...
[10:22:43.661] - Validating connection of MultisessionFuture
[10:22:43.662] - received message: FutureResult
[10:22:43.662] - Received FutureResult
[10:22:43.662] - Erased future from FutureRegistry
[10:22:43.662] result() for ClusterFuture ...
[10:22:43.662] - result already collected: FutureResult
[10:22:43.662] result() for ClusterFuture ... done
[10:22:43.662] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:43.662] A MultisessionFuture was resolved
[10:22:43.662] getGlobalsAndPackages() ...
[10:22:43.663] Searching for globals...
[10:22:43.664] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:22:43.664] Searching for globals ... DONE
[10:22:43.664] Resolving globals: FALSE
[10:22:43.664] 
[10:22:43.664] 
[10:22:43.664] getGlobalsAndPackages() ... DONE
[10:22:43.665] run() for ‘Future’ ...
[10:22:43.665] - state: ‘created’
[10:22:43.665] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:43.679] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:43.679] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:43.679]   - Field: ‘node’
[10:22:43.679]   - Field: ‘label’
[10:22:43.679]   - Field: ‘local’
[10:22:43.679]   - Field: ‘owner’
[10:22:43.679]   - Field: ‘envir’
[10:22:43.679]   - Field: ‘workers’
[10:22:43.680]   - Field: ‘packages’
[10:22:43.680]   - Field: ‘gc’
[10:22:43.680]   - Field: ‘conditions’
[10:22:43.680]   - Field: ‘persistent’
[10:22:43.680]   - Field: ‘expr’
[10:22:43.680]   - Field: ‘uuid’
[10:22:43.680]   - Field: ‘seed’
[10:22:43.680]   - Field: ‘version’
[10:22:43.680]   - Field: ‘result’
[10:22:43.680]   - Field: ‘asynchronous’
[10:22:43.680]   - Field: ‘calls’
[10:22:43.680]   - Field: ‘globals’
[10:22:43.681]   - Field: ‘stdout’
[10:22:43.681]   - Field: ‘earlySignal’
[10:22:43.681]   - Field: ‘lazy’
[10:22:43.681]   - Field: ‘state’
[10:22:43.681] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:43.681] - Launch lazy future ...
[10:22:43.681] Packages needed by the future expression (n = 0): <none>
[10:22:43.681] Packages needed by future strategies (n = 0): <none>
[10:22:43.682] {
[10:22:43.682]     {
[10:22:43.682]         {
[10:22:43.682]             ...future.startTime <- base::Sys.time()
[10:22:43.682]             {
[10:22:43.682]                 {
[10:22:43.682]                   {
[10:22:43.682]                     {
[10:22:43.682]                       base::local({
[10:22:43.682]                         has_future <- base::requireNamespace("future", 
[10:22:43.682]                           quietly = TRUE)
[10:22:43.682]                         if (has_future) {
[10:22:43.682]                           ns <- base::getNamespace("future")
[10:22:43.682]                           version <- ns[[".package"]][["version"]]
[10:22:43.682]                           if (is.null(version)) 
[10:22:43.682]                             version <- utils::packageVersion("future")
[10:22:43.682]                         }
[10:22:43.682]                         else {
[10:22:43.682]                           version <- NULL
[10:22:43.682]                         }
[10:22:43.682]                         if (!has_future || version < "1.8.0") {
[10:22:43.682]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:43.682]                             "", base::R.version$version.string), 
[10:22:43.682]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:43.682]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:43.682]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:43.682]                               "release", "version")], collapse = " "), 
[10:22:43.682]                             hostname = base::Sys.info()[["nodename"]])
[10:22:43.682]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:43.682]                             info)
[10:22:43.682]                           info <- base::paste(info, collapse = "; ")
[10:22:43.682]                           if (!has_future) {
[10:22:43.682]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:43.682]                               info)
[10:22:43.682]                           }
[10:22:43.682]                           else {
[10:22:43.682]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:43.682]                               info, version)
[10:22:43.682]                           }
[10:22:43.682]                           base::stop(msg)
[10:22:43.682]                         }
[10:22:43.682]                       })
[10:22:43.682]                     }
[10:22:43.682]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:43.682]                     base::options(mc.cores = 1L)
[10:22:43.682]                   }
[10:22:43.682]                   ...future.strategy.old <- future::plan("list")
[10:22:43.682]                   options(future.plan = NULL)
[10:22:43.682]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:43.682]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:43.682]                 }
[10:22:43.682]                 ...future.workdir <- getwd()
[10:22:43.682]             }
[10:22:43.682]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:43.682]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:43.682]         }
[10:22:43.682]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:43.682]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:43.682]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:43.682]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:43.682]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:43.682]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:43.682]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:43.682]             base::names(...future.oldOptions))
[10:22:43.682]     }
[10:22:43.682]     if (FALSE) {
[10:22:43.682]     }
[10:22:43.682]     else {
[10:22:43.682]         if (TRUE) {
[10:22:43.682]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:43.682]                 open = "w")
[10:22:43.682]         }
[10:22:43.682]         else {
[10:22:43.682]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:43.682]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:43.682]         }
[10:22:43.682]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:43.682]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:43.682]             base::sink(type = "output", split = FALSE)
[10:22:43.682]             base::close(...future.stdout)
[10:22:43.682]         }, add = TRUE)
[10:22:43.682]     }
[10:22:43.682]     ...future.frame <- base::sys.nframe()
[10:22:43.682]     ...future.conditions <- base::list()
[10:22:43.682]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:43.682]     if (FALSE) {
[10:22:43.682]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:43.682]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:43.682]     }
[10:22:43.682]     ...future.result <- base::tryCatch({
[10:22:43.682]         base::withCallingHandlers({
[10:22:43.682]             ...future.value <- base::withVisible(base::local({
[10:22:43.682]                 ...future.makeSendCondition <- base::local({
[10:22:43.682]                   sendCondition <- NULL
[10:22:43.682]                   function(frame = 1L) {
[10:22:43.682]                     if (is.function(sendCondition)) 
[10:22:43.682]                       return(sendCondition)
[10:22:43.682]                     ns <- getNamespace("parallel")
[10:22:43.682]                     if (exists("sendData", mode = "function", 
[10:22:43.682]                       envir = ns)) {
[10:22:43.682]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:43.682]                         envir = ns)
[10:22:43.682]                       envir <- sys.frame(frame)
[10:22:43.682]                       master <- NULL
[10:22:43.682]                       while (!identical(envir, .GlobalEnv) && 
[10:22:43.682]                         !identical(envir, emptyenv())) {
[10:22:43.682]                         if (exists("master", mode = "list", envir = envir, 
[10:22:43.682]                           inherits = FALSE)) {
[10:22:43.682]                           master <- get("master", mode = "list", 
[10:22:43.682]                             envir = envir, inherits = FALSE)
[10:22:43.682]                           if (inherits(master, c("SOCKnode", 
[10:22:43.682]                             "SOCK0node"))) {
[10:22:43.682]                             sendCondition <<- function(cond) {
[10:22:43.682]                               data <- list(type = "VALUE", value = cond, 
[10:22:43.682]                                 success = TRUE)
[10:22:43.682]                               parallel_sendData(master, data)
[10:22:43.682]                             }
[10:22:43.682]                             return(sendCondition)
[10:22:43.682]                           }
[10:22:43.682]                         }
[10:22:43.682]                         frame <- frame + 1L
[10:22:43.682]                         envir <- sys.frame(frame)
[10:22:43.682]                       }
[10:22:43.682]                     }
[10:22:43.682]                     sendCondition <<- function(cond) NULL
[10:22:43.682]                   }
[10:22:43.682]                 })
[10:22:43.682]                 withCallingHandlers({
[10:22:43.682]                   {
[10:22:43.682]                     Sys.sleep(0.5)
[10:22:43.682]                     list(a = 1, b = 42L)
[10:22:43.682]                   }
[10:22:43.682]                 }, immediateCondition = function(cond) {
[10:22:43.682]                   sendCondition <- ...future.makeSendCondition()
[10:22:43.682]                   sendCondition(cond)
[10:22:43.682]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:43.682]                   {
[10:22:43.682]                     inherits <- base::inherits
[10:22:43.682]                     invokeRestart <- base::invokeRestart
[10:22:43.682]                     is.null <- base::is.null
[10:22:43.682]                     muffled <- FALSE
[10:22:43.682]                     if (inherits(cond, "message")) {
[10:22:43.682]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:43.682]                       if (muffled) 
[10:22:43.682]                         invokeRestart("muffleMessage")
[10:22:43.682]                     }
[10:22:43.682]                     else if (inherits(cond, "warning")) {
[10:22:43.682]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:43.682]                       if (muffled) 
[10:22:43.682]                         invokeRestart("muffleWarning")
[10:22:43.682]                     }
[10:22:43.682]                     else if (inherits(cond, "condition")) {
[10:22:43.682]                       if (!is.null(pattern)) {
[10:22:43.682]                         computeRestarts <- base::computeRestarts
[10:22:43.682]                         grepl <- base::grepl
[10:22:43.682]                         restarts <- computeRestarts(cond)
[10:22:43.682]                         for (restart in restarts) {
[10:22:43.682]                           name <- restart$name
[10:22:43.682]                           if (is.null(name)) 
[10:22:43.682]                             next
[10:22:43.682]                           if (!grepl(pattern, name)) 
[10:22:43.682]                             next
[10:22:43.682]                           invokeRestart(restart)
[10:22:43.682]                           muffled <- TRUE
[10:22:43.682]                           break
[10:22:43.682]                         }
[10:22:43.682]                       }
[10:22:43.682]                     }
[10:22:43.682]                     invisible(muffled)
[10:22:43.682]                   }
[10:22:43.682]                   muffleCondition(cond)
[10:22:43.682]                 })
[10:22:43.682]             }))
[10:22:43.682]             future::FutureResult(value = ...future.value$value, 
[10:22:43.682]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:43.682]                   ...future.rng), globalenv = if (FALSE) 
[10:22:43.682]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:43.682]                     ...future.globalenv.names))
[10:22:43.682]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:43.682]         }, condition = base::local({
[10:22:43.682]             c <- base::c
[10:22:43.682]             inherits <- base::inherits
[10:22:43.682]             invokeRestart <- base::invokeRestart
[10:22:43.682]             length <- base::length
[10:22:43.682]             list <- base::list
[10:22:43.682]             seq.int <- base::seq.int
[10:22:43.682]             signalCondition <- base::signalCondition
[10:22:43.682]             sys.calls <- base::sys.calls
[10:22:43.682]             `[[` <- base::`[[`
[10:22:43.682]             `+` <- base::`+`
[10:22:43.682]             `<<-` <- base::`<<-`
[10:22:43.682]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:43.682]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:43.682]                   3L)]
[10:22:43.682]             }
[10:22:43.682]             function(cond) {
[10:22:43.682]                 is_error <- inherits(cond, "error")
[10:22:43.682]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:43.682]                   NULL)
[10:22:43.682]                 if (is_error) {
[10:22:43.682]                   sessionInformation <- function() {
[10:22:43.682]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:43.682]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:43.682]                       search = base::search(), system = base::Sys.info())
[10:22:43.682]                   }
[10:22:43.682]                   ...future.conditions[[length(...future.conditions) + 
[10:22:43.682]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:43.682]                     cond$call), session = sessionInformation(), 
[10:22:43.682]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:43.682]                   signalCondition(cond)
[10:22:43.682]                 }
[10:22:43.682]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:43.682]                 "immediateCondition"))) {
[10:22:43.682]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:43.682]                   ...future.conditions[[length(...future.conditions) + 
[10:22:43.682]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:43.682]                   if (TRUE && !signal) {
[10:22:43.682]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:43.682]                     {
[10:22:43.682]                       inherits <- base::inherits
[10:22:43.682]                       invokeRestart <- base::invokeRestart
[10:22:43.682]                       is.null <- base::is.null
[10:22:43.682]                       muffled <- FALSE
[10:22:43.682]                       if (inherits(cond, "message")) {
[10:22:43.682]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:43.682]                         if (muffled) 
[10:22:43.682]                           invokeRestart("muffleMessage")
[10:22:43.682]                       }
[10:22:43.682]                       else if (inherits(cond, "warning")) {
[10:22:43.682]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:43.682]                         if (muffled) 
[10:22:43.682]                           invokeRestart("muffleWarning")
[10:22:43.682]                       }
[10:22:43.682]                       else if (inherits(cond, "condition")) {
[10:22:43.682]                         if (!is.null(pattern)) {
[10:22:43.682]                           computeRestarts <- base::computeRestarts
[10:22:43.682]                           grepl <- base::grepl
[10:22:43.682]                           restarts <- computeRestarts(cond)
[10:22:43.682]                           for (restart in restarts) {
[10:22:43.682]                             name <- restart$name
[10:22:43.682]                             if (is.null(name)) 
[10:22:43.682]                               next
[10:22:43.682]                             if (!grepl(pattern, name)) 
[10:22:43.682]                               next
[10:22:43.682]                             invokeRestart(restart)
[10:22:43.682]                             muffled <- TRUE
[10:22:43.682]                             break
[10:22:43.682]                           }
[10:22:43.682]                         }
[10:22:43.682]                       }
[10:22:43.682]                       invisible(muffled)
[10:22:43.682]                     }
[10:22:43.682]                     muffleCondition(cond, pattern = "^muffle")
[10:22:43.682]                   }
[10:22:43.682]                 }
[10:22:43.682]                 else {
[10:22:43.682]                   if (TRUE) {
[10:22:43.682]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:43.682]                     {
[10:22:43.682]                       inherits <- base::inherits
[10:22:43.682]                       invokeRestart <- base::invokeRestart
[10:22:43.682]                       is.null <- base::is.null
[10:22:43.682]                       muffled <- FALSE
[10:22:43.682]                       if (inherits(cond, "message")) {
[10:22:43.682]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:43.682]                         if (muffled) 
[10:22:43.682]                           invokeRestart("muffleMessage")
[10:22:43.682]                       }
[10:22:43.682]                       else if (inherits(cond, "warning")) {
[10:22:43.682]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:43.682]                         if (muffled) 
[10:22:43.682]                           invokeRestart("muffleWarning")
[10:22:43.682]                       }
[10:22:43.682]                       else if (inherits(cond, "condition")) {
[10:22:43.682]                         if (!is.null(pattern)) {
[10:22:43.682]                           computeRestarts <- base::computeRestarts
[10:22:43.682]                           grepl <- base::grepl
[10:22:43.682]                           restarts <- computeRestarts(cond)
[10:22:43.682]                           for (restart in restarts) {
[10:22:43.682]                             name <- restart$name
[10:22:43.682]                             if (is.null(name)) 
[10:22:43.682]                               next
[10:22:43.682]                             if (!grepl(pattern, name)) 
[10:22:43.682]                               next
[10:22:43.682]                             invokeRestart(restart)
[10:22:43.682]                             muffled <- TRUE
[10:22:43.682]                             break
[10:22:43.682]                           }
[10:22:43.682]                         }
[10:22:43.682]                       }
[10:22:43.682]                       invisible(muffled)
[10:22:43.682]                     }
[10:22:43.682]                     muffleCondition(cond, pattern = "^muffle")
[10:22:43.682]                   }
[10:22:43.682]                 }
[10:22:43.682]             }
[10:22:43.682]         }))
[10:22:43.682]     }, error = function(ex) {
[10:22:43.682]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:43.682]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:43.682]                 ...future.rng), started = ...future.startTime, 
[10:22:43.682]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:43.682]             version = "1.8"), class = "FutureResult")
[10:22:43.682]     }, finally = {
[10:22:43.682]         if (!identical(...future.workdir, getwd())) 
[10:22:43.682]             setwd(...future.workdir)
[10:22:43.682]         {
[10:22:43.682]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:43.682]                 ...future.oldOptions$nwarnings <- NULL
[10:22:43.682]             }
[10:22:43.682]             base::options(...future.oldOptions)
[10:22:43.682]             if (.Platform$OS.type == "windows") {
[10:22:43.682]                 old_names <- names(...future.oldEnvVars)
[10:22:43.682]                 envs <- base::Sys.getenv()
[10:22:43.682]                 names <- names(envs)
[10:22:43.682]                 common <- intersect(names, old_names)
[10:22:43.682]                 added <- setdiff(names, old_names)
[10:22:43.682]                 removed <- setdiff(old_names, names)
[10:22:43.682]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:43.682]                   envs[common]]
[10:22:43.682]                 NAMES <- toupper(changed)
[10:22:43.682]                 args <- list()
[10:22:43.682]                 for (kk in seq_along(NAMES)) {
[10:22:43.682]                   name <- changed[[kk]]
[10:22:43.682]                   NAME <- NAMES[[kk]]
[10:22:43.682]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:43.682]                     next
[10:22:43.682]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:43.682]                 }
[10:22:43.682]                 NAMES <- toupper(added)
[10:22:43.682]                 for (kk in seq_along(NAMES)) {
[10:22:43.682]                   name <- added[[kk]]
[10:22:43.682]                   NAME <- NAMES[[kk]]
[10:22:43.682]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:43.682]                     next
[10:22:43.682]                   args[[name]] <- ""
[10:22:43.682]                 }
[10:22:43.682]                 NAMES <- toupper(removed)
[10:22:43.682]                 for (kk in seq_along(NAMES)) {
[10:22:43.682]                   name <- removed[[kk]]
[10:22:43.682]                   NAME <- NAMES[[kk]]
[10:22:43.682]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:43.682]                     next
[10:22:43.682]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:43.682]                 }
[10:22:43.682]                 if (length(args) > 0) 
[10:22:43.682]                   base::do.call(base::Sys.setenv, args = args)
[10:22:43.682]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:43.682]             }
[10:22:43.682]             else {
[10:22:43.682]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:43.682]             }
[10:22:43.682]             {
[10:22:43.682]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:43.682]                   0L) {
[10:22:43.682]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:43.682]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:43.682]                   base::options(opts)
[10:22:43.682]                 }
[10:22:43.682]                 {
[10:22:43.682]                   {
[10:22:43.682]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:43.682]                     NULL
[10:22:43.682]                   }
[10:22:43.682]                   options(future.plan = NULL)
[10:22:43.682]                   if (is.na(NA_character_)) 
[10:22:43.682]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:43.682]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:43.682]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:43.682]                     .init = FALSE)
[10:22:43.682]                 }
[10:22:43.682]             }
[10:22:43.682]         }
[10:22:43.682]     })
[10:22:43.682]     if (TRUE) {
[10:22:43.682]         base::sink(type = "output", split = FALSE)
[10:22:43.682]         if (TRUE) {
[10:22:43.682]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:43.682]         }
[10:22:43.682]         else {
[10:22:43.682]             ...future.result["stdout"] <- base::list(NULL)
[10:22:43.682]         }
[10:22:43.682]         base::close(...future.stdout)
[10:22:43.682]         ...future.stdout <- NULL
[10:22:43.682]     }
[10:22:43.682]     ...future.result$conditions <- ...future.conditions
[10:22:43.682]     ...future.result$finished <- base::Sys.time()
[10:22:43.682]     ...future.result
[10:22:43.682] }
[10:22:43.685] MultisessionFuture started
[10:22:43.685] - Launch lazy future ... done
[10:22:43.685] run() for ‘MultisessionFuture’ ... done
[10:22:44.228] receiveMessageFromWorker() for ClusterFuture ...
[10:22:44.228] - Validating connection of MultisessionFuture
[10:22:44.228] - received message: FutureResult
[10:22:44.229] - Received FutureResult
[10:22:44.229] - Erased future from FutureRegistry
[10:22:44.229] result() for ClusterFuture ...
[10:22:44.229] - result already collected: FutureResult
[10:22:44.229] result() for ClusterFuture ... done
[10:22:44.229] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:44.229] A MultisessionFuture was resolved
- w/ exception ...
[10:22:44.229] getGlobalsAndPackages() ...
[10:22:44.229] Searching for globals...
[10:22:44.230] - globals found: [2] ‘list’, ‘stop’
[10:22:44.230] Searching for globals ... DONE
[10:22:44.230] Resolving globals: FALSE
[10:22:44.231] 
[10:22:44.231] 
[10:22:44.231] getGlobalsAndPackages() ... DONE
[10:22:44.231] run() for ‘Future’ ...
[10:22:44.231] - state: ‘created’
[10:22:44.231] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:44.245] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:44.245] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:44.245]   - Field: ‘node’
[10:22:44.245]   - Field: ‘label’
[10:22:44.246]   - Field: ‘local’
[10:22:44.246]   - Field: ‘owner’
[10:22:44.246]   - Field: ‘envir’
[10:22:44.246]   - Field: ‘workers’
[10:22:44.246]   - Field: ‘packages’
[10:22:44.246]   - Field: ‘gc’
[10:22:44.246]   - Field: ‘conditions’
[10:22:44.246]   - Field: ‘persistent’
[10:22:44.246]   - Field: ‘expr’
[10:22:44.246]   - Field: ‘uuid’
[10:22:44.246]   - Field: ‘seed’
[10:22:44.246]   - Field: ‘version’
[10:22:44.247]   - Field: ‘result’
[10:22:44.247]   - Field: ‘asynchronous’
[10:22:44.247]   - Field: ‘calls’
[10:22:44.247]   - Field: ‘globals’
[10:22:44.247]   - Field: ‘stdout’
[10:22:44.247]   - Field: ‘earlySignal’
[10:22:44.247]   - Field: ‘lazy’
[10:22:44.247]   - Field: ‘state’
[10:22:44.247] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:44.247] - Launch lazy future ...
[10:22:44.248] Packages needed by the future expression (n = 0): <none>
[10:22:44.248] Packages needed by future strategies (n = 0): <none>
[10:22:44.248] {
[10:22:44.248]     {
[10:22:44.248]         {
[10:22:44.248]             ...future.startTime <- base::Sys.time()
[10:22:44.248]             {
[10:22:44.248]                 {
[10:22:44.248]                   {
[10:22:44.248]                     {
[10:22:44.248]                       base::local({
[10:22:44.248]                         has_future <- base::requireNamespace("future", 
[10:22:44.248]                           quietly = TRUE)
[10:22:44.248]                         if (has_future) {
[10:22:44.248]                           ns <- base::getNamespace("future")
[10:22:44.248]                           version <- ns[[".package"]][["version"]]
[10:22:44.248]                           if (is.null(version)) 
[10:22:44.248]                             version <- utils::packageVersion("future")
[10:22:44.248]                         }
[10:22:44.248]                         else {
[10:22:44.248]                           version <- NULL
[10:22:44.248]                         }
[10:22:44.248]                         if (!has_future || version < "1.8.0") {
[10:22:44.248]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:44.248]                             "", base::R.version$version.string), 
[10:22:44.248]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:44.248]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:44.248]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:44.248]                               "release", "version")], collapse = " "), 
[10:22:44.248]                             hostname = base::Sys.info()[["nodename"]])
[10:22:44.248]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:44.248]                             info)
[10:22:44.248]                           info <- base::paste(info, collapse = "; ")
[10:22:44.248]                           if (!has_future) {
[10:22:44.248]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:44.248]                               info)
[10:22:44.248]                           }
[10:22:44.248]                           else {
[10:22:44.248]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:44.248]                               info, version)
[10:22:44.248]                           }
[10:22:44.248]                           base::stop(msg)
[10:22:44.248]                         }
[10:22:44.248]                       })
[10:22:44.248]                     }
[10:22:44.248]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:44.248]                     base::options(mc.cores = 1L)
[10:22:44.248]                   }
[10:22:44.248]                   ...future.strategy.old <- future::plan("list")
[10:22:44.248]                   options(future.plan = NULL)
[10:22:44.248]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:44.248]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:44.248]                 }
[10:22:44.248]                 ...future.workdir <- getwd()
[10:22:44.248]             }
[10:22:44.248]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:44.248]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:44.248]         }
[10:22:44.248]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:44.248]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:44.248]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:44.248]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:44.248]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:44.248]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:44.248]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:44.248]             base::names(...future.oldOptions))
[10:22:44.248]     }
[10:22:44.248]     if (FALSE) {
[10:22:44.248]     }
[10:22:44.248]     else {
[10:22:44.248]         if (TRUE) {
[10:22:44.248]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:44.248]                 open = "w")
[10:22:44.248]         }
[10:22:44.248]         else {
[10:22:44.248]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:44.248]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:44.248]         }
[10:22:44.248]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:44.248]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:44.248]             base::sink(type = "output", split = FALSE)
[10:22:44.248]             base::close(...future.stdout)
[10:22:44.248]         }, add = TRUE)
[10:22:44.248]     }
[10:22:44.248]     ...future.frame <- base::sys.nframe()
[10:22:44.248]     ...future.conditions <- base::list()
[10:22:44.248]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:44.248]     if (FALSE) {
[10:22:44.248]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:44.248]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:44.248]     }
[10:22:44.248]     ...future.result <- base::tryCatch({
[10:22:44.248]         base::withCallingHandlers({
[10:22:44.248]             ...future.value <- base::withVisible(base::local({
[10:22:44.248]                 ...future.makeSendCondition <- base::local({
[10:22:44.248]                   sendCondition <- NULL
[10:22:44.248]                   function(frame = 1L) {
[10:22:44.248]                     if (is.function(sendCondition)) 
[10:22:44.248]                       return(sendCondition)
[10:22:44.248]                     ns <- getNamespace("parallel")
[10:22:44.248]                     if (exists("sendData", mode = "function", 
[10:22:44.248]                       envir = ns)) {
[10:22:44.248]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:44.248]                         envir = ns)
[10:22:44.248]                       envir <- sys.frame(frame)
[10:22:44.248]                       master <- NULL
[10:22:44.248]                       while (!identical(envir, .GlobalEnv) && 
[10:22:44.248]                         !identical(envir, emptyenv())) {
[10:22:44.248]                         if (exists("master", mode = "list", envir = envir, 
[10:22:44.248]                           inherits = FALSE)) {
[10:22:44.248]                           master <- get("master", mode = "list", 
[10:22:44.248]                             envir = envir, inherits = FALSE)
[10:22:44.248]                           if (inherits(master, c("SOCKnode", 
[10:22:44.248]                             "SOCK0node"))) {
[10:22:44.248]                             sendCondition <<- function(cond) {
[10:22:44.248]                               data <- list(type = "VALUE", value = cond, 
[10:22:44.248]                                 success = TRUE)
[10:22:44.248]                               parallel_sendData(master, data)
[10:22:44.248]                             }
[10:22:44.248]                             return(sendCondition)
[10:22:44.248]                           }
[10:22:44.248]                         }
[10:22:44.248]                         frame <- frame + 1L
[10:22:44.248]                         envir <- sys.frame(frame)
[10:22:44.248]                       }
[10:22:44.248]                     }
[10:22:44.248]                     sendCondition <<- function(cond) NULL
[10:22:44.248]                   }
[10:22:44.248]                 })
[10:22:44.248]                 withCallingHandlers({
[10:22:44.248]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:22:44.248]                 }, immediateCondition = function(cond) {
[10:22:44.248]                   sendCondition <- ...future.makeSendCondition()
[10:22:44.248]                   sendCondition(cond)
[10:22:44.248]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.248]                   {
[10:22:44.248]                     inherits <- base::inherits
[10:22:44.248]                     invokeRestart <- base::invokeRestart
[10:22:44.248]                     is.null <- base::is.null
[10:22:44.248]                     muffled <- FALSE
[10:22:44.248]                     if (inherits(cond, "message")) {
[10:22:44.248]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:44.248]                       if (muffled) 
[10:22:44.248]                         invokeRestart("muffleMessage")
[10:22:44.248]                     }
[10:22:44.248]                     else if (inherits(cond, "warning")) {
[10:22:44.248]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:44.248]                       if (muffled) 
[10:22:44.248]                         invokeRestart("muffleWarning")
[10:22:44.248]                     }
[10:22:44.248]                     else if (inherits(cond, "condition")) {
[10:22:44.248]                       if (!is.null(pattern)) {
[10:22:44.248]                         computeRestarts <- base::computeRestarts
[10:22:44.248]                         grepl <- base::grepl
[10:22:44.248]                         restarts <- computeRestarts(cond)
[10:22:44.248]                         for (restart in restarts) {
[10:22:44.248]                           name <- restart$name
[10:22:44.248]                           if (is.null(name)) 
[10:22:44.248]                             next
[10:22:44.248]                           if (!grepl(pattern, name)) 
[10:22:44.248]                             next
[10:22:44.248]                           invokeRestart(restart)
[10:22:44.248]                           muffled <- TRUE
[10:22:44.248]                           break
[10:22:44.248]                         }
[10:22:44.248]                       }
[10:22:44.248]                     }
[10:22:44.248]                     invisible(muffled)
[10:22:44.248]                   }
[10:22:44.248]                   muffleCondition(cond)
[10:22:44.248]                 })
[10:22:44.248]             }))
[10:22:44.248]             future::FutureResult(value = ...future.value$value, 
[10:22:44.248]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:44.248]                   ...future.rng), globalenv = if (FALSE) 
[10:22:44.248]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:44.248]                     ...future.globalenv.names))
[10:22:44.248]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:44.248]         }, condition = base::local({
[10:22:44.248]             c <- base::c
[10:22:44.248]             inherits <- base::inherits
[10:22:44.248]             invokeRestart <- base::invokeRestart
[10:22:44.248]             length <- base::length
[10:22:44.248]             list <- base::list
[10:22:44.248]             seq.int <- base::seq.int
[10:22:44.248]             signalCondition <- base::signalCondition
[10:22:44.248]             sys.calls <- base::sys.calls
[10:22:44.248]             `[[` <- base::`[[`
[10:22:44.248]             `+` <- base::`+`
[10:22:44.248]             `<<-` <- base::`<<-`
[10:22:44.248]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:44.248]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:44.248]                   3L)]
[10:22:44.248]             }
[10:22:44.248]             function(cond) {
[10:22:44.248]                 is_error <- inherits(cond, "error")
[10:22:44.248]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:44.248]                   NULL)
[10:22:44.248]                 if (is_error) {
[10:22:44.248]                   sessionInformation <- function() {
[10:22:44.248]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:44.248]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:44.248]                       search = base::search(), system = base::Sys.info())
[10:22:44.248]                   }
[10:22:44.248]                   ...future.conditions[[length(...future.conditions) + 
[10:22:44.248]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:44.248]                     cond$call), session = sessionInformation(), 
[10:22:44.248]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:44.248]                   signalCondition(cond)
[10:22:44.248]                 }
[10:22:44.248]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:44.248]                 "immediateCondition"))) {
[10:22:44.248]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:44.248]                   ...future.conditions[[length(...future.conditions) + 
[10:22:44.248]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:44.248]                   if (TRUE && !signal) {
[10:22:44.248]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.248]                     {
[10:22:44.248]                       inherits <- base::inherits
[10:22:44.248]                       invokeRestart <- base::invokeRestart
[10:22:44.248]                       is.null <- base::is.null
[10:22:44.248]                       muffled <- FALSE
[10:22:44.248]                       if (inherits(cond, "message")) {
[10:22:44.248]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:44.248]                         if (muffled) 
[10:22:44.248]                           invokeRestart("muffleMessage")
[10:22:44.248]                       }
[10:22:44.248]                       else if (inherits(cond, "warning")) {
[10:22:44.248]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:44.248]                         if (muffled) 
[10:22:44.248]                           invokeRestart("muffleWarning")
[10:22:44.248]                       }
[10:22:44.248]                       else if (inherits(cond, "condition")) {
[10:22:44.248]                         if (!is.null(pattern)) {
[10:22:44.248]                           computeRestarts <- base::computeRestarts
[10:22:44.248]                           grepl <- base::grepl
[10:22:44.248]                           restarts <- computeRestarts(cond)
[10:22:44.248]                           for (restart in restarts) {
[10:22:44.248]                             name <- restart$name
[10:22:44.248]                             if (is.null(name)) 
[10:22:44.248]                               next
[10:22:44.248]                             if (!grepl(pattern, name)) 
[10:22:44.248]                               next
[10:22:44.248]                             invokeRestart(restart)
[10:22:44.248]                             muffled <- TRUE
[10:22:44.248]                             break
[10:22:44.248]                           }
[10:22:44.248]                         }
[10:22:44.248]                       }
[10:22:44.248]                       invisible(muffled)
[10:22:44.248]                     }
[10:22:44.248]                     muffleCondition(cond, pattern = "^muffle")
[10:22:44.248]                   }
[10:22:44.248]                 }
[10:22:44.248]                 else {
[10:22:44.248]                   if (TRUE) {
[10:22:44.248]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.248]                     {
[10:22:44.248]                       inherits <- base::inherits
[10:22:44.248]                       invokeRestart <- base::invokeRestart
[10:22:44.248]                       is.null <- base::is.null
[10:22:44.248]                       muffled <- FALSE
[10:22:44.248]                       if (inherits(cond, "message")) {
[10:22:44.248]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:44.248]                         if (muffled) 
[10:22:44.248]                           invokeRestart("muffleMessage")
[10:22:44.248]                       }
[10:22:44.248]                       else if (inherits(cond, "warning")) {
[10:22:44.248]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:44.248]                         if (muffled) 
[10:22:44.248]                           invokeRestart("muffleWarning")
[10:22:44.248]                       }
[10:22:44.248]                       else if (inherits(cond, "condition")) {
[10:22:44.248]                         if (!is.null(pattern)) {
[10:22:44.248]                           computeRestarts <- base::computeRestarts
[10:22:44.248]                           grepl <- base::grepl
[10:22:44.248]                           restarts <- computeRestarts(cond)
[10:22:44.248]                           for (restart in restarts) {
[10:22:44.248]                             name <- restart$name
[10:22:44.248]                             if (is.null(name)) 
[10:22:44.248]                               next
[10:22:44.248]                             if (!grepl(pattern, name)) 
[10:22:44.248]                               next
[10:22:44.248]                             invokeRestart(restart)
[10:22:44.248]                             muffled <- TRUE
[10:22:44.248]                             break
[10:22:44.248]                           }
[10:22:44.248]                         }
[10:22:44.248]                       }
[10:22:44.248]                       invisible(muffled)
[10:22:44.248]                     }
[10:22:44.248]                     muffleCondition(cond, pattern = "^muffle")
[10:22:44.248]                   }
[10:22:44.248]                 }
[10:22:44.248]             }
[10:22:44.248]         }))
[10:22:44.248]     }, error = function(ex) {
[10:22:44.248]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:44.248]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:44.248]                 ...future.rng), started = ...future.startTime, 
[10:22:44.248]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:44.248]             version = "1.8"), class = "FutureResult")
[10:22:44.248]     }, finally = {
[10:22:44.248]         if (!identical(...future.workdir, getwd())) 
[10:22:44.248]             setwd(...future.workdir)
[10:22:44.248]         {
[10:22:44.248]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:44.248]                 ...future.oldOptions$nwarnings <- NULL
[10:22:44.248]             }
[10:22:44.248]             base::options(...future.oldOptions)
[10:22:44.248]             if (.Platform$OS.type == "windows") {
[10:22:44.248]                 old_names <- names(...future.oldEnvVars)
[10:22:44.248]                 envs <- base::Sys.getenv()
[10:22:44.248]                 names <- names(envs)
[10:22:44.248]                 common <- intersect(names, old_names)
[10:22:44.248]                 added <- setdiff(names, old_names)
[10:22:44.248]                 removed <- setdiff(old_names, names)
[10:22:44.248]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:44.248]                   envs[common]]
[10:22:44.248]                 NAMES <- toupper(changed)
[10:22:44.248]                 args <- list()
[10:22:44.248]                 for (kk in seq_along(NAMES)) {
[10:22:44.248]                   name <- changed[[kk]]
[10:22:44.248]                   NAME <- NAMES[[kk]]
[10:22:44.248]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.248]                     next
[10:22:44.248]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:44.248]                 }
[10:22:44.248]                 NAMES <- toupper(added)
[10:22:44.248]                 for (kk in seq_along(NAMES)) {
[10:22:44.248]                   name <- added[[kk]]
[10:22:44.248]                   NAME <- NAMES[[kk]]
[10:22:44.248]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.248]                     next
[10:22:44.248]                   args[[name]] <- ""
[10:22:44.248]                 }
[10:22:44.248]                 NAMES <- toupper(removed)
[10:22:44.248]                 for (kk in seq_along(NAMES)) {
[10:22:44.248]                   name <- removed[[kk]]
[10:22:44.248]                   NAME <- NAMES[[kk]]
[10:22:44.248]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.248]                     next
[10:22:44.248]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:44.248]                 }
[10:22:44.248]                 if (length(args) > 0) 
[10:22:44.248]                   base::do.call(base::Sys.setenv, args = args)
[10:22:44.248]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:44.248]             }
[10:22:44.248]             else {
[10:22:44.248]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:44.248]             }
[10:22:44.248]             {
[10:22:44.248]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:44.248]                   0L) {
[10:22:44.248]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:44.248]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:44.248]                   base::options(opts)
[10:22:44.248]                 }
[10:22:44.248]                 {
[10:22:44.248]                   {
[10:22:44.248]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:44.248]                     NULL
[10:22:44.248]                   }
[10:22:44.248]                   options(future.plan = NULL)
[10:22:44.248]                   if (is.na(NA_character_)) 
[10:22:44.248]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:44.248]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:44.248]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:44.248]                     .init = FALSE)
[10:22:44.248]                 }
[10:22:44.248]             }
[10:22:44.248]         }
[10:22:44.248]     })
[10:22:44.248]     if (TRUE) {
[10:22:44.248]         base::sink(type = "output", split = FALSE)
[10:22:44.248]         if (TRUE) {
[10:22:44.248]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:44.248]         }
[10:22:44.248]         else {
[10:22:44.248]             ...future.result["stdout"] <- base::list(NULL)
[10:22:44.248]         }
[10:22:44.248]         base::close(...future.stdout)
[10:22:44.248]         ...future.stdout <- NULL
[10:22:44.248]     }
[10:22:44.248]     ...future.result$conditions <- ...future.conditions
[10:22:44.248]     ...future.result$finished <- base::Sys.time()
[10:22:44.248]     ...future.result
[10:22:44.248] }
[10:22:44.251] MultisessionFuture started
[10:22:44.251] - Launch lazy future ... done
[10:22:44.251] run() for ‘MultisessionFuture’ ... done
[10:22:44.293] receiveMessageFromWorker() for ClusterFuture ...
[10:22:44.294] - Validating connection of MultisessionFuture
[10:22:44.294] - received message: FutureResult
[10:22:44.294] - Received FutureResult
[10:22:44.294] - Erased future from FutureRegistry
[10:22:44.294] result() for ClusterFuture ...
[10:22:44.294] - result already collected: FutureResult
[10:22:44.295] result() for ClusterFuture ... done
[10:22:44.295] signalConditions() ...
[10:22:44.295]  - include = ‘immediateCondition’
[10:22:44.295]  - exclude = 
[10:22:44.295]  - resignal = FALSE
[10:22:44.295]  - Number of conditions: 1
[10:22:44.295] signalConditions() ... done
[10:22:44.295] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:44.295] A MultisessionFuture was resolved
[10:22:44.295] getGlobalsAndPackages() ...
[10:22:44.295] Searching for globals...
[10:22:44.296] - globals found: [2] ‘list’, ‘stop’
[10:22:44.296] Searching for globals ... DONE
[10:22:44.296] Resolving globals: FALSE
[10:22:44.297] 
[10:22:44.297] 
[10:22:44.297] getGlobalsAndPackages() ... DONE
[10:22:44.297] run() for ‘Future’ ...
[10:22:44.297] - state: ‘created’
[10:22:44.297] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:44.311] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:44.311] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:44.311]   - Field: ‘node’
[10:22:44.311]   - Field: ‘label’
[10:22:44.311]   - Field: ‘local’
[10:22:44.311]   - Field: ‘owner’
[10:22:44.312]   - Field: ‘envir’
[10:22:44.312]   - Field: ‘workers’
[10:22:44.312]   - Field: ‘packages’
[10:22:44.312]   - Field: ‘gc’
[10:22:44.312]   - Field: ‘conditions’
[10:22:44.312]   - Field: ‘persistent’
[10:22:44.312]   - Field: ‘expr’
[10:22:44.312]   - Field: ‘uuid’
[10:22:44.312]   - Field: ‘seed’
[10:22:44.312]   - Field: ‘version’
[10:22:44.312]   - Field: ‘result’
[10:22:44.312]   - Field: ‘asynchronous’
[10:22:44.313]   - Field: ‘calls’
[10:22:44.313]   - Field: ‘globals’
[10:22:44.313]   - Field: ‘stdout’
[10:22:44.313]   - Field: ‘earlySignal’
[10:22:44.313]   - Field: ‘lazy’
[10:22:44.313]   - Field: ‘state’
[10:22:44.313] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:44.313] - Launch lazy future ...
[10:22:44.313] Packages needed by the future expression (n = 0): <none>
[10:22:44.313] Packages needed by future strategies (n = 0): <none>
[10:22:44.314] {
[10:22:44.314]     {
[10:22:44.314]         {
[10:22:44.314]             ...future.startTime <- base::Sys.time()
[10:22:44.314]             {
[10:22:44.314]                 {
[10:22:44.314]                   {
[10:22:44.314]                     {
[10:22:44.314]                       base::local({
[10:22:44.314]                         has_future <- base::requireNamespace("future", 
[10:22:44.314]                           quietly = TRUE)
[10:22:44.314]                         if (has_future) {
[10:22:44.314]                           ns <- base::getNamespace("future")
[10:22:44.314]                           version <- ns[[".package"]][["version"]]
[10:22:44.314]                           if (is.null(version)) 
[10:22:44.314]                             version <- utils::packageVersion("future")
[10:22:44.314]                         }
[10:22:44.314]                         else {
[10:22:44.314]                           version <- NULL
[10:22:44.314]                         }
[10:22:44.314]                         if (!has_future || version < "1.8.0") {
[10:22:44.314]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:44.314]                             "", base::R.version$version.string), 
[10:22:44.314]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:44.314]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:44.314]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:44.314]                               "release", "version")], collapse = " "), 
[10:22:44.314]                             hostname = base::Sys.info()[["nodename"]])
[10:22:44.314]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:44.314]                             info)
[10:22:44.314]                           info <- base::paste(info, collapse = "; ")
[10:22:44.314]                           if (!has_future) {
[10:22:44.314]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:44.314]                               info)
[10:22:44.314]                           }
[10:22:44.314]                           else {
[10:22:44.314]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:44.314]                               info, version)
[10:22:44.314]                           }
[10:22:44.314]                           base::stop(msg)
[10:22:44.314]                         }
[10:22:44.314]                       })
[10:22:44.314]                     }
[10:22:44.314]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:44.314]                     base::options(mc.cores = 1L)
[10:22:44.314]                   }
[10:22:44.314]                   ...future.strategy.old <- future::plan("list")
[10:22:44.314]                   options(future.plan = NULL)
[10:22:44.314]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:44.314]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:44.314]                 }
[10:22:44.314]                 ...future.workdir <- getwd()
[10:22:44.314]             }
[10:22:44.314]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:44.314]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:44.314]         }
[10:22:44.314]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:44.314]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:44.314]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:44.314]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:44.314]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:44.314]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:44.314]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:44.314]             base::names(...future.oldOptions))
[10:22:44.314]     }
[10:22:44.314]     if (FALSE) {
[10:22:44.314]     }
[10:22:44.314]     else {
[10:22:44.314]         if (TRUE) {
[10:22:44.314]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:44.314]                 open = "w")
[10:22:44.314]         }
[10:22:44.314]         else {
[10:22:44.314]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:44.314]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:44.314]         }
[10:22:44.314]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:44.314]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:44.314]             base::sink(type = "output", split = FALSE)
[10:22:44.314]             base::close(...future.stdout)
[10:22:44.314]         }, add = TRUE)
[10:22:44.314]     }
[10:22:44.314]     ...future.frame <- base::sys.nframe()
[10:22:44.314]     ...future.conditions <- base::list()
[10:22:44.314]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:44.314]     if (FALSE) {
[10:22:44.314]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:44.314]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:44.314]     }
[10:22:44.314]     ...future.result <- base::tryCatch({
[10:22:44.314]         base::withCallingHandlers({
[10:22:44.314]             ...future.value <- base::withVisible(base::local({
[10:22:44.314]                 ...future.makeSendCondition <- base::local({
[10:22:44.314]                   sendCondition <- NULL
[10:22:44.314]                   function(frame = 1L) {
[10:22:44.314]                     if (is.function(sendCondition)) 
[10:22:44.314]                       return(sendCondition)
[10:22:44.314]                     ns <- getNamespace("parallel")
[10:22:44.314]                     if (exists("sendData", mode = "function", 
[10:22:44.314]                       envir = ns)) {
[10:22:44.314]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:44.314]                         envir = ns)
[10:22:44.314]                       envir <- sys.frame(frame)
[10:22:44.314]                       master <- NULL
[10:22:44.314]                       while (!identical(envir, .GlobalEnv) && 
[10:22:44.314]                         !identical(envir, emptyenv())) {
[10:22:44.314]                         if (exists("master", mode = "list", envir = envir, 
[10:22:44.314]                           inherits = FALSE)) {
[10:22:44.314]                           master <- get("master", mode = "list", 
[10:22:44.314]                             envir = envir, inherits = FALSE)
[10:22:44.314]                           if (inherits(master, c("SOCKnode", 
[10:22:44.314]                             "SOCK0node"))) {
[10:22:44.314]                             sendCondition <<- function(cond) {
[10:22:44.314]                               data <- list(type = "VALUE", value = cond, 
[10:22:44.314]                                 success = TRUE)
[10:22:44.314]                               parallel_sendData(master, data)
[10:22:44.314]                             }
[10:22:44.314]                             return(sendCondition)
[10:22:44.314]                           }
[10:22:44.314]                         }
[10:22:44.314]                         frame <- frame + 1L
[10:22:44.314]                         envir <- sys.frame(frame)
[10:22:44.314]                       }
[10:22:44.314]                     }
[10:22:44.314]                     sendCondition <<- function(cond) NULL
[10:22:44.314]                   }
[10:22:44.314]                 })
[10:22:44.314]                 withCallingHandlers({
[10:22:44.314]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:22:44.314]                 }, immediateCondition = function(cond) {
[10:22:44.314]                   sendCondition <- ...future.makeSendCondition()
[10:22:44.314]                   sendCondition(cond)
[10:22:44.314]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.314]                   {
[10:22:44.314]                     inherits <- base::inherits
[10:22:44.314]                     invokeRestart <- base::invokeRestart
[10:22:44.314]                     is.null <- base::is.null
[10:22:44.314]                     muffled <- FALSE
[10:22:44.314]                     if (inherits(cond, "message")) {
[10:22:44.314]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:44.314]                       if (muffled) 
[10:22:44.314]                         invokeRestart("muffleMessage")
[10:22:44.314]                     }
[10:22:44.314]                     else if (inherits(cond, "warning")) {
[10:22:44.314]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:44.314]                       if (muffled) 
[10:22:44.314]                         invokeRestart("muffleWarning")
[10:22:44.314]                     }
[10:22:44.314]                     else if (inherits(cond, "condition")) {
[10:22:44.314]                       if (!is.null(pattern)) {
[10:22:44.314]                         computeRestarts <- base::computeRestarts
[10:22:44.314]                         grepl <- base::grepl
[10:22:44.314]                         restarts <- computeRestarts(cond)
[10:22:44.314]                         for (restart in restarts) {
[10:22:44.314]                           name <- restart$name
[10:22:44.314]                           if (is.null(name)) 
[10:22:44.314]                             next
[10:22:44.314]                           if (!grepl(pattern, name)) 
[10:22:44.314]                             next
[10:22:44.314]                           invokeRestart(restart)
[10:22:44.314]                           muffled <- TRUE
[10:22:44.314]                           break
[10:22:44.314]                         }
[10:22:44.314]                       }
[10:22:44.314]                     }
[10:22:44.314]                     invisible(muffled)
[10:22:44.314]                   }
[10:22:44.314]                   muffleCondition(cond)
[10:22:44.314]                 })
[10:22:44.314]             }))
[10:22:44.314]             future::FutureResult(value = ...future.value$value, 
[10:22:44.314]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:44.314]                   ...future.rng), globalenv = if (FALSE) 
[10:22:44.314]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:44.314]                     ...future.globalenv.names))
[10:22:44.314]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:44.314]         }, condition = base::local({
[10:22:44.314]             c <- base::c
[10:22:44.314]             inherits <- base::inherits
[10:22:44.314]             invokeRestart <- base::invokeRestart
[10:22:44.314]             length <- base::length
[10:22:44.314]             list <- base::list
[10:22:44.314]             seq.int <- base::seq.int
[10:22:44.314]             signalCondition <- base::signalCondition
[10:22:44.314]             sys.calls <- base::sys.calls
[10:22:44.314]             `[[` <- base::`[[`
[10:22:44.314]             `+` <- base::`+`
[10:22:44.314]             `<<-` <- base::`<<-`
[10:22:44.314]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:44.314]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:44.314]                   3L)]
[10:22:44.314]             }
[10:22:44.314]             function(cond) {
[10:22:44.314]                 is_error <- inherits(cond, "error")
[10:22:44.314]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:44.314]                   NULL)
[10:22:44.314]                 if (is_error) {
[10:22:44.314]                   sessionInformation <- function() {
[10:22:44.314]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:44.314]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:44.314]                       search = base::search(), system = base::Sys.info())
[10:22:44.314]                   }
[10:22:44.314]                   ...future.conditions[[length(...future.conditions) + 
[10:22:44.314]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:44.314]                     cond$call), session = sessionInformation(), 
[10:22:44.314]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:44.314]                   signalCondition(cond)
[10:22:44.314]                 }
[10:22:44.314]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:44.314]                 "immediateCondition"))) {
[10:22:44.314]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:44.314]                   ...future.conditions[[length(...future.conditions) + 
[10:22:44.314]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:44.314]                   if (TRUE && !signal) {
[10:22:44.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.314]                     {
[10:22:44.314]                       inherits <- base::inherits
[10:22:44.314]                       invokeRestart <- base::invokeRestart
[10:22:44.314]                       is.null <- base::is.null
[10:22:44.314]                       muffled <- FALSE
[10:22:44.314]                       if (inherits(cond, "message")) {
[10:22:44.314]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:44.314]                         if (muffled) 
[10:22:44.314]                           invokeRestart("muffleMessage")
[10:22:44.314]                       }
[10:22:44.314]                       else if (inherits(cond, "warning")) {
[10:22:44.314]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:44.314]                         if (muffled) 
[10:22:44.314]                           invokeRestart("muffleWarning")
[10:22:44.314]                       }
[10:22:44.314]                       else if (inherits(cond, "condition")) {
[10:22:44.314]                         if (!is.null(pattern)) {
[10:22:44.314]                           computeRestarts <- base::computeRestarts
[10:22:44.314]                           grepl <- base::grepl
[10:22:44.314]                           restarts <- computeRestarts(cond)
[10:22:44.314]                           for (restart in restarts) {
[10:22:44.314]                             name <- restart$name
[10:22:44.314]                             if (is.null(name)) 
[10:22:44.314]                               next
[10:22:44.314]                             if (!grepl(pattern, name)) 
[10:22:44.314]                               next
[10:22:44.314]                             invokeRestart(restart)
[10:22:44.314]                             muffled <- TRUE
[10:22:44.314]                             break
[10:22:44.314]                           }
[10:22:44.314]                         }
[10:22:44.314]                       }
[10:22:44.314]                       invisible(muffled)
[10:22:44.314]                     }
[10:22:44.314]                     muffleCondition(cond, pattern = "^muffle")
[10:22:44.314]                   }
[10:22:44.314]                 }
[10:22:44.314]                 else {
[10:22:44.314]                   if (TRUE) {
[10:22:44.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.314]                     {
[10:22:44.314]                       inherits <- base::inherits
[10:22:44.314]                       invokeRestart <- base::invokeRestart
[10:22:44.314]                       is.null <- base::is.null
[10:22:44.314]                       muffled <- FALSE
[10:22:44.314]                       if (inherits(cond, "message")) {
[10:22:44.314]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:44.314]                         if (muffled) 
[10:22:44.314]                           invokeRestart("muffleMessage")
[10:22:44.314]                       }
[10:22:44.314]                       else if (inherits(cond, "warning")) {
[10:22:44.314]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:44.314]                         if (muffled) 
[10:22:44.314]                           invokeRestart("muffleWarning")
[10:22:44.314]                       }
[10:22:44.314]                       else if (inherits(cond, "condition")) {
[10:22:44.314]                         if (!is.null(pattern)) {
[10:22:44.314]                           computeRestarts <- base::computeRestarts
[10:22:44.314]                           grepl <- base::grepl
[10:22:44.314]                           restarts <- computeRestarts(cond)
[10:22:44.314]                           for (restart in restarts) {
[10:22:44.314]                             name <- restart$name
[10:22:44.314]                             if (is.null(name)) 
[10:22:44.314]                               next
[10:22:44.314]                             if (!grepl(pattern, name)) 
[10:22:44.314]                               next
[10:22:44.314]                             invokeRestart(restart)
[10:22:44.314]                             muffled <- TRUE
[10:22:44.314]                             break
[10:22:44.314]                           }
[10:22:44.314]                         }
[10:22:44.314]                       }
[10:22:44.314]                       invisible(muffled)
[10:22:44.314]                     }
[10:22:44.314]                     muffleCondition(cond, pattern = "^muffle")
[10:22:44.314]                   }
[10:22:44.314]                 }
[10:22:44.314]             }
[10:22:44.314]         }))
[10:22:44.314]     }, error = function(ex) {
[10:22:44.314]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:44.314]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:44.314]                 ...future.rng), started = ...future.startTime, 
[10:22:44.314]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:44.314]             version = "1.8"), class = "FutureResult")
[10:22:44.314]     }, finally = {
[10:22:44.314]         if (!identical(...future.workdir, getwd())) 
[10:22:44.314]             setwd(...future.workdir)
[10:22:44.314]         {
[10:22:44.314]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:44.314]                 ...future.oldOptions$nwarnings <- NULL
[10:22:44.314]             }
[10:22:44.314]             base::options(...future.oldOptions)
[10:22:44.314]             if (.Platform$OS.type == "windows") {
[10:22:44.314]                 old_names <- names(...future.oldEnvVars)
[10:22:44.314]                 envs <- base::Sys.getenv()
[10:22:44.314]                 names <- names(envs)
[10:22:44.314]                 common <- intersect(names, old_names)
[10:22:44.314]                 added <- setdiff(names, old_names)
[10:22:44.314]                 removed <- setdiff(old_names, names)
[10:22:44.314]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:44.314]                   envs[common]]
[10:22:44.314]                 NAMES <- toupper(changed)
[10:22:44.314]                 args <- list()
[10:22:44.314]                 for (kk in seq_along(NAMES)) {
[10:22:44.314]                   name <- changed[[kk]]
[10:22:44.314]                   NAME <- NAMES[[kk]]
[10:22:44.314]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.314]                     next
[10:22:44.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:44.314]                 }
[10:22:44.314]                 NAMES <- toupper(added)
[10:22:44.314]                 for (kk in seq_along(NAMES)) {
[10:22:44.314]                   name <- added[[kk]]
[10:22:44.314]                   NAME <- NAMES[[kk]]
[10:22:44.314]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.314]                     next
[10:22:44.314]                   args[[name]] <- ""
[10:22:44.314]                 }
[10:22:44.314]                 NAMES <- toupper(removed)
[10:22:44.314]                 for (kk in seq_along(NAMES)) {
[10:22:44.314]                   name <- removed[[kk]]
[10:22:44.314]                   NAME <- NAMES[[kk]]
[10:22:44.314]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.314]                     next
[10:22:44.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:44.314]                 }
[10:22:44.314]                 if (length(args) > 0) 
[10:22:44.314]                   base::do.call(base::Sys.setenv, args = args)
[10:22:44.314]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:44.314]             }
[10:22:44.314]             else {
[10:22:44.314]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:44.314]             }
[10:22:44.314]             {
[10:22:44.314]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:44.314]                   0L) {
[10:22:44.314]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:44.314]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:44.314]                   base::options(opts)
[10:22:44.314]                 }
[10:22:44.314]                 {
[10:22:44.314]                   {
[10:22:44.314]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:44.314]                     NULL
[10:22:44.314]                   }
[10:22:44.314]                   options(future.plan = NULL)
[10:22:44.314]                   if (is.na(NA_character_)) 
[10:22:44.314]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:44.314]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:44.314]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:44.314]                     .init = FALSE)
[10:22:44.314]                 }
[10:22:44.314]             }
[10:22:44.314]         }
[10:22:44.314]     })
[10:22:44.314]     if (TRUE) {
[10:22:44.314]         base::sink(type = "output", split = FALSE)
[10:22:44.314]         if (TRUE) {
[10:22:44.314]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:44.314]         }
[10:22:44.314]         else {
[10:22:44.314]             ...future.result["stdout"] <- base::list(NULL)
[10:22:44.314]         }
[10:22:44.314]         base::close(...future.stdout)
[10:22:44.314]         ...future.stdout <- NULL
[10:22:44.314]     }
[10:22:44.314]     ...future.result$conditions <- ...future.conditions
[10:22:44.314]     ...future.result$finished <- base::Sys.time()
[10:22:44.314]     ...future.result
[10:22:44.314] }
[10:22:44.319] MultisessionFuture started
[10:22:44.319] - Launch lazy future ... done
[10:22:44.319] run() for ‘MultisessionFuture’ ... done
[10:22:44.361] receiveMessageFromWorker() for ClusterFuture ...
[10:22:44.362] - Validating connection of MultisessionFuture
[10:22:44.362] - received message: FutureResult
[10:22:44.362] - Received FutureResult
[10:22:44.362] - Erased future from FutureRegistry
[10:22:44.362] result() for ClusterFuture ...
[10:22:44.362] - result already collected: FutureResult
[10:22:44.363] result() for ClusterFuture ... done
[10:22:44.363] signalConditions() ...
[10:22:44.363]  - include = ‘immediateCondition’
[10:22:44.363]  - exclude = 
[10:22:44.363]  - resignal = FALSE
[10:22:44.363]  - Number of conditions: 1
[10:22:44.363] signalConditions() ... done
[10:22:44.363] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:44.363] A MultisessionFuture was resolved
- result = TRUE, recursive = 0 ... DONE
- result = TRUE, recursive = 1 ...
[10:22:44.363] getGlobalsAndPackages() ...
[10:22:44.364] Searching for globals...
[10:22:44.365] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:22:44.365] Searching for globals ... DONE
[10:22:44.365] Resolving globals: FALSE
[10:22:44.365] 
[10:22:44.365] 
[10:22:44.365] getGlobalsAndPackages() ... DONE
[10:22:44.366] run() for ‘Future’ ...
[10:22:44.366] - state: ‘created’
[10:22:44.366] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:44.379] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:44.379] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:44.379]   - Field: ‘node’
[10:22:44.379]   - Field: ‘label’
[10:22:44.380]   - Field: ‘local’
[10:22:44.380]   - Field: ‘owner’
[10:22:44.380]   - Field: ‘envir’
[10:22:44.380]   - Field: ‘workers’
[10:22:44.380]   - Field: ‘packages’
[10:22:44.380]   - Field: ‘gc’
[10:22:44.380]   - Field: ‘conditions’
[10:22:44.380]   - Field: ‘persistent’
[10:22:44.380]   - Field: ‘expr’
[10:22:44.380]   - Field: ‘uuid’
[10:22:44.380]   - Field: ‘seed’
[10:22:44.381]   - Field: ‘version’
[10:22:44.381]   - Field: ‘result’
[10:22:44.381]   - Field: ‘asynchronous’
[10:22:44.381]   - Field: ‘calls’
[10:22:44.381]   - Field: ‘globals’
[10:22:44.381]   - Field: ‘stdout’
[10:22:44.381]   - Field: ‘earlySignal’
[10:22:44.381]   - Field: ‘lazy’
[10:22:44.381]   - Field: ‘state’
[10:22:44.381] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:44.381] - Launch lazy future ...
[10:22:44.382] Packages needed by the future expression (n = 0): <none>
[10:22:44.382] Packages needed by future strategies (n = 0): <none>
[10:22:44.382] {
[10:22:44.382]     {
[10:22:44.382]         {
[10:22:44.382]             ...future.startTime <- base::Sys.time()
[10:22:44.382]             {
[10:22:44.382]                 {
[10:22:44.382]                   {
[10:22:44.382]                     {
[10:22:44.382]                       base::local({
[10:22:44.382]                         has_future <- base::requireNamespace("future", 
[10:22:44.382]                           quietly = TRUE)
[10:22:44.382]                         if (has_future) {
[10:22:44.382]                           ns <- base::getNamespace("future")
[10:22:44.382]                           version <- ns[[".package"]][["version"]]
[10:22:44.382]                           if (is.null(version)) 
[10:22:44.382]                             version <- utils::packageVersion("future")
[10:22:44.382]                         }
[10:22:44.382]                         else {
[10:22:44.382]                           version <- NULL
[10:22:44.382]                         }
[10:22:44.382]                         if (!has_future || version < "1.8.0") {
[10:22:44.382]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:44.382]                             "", base::R.version$version.string), 
[10:22:44.382]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:44.382]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:44.382]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:44.382]                               "release", "version")], collapse = " "), 
[10:22:44.382]                             hostname = base::Sys.info()[["nodename"]])
[10:22:44.382]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:44.382]                             info)
[10:22:44.382]                           info <- base::paste(info, collapse = "; ")
[10:22:44.382]                           if (!has_future) {
[10:22:44.382]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:44.382]                               info)
[10:22:44.382]                           }
[10:22:44.382]                           else {
[10:22:44.382]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:44.382]                               info, version)
[10:22:44.382]                           }
[10:22:44.382]                           base::stop(msg)
[10:22:44.382]                         }
[10:22:44.382]                       })
[10:22:44.382]                     }
[10:22:44.382]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:44.382]                     base::options(mc.cores = 1L)
[10:22:44.382]                   }
[10:22:44.382]                   ...future.strategy.old <- future::plan("list")
[10:22:44.382]                   options(future.plan = NULL)
[10:22:44.382]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:44.382]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:44.382]                 }
[10:22:44.382]                 ...future.workdir <- getwd()
[10:22:44.382]             }
[10:22:44.382]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:44.382]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:44.382]         }
[10:22:44.382]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:44.382]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:44.382]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:44.382]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:44.382]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:44.382]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:44.382]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:44.382]             base::names(...future.oldOptions))
[10:22:44.382]     }
[10:22:44.382]     if (FALSE) {
[10:22:44.382]     }
[10:22:44.382]     else {
[10:22:44.382]         if (TRUE) {
[10:22:44.382]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:44.382]                 open = "w")
[10:22:44.382]         }
[10:22:44.382]         else {
[10:22:44.382]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:44.382]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:44.382]         }
[10:22:44.382]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:44.382]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:44.382]             base::sink(type = "output", split = FALSE)
[10:22:44.382]             base::close(...future.stdout)
[10:22:44.382]         }, add = TRUE)
[10:22:44.382]     }
[10:22:44.382]     ...future.frame <- base::sys.nframe()
[10:22:44.382]     ...future.conditions <- base::list()
[10:22:44.382]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:44.382]     if (FALSE) {
[10:22:44.382]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:44.382]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:44.382]     }
[10:22:44.382]     ...future.result <- base::tryCatch({
[10:22:44.382]         base::withCallingHandlers({
[10:22:44.382]             ...future.value <- base::withVisible(base::local({
[10:22:44.382]                 ...future.makeSendCondition <- base::local({
[10:22:44.382]                   sendCondition <- NULL
[10:22:44.382]                   function(frame = 1L) {
[10:22:44.382]                     if (is.function(sendCondition)) 
[10:22:44.382]                       return(sendCondition)
[10:22:44.382]                     ns <- getNamespace("parallel")
[10:22:44.382]                     if (exists("sendData", mode = "function", 
[10:22:44.382]                       envir = ns)) {
[10:22:44.382]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:44.382]                         envir = ns)
[10:22:44.382]                       envir <- sys.frame(frame)
[10:22:44.382]                       master <- NULL
[10:22:44.382]                       while (!identical(envir, .GlobalEnv) && 
[10:22:44.382]                         !identical(envir, emptyenv())) {
[10:22:44.382]                         if (exists("master", mode = "list", envir = envir, 
[10:22:44.382]                           inherits = FALSE)) {
[10:22:44.382]                           master <- get("master", mode = "list", 
[10:22:44.382]                             envir = envir, inherits = FALSE)
[10:22:44.382]                           if (inherits(master, c("SOCKnode", 
[10:22:44.382]                             "SOCK0node"))) {
[10:22:44.382]                             sendCondition <<- function(cond) {
[10:22:44.382]                               data <- list(type = "VALUE", value = cond, 
[10:22:44.382]                                 success = TRUE)
[10:22:44.382]                               parallel_sendData(master, data)
[10:22:44.382]                             }
[10:22:44.382]                             return(sendCondition)
[10:22:44.382]                           }
[10:22:44.382]                         }
[10:22:44.382]                         frame <- frame + 1L
[10:22:44.382]                         envir <- sys.frame(frame)
[10:22:44.382]                       }
[10:22:44.382]                     }
[10:22:44.382]                     sendCondition <<- function(cond) NULL
[10:22:44.382]                   }
[10:22:44.382]                 })
[10:22:44.382]                 withCallingHandlers({
[10:22:44.382]                   {
[10:22:44.382]                     Sys.sleep(0.5)
[10:22:44.382]                     list(a = 1, b = 42L)
[10:22:44.382]                   }
[10:22:44.382]                 }, immediateCondition = function(cond) {
[10:22:44.382]                   sendCondition <- ...future.makeSendCondition()
[10:22:44.382]                   sendCondition(cond)
[10:22:44.382]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.382]                   {
[10:22:44.382]                     inherits <- base::inherits
[10:22:44.382]                     invokeRestart <- base::invokeRestart
[10:22:44.382]                     is.null <- base::is.null
[10:22:44.382]                     muffled <- FALSE
[10:22:44.382]                     if (inherits(cond, "message")) {
[10:22:44.382]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:44.382]                       if (muffled) 
[10:22:44.382]                         invokeRestart("muffleMessage")
[10:22:44.382]                     }
[10:22:44.382]                     else if (inherits(cond, "warning")) {
[10:22:44.382]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:44.382]                       if (muffled) 
[10:22:44.382]                         invokeRestart("muffleWarning")
[10:22:44.382]                     }
[10:22:44.382]                     else if (inherits(cond, "condition")) {
[10:22:44.382]                       if (!is.null(pattern)) {
[10:22:44.382]                         computeRestarts <- base::computeRestarts
[10:22:44.382]                         grepl <- base::grepl
[10:22:44.382]                         restarts <- computeRestarts(cond)
[10:22:44.382]                         for (restart in restarts) {
[10:22:44.382]                           name <- restart$name
[10:22:44.382]                           if (is.null(name)) 
[10:22:44.382]                             next
[10:22:44.382]                           if (!grepl(pattern, name)) 
[10:22:44.382]                             next
[10:22:44.382]                           invokeRestart(restart)
[10:22:44.382]                           muffled <- TRUE
[10:22:44.382]                           break
[10:22:44.382]                         }
[10:22:44.382]                       }
[10:22:44.382]                     }
[10:22:44.382]                     invisible(muffled)
[10:22:44.382]                   }
[10:22:44.382]                   muffleCondition(cond)
[10:22:44.382]                 })
[10:22:44.382]             }))
[10:22:44.382]             future::FutureResult(value = ...future.value$value, 
[10:22:44.382]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:44.382]                   ...future.rng), globalenv = if (FALSE) 
[10:22:44.382]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:44.382]                     ...future.globalenv.names))
[10:22:44.382]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:44.382]         }, condition = base::local({
[10:22:44.382]             c <- base::c
[10:22:44.382]             inherits <- base::inherits
[10:22:44.382]             invokeRestart <- base::invokeRestart
[10:22:44.382]             length <- base::length
[10:22:44.382]             list <- base::list
[10:22:44.382]             seq.int <- base::seq.int
[10:22:44.382]             signalCondition <- base::signalCondition
[10:22:44.382]             sys.calls <- base::sys.calls
[10:22:44.382]             `[[` <- base::`[[`
[10:22:44.382]             `+` <- base::`+`
[10:22:44.382]             `<<-` <- base::`<<-`
[10:22:44.382]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:44.382]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:44.382]                   3L)]
[10:22:44.382]             }
[10:22:44.382]             function(cond) {
[10:22:44.382]                 is_error <- inherits(cond, "error")
[10:22:44.382]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:44.382]                   NULL)
[10:22:44.382]                 if (is_error) {
[10:22:44.382]                   sessionInformation <- function() {
[10:22:44.382]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:44.382]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:44.382]                       search = base::search(), system = base::Sys.info())
[10:22:44.382]                   }
[10:22:44.382]                   ...future.conditions[[length(...future.conditions) + 
[10:22:44.382]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:44.382]                     cond$call), session = sessionInformation(), 
[10:22:44.382]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:44.382]                   signalCondition(cond)
[10:22:44.382]                 }
[10:22:44.382]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:44.382]                 "immediateCondition"))) {
[10:22:44.382]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:44.382]                   ...future.conditions[[length(...future.conditions) + 
[10:22:44.382]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:44.382]                   if (TRUE && !signal) {
[10:22:44.382]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.382]                     {
[10:22:44.382]                       inherits <- base::inherits
[10:22:44.382]                       invokeRestart <- base::invokeRestart
[10:22:44.382]                       is.null <- base::is.null
[10:22:44.382]                       muffled <- FALSE
[10:22:44.382]                       if (inherits(cond, "message")) {
[10:22:44.382]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:44.382]                         if (muffled) 
[10:22:44.382]                           invokeRestart("muffleMessage")
[10:22:44.382]                       }
[10:22:44.382]                       else if (inherits(cond, "warning")) {
[10:22:44.382]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:44.382]                         if (muffled) 
[10:22:44.382]                           invokeRestart("muffleWarning")
[10:22:44.382]                       }
[10:22:44.382]                       else if (inherits(cond, "condition")) {
[10:22:44.382]                         if (!is.null(pattern)) {
[10:22:44.382]                           computeRestarts <- base::computeRestarts
[10:22:44.382]                           grepl <- base::grepl
[10:22:44.382]                           restarts <- computeRestarts(cond)
[10:22:44.382]                           for (restart in restarts) {
[10:22:44.382]                             name <- restart$name
[10:22:44.382]                             if (is.null(name)) 
[10:22:44.382]                               next
[10:22:44.382]                             if (!grepl(pattern, name)) 
[10:22:44.382]                               next
[10:22:44.382]                             invokeRestart(restart)
[10:22:44.382]                             muffled <- TRUE
[10:22:44.382]                             break
[10:22:44.382]                           }
[10:22:44.382]                         }
[10:22:44.382]                       }
[10:22:44.382]                       invisible(muffled)
[10:22:44.382]                     }
[10:22:44.382]                     muffleCondition(cond, pattern = "^muffle")
[10:22:44.382]                   }
[10:22:44.382]                 }
[10:22:44.382]                 else {
[10:22:44.382]                   if (TRUE) {
[10:22:44.382]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.382]                     {
[10:22:44.382]                       inherits <- base::inherits
[10:22:44.382]                       invokeRestart <- base::invokeRestart
[10:22:44.382]                       is.null <- base::is.null
[10:22:44.382]                       muffled <- FALSE
[10:22:44.382]                       if (inherits(cond, "message")) {
[10:22:44.382]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:44.382]                         if (muffled) 
[10:22:44.382]                           invokeRestart("muffleMessage")
[10:22:44.382]                       }
[10:22:44.382]                       else if (inherits(cond, "warning")) {
[10:22:44.382]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:44.382]                         if (muffled) 
[10:22:44.382]                           invokeRestart("muffleWarning")
[10:22:44.382]                       }
[10:22:44.382]                       else if (inherits(cond, "condition")) {
[10:22:44.382]                         if (!is.null(pattern)) {
[10:22:44.382]                           computeRestarts <- base::computeRestarts
[10:22:44.382]                           grepl <- base::grepl
[10:22:44.382]                           restarts <- computeRestarts(cond)
[10:22:44.382]                           for (restart in restarts) {
[10:22:44.382]                             name <- restart$name
[10:22:44.382]                             if (is.null(name)) 
[10:22:44.382]                               next
[10:22:44.382]                             if (!grepl(pattern, name)) 
[10:22:44.382]                               next
[10:22:44.382]                             invokeRestart(restart)
[10:22:44.382]                             muffled <- TRUE
[10:22:44.382]                             break
[10:22:44.382]                           }
[10:22:44.382]                         }
[10:22:44.382]                       }
[10:22:44.382]                       invisible(muffled)
[10:22:44.382]                     }
[10:22:44.382]                     muffleCondition(cond, pattern = "^muffle")
[10:22:44.382]                   }
[10:22:44.382]                 }
[10:22:44.382]             }
[10:22:44.382]         }))
[10:22:44.382]     }, error = function(ex) {
[10:22:44.382]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:44.382]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:44.382]                 ...future.rng), started = ...future.startTime, 
[10:22:44.382]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:44.382]             version = "1.8"), class = "FutureResult")
[10:22:44.382]     }, finally = {
[10:22:44.382]         if (!identical(...future.workdir, getwd())) 
[10:22:44.382]             setwd(...future.workdir)
[10:22:44.382]         {
[10:22:44.382]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:44.382]                 ...future.oldOptions$nwarnings <- NULL
[10:22:44.382]             }
[10:22:44.382]             base::options(...future.oldOptions)
[10:22:44.382]             if (.Platform$OS.type == "windows") {
[10:22:44.382]                 old_names <- names(...future.oldEnvVars)
[10:22:44.382]                 envs <- base::Sys.getenv()
[10:22:44.382]                 names <- names(envs)
[10:22:44.382]                 common <- intersect(names, old_names)
[10:22:44.382]                 added <- setdiff(names, old_names)
[10:22:44.382]                 removed <- setdiff(old_names, names)
[10:22:44.382]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:44.382]                   envs[common]]
[10:22:44.382]                 NAMES <- toupper(changed)
[10:22:44.382]                 args <- list()
[10:22:44.382]                 for (kk in seq_along(NAMES)) {
[10:22:44.382]                   name <- changed[[kk]]
[10:22:44.382]                   NAME <- NAMES[[kk]]
[10:22:44.382]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.382]                     next
[10:22:44.382]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:44.382]                 }
[10:22:44.382]                 NAMES <- toupper(added)
[10:22:44.382]                 for (kk in seq_along(NAMES)) {
[10:22:44.382]                   name <- added[[kk]]
[10:22:44.382]                   NAME <- NAMES[[kk]]
[10:22:44.382]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.382]                     next
[10:22:44.382]                   args[[name]] <- ""
[10:22:44.382]                 }
[10:22:44.382]                 NAMES <- toupper(removed)
[10:22:44.382]                 for (kk in seq_along(NAMES)) {
[10:22:44.382]                   name <- removed[[kk]]
[10:22:44.382]                   NAME <- NAMES[[kk]]
[10:22:44.382]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.382]                     next
[10:22:44.382]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:44.382]                 }
[10:22:44.382]                 if (length(args) > 0) 
[10:22:44.382]                   base::do.call(base::Sys.setenv, args = args)
[10:22:44.382]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:44.382]             }
[10:22:44.382]             else {
[10:22:44.382]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:44.382]             }
[10:22:44.382]             {
[10:22:44.382]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:44.382]                   0L) {
[10:22:44.382]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:44.382]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:44.382]                   base::options(opts)
[10:22:44.382]                 }
[10:22:44.382]                 {
[10:22:44.382]                   {
[10:22:44.382]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:44.382]                     NULL
[10:22:44.382]                   }
[10:22:44.382]                   options(future.plan = NULL)
[10:22:44.382]                   if (is.na(NA_character_)) 
[10:22:44.382]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:44.382]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:44.382]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:44.382]                     .init = FALSE)
[10:22:44.382]                 }
[10:22:44.382]             }
[10:22:44.382]         }
[10:22:44.382]     })
[10:22:44.382]     if (TRUE) {
[10:22:44.382]         base::sink(type = "output", split = FALSE)
[10:22:44.382]         if (TRUE) {
[10:22:44.382]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:44.382]         }
[10:22:44.382]         else {
[10:22:44.382]             ...future.result["stdout"] <- base::list(NULL)
[10:22:44.382]         }
[10:22:44.382]         base::close(...future.stdout)
[10:22:44.382]         ...future.stdout <- NULL
[10:22:44.382]     }
[10:22:44.382]     ...future.result$conditions <- ...future.conditions
[10:22:44.382]     ...future.result$finished <- base::Sys.time()
[10:22:44.382]     ...future.result
[10:22:44.382] }
[10:22:44.385] MultisessionFuture started
[10:22:44.385] - Launch lazy future ... done
[10:22:44.385] run() for ‘MultisessionFuture’ ... done
[10:22:44.928] receiveMessageFromWorker() for ClusterFuture ...
[10:22:44.928] - Validating connection of MultisessionFuture
[10:22:44.928] - received message: FutureResult
[10:22:44.928] - Received FutureResult
[10:22:44.929] - Erased future from FutureRegistry
[10:22:44.929] result() for ClusterFuture ...
[10:22:44.929] - result already collected: FutureResult
[10:22:44.929] result() for ClusterFuture ... done
[10:22:44.929] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:44.929] resolve() on list ...
[10:22:44.929]  recursive: 0
[10:22:44.929]  length: 2
[10:22:44.929]  elements: ‘a’, ‘b’
[10:22:44.929]  length: 1 (resolved future 1)
[10:22:44.929]  length: 0 (resolved future 2)
[10:22:44.930] resolve() on list ... DONE
[10:22:44.930] A MultisessionFuture was resolved (and resolved itself)
[10:22:44.930] getGlobalsAndPackages() ...
[10:22:44.930] Searching for globals...
[10:22:44.931] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:22:44.931] Searching for globals ... DONE
[10:22:44.931] Resolving globals: FALSE
[10:22:44.932] 
[10:22:44.932] 
[10:22:44.932] getGlobalsAndPackages() ... DONE
[10:22:44.932] run() for ‘Future’ ...
[10:22:44.932] - state: ‘created’
[10:22:44.932] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:44.949] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:44.949] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:44.949]   - Field: ‘node’
[10:22:44.949]   - Field: ‘label’
[10:22:44.949]   - Field: ‘local’
[10:22:44.949]   - Field: ‘owner’
[10:22:44.950]   - Field: ‘envir’
[10:22:44.950]   - Field: ‘workers’
[10:22:44.950]   - Field: ‘packages’
[10:22:44.950]   - Field: ‘gc’
[10:22:44.950]   - Field: ‘conditions’
[10:22:44.950]   - Field: ‘persistent’
[10:22:44.950]   - Field: ‘expr’
[10:22:44.950]   - Field: ‘uuid’
[10:22:44.950]   - Field: ‘seed’
[10:22:44.950]   - Field: ‘version’
[10:22:44.950]   - Field: ‘result’
[10:22:44.950]   - Field: ‘asynchronous’
[10:22:44.951]   - Field: ‘calls’
[10:22:44.951]   - Field: ‘globals’
[10:22:44.951]   - Field: ‘stdout’
[10:22:44.951]   - Field: ‘earlySignal’
[10:22:44.951]   - Field: ‘lazy’
[10:22:44.951]   - Field: ‘state’
[10:22:44.951] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:44.951] - Launch lazy future ...
[10:22:44.951] Packages needed by the future expression (n = 0): <none>
[10:22:44.952] Packages needed by future strategies (n = 0): <none>
[10:22:44.952] {
[10:22:44.952]     {
[10:22:44.952]         {
[10:22:44.952]             ...future.startTime <- base::Sys.time()
[10:22:44.952]             {
[10:22:44.952]                 {
[10:22:44.952]                   {
[10:22:44.952]                     {
[10:22:44.952]                       base::local({
[10:22:44.952]                         has_future <- base::requireNamespace("future", 
[10:22:44.952]                           quietly = TRUE)
[10:22:44.952]                         if (has_future) {
[10:22:44.952]                           ns <- base::getNamespace("future")
[10:22:44.952]                           version <- ns[[".package"]][["version"]]
[10:22:44.952]                           if (is.null(version)) 
[10:22:44.952]                             version <- utils::packageVersion("future")
[10:22:44.952]                         }
[10:22:44.952]                         else {
[10:22:44.952]                           version <- NULL
[10:22:44.952]                         }
[10:22:44.952]                         if (!has_future || version < "1.8.0") {
[10:22:44.952]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:44.952]                             "", base::R.version$version.string), 
[10:22:44.952]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:44.952]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:44.952]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:44.952]                               "release", "version")], collapse = " "), 
[10:22:44.952]                             hostname = base::Sys.info()[["nodename"]])
[10:22:44.952]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:44.952]                             info)
[10:22:44.952]                           info <- base::paste(info, collapse = "; ")
[10:22:44.952]                           if (!has_future) {
[10:22:44.952]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:44.952]                               info)
[10:22:44.952]                           }
[10:22:44.952]                           else {
[10:22:44.952]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:44.952]                               info, version)
[10:22:44.952]                           }
[10:22:44.952]                           base::stop(msg)
[10:22:44.952]                         }
[10:22:44.952]                       })
[10:22:44.952]                     }
[10:22:44.952]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:44.952]                     base::options(mc.cores = 1L)
[10:22:44.952]                   }
[10:22:44.952]                   ...future.strategy.old <- future::plan("list")
[10:22:44.952]                   options(future.plan = NULL)
[10:22:44.952]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:44.952]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:44.952]                 }
[10:22:44.952]                 ...future.workdir <- getwd()
[10:22:44.952]             }
[10:22:44.952]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:44.952]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:44.952]         }
[10:22:44.952]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:44.952]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:44.952]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:44.952]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:44.952]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:44.952]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:44.952]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:44.952]             base::names(...future.oldOptions))
[10:22:44.952]     }
[10:22:44.952]     if (FALSE) {
[10:22:44.952]     }
[10:22:44.952]     else {
[10:22:44.952]         if (TRUE) {
[10:22:44.952]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:44.952]                 open = "w")
[10:22:44.952]         }
[10:22:44.952]         else {
[10:22:44.952]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:44.952]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:44.952]         }
[10:22:44.952]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:44.952]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:44.952]             base::sink(type = "output", split = FALSE)
[10:22:44.952]             base::close(...future.stdout)
[10:22:44.952]         }, add = TRUE)
[10:22:44.952]     }
[10:22:44.952]     ...future.frame <- base::sys.nframe()
[10:22:44.952]     ...future.conditions <- base::list()
[10:22:44.952]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:44.952]     if (FALSE) {
[10:22:44.952]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:44.952]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:44.952]     }
[10:22:44.952]     ...future.result <- base::tryCatch({
[10:22:44.952]         base::withCallingHandlers({
[10:22:44.952]             ...future.value <- base::withVisible(base::local({
[10:22:44.952]                 ...future.makeSendCondition <- base::local({
[10:22:44.952]                   sendCondition <- NULL
[10:22:44.952]                   function(frame = 1L) {
[10:22:44.952]                     if (is.function(sendCondition)) 
[10:22:44.952]                       return(sendCondition)
[10:22:44.952]                     ns <- getNamespace("parallel")
[10:22:44.952]                     if (exists("sendData", mode = "function", 
[10:22:44.952]                       envir = ns)) {
[10:22:44.952]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:44.952]                         envir = ns)
[10:22:44.952]                       envir <- sys.frame(frame)
[10:22:44.952]                       master <- NULL
[10:22:44.952]                       while (!identical(envir, .GlobalEnv) && 
[10:22:44.952]                         !identical(envir, emptyenv())) {
[10:22:44.952]                         if (exists("master", mode = "list", envir = envir, 
[10:22:44.952]                           inherits = FALSE)) {
[10:22:44.952]                           master <- get("master", mode = "list", 
[10:22:44.952]                             envir = envir, inherits = FALSE)
[10:22:44.952]                           if (inherits(master, c("SOCKnode", 
[10:22:44.952]                             "SOCK0node"))) {
[10:22:44.952]                             sendCondition <<- function(cond) {
[10:22:44.952]                               data <- list(type = "VALUE", value = cond, 
[10:22:44.952]                                 success = TRUE)
[10:22:44.952]                               parallel_sendData(master, data)
[10:22:44.952]                             }
[10:22:44.952]                             return(sendCondition)
[10:22:44.952]                           }
[10:22:44.952]                         }
[10:22:44.952]                         frame <- frame + 1L
[10:22:44.952]                         envir <- sys.frame(frame)
[10:22:44.952]                       }
[10:22:44.952]                     }
[10:22:44.952]                     sendCondition <<- function(cond) NULL
[10:22:44.952]                   }
[10:22:44.952]                 })
[10:22:44.952]                 withCallingHandlers({
[10:22:44.952]                   {
[10:22:44.952]                     Sys.sleep(0.5)
[10:22:44.952]                     list(a = 1, b = 42L)
[10:22:44.952]                   }
[10:22:44.952]                 }, immediateCondition = function(cond) {
[10:22:44.952]                   sendCondition <- ...future.makeSendCondition()
[10:22:44.952]                   sendCondition(cond)
[10:22:44.952]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.952]                   {
[10:22:44.952]                     inherits <- base::inherits
[10:22:44.952]                     invokeRestart <- base::invokeRestart
[10:22:44.952]                     is.null <- base::is.null
[10:22:44.952]                     muffled <- FALSE
[10:22:44.952]                     if (inherits(cond, "message")) {
[10:22:44.952]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:44.952]                       if (muffled) 
[10:22:44.952]                         invokeRestart("muffleMessage")
[10:22:44.952]                     }
[10:22:44.952]                     else if (inherits(cond, "warning")) {
[10:22:44.952]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:44.952]                       if (muffled) 
[10:22:44.952]                         invokeRestart("muffleWarning")
[10:22:44.952]                     }
[10:22:44.952]                     else if (inherits(cond, "condition")) {
[10:22:44.952]                       if (!is.null(pattern)) {
[10:22:44.952]                         computeRestarts <- base::computeRestarts
[10:22:44.952]                         grepl <- base::grepl
[10:22:44.952]                         restarts <- computeRestarts(cond)
[10:22:44.952]                         for (restart in restarts) {
[10:22:44.952]                           name <- restart$name
[10:22:44.952]                           if (is.null(name)) 
[10:22:44.952]                             next
[10:22:44.952]                           if (!grepl(pattern, name)) 
[10:22:44.952]                             next
[10:22:44.952]                           invokeRestart(restart)
[10:22:44.952]                           muffled <- TRUE
[10:22:44.952]                           break
[10:22:44.952]                         }
[10:22:44.952]                       }
[10:22:44.952]                     }
[10:22:44.952]                     invisible(muffled)
[10:22:44.952]                   }
[10:22:44.952]                   muffleCondition(cond)
[10:22:44.952]                 })
[10:22:44.952]             }))
[10:22:44.952]             future::FutureResult(value = ...future.value$value, 
[10:22:44.952]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:44.952]                   ...future.rng), globalenv = if (FALSE) 
[10:22:44.952]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:44.952]                     ...future.globalenv.names))
[10:22:44.952]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:44.952]         }, condition = base::local({
[10:22:44.952]             c <- base::c
[10:22:44.952]             inherits <- base::inherits
[10:22:44.952]             invokeRestart <- base::invokeRestart
[10:22:44.952]             length <- base::length
[10:22:44.952]             list <- base::list
[10:22:44.952]             seq.int <- base::seq.int
[10:22:44.952]             signalCondition <- base::signalCondition
[10:22:44.952]             sys.calls <- base::sys.calls
[10:22:44.952]             `[[` <- base::`[[`
[10:22:44.952]             `+` <- base::`+`
[10:22:44.952]             `<<-` <- base::`<<-`
[10:22:44.952]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:44.952]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:44.952]                   3L)]
[10:22:44.952]             }
[10:22:44.952]             function(cond) {
[10:22:44.952]                 is_error <- inherits(cond, "error")
[10:22:44.952]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:44.952]                   NULL)
[10:22:44.952]                 if (is_error) {
[10:22:44.952]                   sessionInformation <- function() {
[10:22:44.952]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:44.952]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:44.952]                       search = base::search(), system = base::Sys.info())
[10:22:44.952]                   }
[10:22:44.952]                   ...future.conditions[[length(...future.conditions) + 
[10:22:44.952]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:44.952]                     cond$call), session = sessionInformation(), 
[10:22:44.952]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:44.952]                   signalCondition(cond)
[10:22:44.952]                 }
[10:22:44.952]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:44.952]                 "immediateCondition"))) {
[10:22:44.952]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:44.952]                   ...future.conditions[[length(...future.conditions) + 
[10:22:44.952]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:44.952]                   if (TRUE && !signal) {
[10:22:44.952]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.952]                     {
[10:22:44.952]                       inherits <- base::inherits
[10:22:44.952]                       invokeRestart <- base::invokeRestart
[10:22:44.952]                       is.null <- base::is.null
[10:22:44.952]                       muffled <- FALSE
[10:22:44.952]                       if (inherits(cond, "message")) {
[10:22:44.952]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:44.952]                         if (muffled) 
[10:22:44.952]                           invokeRestart("muffleMessage")
[10:22:44.952]                       }
[10:22:44.952]                       else if (inherits(cond, "warning")) {
[10:22:44.952]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:44.952]                         if (muffled) 
[10:22:44.952]                           invokeRestart("muffleWarning")
[10:22:44.952]                       }
[10:22:44.952]                       else if (inherits(cond, "condition")) {
[10:22:44.952]                         if (!is.null(pattern)) {
[10:22:44.952]                           computeRestarts <- base::computeRestarts
[10:22:44.952]                           grepl <- base::grepl
[10:22:44.952]                           restarts <- computeRestarts(cond)
[10:22:44.952]                           for (restart in restarts) {
[10:22:44.952]                             name <- restart$name
[10:22:44.952]                             if (is.null(name)) 
[10:22:44.952]                               next
[10:22:44.952]                             if (!grepl(pattern, name)) 
[10:22:44.952]                               next
[10:22:44.952]                             invokeRestart(restart)
[10:22:44.952]                             muffled <- TRUE
[10:22:44.952]                             break
[10:22:44.952]                           }
[10:22:44.952]                         }
[10:22:44.952]                       }
[10:22:44.952]                       invisible(muffled)
[10:22:44.952]                     }
[10:22:44.952]                     muffleCondition(cond, pattern = "^muffle")
[10:22:44.952]                   }
[10:22:44.952]                 }
[10:22:44.952]                 else {
[10:22:44.952]                   if (TRUE) {
[10:22:44.952]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:44.952]                     {
[10:22:44.952]                       inherits <- base::inherits
[10:22:44.952]                       invokeRestart <- base::invokeRestart
[10:22:44.952]                       is.null <- base::is.null
[10:22:44.952]                       muffled <- FALSE
[10:22:44.952]                       if (inherits(cond, "message")) {
[10:22:44.952]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:44.952]                         if (muffled) 
[10:22:44.952]                           invokeRestart("muffleMessage")
[10:22:44.952]                       }
[10:22:44.952]                       else if (inherits(cond, "warning")) {
[10:22:44.952]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:44.952]                         if (muffled) 
[10:22:44.952]                           invokeRestart("muffleWarning")
[10:22:44.952]                       }
[10:22:44.952]                       else if (inherits(cond, "condition")) {
[10:22:44.952]                         if (!is.null(pattern)) {
[10:22:44.952]                           computeRestarts <- base::computeRestarts
[10:22:44.952]                           grepl <- base::grepl
[10:22:44.952]                           restarts <- computeRestarts(cond)
[10:22:44.952]                           for (restart in restarts) {
[10:22:44.952]                             name <- restart$name
[10:22:44.952]                             if (is.null(name)) 
[10:22:44.952]                               next
[10:22:44.952]                             if (!grepl(pattern, name)) 
[10:22:44.952]                               next
[10:22:44.952]                             invokeRestart(restart)
[10:22:44.952]                             muffled <- TRUE
[10:22:44.952]                             break
[10:22:44.952]                           }
[10:22:44.952]                         }
[10:22:44.952]                       }
[10:22:44.952]                       invisible(muffled)
[10:22:44.952]                     }
[10:22:44.952]                     muffleCondition(cond, pattern = "^muffle")
[10:22:44.952]                   }
[10:22:44.952]                 }
[10:22:44.952]             }
[10:22:44.952]         }))
[10:22:44.952]     }, error = function(ex) {
[10:22:44.952]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:44.952]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:44.952]                 ...future.rng), started = ...future.startTime, 
[10:22:44.952]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:44.952]             version = "1.8"), class = "FutureResult")
[10:22:44.952]     }, finally = {
[10:22:44.952]         if (!identical(...future.workdir, getwd())) 
[10:22:44.952]             setwd(...future.workdir)
[10:22:44.952]         {
[10:22:44.952]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:44.952]                 ...future.oldOptions$nwarnings <- NULL
[10:22:44.952]             }
[10:22:44.952]             base::options(...future.oldOptions)
[10:22:44.952]             if (.Platform$OS.type == "windows") {
[10:22:44.952]                 old_names <- names(...future.oldEnvVars)
[10:22:44.952]                 envs <- base::Sys.getenv()
[10:22:44.952]                 names <- names(envs)
[10:22:44.952]                 common <- intersect(names, old_names)
[10:22:44.952]                 added <- setdiff(names, old_names)
[10:22:44.952]                 removed <- setdiff(old_names, names)
[10:22:44.952]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:44.952]                   envs[common]]
[10:22:44.952]                 NAMES <- toupper(changed)
[10:22:44.952]                 args <- list()
[10:22:44.952]                 for (kk in seq_along(NAMES)) {
[10:22:44.952]                   name <- changed[[kk]]
[10:22:44.952]                   NAME <- NAMES[[kk]]
[10:22:44.952]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.952]                     next
[10:22:44.952]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:44.952]                 }
[10:22:44.952]                 NAMES <- toupper(added)
[10:22:44.952]                 for (kk in seq_along(NAMES)) {
[10:22:44.952]                   name <- added[[kk]]
[10:22:44.952]                   NAME <- NAMES[[kk]]
[10:22:44.952]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.952]                     next
[10:22:44.952]                   args[[name]] <- ""
[10:22:44.952]                 }
[10:22:44.952]                 NAMES <- toupper(removed)
[10:22:44.952]                 for (kk in seq_along(NAMES)) {
[10:22:44.952]                   name <- removed[[kk]]
[10:22:44.952]                   NAME <- NAMES[[kk]]
[10:22:44.952]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:44.952]                     next
[10:22:44.952]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:44.952]                 }
[10:22:44.952]                 if (length(args) > 0) 
[10:22:44.952]                   base::do.call(base::Sys.setenv, args = args)
[10:22:44.952]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:44.952]             }
[10:22:44.952]             else {
[10:22:44.952]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:44.952]             }
[10:22:44.952]             {
[10:22:44.952]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:44.952]                   0L) {
[10:22:44.952]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:44.952]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:44.952]                   base::options(opts)
[10:22:44.952]                 }
[10:22:44.952]                 {
[10:22:44.952]                   {
[10:22:44.952]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:44.952]                     NULL
[10:22:44.952]                   }
[10:22:44.952]                   options(future.plan = NULL)
[10:22:44.952]                   if (is.na(NA_character_)) 
[10:22:44.952]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:44.952]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:44.952]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:44.952]                     .init = FALSE)
[10:22:44.952]                 }
[10:22:44.952]             }
[10:22:44.952]         }
[10:22:44.952]     })
[10:22:44.952]     if (TRUE) {
[10:22:44.952]         base::sink(type = "output", split = FALSE)
[10:22:44.952]         if (TRUE) {
[10:22:44.952]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:44.952]         }
[10:22:44.952]         else {
[10:22:44.952]             ...future.result["stdout"] <- base::list(NULL)
[10:22:44.952]         }
[10:22:44.952]         base::close(...future.stdout)
[10:22:44.952]         ...future.stdout <- NULL
[10:22:44.952]     }
[10:22:44.952]     ...future.result$conditions <- ...future.conditions
[10:22:44.952]     ...future.result$finished <- base::Sys.time()
[10:22:44.952]     ...future.result
[10:22:44.952] }
[10:22:44.955] MultisessionFuture started
[10:22:44.955] - Launch lazy future ... done
[10:22:44.955] run() for ‘MultisessionFuture’ ... done
[10:22:45.498] receiveMessageFromWorker() for ClusterFuture ...
[10:22:45.498] - Validating connection of MultisessionFuture
[10:22:45.498] - received message: FutureResult
[10:22:45.499] - Received FutureResult
[10:22:45.499] - Erased future from FutureRegistry
[10:22:45.499] result() for ClusterFuture ...
[10:22:45.499] - result already collected: FutureResult
[10:22:45.499] result() for ClusterFuture ... done
[10:22:45.499] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:45.499] resolve() on list ...
[10:22:45.499]  recursive: 0
[10:22:45.499]  length: 2
[10:22:45.499]  elements: ‘a’, ‘b’
[10:22:45.500]  length: 1 (resolved future 1)
[10:22:45.500]  length: 0 (resolved future 2)
[10:22:45.500] resolve() on list ... DONE
[10:22:45.500] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[10:22:45.500] getGlobalsAndPackages() ...
[10:22:45.500] Searching for globals...
[10:22:45.501] - globals found: [2] ‘list’, ‘stop’
[10:22:45.501] Searching for globals ... DONE
[10:22:45.501] Resolving globals: FALSE
[10:22:45.501] 
[10:22:45.501] 
[10:22:45.502] getGlobalsAndPackages() ... DONE
[10:22:45.502] run() for ‘Future’ ...
[10:22:45.502] - state: ‘created’
[10:22:45.502] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:45.516] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:45.516] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:45.516]   - Field: ‘node’
[10:22:45.516]   - Field: ‘label’
[10:22:45.516]   - Field: ‘local’
[10:22:45.516]   - Field: ‘owner’
[10:22:45.516]   - Field: ‘envir’
[10:22:45.516]   - Field: ‘workers’
[10:22:45.517]   - Field: ‘packages’
[10:22:45.517]   - Field: ‘gc’
[10:22:45.517]   - Field: ‘conditions’
[10:22:45.517]   - Field: ‘persistent’
[10:22:45.517]   - Field: ‘expr’
[10:22:45.517]   - Field: ‘uuid’
[10:22:45.517]   - Field: ‘seed’
[10:22:45.517]   - Field: ‘version’
[10:22:45.517]   - Field: ‘result’
[10:22:45.517]   - Field: ‘asynchronous’
[10:22:45.517]   - Field: ‘calls’
[10:22:45.517]   - Field: ‘globals’
[10:22:45.518]   - Field: ‘stdout’
[10:22:45.518]   - Field: ‘earlySignal’
[10:22:45.518]   - Field: ‘lazy’
[10:22:45.518]   - Field: ‘state’
[10:22:45.518] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:45.518] - Launch lazy future ...
[10:22:45.518] Packages needed by the future expression (n = 0): <none>
[10:22:45.518] Packages needed by future strategies (n = 0): <none>
[10:22:45.519] {
[10:22:45.519]     {
[10:22:45.519]         {
[10:22:45.519]             ...future.startTime <- base::Sys.time()
[10:22:45.519]             {
[10:22:45.519]                 {
[10:22:45.519]                   {
[10:22:45.519]                     {
[10:22:45.519]                       base::local({
[10:22:45.519]                         has_future <- base::requireNamespace("future", 
[10:22:45.519]                           quietly = TRUE)
[10:22:45.519]                         if (has_future) {
[10:22:45.519]                           ns <- base::getNamespace("future")
[10:22:45.519]                           version <- ns[[".package"]][["version"]]
[10:22:45.519]                           if (is.null(version)) 
[10:22:45.519]                             version <- utils::packageVersion("future")
[10:22:45.519]                         }
[10:22:45.519]                         else {
[10:22:45.519]                           version <- NULL
[10:22:45.519]                         }
[10:22:45.519]                         if (!has_future || version < "1.8.0") {
[10:22:45.519]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:45.519]                             "", base::R.version$version.string), 
[10:22:45.519]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:45.519]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:45.519]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:45.519]                               "release", "version")], collapse = " "), 
[10:22:45.519]                             hostname = base::Sys.info()[["nodename"]])
[10:22:45.519]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:45.519]                             info)
[10:22:45.519]                           info <- base::paste(info, collapse = "; ")
[10:22:45.519]                           if (!has_future) {
[10:22:45.519]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:45.519]                               info)
[10:22:45.519]                           }
[10:22:45.519]                           else {
[10:22:45.519]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:45.519]                               info, version)
[10:22:45.519]                           }
[10:22:45.519]                           base::stop(msg)
[10:22:45.519]                         }
[10:22:45.519]                       })
[10:22:45.519]                     }
[10:22:45.519]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:45.519]                     base::options(mc.cores = 1L)
[10:22:45.519]                   }
[10:22:45.519]                   ...future.strategy.old <- future::plan("list")
[10:22:45.519]                   options(future.plan = NULL)
[10:22:45.519]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:45.519]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:45.519]                 }
[10:22:45.519]                 ...future.workdir <- getwd()
[10:22:45.519]             }
[10:22:45.519]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:45.519]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:45.519]         }
[10:22:45.519]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:45.519]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:45.519]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:45.519]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:45.519]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:45.519]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:45.519]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:45.519]             base::names(...future.oldOptions))
[10:22:45.519]     }
[10:22:45.519]     if (FALSE) {
[10:22:45.519]     }
[10:22:45.519]     else {
[10:22:45.519]         if (TRUE) {
[10:22:45.519]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:45.519]                 open = "w")
[10:22:45.519]         }
[10:22:45.519]         else {
[10:22:45.519]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:45.519]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:45.519]         }
[10:22:45.519]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:45.519]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:45.519]             base::sink(type = "output", split = FALSE)
[10:22:45.519]             base::close(...future.stdout)
[10:22:45.519]         }, add = TRUE)
[10:22:45.519]     }
[10:22:45.519]     ...future.frame <- base::sys.nframe()
[10:22:45.519]     ...future.conditions <- base::list()
[10:22:45.519]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:45.519]     if (FALSE) {
[10:22:45.519]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:45.519]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:45.519]     }
[10:22:45.519]     ...future.result <- base::tryCatch({
[10:22:45.519]         base::withCallingHandlers({
[10:22:45.519]             ...future.value <- base::withVisible(base::local({
[10:22:45.519]                 ...future.makeSendCondition <- base::local({
[10:22:45.519]                   sendCondition <- NULL
[10:22:45.519]                   function(frame = 1L) {
[10:22:45.519]                     if (is.function(sendCondition)) 
[10:22:45.519]                       return(sendCondition)
[10:22:45.519]                     ns <- getNamespace("parallel")
[10:22:45.519]                     if (exists("sendData", mode = "function", 
[10:22:45.519]                       envir = ns)) {
[10:22:45.519]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:45.519]                         envir = ns)
[10:22:45.519]                       envir <- sys.frame(frame)
[10:22:45.519]                       master <- NULL
[10:22:45.519]                       while (!identical(envir, .GlobalEnv) && 
[10:22:45.519]                         !identical(envir, emptyenv())) {
[10:22:45.519]                         if (exists("master", mode = "list", envir = envir, 
[10:22:45.519]                           inherits = FALSE)) {
[10:22:45.519]                           master <- get("master", mode = "list", 
[10:22:45.519]                             envir = envir, inherits = FALSE)
[10:22:45.519]                           if (inherits(master, c("SOCKnode", 
[10:22:45.519]                             "SOCK0node"))) {
[10:22:45.519]                             sendCondition <<- function(cond) {
[10:22:45.519]                               data <- list(type = "VALUE", value = cond, 
[10:22:45.519]                                 success = TRUE)
[10:22:45.519]                               parallel_sendData(master, data)
[10:22:45.519]                             }
[10:22:45.519]                             return(sendCondition)
[10:22:45.519]                           }
[10:22:45.519]                         }
[10:22:45.519]                         frame <- frame + 1L
[10:22:45.519]                         envir <- sys.frame(frame)
[10:22:45.519]                       }
[10:22:45.519]                     }
[10:22:45.519]                     sendCondition <<- function(cond) NULL
[10:22:45.519]                   }
[10:22:45.519]                 })
[10:22:45.519]                 withCallingHandlers({
[10:22:45.519]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:22:45.519]                 }, immediateCondition = function(cond) {
[10:22:45.519]                   sendCondition <- ...future.makeSendCondition()
[10:22:45.519]                   sendCondition(cond)
[10:22:45.519]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:45.519]                   {
[10:22:45.519]                     inherits <- base::inherits
[10:22:45.519]                     invokeRestart <- base::invokeRestart
[10:22:45.519]                     is.null <- base::is.null
[10:22:45.519]                     muffled <- FALSE
[10:22:45.519]                     if (inherits(cond, "message")) {
[10:22:45.519]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:45.519]                       if (muffled) 
[10:22:45.519]                         invokeRestart("muffleMessage")
[10:22:45.519]                     }
[10:22:45.519]                     else if (inherits(cond, "warning")) {
[10:22:45.519]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:45.519]                       if (muffled) 
[10:22:45.519]                         invokeRestart("muffleWarning")
[10:22:45.519]                     }
[10:22:45.519]                     else if (inherits(cond, "condition")) {
[10:22:45.519]                       if (!is.null(pattern)) {
[10:22:45.519]                         computeRestarts <- base::computeRestarts
[10:22:45.519]                         grepl <- base::grepl
[10:22:45.519]                         restarts <- computeRestarts(cond)
[10:22:45.519]                         for (restart in restarts) {
[10:22:45.519]                           name <- restart$name
[10:22:45.519]                           if (is.null(name)) 
[10:22:45.519]                             next
[10:22:45.519]                           if (!grepl(pattern, name)) 
[10:22:45.519]                             next
[10:22:45.519]                           invokeRestart(restart)
[10:22:45.519]                           muffled <- TRUE
[10:22:45.519]                           break
[10:22:45.519]                         }
[10:22:45.519]                       }
[10:22:45.519]                     }
[10:22:45.519]                     invisible(muffled)
[10:22:45.519]                   }
[10:22:45.519]                   muffleCondition(cond)
[10:22:45.519]                 })
[10:22:45.519]             }))
[10:22:45.519]             future::FutureResult(value = ...future.value$value, 
[10:22:45.519]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:45.519]                   ...future.rng), globalenv = if (FALSE) 
[10:22:45.519]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:45.519]                     ...future.globalenv.names))
[10:22:45.519]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:45.519]         }, condition = base::local({
[10:22:45.519]             c <- base::c
[10:22:45.519]             inherits <- base::inherits
[10:22:45.519]             invokeRestart <- base::invokeRestart
[10:22:45.519]             length <- base::length
[10:22:45.519]             list <- base::list
[10:22:45.519]             seq.int <- base::seq.int
[10:22:45.519]             signalCondition <- base::signalCondition
[10:22:45.519]             sys.calls <- base::sys.calls
[10:22:45.519]             `[[` <- base::`[[`
[10:22:45.519]             `+` <- base::`+`
[10:22:45.519]             `<<-` <- base::`<<-`
[10:22:45.519]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:45.519]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:45.519]                   3L)]
[10:22:45.519]             }
[10:22:45.519]             function(cond) {
[10:22:45.519]                 is_error <- inherits(cond, "error")
[10:22:45.519]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:45.519]                   NULL)
[10:22:45.519]                 if (is_error) {
[10:22:45.519]                   sessionInformation <- function() {
[10:22:45.519]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:45.519]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:45.519]                       search = base::search(), system = base::Sys.info())
[10:22:45.519]                   }
[10:22:45.519]                   ...future.conditions[[length(...future.conditions) + 
[10:22:45.519]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:45.519]                     cond$call), session = sessionInformation(), 
[10:22:45.519]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:45.519]                   signalCondition(cond)
[10:22:45.519]                 }
[10:22:45.519]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:45.519]                 "immediateCondition"))) {
[10:22:45.519]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:45.519]                   ...future.conditions[[length(...future.conditions) + 
[10:22:45.519]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:45.519]                   if (TRUE && !signal) {
[10:22:45.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:45.519]                     {
[10:22:45.519]                       inherits <- base::inherits
[10:22:45.519]                       invokeRestart <- base::invokeRestart
[10:22:45.519]                       is.null <- base::is.null
[10:22:45.519]                       muffled <- FALSE
[10:22:45.519]                       if (inherits(cond, "message")) {
[10:22:45.519]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:45.519]                         if (muffled) 
[10:22:45.519]                           invokeRestart("muffleMessage")
[10:22:45.519]                       }
[10:22:45.519]                       else if (inherits(cond, "warning")) {
[10:22:45.519]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:45.519]                         if (muffled) 
[10:22:45.519]                           invokeRestart("muffleWarning")
[10:22:45.519]                       }
[10:22:45.519]                       else if (inherits(cond, "condition")) {
[10:22:45.519]                         if (!is.null(pattern)) {
[10:22:45.519]                           computeRestarts <- base::computeRestarts
[10:22:45.519]                           grepl <- base::grepl
[10:22:45.519]                           restarts <- computeRestarts(cond)
[10:22:45.519]                           for (restart in restarts) {
[10:22:45.519]                             name <- restart$name
[10:22:45.519]                             if (is.null(name)) 
[10:22:45.519]                               next
[10:22:45.519]                             if (!grepl(pattern, name)) 
[10:22:45.519]                               next
[10:22:45.519]                             invokeRestart(restart)
[10:22:45.519]                             muffled <- TRUE
[10:22:45.519]                             break
[10:22:45.519]                           }
[10:22:45.519]                         }
[10:22:45.519]                       }
[10:22:45.519]                       invisible(muffled)
[10:22:45.519]                     }
[10:22:45.519]                     muffleCondition(cond, pattern = "^muffle")
[10:22:45.519]                   }
[10:22:45.519]                 }
[10:22:45.519]                 else {
[10:22:45.519]                   if (TRUE) {
[10:22:45.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:45.519]                     {
[10:22:45.519]                       inherits <- base::inherits
[10:22:45.519]                       invokeRestart <- base::invokeRestart
[10:22:45.519]                       is.null <- base::is.null
[10:22:45.519]                       muffled <- FALSE
[10:22:45.519]                       if (inherits(cond, "message")) {
[10:22:45.519]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:45.519]                         if (muffled) 
[10:22:45.519]                           invokeRestart("muffleMessage")
[10:22:45.519]                       }
[10:22:45.519]                       else if (inherits(cond, "warning")) {
[10:22:45.519]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:45.519]                         if (muffled) 
[10:22:45.519]                           invokeRestart("muffleWarning")
[10:22:45.519]                       }
[10:22:45.519]                       else if (inherits(cond, "condition")) {
[10:22:45.519]                         if (!is.null(pattern)) {
[10:22:45.519]                           computeRestarts <- base::computeRestarts
[10:22:45.519]                           grepl <- base::grepl
[10:22:45.519]                           restarts <- computeRestarts(cond)
[10:22:45.519]                           for (restart in restarts) {
[10:22:45.519]                             name <- restart$name
[10:22:45.519]                             if (is.null(name)) 
[10:22:45.519]                               next
[10:22:45.519]                             if (!grepl(pattern, name)) 
[10:22:45.519]                               next
[10:22:45.519]                             invokeRestart(restart)
[10:22:45.519]                             muffled <- TRUE
[10:22:45.519]                             break
[10:22:45.519]                           }
[10:22:45.519]                         }
[10:22:45.519]                       }
[10:22:45.519]                       invisible(muffled)
[10:22:45.519]                     }
[10:22:45.519]                     muffleCondition(cond, pattern = "^muffle")
[10:22:45.519]                   }
[10:22:45.519]                 }
[10:22:45.519]             }
[10:22:45.519]         }))
[10:22:45.519]     }, error = function(ex) {
[10:22:45.519]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:45.519]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:45.519]                 ...future.rng), started = ...future.startTime, 
[10:22:45.519]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:45.519]             version = "1.8"), class = "FutureResult")
[10:22:45.519]     }, finally = {
[10:22:45.519]         if (!identical(...future.workdir, getwd())) 
[10:22:45.519]             setwd(...future.workdir)
[10:22:45.519]         {
[10:22:45.519]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:45.519]                 ...future.oldOptions$nwarnings <- NULL
[10:22:45.519]             }
[10:22:45.519]             base::options(...future.oldOptions)
[10:22:45.519]             if (.Platform$OS.type == "windows") {
[10:22:45.519]                 old_names <- names(...future.oldEnvVars)
[10:22:45.519]                 envs <- base::Sys.getenv()
[10:22:45.519]                 names <- names(envs)
[10:22:45.519]                 common <- intersect(names, old_names)
[10:22:45.519]                 added <- setdiff(names, old_names)
[10:22:45.519]                 removed <- setdiff(old_names, names)
[10:22:45.519]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:45.519]                   envs[common]]
[10:22:45.519]                 NAMES <- toupper(changed)
[10:22:45.519]                 args <- list()
[10:22:45.519]                 for (kk in seq_along(NAMES)) {
[10:22:45.519]                   name <- changed[[kk]]
[10:22:45.519]                   NAME <- NAMES[[kk]]
[10:22:45.519]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:45.519]                     next
[10:22:45.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:45.519]                 }
[10:22:45.519]                 NAMES <- toupper(added)
[10:22:45.519]                 for (kk in seq_along(NAMES)) {
[10:22:45.519]                   name <- added[[kk]]
[10:22:45.519]                   NAME <- NAMES[[kk]]
[10:22:45.519]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:45.519]                     next
[10:22:45.519]                   args[[name]] <- ""
[10:22:45.519]                 }
[10:22:45.519]                 NAMES <- toupper(removed)
[10:22:45.519]                 for (kk in seq_along(NAMES)) {
[10:22:45.519]                   name <- removed[[kk]]
[10:22:45.519]                   NAME <- NAMES[[kk]]
[10:22:45.519]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:45.519]                     next
[10:22:45.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:45.519]                 }
[10:22:45.519]                 if (length(args) > 0) 
[10:22:45.519]                   base::do.call(base::Sys.setenv, args = args)
[10:22:45.519]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:45.519]             }
[10:22:45.519]             else {
[10:22:45.519]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:45.519]             }
[10:22:45.519]             {
[10:22:45.519]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:45.519]                   0L) {
[10:22:45.519]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:45.519]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:45.519]                   base::options(opts)
[10:22:45.519]                 }
[10:22:45.519]                 {
[10:22:45.519]                   {
[10:22:45.519]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:45.519]                     NULL
[10:22:45.519]                   }
[10:22:45.519]                   options(future.plan = NULL)
[10:22:45.519]                   if (is.na(NA_character_)) 
[10:22:45.519]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:45.519]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:45.519]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:45.519]                     .init = FALSE)
[10:22:45.519]                 }
[10:22:45.519]             }
[10:22:45.519]         }
[10:22:45.519]     })
[10:22:45.519]     if (TRUE) {
[10:22:45.519]         base::sink(type = "output", split = FALSE)
[10:22:45.519]         if (TRUE) {
[10:22:45.519]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:45.519]         }
[10:22:45.519]         else {
[10:22:45.519]             ...future.result["stdout"] <- base::list(NULL)
[10:22:45.519]         }
[10:22:45.519]         base::close(...future.stdout)
[10:22:45.519]         ...future.stdout <- NULL
[10:22:45.519]     }
[10:22:45.519]     ...future.result$conditions <- ...future.conditions
[10:22:45.519]     ...future.result$finished <- base::Sys.time()
[10:22:45.519]     ...future.result
[10:22:45.519] }
[10:22:45.522] MultisessionFuture started
[10:22:45.522] - Launch lazy future ... done
[10:22:45.522] run() for ‘MultisessionFuture’ ... done
[10:22:45.564] receiveMessageFromWorker() for ClusterFuture ...
[10:22:45.565] - Validating connection of MultisessionFuture
[10:22:45.565] - received message: FutureResult
[10:22:45.565] - Received FutureResult
[10:22:45.565] - Erased future from FutureRegistry
[10:22:45.565] result() for ClusterFuture ...
[10:22:45.566] - result already collected: FutureResult
[10:22:45.566] result() for ClusterFuture ... done
[10:22:45.566] signalConditions() ...
[10:22:45.566]  - include = ‘immediateCondition’
[10:22:45.566]  - exclude = 
[10:22:45.566]  - resignal = FALSE
[10:22:45.566]  - Number of conditions: 1
[10:22:45.566] signalConditions() ... done
[10:22:45.566] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:45.566] A MultisessionFuture was resolved (and resolved itself)
[10:22:45.566] getGlobalsAndPackages() ...
[10:22:45.566] Searching for globals...
[10:22:45.567] - globals found: [2] ‘list’, ‘stop’
[10:22:45.567] Searching for globals ... DONE
[10:22:45.567] Resolving globals: FALSE
[10:22:45.568] 
[10:22:45.568] 
[10:22:45.568] getGlobalsAndPackages() ... DONE
[10:22:45.568] run() for ‘Future’ ...
[10:22:45.568] - state: ‘created’
[10:22:45.568] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:45.582] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:45.582] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:45.582]   - Field: ‘node’
[10:22:45.582]   - Field: ‘label’
[10:22:45.582]   - Field: ‘local’
[10:22:45.582]   - Field: ‘owner’
[10:22:45.583]   - Field: ‘envir’
[10:22:45.583]   - Field: ‘workers’
[10:22:45.583]   - Field: ‘packages’
[10:22:45.583]   - Field: ‘gc’
[10:22:45.583]   - Field: ‘conditions’
[10:22:45.583]   - Field: ‘persistent’
[10:22:45.583]   - Field: ‘expr’
[10:22:45.584]   - Field: ‘uuid’
[10:22:45.584]   - Field: ‘seed’
[10:22:45.584]   - Field: ‘version’
[10:22:45.584]   - Field: ‘result’
[10:22:45.584]   - Field: ‘asynchronous’
[10:22:45.584]   - Field: ‘calls’
[10:22:45.584]   - Field: ‘globals’
[10:22:45.585]   - Field: ‘stdout’
[10:22:45.585]   - Field: ‘earlySignal’
[10:22:45.585]   - Field: ‘lazy’
[10:22:45.585]   - Field: ‘state’
[10:22:45.585] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:45.585] - Launch lazy future ...
[10:22:45.585] Packages needed by the future expression (n = 0): <none>
[10:22:45.586] Packages needed by future strategies (n = 0): <none>
[10:22:45.586] {
[10:22:45.586]     {
[10:22:45.586]         {
[10:22:45.586]             ...future.startTime <- base::Sys.time()
[10:22:45.586]             {
[10:22:45.586]                 {
[10:22:45.586]                   {
[10:22:45.586]                     {
[10:22:45.586]                       base::local({
[10:22:45.586]                         has_future <- base::requireNamespace("future", 
[10:22:45.586]                           quietly = TRUE)
[10:22:45.586]                         if (has_future) {
[10:22:45.586]                           ns <- base::getNamespace("future")
[10:22:45.586]                           version <- ns[[".package"]][["version"]]
[10:22:45.586]                           if (is.null(version)) 
[10:22:45.586]                             version <- utils::packageVersion("future")
[10:22:45.586]                         }
[10:22:45.586]                         else {
[10:22:45.586]                           version <- NULL
[10:22:45.586]                         }
[10:22:45.586]                         if (!has_future || version < "1.8.0") {
[10:22:45.586]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:45.586]                             "", base::R.version$version.string), 
[10:22:45.586]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:45.586]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:45.586]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:45.586]                               "release", "version")], collapse = " "), 
[10:22:45.586]                             hostname = base::Sys.info()[["nodename"]])
[10:22:45.586]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:45.586]                             info)
[10:22:45.586]                           info <- base::paste(info, collapse = "; ")
[10:22:45.586]                           if (!has_future) {
[10:22:45.586]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:45.586]                               info)
[10:22:45.586]                           }
[10:22:45.586]                           else {
[10:22:45.586]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:45.586]                               info, version)
[10:22:45.586]                           }
[10:22:45.586]                           base::stop(msg)
[10:22:45.586]                         }
[10:22:45.586]                       })
[10:22:45.586]                     }
[10:22:45.586]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:45.586]                     base::options(mc.cores = 1L)
[10:22:45.586]                   }
[10:22:45.586]                   ...future.strategy.old <- future::plan("list")
[10:22:45.586]                   options(future.plan = NULL)
[10:22:45.586]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:45.586]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:45.586]                 }
[10:22:45.586]                 ...future.workdir <- getwd()
[10:22:45.586]             }
[10:22:45.586]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:45.586]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:45.586]         }
[10:22:45.586]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:45.586]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:45.586]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:45.586]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:45.586]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:45.586]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:45.586]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:45.586]             base::names(...future.oldOptions))
[10:22:45.586]     }
[10:22:45.586]     if (FALSE) {
[10:22:45.586]     }
[10:22:45.586]     else {
[10:22:45.586]         if (TRUE) {
[10:22:45.586]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:45.586]                 open = "w")
[10:22:45.586]         }
[10:22:45.586]         else {
[10:22:45.586]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:45.586]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:45.586]         }
[10:22:45.586]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:45.586]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:45.586]             base::sink(type = "output", split = FALSE)
[10:22:45.586]             base::close(...future.stdout)
[10:22:45.586]         }, add = TRUE)
[10:22:45.586]     }
[10:22:45.586]     ...future.frame <- base::sys.nframe()
[10:22:45.586]     ...future.conditions <- base::list()
[10:22:45.586]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:45.586]     if (FALSE) {
[10:22:45.586]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:45.586]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:45.586]     }
[10:22:45.586]     ...future.result <- base::tryCatch({
[10:22:45.586]         base::withCallingHandlers({
[10:22:45.586]             ...future.value <- base::withVisible(base::local({
[10:22:45.586]                 ...future.makeSendCondition <- base::local({
[10:22:45.586]                   sendCondition <- NULL
[10:22:45.586]                   function(frame = 1L) {
[10:22:45.586]                     if (is.function(sendCondition)) 
[10:22:45.586]                       return(sendCondition)
[10:22:45.586]                     ns <- getNamespace("parallel")
[10:22:45.586]                     if (exists("sendData", mode = "function", 
[10:22:45.586]                       envir = ns)) {
[10:22:45.586]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:45.586]                         envir = ns)
[10:22:45.586]                       envir <- sys.frame(frame)
[10:22:45.586]                       master <- NULL
[10:22:45.586]                       while (!identical(envir, .GlobalEnv) && 
[10:22:45.586]                         !identical(envir, emptyenv())) {
[10:22:45.586]                         if (exists("master", mode = "list", envir = envir, 
[10:22:45.586]                           inherits = FALSE)) {
[10:22:45.586]                           master <- get("master", mode = "list", 
[10:22:45.586]                             envir = envir, inherits = FALSE)
[10:22:45.586]                           if (inherits(master, c("SOCKnode", 
[10:22:45.586]                             "SOCK0node"))) {
[10:22:45.586]                             sendCondition <<- function(cond) {
[10:22:45.586]                               data <- list(type = "VALUE", value = cond, 
[10:22:45.586]                                 success = TRUE)
[10:22:45.586]                               parallel_sendData(master, data)
[10:22:45.586]                             }
[10:22:45.586]                             return(sendCondition)
[10:22:45.586]                           }
[10:22:45.586]                         }
[10:22:45.586]                         frame <- frame + 1L
[10:22:45.586]                         envir <- sys.frame(frame)
[10:22:45.586]                       }
[10:22:45.586]                     }
[10:22:45.586]                     sendCondition <<- function(cond) NULL
[10:22:45.586]                   }
[10:22:45.586]                 })
[10:22:45.586]                 withCallingHandlers({
[10:22:45.586]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:22:45.586]                 }, immediateCondition = function(cond) {
[10:22:45.586]                   sendCondition <- ...future.makeSendCondition()
[10:22:45.586]                   sendCondition(cond)
[10:22:45.586]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:45.586]                   {
[10:22:45.586]                     inherits <- base::inherits
[10:22:45.586]                     invokeRestart <- base::invokeRestart
[10:22:45.586]                     is.null <- base::is.null
[10:22:45.586]                     muffled <- FALSE
[10:22:45.586]                     if (inherits(cond, "message")) {
[10:22:45.586]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:45.586]                       if (muffled) 
[10:22:45.586]                         invokeRestart("muffleMessage")
[10:22:45.586]                     }
[10:22:45.586]                     else if (inherits(cond, "warning")) {
[10:22:45.586]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:45.586]                       if (muffled) 
[10:22:45.586]                         invokeRestart("muffleWarning")
[10:22:45.586]                     }
[10:22:45.586]                     else if (inherits(cond, "condition")) {
[10:22:45.586]                       if (!is.null(pattern)) {
[10:22:45.586]                         computeRestarts <- base::computeRestarts
[10:22:45.586]                         grepl <- base::grepl
[10:22:45.586]                         restarts <- computeRestarts(cond)
[10:22:45.586]                         for (restart in restarts) {
[10:22:45.586]                           name <- restart$name
[10:22:45.586]                           if (is.null(name)) 
[10:22:45.586]                             next
[10:22:45.586]                           if (!grepl(pattern, name)) 
[10:22:45.586]                             next
[10:22:45.586]                           invokeRestart(restart)
[10:22:45.586]                           muffled <- TRUE
[10:22:45.586]                           break
[10:22:45.586]                         }
[10:22:45.586]                       }
[10:22:45.586]                     }
[10:22:45.586]                     invisible(muffled)
[10:22:45.586]                   }
[10:22:45.586]                   muffleCondition(cond)
[10:22:45.586]                 })
[10:22:45.586]             }))
[10:22:45.586]             future::FutureResult(value = ...future.value$value, 
[10:22:45.586]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:45.586]                   ...future.rng), globalenv = if (FALSE) 
[10:22:45.586]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:45.586]                     ...future.globalenv.names))
[10:22:45.586]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:45.586]         }, condition = base::local({
[10:22:45.586]             c <- base::c
[10:22:45.586]             inherits <- base::inherits
[10:22:45.586]             invokeRestart <- base::invokeRestart
[10:22:45.586]             length <- base::length
[10:22:45.586]             list <- base::list
[10:22:45.586]             seq.int <- base::seq.int
[10:22:45.586]             signalCondition <- base::signalCondition
[10:22:45.586]             sys.calls <- base::sys.calls
[10:22:45.586]             `[[` <- base::`[[`
[10:22:45.586]             `+` <- base::`+`
[10:22:45.586]             `<<-` <- base::`<<-`
[10:22:45.586]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:45.586]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:45.586]                   3L)]
[10:22:45.586]             }
[10:22:45.586]             function(cond) {
[10:22:45.586]                 is_error <- inherits(cond, "error")
[10:22:45.586]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:45.586]                   NULL)
[10:22:45.586]                 if (is_error) {
[10:22:45.586]                   sessionInformation <- function() {
[10:22:45.586]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:45.586]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:45.586]                       search = base::search(), system = base::Sys.info())
[10:22:45.586]                   }
[10:22:45.586]                   ...future.conditions[[length(...future.conditions) + 
[10:22:45.586]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:45.586]                     cond$call), session = sessionInformation(), 
[10:22:45.586]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:45.586]                   signalCondition(cond)
[10:22:45.586]                 }
[10:22:45.586]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:45.586]                 "immediateCondition"))) {
[10:22:45.586]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:45.586]                   ...future.conditions[[length(...future.conditions) + 
[10:22:45.586]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:45.586]                   if (TRUE && !signal) {
[10:22:45.586]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:45.586]                     {
[10:22:45.586]                       inherits <- base::inherits
[10:22:45.586]                       invokeRestart <- base::invokeRestart
[10:22:45.586]                       is.null <- base::is.null
[10:22:45.586]                       muffled <- FALSE
[10:22:45.586]                       if (inherits(cond, "message")) {
[10:22:45.586]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:45.586]                         if (muffled) 
[10:22:45.586]                           invokeRestart("muffleMessage")
[10:22:45.586]                       }
[10:22:45.586]                       else if (inherits(cond, "warning")) {
[10:22:45.586]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:45.586]                         if (muffled) 
[10:22:45.586]                           invokeRestart("muffleWarning")
[10:22:45.586]                       }
[10:22:45.586]                       else if (inherits(cond, "condition")) {
[10:22:45.586]                         if (!is.null(pattern)) {
[10:22:45.586]                           computeRestarts <- base::computeRestarts
[10:22:45.586]                           grepl <- base::grepl
[10:22:45.586]                           restarts <- computeRestarts(cond)
[10:22:45.586]                           for (restart in restarts) {
[10:22:45.586]                             name <- restart$name
[10:22:45.586]                             if (is.null(name)) 
[10:22:45.586]                               next
[10:22:45.586]                             if (!grepl(pattern, name)) 
[10:22:45.586]                               next
[10:22:45.586]                             invokeRestart(restart)
[10:22:45.586]                             muffled <- TRUE
[10:22:45.586]                             break
[10:22:45.586]                           }
[10:22:45.586]                         }
[10:22:45.586]                       }
[10:22:45.586]                       invisible(muffled)
[10:22:45.586]                     }
[10:22:45.586]                     muffleCondition(cond, pattern = "^muffle")
[10:22:45.586]                   }
[10:22:45.586]                 }
[10:22:45.586]                 else {
[10:22:45.586]                   if (TRUE) {
[10:22:45.586]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:45.586]                     {
[10:22:45.586]                       inherits <- base::inherits
[10:22:45.586]                       invokeRestart <- base::invokeRestart
[10:22:45.586]                       is.null <- base::is.null
[10:22:45.586]                       muffled <- FALSE
[10:22:45.586]                       if (inherits(cond, "message")) {
[10:22:45.586]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:45.586]                         if (muffled) 
[10:22:45.586]                           invokeRestart("muffleMessage")
[10:22:45.586]                       }
[10:22:45.586]                       else if (inherits(cond, "warning")) {
[10:22:45.586]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:45.586]                         if (muffled) 
[10:22:45.586]                           invokeRestart("muffleWarning")
[10:22:45.586]                       }
[10:22:45.586]                       else if (inherits(cond, "condition")) {
[10:22:45.586]                         if (!is.null(pattern)) {
[10:22:45.586]                           computeRestarts <- base::computeRestarts
[10:22:45.586]                           grepl <- base::grepl
[10:22:45.586]                           restarts <- computeRestarts(cond)
[10:22:45.586]                           for (restart in restarts) {
[10:22:45.586]                             name <- restart$name
[10:22:45.586]                             if (is.null(name)) 
[10:22:45.586]                               next
[10:22:45.586]                             if (!grepl(pattern, name)) 
[10:22:45.586]                               next
[10:22:45.586]                             invokeRestart(restart)
[10:22:45.586]                             muffled <- TRUE
[10:22:45.586]                             break
[10:22:45.586]                           }
[10:22:45.586]                         }
[10:22:45.586]                       }
[10:22:45.586]                       invisible(muffled)
[10:22:45.586]                     }
[10:22:45.586]                     muffleCondition(cond, pattern = "^muffle")
[10:22:45.586]                   }
[10:22:45.586]                 }
[10:22:45.586]             }
[10:22:45.586]         }))
[10:22:45.586]     }, error = function(ex) {
[10:22:45.586]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:45.586]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:45.586]                 ...future.rng), started = ...future.startTime, 
[10:22:45.586]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:45.586]             version = "1.8"), class = "FutureResult")
[10:22:45.586]     }, finally = {
[10:22:45.586]         if (!identical(...future.workdir, getwd())) 
[10:22:45.586]             setwd(...future.workdir)
[10:22:45.586]         {
[10:22:45.586]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:45.586]                 ...future.oldOptions$nwarnings <- NULL
[10:22:45.586]             }
[10:22:45.586]             base::options(...future.oldOptions)
[10:22:45.586]             if (.Platform$OS.type == "windows") {
[10:22:45.586]                 old_names <- names(...future.oldEnvVars)
[10:22:45.586]                 envs <- base::Sys.getenv()
[10:22:45.586]                 names <- names(envs)
[10:22:45.586]                 common <- intersect(names, old_names)
[10:22:45.586]                 added <- setdiff(names, old_names)
[10:22:45.586]                 removed <- setdiff(old_names, names)
[10:22:45.586]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:45.586]                   envs[common]]
[10:22:45.586]                 NAMES <- toupper(changed)
[10:22:45.586]                 args <- list()
[10:22:45.586]                 for (kk in seq_along(NAMES)) {
[10:22:45.586]                   name <- changed[[kk]]
[10:22:45.586]                   NAME <- NAMES[[kk]]
[10:22:45.586]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:45.586]                     next
[10:22:45.586]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:45.586]                 }
[10:22:45.586]                 NAMES <- toupper(added)
[10:22:45.586]                 for (kk in seq_along(NAMES)) {
[10:22:45.586]                   name <- added[[kk]]
[10:22:45.586]                   NAME <- NAMES[[kk]]
[10:22:45.586]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:45.586]                     next
[10:22:45.586]                   args[[name]] <- ""
[10:22:45.586]                 }
[10:22:45.586]                 NAMES <- toupper(removed)
[10:22:45.586]                 for (kk in seq_along(NAMES)) {
[10:22:45.586]                   name <- removed[[kk]]
[10:22:45.586]                   NAME <- NAMES[[kk]]
[10:22:45.586]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:45.586]                     next
[10:22:45.586]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:45.586]                 }
[10:22:45.586]                 if (length(args) > 0) 
[10:22:45.586]                   base::do.call(base::Sys.setenv, args = args)
[10:22:45.586]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:45.586]             }
[10:22:45.586]             else {
[10:22:45.586]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:45.586]             }
[10:22:45.586]             {
[10:22:45.586]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:45.586]                   0L) {
[10:22:45.586]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:45.586]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:45.586]                   base::options(opts)
[10:22:45.586]                 }
[10:22:45.586]                 {
[10:22:45.586]                   {
[10:22:45.586]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:45.586]                     NULL
[10:22:45.586]                   }
[10:22:45.586]                   options(future.plan = NULL)
[10:22:45.586]                   if (is.na(NA_character_)) 
[10:22:45.586]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:45.586]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:45.586]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:45.586]                     .init = FALSE)
[10:22:45.586]                 }
[10:22:45.586]             }
[10:22:45.586]         }
[10:22:45.586]     })
[10:22:45.586]     if (TRUE) {
[10:22:45.586]         base::sink(type = "output", split = FALSE)
[10:22:45.586]         if (TRUE) {
[10:22:45.586]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:45.586]         }
[10:22:45.586]         else {
[10:22:45.586]             ...future.result["stdout"] <- base::list(NULL)
[10:22:45.586]         }
[10:22:45.586]         base::close(...future.stdout)
[10:22:45.586]         ...future.stdout <- NULL
[10:22:45.586]     }
[10:22:45.586]     ...future.result$conditions <- ...future.conditions
[10:22:45.586]     ...future.result$finished <- base::Sys.time()
[10:22:45.586]     ...future.result
[10:22:45.586] }
[10:22:45.589] MultisessionFuture started
[10:22:45.589] - Launch lazy future ... done
[10:22:45.589] run() for ‘MultisessionFuture’ ... done
[10:22:45.631] receiveMessageFromWorker() for ClusterFuture ...
[10:22:45.632] - Validating connection of MultisessionFuture
[10:22:45.632] - received message: FutureResult
[10:22:45.632] - Received FutureResult
[10:22:45.632] - Erased future from FutureRegistry
[10:22:45.632] result() for ClusterFuture ...
[10:22:45.632] - result already collected: FutureResult
[10:22:45.633] result() for ClusterFuture ... done
[10:22:45.633] signalConditions() ...
[10:22:45.633]  - include = ‘immediateCondition’
[10:22:45.633]  - exclude = 
[10:22:45.633]  - resignal = FALSE
[10:22:45.633]  - Number of conditions: 1
[10:22:45.633] signalConditions() ... done
[10:22:45.633] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:45.633] A MultisessionFuture was resolved (and resolved itself)
- result = TRUE, recursive = 1 ... DONE
- result = TRUE, recursive = 2 ...
[10:22:45.633] getGlobalsAndPackages() ...
[10:22:45.634] Searching for globals...
[10:22:45.635] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:22:45.635] Searching for globals ... DONE
[10:22:45.635] Resolving globals: FALSE
[10:22:45.635] 
[10:22:45.635] 
[10:22:45.635] getGlobalsAndPackages() ... DONE
[10:22:45.636] run() for ‘Future’ ...
[10:22:45.636] - state: ‘created’
[10:22:45.636] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:45.650] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:45.650] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:45.650]   - Field: ‘node’
[10:22:45.650]   - Field: ‘label’
[10:22:45.650]   - Field: ‘local’
[10:22:45.650]   - Field: ‘owner’
[10:22:45.650]   - Field: ‘envir’
[10:22:45.650]   - Field: ‘workers’
[10:22:45.650]   - Field: ‘packages’
[10:22:45.651]   - Field: ‘gc’
[10:22:45.651]   - Field: ‘conditions’
[10:22:45.651]   - Field: ‘persistent’
[10:22:45.651]   - Field: ‘expr’
[10:22:45.651]   - Field: ‘uuid’
[10:22:45.651]   - Field: ‘seed’
[10:22:45.651]   - Field: ‘version’
[10:22:45.651]   - Field: ‘result’
[10:22:45.651]   - Field: ‘asynchronous’
[10:22:45.651]   - Field: ‘calls’
[10:22:45.651]   - Field: ‘globals’
[10:22:45.651]   - Field: ‘stdout’
[10:22:45.652]   - Field: ‘earlySignal’
[10:22:45.652]   - Field: ‘lazy’
[10:22:45.652]   - Field: ‘state’
[10:22:45.652] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:45.652] - Launch lazy future ...
[10:22:45.652] Packages needed by the future expression (n = 0): <none>
[10:22:45.652] Packages needed by future strategies (n = 0): <none>
[10:22:45.653] {
[10:22:45.653]     {
[10:22:45.653]         {
[10:22:45.653]             ...future.startTime <- base::Sys.time()
[10:22:45.653]             {
[10:22:45.653]                 {
[10:22:45.653]                   {
[10:22:45.653]                     {
[10:22:45.653]                       base::local({
[10:22:45.653]                         has_future <- base::requireNamespace("future", 
[10:22:45.653]                           quietly = TRUE)
[10:22:45.653]                         if (has_future) {
[10:22:45.653]                           ns <- base::getNamespace("future")
[10:22:45.653]                           version <- ns[[".package"]][["version"]]
[10:22:45.653]                           if (is.null(version)) 
[10:22:45.653]                             version <- utils::packageVersion("future")
[10:22:45.653]                         }
[10:22:45.653]                         else {
[10:22:45.653]                           version <- NULL
[10:22:45.653]                         }
[10:22:45.653]                         if (!has_future || version < "1.8.0") {
[10:22:45.653]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:45.653]                             "", base::R.version$version.string), 
[10:22:45.653]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:45.653]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:45.653]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:45.653]                               "release", "version")], collapse = " "), 
[10:22:45.653]                             hostname = base::Sys.info()[["nodename"]])
[10:22:45.653]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:45.653]                             info)
[10:22:45.653]                           info <- base::paste(info, collapse = "; ")
[10:22:45.653]                           if (!has_future) {
[10:22:45.653]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:45.653]                               info)
[10:22:45.653]                           }
[10:22:45.653]                           else {
[10:22:45.653]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:45.653]                               info, version)
[10:22:45.653]                           }
[10:22:45.653]                           base::stop(msg)
[10:22:45.653]                         }
[10:22:45.653]                       })
[10:22:45.653]                     }
[10:22:45.653]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:45.653]                     base::options(mc.cores = 1L)
[10:22:45.653]                   }
[10:22:45.653]                   ...future.strategy.old <- future::plan("list")
[10:22:45.653]                   options(future.plan = NULL)
[10:22:45.653]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:45.653]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:45.653]                 }
[10:22:45.653]                 ...future.workdir <- getwd()
[10:22:45.653]             }
[10:22:45.653]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:45.653]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:45.653]         }
[10:22:45.653]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:45.653]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:45.653]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:45.653]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:45.653]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:45.653]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:45.653]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:45.653]             base::names(...future.oldOptions))
[10:22:45.653]     }
[10:22:45.653]     if (FALSE) {
[10:22:45.653]     }
[10:22:45.653]     else {
[10:22:45.653]         if (TRUE) {
[10:22:45.653]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:45.653]                 open = "w")
[10:22:45.653]         }
[10:22:45.653]         else {
[10:22:45.653]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:45.653]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:45.653]         }
[10:22:45.653]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:45.653]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:45.653]             base::sink(type = "output", split = FALSE)
[10:22:45.653]             base::close(...future.stdout)
[10:22:45.653]         }, add = TRUE)
[10:22:45.653]     }
[10:22:45.653]     ...future.frame <- base::sys.nframe()
[10:22:45.653]     ...future.conditions <- base::list()
[10:22:45.653]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:45.653]     if (FALSE) {
[10:22:45.653]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:45.653]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:45.653]     }
[10:22:45.653]     ...future.result <- base::tryCatch({
[10:22:45.653]         base::withCallingHandlers({
[10:22:45.653]             ...future.value <- base::withVisible(base::local({
[10:22:45.653]                 ...future.makeSendCondition <- base::local({
[10:22:45.653]                   sendCondition <- NULL
[10:22:45.653]                   function(frame = 1L) {
[10:22:45.653]                     if (is.function(sendCondition)) 
[10:22:45.653]                       return(sendCondition)
[10:22:45.653]                     ns <- getNamespace("parallel")
[10:22:45.653]                     if (exists("sendData", mode = "function", 
[10:22:45.653]                       envir = ns)) {
[10:22:45.653]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:45.653]                         envir = ns)
[10:22:45.653]                       envir <- sys.frame(frame)
[10:22:45.653]                       master <- NULL
[10:22:45.653]                       while (!identical(envir, .GlobalEnv) && 
[10:22:45.653]                         !identical(envir, emptyenv())) {
[10:22:45.653]                         if (exists("master", mode = "list", envir = envir, 
[10:22:45.653]                           inherits = FALSE)) {
[10:22:45.653]                           master <- get("master", mode = "list", 
[10:22:45.653]                             envir = envir, inherits = FALSE)
[10:22:45.653]                           if (inherits(master, c("SOCKnode", 
[10:22:45.653]                             "SOCK0node"))) {
[10:22:45.653]                             sendCondition <<- function(cond) {
[10:22:45.653]                               data <- list(type = "VALUE", value = cond, 
[10:22:45.653]                                 success = TRUE)
[10:22:45.653]                               parallel_sendData(master, data)
[10:22:45.653]                             }
[10:22:45.653]                             return(sendCondition)
[10:22:45.653]                           }
[10:22:45.653]                         }
[10:22:45.653]                         frame <- frame + 1L
[10:22:45.653]                         envir <- sys.frame(frame)
[10:22:45.653]                       }
[10:22:45.653]                     }
[10:22:45.653]                     sendCondition <<- function(cond) NULL
[10:22:45.653]                   }
[10:22:45.653]                 })
[10:22:45.653]                 withCallingHandlers({
[10:22:45.653]                   {
[10:22:45.653]                     Sys.sleep(0.5)
[10:22:45.653]                     list(a = 1, b = 42L)
[10:22:45.653]                   }
[10:22:45.653]                 }, immediateCondition = function(cond) {
[10:22:45.653]                   sendCondition <- ...future.makeSendCondition()
[10:22:45.653]                   sendCondition(cond)
[10:22:45.653]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:45.653]                   {
[10:22:45.653]                     inherits <- base::inherits
[10:22:45.653]                     invokeRestart <- base::invokeRestart
[10:22:45.653]                     is.null <- base::is.null
[10:22:45.653]                     muffled <- FALSE
[10:22:45.653]                     if (inherits(cond, "message")) {
[10:22:45.653]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:45.653]                       if (muffled) 
[10:22:45.653]                         invokeRestart("muffleMessage")
[10:22:45.653]                     }
[10:22:45.653]                     else if (inherits(cond, "warning")) {
[10:22:45.653]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:45.653]                       if (muffled) 
[10:22:45.653]                         invokeRestart("muffleWarning")
[10:22:45.653]                     }
[10:22:45.653]                     else if (inherits(cond, "condition")) {
[10:22:45.653]                       if (!is.null(pattern)) {
[10:22:45.653]                         computeRestarts <- base::computeRestarts
[10:22:45.653]                         grepl <- base::grepl
[10:22:45.653]                         restarts <- computeRestarts(cond)
[10:22:45.653]                         for (restart in restarts) {
[10:22:45.653]                           name <- restart$name
[10:22:45.653]                           if (is.null(name)) 
[10:22:45.653]                             next
[10:22:45.653]                           if (!grepl(pattern, name)) 
[10:22:45.653]                             next
[10:22:45.653]                           invokeRestart(restart)
[10:22:45.653]                           muffled <- TRUE
[10:22:45.653]                           break
[10:22:45.653]                         }
[10:22:45.653]                       }
[10:22:45.653]                     }
[10:22:45.653]                     invisible(muffled)
[10:22:45.653]                   }
[10:22:45.653]                   muffleCondition(cond)
[10:22:45.653]                 })
[10:22:45.653]             }))
[10:22:45.653]             future::FutureResult(value = ...future.value$value, 
[10:22:45.653]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:45.653]                   ...future.rng), globalenv = if (FALSE) 
[10:22:45.653]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:45.653]                     ...future.globalenv.names))
[10:22:45.653]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:45.653]         }, condition = base::local({
[10:22:45.653]             c <- base::c
[10:22:45.653]             inherits <- base::inherits
[10:22:45.653]             invokeRestart <- base::invokeRestart
[10:22:45.653]             length <- base::length
[10:22:45.653]             list <- base::list
[10:22:45.653]             seq.int <- base::seq.int
[10:22:45.653]             signalCondition <- base::signalCondition
[10:22:45.653]             sys.calls <- base::sys.calls
[10:22:45.653]             `[[` <- base::`[[`
[10:22:45.653]             `+` <- base::`+`
[10:22:45.653]             `<<-` <- base::`<<-`
[10:22:45.653]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:45.653]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:45.653]                   3L)]
[10:22:45.653]             }
[10:22:45.653]             function(cond) {
[10:22:45.653]                 is_error <- inherits(cond, "error")
[10:22:45.653]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:45.653]                   NULL)
[10:22:45.653]                 if (is_error) {
[10:22:45.653]                   sessionInformation <- function() {
[10:22:45.653]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:45.653]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:45.653]                       search = base::search(), system = base::Sys.info())
[10:22:45.653]                   }
[10:22:45.653]                   ...future.conditions[[length(...future.conditions) + 
[10:22:45.653]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:45.653]                     cond$call), session = sessionInformation(), 
[10:22:45.653]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:45.653]                   signalCondition(cond)
[10:22:45.653]                 }
[10:22:45.653]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:45.653]                 "immediateCondition"))) {
[10:22:45.653]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:45.653]                   ...future.conditions[[length(...future.conditions) + 
[10:22:45.653]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:45.653]                   if (TRUE && !signal) {
[10:22:45.653]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:45.653]                     {
[10:22:45.653]                       inherits <- base::inherits
[10:22:45.653]                       invokeRestart <- base::invokeRestart
[10:22:45.653]                       is.null <- base::is.null
[10:22:45.653]                       muffled <- FALSE
[10:22:45.653]                       if (inherits(cond, "message")) {
[10:22:45.653]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:45.653]                         if (muffled) 
[10:22:45.653]                           invokeRestart("muffleMessage")
[10:22:45.653]                       }
[10:22:45.653]                       else if (inherits(cond, "warning")) {
[10:22:45.653]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:45.653]                         if (muffled) 
[10:22:45.653]                           invokeRestart("muffleWarning")
[10:22:45.653]                       }
[10:22:45.653]                       else if (inherits(cond, "condition")) {
[10:22:45.653]                         if (!is.null(pattern)) {
[10:22:45.653]                           computeRestarts <- base::computeRestarts
[10:22:45.653]                           grepl <- base::grepl
[10:22:45.653]                           restarts <- computeRestarts(cond)
[10:22:45.653]                           for (restart in restarts) {
[10:22:45.653]                             name <- restart$name
[10:22:45.653]                             if (is.null(name)) 
[10:22:45.653]                               next
[10:22:45.653]                             if (!grepl(pattern, name)) 
[10:22:45.653]                               next
[10:22:45.653]                             invokeRestart(restart)
[10:22:45.653]                             muffled <- TRUE
[10:22:45.653]                             break
[10:22:45.653]                           }
[10:22:45.653]                         }
[10:22:45.653]                       }
[10:22:45.653]                       invisible(muffled)
[10:22:45.653]                     }
[10:22:45.653]                     muffleCondition(cond, pattern = "^muffle")
[10:22:45.653]                   }
[10:22:45.653]                 }
[10:22:45.653]                 else {
[10:22:45.653]                   if (TRUE) {
[10:22:45.653]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:45.653]                     {
[10:22:45.653]                       inherits <- base::inherits
[10:22:45.653]                       invokeRestart <- base::invokeRestart
[10:22:45.653]                       is.null <- base::is.null
[10:22:45.653]                       muffled <- FALSE
[10:22:45.653]                       if (inherits(cond, "message")) {
[10:22:45.653]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:45.653]                         if (muffled) 
[10:22:45.653]                           invokeRestart("muffleMessage")
[10:22:45.653]                       }
[10:22:45.653]                       else if (inherits(cond, "warning")) {
[10:22:45.653]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:45.653]                         if (muffled) 
[10:22:45.653]                           invokeRestart("muffleWarning")
[10:22:45.653]                       }
[10:22:45.653]                       else if (inherits(cond, "condition")) {
[10:22:45.653]                         if (!is.null(pattern)) {
[10:22:45.653]                           computeRestarts <- base::computeRestarts
[10:22:45.653]                           grepl <- base::grepl
[10:22:45.653]                           restarts <- computeRestarts(cond)
[10:22:45.653]                           for (restart in restarts) {
[10:22:45.653]                             name <- restart$name
[10:22:45.653]                             if (is.null(name)) 
[10:22:45.653]                               next
[10:22:45.653]                             if (!grepl(pattern, name)) 
[10:22:45.653]                               next
[10:22:45.653]                             invokeRestart(restart)
[10:22:45.653]                             muffled <- TRUE
[10:22:45.653]                             break
[10:22:45.653]                           }
[10:22:45.653]                         }
[10:22:45.653]                       }
[10:22:45.653]                       invisible(muffled)
[10:22:45.653]                     }
[10:22:45.653]                     muffleCondition(cond, pattern = "^muffle")
[10:22:45.653]                   }
[10:22:45.653]                 }
[10:22:45.653]             }
[10:22:45.653]         }))
[10:22:45.653]     }, error = function(ex) {
[10:22:45.653]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:45.653]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:45.653]                 ...future.rng), started = ...future.startTime, 
[10:22:45.653]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:45.653]             version = "1.8"), class = "FutureResult")
[10:22:45.653]     }, finally = {
[10:22:45.653]         if (!identical(...future.workdir, getwd())) 
[10:22:45.653]             setwd(...future.workdir)
[10:22:45.653]         {
[10:22:45.653]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:45.653]                 ...future.oldOptions$nwarnings <- NULL
[10:22:45.653]             }
[10:22:45.653]             base::options(...future.oldOptions)
[10:22:45.653]             if (.Platform$OS.type == "windows") {
[10:22:45.653]                 old_names <- names(...future.oldEnvVars)
[10:22:45.653]                 envs <- base::Sys.getenv()
[10:22:45.653]                 names <- names(envs)
[10:22:45.653]                 common <- intersect(names, old_names)
[10:22:45.653]                 added <- setdiff(names, old_names)
[10:22:45.653]                 removed <- setdiff(old_names, names)
[10:22:45.653]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:45.653]                   envs[common]]
[10:22:45.653]                 NAMES <- toupper(changed)
[10:22:45.653]                 args <- list()
[10:22:45.653]                 for (kk in seq_along(NAMES)) {
[10:22:45.653]                   name <- changed[[kk]]
[10:22:45.653]                   NAME <- NAMES[[kk]]
[10:22:45.653]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:45.653]                     next
[10:22:45.653]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:45.653]                 }
[10:22:45.653]                 NAMES <- toupper(added)
[10:22:45.653]                 for (kk in seq_along(NAMES)) {
[10:22:45.653]                   name <- added[[kk]]
[10:22:45.653]                   NAME <- NAMES[[kk]]
[10:22:45.653]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:45.653]                     next
[10:22:45.653]                   args[[name]] <- ""
[10:22:45.653]                 }
[10:22:45.653]                 NAMES <- toupper(removed)
[10:22:45.653]                 for (kk in seq_along(NAMES)) {
[10:22:45.653]                   name <- removed[[kk]]
[10:22:45.653]                   NAME <- NAMES[[kk]]
[10:22:45.653]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:45.653]                     next
[10:22:45.653]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:45.653]                 }
[10:22:45.653]                 if (length(args) > 0) 
[10:22:45.653]                   base::do.call(base::Sys.setenv, args = args)
[10:22:45.653]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:45.653]             }
[10:22:45.653]             else {
[10:22:45.653]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:45.653]             }
[10:22:45.653]             {
[10:22:45.653]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:45.653]                   0L) {
[10:22:45.653]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:45.653]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:45.653]                   base::options(opts)
[10:22:45.653]                 }
[10:22:45.653]                 {
[10:22:45.653]                   {
[10:22:45.653]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:45.653]                     NULL
[10:22:45.653]                   }
[10:22:45.653]                   options(future.plan = NULL)
[10:22:45.653]                   if (is.na(NA_character_)) 
[10:22:45.653]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:45.653]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:45.653]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:45.653]                     .init = FALSE)
[10:22:45.653]                 }
[10:22:45.653]             }
[10:22:45.653]         }
[10:22:45.653]     })
[10:22:45.653]     if (TRUE) {
[10:22:45.653]         base::sink(type = "output", split = FALSE)
[10:22:45.653]         if (TRUE) {
[10:22:45.653]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:45.653]         }
[10:22:45.653]         else {
[10:22:45.653]             ...future.result["stdout"] <- base::list(NULL)
[10:22:45.653]         }
[10:22:45.653]         base::close(...future.stdout)
[10:22:45.653]         ...future.stdout <- NULL
[10:22:45.653]     }
[10:22:45.653]     ...future.result$conditions <- ...future.conditions
[10:22:45.653]     ...future.result$finished <- base::Sys.time()
[10:22:45.653]     ...future.result
[10:22:45.653] }
[10:22:45.656] MultisessionFuture started
[10:22:45.656] - Launch lazy future ... done
[10:22:45.658] run() for ‘MultisessionFuture’ ... done
[10:22:46.199] receiveMessageFromWorker() for ClusterFuture ...
[10:22:46.199] - Validating connection of MultisessionFuture
[10:22:46.199] - received message: FutureResult
[10:22:46.200] - Received FutureResult
[10:22:46.200] - Erased future from FutureRegistry
[10:22:46.200] result() for ClusterFuture ...
[10:22:46.200] - result already collected: FutureResult
[10:22:46.200] result() for ClusterFuture ... done
[10:22:46.200] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:46.200] resolve() on list ...
[10:22:46.200]  recursive: 1
[10:22:46.200]  length: 2
[10:22:46.200]  elements: ‘a’, ‘b’
[10:22:46.201]  length: 1 (resolved future 1)
[10:22:46.201]  length: 0 (resolved future 2)
[10:22:46.201] resolve() on list ... DONE
[10:22:46.201] A MultisessionFuture was resolved (and resolved itself)
[10:22:46.201] getGlobalsAndPackages() ...
[10:22:46.201] Searching for globals...
[10:22:46.202] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:22:46.202] Searching for globals ... DONE
[10:22:46.202] Resolving globals: FALSE
[10:22:46.203] 
[10:22:46.203] 
[10:22:46.203] getGlobalsAndPackages() ... DONE
[10:22:46.203] run() for ‘Future’ ...
[10:22:46.203] - state: ‘created’
[10:22:46.203] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:46.217] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:46.217] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:46.217]   - Field: ‘node’
[10:22:46.217]   - Field: ‘label’
[10:22:46.218]   - Field: ‘local’
[10:22:46.218]   - Field: ‘owner’
[10:22:46.218]   - Field: ‘envir’
[10:22:46.218]   - Field: ‘workers’
[10:22:46.218]   - Field: ‘packages’
[10:22:46.218]   - Field: ‘gc’
[10:22:46.218]   - Field: ‘conditions’
[10:22:46.218]   - Field: ‘persistent’
[10:22:46.218]   - Field: ‘expr’
[10:22:46.218]   - Field: ‘uuid’
[10:22:46.218]   - Field: ‘seed’
[10:22:46.219]   - Field: ‘version’
[10:22:46.219]   - Field: ‘result’
[10:22:46.219]   - Field: ‘asynchronous’
[10:22:46.219]   - Field: ‘calls’
[10:22:46.219]   - Field: ‘globals’
[10:22:46.219]   - Field: ‘stdout’
[10:22:46.219]   - Field: ‘earlySignal’
[10:22:46.219]   - Field: ‘lazy’
[10:22:46.219]   - Field: ‘state’
[10:22:46.219] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:46.219] - Launch lazy future ...
[10:22:46.220] Packages needed by the future expression (n = 0): <none>
[10:22:46.220] Packages needed by future strategies (n = 0): <none>
[10:22:46.220] {
[10:22:46.220]     {
[10:22:46.220]         {
[10:22:46.220]             ...future.startTime <- base::Sys.time()
[10:22:46.220]             {
[10:22:46.220]                 {
[10:22:46.220]                   {
[10:22:46.220]                     {
[10:22:46.220]                       base::local({
[10:22:46.220]                         has_future <- base::requireNamespace("future", 
[10:22:46.220]                           quietly = TRUE)
[10:22:46.220]                         if (has_future) {
[10:22:46.220]                           ns <- base::getNamespace("future")
[10:22:46.220]                           version <- ns[[".package"]][["version"]]
[10:22:46.220]                           if (is.null(version)) 
[10:22:46.220]                             version <- utils::packageVersion("future")
[10:22:46.220]                         }
[10:22:46.220]                         else {
[10:22:46.220]                           version <- NULL
[10:22:46.220]                         }
[10:22:46.220]                         if (!has_future || version < "1.8.0") {
[10:22:46.220]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:46.220]                             "", base::R.version$version.string), 
[10:22:46.220]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:46.220]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:46.220]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:46.220]                               "release", "version")], collapse = " "), 
[10:22:46.220]                             hostname = base::Sys.info()[["nodename"]])
[10:22:46.220]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:46.220]                             info)
[10:22:46.220]                           info <- base::paste(info, collapse = "; ")
[10:22:46.220]                           if (!has_future) {
[10:22:46.220]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:46.220]                               info)
[10:22:46.220]                           }
[10:22:46.220]                           else {
[10:22:46.220]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:46.220]                               info, version)
[10:22:46.220]                           }
[10:22:46.220]                           base::stop(msg)
[10:22:46.220]                         }
[10:22:46.220]                       })
[10:22:46.220]                     }
[10:22:46.220]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:46.220]                     base::options(mc.cores = 1L)
[10:22:46.220]                   }
[10:22:46.220]                   ...future.strategy.old <- future::plan("list")
[10:22:46.220]                   options(future.plan = NULL)
[10:22:46.220]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:46.220]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:46.220]                 }
[10:22:46.220]                 ...future.workdir <- getwd()
[10:22:46.220]             }
[10:22:46.220]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:46.220]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:46.220]         }
[10:22:46.220]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:46.220]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:46.220]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:46.220]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:46.220]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:46.220]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:46.220]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:46.220]             base::names(...future.oldOptions))
[10:22:46.220]     }
[10:22:46.220]     if (FALSE) {
[10:22:46.220]     }
[10:22:46.220]     else {
[10:22:46.220]         if (TRUE) {
[10:22:46.220]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:46.220]                 open = "w")
[10:22:46.220]         }
[10:22:46.220]         else {
[10:22:46.220]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:46.220]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:46.220]         }
[10:22:46.220]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:46.220]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:46.220]             base::sink(type = "output", split = FALSE)
[10:22:46.220]             base::close(...future.stdout)
[10:22:46.220]         }, add = TRUE)
[10:22:46.220]     }
[10:22:46.220]     ...future.frame <- base::sys.nframe()
[10:22:46.220]     ...future.conditions <- base::list()
[10:22:46.220]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:46.220]     if (FALSE) {
[10:22:46.220]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:46.220]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:46.220]     }
[10:22:46.220]     ...future.result <- base::tryCatch({
[10:22:46.220]         base::withCallingHandlers({
[10:22:46.220]             ...future.value <- base::withVisible(base::local({
[10:22:46.220]                 ...future.makeSendCondition <- base::local({
[10:22:46.220]                   sendCondition <- NULL
[10:22:46.220]                   function(frame = 1L) {
[10:22:46.220]                     if (is.function(sendCondition)) 
[10:22:46.220]                       return(sendCondition)
[10:22:46.220]                     ns <- getNamespace("parallel")
[10:22:46.220]                     if (exists("sendData", mode = "function", 
[10:22:46.220]                       envir = ns)) {
[10:22:46.220]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:46.220]                         envir = ns)
[10:22:46.220]                       envir <- sys.frame(frame)
[10:22:46.220]                       master <- NULL
[10:22:46.220]                       while (!identical(envir, .GlobalEnv) && 
[10:22:46.220]                         !identical(envir, emptyenv())) {
[10:22:46.220]                         if (exists("master", mode = "list", envir = envir, 
[10:22:46.220]                           inherits = FALSE)) {
[10:22:46.220]                           master <- get("master", mode = "list", 
[10:22:46.220]                             envir = envir, inherits = FALSE)
[10:22:46.220]                           if (inherits(master, c("SOCKnode", 
[10:22:46.220]                             "SOCK0node"))) {
[10:22:46.220]                             sendCondition <<- function(cond) {
[10:22:46.220]                               data <- list(type = "VALUE", value = cond, 
[10:22:46.220]                                 success = TRUE)
[10:22:46.220]                               parallel_sendData(master, data)
[10:22:46.220]                             }
[10:22:46.220]                             return(sendCondition)
[10:22:46.220]                           }
[10:22:46.220]                         }
[10:22:46.220]                         frame <- frame + 1L
[10:22:46.220]                         envir <- sys.frame(frame)
[10:22:46.220]                       }
[10:22:46.220]                     }
[10:22:46.220]                     sendCondition <<- function(cond) NULL
[10:22:46.220]                   }
[10:22:46.220]                 })
[10:22:46.220]                 withCallingHandlers({
[10:22:46.220]                   {
[10:22:46.220]                     Sys.sleep(0.5)
[10:22:46.220]                     list(a = 1, b = 42L)
[10:22:46.220]                   }
[10:22:46.220]                 }, immediateCondition = function(cond) {
[10:22:46.220]                   sendCondition <- ...future.makeSendCondition()
[10:22:46.220]                   sendCondition(cond)
[10:22:46.220]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:46.220]                   {
[10:22:46.220]                     inherits <- base::inherits
[10:22:46.220]                     invokeRestart <- base::invokeRestart
[10:22:46.220]                     is.null <- base::is.null
[10:22:46.220]                     muffled <- FALSE
[10:22:46.220]                     if (inherits(cond, "message")) {
[10:22:46.220]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:46.220]                       if (muffled) 
[10:22:46.220]                         invokeRestart("muffleMessage")
[10:22:46.220]                     }
[10:22:46.220]                     else if (inherits(cond, "warning")) {
[10:22:46.220]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:46.220]                       if (muffled) 
[10:22:46.220]                         invokeRestart("muffleWarning")
[10:22:46.220]                     }
[10:22:46.220]                     else if (inherits(cond, "condition")) {
[10:22:46.220]                       if (!is.null(pattern)) {
[10:22:46.220]                         computeRestarts <- base::computeRestarts
[10:22:46.220]                         grepl <- base::grepl
[10:22:46.220]                         restarts <- computeRestarts(cond)
[10:22:46.220]                         for (restart in restarts) {
[10:22:46.220]                           name <- restart$name
[10:22:46.220]                           if (is.null(name)) 
[10:22:46.220]                             next
[10:22:46.220]                           if (!grepl(pattern, name)) 
[10:22:46.220]                             next
[10:22:46.220]                           invokeRestart(restart)
[10:22:46.220]                           muffled <- TRUE
[10:22:46.220]                           break
[10:22:46.220]                         }
[10:22:46.220]                       }
[10:22:46.220]                     }
[10:22:46.220]                     invisible(muffled)
[10:22:46.220]                   }
[10:22:46.220]                   muffleCondition(cond)
[10:22:46.220]                 })
[10:22:46.220]             }))
[10:22:46.220]             future::FutureResult(value = ...future.value$value, 
[10:22:46.220]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:46.220]                   ...future.rng), globalenv = if (FALSE) 
[10:22:46.220]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:46.220]                     ...future.globalenv.names))
[10:22:46.220]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:46.220]         }, condition = base::local({
[10:22:46.220]             c <- base::c
[10:22:46.220]             inherits <- base::inherits
[10:22:46.220]             invokeRestart <- base::invokeRestart
[10:22:46.220]             length <- base::length
[10:22:46.220]             list <- base::list
[10:22:46.220]             seq.int <- base::seq.int
[10:22:46.220]             signalCondition <- base::signalCondition
[10:22:46.220]             sys.calls <- base::sys.calls
[10:22:46.220]             `[[` <- base::`[[`
[10:22:46.220]             `+` <- base::`+`
[10:22:46.220]             `<<-` <- base::`<<-`
[10:22:46.220]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:46.220]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:46.220]                   3L)]
[10:22:46.220]             }
[10:22:46.220]             function(cond) {
[10:22:46.220]                 is_error <- inherits(cond, "error")
[10:22:46.220]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:46.220]                   NULL)
[10:22:46.220]                 if (is_error) {
[10:22:46.220]                   sessionInformation <- function() {
[10:22:46.220]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:46.220]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:46.220]                       search = base::search(), system = base::Sys.info())
[10:22:46.220]                   }
[10:22:46.220]                   ...future.conditions[[length(...future.conditions) + 
[10:22:46.220]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:46.220]                     cond$call), session = sessionInformation(), 
[10:22:46.220]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:46.220]                   signalCondition(cond)
[10:22:46.220]                 }
[10:22:46.220]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:46.220]                 "immediateCondition"))) {
[10:22:46.220]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:46.220]                   ...future.conditions[[length(...future.conditions) + 
[10:22:46.220]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:46.220]                   if (TRUE && !signal) {
[10:22:46.220]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:46.220]                     {
[10:22:46.220]                       inherits <- base::inherits
[10:22:46.220]                       invokeRestart <- base::invokeRestart
[10:22:46.220]                       is.null <- base::is.null
[10:22:46.220]                       muffled <- FALSE
[10:22:46.220]                       if (inherits(cond, "message")) {
[10:22:46.220]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:46.220]                         if (muffled) 
[10:22:46.220]                           invokeRestart("muffleMessage")
[10:22:46.220]                       }
[10:22:46.220]                       else if (inherits(cond, "warning")) {
[10:22:46.220]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:46.220]                         if (muffled) 
[10:22:46.220]                           invokeRestart("muffleWarning")
[10:22:46.220]                       }
[10:22:46.220]                       else if (inherits(cond, "condition")) {
[10:22:46.220]                         if (!is.null(pattern)) {
[10:22:46.220]                           computeRestarts <- base::computeRestarts
[10:22:46.220]                           grepl <- base::grepl
[10:22:46.220]                           restarts <- computeRestarts(cond)
[10:22:46.220]                           for (restart in restarts) {
[10:22:46.220]                             name <- restart$name
[10:22:46.220]                             if (is.null(name)) 
[10:22:46.220]                               next
[10:22:46.220]                             if (!grepl(pattern, name)) 
[10:22:46.220]                               next
[10:22:46.220]                             invokeRestart(restart)
[10:22:46.220]                             muffled <- TRUE
[10:22:46.220]                             break
[10:22:46.220]                           }
[10:22:46.220]                         }
[10:22:46.220]                       }
[10:22:46.220]                       invisible(muffled)
[10:22:46.220]                     }
[10:22:46.220]                     muffleCondition(cond, pattern = "^muffle")
[10:22:46.220]                   }
[10:22:46.220]                 }
[10:22:46.220]                 else {
[10:22:46.220]                   if (TRUE) {
[10:22:46.220]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:46.220]                     {
[10:22:46.220]                       inherits <- base::inherits
[10:22:46.220]                       invokeRestart <- base::invokeRestart
[10:22:46.220]                       is.null <- base::is.null
[10:22:46.220]                       muffled <- FALSE
[10:22:46.220]                       if (inherits(cond, "message")) {
[10:22:46.220]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:46.220]                         if (muffled) 
[10:22:46.220]                           invokeRestart("muffleMessage")
[10:22:46.220]                       }
[10:22:46.220]                       else if (inherits(cond, "warning")) {
[10:22:46.220]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:46.220]                         if (muffled) 
[10:22:46.220]                           invokeRestart("muffleWarning")
[10:22:46.220]                       }
[10:22:46.220]                       else if (inherits(cond, "condition")) {
[10:22:46.220]                         if (!is.null(pattern)) {
[10:22:46.220]                           computeRestarts <- base::computeRestarts
[10:22:46.220]                           grepl <- base::grepl
[10:22:46.220]                           restarts <- computeRestarts(cond)
[10:22:46.220]                           for (restart in restarts) {
[10:22:46.220]                             name <- restart$name
[10:22:46.220]                             if (is.null(name)) 
[10:22:46.220]                               next
[10:22:46.220]                             if (!grepl(pattern, name)) 
[10:22:46.220]                               next
[10:22:46.220]                             invokeRestart(restart)
[10:22:46.220]                             muffled <- TRUE
[10:22:46.220]                             break
[10:22:46.220]                           }
[10:22:46.220]                         }
[10:22:46.220]                       }
[10:22:46.220]                       invisible(muffled)
[10:22:46.220]                     }
[10:22:46.220]                     muffleCondition(cond, pattern = "^muffle")
[10:22:46.220]                   }
[10:22:46.220]                 }
[10:22:46.220]             }
[10:22:46.220]         }))
[10:22:46.220]     }, error = function(ex) {
[10:22:46.220]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:46.220]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:46.220]                 ...future.rng), started = ...future.startTime, 
[10:22:46.220]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:46.220]             version = "1.8"), class = "FutureResult")
[10:22:46.220]     }, finally = {
[10:22:46.220]         if (!identical(...future.workdir, getwd())) 
[10:22:46.220]             setwd(...future.workdir)
[10:22:46.220]         {
[10:22:46.220]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:46.220]                 ...future.oldOptions$nwarnings <- NULL
[10:22:46.220]             }
[10:22:46.220]             base::options(...future.oldOptions)
[10:22:46.220]             if (.Platform$OS.type == "windows") {
[10:22:46.220]                 old_names <- names(...future.oldEnvVars)
[10:22:46.220]                 envs <- base::Sys.getenv()
[10:22:46.220]                 names <- names(envs)
[10:22:46.220]                 common <- intersect(names, old_names)
[10:22:46.220]                 added <- setdiff(names, old_names)
[10:22:46.220]                 removed <- setdiff(old_names, names)
[10:22:46.220]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:46.220]                   envs[common]]
[10:22:46.220]                 NAMES <- toupper(changed)
[10:22:46.220]                 args <- list()
[10:22:46.220]                 for (kk in seq_along(NAMES)) {
[10:22:46.220]                   name <- changed[[kk]]
[10:22:46.220]                   NAME <- NAMES[[kk]]
[10:22:46.220]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:46.220]                     next
[10:22:46.220]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:46.220]                 }
[10:22:46.220]                 NAMES <- toupper(added)
[10:22:46.220]                 for (kk in seq_along(NAMES)) {
[10:22:46.220]                   name <- added[[kk]]
[10:22:46.220]                   NAME <- NAMES[[kk]]
[10:22:46.220]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:46.220]                     next
[10:22:46.220]                   args[[name]] <- ""
[10:22:46.220]                 }
[10:22:46.220]                 NAMES <- toupper(removed)
[10:22:46.220]                 for (kk in seq_along(NAMES)) {
[10:22:46.220]                   name <- removed[[kk]]
[10:22:46.220]                   NAME <- NAMES[[kk]]
[10:22:46.220]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:46.220]                     next
[10:22:46.220]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:46.220]                 }
[10:22:46.220]                 if (length(args) > 0) 
[10:22:46.220]                   base::do.call(base::Sys.setenv, args = args)
[10:22:46.220]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:46.220]             }
[10:22:46.220]             else {
[10:22:46.220]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:46.220]             }
[10:22:46.220]             {
[10:22:46.220]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:46.220]                   0L) {
[10:22:46.220]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:46.220]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:46.220]                   base::options(opts)
[10:22:46.220]                 }
[10:22:46.220]                 {
[10:22:46.220]                   {
[10:22:46.220]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:46.220]                     NULL
[10:22:46.220]                   }
[10:22:46.220]                   options(future.plan = NULL)
[10:22:46.220]                   if (is.na(NA_character_)) 
[10:22:46.220]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:46.220]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:46.220]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:46.220]                     .init = FALSE)
[10:22:46.220]                 }
[10:22:46.220]             }
[10:22:46.220]         }
[10:22:46.220]     })
[10:22:46.220]     if (TRUE) {
[10:22:46.220]         base::sink(type = "output", split = FALSE)
[10:22:46.220]         if (TRUE) {
[10:22:46.220]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:46.220]         }
[10:22:46.220]         else {
[10:22:46.220]             ...future.result["stdout"] <- base::list(NULL)
[10:22:46.220]         }
[10:22:46.220]         base::close(...future.stdout)
[10:22:46.220]         ...future.stdout <- NULL
[10:22:46.220]     }
[10:22:46.220]     ...future.result$conditions <- ...future.conditions
[10:22:46.220]     ...future.result$finished <- base::Sys.time()
[10:22:46.220]     ...future.result
[10:22:46.220] }
[10:22:46.223] MultisessionFuture started
[10:22:46.223] - Launch lazy future ... done
[10:22:46.224] run() for ‘MultisessionFuture’ ... done
[10:22:46.766] receiveMessageFromWorker() for ClusterFuture ...
[10:22:46.766] - Validating connection of MultisessionFuture
[10:22:46.767] - received message: FutureResult
[10:22:46.767] - Received FutureResult
[10:22:46.767] - Erased future from FutureRegistry
[10:22:46.767] result() for ClusterFuture ...
[10:22:46.767] - result already collected: FutureResult
[10:22:46.767] result() for ClusterFuture ... done
[10:22:46.767] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:46.767] resolve() on list ...
[10:22:46.767]  recursive: 1
[10:22:46.768]  length: 2
[10:22:46.768]  elements: ‘a’, ‘b’
[10:22:46.768]  length: 1 (resolved future 1)
[10:22:46.768]  length: 0 (resolved future 2)
[10:22:46.768] resolve() on list ... DONE
[10:22:46.768] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[10:22:46.768] getGlobalsAndPackages() ...
[10:22:46.768] Searching for globals...
[10:22:46.769] - globals found: [2] ‘list’, ‘stop’
[10:22:46.769] Searching for globals ... DONE
[10:22:46.769] Resolving globals: FALSE
[10:22:46.769] 
[10:22:46.770] 
[10:22:46.770] getGlobalsAndPackages() ... DONE
[10:22:46.770] run() for ‘Future’ ...
[10:22:46.770] - state: ‘created’
[10:22:46.770] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:46.784] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:46.784] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:46.784]   - Field: ‘node’
[10:22:46.784]   - Field: ‘label’
[10:22:46.784]   - Field: ‘local’
[10:22:46.784]   - Field: ‘owner’
[10:22:46.785]   - Field: ‘envir’
[10:22:46.785]   - Field: ‘workers’
[10:22:46.785]   - Field: ‘packages’
[10:22:46.785]   - Field: ‘gc’
[10:22:46.785]   - Field: ‘conditions’
[10:22:46.785]   - Field: ‘persistent’
[10:22:46.785]   - Field: ‘expr’
[10:22:46.785]   - Field: ‘uuid’
[10:22:46.785]   - Field: ‘seed’
[10:22:46.785]   - Field: ‘version’
[10:22:46.785]   - Field: ‘result’
[10:22:46.786]   - Field: ‘asynchronous’
[10:22:46.786]   - Field: ‘calls’
[10:22:46.786]   - Field: ‘globals’
[10:22:46.786]   - Field: ‘stdout’
[10:22:46.786]   - Field: ‘earlySignal’
[10:22:46.786]   - Field: ‘lazy’
[10:22:46.786]   - Field: ‘state’
[10:22:46.786] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:46.786] - Launch lazy future ...
[10:22:46.786] Packages needed by the future expression (n = 0): <none>
[10:22:46.787] Packages needed by future strategies (n = 0): <none>
[10:22:46.787] {
[10:22:46.787]     {
[10:22:46.787]         {
[10:22:46.787]             ...future.startTime <- base::Sys.time()
[10:22:46.787]             {
[10:22:46.787]                 {
[10:22:46.787]                   {
[10:22:46.787]                     {
[10:22:46.787]                       base::local({
[10:22:46.787]                         has_future <- base::requireNamespace("future", 
[10:22:46.787]                           quietly = TRUE)
[10:22:46.787]                         if (has_future) {
[10:22:46.787]                           ns <- base::getNamespace("future")
[10:22:46.787]                           version <- ns[[".package"]][["version"]]
[10:22:46.787]                           if (is.null(version)) 
[10:22:46.787]                             version <- utils::packageVersion("future")
[10:22:46.787]                         }
[10:22:46.787]                         else {
[10:22:46.787]                           version <- NULL
[10:22:46.787]                         }
[10:22:46.787]                         if (!has_future || version < "1.8.0") {
[10:22:46.787]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:46.787]                             "", base::R.version$version.string), 
[10:22:46.787]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:46.787]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:46.787]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:46.787]                               "release", "version")], collapse = " "), 
[10:22:46.787]                             hostname = base::Sys.info()[["nodename"]])
[10:22:46.787]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:46.787]                             info)
[10:22:46.787]                           info <- base::paste(info, collapse = "; ")
[10:22:46.787]                           if (!has_future) {
[10:22:46.787]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:46.787]                               info)
[10:22:46.787]                           }
[10:22:46.787]                           else {
[10:22:46.787]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:46.787]                               info, version)
[10:22:46.787]                           }
[10:22:46.787]                           base::stop(msg)
[10:22:46.787]                         }
[10:22:46.787]                       })
[10:22:46.787]                     }
[10:22:46.787]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:46.787]                     base::options(mc.cores = 1L)
[10:22:46.787]                   }
[10:22:46.787]                   ...future.strategy.old <- future::plan("list")
[10:22:46.787]                   options(future.plan = NULL)
[10:22:46.787]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:46.787]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:46.787]                 }
[10:22:46.787]                 ...future.workdir <- getwd()
[10:22:46.787]             }
[10:22:46.787]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:46.787]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:46.787]         }
[10:22:46.787]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:46.787]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:46.787]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:46.787]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:46.787]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:46.787]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:46.787]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:46.787]             base::names(...future.oldOptions))
[10:22:46.787]     }
[10:22:46.787]     if (FALSE) {
[10:22:46.787]     }
[10:22:46.787]     else {
[10:22:46.787]         if (TRUE) {
[10:22:46.787]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:46.787]                 open = "w")
[10:22:46.787]         }
[10:22:46.787]         else {
[10:22:46.787]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:46.787]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:46.787]         }
[10:22:46.787]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:46.787]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:46.787]             base::sink(type = "output", split = FALSE)
[10:22:46.787]             base::close(...future.stdout)
[10:22:46.787]         }, add = TRUE)
[10:22:46.787]     }
[10:22:46.787]     ...future.frame <- base::sys.nframe()
[10:22:46.787]     ...future.conditions <- base::list()
[10:22:46.787]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:46.787]     if (FALSE) {
[10:22:46.787]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:46.787]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:46.787]     }
[10:22:46.787]     ...future.result <- base::tryCatch({
[10:22:46.787]         base::withCallingHandlers({
[10:22:46.787]             ...future.value <- base::withVisible(base::local({
[10:22:46.787]                 ...future.makeSendCondition <- base::local({
[10:22:46.787]                   sendCondition <- NULL
[10:22:46.787]                   function(frame = 1L) {
[10:22:46.787]                     if (is.function(sendCondition)) 
[10:22:46.787]                       return(sendCondition)
[10:22:46.787]                     ns <- getNamespace("parallel")
[10:22:46.787]                     if (exists("sendData", mode = "function", 
[10:22:46.787]                       envir = ns)) {
[10:22:46.787]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:46.787]                         envir = ns)
[10:22:46.787]                       envir <- sys.frame(frame)
[10:22:46.787]                       master <- NULL
[10:22:46.787]                       while (!identical(envir, .GlobalEnv) && 
[10:22:46.787]                         !identical(envir, emptyenv())) {
[10:22:46.787]                         if (exists("master", mode = "list", envir = envir, 
[10:22:46.787]                           inherits = FALSE)) {
[10:22:46.787]                           master <- get("master", mode = "list", 
[10:22:46.787]                             envir = envir, inherits = FALSE)
[10:22:46.787]                           if (inherits(master, c("SOCKnode", 
[10:22:46.787]                             "SOCK0node"))) {
[10:22:46.787]                             sendCondition <<- function(cond) {
[10:22:46.787]                               data <- list(type = "VALUE", value = cond, 
[10:22:46.787]                                 success = TRUE)
[10:22:46.787]                               parallel_sendData(master, data)
[10:22:46.787]                             }
[10:22:46.787]                             return(sendCondition)
[10:22:46.787]                           }
[10:22:46.787]                         }
[10:22:46.787]                         frame <- frame + 1L
[10:22:46.787]                         envir <- sys.frame(frame)
[10:22:46.787]                       }
[10:22:46.787]                     }
[10:22:46.787]                     sendCondition <<- function(cond) NULL
[10:22:46.787]                   }
[10:22:46.787]                 })
[10:22:46.787]                 withCallingHandlers({
[10:22:46.787]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:22:46.787]                 }, immediateCondition = function(cond) {
[10:22:46.787]                   sendCondition <- ...future.makeSendCondition()
[10:22:46.787]                   sendCondition(cond)
[10:22:46.787]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:46.787]                   {
[10:22:46.787]                     inherits <- base::inherits
[10:22:46.787]                     invokeRestart <- base::invokeRestart
[10:22:46.787]                     is.null <- base::is.null
[10:22:46.787]                     muffled <- FALSE
[10:22:46.787]                     if (inherits(cond, "message")) {
[10:22:46.787]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:46.787]                       if (muffled) 
[10:22:46.787]                         invokeRestart("muffleMessage")
[10:22:46.787]                     }
[10:22:46.787]                     else if (inherits(cond, "warning")) {
[10:22:46.787]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:46.787]                       if (muffled) 
[10:22:46.787]                         invokeRestart("muffleWarning")
[10:22:46.787]                     }
[10:22:46.787]                     else if (inherits(cond, "condition")) {
[10:22:46.787]                       if (!is.null(pattern)) {
[10:22:46.787]                         computeRestarts <- base::computeRestarts
[10:22:46.787]                         grepl <- base::grepl
[10:22:46.787]                         restarts <- computeRestarts(cond)
[10:22:46.787]                         for (restart in restarts) {
[10:22:46.787]                           name <- restart$name
[10:22:46.787]                           if (is.null(name)) 
[10:22:46.787]                             next
[10:22:46.787]                           if (!grepl(pattern, name)) 
[10:22:46.787]                             next
[10:22:46.787]                           invokeRestart(restart)
[10:22:46.787]                           muffled <- TRUE
[10:22:46.787]                           break
[10:22:46.787]                         }
[10:22:46.787]                       }
[10:22:46.787]                     }
[10:22:46.787]                     invisible(muffled)
[10:22:46.787]                   }
[10:22:46.787]                   muffleCondition(cond)
[10:22:46.787]                 })
[10:22:46.787]             }))
[10:22:46.787]             future::FutureResult(value = ...future.value$value, 
[10:22:46.787]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:46.787]                   ...future.rng), globalenv = if (FALSE) 
[10:22:46.787]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:46.787]                     ...future.globalenv.names))
[10:22:46.787]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:46.787]         }, condition = base::local({
[10:22:46.787]             c <- base::c
[10:22:46.787]             inherits <- base::inherits
[10:22:46.787]             invokeRestart <- base::invokeRestart
[10:22:46.787]             length <- base::length
[10:22:46.787]             list <- base::list
[10:22:46.787]             seq.int <- base::seq.int
[10:22:46.787]             signalCondition <- base::signalCondition
[10:22:46.787]             sys.calls <- base::sys.calls
[10:22:46.787]             `[[` <- base::`[[`
[10:22:46.787]             `+` <- base::`+`
[10:22:46.787]             `<<-` <- base::`<<-`
[10:22:46.787]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:46.787]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:46.787]                   3L)]
[10:22:46.787]             }
[10:22:46.787]             function(cond) {
[10:22:46.787]                 is_error <- inherits(cond, "error")
[10:22:46.787]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:46.787]                   NULL)
[10:22:46.787]                 if (is_error) {
[10:22:46.787]                   sessionInformation <- function() {
[10:22:46.787]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:46.787]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:46.787]                       search = base::search(), system = base::Sys.info())
[10:22:46.787]                   }
[10:22:46.787]                   ...future.conditions[[length(...future.conditions) + 
[10:22:46.787]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:46.787]                     cond$call), session = sessionInformation(), 
[10:22:46.787]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:46.787]                   signalCondition(cond)
[10:22:46.787]                 }
[10:22:46.787]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:46.787]                 "immediateCondition"))) {
[10:22:46.787]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:46.787]                   ...future.conditions[[length(...future.conditions) + 
[10:22:46.787]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:46.787]                   if (TRUE && !signal) {
[10:22:46.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:46.787]                     {
[10:22:46.787]                       inherits <- base::inherits
[10:22:46.787]                       invokeRestart <- base::invokeRestart
[10:22:46.787]                       is.null <- base::is.null
[10:22:46.787]                       muffled <- FALSE
[10:22:46.787]                       if (inherits(cond, "message")) {
[10:22:46.787]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:46.787]                         if (muffled) 
[10:22:46.787]                           invokeRestart("muffleMessage")
[10:22:46.787]                       }
[10:22:46.787]                       else if (inherits(cond, "warning")) {
[10:22:46.787]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:46.787]                         if (muffled) 
[10:22:46.787]                           invokeRestart("muffleWarning")
[10:22:46.787]                       }
[10:22:46.787]                       else if (inherits(cond, "condition")) {
[10:22:46.787]                         if (!is.null(pattern)) {
[10:22:46.787]                           computeRestarts <- base::computeRestarts
[10:22:46.787]                           grepl <- base::grepl
[10:22:46.787]                           restarts <- computeRestarts(cond)
[10:22:46.787]                           for (restart in restarts) {
[10:22:46.787]                             name <- restart$name
[10:22:46.787]                             if (is.null(name)) 
[10:22:46.787]                               next
[10:22:46.787]                             if (!grepl(pattern, name)) 
[10:22:46.787]                               next
[10:22:46.787]                             invokeRestart(restart)
[10:22:46.787]                             muffled <- TRUE
[10:22:46.787]                             break
[10:22:46.787]                           }
[10:22:46.787]                         }
[10:22:46.787]                       }
[10:22:46.787]                       invisible(muffled)
[10:22:46.787]                     }
[10:22:46.787]                     muffleCondition(cond, pattern = "^muffle")
[10:22:46.787]                   }
[10:22:46.787]                 }
[10:22:46.787]                 else {
[10:22:46.787]                   if (TRUE) {
[10:22:46.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:46.787]                     {
[10:22:46.787]                       inherits <- base::inherits
[10:22:46.787]                       invokeRestart <- base::invokeRestart
[10:22:46.787]                       is.null <- base::is.null
[10:22:46.787]                       muffled <- FALSE
[10:22:46.787]                       if (inherits(cond, "message")) {
[10:22:46.787]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:46.787]                         if (muffled) 
[10:22:46.787]                           invokeRestart("muffleMessage")
[10:22:46.787]                       }
[10:22:46.787]                       else if (inherits(cond, "warning")) {
[10:22:46.787]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:46.787]                         if (muffled) 
[10:22:46.787]                           invokeRestart("muffleWarning")
[10:22:46.787]                       }
[10:22:46.787]                       else if (inherits(cond, "condition")) {
[10:22:46.787]                         if (!is.null(pattern)) {
[10:22:46.787]                           computeRestarts <- base::computeRestarts
[10:22:46.787]                           grepl <- base::grepl
[10:22:46.787]                           restarts <- computeRestarts(cond)
[10:22:46.787]                           for (restart in restarts) {
[10:22:46.787]                             name <- restart$name
[10:22:46.787]                             if (is.null(name)) 
[10:22:46.787]                               next
[10:22:46.787]                             if (!grepl(pattern, name)) 
[10:22:46.787]                               next
[10:22:46.787]                             invokeRestart(restart)
[10:22:46.787]                             muffled <- TRUE
[10:22:46.787]                             break
[10:22:46.787]                           }
[10:22:46.787]                         }
[10:22:46.787]                       }
[10:22:46.787]                       invisible(muffled)
[10:22:46.787]                     }
[10:22:46.787]                     muffleCondition(cond, pattern = "^muffle")
[10:22:46.787]                   }
[10:22:46.787]                 }
[10:22:46.787]             }
[10:22:46.787]         }))
[10:22:46.787]     }, error = function(ex) {
[10:22:46.787]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:46.787]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:46.787]                 ...future.rng), started = ...future.startTime, 
[10:22:46.787]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:46.787]             version = "1.8"), class = "FutureResult")
[10:22:46.787]     }, finally = {
[10:22:46.787]         if (!identical(...future.workdir, getwd())) 
[10:22:46.787]             setwd(...future.workdir)
[10:22:46.787]         {
[10:22:46.787]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:46.787]                 ...future.oldOptions$nwarnings <- NULL
[10:22:46.787]             }
[10:22:46.787]             base::options(...future.oldOptions)
[10:22:46.787]             if (.Platform$OS.type == "windows") {
[10:22:46.787]                 old_names <- names(...future.oldEnvVars)
[10:22:46.787]                 envs <- base::Sys.getenv()
[10:22:46.787]                 names <- names(envs)
[10:22:46.787]                 common <- intersect(names, old_names)
[10:22:46.787]                 added <- setdiff(names, old_names)
[10:22:46.787]                 removed <- setdiff(old_names, names)
[10:22:46.787]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:46.787]                   envs[common]]
[10:22:46.787]                 NAMES <- toupper(changed)
[10:22:46.787]                 args <- list()
[10:22:46.787]                 for (kk in seq_along(NAMES)) {
[10:22:46.787]                   name <- changed[[kk]]
[10:22:46.787]                   NAME <- NAMES[[kk]]
[10:22:46.787]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:46.787]                     next
[10:22:46.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:46.787]                 }
[10:22:46.787]                 NAMES <- toupper(added)
[10:22:46.787]                 for (kk in seq_along(NAMES)) {
[10:22:46.787]                   name <- added[[kk]]
[10:22:46.787]                   NAME <- NAMES[[kk]]
[10:22:46.787]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:46.787]                     next
[10:22:46.787]                   args[[name]] <- ""
[10:22:46.787]                 }
[10:22:46.787]                 NAMES <- toupper(removed)
[10:22:46.787]                 for (kk in seq_along(NAMES)) {
[10:22:46.787]                   name <- removed[[kk]]
[10:22:46.787]                   NAME <- NAMES[[kk]]
[10:22:46.787]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:46.787]                     next
[10:22:46.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:46.787]                 }
[10:22:46.787]                 if (length(args) > 0) 
[10:22:46.787]                   base::do.call(base::Sys.setenv, args = args)
[10:22:46.787]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:46.787]             }
[10:22:46.787]             else {
[10:22:46.787]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:46.787]             }
[10:22:46.787]             {
[10:22:46.787]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:46.787]                   0L) {
[10:22:46.787]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:46.787]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:46.787]                   base::options(opts)
[10:22:46.787]                 }
[10:22:46.787]                 {
[10:22:46.787]                   {
[10:22:46.787]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:46.787]                     NULL
[10:22:46.787]                   }
[10:22:46.787]                   options(future.plan = NULL)
[10:22:46.787]                   if (is.na(NA_character_)) 
[10:22:46.787]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:46.787]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:46.787]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:46.787]                     .init = FALSE)
[10:22:46.787]                 }
[10:22:46.787]             }
[10:22:46.787]         }
[10:22:46.787]     })
[10:22:46.787]     if (TRUE) {
[10:22:46.787]         base::sink(type = "output", split = FALSE)
[10:22:46.787]         if (TRUE) {
[10:22:46.787]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:46.787]         }
[10:22:46.787]         else {
[10:22:46.787]             ...future.result["stdout"] <- base::list(NULL)
[10:22:46.787]         }
[10:22:46.787]         base::close(...future.stdout)
[10:22:46.787]         ...future.stdout <- NULL
[10:22:46.787]     }
[10:22:46.787]     ...future.result$conditions <- ...future.conditions
[10:22:46.787]     ...future.result$finished <- base::Sys.time()
[10:22:46.787]     ...future.result
[10:22:46.787] }
[10:22:46.790] MultisessionFuture started
[10:22:46.790] - Launch lazy future ... done
[10:22:46.790] run() for ‘MultisessionFuture’ ... done
[10:22:46.833] receiveMessageFromWorker() for ClusterFuture ...
[10:22:46.833] - Validating connection of MultisessionFuture
[10:22:46.833] - received message: FutureResult
[10:22:46.833] - Received FutureResult
[10:22:46.833] - Erased future from FutureRegistry
[10:22:46.834] result() for ClusterFuture ...
[10:22:46.834] - result already collected: FutureResult
[10:22:46.834] result() for ClusterFuture ... done
[10:22:46.834] signalConditions() ...
[10:22:46.834]  - include = ‘immediateCondition’
[10:22:46.834]  - exclude = 
[10:22:46.834]  - resignal = FALSE
[10:22:46.834]  - Number of conditions: 1
[10:22:46.834] signalConditions() ... done
[10:22:46.834] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:46.834] A MultisessionFuture was resolved (and resolved itself)
[10:22:46.835] getGlobalsAndPackages() ...
[10:22:46.835] Searching for globals...
[10:22:46.835] - globals found: [2] ‘list’, ‘stop’
[10:22:46.835] Searching for globals ... DONE
[10:22:46.836] Resolving globals: FALSE
[10:22:46.836] 
[10:22:46.836] 
[10:22:46.836] getGlobalsAndPackages() ... DONE
[10:22:46.836] run() for ‘Future’ ...
[10:22:46.836] - state: ‘created’
[10:22:46.836] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:46.850] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:46.850] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:46.850]   - Field: ‘node’
[10:22:46.850]   - Field: ‘label’
[10:22:46.851]   - Field: ‘local’
[10:22:46.851]   - Field: ‘owner’
[10:22:46.851]   - Field: ‘envir’
[10:22:46.851]   - Field: ‘workers’
[10:22:46.851]   - Field: ‘packages’
[10:22:46.851]   - Field: ‘gc’
[10:22:46.851]   - Field: ‘conditions’
[10:22:46.851]   - Field: ‘persistent’
[10:22:46.851]   - Field: ‘expr’
[10:22:46.851]   - Field: ‘uuid’
[10:22:46.851]   - Field: ‘seed’
[10:22:46.852]   - Field: ‘version’
[10:22:46.852]   - Field: ‘result’
[10:22:46.852]   - Field: ‘asynchronous’
[10:22:46.852]   - Field: ‘calls’
[10:22:46.852]   - Field: ‘globals’
[10:22:46.852]   - Field: ‘stdout’
[10:22:46.852]   - Field: ‘earlySignal’
[10:22:46.852]   - Field: ‘lazy’
[10:22:46.852]   - Field: ‘state’
[10:22:46.852] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:46.852] - Launch lazy future ...
[10:22:46.853] Packages needed by the future expression (n = 0): <none>
[10:22:46.853] Packages needed by future strategies (n = 0): <none>
[10:22:46.853] {
[10:22:46.853]     {
[10:22:46.853]         {
[10:22:46.853]             ...future.startTime <- base::Sys.time()
[10:22:46.853]             {
[10:22:46.853]                 {
[10:22:46.853]                   {
[10:22:46.853]                     {
[10:22:46.853]                       base::local({
[10:22:46.853]                         has_future <- base::requireNamespace("future", 
[10:22:46.853]                           quietly = TRUE)
[10:22:46.853]                         if (has_future) {
[10:22:46.853]                           ns <- base::getNamespace("future")
[10:22:46.853]                           version <- ns[[".package"]][["version"]]
[10:22:46.853]                           if (is.null(version)) 
[10:22:46.853]                             version <- utils::packageVersion("future")
[10:22:46.853]                         }
[10:22:46.853]                         else {
[10:22:46.853]                           version <- NULL
[10:22:46.853]                         }
[10:22:46.853]                         if (!has_future || version < "1.8.0") {
[10:22:46.853]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:46.853]                             "", base::R.version$version.string), 
[10:22:46.853]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:46.853]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:46.853]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:46.853]                               "release", "version")], collapse = " "), 
[10:22:46.853]                             hostname = base::Sys.info()[["nodename"]])
[10:22:46.853]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:46.853]                             info)
[10:22:46.853]                           info <- base::paste(info, collapse = "; ")
[10:22:46.853]                           if (!has_future) {
[10:22:46.853]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:46.853]                               info)
[10:22:46.853]                           }
[10:22:46.853]                           else {
[10:22:46.853]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:46.853]                               info, version)
[10:22:46.853]                           }
[10:22:46.853]                           base::stop(msg)
[10:22:46.853]                         }
[10:22:46.853]                       })
[10:22:46.853]                     }
[10:22:46.853]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:46.853]                     base::options(mc.cores = 1L)
[10:22:46.853]                   }
[10:22:46.853]                   ...future.strategy.old <- future::plan("list")
[10:22:46.853]                   options(future.plan = NULL)
[10:22:46.853]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:46.853]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:46.853]                 }
[10:22:46.853]                 ...future.workdir <- getwd()
[10:22:46.853]             }
[10:22:46.853]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:46.853]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:46.853]         }
[10:22:46.853]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:46.853]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:46.853]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:46.853]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:46.853]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:46.853]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:46.853]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:46.853]             base::names(...future.oldOptions))
[10:22:46.853]     }
[10:22:46.853]     if (FALSE) {
[10:22:46.853]     }
[10:22:46.853]     else {
[10:22:46.853]         if (TRUE) {
[10:22:46.853]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:46.853]                 open = "w")
[10:22:46.853]         }
[10:22:46.853]         else {
[10:22:46.853]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:46.853]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:46.853]         }
[10:22:46.853]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:46.853]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:46.853]             base::sink(type = "output", split = FALSE)
[10:22:46.853]             base::close(...future.stdout)
[10:22:46.853]         }, add = TRUE)
[10:22:46.853]     }
[10:22:46.853]     ...future.frame <- base::sys.nframe()
[10:22:46.853]     ...future.conditions <- base::list()
[10:22:46.853]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:46.853]     if (FALSE) {
[10:22:46.853]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:46.853]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:46.853]     }
[10:22:46.853]     ...future.result <- base::tryCatch({
[10:22:46.853]         base::withCallingHandlers({
[10:22:46.853]             ...future.value <- base::withVisible(base::local({
[10:22:46.853]                 ...future.makeSendCondition <- base::local({
[10:22:46.853]                   sendCondition <- NULL
[10:22:46.853]                   function(frame = 1L) {
[10:22:46.853]                     if (is.function(sendCondition)) 
[10:22:46.853]                       return(sendCondition)
[10:22:46.853]                     ns <- getNamespace("parallel")
[10:22:46.853]                     if (exists("sendData", mode = "function", 
[10:22:46.853]                       envir = ns)) {
[10:22:46.853]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:46.853]                         envir = ns)
[10:22:46.853]                       envir <- sys.frame(frame)
[10:22:46.853]                       master <- NULL
[10:22:46.853]                       while (!identical(envir, .GlobalEnv) && 
[10:22:46.853]                         !identical(envir, emptyenv())) {
[10:22:46.853]                         if (exists("master", mode = "list", envir = envir, 
[10:22:46.853]                           inherits = FALSE)) {
[10:22:46.853]                           master <- get("master", mode = "list", 
[10:22:46.853]                             envir = envir, inherits = FALSE)
[10:22:46.853]                           if (inherits(master, c("SOCKnode", 
[10:22:46.853]                             "SOCK0node"))) {
[10:22:46.853]                             sendCondition <<- function(cond) {
[10:22:46.853]                               data <- list(type = "VALUE", value = cond, 
[10:22:46.853]                                 success = TRUE)
[10:22:46.853]                               parallel_sendData(master, data)
[10:22:46.853]                             }
[10:22:46.853]                             return(sendCondition)
[10:22:46.853]                           }
[10:22:46.853]                         }
[10:22:46.853]                         frame <- frame + 1L
[10:22:46.853]                         envir <- sys.frame(frame)
[10:22:46.853]                       }
[10:22:46.853]                     }
[10:22:46.853]                     sendCondition <<- function(cond) NULL
[10:22:46.853]                   }
[10:22:46.853]                 })
[10:22:46.853]                 withCallingHandlers({
[10:22:46.853]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:22:46.853]                 }, immediateCondition = function(cond) {
[10:22:46.853]                   sendCondition <- ...future.makeSendCondition()
[10:22:46.853]                   sendCondition(cond)
[10:22:46.853]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:46.853]                   {
[10:22:46.853]                     inherits <- base::inherits
[10:22:46.853]                     invokeRestart <- base::invokeRestart
[10:22:46.853]                     is.null <- base::is.null
[10:22:46.853]                     muffled <- FALSE
[10:22:46.853]                     if (inherits(cond, "message")) {
[10:22:46.853]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:46.853]                       if (muffled) 
[10:22:46.853]                         invokeRestart("muffleMessage")
[10:22:46.853]                     }
[10:22:46.853]                     else if (inherits(cond, "warning")) {
[10:22:46.853]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:46.853]                       if (muffled) 
[10:22:46.853]                         invokeRestart("muffleWarning")
[10:22:46.853]                     }
[10:22:46.853]                     else if (inherits(cond, "condition")) {
[10:22:46.853]                       if (!is.null(pattern)) {
[10:22:46.853]                         computeRestarts <- base::computeRestarts
[10:22:46.853]                         grepl <- base::grepl
[10:22:46.853]                         restarts <- computeRestarts(cond)
[10:22:46.853]                         for (restart in restarts) {
[10:22:46.853]                           name <- restart$name
[10:22:46.853]                           if (is.null(name)) 
[10:22:46.853]                             next
[10:22:46.853]                           if (!grepl(pattern, name)) 
[10:22:46.853]                             next
[10:22:46.853]                           invokeRestart(restart)
[10:22:46.853]                           muffled <- TRUE
[10:22:46.853]                           break
[10:22:46.853]                         }
[10:22:46.853]                       }
[10:22:46.853]                     }
[10:22:46.853]                     invisible(muffled)
[10:22:46.853]                   }
[10:22:46.853]                   muffleCondition(cond)
[10:22:46.853]                 })
[10:22:46.853]             }))
[10:22:46.853]             future::FutureResult(value = ...future.value$value, 
[10:22:46.853]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:46.853]                   ...future.rng), globalenv = if (FALSE) 
[10:22:46.853]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:46.853]                     ...future.globalenv.names))
[10:22:46.853]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:46.853]         }, condition = base::local({
[10:22:46.853]             c <- base::c
[10:22:46.853]             inherits <- base::inherits
[10:22:46.853]             invokeRestart <- base::invokeRestart
[10:22:46.853]             length <- base::length
[10:22:46.853]             list <- base::list
[10:22:46.853]             seq.int <- base::seq.int
[10:22:46.853]             signalCondition <- base::signalCondition
[10:22:46.853]             sys.calls <- base::sys.calls
[10:22:46.853]             `[[` <- base::`[[`
[10:22:46.853]             `+` <- base::`+`
[10:22:46.853]             `<<-` <- base::`<<-`
[10:22:46.853]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:46.853]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:46.853]                   3L)]
[10:22:46.853]             }
[10:22:46.853]             function(cond) {
[10:22:46.853]                 is_error <- inherits(cond, "error")
[10:22:46.853]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:46.853]                   NULL)
[10:22:46.853]                 if (is_error) {
[10:22:46.853]                   sessionInformation <- function() {
[10:22:46.853]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:46.853]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:46.853]                       search = base::search(), system = base::Sys.info())
[10:22:46.853]                   }
[10:22:46.853]                   ...future.conditions[[length(...future.conditions) + 
[10:22:46.853]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:46.853]                     cond$call), session = sessionInformation(), 
[10:22:46.853]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:46.853]                   signalCondition(cond)
[10:22:46.853]                 }
[10:22:46.853]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:46.853]                 "immediateCondition"))) {
[10:22:46.853]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:46.853]                   ...future.conditions[[length(...future.conditions) + 
[10:22:46.853]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:46.853]                   if (TRUE && !signal) {
[10:22:46.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:46.853]                     {
[10:22:46.853]                       inherits <- base::inherits
[10:22:46.853]                       invokeRestart <- base::invokeRestart
[10:22:46.853]                       is.null <- base::is.null
[10:22:46.853]                       muffled <- FALSE
[10:22:46.853]                       if (inherits(cond, "message")) {
[10:22:46.853]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:46.853]                         if (muffled) 
[10:22:46.853]                           invokeRestart("muffleMessage")
[10:22:46.853]                       }
[10:22:46.853]                       else if (inherits(cond, "warning")) {
[10:22:46.853]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:46.853]                         if (muffled) 
[10:22:46.853]                           invokeRestart("muffleWarning")
[10:22:46.853]                       }
[10:22:46.853]                       else if (inherits(cond, "condition")) {
[10:22:46.853]                         if (!is.null(pattern)) {
[10:22:46.853]                           computeRestarts <- base::computeRestarts
[10:22:46.853]                           grepl <- base::grepl
[10:22:46.853]                           restarts <- computeRestarts(cond)
[10:22:46.853]                           for (restart in restarts) {
[10:22:46.853]                             name <- restart$name
[10:22:46.853]                             if (is.null(name)) 
[10:22:46.853]                               next
[10:22:46.853]                             if (!grepl(pattern, name)) 
[10:22:46.853]                               next
[10:22:46.853]                             invokeRestart(restart)
[10:22:46.853]                             muffled <- TRUE
[10:22:46.853]                             break
[10:22:46.853]                           }
[10:22:46.853]                         }
[10:22:46.853]                       }
[10:22:46.853]                       invisible(muffled)
[10:22:46.853]                     }
[10:22:46.853]                     muffleCondition(cond, pattern = "^muffle")
[10:22:46.853]                   }
[10:22:46.853]                 }
[10:22:46.853]                 else {
[10:22:46.853]                   if (TRUE) {
[10:22:46.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:46.853]                     {
[10:22:46.853]                       inherits <- base::inherits
[10:22:46.853]                       invokeRestart <- base::invokeRestart
[10:22:46.853]                       is.null <- base::is.null
[10:22:46.853]                       muffled <- FALSE
[10:22:46.853]                       if (inherits(cond, "message")) {
[10:22:46.853]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:46.853]                         if (muffled) 
[10:22:46.853]                           invokeRestart("muffleMessage")
[10:22:46.853]                       }
[10:22:46.853]                       else if (inherits(cond, "warning")) {
[10:22:46.853]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:46.853]                         if (muffled) 
[10:22:46.853]                           invokeRestart("muffleWarning")
[10:22:46.853]                       }
[10:22:46.853]                       else if (inherits(cond, "condition")) {
[10:22:46.853]                         if (!is.null(pattern)) {
[10:22:46.853]                           computeRestarts <- base::computeRestarts
[10:22:46.853]                           grepl <- base::grepl
[10:22:46.853]                           restarts <- computeRestarts(cond)
[10:22:46.853]                           for (restart in restarts) {
[10:22:46.853]                             name <- restart$name
[10:22:46.853]                             if (is.null(name)) 
[10:22:46.853]                               next
[10:22:46.853]                             if (!grepl(pattern, name)) 
[10:22:46.853]                               next
[10:22:46.853]                             invokeRestart(restart)
[10:22:46.853]                             muffled <- TRUE
[10:22:46.853]                             break
[10:22:46.853]                           }
[10:22:46.853]                         }
[10:22:46.853]                       }
[10:22:46.853]                       invisible(muffled)
[10:22:46.853]                     }
[10:22:46.853]                     muffleCondition(cond, pattern = "^muffle")
[10:22:46.853]                   }
[10:22:46.853]                 }
[10:22:46.853]             }
[10:22:46.853]         }))
[10:22:46.853]     }, error = function(ex) {
[10:22:46.853]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:46.853]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:46.853]                 ...future.rng), started = ...future.startTime, 
[10:22:46.853]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:46.853]             version = "1.8"), class = "FutureResult")
[10:22:46.853]     }, finally = {
[10:22:46.853]         if (!identical(...future.workdir, getwd())) 
[10:22:46.853]             setwd(...future.workdir)
[10:22:46.853]         {
[10:22:46.853]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:46.853]                 ...future.oldOptions$nwarnings <- NULL
[10:22:46.853]             }
[10:22:46.853]             base::options(...future.oldOptions)
[10:22:46.853]             if (.Platform$OS.type == "windows") {
[10:22:46.853]                 old_names <- names(...future.oldEnvVars)
[10:22:46.853]                 envs <- base::Sys.getenv()
[10:22:46.853]                 names <- names(envs)
[10:22:46.853]                 common <- intersect(names, old_names)
[10:22:46.853]                 added <- setdiff(names, old_names)
[10:22:46.853]                 removed <- setdiff(old_names, names)
[10:22:46.853]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:46.853]                   envs[common]]
[10:22:46.853]                 NAMES <- toupper(changed)
[10:22:46.853]                 args <- list()
[10:22:46.853]                 for (kk in seq_along(NAMES)) {
[10:22:46.853]                   name <- changed[[kk]]
[10:22:46.853]                   NAME <- NAMES[[kk]]
[10:22:46.853]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:46.853]                     next
[10:22:46.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:46.853]                 }
[10:22:46.853]                 NAMES <- toupper(added)
[10:22:46.853]                 for (kk in seq_along(NAMES)) {
[10:22:46.853]                   name <- added[[kk]]
[10:22:46.853]                   NAME <- NAMES[[kk]]
[10:22:46.853]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:46.853]                     next
[10:22:46.853]                   args[[name]] <- ""
[10:22:46.853]                 }
[10:22:46.853]                 NAMES <- toupper(removed)
[10:22:46.853]                 for (kk in seq_along(NAMES)) {
[10:22:46.853]                   name <- removed[[kk]]
[10:22:46.853]                   NAME <- NAMES[[kk]]
[10:22:46.853]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:46.853]                     next
[10:22:46.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:46.853]                 }
[10:22:46.853]                 if (length(args) > 0) 
[10:22:46.853]                   base::do.call(base::Sys.setenv, args = args)
[10:22:46.853]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:46.853]             }
[10:22:46.853]             else {
[10:22:46.853]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:46.853]             }
[10:22:46.853]             {
[10:22:46.853]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:46.853]                   0L) {
[10:22:46.853]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:46.853]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:46.853]                   base::options(opts)
[10:22:46.853]                 }
[10:22:46.853]                 {
[10:22:46.853]                   {
[10:22:46.853]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:46.853]                     NULL
[10:22:46.853]                   }
[10:22:46.853]                   options(future.plan = NULL)
[10:22:46.853]                   if (is.na(NA_character_)) 
[10:22:46.853]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:46.853]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:46.853]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:46.853]                     .init = FALSE)
[10:22:46.853]                 }
[10:22:46.853]             }
[10:22:46.853]         }
[10:22:46.853]     })
[10:22:46.853]     if (TRUE) {
[10:22:46.853]         base::sink(type = "output", split = FALSE)
[10:22:46.853]         if (TRUE) {
[10:22:46.853]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:46.853]         }
[10:22:46.853]         else {
[10:22:46.853]             ...future.result["stdout"] <- base::list(NULL)
[10:22:46.853]         }
[10:22:46.853]         base::close(...future.stdout)
[10:22:46.853]         ...future.stdout <- NULL
[10:22:46.853]     }
[10:22:46.853]     ...future.result$conditions <- ...future.conditions
[10:22:46.853]     ...future.result$finished <- base::Sys.time()
[10:22:46.853]     ...future.result
[10:22:46.853] }
[10:22:46.856] MultisessionFuture started
[10:22:46.856] - Launch lazy future ... done
[10:22:46.856] run() for ‘MultisessionFuture’ ... done
[10:22:46.898] receiveMessageFromWorker() for ClusterFuture ...
[10:22:46.898] - Validating connection of MultisessionFuture
[10:22:46.899] - received message: FutureResult
[10:22:46.899] - Received FutureResult
[10:22:46.899] - Erased future from FutureRegistry
[10:22:46.899] result() for ClusterFuture ...
[10:22:46.899] - result already collected: FutureResult
[10:22:46.899] result() for ClusterFuture ... done
[10:22:46.899] signalConditions() ...
[10:22:46.899]  - include = ‘immediateCondition’
[10:22:46.900]  - exclude = 
[10:22:46.900]  - resignal = FALSE
[10:22:46.900]  - Number of conditions: 1
[10:22:46.900] signalConditions() ... done
[10:22:46.900] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:46.900] A MultisessionFuture was resolved (and resolved itself)
- result = TRUE, recursive = 2 ... DONE
- result = TRUE, recursive = Inf ...
[10:22:46.900] getGlobalsAndPackages() ...
[10:22:46.900] Searching for globals...
[10:22:46.901] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:22:46.901] Searching for globals ... DONE
[10:22:46.902] Resolving globals: FALSE
[10:22:46.902] 
[10:22:46.902] 
[10:22:46.902] getGlobalsAndPackages() ... DONE
[10:22:46.902] run() for ‘Future’ ...
[10:22:46.902] - state: ‘created’
[10:22:46.902] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:46.916] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:46.916] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:46.916]   - Field: ‘node’
[10:22:46.916]   - Field: ‘label’
[10:22:46.917]   - Field: ‘local’
[10:22:46.917]   - Field: ‘owner’
[10:22:46.917]   - Field: ‘envir’
[10:22:46.917]   - Field: ‘workers’
[10:22:46.917]   - Field: ‘packages’
[10:22:46.917]   - Field: ‘gc’
[10:22:46.917]   - Field: ‘conditions’
[10:22:46.917]   - Field: ‘persistent’
[10:22:46.917]   - Field: ‘expr’
[10:22:46.917]   - Field: ‘uuid’
[10:22:46.917]   - Field: ‘seed’
[10:22:46.917]   - Field: ‘version’
[10:22:46.918]   - Field: ‘result’
[10:22:46.918]   - Field: ‘asynchronous’
[10:22:46.918]   - Field: ‘calls’
[10:22:46.918]   - Field: ‘globals’
[10:22:46.918]   - Field: ‘stdout’
[10:22:46.918]   - Field: ‘earlySignal’
[10:22:46.918]   - Field: ‘lazy’
[10:22:46.918]   - Field: ‘state’
[10:22:46.918] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:46.918] - Launch lazy future ...
[10:22:46.919] Packages needed by the future expression (n = 0): <none>
[10:22:46.919] Packages needed by future strategies (n = 0): <none>
[10:22:46.919] {
[10:22:46.919]     {
[10:22:46.919]         {
[10:22:46.919]             ...future.startTime <- base::Sys.time()
[10:22:46.919]             {
[10:22:46.919]                 {
[10:22:46.919]                   {
[10:22:46.919]                     {
[10:22:46.919]                       base::local({
[10:22:46.919]                         has_future <- base::requireNamespace("future", 
[10:22:46.919]                           quietly = TRUE)
[10:22:46.919]                         if (has_future) {
[10:22:46.919]                           ns <- base::getNamespace("future")
[10:22:46.919]                           version <- ns[[".package"]][["version"]]
[10:22:46.919]                           if (is.null(version)) 
[10:22:46.919]                             version <- utils::packageVersion("future")
[10:22:46.919]                         }
[10:22:46.919]                         else {
[10:22:46.919]                           version <- NULL
[10:22:46.919]                         }
[10:22:46.919]                         if (!has_future || version < "1.8.0") {
[10:22:46.919]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:46.919]                             "", base::R.version$version.string), 
[10:22:46.919]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:46.919]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:46.919]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:46.919]                               "release", "version")], collapse = " "), 
[10:22:46.919]                             hostname = base::Sys.info()[["nodename"]])
[10:22:46.919]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:46.919]                             info)
[10:22:46.919]                           info <- base::paste(info, collapse = "; ")
[10:22:46.919]                           if (!has_future) {
[10:22:46.919]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:46.919]                               info)
[10:22:46.919]                           }
[10:22:46.919]                           else {
[10:22:46.919]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:46.919]                               info, version)
[10:22:46.919]                           }
[10:22:46.919]                           base::stop(msg)
[10:22:46.919]                         }
[10:22:46.919]                       })
[10:22:46.919]                     }
[10:22:46.919]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:46.919]                     base::options(mc.cores = 1L)
[10:22:46.919]                   }
[10:22:46.919]                   ...future.strategy.old <- future::plan("list")
[10:22:46.919]                   options(future.plan = NULL)
[10:22:46.919]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:46.919]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:46.919]                 }
[10:22:46.919]                 ...future.workdir <- getwd()
[10:22:46.919]             }
[10:22:46.919]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:46.919]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:46.919]         }
[10:22:46.919]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:46.919]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:46.919]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:46.919]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:46.919]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:46.919]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:46.919]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:46.919]             base::names(...future.oldOptions))
[10:22:46.919]     }
[10:22:46.919]     if (FALSE) {
[10:22:46.919]     }
[10:22:46.919]     else {
[10:22:46.919]         if (TRUE) {
[10:22:46.919]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:46.919]                 open = "w")
[10:22:46.919]         }
[10:22:46.919]         else {
[10:22:46.919]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:46.919]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:46.919]         }
[10:22:46.919]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:46.919]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:46.919]             base::sink(type = "output", split = FALSE)
[10:22:46.919]             base::close(...future.stdout)
[10:22:46.919]         }, add = TRUE)
[10:22:46.919]     }
[10:22:46.919]     ...future.frame <- base::sys.nframe()
[10:22:46.919]     ...future.conditions <- base::list()
[10:22:46.919]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:46.919]     if (FALSE) {
[10:22:46.919]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:46.919]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:46.919]     }
[10:22:46.919]     ...future.result <- base::tryCatch({
[10:22:46.919]         base::withCallingHandlers({
[10:22:46.919]             ...future.value <- base::withVisible(base::local({
[10:22:46.919]                 ...future.makeSendCondition <- base::local({
[10:22:46.919]                   sendCondition <- NULL
[10:22:46.919]                   function(frame = 1L) {
[10:22:46.919]                     if (is.function(sendCondition)) 
[10:22:46.919]                       return(sendCondition)
[10:22:46.919]                     ns <- getNamespace("parallel")
[10:22:46.919]                     if (exists("sendData", mode = "function", 
[10:22:46.919]                       envir = ns)) {
[10:22:46.919]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:46.919]                         envir = ns)
[10:22:46.919]                       envir <- sys.frame(frame)
[10:22:46.919]                       master <- NULL
[10:22:46.919]                       while (!identical(envir, .GlobalEnv) && 
[10:22:46.919]                         !identical(envir, emptyenv())) {
[10:22:46.919]                         if (exists("master", mode = "list", envir = envir, 
[10:22:46.919]                           inherits = FALSE)) {
[10:22:46.919]                           master <- get("master", mode = "list", 
[10:22:46.919]                             envir = envir, inherits = FALSE)
[10:22:46.919]                           if (inherits(master, c("SOCKnode", 
[10:22:46.919]                             "SOCK0node"))) {
[10:22:46.919]                             sendCondition <<- function(cond) {
[10:22:46.919]                               data <- list(type = "VALUE", value = cond, 
[10:22:46.919]                                 success = TRUE)
[10:22:46.919]                               parallel_sendData(master, data)
[10:22:46.919]                             }
[10:22:46.919]                             return(sendCondition)
[10:22:46.919]                           }
[10:22:46.919]                         }
[10:22:46.919]                         frame <- frame + 1L
[10:22:46.919]                         envir <- sys.frame(frame)
[10:22:46.919]                       }
[10:22:46.919]                     }
[10:22:46.919]                     sendCondition <<- function(cond) NULL
[10:22:46.919]                   }
[10:22:46.919]                 })
[10:22:46.919]                 withCallingHandlers({
[10:22:46.919]                   {
[10:22:46.919]                     Sys.sleep(0.5)
[10:22:46.919]                     list(a = 1, b = 42L)
[10:22:46.919]                   }
[10:22:46.919]                 }, immediateCondition = function(cond) {
[10:22:46.919]                   sendCondition <- ...future.makeSendCondition()
[10:22:46.919]                   sendCondition(cond)
[10:22:46.919]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:46.919]                   {
[10:22:46.919]                     inherits <- base::inherits
[10:22:46.919]                     invokeRestart <- base::invokeRestart
[10:22:46.919]                     is.null <- base::is.null
[10:22:46.919]                     muffled <- FALSE
[10:22:46.919]                     if (inherits(cond, "message")) {
[10:22:46.919]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:46.919]                       if (muffled) 
[10:22:46.919]                         invokeRestart("muffleMessage")
[10:22:46.919]                     }
[10:22:46.919]                     else if (inherits(cond, "warning")) {
[10:22:46.919]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:46.919]                       if (muffled) 
[10:22:46.919]                         invokeRestart("muffleWarning")
[10:22:46.919]                     }
[10:22:46.919]                     else if (inherits(cond, "condition")) {
[10:22:46.919]                       if (!is.null(pattern)) {
[10:22:46.919]                         computeRestarts <- base::computeRestarts
[10:22:46.919]                         grepl <- base::grepl
[10:22:46.919]                         restarts <- computeRestarts(cond)
[10:22:46.919]                         for (restart in restarts) {
[10:22:46.919]                           name <- restart$name
[10:22:46.919]                           if (is.null(name)) 
[10:22:46.919]                             next
[10:22:46.919]                           if (!grepl(pattern, name)) 
[10:22:46.919]                             next
[10:22:46.919]                           invokeRestart(restart)
[10:22:46.919]                           muffled <- TRUE
[10:22:46.919]                           break
[10:22:46.919]                         }
[10:22:46.919]                       }
[10:22:46.919]                     }
[10:22:46.919]                     invisible(muffled)
[10:22:46.919]                   }
[10:22:46.919]                   muffleCondition(cond)
[10:22:46.919]                 })
[10:22:46.919]             }))
[10:22:46.919]             future::FutureResult(value = ...future.value$value, 
[10:22:46.919]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:46.919]                   ...future.rng), globalenv = if (FALSE) 
[10:22:46.919]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:46.919]                     ...future.globalenv.names))
[10:22:46.919]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:46.919]         }, condition = base::local({
[10:22:46.919]             c <- base::c
[10:22:46.919]             inherits <- base::inherits
[10:22:46.919]             invokeRestart <- base::invokeRestart
[10:22:46.919]             length <- base::length
[10:22:46.919]             list <- base::list
[10:22:46.919]             seq.int <- base::seq.int
[10:22:46.919]             signalCondition <- base::signalCondition
[10:22:46.919]             sys.calls <- base::sys.calls
[10:22:46.919]             `[[` <- base::`[[`
[10:22:46.919]             `+` <- base::`+`
[10:22:46.919]             `<<-` <- base::`<<-`
[10:22:46.919]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:46.919]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:46.919]                   3L)]
[10:22:46.919]             }
[10:22:46.919]             function(cond) {
[10:22:46.919]                 is_error <- inherits(cond, "error")
[10:22:46.919]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:46.919]                   NULL)
[10:22:46.919]                 if (is_error) {
[10:22:46.919]                   sessionInformation <- function() {
[10:22:46.919]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:46.919]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:46.919]                       search = base::search(), system = base::Sys.info())
[10:22:46.919]                   }
[10:22:46.919]                   ...future.conditions[[length(...future.conditions) + 
[10:22:46.919]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:46.919]                     cond$call), session = sessionInformation(), 
[10:22:46.919]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:46.919]                   signalCondition(cond)
[10:22:46.919]                 }
[10:22:46.919]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:46.919]                 "immediateCondition"))) {
[10:22:46.919]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:46.919]                   ...future.conditions[[length(...future.conditions) + 
[10:22:46.919]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:46.919]                   if (TRUE && !signal) {
[10:22:46.919]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:46.919]                     {
[10:22:46.919]                       inherits <- base::inherits
[10:22:46.919]                       invokeRestart <- base::invokeRestart
[10:22:46.919]                       is.null <- base::is.null
[10:22:46.919]                       muffled <- FALSE
[10:22:46.919]                       if (inherits(cond, "message")) {
[10:22:46.919]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:46.919]                         if (muffled) 
[10:22:46.919]                           invokeRestart("muffleMessage")
[10:22:46.919]                       }
[10:22:46.919]                       else if (inherits(cond, "warning")) {
[10:22:46.919]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:46.919]                         if (muffled) 
[10:22:46.919]                           invokeRestart("muffleWarning")
[10:22:46.919]                       }
[10:22:46.919]                       else if (inherits(cond, "condition")) {
[10:22:46.919]                         if (!is.null(pattern)) {
[10:22:46.919]                           computeRestarts <- base::computeRestarts
[10:22:46.919]                           grepl <- base::grepl
[10:22:46.919]                           restarts <- computeRestarts(cond)
[10:22:46.919]                           for (restart in restarts) {
[10:22:46.919]                             name <- restart$name
[10:22:46.919]                             if (is.null(name)) 
[10:22:46.919]                               next
[10:22:46.919]                             if (!grepl(pattern, name)) 
[10:22:46.919]                               next
[10:22:46.919]                             invokeRestart(restart)
[10:22:46.919]                             muffled <- TRUE
[10:22:46.919]                             break
[10:22:46.919]                           }
[10:22:46.919]                         }
[10:22:46.919]                       }
[10:22:46.919]                       invisible(muffled)
[10:22:46.919]                     }
[10:22:46.919]                     muffleCondition(cond, pattern = "^muffle")
[10:22:46.919]                   }
[10:22:46.919]                 }
[10:22:46.919]                 else {
[10:22:46.919]                   if (TRUE) {
[10:22:46.919]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:46.919]                     {
[10:22:46.919]                       inherits <- base::inherits
[10:22:46.919]                       invokeRestart <- base::invokeRestart
[10:22:46.919]                       is.null <- base::is.null
[10:22:46.919]                       muffled <- FALSE
[10:22:46.919]                       if (inherits(cond, "message")) {
[10:22:46.919]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:46.919]                         if (muffled) 
[10:22:46.919]                           invokeRestart("muffleMessage")
[10:22:46.919]                       }
[10:22:46.919]                       else if (inherits(cond, "warning")) {
[10:22:46.919]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:46.919]                         if (muffled) 
[10:22:46.919]                           invokeRestart("muffleWarning")
[10:22:46.919]                       }
[10:22:46.919]                       else if (inherits(cond, "condition")) {
[10:22:46.919]                         if (!is.null(pattern)) {
[10:22:46.919]                           computeRestarts <- base::computeRestarts
[10:22:46.919]                           grepl <- base::grepl
[10:22:46.919]                           restarts <- computeRestarts(cond)
[10:22:46.919]                           for (restart in restarts) {
[10:22:46.919]                             name <- restart$name
[10:22:46.919]                             if (is.null(name)) 
[10:22:46.919]                               next
[10:22:46.919]                             if (!grepl(pattern, name)) 
[10:22:46.919]                               next
[10:22:46.919]                             invokeRestart(restart)
[10:22:46.919]                             muffled <- TRUE
[10:22:46.919]                             break
[10:22:46.919]                           }
[10:22:46.919]                         }
[10:22:46.919]                       }
[10:22:46.919]                       invisible(muffled)
[10:22:46.919]                     }
[10:22:46.919]                     muffleCondition(cond, pattern = "^muffle")
[10:22:46.919]                   }
[10:22:46.919]                 }
[10:22:46.919]             }
[10:22:46.919]         }))
[10:22:46.919]     }, error = function(ex) {
[10:22:46.919]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:46.919]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:46.919]                 ...future.rng), started = ...future.startTime, 
[10:22:46.919]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:46.919]             version = "1.8"), class = "FutureResult")
[10:22:46.919]     }, finally = {
[10:22:46.919]         if (!identical(...future.workdir, getwd())) 
[10:22:46.919]             setwd(...future.workdir)
[10:22:46.919]         {
[10:22:46.919]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:46.919]                 ...future.oldOptions$nwarnings <- NULL
[10:22:46.919]             }
[10:22:46.919]             base::options(...future.oldOptions)
[10:22:46.919]             if (.Platform$OS.type == "windows") {
[10:22:46.919]                 old_names <- names(...future.oldEnvVars)
[10:22:46.919]                 envs <- base::Sys.getenv()
[10:22:46.919]                 names <- names(envs)
[10:22:46.919]                 common <- intersect(names, old_names)
[10:22:46.919]                 added <- setdiff(names, old_names)
[10:22:46.919]                 removed <- setdiff(old_names, names)
[10:22:46.919]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:46.919]                   envs[common]]
[10:22:46.919]                 NAMES <- toupper(changed)
[10:22:46.919]                 args <- list()
[10:22:46.919]                 for (kk in seq_along(NAMES)) {
[10:22:46.919]                   name <- changed[[kk]]
[10:22:46.919]                   NAME <- NAMES[[kk]]
[10:22:46.919]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:46.919]                     next
[10:22:46.919]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:46.919]                 }
[10:22:46.919]                 NAMES <- toupper(added)
[10:22:46.919]                 for (kk in seq_along(NAMES)) {
[10:22:46.919]                   name <- added[[kk]]
[10:22:46.919]                   NAME <- NAMES[[kk]]
[10:22:46.919]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:46.919]                     next
[10:22:46.919]                   args[[name]] <- ""
[10:22:46.919]                 }
[10:22:46.919]                 NAMES <- toupper(removed)
[10:22:46.919]                 for (kk in seq_along(NAMES)) {
[10:22:46.919]                   name <- removed[[kk]]
[10:22:46.919]                   NAME <- NAMES[[kk]]
[10:22:46.919]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:46.919]                     next
[10:22:46.919]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:46.919]                 }
[10:22:46.919]                 if (length(args) > 0) 
[10:22:46.919]                   base::do.call(base::Sys.setenv, args = args)
[10:22:46.919]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:46.919]             }
[10:22:46.919]             else {
[10:22:46.919]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:46.919]             }
[10:22:46.919]             {
[10:22:46.919]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:46.919]                   0L) {
[10:22:46.919]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:46.919]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:46.919]                   base::options(opts)
[10:22:46.919]                 }
[10:22:46.919]                 {
[10:22:46.919]                   {
[10:22:46.919]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:46.919]                     NULL
[10:22:46.919]                   }
[10:22:46.919]                   options(future.plan = NULL)
[10:22:46.919]                   if (is.na(NA_character_)) 
[10:22:46.919]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:46.919]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:46.919]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:46.919]                     .init = FALSE)
[10:22:46.919]                 }
[10:22:46.919]             }
[10:22:46.919]         }
[10:22:46.919]     })
[10:22:46.919]     if (TRUE) {
[10:22:46.919]         base::sink(type = "output", split = FALSE)
[10:22:46.919]         if (TRUE) {
[10:22:46.919]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:46.919]         }
[10:22:46.919]         else {
[10:22:46.919]             ...future.result["stdout"] <- base::list(NULL)
[10:22:46.919]         }
[10:22:46.919]         base::close(...future.stdout)
[10:22:46.919]         ...future.stdout <- NULL
[10:22:46.919]     }
[10:22:46.919]     ...future.result$conditions <- ...future.conditions
[10:22:46.919]     ...future.result$finished <- base::Sys.time()
[10:22:46.919]     ...future.result
[10:22:46.919] }
[10:22:46.922] MultisessionFuture started
[10:22:46.922] - Launch lazy future ... done
[10:22:46.922] run() for ‘MultisessionFuture’ ... done
[10:22:47.465] receiveMessageFromWorker() for ClusterFuture ...
[10:22:47.465] - Validating connection of MultisessionFuture
[10:22:47.465] - received message: FutureResult
[10:22:47.465] - Received FutureResult
[10:22:47.465] - Erased future from FutureRegistry
[10:22:47.465] result() for ClusterFuture ...
[10:22:47.466] - result already collected: FutureResult
[10:22:47.466] result() for ClusterFuture ... done
[10:22:47.466] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:47.466] resolve() on list ...
[10:22:47.466]  recursive: Inf
[10:22:47.466]  length: 2
[10:22:47.466]  elements: ‘a’, ‘b’
[10:22:47.466]  length: 1 (resolved future 1)
[10:22:47.466]  length: 0 (resolved future 2)
[10:22:47.466] resolve() on list ... DONE
[10:22:47.466] A MultisessionFuture was resolved (and resolved itself)
[10:22:47.467] getGlobalsAndPackages() ...
[10:22:47.467] Searching for globals...
[10:22:47.468] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[10:22:47.468] Searching for globals ... DONE
[10:22:47.468] Resolving globals: FALSE
[10:22:47.468] 
[10:22:47.469] 
[10:22:47.469] getGlobalsAndPackages() ... DONE
[10:22:47.469] run() for ‘Future’ ...
[10:22:47.469] - state: ‘created’
[10:22:47.469] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:47.492] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:47.492] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:47.492]   - Field: ‘node’
[10:22:47.492]   - Field: ‘label’
[10:22:47.492]   - Field: ‘local’
[10:22:47.492]   - Field: ‘owner’
[10:22:47.492]   - Field: ‘envir’
[10:22:47.492]   - Field: ‘workers’
[10:22:47.492]   - Field: ‘packages’
[10:22:47.492]   - Field: ‘gc’
[10:22:47.493]   - Field: ‘conditions’
[10:22:47.493]   - Field: ‘persistent’
[10:22:47.493]   - Field: ‘expr’
[10:22:47.493]   - Field: ‘uuid’
[10:22:47.493]   - Field: ‘seed’
[10:22:47.493]   - Field: ‘version’
[10:22:47.493]   - Field: ‘result’
[10:22:47.493]   - Field: ‘asynchronous’
[10:22:47.493]   - Field: ‘calls’
[10:22:47.493]   - Field: ‘globals’
[10:22:47.493]   - Field: ‘stdout’
[10:22:47.493]   - Field: ‘earlySignal’
[10:22:47.494]   - Field: ‘lazy’
[10:22:47.494]   - Field: ‘state’
[10:22:47.494] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:47.494] - Launch lazy future ...
[10:22:47.494] Packages needed by the future expression (n = 0): <none>
[10:22:47.494] Packages needed by future strategies (n = 0): <none>
[10:22:47.495] {
[10:22:47.495]     {
[10:22:47.495]         {
[10:22:47.495]             ...future.startTime <- base::Sys.time()
[10:22:47.495]             {
[10:22:47.495]                 {
[10:22:47.495]                   {
[10:22:47.495]                     {
[10:22:47.495]                       base::local({
[10:22:47.495]                         has_future <- base::requireNamespace("future", 
[10:22:47.495]                           quietly = TRUE)
[10:22:47.495]                         if (has_future) {
[10:22:47.495]                           ns <- base::getNamespace("future")
[10:22:47.495]                           version <- ns[[".package"]][["version"]]
[10:22:47.495]                           if (is.null(version)) 
[10:22:47.495]                             version <- utils::packageVersion("future")
[10:22:47.495]                         }
[10:22:47.495]                         else {
[10:22:47.495]                           version <- NULL
[10:22:47.495]                         }
[10:22:47.495]                         if (!has_future || version < "1.8.0") {
[10:22:47.495]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:47.495]                             "", base::R.version$version.string), 
[10:22:47.495]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:47.495]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:47.495]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:47.495]                               "release", "version")], collapse = " "), 
[10:22:47.495]                             hostname = base::Sys.info()[["nodename"]])
[10:22:47.495]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:47.495]                             info)
[10:22:47.495]                           info <- base::paste(info, collapse = "; ")
[10:22:47.495]                           if (!has_future) {
[10:22:47.495]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:47.495]                               info)
[10:22:47.495]                           }
[10:22:47.495]                           else {
[10:22:47.495]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:47.495]                               info, version)
[10:22:47.495]                           }
[10:22:47.495]                           base::stop(msg)
[10:22:47.495]                         }
[10:22:47.495]                       })
[10:22:47.495]                     }
[10:22:47.495]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:47.495]                     base::options(mc.cores = 1L)
[10:22:47.495]                   }
[10:22:47.495]                   ...future.strategy.old <- future::plan("list")
[10:22:47.495]                   options(future.plan = NULL)
[10:22:47.495]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:47.495]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:47.495]                 }
[10:22:47.495]                 ...future.workdir <- getwd()
[10:22:47.495]             }
[10:22:47.495]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:47.495]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:47.495]         }
[10:22:47.495]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:47.495]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:47.495]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:47.495]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:47.495]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:47.495]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:47.495]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:47.495]             base::names(...future.oldOptions))
[10:22:47.495]     }
[10:22:47.495]     if (FALSE) {
[10:22:47.495]     }
[10:22:47.495]     else {
[10:22:47.495]         if (TRUE) {
[10:22:47.495]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:47.495]                 open = "w")
[10:22:47.495]         }
[10:22:47.495]         else {
[10:22:47.495]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:47.495]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:47.495]         }
[10:22:47.495]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:47.495]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:47.495]             base::sink(type = "output", split = FALSE)
[10:22:47.495]             base::close(...future.stdout)
[10:22:47.495]         }, add = TRUE)
[10:22:47.495]     }
[10:22:47.495]     ...future.frame <- base::sys.nframe()
[10:22:47.495]     ...future.conditions <- base::list()
[10:22:47.495]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:47.495]     if (FALSE) {
[10:22:47.495]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:47.495]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:47.495]     }
[10:22:47.495]     ...future.result <- base::tryCatch({
[10:22:47.495]         base::withCallingHandlers({
[10:22:47.495]             ...future.value <- base::withVisible(base::local({
[10:22:47.495]                 ...future.makeSendCondition <- base::local({
[10:22:47.495]                   sendCondition <- NULL
[10:22:47.495]                   function(frame = 1L) {
[10:22:47.495]                     if (is.function(sendCondition)) 
[10:22:47.495]                       return(sendCondition)
[10:22:47.495]                     ns <- getNamespace("parallel")
[10:22:47.495]                     if (exists("sendData", mode = "function", 
[10:22:47.495]                       envir = ns)) {
[10:22:47.495]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:47.495]                         envir = ns)
[10:22:47.495]                       envir <- sys.frame(frame)
[10:22:47.495]                       master <- NULL
[10:22:47.495]                       while (!identical(envir, .GlobalEnv) && 
[10:22:47.495]                         !identical(envir, emptyenv())) {
[10:22:47.495]                         if (exists("master", mode = "list", envir = envir, 
[10:22:47.495]                           inherits = FALSE)) {
[10:22:47.495]                           master <- get("master", mode = "list", 
[10:22:47.495]                             envir = envir, inherits = FALSE)
[10:22:47.495]                           if (inherits(master, c("SOCKnode", 
[10:22:47.495]                             "SOCK0node"))) {
[10:22:47.495]                             sendCondition <<- function(cond) {
[10:22:47.495]                               data <- list(type = "VALUE", value = cond, 
[10:22:47.495]                                 success = TRUE)
[10:22:47.495]                               parallel_sendData(master, data)
[10:22:47.495]                             }
[10:22:47.495]                             return(sendCondition)
[10:22:47.495]                           }
[10:22:47.495]                         }
[10:22:47.495]                         frame <- frame + 1L
[10:22:47.495]                         envir <- sys.frame(frame)
[10:22:47.495]                       }
[10:22:47.495]                     }
[10:22:47.495]                     sendCondition <<- function(cond) NULL
[10:22:47.495]                   }
[10:22:47.495]                 })
[10:22:47.495]                 withCallingHandlers({
[10:22:47.495]                   {
[10:22:47.495]                     Sys.sleep(0.5)
[10:22:47.495]                     list(a = 1, b = 42L)
[10:22:47.495]                   }
[10:22:47.495]                 }, immediateCondition = function(cond) {
[10:22:47.495]                   sendCondition <- ...future.makeSendCondition()
[10:22:47.495]                   sendCondition(cond)
[10:22:47.495]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.495]                   {
[10:22:47.495]                     inherits <- base::inherits
[10:22:47.495]                     invokeRestart <- base::invokeRestart
[10:22:47.495]                     is.null <- base::is.null
[10:22:47.495]                     muffled <- FALSE
[10:22:47.495]                     if (inherits(cond, "message")) {
[10:22:47.495]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:47.495]                       if (muffled) 
[10:22:47.495]                         invokeRestart("muffleMessage")
[10:22:47.495]                     }
[10:22:47.495]                     else if (inherits(cond, "warning")) {
[10:22:47.495]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:47.495]                       if (muffled) 
[10:22:47.495]                         invokeRestart("muffleWarning")
[10:22:47.495]                     }
[10:22:47.495]                     else if (inherits(cond, "condition")) {
[10:22:47.495]                       if (!is.null(pattern)) {
[10:22:47.495]                         computeRestarts <- base::computeRestarts
[10:22:47.495]                         grepl <- base::grepl
[10:22:47.495]                         restarts <- computeRestarts(cond)
[10:22:47.495]                         for (restart in restarts) {
[10:22:47.495]                           name <- restart$name
[10:22:47.495]                           if (is.null(name)) 
[10:22:47.495]                             next
[10:22:47.495]                           if (!grepl(pattern, name)) 
[10:22:47.495]                             next
[10:22:47.495]                           invokeRestart(restart)
[10:22:47.495]                           muffled <- TRUE
[10:22:47.495]                           break
[10:22:47.495]                         }
[10:22:47.495]                       }
[10:22:47.495]                     }
[10:22:47.495]                     invisible(muffled)
[10:22:47.495]                   }
[10:22:47.495]                   muffleCondition(cond)
[10:22:47.495]                 })
[10:22:47.495]             }))
[10:22:47.495]             future::FutureResult(value = ...future.value$value, 
[10:22:47.495]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:47.495]                   ...future.rng), globalenv = if (FALSE) 
[10:22:47.495]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:47.495]                     ...future.globalenv.names))
[10:22:47.495]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:47.495]         }, condition = base::local({
[10:22:47.495]             c <- base::c
[10:22:47.495]             inherits <- base::inherits
[10:22:47.495]             invokeRestart <- base::invokeRestart
[10:22:47.495]             length <- base::length
[10:22:47.495]             list <- base::list
[10:22:47.495]             seq.int <- base::seq.int
[10:22:47.495]             signalCondition <- base::signalCondition
[10:22:47.495]             sys.calls <- base::sys.calls
[10:22:47.495]             `[[` <- base::`[[`
[10:22:47.495]             `+` <- base::`+`
[10:22:47.495]             `<<-` <- base::`<<-`
[10:22:47.495]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:47.495]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:47.495]                   3L)]
[10:22:47.495]             }
[10:22:47.495]             function(cond) {
[10:22:47.495]                 is_error <- inherits(cond, "error")
[10:22:47.495]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:47.495]                   NULL)
[10:22:47.495]                 if (is_error) {
[10:22:47.495]                   sessionInformation <- function() {
[10:22:47.495]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:47.495]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:47.495]                       search = base::search(), system = base::Sys.info())
[10:22:47.495]                   }
[10:22:47.495]                   ...future.conditions[[length(...future.conditions) + 
[10:22:47.495]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:47.495]                     cond$call), session = sessionInformation(), 
[10:22:47.495]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:47.495]                   signalCondition(cond)
[10:22:47.495]                 }
[10:22:47.495]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:47.495]                 "immediateCondition"))) {
[10:22:47.495]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:47.495]                   ...future.conditions[[length(...future.conditions) + 
[10:22:47.495]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:47.495]                   if (TRUE && !signal) {
[10:22:47.495]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.495]                     {
[10:22:47.495]                       inherits <- base::inherits
[10:22:47.495]                       invokeRestart <- base::invokeRestart
[10:22:47.495]                       is.null <- base::is.null
[10:22:47.495]                       muffled <- FALSE
[10:22:47.495]                       if (inherits(cond, "message")) {
[10:22:47.495]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:47.495]                         if (muffled) 
[10:22:47.495]                           invokeRestart("muffleMessage")
[10:22:47.495]                       }
[10:22:47.495]                       else if (inherits(cond, "warning")) {
[10:22:47.495]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:47.495]                         if (muffled) 
[10:22:47.495]                           invokeRestart("muffleWarning")
[10:22:47.495]                       }
[10:22:47.495]                       else if (inherits(cond, "condition")) {
[10:22:47.495]                         if (!is.null(pattern)) {
[10:22:47.495]                           computeRestarts <- base::computeRestarts
[10:22:47.495]                           grepl <- base::grepl
[10:22:47.495]                           restarts <- computeRestarts(cond)
[10:22:47.495]                           for (restart in restarts) {
[10:22:47.495]                             name <- restart$name
[10:22:47.495]                             if (is.null(name)) 
[10:22:47.495]                               next
[10:22:47.495]                             if (!grepl(pattern, name)) 
[10:22:47.495]                               next
[10:22:47.495]                             invokeRestart(restart)
[10:22:47.495]                             muffled <- TRUE
[10:22:47.495]                             break
[10:22:47.495]                           }
[10:22:47.495]                         }
[10:22:47.495]                       }
[10:22:47.495]                       invisible(muffled)
[10:22:47.495]                     }
[10:22:47.495]                     muffleCondition(cond, pattern = "^muffle")
[10:22:47.495]                   }
[10:22:47.495]                 }
[10:22:47.495]                 else {
[10:22:47.495]                   if (TRUE) {
[10:22:47.495]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:47.495]                     {
[10:22:47.495]                       inherits <- base::inherits
[10:22:47.495]                       invokeRestart <- base::invokeRestart
[10:22:47.495]                       is.null <- base::is.null
[10:22:47.495]                       muffled <- FALSE
[10:22:47.495]                       if (inherits(cond, "message")) {
[10:22:47.495]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:47.495]                         if (muffled) 
[10:22:47.495]                           invokeRestart("muffleMessage")
[10:22:47.495]                       }
[10:22:47.495]                       else if (inherits(cond, "warning")) {
[10:22:47.495]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:47.495]                         if (muffled) 
[10:22:47.495]                           invokeRestart("muffleWarning")
[10:22:47.495]                       }
[10:22:47.495]                       else if (inherits(cond, "condition")) {
[10:22:47.495]                         if (!is.null(pattern)) {
[10:22:47.495]                           computeRestarts <- base::computeRestarts
[10:22:47.495]                           grepl <- base::grepl
[10:22:47.495]                           restarts <- computeRestarts(cond)
[10:22:47.495]                           for (restart in restarts) {
[10:22:47.495]                             name <- restart$name
[10:22:47.495]                             if (is.null(name)) 
[10:22:47.495]                               next
[10:22:47.495]                             if (!grepl(pattern, name)) 
[10:22:47.495]                               next
[10:22:47.495]                             invokeRestart(restart)
[10:22:47.495]                             muffled <- TRUE
[10:22:47.495]                             break
[10:22:47.495]                           }
[10:22:47.495]                         }
[10:22:47.495]                       }
[10:22:47.495]                       invisible(muffled)
[10:22:47.495]                     }
[10:22:47.495]                     muffleCondition(cond, pattern = "^muffle")
[10:22:47.495]                   }
[10:22:47.495]                 }
[10:22:47.495]             }
[10:22:47.495]         }))
[10:22:47.495]     }, error = function(ex) {
[10:22:47.495]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:47.495]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:47.495]                 ...future.rng), started = ...future.startTime, 
[10:22:47.495]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:47.495]             version = "1.8"), class = "FutureResult")
[10:22:47.495]     }, finally = {
[10:22:47.495]         if (!identical(...future.workdir, getwd())) 
[10:22:47.495]             setwd(...future.workdir)
[10:22:47.495]         {
[10:22:47.495]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:47.495]                 ...future.oldOptions$nwarnings <- NULL
[10:22:47.495]             }
[10:22:47.495]             base::options(...future.oldOptions)
[10:22:47.495]             if (.Platform$OS.type == "windows") {
[10:22:47.495]                 old_names <- names(...future.oldEnvVars)
[10:22:47.495]                 envs <- base::Sys.getenv()
[10:22:47.495]                 names <- names(envs)
[10:22:47.495]                 common <- intersect(names, old_names)
[10:22:47.495]                 added <- setdiff(names, old_names)
[10:22:47.495]                 removed <- setdiff(old_names, names)
[10:22:47.495]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:47.495]                   envs[common]]
[10:22:47.495]                 NAMES <- toupper(changed)
[10:22:47.495]                 args <- list()
[10:22:47.495]                 for (kk in seq_along(NAMES)) {
[10:22:47.495]                   name <- changed[[kk]]
[10:22:47.495]                   NAME <- NAMES[[kk]]
[10:22:47.495]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.495]                     next
[10:22:47.495]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:47.495]                 }
[10:22:47.495]                 NAMES <- toupper(added)
[10:22:47.495]                 for (kk in seq_along(NAMES)) {
[10:22:47.495]                   name <- added[[kk]]
[10:22:47.495]                   NAME <- NAMES[[kk]]
[10:22:47.495]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.495]                     next
[10:22:47.495]                   args[[name]] <- ""
[10:22:47.495]                 }
[10:22:47.495]                 NAMES <- toupper(removed)
[10:22:47.495]                 for (kk in seq_along(NAMES)) {
[10:22:47.495]                   name <- removed[[kk]]
[10:22:47.495]                   NAME <- NAMES[[kk]]
[10:22:47.495]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:47.495]                     next
[10:22:47.495]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:47.495]                 }
[10:22:47.495]                 if (length(args) > 0) 
[10:22:47.495]                   base::do.call(base::Sys.setenv, args = args)
[10:22:47.495]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:47.495]             }
[10:22:47.495]             else {
[10:22:47.495]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:47.495]             }
[10:22:47.495]             {
[10:22:47.495]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:47.495]                   0L) {
[10:22:47.495]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:47.495]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:47.495]                   base::options(opts)
[10:22:47.495]                 }
[10:22:47.495]                 {
[10:22:47.495]                   {
[10:22:47.495]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:47.495]                     NULL
[10:22:47.495]                   }
[10:22:47.495]                   options(future.plan = NULL)
[10:22:47.495]                   if (is.na(NA_character_)) 
[10:22:47.495]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:47.495]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:47.495]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:47.495]                     .init = FALSE)
[10:22:47.495]                 }
[10:22:47.495]             }
[10:22:47.495]         }
[10:22:47.495]     })
[10:22:47.495]     if (TRUE) {
[10:22:47.495]         base::sink(type = "output", split = FALSE)
[10:22:47.495]         if (TRUE) {
[10:22:47.495]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:47.495]         }
[10:22:47.495]         else {
[10:22:47.495]             ...future.result["stdout"] <- base::list(NULL)
[10:22:47.495]         }
[10:22:47.495]         base::close(...future.stdout)
[10:22:47.495]         ...future.stdout <- NULL
[10:22:47.495]     }
[10:22:47.495]     ...future.result$conditions <- ...future.conditions
[10:22:47.495]     ...future.result$finished <- base::Sys.time()
[10:22:47.495]     ...future.result
[10:22:47.495] }
[10:22:47.498] MultisessionFuture started
[10:22:47.498] - Launch lazy future ... done
[10:22:47.498] run() for ‘MultisessionFuture’ ... done
[10:22:48.041] receiveMessageFromWorker() for ClusterFuture ...
[10:22:48.041] - Validating connection of MultisessionFuture
[10:22:48.041] - received message: FutureResult
[10:22:48.042] - Received FutureResult
[10:22:48.042] - Erased future from FutureRegistry
[10:22:48.042] result() for ClusterFuture ...
[10:22:48.042] - result already collected: FutureResult
[10:22:48.042] result() for ClusterFuture ... done
[10:22:48.042] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:48.042] resolve() on list ...
[10:22:48.042]  recursive: Inf
[10:22:48.042]  length: 2
[10:22:48.042]  elements: ‘a’, ‘b’
[10:22:48.043]  length: 1 (resolved future 1)
[10:22:48.043]  length: 0 (resolved future 2)
[10:22:48.043] resolve() on list ... DONE
[10:22:48.043] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[10:22:48.043] getGlobalsAndPackages() ...
[10:22:48.043] Searching for globals...
[10:22:48.044] - globals found: [2] ‘list’, ‘stop’
[10:22:48.044] Searching for globals ... DONE
[10:22:48.044] Resolving globals: FALSE
[10:22:48.044] 
[10:22:48.044] 
[10:22:48.044] getGlobalsAndPackages() ... DONE
[10:22:48.045] run() for ‘Future’ ...
[10:22:48.045] - state: ‘created’
[10:22:48.045] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:48.059] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:48.059] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:48.059]   - Field: ‘node’
[10:22:48.059]   - Field: ‘label’
[10:22:48.059]   - Field: ‘local’
[10:22:48.059]   - Field: ‘owner’
[10:22:48.059]   - Field: ‘envir’
[10:22:48.059]   - Field: ‘workers’
[10:22:48.060]   - Field: ‘packages’
[10:22:48.060]   - Field: ‘gc’
[10:22:48.060]   - Field: ‘conditions’
[10:22:48.060]   - Field: ‘persistent’
[10:22:48.060]   - Field: ‘expr’
[10:22:48.060]   - Field: ‘uuid’
[10:22:48.060]   - Field: ‘seed’
[10:22:48.060]   - Field: ‘version’
[10:22:48.060]   - Field: ‘result’
[10:22:48.060]   - Field: ‘asynchronous’
[10:22:48.060]   - Field: ‘calls’
[10:22:48.060]   - Field: ‘globals’
[10:22:48.061]   - Field: ‘stdout’
[10:22:48.061]   - Field: ‘earlySignal’
[10:22:48.061]   - Field: ‘lazy’
[10:22:48.061]   - Field: ‘state’
[10:22:48.061] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:48.061] - Launch lazy future ...
[10:22:48.061] Packages needed by the future expression (n = 0): <none>
[10:22:48.061] Packages needed by future strategies (n = 0): <none>
[10:22:48.062] {
[10:22:48.062]     {
[10:22:48.062]         {
[10:22:48.062]             ...future.startTime <- base::Sys.time()
[10:22:48.062]             {
[10:22:48.062]                 {
[10:22:48.062]                   {
[10:22:48.062]                     {
[10:22:48.062]                       base::local({
[10:22:48.062]                         has_future <- base::requireNamespace("future", 
[10:22:48.062]                           quietly = TRUE)
[10:22:48.062]                         if (has_future) {
[10:22:48.062]                           ns <- base::getNamespace("future")
[10:22:48.062]                           version <- ns[[".package"]][["version"]]
[10:22:48.062]                           if (is.null(version)) 
[10:22:48.062]                             version <- utils::packageVersion("future")
[10:22:48.062]                         }
[10:22:48.062]                         else {
[10:22:48.062]                           version <- NULL
[10:22:48.062]                         }
[10:22:48.062]                         if (!has_future || version < "1.8.0") {
[10:22:48.062]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:48.062]                             "", base::R.version$version.string), 
[10:22:48.062]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:48.062]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:48.062]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:48.062]                               "release", "version")], collapse = " "), 
[10:22:48.062]                             hostname = base::Sys.info()[["nodename"]])
[10:22:48.062]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:48.062]                             info)
[10:22:48.062]                           info <- base::paste(info, collapse = "; ")
[10:22:48.062]                           if (!has_future) {
[10:22:48.062]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:48.062]                               info)
[10:22:48.062]                           }
[10:22:48.062]                           else {
[10:22:48.062]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:48.062]                               info, version)
[10:22:48.062]                           }
[10:22:48.062]                           base::stop(msg)
[10:22:48.062]                         }
[10:22:48.062]                       })
[10:22:48.062]                     }
[10:22:48.062]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:48.062]                     base::options(mc.cores = 1L)
[10:22:48.062]                   }
[10:22:48.062]                   ...future.strategy.old <- future::plan("list")
[10:22:48.062]                   options(future.plan = NULL)
[10:22:48.062]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.062]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:48.062]                 }
[10:22:48.062]                 ...future.workdir <- getwd()
[10:22:48.062]             }
[10:22:48.062]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:48.062]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:48.062]         }
[10:22:48.062]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:48.062]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:48.062]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:48.062]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:48.062]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:48.062]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:48.062]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:48.062]             base::names(...future.oldOptions))
[10:22:48.062]     }
[10:22:48.062]     if (FALSE) {
[10:22:48.062]     }
[10:22:48.062]     else {
[10:22:48.062]         if (TRUE) {
[10:22:48.062]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:48.062]                 open = "w")
[10:22:48.062]         }
[10:22:48.062]         else {
[10:22:48.062]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:48.062]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:48.062]         }
[10:22:48.062]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:48.062]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:48.062]             base::sink(type = "output", split = FALSE)
[10:22:48.062]             base::close(...future.stdout)
[10:22:48.062]         }, add = TRUE)
[10:22:48.062]     }
[10:22:48.062]     ...future.frame <- base::sys.nframe()
[10:22:48.062]     ...future.conditions <- base::list()
[10:22:48.062]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:48.062]     if (FALSE) {
[10:22:48.062]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:48.062]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:48.062]     }
[10:22:48.062]     ...future.result <- base::tryCatch({
[10:22:48.062]         base::withCallingHandlers({
[10:22:48.062]             ...future.value <- base::withVisible(base::local({
[10:22:48.062]                 ...future.makeSendCondition <- base::local({
[10:22:48.062]                   sendCondition <- NULL
[10:22:48.062]                   function(frame = 1L) {
[10:22:48.062]                     if (is.function(sendCondition)) 
[10:22:48.062]                       return(sendCondition)
[10:22:48.062]                     ns <- getNamespace("parallel")
[10:22:48.062]                     if (exists("sendData", mode = "function", 
[10:22:48.062]                       envir = ns)) {
[10:22:48.062]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:48.062]                         envir = ns)
[10:22:48.062]                       envir <- sys.frame(frame)
[10:22:48.062]                       master <- NULL
[10:22:48.062]                       while (!identical(envir, .GlobalEnv) && 
[10:22:48.062]                         !identical(envir, emptyenv())) {
[10:22:48.062]                         if (exists("master", mode = "list", envir = envir, 
[10:22:48.062]                           inherits = FALSE)) {
[10:22:48.062]                           master <- get("master", mode = "list", 
[10:22:48.062]                             envir = envir, inherits = FALSE)
[10:22:48.062]                           if (inherits(master, c("SOCKnode", 
[10:22:48.062]                             "SOCK0node"))) {
[10:22:48.062]                             sendCondition <<- function(cond) {
[10:22:48.062]                               data <- list(type = "VALUE", value = cond, 
[10:22:48.062]                                 success = TRUE)
[10:22:48.062]                               parallel_sendData(master, data)
[10:22:48.062]                             }
[10:22:48.062]                             return(sendCondition)
[10:22:48.062]                           }
[10:22:48.062]                         }
[10:22:48.062]                         frame <- frame + 1L
[10:22:48.062]                         envir <- sys.frame(frame)
[10:22:48.062]                       }
[10:22:48.062]                     }
[10:22:48.062]                     sendCondition <<- function(cond) NULL
[10:22:48.062]                   }
[10:22:48.062]                 })
[10:22:48.062]                 withCallingHandlers({
[10:22:48.062]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:22:48.062]                 }, immediateCondition = function(cond) {
[10:22:48.062]                   sendCondition <- ...future.makeSendCondition()
[10:22:48.062]                   sendCondition(cond)
[10:22:48.062]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.062]                   {
[10:22:48.062]                     inherits <- base::inherits
[10:22:48.062]                     invokeRestart <- base::invokeRestart
[10:22:48.062]                     is.null <- base::is.null
[10:22:48.062]                     muffled <- FALSE
[10:22:48.062]                     if (inherits(cond, "message")) {
[10:22:48.062]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:48.062]                       if (muffled) 
[10:22:48.062]                         invokeRestart("muffleMessage")
[10:22:48.062]                     }
[10:22:48.062]                     else if (inherits(cond, "warning")) {
[10:22:48.062]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:48.062]                       if (muffled) 
[10:22:48.062]                         invokeRestart("muffleWarning")
[10:22:48.062]                     }
[10:22:48.062]                     else if (inherits(cond, "condition")) {
[10:22:48.062]                       if (!is.null(pattern)) {
[10:22:48.062]                         computeRestarts <- base::computeRestarts
[10:22:48.062]                         grepl <- base::grepl
[10:22:48.062]                         restarts <- computeRestarts(cond)
[10:22:48.062]                         for (restart in restarts) {
[10:22:48.062]                           name <- restart$name
[10:22:48.062]                           if (is.null(name)) 
[10:22:48.062]                             next
[10:22:48.062]                           if (!grepl(pattern, name)) 
[10:22:48.062]                             next
[10:22:48.062]                           invokeRestart(restart)
[10:22:48.062]                           muffled <- TRUE
[10:22:48.062]                           break
[10:22:48.062]                         }
[10:22:48.062]                       }
[10:22:48.062]                     }
[10:22:48.062]                     invisible(muffled)
[10:22:48.062]                   }
[10:22:48.062]                   muffleCondition(cond)
[10:22:48.062]                 })
[10:22:48.062]             }))
[10:22:48.062]             future::FutureResult(value = ...future.value$value, 
[10:22:48.062]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.062]                   ...future.rng), globalenv = if (FALSE) 
[10:22:48.062]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:48.062]                     ...future.globalenv.names))
[10:22:48.062]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:48.062]         }, condition = base::local({
[10:22:48.062]             c <- base::c
[10:22:48.062]             inherits <- base::inherits
[10:22:48.062]             invokeRestart <- base::invokeRestart
[10:22:48.062]             length <- base::length
[10:22:48.062]             list <- base::list
[10:22:48.062]             seq.int <- base::seq.int
[10:22:48.062]             signalCondition <- base::signalCondition
[10:22:48.062]             sys.calls <- base::sys.calls
[10:22:48.062]             `[[` <- base::`[[`
[10:22:48.062]             `+` <- base::`+`
[10:22:48.062]             `<<-` <- base::`<<-`
[10:22:48.062]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:48.062]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:48.062]                   3L)]
[10:22:48.062]             }
[10:22:48.062]             function(cond) {
[10:22:48.062]                 is_error <- inherits(cond, "error")
[10:22:48.062]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:48.062]                   NULL)
[10:22:48.062]                 if (is_error) {
[10:22:48.062]                   sessionInformation <- function() {
[10:22:48.062]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:48.062]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:48.062]                       search = base::search(), system = base::Sys.info())
[10:22:48.062]                   }
[10:22:48.062]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.062]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:48.062]                     cond$call), session = sessionInformation(), 
[10:22:48.062]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:48.062]                   signalCondition(cond)
[10:22:48.062]                 }
[10:22:48.062]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:48.062]                 "immediateCondition"))) {
[10:22:48.062]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:48.062]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.062]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:48.062]                   if (TRUE && !signal) {
[10:22:48.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.062]                     {
[10:22:48.062]                       inherits <- base::inherits
[10:22:48.062]                       invokeRestart <- base::invokeRestart
[10:22:48.062]                       is.null <- base::is.null
[10:22:48.062]                       muffled <- FALSE
[10:22:48.062]                       if (inherits(cond, "message")) {
[10:22:48.062]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.062]                         if (muffled) 
[10:22:48.062]                           invokeRestart("muffleMessage")
[10:22:48.062]                       }
[10:22:48.062]                       else if (inherits(cond, "warning")) {
[10:22:48.062]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.062]                         if (muffled) 
[10:22:48.062]                           invokeRestart("muffleWarning")
[10:22:48.062]                       }
[10:22:48.062]                       else if (inherits(cond, "condition")) {
[10:22:48.062]                         if (!is.null(pattern)) {
[10:22:48.062]                           computeRestarts <- base::computeRestarts
[10:22:48.062]                           grepl <- base::grepl
[10:22:48.062]                           restarts <- computeRestarts(cond)
[10:22:48.062]                           for (restart in restarts) {
[10:22:48.062]                             name <- restart$name
[10:22:48.062]                             if (is.null(name)) 
[10:22:48.062]                               next
[10:22:48.062]                             if (!grepl(pattern, name)) 
[10:22:48.062]                               next
[10:22:48.062]                             invokeRestart(restart)
[10:22:48.062]                             muffled <- TRUE
[10:22:48.062]                             break
[10:22:48.062]                           }
[10:22:48.062]                         }
[10:22:48.062]                       }
[10:22:48.062]                       invisible(muffled)
[10:22:48.062]                     }
[10:22:48.062]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.062]                   }
[10:22:48.062]                 }
[10:22:48.062]                 else {
[10:22:48.062]                   if (TRUE) {
[10:22:48.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.062]                     {
[10:22:48.062]                       inherits <- base::inherits
[10:22:48.062]                       invokeRestart <- base::invokeRestart
[10:22:48.062]                       is.null <- base::is.null
[10:22:48.062]                       muffled <- FALSE
[10:22:48.062]                       if (inherits(cond, "message")) {
[10:22:48.062]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.062]                         if (muffled) 
[10:22:48.062]                           invokeRestart("muffleMessage")
[10:22:48.062]                       }
[10:22:48.062]                       else if (inherits(cond, "warning")) {
[10:22:48.062]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.062]                         if (muffled) 
[10:22:48.062]                           invokeRestart("muffleWarning")
[10:22:48.062]                       }
[10:22:48.062]                       else if (inherits(cond, "condition")) {
[10:22:48.062]                         if (!is.null(pattern)) {
[10:22:48.062]                           computeRestarts <- base::computeRestarts
[10:22:48.062]                           grepl <- base::grepl
[10:22:48.062]                           restarts <- computeRestarts(cond)
[10:22:48.062]                           for (restart in restarts) {
[10:22:48.062]                             name <- restart$name
[10:22:48.062]                             if (is.null(name)) 
[10:22:48.062]                               next
[10:22:48.062]                             if (!grepl(pattern, name)) 
[10:22:48.062]                               next
[10:22:48.062]                             invokeRestart(restart)
[10:22:48.062]                             muffled <- TRUE
[10:22:48.062]                             break
[10:22:48.062]                           }
[10:22:48.062]                         }
[10:22:48.062]                       }
[10:22:48.062]                       invisible(muffled)
[10:22:48.062]                     }
[10:22:48.062]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.062]                   }
[10:22:48.062]                 }
[10:22:48.062]             }
[10:22:48.062]         }))
[10:22:48.062]     }, error = function(ex) {
[10:22:48.062]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:48.062]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.062]                 ...future.rng), started = ...future.startTime, 
[10:22:48.062]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:48.062]             version = "1.8"), class = "FutureResult")
[10:22:48.062]     }, finally = {
[10:22:48.062]         if (!identical(...future.workdir, getwd())) 
[10:22:48.062]             setwd(...future.workdir)
[10:22:48.062]         {
[10:22:48.062]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:48.062]                 ...future.oldOptions$nwarnings <- NULL
[10:22:48.062]             }
[10:22:48.062]             base::options(...future.oldOptions)
[10:22:48.062]             if (.Platform$OS.type == "windows") {
[10:22:48.062]                 old_names <- names(...future.oldEnvVars)
[10:22:48.062]                 envs <- base::Sys.getenv()
[10:22:48.062]                 names <- names(envs)
[10:22:48.062]                 common <- intersect(names, old_names)
[10:22:48.062]                 added <- setdiff(names, old_names)
[10:22:48.062]                 removed <- setdiff(old_names, names)
[10:22:48.062]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:48.062]                   envs[common]]
[10:22:48.062]                 NAMES <- toupper(changed)
[10:22:48.062]                 args <- list()
[10:22:48.062]                 for (kk in seq_along(NAMES)) {
[10:22:48.062]                   name <- changed[[kk]]
[10:22:48.062]                   NAME <- NAMES[[kk]]
[10:22:48.062]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.062]                     next
[10:22:48.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.062]                 }
[10:22:48.062]                 NAMES <- toupper(added)
[10:22:48.062]                 for (kk in seq_along(NAMES)) {
[10:22:48.062]                   name <- added[[kk]]
[10:22:48.062]                   NAME <- NAMES[[kk]]
[10:22:48.062]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.062]                     next
[10:22:48.062]                   args[[name]] <- ""
[10:22:48.062]                 }
[10:22:48.062]                 NAMES <- toupper(removed)
[10:22:48.062]                 for (kk in seq_along(NAMES)) {
[10:22:48.062]                   name <- removed[[kk]]
[10:22:48.062]                   NAME <- NAMES[[kk]]
[10:22:48.062]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.062]                     next
[10:22:48.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.062]                 }
[10:22:48.062]                 if (length(args) > 0) 
[10:22:48.062]                   base::do.call(base::Sys.setenv, args = args)
[10:22:48.062]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:48.062]             }
[10:22:48.062]             else {
[10:22:48.062]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:48.062]             }
[10:22:48.062]             {
[10:22:48.062]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:48.062]                   0L) {
[10:22:48.062]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:48.062]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:48.062]                   base::options(opts)
[10:22:48.062]                 }
[10:22:48.062]                 {
[10:22:48.062]                   {
[10:22:48.062]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:48.062]                     NULL
[10:22:48.062]                   }
[10:22:48.062]                   options(future.plan = NULL)
[10:22:48.062]                   if (is.na(NA_character_)) 
[10:22:48.062]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.062]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:48.062]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:48.062]                     .init = FALSE)
[10:22:48.062]                 }
[10:22:48.062]             }
[10:22:48.062]         }
[10:22:48.062]     })
[10:22:48.062]     if (TRUE) {
[10:22:48.062]         base::sink(type = "output", split = FALSE)
[10:22:48.062]         if (TRUE) {
[10:22:48.062]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:48.062]         }
[10:22:48.062]         else {
[10:22:48.062]             ...future.result["stdout"] <- base::list(NULL)
[10:22:48.062]         }
[10:22:48.062]         base::close(...future.stdout)
[10:22:48.062]         ...future.stdout <- NULL
[10:22:48.062]     }
[10:22:48.062]     ...future.result$conditions <- ...future.conditions
[10:22:48.062]     ...future.result$finished <- base::Sys.time()
[10:22:48.062]     ...future.result
[10:22:48.062] }
[10:22:48.065] MultisessionFuture started
[10:22:48.065] - Launch lazy future ... done
[10:22:48.065] run() for ‘MultisessionFuture’ ... done
[10:22:48.107] receiveMessageFromWorker() for ClusterFuture ...
[10:22:48.108] - Validating connection of MultisessionFuture
[10:22:48.108] - received message: FutureResult
[10:22:48.108] - Received FutureResult
[10:22:48.108] - Erased future from FutureRegistry
[10:22:48.108] result() for ClusterFuture ...
[10:22:48.108] - result already collected: FutureResult
[10:22:48.109] result() for ClusterFuture ... done
[10:22:48.109] signalConditions() ...
[10:22:48.109]  - include = ‘immediateCondition’
[10:22:48.109]  - exclude = 
[10:22:48.109]  - resignal = FALSE
[10:22:48.109]  - Number of conditions: 1
[10:22:48.109] signalConditions() ... done
[10:22:48.109] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:48.109] A MultisessionFuture was resolved (and resolved itself)
[10:22:48.109] getGlobalsAndPackages() ...
[10:22:48.109] Searching for globals...
[10:22:48.110] - globals found: [2] ‘list’, ‘stop’
[10:22:48.110] Searching for globals ... DONE
[10:22:48.110] Resolving globals: FALSE
[10:22:48.111] 
[10:22:48.111] 
[10:22:48.111] getGlobalsAndPackages() ... DONE
[10:22:48.111] run() for ‘Future’ ...
[10:22:48.111] - state: ‘created’
[10:22:48.111] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:48.125] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:48.125] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:48.125]   - Field: ‘node’
[10:22:48.125]   - Field: ‘label’
[10:22:48.125]   - Field: ‘local’
[10:22:48.126]   - Field: ‘owner’
[10:22:48.126]   - Field: ‘envir’
[10:22:48.126]   - Field: ‘workers’
[10:22:48.126]   - Field: ‘packages’
[10:22:48.126]   - Field: ‘gc’
[10:22:48.126]   - Field: ‘conditions’
[10:22:48.126]   - Field: ‘persistent’
[10:22:48.126]   - Field: ‘expr’
[10:22:48.126]   - Field: ‘uuid’
[10:22:48.126]   - Field: ‘seed’
[10:22:48.126]   - Field: ‘version’
[10:22:48.127]   - Field: ‘result’
[10:22:48.127]   - Field: ‘asynchronous’
[10:22:48.127]   - Field: ‘calls’
[10:22:48.127]   - Field: ‘globals’
[10:22:48.127]   - Field: ‘stdout’
[10:22:48.127]   - Field: ‘earlySignal’
[10:22:48.127]   - Field: ‘lazy’
[10:22:48.127]   - Field: ‘state’
[10:22:48.127] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:48.127] - Launch lazy future ...
[10:22:48.128] Packages needed by the future expression (n = 0): <none>
[10:22:48.128] Packages needed by future strategies (n = 0): <none>
[10:22:48.128] {
[10:22:48.128]     {
[10:22:48.128]         {
[10:22:48.128]             ...future.startTime <- base::Sys.time()
[10:22:48.128]             {
[10:22:48.128]                 {
[10:22:48.128]                   {
[10:22:48.128]                     {
[10:22:48.128]                       base::local({
[10:22:48.128]                         has_future <- base::requireNamespace("future", 
[10:22:48.128]                           quietly = TRUE)
[10:22:48.128]                         if (has_future) {
[10:22:48.128]                           ns <- base::getNamespace("future")
[10:22:48.128]                           version <- ns[[".package"]][["version"]]
[10:22:48.128]                           if (is.null(version)) 
[10:22:48.128]                             version <- utils::packageVersion("future")
[10:22:48.128]                         }
[10:22:48.128]                         else {
[10:22:48.128]                           version <- NULL
[10:22:48.128]                         }
[10:22:48.128]                         if (!has_future || version < "1.8.0") {
[10:22:48.128]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:48.128]                             "", base::R.version$version.string), 
[10:22:48.128]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:48.128]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:48.128]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:48.128]                               "release", "version")], collapse = " "), 
[10:22:48.128]                             hostname = base::Sys.info()[["nodename"]])
[10:22:48.128]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:48.128]                             info)
[10:22:48.128]                           info <- base::paste(info, collapse = "; ")
[10:22:48.128]                           if (!has_future) {
[10:22:48.128]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:48.128]                               info)
[10:22:48.128]                           }
[10:22:48.128]                           else {
[10:22:48.128]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:48.128]                               info, version)
[10:22:48.128]                           }
[10:22:48.128]                           base::stop(msg)
[10:22:48.128]                         }
[10:22:48.128]                       })
[10:22:48.128]                     }
[10:22:48.128]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:48.128]                     base::options(mc.cores = 1L)
[10:22:48.128]                   }
[10:22:48.128]                   ...future.strategy.old <- future::plan("list")
[10:22:48.128]                   options(future.plan = NULL)
[10:22:48.128]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.128]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:48.128]                 }
[10:22:48.128]                 ...future.workdir <- getwd()
[10:22:48.128]             }
[10:22:48.128]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:48.128]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:48.128]         }
[10:22:48.128]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:48.128]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:48.128]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:48.128]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:48.128]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:48.128]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:48.128]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:48.128]             base::names(...future.oldOptions))
[10:22:48.128]     }
[10:22:48.128]     if (FALSE) {
[10:22:48.128]     }
[10:22:48.128]     else {
[10:22:48.128]         if (TRUE) {
[10:22:48.128]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:48.128]                 open = "w")
[10:22:48.128]         }
[10:22:48.128]         else {
[10:22:48.128]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:48.128]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:48.128]         }
[10:22:48.128]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:48.128]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:48.128]             base::sink(type = "output", split = FALSE)
[10:22:48.128]             base::close(...future.stdout)
[10:22:48.128]         }, add = TRUE)
[10:22:48.128]     }
[10:22:48.128]     ...future.frame <- base::sys.nframe()
[10:22:48.128]     ...future.conditions <- base::list()
[10:22:48.128]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:48.128]     if (FALSE) {
[10:22:48.128]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:48.128]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:48.128]     }
[10:22:48.128]     ...future.result <- base::tryCatch({
[10:22:48.128]         base::withCallingHandlers({
[10:22:48.128]             ...future.value <- base::withVisible(base::local({
[10:22:48.128]                 ...future.makeSendCondition <- base::local({
[10:22:48.128]                   sendCondition <- NULL
[10:22:48.128]                   function(frame = 1L) {
[10:22:48.128]                     if (is.function(sendCondition)) 
[10:22:48.128]                       return(sendCondition)
[10:22:48.128]                     ns <- getNamespace("parallel")
[10:22:48.128]                     if (exists("sendData", mode = "function", 
[10:22:48.128]                       envir = ns)) {
[10:22:48.128]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:48.128]                         envir = ns)
[10:22:48.128]                       envir <- sys.frame(frame)
[10:22:48.128]                       master <- NULL
[10:22:48.128]                       while (!identical(envir, .GlobalEnv) && 
[10:22:48.128]                         !identical(envir, emptyenv())) {
[10:22:48.128]                         if (exists("master", mode = "list", envir = envir, 
[10:22:48.128]                           inherits = FALSE)) {
[10:22:48.128]                           master <- get("master", mode = "list", 
[10:22:48.128]                             envir = envir, inherits = FALSE)
[10:22:48.128]                           if (inherits(master, c("SOCKnode", 
[10:22:48.128]                             "SOCK0node"))) {
[10:22:48.128]                             sendCondition <<- function(cond) {
[10:22:48.128]                               data <- list(type = "VALUE", value = cond, 
[10:22:48.128]                                 success = TRUE)
[10:22:48.128]                               parallel_sendData(master, data)
[10:22:48.128]                             }
[10:22:48.128]                             return(sendCondition)
[10:22:48.128]                           }
[10:22:48.128]                         }
[10:22:48.128]                         frame <- frame + 1L
[10:22:48.128]                         envir <- sys.frame(frame)
[10:22:48.128]                       }
[10:22:48.128]                     }
[10:22:48.128]                     sendCondition <<- function(cond) NULL
[10:22:48.128]                   }
[10:22:48.128]                 })
[10:22:48.128]                 withCallingHandlers({
[10:22:48.128]                   list(a = 1, b = 42L, c = stop("Nah!"))
[10:22:48.128]                 }, immediateCondition = function(cond) {
[10:22:48.128]                   sendCondition <- ...future.makeSendCondition()
[10:22:48.128]                   sendCondition(cond)
[10:22:48.128]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.128]                   {
[10:22:48.128]                     inherits <- base::inherits
[10:22:48.128]                     invokeRestart <- base::invokeRestart
[10:22:48.128]                     is.null <- base::is.null
[10:22:48.128]                     muffled <- FALSE
[10:22:48.128]                     if (inherits(cond, "message")) {
[10:22:48.128]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:48.128]                       if (muffled) 
[10:22:48.128]                         invokeRestart("muffleMessage")
[10:22:48.128]                     }
[10:22:48.128]                     else if (inherits(cond, "warning")) {
[10:22:48.128]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:48.128]                       if (muffled) 
[10:22:48.128]                         invokeRestart("muffleWarning")
[10:22:48.128]                     }
[10:22:48.128]                     else if (inherits(cond, "condition")) {
[10:22:48.128]                       if (!is.null(pattern)) {
[10:22:48.128]                         computeRestarts <- base::computeRestarts
[10:22:48.128]                         grepl <- base::grepl
[10:22:48.128]                         restarts <- computeRestarts(cond)
[10:22:48.128]                         for (restart in restarts) {
[10:22:48.128]                           name <- restart$name
[10:22:48.128]                           if (is.null(name)) 
[10:22:48.128]                             next
[10:22:48.128]                           if (!grepl(pattern, name)) 
[10:22:48.128]                             next
[10:22:48.128]                           invokeRestart(restart)
[10:22:48.128]                           muffled <- TRUE
[10:22:48.128]                           break
[10:22:48.128]                         }
[10:22:48.128]                       }
[10:22:48.128]                     }
[10:22:48.128]                     invisible(muffled)
[10:22:48.128]                   }
[10:22:48.128]                   muffleCondition(cond)
[10:22:48.128]                 })
[10:22:48.128]             }))
[10:22:48.128]             future::FutureResult(value = ...future.value$value, 
[10:22:48.128]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.128]                   ...future.rng), globalenv = if (FALSE) 
[10:22:48.128]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:48.128]                     ...future.globalenv.names))
[10:22:48.128]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:48.128]         }, condition = base::local({
[10:22:48.128]             c <- base::c
[10:22:48.128]             inherits <- base::inherits
[10:22:48.128]             invokeRestart <- base::invokeRestart
[10:22:48.128]             length <- base::length
[10:22:48.128]             list <- base::list
[10:22:48.128]             seq.int <- base::seq.int
[10:22:48.128]             signalCondition <- base::signalCondition
[10:22:48.128]             sys.calls <- base::sys.calls
[10:22:48.128]             `[[` <- base::`[[`
[10:22:48.128]             `+` <- base::`+`
[10:22:48.128]             `<<-` <- base::`<<-`
[10:22:48.128]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:48.128]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:48.128]                   3L)]
[10:22:48.128]             }
[10:22:48.128]             function(cond) {
[10:22:48.128]                 is_error <- inherits(cond, "error")
[10:22:48.128]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:48.128]                   NULL)
[10:22:48.128]                 if (is_error) {
[10:22:48.128]                   sessionInformation <- function() {
[10:22:48.128]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:48.128]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:48.128]                       search = base::search(), system = base::Sys.info())
[10:22:48.128]                   }
[10:22:48.128]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.128]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:48.128]                     cond$call), session = sessionInformation(), 
[10:22:48.128]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:48.128]                   signalCondition(cond)
[10:22:48.128]                 }
[10:22:48.128]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:48.128]                 "immediateCondition"))) {
[10:22:48.128]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:48.128]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.128]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:48.128]                   if (TRUE && !signal) {
[10:22:48.128]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.128]                     {
[10:22:48.128]                       inherits <- base::inherits
[10:22:48.128]                       invokeRestart <- base::invokeRestart
[10:22:48.128]                       is.null <- base::is.null
[10:22:48.128]                       muffled <- FALSE
[10:22:48.128]                       if (inherits(cond, "message")) {
[10:22:48.128]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.128]                         if (muffled) 
[10:22:48.128]                           invokeRestart("muffleMessage")
[10:22:48.128]                       }
[10:22:48.128]                       else if (inherits(cond, "warning")) {
[10:22:48.128]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.128]                         if (muffled) 
[10:22:48.128]                           invokeRestart("muffleWarning")
[10:22:48.128]                       }
[10:22:48.128]                       else if (inherits(cond, "condition")) {
[10:22:48.128]                         if (!is.null(pattern)) {
[10:22:48.128]                           computeRestarts <- base::computeRestarts
[10:22:48.128]                           grepl <- base::grepl
[10:22:48.128]                           restarts <- computeRestarts(cond)
[10:22:48.128]                           for (restart in restarts) {
[10:22:48.128]                             name <- restart$name
[10:22:48.128]                             if (is.null(name)) 
[10:22:48.128]                               next
[10:22:48.128]                             if (!grepl(pattern, name)) 
[10:22:48.128]                               next
[10:22:48.128]                             invokeRestart(restart)
[10:22:48.128]                             muffled <- TRUE
[10:22:48.128]                             break
[10:22:48.128]                           }
[10:22:48.128]                         }
[10:22:48.128]                       }
[10:22:48.128]                       invisible(muffled)
[10:22:48.128]                     }
[10:22:48.128]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.128]                   }
[10:22:48.128]                 }
[10:22:48.128]                 else {
[10:22:48.128]                   if (TRUE) {
[10:22:48.128]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.128]                     {
[10:22:48.128]                       inherits <- base::inherits
[10:22:48.128]                       invokeRestart <- base::invokeRestart
[10:22:48.128]                       is.null <- base::is.null
[10:22:48.128]                       muffled <- FALSE
[10:22:48.128]                       if (inherits(cond, "message")) {
[10:22:48.128]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.128]                         if (muffled) 
[10:22:48.128]                           invokeRestart("muffleMessage")
[10:22:48.128]                       }
[10:22:48.128]                       else if (inherits(cond, "warning")) {
[10:22:48.128]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.128]                         if (muffled) 
[10:22:48.128]                           invokeRestart("muffleWarning")
[10:22:48.128]                       }
[10:22:48.128]                       else if (inherits(cond, "condition")) {
[10:22:48.128]                         if (!is.null(pattern)) {
[10:22:48.128]                           computeRestarts <- base::computeRestarts
[10:22:48.128]                           grepl <- base::grepl
[10:22:48.128]                           restarts <- computeRestarts(cond)
[10:22:48.128]                           for (restart in restarts) {
[10:22:48.128]                             name <- restart$name
[10:22:48.128]                             if (is.null(name)) 
[10:22:48.128]                               next
[10:22:48.128]                             if (!grepl(pattern, name)) 
[10:22:48.128]                               next
[10:22:48.128]                             invokeRestart(restart)
[10:22:48.128]                             muffled <- TRUE
[10:22:48.128]                             break
[10:22:48.128]                           }
[10:22:48.128]                         }
[10:22:48.128]                       }
[10:22:48.128]                       invisible(muffled)
[10:22:48.128]                     }
[10:22:48.128]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.128]                   }
[10:22:48.128]                 }
[10:22:48.128]             }
[10:22:48.128]         }))
[10:22:48.128]     }, error = function(ex) {
[10:22:48.128]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:48.128]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.128]                 ...future.rng), started = ...future.startTime, 
[10:22:48.128]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:48.128]             version = "1.8"), class = "FutureResult")
[10:22:48.128]     }, finally = {
[10:22:48.128]         if (!identical(...future.workdir, getwd())) 
[10:22:48.128]             setwd(...future.workdir)
[10:22:48.128]         {
[10:22:48.128]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:48.128]                 ...future.oldOptions$nwarnings <- NULL
[10:22:48.128]             }
[10:22:48.128]             base::options(...future.oldOptions)
[10:22:48.128]             if (.Platform$OS.type == "windows") {
[10:22:48.128]                 old_names <- names(...future.oldEnvVars)
[10:22:48.128]                 envs <- base::Sys.getenv()
[10:22:48.128]                 names <- names(envs)
[10:22:48.128]                 common <- intersect(names, old_names)
[10:22:48.128]                 added <- setdiff(names, old_names)
[10:22:48.128]                 removed <- setdiff(old_names, names)
[10:22:48.128]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:48.128]                   envs[common]]
[10:22:48.128]                 NAMES <- toupper(changed)
[10:22:48.128]                 args <- list()
[10:22:48.128]                 for (kk in seq_along(NAMES)) {
[10:22:48.128]                   name <- changed[[kk]]
[10:22:48.128]                   NAME <- NAMES[[kk]]
[10:22:48.128]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.128]                     next
[10:22:48.128]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.128]                 }
[10:22:48.128]                 NAMES <- toupper(added)
[10:22:48.128]                 for (kk in seq_along(NAMES)) {
[10:22:48.128]                   name <- added[[kk]]
[10:22:48.128]                   NAME <- NAMES[[kk]]
[10:22:48.128]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.128]                     next
[10:22:48.128]                   args[[name]] <- ""
[10:22:48.128]                 }
[10:22:48.128]                 NAMES <- toupper(removed)
[10:22:48.128]                 for (kk in seq_along(NAMES)) {
[10:22:48.128]                   name <- removed[[kk]]
[10:22:48.128]                   NAME <- NAMES[[kk]]
[10:22:48.128]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.128]                     next
[10:22:48.128]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.128]                 }
[10:22:48.128]                 if (length(args) > 0) 
[10:22:48.128]                   base::do.call(base::Sys.setenv, args = args)
[10:22:48.128]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:48.128]             }
[10:22:48.128]             else {
[10:22:48.128]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:48.128]             }
[10:22:48.128]             {
[10:22:48.128]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:48.128]                   0L) {
[10:22:48.128]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:48.128]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:48.128]                   base::options(opts)
[10:22:48.128]                 }
[10:22:48.128]                 {
[10:22:48.128]                   {
[10:22:48.128]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:48.128]                     NULL
[10:22:48.128]                   }
[10:22:48.128]                   options(future.plan = NULL)
[10:22:48.128]                   if (is.na(NA_character_)) 
[10:22:48.128]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.128]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:48.128]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:48.128]                     .init = FALSE)
[10:22:48.128]                 }
[10:22:48.128]             }
[10:22:48.128]         }
[10:22:48.128]     })
[10:22:48.128]     if (TRUE) {
[10:22:48.128]         base::sink(type = "output", split = FALSE)
[10:22:48.128]         if (TRUE) {
[10:22:48.128]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:48.128]         }
[10:22:48.128]         else {
[10:22:48.128]             ...future.result["stdout"] <- base::list(NULL)
[10:22:48.128]         }
[10:22:48.128]         base::close(...future.stdout)
[10:22:48.128]         ...future.stdout <- NULL
[10:22:48.128]     }
[10:22:48.128]     ...future.result$conditions <- ...future.conditions
[10:22:48.128]     ...future.result$finished <- base::Sys.time()
[10:22:48.128]     ...future.result
[10:22:48.128] }
[10:22:48.131] MultisessionFuture started
[10:22:48.131] - Launch lazy future ... done
[10:22:48.131] run() for ‘MultisessionFuture’ ... done
[10:22:48.173] receiveMessageFromWorker() for ClusterFuture ...
[10:22:48.173] - Validating connection of MultisessionFuture
[10:22:48.174] - received message: FutureResult
[10:22:48.174] - Received FutureResult
[10:22:48.174] - Erased future from FutureRegistry
[10:22:48.174] result() for ClusterFuture ...
[10:22:48.174] - result already collected: FutureResult
[10:22:48.174] result() for ClusterFuture ... done
[10:22:48.174] signalConditions() ...
[10:22:48.175]  - include = ‘immediateCondition’
[10:22:48.175]  - exclude = 
[10:22:48.175]  - resignal = FALSE
[10:22:48.175]  - Number of conditions: 1
[10:22:48.175] signalConditions() ... done
[10:22:48.175] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:48.175] A MultisessionFuture was resolved (and resolved itself)
- result = TRUE, recursive = Inf ... DONE
*** resolve() for Future objects ... DONE
*** resolve() for lists ...
[10:22:48.175] resolve() on list ...
[10:22:48.175]  recursive: 0
[10:22:48.176]  length: 2
[10:22:48.176]  elements: ‘a’, ‘b’
[10:22:48.176]  length: 1 (resolved future 1)
[10:22:48.176]  length: 0 (resolved future 2)
[10:22:48.176] resolve() on list ... DONE
[10:22:48.176] getGlobalsAndPackages() ...
[10:22:48.176] Searching for globals...
[10:22:48.176] 
[10:22:48.176] Searching for globals ... DONE
[10:22:48.177] - globals: [0] <none>
[10:22:48.177] getGlobalsAndPackages() ... DONE
[10:22:48.177] run() for ‘Future’ ...
[10:22:48.177] - state: ‘created’
[10:22:48.177] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:48.191] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:48.191] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:48.191]   - Field: ‘node’
[10:22:48.191]   - Field: ‘label’
[10:22:48.191]   - Field: ‘local’
[10:22:48.191]   - Field: ‘owner’
[10:22:48.191]   - Field: ‘envir’
[10:22:48.191]   - Field: ‘workers’
[10:22:48.191]   - Field: ‘packages’
[10:22:48.192]   - Field: ‘gc’
[10:22:48.192]   - Field: ‘conditions’
[10:22:48.192]   - Field: ‘persistent’
[10:22:48.192]   - Field: ‘expr’
[10:22:48.192]   - Field: ‘uuid’
[10:22:48.192]   - Field: ‘seed’
[10:22:48.192]   - Field: ‘version’
[10:22:48.192]   - Field: ‘result’
[10:22:48.192]   - Field: ‘asynchronous’
[10:22:48.192]   - Field: ‘calls’
[10:22:48.192]   - Field: ‘globals’
[10:22:48.193]   - Field: ‘stdout’
[10:22:48.193]   - Field: ‘earlySignal’
[10:22:48.193]   - Field: ‘lazy’
[10:22:48.193]   - Field: ‘state’
[10:22:48.193] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:48.193] - Launch lazy future ...
[10:22:48.193] Packages needed by the future expression (n = 0): <none>
[10:22:48.193] Packages needed by future strategies (n = 0): <none>
[10:22:48.194] {
[10:22:48.194]     {
[10:22:48.194]         {
[10:22:48.194]             ...future.startTime <- base::Sys.time()
[10:22:48.194]             {
[10:22:48.194]                 {
[10:22:48.194]                   {
[10:22:48.194]                     {
[10:22:48.194]                       base::local({
[10:22:48.194]                         has_future <- base::requireNamespace("future", 
[10:22:48.194]                           quietly = TRUE)
[10:22:48.194]                         if (has_future) {
[10:22:48.194]                           ns <- base::getNamespace("future")
[10:22:48.194]                           version <- ns[[".package"]][["version"]]
[10:22:48.194]                           if (is.null(version)) 
[10:22:48.194]                             version <- utils::packageVersion("future")
[10:22:48.194]                         }
[10:22:48.194]                         else {
[10:22:48.194]                           version <- NULL
[10:22:48.194]                         }
[10:22:48.194]                         if (!has_future || version < "1.8.0") {
[10:22:48.194]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:48.194]                             "", base::R.version$version.string), 
[10:22:48.194]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:48.194]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:48.194]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:48.194]                               "release", "version")], collapse = " "), 
[10:22:48.194]                             hostname = base::Sys.info()[["nodename"]])
[10:22:48.194]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:48.194]                             info)
[10:22:48.194]                           info <- base::paste(info, collapse = "; ")
[10:22:48.194]                           if (!has_future) {
[10:22:48.194]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:48.194]                               info)
[10:22:48.194]                           }
[10:22:48.194]                           else {
[10:22:48.194]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:48.194]                               info, version)
[10:22:48.194]                           }
[10:22:48.194]                           base::stop(msg)
[10:22:48.194]                         }
[10:22:48.194]                       })
[10:22:48.194]                     }
[10:22:48.194]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:48.194]                     base::options(mc.cores = 1L)
[10:22:48.194]                   }
[10:22:48.194]                   ...future.strategy.old <- future::plan("list")
[10:22:48.194]                   options(future.plan = NULL)
[10:22:48.194]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.194]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:48.194]                 }
[10:22:48.194]                 ...future.workdir <- getwd()
[10:22:48.194]             }
[10:22:48.194]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:48.194]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:48.194]         }
[10:22:48.194]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:48.194]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:48.194]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:48.194]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:48.194]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:48.194]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:48.194]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:48.194]             base::names(...future.oldOptions))
[10:22:48.194]     }
[10:22:48.194]     if (FALSE) {
[10:22:48.194]     }
[10:22:48.194]     else {
[10:22:48.194]         if (TRUE) {
[10:22:48.194]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:48.194]                 open = "w")
[10:22:48.194]         }
[10:22:48.194]         else {
[10:22:48.194]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:48.194]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:48.194]         }
[10:22:48.194]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:48.194]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:48.194]             base::sink(type = "output", split = FALSE)
[10:22:48.194]             base::close(...future.stdout)
[10:22:48.194]         }, add = TRUE)
[10:22:48.194]     }
[10:22:48.194]     ...future.frame <- base::sys.nframe()
[10:22:48.194]     ...future.conditions <- base::list()
[10:22:48.194]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:48.194]     if (FALSE) {
[10:22:48.194]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:48.194]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:48.194]     }
[10:22:48.194]     ...future.result <- base::tryCatch({
[10:22:48.194]         base::withCallingHandlers({
[10:22:48.194]             ...future.value <- base::withVisible(base::local({
[10:22:48.194]                 ...future.makeSendCondition <- base::local({
[10:22:48.194]                   sendCondition <- NULL
[10:22:48.194]                   function(frame = 1L) {
[10:22:48.194]                     if (is.function(sendCondition)) 
[10:22:48.194]                       return(sendCondition)
[10:22:48.194]                     ns <- getNamespace("parallel")
[10:22:48.194]                     if (exists("sendData", mode = "function", 
[10:22:48.194]                       envir = ns)) {
[10:22:48.194]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:48.194]                         envir = ns)
[10:22:48.194]                       envir <- sys.frame(frame)
[10:22:48.194]                       master <- NULL
[10:22:48.194]                       while (!identical(envir, .GlobalEnv) && 
[10:22:48.194]                         !identical(envir, emptyenv())) {
[10:22:48.194]                         if (exists("master", mode = "list", envir = envir, 
[10:22:48.194]                           inherits = FALSE)) {
[10:22:48.194]                           master <- get("master", mode = "list", 
[10:22:48.194]                             envir = envir, inherits = FALSE)
[10:22:48.194]                           if (inherits(master, c("SOCKnode", 
[10:22:48.194]                             "SOCK0node"))) {
[10:22:48.194]                             sendCondition <<- function(cond) {
[10:22:48.194]                               data <- list(type = "VALUE", value = cond, 
[10:22:48.194]                                 success = TRUE)
[10:22:48.194]                               parallel_sendData(master, data)
[10:22:48.194]                             }
[10:22:48.194]                             return(sendCondition)
[10:22:48.194]                           }
[10:22:48.194]                         }
[10:22:48.194]                         frame <- frame + 1L
[10:22:48.194]                         envir <- sys.frame(frame)
[10:22:48.194]                       }
[10:22:48.194]                     }
[10:22:48.194]                     sendCondition <<- function(cond) NULL
[10:22:48.194]                   }
[10:22:48.194]                 })
[10:22:48.194]                 withCallingHandlers({
[10:22:48.194]                   1
[10:22:48.194]                 }, immediateCondition = function(cond) {
[10:22:48.194]                   sendCondition <- ...future.makeSendCondition()
[10:22:48.194]                   sendCondition(cond)
[10:22:48.194]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.194]                   {
[10:22:48.194]                     inherits <- base::inherits
[10:22:48.194]                     invokeRestart <- base::invokeRestart
[10:22:48.194]                     is.null <- base::is.null
[10:22:48.194]                     muffled <- FALSE
[10:22:48.194]                     if (inherits(cond, "message")) {
[10:22:48.194]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:48.194]                       if (muffled) 
[10:22:48.194]                         invokeRestart("muffleMessage")
[10:22:48.194]                     }
[10:22:48.194]                     else if (inherits(cond, "warning")) {
[10:22:48.194]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:48.194]                       if (muffled) 
[10:22:48.194]                         invokeRestart("muffleWarning")
[10:22:48.194]                     }
[10:22:48.194]                     else if (inherits(cond, "condition")) {
[10:22:48.194]                       if (!is.null(pattern)) {
[10:22:48.194]                         computeRestarts <- base::computeRestarts
[10:22:48.194]                         grepl <- base::grepl
[10:22:48.194]                         restarts <- computeRestarts(cond)
[10:22:48.194]                         for (restart in restarts) {
[10:22:48.194]                           name <- restart$name
[10:22:48.194]                           if (is.null(name)) 
[10:22:48.194]                             next
[10:22:48.194]                           if (!grepl(pattern, name)) 
[10:22:48.194]                             next
[10:22:48.194]                           invokeRestart(restart)
[10:22:48.194]                           muffled <- TRUE
[10:22:48.194]                           break
[10:22:48.194]                         }
[10:22:48.194]                       }
[10:22:48.194]                     }
[10:22:48.194]                     invisible(muffled)
[10:22:48.194]                   }
[10:22:48.194]                   muffleCondition(cond)
[10:22:48.194]                 })
[10:22:48.194]             }))
[10:22:48.194]             future::FutureResult(value = ...future.value$value, 
[10:22:48.194]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.194]                   ...future.rng), globalenv = if (FALSE) 
[10:22:48.194]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:48.194]                     ...future.globalenv.names))
[10:22:48.194]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:48.194]         }, condition = base::local({
[10:22:48.194]             c <- base::c
[10:22:48.194]             inherits <- base::inherits
[10:22:48.194]             invokeRestart <- base::invokeRestart
[10:22:48.194]             length <- base::length
[10:22:48.194]             list <- base::list
[10:22:48.194]             seq.int <- base::seq.int
[10:22:48.194]             signalCondition <- base::signalCondition
[10:22:48.194]             sys.calls <- base::sys.calls
[10:22:48.194]             `[[` <- base::`[[`
[10:22:48.194]             `+` <- base::`+`
[10:22:48.194]             `<<-` <- base::`<<-`
[10:22:48.194]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:48.194]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:48.194]                   3L)]
[10:22:48.194]             }
[10:22:48.194]             function(cond) {
[10:22:48.194]                 is_error <- inherits(cond, "error")
[10:22:48.194]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:48.194]                   NULL)
[10:22:48.194]                 if (is_error) {
[10:22:48.194]                   sessionInformation <- function() {
[10:22:48.194]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:48.194]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:48.194]                       search = base::search(), system = base::Sys.info())
[10:22:48.194]                   }
[10:22:48.194]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.194]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:48.194]                     cond$call), session = sessionInformation(), 
[10:22:48.194]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:48.194]                   signalCondition(cond)
[10:22:48.194]                 }
[10:22:48.194]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:48.194]                 "immediateCondition"))) {
[10:22:48.194]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:48.194]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.194]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:48.194]                   if (TRUE && !signal) {
[10:22:48.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.194]                     {
[10:22:48.194]                       inherits <- base::inherits
[10:22:48.194]                       invokeRestart <- base::invokeRestart
[10:22:48.194]                       is.null <- base::is.null
[10:22:48.194]                       muffled <- FALSE
[10:22:48.194]                       if (inherits(cond, "message")) {
[10:22:48.194]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.194]                         if (muffled) 
[10:22:48.194]                           invokeRestart("muffleMessage")
[10:22:48.194]                       }
[10:22:48.194]                       else if (inherits(cond, "warning")) {
[10:22:48.194]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.194]                         if (muffled) 
[10:22:48.194]                           invokeRestart("muffleWarning")
[10:22:48.194]                       }
[10:22:48.194]                       else if (inherits(cond, "condition")) {
[10:22:48.194]                         if (!is.null(pattern)) {
[10:22:48.194]                           computeRestarts <- base::computeRestarts
[10:22:48.194]                           grepl <- base::grepl
[10:22:48.194]                           restarts <- computeRestarts(cond)
[10:22:48.194]                           for (restart in restarts) {
[10:22:48.194]                             name <- restart$name
[10:22:48.194]                             if (is.null(name)) 
[10:22:48.194]                               next
[10:22:48.194]                             if (!grepl(pattern, name)) 
[10:22:48.194]                               next
[10:22:48.194]                             invokeRestart(restart)
[10:22:48.194]                             muffled <- TRUE
[10:22:48.194]                             break
[10:22:48.194]                           }
[10:22:48.194]                         }
[10:22:48.194]                       }
[10:22:48.194]                       invisible(muffled)
[10:22:48.194]                     }
[10:22:48.194]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.194]                   }
[10:22:48.194]                 }
[10:22:48.194]                 else {
[10:22:48.194]                   if (TRUE) {
[10:22:48.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.194]                     {
[10:22:48.194]                       inherits <- base::inherits
[10:22:48.194]                       invokeRestart <- base::invokeRestart
[10:22:48.194]                       is.null <- base::is.null
[10:22:48.194]                       muffled <- FALSE
[10:22:48.194]                       if (inherits(cond, "message")) {
[10:22:48.194]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.194]                         if (muffled) 
[10:22:48.194]                           invokeRestart("muffleMessage")
[10:22:48.194]                       }
[10:22:48.194]                       else if (inherits(cond, "warning")) {
[10:22:48.194]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.194]                         if (muffled) 
[10:22:48.194]                           invokeRestart("muffleWarning")
[10:22:48.194]                       }
[10:22:48.194]                       else if (inherits(cond, "condition")) {
[10:22:48.194]                         if (!is.null(pattern)) {
[10:22:48.194]                           computeRestarts <- base::computeRestarts
[10:22:48.194]                           grepl <- base::grepl
[10:22:48.194]                           restarts <- computeRestarts(cond)
[10:22:48.194]                           for (restart in restarts) {
[10:22:48.194]                             name <- restart$name
[10:22:48.194]                             if (is.null(name)) 
[10:22:48.194]                               next
[10:22:48.194]                             if (!grepl(pattern, name)) 
[10:22:48.194]                               next
[10:22:48.194]                             invokeRestart(restart)
[10:22:48.194]                             muffled <- TRUE
[10:22:48.194]                             break
[10:22:48.194]                           }
[10:22:48.194]                         }
[10:22:48.194]                       }
[10:22:48.194]                       invisible(muffled)
[10:22:48.194]                     }
[10:22:48.194]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.194]                   }
[10:22:48.194]                 }
[10:22:48.194]             }
[10:22:48.194]         }))
[10:22:48.194]     }, error = function(ex) {
[10:22:48.194]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:48.194]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.194]                 ...future.rng), started = ...future.startTime, 
[10:22:48.194]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:48.194]             version = "1.8"), class = "FutureResult")
[10:22:48.194]     }, finally = {
[10:22:48.194]         if (!identical(...future.workdir, getwd())) 
[10:22:48.194]             setwd(...future.workdir)
[10:22:48.194]         {
[10:22:48.194]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:48.194]                 ...future.oldOptions$nwarnings <- NULL
[10:22:48.194]             }
[10:22:48.194]             base::options(...future.oldOptions)
[10:22:48.194]             if (.Platform$OS.type == "windows") {
[10:22:48.194]                 old_names <- names(...future.oldEnvVars)
[10:22:48.194]                 envs <- base::Sys.getenv()
[10:22:48.194]                 names <- names(envs)
[10:22:48.194]                 common <- intersect(names, old_names)
[10:22:48.194]                 added <- setdiff(names, old_names)
[10:22:48.194]                 removed <- setdiff(old_names, names)
[10:22:48.194]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:48.194]                   envs[common]]
[10:22:48.194]                 NAMES <- toupper(changed)
[10:22:48.194]                 args <- list()
[10:22:48.194]                 for (kk in seq_along(NAMES)) {
[10:22:48.194]                   name <- changed[[kk]]
[10:22:48.194]                   NAME <- NAMES[[kk]]
[10:22:48.194]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.194]                     next
[10:22:48.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.194]                 }
[10:22:48.194]                 NAMES <- toupper(added)
[10:22:48.194]                 for (kk in seq_along(NAMES)) {
[10:22:48.194]                   name <- added[[kk]]
[10:22:48.194]                   NAME <- NAMES[[kk]]
[10:22:48.194]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.194]                     next
[10:22:48.194]                   args[[name]] <- ""
[10:22:48.194]                 }
[10:22:48.194]                 NAMES <- toupper(removed)
[10:22:48.194]                 for (kk in seq_along(NAMES)) {
[10:22:48.194]                   name <- removed[[kk]]
[10:22:48.194]                   NAME <- NAMES[[kk]]
[10:22:48.194]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.194]                     next
[10:22:48.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.194]                 }
[10:22:48.194]                 if (length(args) > 0) 
[10:22:48.194]                   base::do.call(base::Sys.setenv, args = args)
[10:22:48.194]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:48.194]             }
[10:22:48.194]             else {
[10:22:48.194]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:48.194]             }
[10:22:48.194]             {
[10:22:48.194]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:48.194]                   0L) {
[10:22:48.194]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:48.194]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:48.194]                   base::options(opts)
[10:22:48.194]                 }
[10:22:48.194]                 {
[10:22:48.194]                   {
[10:22:48.194]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:48.194]                     NULL
[10:22:48.194]                   }
[10:22:48.194]                   options(future.plan = NULL)
[10:22:48.194]                   if (is.na(NA_character_)) 
[10:22:48.194]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.194]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:48.194]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:48.194]                     .init = FALSE)
[10:22:48.194]                 }
[10:22:48.194]             }
[10:22:48.194]         }
[10:22:48.194]     })
[10:22:48.194]     if (TRUE) {
[10:22:48.194]         base::sink(type = "output", split = FALSE)
[10:22:48.194]         if (TRUE) {
[10:22:48.194]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:48.194]         }
[10:22:48.194]         else {
[10:22:48.194]             ...future.result["stdout"] <- base::list(NULL)
[10:22:48.194]         }
[10:22:48.194]         base::close(...future.stdout)
[10:22:48.194]         ...future.stdout <- NULL
[10:22:48.194]     }
[10:22:48.194]     ...future.result$conditions <- ...future.conditions
[10:22:48.194]     ...future.result$finished <- base::Sys.time()
[10:22:48.194]     ...future.result
[10:22:48.194] }
[10:22:48.197] MultisessionFuture started
[10:22:48.197] - Launch lazy future ... done
[10:22:48.197] run() for ‘MultisessionFuture’ ... done
[10:22:48.197] getGlobalsAndPackages() ...
[10:22:48.197] Searching for globals...
[10:22:48.197] 
[10:22:48.197] Searching for globals ... DONE
[10:22:48.198] - globals: [0] <none>
[10:22:48.198] getGlobalsAndPackages() ... DONE
[10:22:48.198] run() for ‘Future’ ...
[10:22:48.198] - state: ‘created’
[10:22:48.198] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:48.212] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:48.212] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:48.212]   - Field: ‘node’
[10:22:48.212]   - Field: ‘label’
[10:22:48.212]   - Field: ‘local’
[10:22:48.212]   - Field: ‘owner’
[10:22:48.212]   - Field: ‘envir’
[10:22:48.212]   - Field: ‘workers’
[10:22:48.212]   - Field: ‘packages’
[10:22:48.212]   - Field: ‘gc’
[10:22:48.212]   - Field: ‘conditions’
[10:22:48.213]   - Field: ‘persistent’
[10:22:48.213]   - Field: ‘expr’
[10:22:48.213]   - Field: ‘uuid’
[10:22:48.213]   - Field: ‘seed’
[10:22:48.213]   - Field: ‘version’
[10:22:48.213]   - Field: ‘result’
[10:22:48.213]   - Field: ‘asynchronous’
[10:22:48.213]   - Field: ‘calls’
[10:22:48.213]   - Field: ‘globals’
[10:22:48.213]   - Field: ‘stdout’
[10:22:48.213]   - Field: ‘earlySignal’
[10:22:48.213]   - Field: ‘lazy’
[10:22:48.214]   - Field: ‘state’
[10:22:48.214] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:48.214] - Launch lazy future ...
[10:22:48.214] Packages needed by the future expression (n = 0): <none>
[10:22:48.214] Packages needed by future strategies (n = 0): <none>
[10:22:48.214] {
[10:22:48.214]     {
[10:22:48.214]         {
[10:22:48.214]             ...future.startTime <- base::Sys.time()
[10:22:48.214]             {
[10:22:48.214]                 {
[10:22:48.214]                   {
[10:22:48.214]                     {
[10:22:48.214]                       base::local({
[10:22:48.214]                         has_future <- base::requireNamespace("future", 
[10:22:48.214]                           quietly = TRUE)
[10:22:48.214]                         if (has_future) {
[10:22:48.214]                           ns <- base::getNamespace("future")
[10:22:48.214]                           version <- ns[[".package"]][["version"]]
[10:22:48.214]                           if (is.null(version)) 
[10:22:48.214]                             version <- utils::packageVersion("future")
[10:22:48.214]                         }
[10:22:48.214]                         else {
[10:22:48.214]                           version <- NULL
[10:22:48.214]                         }
[10:22:48.214]                         if (!has_future || version < "1.8.0") {
[10:22:48.214]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:48.214]                             "", base::R.version$version.string), 
[10:22:48.214]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:48.214]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:48.214]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:48.214]                               "release", "version")], collapse = " "), 
[10:22:48.214]                             hostname = base::Sys.info()[["nodename"]])
[10:22:48.214]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:48.214]                             info)
[10:22:48.214]                           info <- base::paste(info, collapse = "; ")
[10:22:48.214]                           if (!has_future) {
[10:22:48.214]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:48.214]                               info)
[10:22:48.214]                           }
[10:22:48.214]                           else {
[10:22:48.214]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:48.214]                               info, version)
[10:22:48.214]                           }
[10:22:48.214]                           base::stop(msg)
[10:22:48.214]                         }
[10:22:48.214]                       })
[10:22:48.214]                     }
[10:22:48.214]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:48.214]                     base::options(mc.cores = 1L)
[10:22:48.214]                   }
[10:22:48.214]                   ...future.strategy.old <- future::plan("list")
[10:22:48.214]                   options(future.plan = NULL)
[10:22:48.214]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.214]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:48.214]                 }
[10:22:48.214]                 ...future.workdir <- getwd()
[10:22:48.214]             }
[10:22:48.214]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:48.214]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:48.214]         }
[10:22:48.214]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:48.214]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:48.214]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:48.214]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:48.214]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:48.214]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:48.214]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:48.214]             base::names(...future.oldOptions))
[10:22:48.214]     }
[10:22:48.214]     if (FALSE) {
[10:22:48.214]     }
[10:22:48.214]     else {
[10:22:48.214]         if (TRUE) {
[10:22:48.214]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:48.214]                 open = "w")
[10:22:48.214]         }
[10:22:48.214]         else {
[10:22:48.214]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:48.214]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:48.214]         }
[10:22:48.214]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:48.214]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:48.214]             base::sink(type = "output", split = FALSE)
[10:22:48.214]             base::close(...future.stdout)
[10:22:48.214]         }, add = TRUE)
[10:22:48.214]     }
[10:22:48.214]     ...future.frame <- base::sys.nframe()
[10:22:48.214]     ...future.conditions <- base::list()
[10:22:48.214]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:48.214]     if (FALSE) {
[10:22:48.214]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:48.214]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:48.214]     }
[10:22:48.214]     ...future.result <- base::tryCatch({
[10:22:48.214]         base::withCallingHandlers({
[10:22:48.214]             ...future.value <- base::withVisible(base::local({
[10:22:48.214]                 ...future.makeSendCondition <- base::local({
[10:22:48.214]                   sendCondition <- NULL
[10:22:48.214]                   function(frame = 1L) {
[10:22:48.214]                     if (is.function(sendCondition)) 
[10:22:48.214]                       return(sendCondition)
[10:22:48.214]                     ns <- getNamespace("parallel")
[10:22:48.214]                     if (exists("sendData", mode = "function", 
[10:22:48.214]                       envir = ns)) {
[10:22:48.214]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:48.214]                         envir = ns)
[10:22:48.214]                       envir <- sys.frame(frame)
[10:22:48.214]                       master <- NULL
[10:22:48.214]                       while (!identical(envir, .GlobalEnv) && 
[10:22:48.214]                         !identical(envir, emptyenv())) {
[10:22:48.214]                         if (exists("master", mode = "list", envir = envir, 
[10:22:48.214]                           inherits = FALSE)) {
[10:22:48.214]                           master <- get("master", mode = "list", 
[10:22:48.214]                             envir = envir, inherits = FALSE)
[10:22:48.214]                           if (inherits(master, c("SOCKnode", 
[10:22:48.214]                             "SOCK0node"))) {
[10:22:48.214]                             sendCondition <<- function(cond) {
[10:22:48.214]                               data <- list(type = "VALUE", value = cond, 
[10:22:48.214]                                 success = TRUE)
[10:22:48.214]                               parallel_sendData(master, data)
[10:22:48.214]                             }
[10:22:48.214]                             return(sendCondition)
[10:22:48.214]                           }
[10:22:48.214]                         }
[10:22:48.214]                         frame <- frame + 1L
[10:22:48.214]                         envir <- sys.frame(frame)
[10:22:48.214]                       }
[10:22:48.214]                     }
[10:22:48.214]                     sendCondition <<- function(cond) NULL
[10:22:48.214]                   }
[10:22:48.214]                 })
[10:22:48.214]                 withCallingHandlers({
[10:22:48.214]                   2
[10:22:48.214]                 }, immediateCondition = function(cond) {
[10:22:48.214]                   sendCondition <- ...future.makeSendCondition()
[10:22:48.214]                   sendCondition(cond)
[10:22:48.214]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.214]                   {
[10:22:48.214]                     inherits <- base::inherits
[10:22:48.214]                     invokeRestart <- base::invokeRestart
[10:22:48.214]                     is.null <- base::is.null
[10:22:48.214]                     muffled <- FALSE
[10:22:48.214]                     if (inherits(cond, "message")) {
[10:22:48.214]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:48.214]                       if (muffled) 
[10:22:48.214]                         invokeRestart("muffleMessage")
[10:22:48.214]                     }
[10:22:48.214]                     else if (inherits(cond, "warning")) {
[10:22:48.214]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:48.214]                       if (muffled) 
[10:22:48.214]                         invokeRestart("muffleWarning")
[10:22:48.214]                     }
[10:22:48.214]                     else if (inherits(cond, "condition")) {
[10:22:48.214]                       if (!is.null(pattern)) {
[10:22:48.214]                         computeRestarts <- base::computeRestarts
[10:22:48.214]                         grepl <- base::grepl
[10:22:48.214]                         restarts <- computeRestarts(cond)
[10:22:48.214]                         for (restart in restarts) {
[10:22:48.214]                           name <- restart$name
[10:22:48.214]                           if (is.null(name)) 
[10:22:48.214]                             next
[10:22:48.214]                           if (!grepl(pattern, name)) 
[10:22:48.214]                             next
[10:22:48.214]                           invokeRestart(restart)
[10:22:48.214]                           muffled <- TRUE
[10:22:48.214]                           break
[10:22:48.214]                         }
[10:22:48.214]                       }
[10:22:48.214]                     }
[10:22:48.214]                     invisible(muffled)
[10:22:48.214]                   }
[10:22:48.214]                   muffleCondition(cond)
[10:22:48.214]                 })
[10:22:48.214]             }))
[10:22:48.214]             future::FutureResult(value = ...future.value$value, 
[10:22:48.214]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.214]                   ...future.rng), globalenv = if (FALSE) 
[10:22:48.214]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:48.214]                     ...future.globalenv.names))
[10:22:48.214]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:48.214]         }, condition = base::local({
[10:22:48.214]             c <- base::c
[10:22:48.214]             inherits <- base::inherits
[10:22:48.214]             invokeRestart <- base::invokeRestart
[10:22:48.214]             length <- base::length
[10:22:48.214]             list <- base::list
[10:22:48.214]             seq.int <- base::seq.int
[10:22:48.214]             signalCondition <- base::signalCondition
[10:22:48.214]             sys.calls <- base::sys.calls
[10:22:48.214]             `[[` <- base::`[[`
[10:22:48.214]             `+` <- base::`+`
[10:22:48.214]             `<<-` <- base::`<<-`
[10:22:48.214]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:48.214]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:48.214]                   3L)]
[10:22:48.214]             }
[10:22:48.214]             function(cond) {
[10:22:48.214]                 is_error <- inherits(cond, "error")
[10:22:48.214]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:48.214]                   NULL)
[10:22:48.214]                 if (is_error) {
[10:22:48.214]                   sessionInformation <- function() {
[10:22:48.214]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:48.214]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:48.214]                       search = base::search(), system = base::Sys.info())
[10:22:48.214]                   }
[10:22:48.214]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.214]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:48.214]                     cond$call), session = sessionInformation(), 
[10:22:48.214]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:48.214]                   signalCondition(cond)
[10:22:48.214]                 }
[10:22:48.214]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:48.214]                 "immediateCondition"))) {
[10:22:48.214]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:48.214]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.214]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:48.214]                   if (TRUE && !signal) {
[10:22:48.214]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.214]                     {
[10:22:48.214]                       inherits <- base::inherits
[10:22:48.214]                       invokeRestart <- base::invokeRestart
[10:22:48.214]                       is.null <- base::is.null
[10:22:48.214]                       muffled <- FALSE
[10:22:48.214]                       if (inherits(cond, "message")) {
[10:22:48.214]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.214]                         if (muffled) 
[10:22:48.214]                           invokeRestart("muffleMessage")
[10:22:48.214]                       }
[10:22:48.214]                       else if (inherits(cond, "warning")) {
[10:22:48.214]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.214]                         if (muffled) 
[10:22:48.214]                           invokeRestart("muffleWarning")
[10:22:48.214]                       }
[10:22:48.214]                       else if (inherits(cond, "condition")) {
[10:22:48.214]                         if (!is.null(pattern)) {
[10:22:48.214]                           computeRestarts <- base::computeRestarts
[10:22:48.214]                           grepl <- base::grepl
[10:22:48.214]                           restarts <- computeRestarts(cond)
[10:22:48.214]                           for (restart in restarts) {
[10:22:48.214]                             name <- restart$name
[10:22:48.214]                             if (is.null(name)) 
[10:22:48.214]                               next
[10:22:48.214]                             if (!grepl(pattern, name)) 
[10:22:48.214]                               next
[10:22:48.214]                             invokeRestart(restart)
[10:22:48.214]                             muffled <- TRUE
[10:22:48.214]                             break
[10:22:48.214]                           }
[10:22:48.214]                         }
[10:22:48.214]                       }
[10:22:48.214]                       invisible(muffled)
[10:22:48.214]                     }
[10:22:48.214]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.214]                   }
[10:22:48.214]                 }
[10:22:48.214]                 else {
[10:22:48.214]                   if (TRUE) {
[10:22:48.214]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.214]                     {
[10:22:48.214]                       inherits <- base::inherits
[10:22:48.214]                       invokeRestart <- base::invokeRestart
[10:22:48.214]                       is.null <- base::is.null
[10:22:48.214]                       muffled <- FALSE
[10:22:48.214]                       if (inherits(cond, "message")) {
[10:22:48.214]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.214]                         if (muffled) 
[10:22:48.214]                           invokeRestart("muffleMessage")
[10:22:48.214]                       }
[10:22:48.214]                       else if (inherits(cond, "warning")) {
[10:22:48.214]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.214]                         if (muffled) 
[10:22:48.214]                           invokeRestart("muffleWarning")
[10:22:48.214]                       }
[10:22:48.214]                       else if (inherits(cond, "condition")) {
[10:22:48.214]                         if (!is.null(pattern)) {
[10:22:48.214]                           computeRestarts <- base::computeRestarts
[10:22:48.214]                           grepl <- base::grepl
[10:22:48.214]                           restarts <- computeRestarts(cond)
[10:22:48.214]                           for (restart in restarts) {
[10:22:48.214]                             name <- restart$name
[10:22:48.214]                             if (is.null(name)) 
[10:22:48.214]                               next
[10:22:48.214]                             if (!grepl(pattern, name)) 
[10:22:48.214]                               next
[10:22:48.214]                             invokeRestart(restart)
[10:22:48.214]                             muffled <- TRUE
[10:22:48.214]                             break
[10:22:48.214]                           }
[10:22:48.214]                         }
[10:22:48.214]                       }
[10:22:48.214]                       invisible(muffled)
[10:22:48.214]                     }
[10:22:48.214]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.214]                   }
[10:22:48.214]                 }
[10:22:48.214]             }
[10:22:48.214]         }))
[10:22:48.214]     }, error = function(ex) {
[10:22:48.214]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:48.214]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.214]                 ...future.rng), started = ...future.startTime, 
[10:22:48.214]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:48.214]             version = "1.8"), class = "FutureResult")
[10:22:48.214]     }, finally = {
[10:22:48.214]         if (!identical(...future.workdir, getwd())) 
[10:22:48.214]             setwd(...future.workdir)
[10:22:48.214]         {
[10:22:48.214]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:48.214]                 ...future.oldOptions$nwarnings <- NULL
[10:22:48.214]             }
[10:22:48.214]             base::options(...future.oldOptions)
[10:22:48.214]             if (.Platform$OS.type == "windows") {
[10:22:48.214]                 old_names <- names(...future.oldEnvVars)
[10:22:48.214]                 envs <- base::Sys.getenv()
[10:22:48.214]                 names <- names(envs)
[10:22:48.214]                 common <- intersect(names, old_names)
[10:22:48.214]                 added <- setdiff(names, old_names)
[10:22:48.214]                 removed <- setdiff(old_names, names)
[10:22:48.214]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:48.214]                   envs[common]]
[10:22:48.214]                 NAMES <- toupper(changed)
[10:22:48.214]                 args <- list()
[10:22:48.214]                 for (kk in seq_along(NAMES)) {
[10:22:48.214]                   name <- changed[[kk]]
[10:22:48.214]                   NAME <- NAMES[[kk]]
[10:22:48.214]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.214]                     next
[10:22:48.214]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.214]                 }
[10:22:48.214]                 NAMES <- toupper(added)
[10:22:48.214]                 for (kk in seq_along(NAMES)) {
[10:22:48.214]                   name <- added[[kk]]
[10:22:48.214]                   NAME <- NAMES[[kk]]
[10:22:48.214]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.214]                     next
[10:22:48.214]                   args[[name]] <- ""
[10:22:48.214]                 }
[10:22:48.214]                 NAMES <- toupper(removed)
[10:22:48.214]                 for (kk in seq_along(NAMES)) {
[10:22:48.214]                   name <- removed[[kk]]
[10:22:48.214]                   NAME <- NAMES[[kk]]
[10:22:48.214]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.214]                     next
[10:22:48.214]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.214]                 }
[10:22:48.214]                 if (length(args) > 0) 
[10:22:48.214]                   base::do.call(base::Sys.setenv, args = args)
[10:22:48.214]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:48.214]             }
[10:22:48.214]             else {
[10:22:48.214]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:48.214]             }
[10:22:48.214]             {
[10:22:48.214]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:48.214]                   0L) {
[10:22:48.214]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:48.214]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:48.214]                   base::options(opts)
[10:22:48.214]                 }
[10:22:48.214]                 {
[10:22:48.214]                   {
[10:22:48.214]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:48.214]                     NULL
[10:22:48.214]                   }
[10:22:48.214]                   options(future.plan = NULL)
[10:22:48.214]                   if (is.na(NA_character_)) 
[10:22:48.214]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.214]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:48.214]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:48.214]                     .init = FALSE)
[10:22:48.214]                 }
[10:22:48.214]             }
[10:22:48.214]         }
[10:22:48.214]     })
[10:22:48.214]     if (TRUE) {
[10:22:48.214]         base::sink(type = "output", split = FALSE)
[10:22:48.214]         if (TRUE) {
[10:22:48.214]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:48.214]         }
[10:22:48.214]         else {
[10:22:48.214]             ...future.result["stdout"] <- base::list(NULL)
[10:22:48.214]         }
[10:22:48.214]         base::close(...future.stdout)
[10:22:48.214]         ...future.stdout <- NULL
[10:22:48.214]     }
[10:22:48.214]     ...future.result$conditions <- ...future.conditions
[10:22:48.214]     ...future.result$finished <- base::Sys.time()
[10:22:48.214]     ...future.result
[10:22:48.214] }
[10:22:48.217] Poll #1 (0): usedNodes() = 2, workers = 2
[10:22:48.227] receiveMessageFromWorker() for ClusterFuture ...
[10:22:48.227] - Validating connection of MultisessionFuture
[10:22:48.228] - received message: FutureResult
[10:22:48.228] - Received FutureResult
[10:22:48.228] - Erased future from FutureRegistry
[10:22:48.228] result() for ClusterFuture ...
[10:22:48.228] - result already collected: FutureResult
[10:22:48.228] result() for ClusterFuture ... done
[10:22:48.228] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:48.228] result() for ClusterFuture ...
[10:22:48.228] - result already collected: FutureResult
[10:22:48.229] result() for ClusterFuture ... done
[10:22:48.229] result() for ClusterFuture ...
[10:22:48.229] - result already collected: FutureResult
[10:22:48.229] result() for ClusterFuture ... done
[10:22:48.230] MultisessionFuture started
[10:22:48.230] - Launch lazy future ... done
[10:22:48.230] run() for ‘MultisessionFuture’ ... done
[10:22:48.230] resolve() on list ...
[10:22:48.230]  recursive: 0
[10:22:48.230]  length: 3
[10:22:48.230]  elements: ‘a’, ‘b’, ‘’
[10:22:48.239] receiveMessageFromWorker() for ClusterFuture ...
[10:22:48.239] - Validating connection of MultisessionFuture
[10:22:48.239] - received message: FutureResult
[10:22:48.239] - Received FutureResult
[10:22:48.239] - Erased future from FutureRegistry
[10:22:48.239] result() for ClusterFuture ...
[10:22:48.240] - result already collected: FutureResult
[10:22:48.240] result() for ClusterFuture ... done
[10:22:48.240] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:48.240] Future #1
[10:22:48.240]  length: 2 (resolved future 1)
[10:22:48.250]  length: 1 (resolved future 3)
[10:22:48.282] receiveMessageFromWorker() for ClusterFuture ...
[10:22:48.282] - Validating connection of MultisessionFuture
[10:22:48.282] - received message: FutureResult
[10:22:48.282] - Received FutureResult
[10:22:48.282] - Erased future from FutureRegistry
[10:22:48.282] result() for ClusterFuture ...
[10:22:48.282] - result already collected: FutureResult
[10:22:48.282] result() for ClusterFuture ... done
[10:22:48.283] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:48.283] Future #2
[10:22:48.283]  length: 0 (resolved future 2)
[10:22:48.283] resolve() on list ... DONE
[10:22:48.283] getGlobalsAndPackages() ...
[10:22:48.283] Searching for globals...
[10:22:48.283] 
[10:22:48.283] Searching for globals ... DONE
[10:22:48.284] - globals: [0] <none>
[10:22:48.284] getGlobalsAndPackages() ... DONE
[10:22:48.284] getGlobalsAndPackages() ...
[10:22:48.284] Searching for globals...
[10:22:48.284] 
[10:22:48.284] Searching for globals ... DONE
[10:22:48.284] - globals: [0] <none>
[10:22:48.285] getGlobalsAndPackages() ... DONE
[10:22:48.285] run() for ‘Future’ ...
[10:22:48.285] - state: ‘created’
[10:22:48.285] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:48.299] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:48.299] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:48.299]   - Field: ‘node’
[10:22:48.299]   - Field: ‘label’
[10:22:48.299]   - Field: ‘local’
[10:22:48.299]   - Field: ‘owner’
[10:22:48.299]   - Field: ‘envir’
[10:22:48.299]   - Field: ‘workers’
[10:22:48.300]   - Field: ‘packages’
[10:22:48.300]   - Field: ‘gc’
[10:22:48.300]   - Field: ‘conditions’
[10:22:48.300]   - Field: ‘persistent’
[10:22:48.300]   - Field: ‘expr’
[10:22:48.300]   - Field: ‘uuid’
[10:22:48.300]   - Field: ‘seed’
[10:22:48.300]   - Field: ‘version’
[10:22:48.300]   - Field: ‘result’
[10:22:48.300]   - Field: ‘asynchronous’
[10:22:48.300]   - Field: ‘calls’
[10:22:48.300]   - Field: ‘globals’
[10:22:48.301]   - Field: ‘stdout’
[10:22:48.301]   - Field: ‘earlySignal’
[10:22:48.301]   - Field: ‘lazy’
[10:22:48.301]   - Field: ‘state’
[10:22:48.301] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:48.301] - Launch lazy future ...
[10:22:48.301] Packages needed by the future expression (n = 0): <none>
[10:22:48.301] Packages needed by future strategies (n = 0): <none>
[10:22:48.302] {
[10:22:48.302]     {
[10:22:48.302]         {
[10:22:48.302]             ...future.startTime <- base::Sys.time()
[10:22:48.302]             {
[10:22:48.302]                 {
[10:22:48.302]                   {
[10:22:48.302]                     {
[10:22:48.302]                       base::local({
[10:22:48.302]                         has_future <- base::requireNamespace("future", 
[10:22:48.302]                           quietly = TRUE)
[10:22:48.302]                         if (has_future) {
[10:22:48.302]                           ns <- base::getNamespace("future")
[10:22:48.302]                           version <- ns[[".package"]][["version"]]
[10:22:48.302]                           if (is.null(version)) 
[10:22:48.302]                             version <- utils::packageVersion("future")
[10:22:48.302]                         }
[10:22:48.302]                         else {
[10:22:48.302]                           version <- NULL
[10:22:48.302]                         }
[10:22:48.302]                         if (!has_future || version < "1.8.0") {
[10:22:48.302]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:48.302]                             "", base::R.version$version.string), 
[10:22:48.302]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:48.302]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:48.302]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:48.302]                               "release", "version")], collapse = " "), 
[10:22:48.302]                             hostname = base::Sys.info()[["nodename"]])
[10:22:48.302]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:48.302]                             info)
[10:22:48.302]                           info <- base::paste(info, collapse = "; ")
[10:22:48.302]                           if (!has_future) {
[10:22:48.302]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:48.302]                               info)
[10:22:48.302]                           }
[10:22:48.302]                           else {
[10:22:48.302]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:48.302]                               info, version)
[10:22:48.302]                           }
[10:22:48.302]                           base::stop(msg)
[10:22:48.302]                         }
[10:22:48.302]                       })
[10:22:48.302]                     }
[10:22:48.302]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:48.302]                     base::options(mc.cores = 1L)
[10:22:48.302]                   }
[10:22:48.302]                   ...future.strategy.old <- future::plan("list")
[10:22:48.302]                   options(future.plan = NULL)
[10:22:48.302]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.302]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:48.302]                 }
[10:22:48.302]                 ...future.workdir <- getwd()
[10:22:48.302]             }
[10:22:48.302]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:48.302]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:48.302]         }
[10:22:48.302]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:48.302]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:48.302]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:48.302]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:48.302]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:48.302]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:48.302]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:48.302]             base::names(...future.oldOptions))
[10:22:48.302]     }
[10:22:48.302]     if (FALSE) {
[10:22:48.302]     }
[10:22:48.302]     else {
[10:22:48.302]         if (TRUE) {
[10:22:48.302]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:48.302]                 open = "w")
[10:22:48.302]         }
[10:22:48.302]         else {
[10:22:48.302]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:48.302]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:48.302]         }
[10:22:48.302]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:48.302]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:48.302]             base::sink(type = "output", split = FALSE)
[10:22:48.302]             base::close(...future.stdout)
[10:22:48.302]         }, add = TRUE)
[10:22:48.302]     }
[10:22:48.302]     ...future.frame <- base::sys.nframe()
[10:22:48.302]     ...future.conditions <- base::list()
[10:22:48.302]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:48.302]     if (FALSE) {
[10:22:48.302]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:48.302]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:48.302]     }
[10:22:48.302]     ...future.result <- base::tryCatch({
[10:22:48.302]         base::withCallingHandlers({
[10:22:48.302]             ...future.value <- base::withVisible(base::local({
[10:22:48.302]                 ...future.makeSendCondition <- base::local({
[10:22:48.302]                   sendCondition <- NULL
[10:22:48.302]                   function(frame = 1L) {
[10:22:48.302]                     if (is.function(sendCondition)) 
[10:22:48.302]                       return(sendCondition)
[10:22:48.302]                     ns <- getNamespace("parallel")
[10:22:48.302]                     if (exists("sendData", mode = "function", 
[10:22:48.302]                       envir = ns)) {
[10:22:48.302]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:48.302]                         envir = ns)
[10:22:48.302]                       envir <- sys.frame(frame)
[10:22:48.302]                       master <- NULL
[10:22:48.302]                       while (!identical(envir, .GlobalEnv) && 
[10:22:48.302]                         !identical(envir, emptyenv())) {
[10:22:48.302]                         if (exists("master", mode = "list", envir = envir, 
[10:22:48.302]                           inherits = FALSE)) {
[10:22:48.302]                           master <- get("master", mode = "list", 
[10:22:48.302]                             envir = envir, inherits = FALSE)
[10:22:48.302]                           if (inherits(master, c("SOCKnode", 
[10:22:48.302]                             "SOCK0node"))) {
[10:22:48.302]                             sendCondition <<- function(cond) {
[10:22:48.302]                               data <- list(type = "VALUE", value = cond, 
[10:22:48.302]                                 success = TRUE)
[10:22:48.302]                               parallel_sendData(master, data)
[10:22:48.302]                             }
[10:22:48.302]                             return(sendCondition)
[10:22:48.302]                           }
[10:22:48.302]                         }
[10:22:48.302]                         frame <- frame + 1L
[10:22:48.302]                         envir <- sys.frame(frame)
[10:22:48.302]                       }
[10:22:48.302]                     }
[10:22:48.302]                     sendCondition <<- function(cond) NULL
[10:22:48.302]                   }
[10:22:48.302]                 })
[10:22:48.302]                 withCallingHandlers({
[10:22:48.302]                   2
[10:22:48.302]                 }, immediateCondition = function(cond) {
[10:22:48.302]                   sendCondition <- ...future.makeSendCondition()
[10:22:48.302]                   sendCondition(cond)
[10:22:48.302]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.302]                   {
[10:22:48.302]                     inherits <- base::inherits
[10:22:48.302]                     invokeRestart <- base::invokeRestart
[10:22:48.302]                     is.null <- base::is.null
[10:22:48.302]                     muffled <- FALSE
[10:22:48.302]                     if (inherits(cond, "message")) {
[10:22:48.302]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:48.302]                       if (muffled) 
[10:22:48.302]                         invokeRestart("muffleMessage")
[10:22:48.302]                     }
[10:22:48.302]                     else if (inherits(cond, "warning")) {
[10:22:48.302]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:48.302]                       if (muffled) 
[10:22:48.302]                         invokeRestart("muffleWarning")
[10:22:48.302]                     }
[10:22:48.302]                     else if (inherits(cond, "condition")) {
[10:22:48.302]                       if (!is.null(pattern)) {
[10:22:48.302]                         computeRestarts <- base::computeRestarts
[10:22:48.302]                         grepl <- base::grepl
[10:22:48.302]                         restarts <- computeRestarts(cond)
[10:22:48.302]                         for (restart in restarts) {
[10:22:48.302]                           name <- restart$name
[10:22:48.302]                           if (is.null(name)) 
[10:22:48.302]                             next
[10:22:48.302]                           if (!grepl(pattern, name)) 
[10:22:48.302]                             next
[10:22:48.302]                           invokeRestart(restart)
[10:22:48.302]                           muffled <- TRUE
[10:22:48.302]                           break
[10:22:48.302]                         }
[10:22:48.302]                       }
[10:22:48.302]                     }
[10:22:48.302]                     invisible(muffled)
[10:22:48.302]                   }
[10:22:48.302]                   muffleCondition(cond)
[10:22:48.302]                 })
[10:22:48.302]             }))
[10:22:48.302]             future::FutureResult(value = ...future.value$value, 
[10:22:48.302]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.302]                   ...future.rng), globalenv = if (FALSE) 
[10:22:48.302]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:48.302]                     ...future.globalenv.names))
[10:22:48.302]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:48.302]         }, condition = base::local({
[10:22:48.302]             c <- base::c
[10:22:48.302]             inherits <- base::inherits
[10:22:48.302]             invokeRestart <- base::invokeRestart
[10:22:48.302]             length <- base::length
[10:22:48.302]             list <- base::list
[10:22:48.302]             seq.int <- base::seq.int
[10:22:48.302]             signalCondition <- base::signalCondition
[10:22:48.302]             sys.calls <- base::sys.calls
[10:22:48.302]             `[[` <- base::`[[`
[10:22:48.302]             `+` <- base::`+`
[10:22:48.302]             `<<-` <- base::`<<-`
[10:22:48.302]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:48.302]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:48.302]                   3L)]
[10:22:48.302]             }
[10:22:48.302]             function(cond) {
[10:22:48.302]                 is_error <- inherits(cond, "error")
[10:22:48.302]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:48.302]                   NULL)
[10:22:48.302]                 if (is_error) {
[10:22:48.302]                   sessionInformation <- function() {
[10:22:48.302]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:48.302]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:48.302]                       search = base::search(), system = base::Sys.info())
[10:22:48.302]                   }
[10:22:48.302]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.302]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:48.302]                     cond$call), session = sessionInformation(), 
[10:22:48.302]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:48.302]                   signalCondition(cond)
[10:22:48.302]                 }
[10:22:48.302]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:48.302]                 "immediateCondition"))) {
[10:22:48.302]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:48.302]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.302]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:48.302]                   if (TRUE && !signal) {
[10:22:48.302]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.302]                     {
[10:22:48.302]                       inherits <- base::inherits
[10:22:48.302]                       invokeRestart <- base::invokeRestart
[10:22:48.302]                       is.null <- base::is.null
[10:22:48.302]                       muffled <- FALSE
[10:22:48.302]                       if (inherits(cond, "message")) {
[10:22:48.302]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.302]                         if (muffled) 
[10:22:48.302]                           invokeRestart("muffleMessage")
[10:22:48.302]                       }
[10:22:48.302]                       else if (inherits(cond, "warning")) {
[10:22:48.302]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.302]                         if (muffled) 
[10:22:48.302]                           invokeRestart("muffleWarning")
[10:22:48.302]                       }
[10:22:48.302]                       else if (inherits(cond, "condition")) {
[10:22:48.302]                         if (!is.null(pattern)) {
[10:22:48.302]                           computeRestarts <- base::computeRestarts
[10:22:48.302]                           grepl <- base::grepl
[10:22:48.302]                           restarts <- computeRestarts(cond)
[10:22:48.302]                           for (restart in restarts) {
[10:22:48.302]                             name <- restart$name
[10:22:48.302]                             if (is.null(name)) 
[10:22:48.302]                               next
[10:22:48.302]                             if (!grepl(pattern, name)) 
[10:22:48.302]                               next
[10:22:48.302]                             invokeRestart(restart)
[10:22:48.302]                             muffled <- TRUE
[10:22:48.302]                             break
[10:22:48.302]                           }
[10:22:48.302]                         }
[10:22:48.302]                       }
[10:22:48.302]                       invisible(muffled)
[10:22:48.302]                     }
[10:22:48.302]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.302]                   }
[10:22:48.302]                 }
[10:22:48.302]                 else {
[10:22:48.302]                   if (TRUE) {
[10:22:48.302]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.302]                     {
[10:22:48.302]                       inherits <- base::inherits
[10:22:48.302]                       invokeRestart <- base::invokeRestart
[10:22:48.302]                       is.null <- base::is.null
[10:22:48.302]                       muffled <- FALSE
[10:22:48.302]                       if (inherits(cond, "message")) {
[10:22:48.302]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.302]                         if (muffled) 
[10:22:48.302]                           invokeRestart("muffleMessage")
[10:22:48.302]                       }
[10:22:48.302]                       else if (inherits(cond, "warning")) {
[10:22:48.302]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.302]                         if (muffled) 
[10:22:48.302]                           invokeRestart("muffleWarning")
[10:22:48.302]                       }
[10:22:48.302]                       else if (inherits(cond, "condition")) {
[10:22:48.302]                         if (!is.null(pattern)) {
[10:22:48.302]                           computeRestarts <- base::computeRestarts
[10:22:48.302]                           grepl <- base::grepl
[10:22:48.302]                           restarts <- computeRestarts(cond)
[10:22:48.302]                           for (restart in restarts) {
[10:22:48.302]                             name <- restart$name
[10:22:48.302]                             if (is.null(name)) 
[10:22:48.302]                               next
[10:22:48.302]                             if (!grepl(pattern, name)) 
[10:22:48.302]                               next
[10:22:48.302]                             invokeRestart(restart)
[10:22:48.302]                             muffled <- TRUE
[10:22:48.302]                             break
[10:22:48.302]                           }
[10:22:48.302]                         }
[10:22:48.302]                       }
[10:22:48.302]                       invisible(muffled)
[10:22:48.302]                     }
[10:22:48.302]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.302]                   }
[10:22:48.302]                 }
[10:22:48.302]             }
[10:22:48.302]         }))
[10:22:48.302]     }, error = function(ex) {
[10:22:48.302]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:48.302]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.302]                 ...future.rng), started = ...future.startTime, 
[10:22:48.302]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:48.302]             version = "1.8"), class = "FutureResult")
[10:22:48.302]     }, finally = {
[10:22:48.302]         if (!identical(...future.workdir, getwd())) 
[10:22:48.302]             setwd(...future.workdir)
[10:22:48.302]         {
[10:22:48.302]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:48.302]                 ...future.oldOptions$nwarnings <- NULL
[10:22:48.302]             }
[10:22:48.302]             base::options(...future.oldOptions)
[10:22:48.302]             if (.Platform$OS.type == "windows") {
[10:22:48.302]                 old_names <- names(...future.oldEnvVars)
[10:22:48.302]                 envs <- base::Sys.getenv()
[10:22:48.302]                 names <- names(envs)
[10:22:48.302]                 common <- intersect(names, old_names)
[10:22:48.302]                 added <- setdiff(names, old_names)
[10:22:48.302]                 removed <- setdiff(old_names, names)
[10:22:48.302]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:48.302]                   envs[common]]
[10:22:48.302]                 NAMES <- toupper(changed)
[10:22:48.302]                 args <- list()
[10:22:48.302]                 for (kk in seq_along(NAMES)) {
[10:22:48.302]                   name <- changed[[kk]]
[10:22:48.302]                   NAME <- NAMES[[kk]]
[10:22:48.302]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.302]                     next
[10:22:48.302]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.302]                 }
[10:22:48.302]                 NAMES <- toupper(added)
[10:22:48.302]                 for (kk in seq_along(NAMES)) {
[10:22:48.302]                   name <- added[[kk]]
[10:22:48.302]                   NAME <- NAMES[[kk]]
[10:22:48.302]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.302]                     next
[10:22:48.302]                   args[[name]] <- ""
[10:22:48.302]                 }
[10:22:48.302]                 NAMES <- toupper(removed)
[10:22:48.302]                 for (kk in seq_along(NAMES)) {
[10:22:48.302]                   name <- removed[[kk]]
[10:22:48.302]                   NAME <- NAMES[[kk]]
[10:22:48.302]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.302]                     next
[10:22:48.302]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.302]                 }
[10:22:48.302]                 if (length(args) > 0) 
[10:22:48.302]                   base::do.call(base::Sys.setenv, args = args)
[10:22:48.302]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:48.302]             }
[10:22:48.302]             else {
[10:22:48.302]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:48.302]             }
[10:22:48.302]             {
[10:22:48.302]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:48.302]                   0L) {
[10:22:48.302]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:48.302]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:48.302]                   base::options(opts)
[10:22:48.302]                 }
[10:22:48.302]                 {
[10:22:48.302]                   {
[10:22:48.302]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:48.302]                     NULL
[10:22:48.302]                   }
[10:22:48.302]                   options(future.plan = NULL)
[10:22:48.302]                   if (is.na(NA_character_)) 
[10:22:48.302]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.302]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:48.302]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:48.302]                     .init = FALSE)
[10:22:48.302]                 }
[10:22:48.302]             }
[10:22:48.302]         }
[10:22:48.302]     })
[10:22:48.302]     if (TRUE) {
[10:22:48.302]         base::sink(type = "output", split = FALSE)
[10:22:48.302]         if (TRUE) {
[10:22:48.302]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:48.302]         }
[10:22:48.302]         else {
[10:22:48.302]             ...future.result["stdout"] <- base::list(NULL)
[10:22:48.302]         }
[10:22:48.302]         base::close(...future.stdout)
[10:22:48.302]         ...future.stdout <- NULL
[10:22:48.302]     }
[10:22:48.302]     ...future.result$conditions <- ...future.conditions
[10:22:48.302]     ...future.result$finished <- base::Sys.time()
[10:22:48.302]     ...future.result
[10:22:48.302] }
[10:22:48.305] MultisessionFuture started
[10:22:48.305] - Launch lazy future ... done
[10:22:48.305] run() for ‘MultisessionFuture’ ... done
[10:22:48.305] resolve() on list ...
[10:22:48.305]  recursive: 0
[10:22:48.305]  length: 3
[10:22:48.305]  elements: ‘a’, ‘b’, ‘’
[10:22:48.306] run() for ‘Future’ ...
[10:22:48.306] - state: ‘created’
[10:22:48.306] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:48.326] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:48.327] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:48.327]   - Field: ‘node’
[10:22:48.327]   - Field: ‘label’
[10:22:48.327]   - Field: ‘local’
[10:22:48.327]   - Field: ‘owner’
[10:22:48.327]   - Field: ‘envir’
[10:22:48.327]   - Field: ‘workers’
[10:22:48.327]   - Field: ‘packages’
[10:22:48.327]   - Field: ‘gc’
[10:22:48.327]   - Field: ‘conditions’
[10:22:48.327]   - Field: ‘persistent’
[10:22:48.328]   - Field: ‘expr’
[10:22:48.328]   - Field: ‘uuid’
[10:22:48.328]   - Field: ‘seed’
[10:22:48.328]   - Field: ‘version’
[10:22:48.328]   - Field: ‘result’
[10:22:48.328]   - Field: ‘asynchronous’
[10:22:48.328]   - Field: ‘calls’
[10:22:48.328]   - Field: ‘globals’
[10:22:48.328]   - Field: ‘stdout’
[10:22:48.328]   - Field: ‘earlySignal’
[10:22:48.328]   - Field: ‘lazy’
[10:22:48.328]   - Field: ‘state’
[10:22:48.329] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:48.329] - Launch lazy future ...
[10:22:48.329] Packages needed by the future expression (n = 0): <none>
[10:22:48.329] Packages needed by future strategies (n = 0): <none>
[10:22:48.329] {
[10:22:48.329]     {
[10:22:48.329]         {
[10:22:48.329]             ...future.startTime <- base::Sys.time()
[10:22:48.329]             {
[10:22:48.329]                 {
[10:22:48.329]                   {
[10:22:48.329]                     {
[10:22:48.329]                       base::local({
[10:22:48.329]                         has_future <- base::requireNamespace("future", 
[10:22:48.329]                           quietly = TRUE)
[10:22:48.329]                         if (has_future) {
[10:22:48.329]                           ns <- base::getNamespace("future")
[10:22:48.329]                           version <- ns[[".package"]][["version"]]
[10:22:48.329]                           if (is.null(version)) 
[10:22:48.329]                             version <- utils::packageVersion("future")
[10:22:48.329]                         }
[10:22:48.329]                         else {
[10:22:48.329]                           version <- NULL
[10:22:48.329]                         }
[10:22:48.329]                         if (!has_future || version < "1.8.0") {
[10:22:48.329]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:48.329]                             "", base::R.version$version.string), 
[10:22:48.329]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:48.329]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:48.329]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:48.329]                               "release", "version")], collapse = " "), 
[10:22:48.329]                             hostname = base::Sys.info()[["nodename"]])
[10:22:48.329]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:48.329]                             info)
[10:22:48.329]                           info <- base::paste(info, collapse = "; ")
[10:22:48.329]                           if (!has_future) {
[10:22:48.329]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:48.329]                               info)
[10:22:48.329]                           }
[10:22:48.329]                           else {
[10:22:48.329]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:48.329]                               info, version)
[10:22:48.329]                           }
[10:22:48.329]                           base::stop(msg)
[10:22:48.329]                         }
[10:22:48.329]                       })
[10:22:48.329]                     }
[10:22:48.329]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:48.329]                     base::options(mc.cores = 1L)
[10:22:48.329]                   }
[10:22:48.329]                   ...future.strategy.old <- future::plan("list")
[10:22:48.329]                   options(future.plan = NULL)
[10:22:48.329]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.329]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:48.329]                 }
[10:22:48.329]                 ...future.workdir <- getwd()
[10:22:48.329]             }
[10:22:48.329]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:48.329]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:48.329]         }
[10:22:48.329]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:48.329]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:48.329]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:48.329]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:48.329]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:48.329]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:48.329]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:48.329]             base::names(...future.oldOptions))
[10:22:48.329]     }
[10:22:48.329]     if (FALSE) {
[10:22:48.329]     }
[10:22:48.329]     else {
[10:22:48.329]         if (TRUE) {
[10:22:48.329]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:48.329]                 open = "w")
[10:22:48.329]         }
[10:22:48.329]         else {
[10:22:48.329]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:48.329]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:48.329]         }
[10:22:48.329]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:48.329]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:48.329]             base::sink(type = "output", split = FALSE)
[10:22:48.329]             base::close(...future.stdout)
[10:22:48.329]         }, add = TRUE)
[10:22:48.329]     }
[10:22:48.329]     ...future.frame <- base::sys.nframe()
[10:22:48.329]     ...future.conditions <- base::list()
[10:22:48.329]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:48.329]     if (FALSE) {
[10:22:48.329]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:48.329]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:48.329]     }
[10:22:48.329]     ...future.result <- base::tryCatch({
[10:22:48.329]         base::withCallingHandlers({
[10:22:48.329]             ...future.value <- base::withVisible(base::local({
[10:22:48.329]                 ...future.makeSendCondition <- base::local({
[10:22:48.329]                   sendCondition <- NULL
[10:22:48.329]                   function(frame = 1L) {
[10:22:48.329]                     if (is.function(sendCondition)) 
[10:22:48.329]                       return(sendCondition)
[10:22:48.329]                     ns <- getNamespace("parallel")
[10:22:48.329]                     if (exists("sendData", mode = "function", 
[10:22:48.329]                       envir = ns)) {
[10:22:48.329]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:48.329]                         envir = ns)
[10:22:48.329]                       envir <- sys.frame(frame)
[10:22:48.329]                       master <- NULL
[10:22:48.329]                       while (!identical(envir, .GlobalEnv) && 
[10:22:48.329]                         !identical(envir, emptyenv())) {
[10:22:48.329]                         if (exists("master", mode = "list", envir = envir, 
[10:22:48.329]                           inherits = FALSE)) {
[10:22:48.329]                           master <- get("master", mode = "list", 
[10:22:48.329]                             envir = envir, inherits = FALSE)
[10:22:48.329]                           if (inherits(master, c("SOCKnode", 
[10:22:48.329]                             "SOCK0node"))) {
[10:22:48.329]                             sendCondition <<- function(cond) {
[10:22:48.329]                               data <- list(type = "VALUE", value = cond, 
[10:22:48.329]                                 success = TRUE)
[10:22:48.329]                               parallel_sendData(master, data)
[10:22:48.329]                             }
[10:22:48.329]                             return(sendCondition)
[10:22:48.329]                           }
[10:22:48.329]                         }
[10:22:48.329]                         frame <- frame + 1L
[10:22:48.329]                         envir <- sys.frame(frame)
[10:22:48.329]                       }
[10:22:48.329]                     }
[10:22:48.329]                     sendCondition <<- function(cond) NULL
[10:22:48.329]                   }
[10:22:48.329]                 })
[10:22:48.329]                 withCallingHandlers({
[10:22:48.329]                   1
[10:22:48.329]                 }, immediateCondition = function(cond) {
[10:22:48.329]                   sendCondition <- ...future.makeSendCondition()
[10:22:48.329]                   sendCondition(cond)
[10:22:48.329]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.329]                   {
[10:22:48.329]                     inherits <- base::inherits
[10:22:48.329]                     invokeRestart <- base::invokeRestart
[10:22:48.329]                     is.null <- base::is.null
[10:22:48.329]                     muffled <- FALSE
[10:22:48.329]                     if (inherits(cond, "message")) {
[10:22:48.329]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:48.329]                       if (muffled) 
[10:22:48.329]                         invokeRestart("muffleMessage")
[10:22:48.329]                     }
[10:22:48.329]                     else if (inherits(cond, "warning")) {
[10:22:48.329]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:48.329]                       if (muffled) 
[10:22:48.329]                         invokeRestart("muffleWarning")
[10:22:48.329]                     }
[10:22:48.329]                     else if (inherits(cond, "condition")) {
[10:22:48.329]                       if (!is.null(pattern)) {
[10:22:48.329]                         computeRestarts <- base::computeRestarts
[10:22:48.329]                         grepl <- base::grepl
[10:22:48.329]                         restarts <- computeRestarts(cond)
[10:22:48.329]                         for (restart in restarts) {
[10:22:48.329]                           name <- restart$name
[10:22:48.329]                           if (is.null(name)) 
[10:22:48.329]                             next
[10:22:48.329]                           if (!grepl(pattern, name)) 
[10:22:48.329]                             next
[10:22:48.329]                           invokeRestart(restart)
[10:22:48.329]                           muffled <- TRUE
[10:22:48.329]                           break
[10:22:48.329]                         }
[10:22:48.329]                       }
[10:22:48.329]                     }
[10:22:48.329]                     invisible(muffled)
[10:22:48.329]                   }
[10:22:48.329]                   muffleCondition(cond)
[10:22:48.329]                 })
[10:22:48.329]             }))
[10:22:48.329]             future::FutureResult(value = ...future.value$value, 
[10:22:48.329]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.329]                   ...future.rng), globalenv = if (FALSE) 
[10:22:48.329]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:48.329]                     ...future.globalenv.names))
[10:22:48.329]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:48.329]         }, condition = base::local({
[10:22:48.329]             c <- base::c
[10:22:48.329]             inherits <- base::inherits
[10:22:48.329]             invokeRestart <- base::invokeRestart
[10:22:48.329]             length <- base::length
[10:22:48.329]             list <- base::list
[10:22:48.329]             seq.int <- base::seq.int
[10:22:48.329]             signalCondition <- base::signalCondition
[10:22:48.329]             sys.calls <- base::sys.calls
[10:22:48.329]             `[[` <- base::`[[`
[10:22:48.329]             `+` <- base::`+`
[10:22:48.329]             `<<-` <- base::`<<-`
[10:22:48.329]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:48.329]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:48.329]                   3L)]
[10:22:48.329]             }
[10:22:48.329]             function(cond) {
[10:22:48.329]                 is_error <- inherits(cond, "error")
[10:22:48.329]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:48.329]                   NULL)
[10:22:48.329]                 if (is_error) {
[10:22:48.329]                   sessionInformation <- function() {
[10:22:48.329]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:48.329]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:48.329]                       search = base::search(), system = base::Sys.info())
[10:22:48.329]                   }
[10:22:48.329]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.329]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:48.329]                     cond$call), session = sessionInformation(), 
[10:22:48.329]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:48.329]                   signalCondition(cond)
[10:22:48.329]                 }
[10:22:48.329]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:48.329]                 "immediateCondition"))) {
[10:22:48.329]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:48.329]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.329]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:48.329]                   if (TRUE && !signal) {
[10:22:48.329]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.329]                     {
[10:22:48.329]                       inherits <- base::inherits
[10:22:48.329]                       invokeRestart <- base::invokeRestart
[10:22:48.329]                       is.null <- base::is.null
[10:22:48.329]                       muffled <- FALSE
[10:22:48.329]                       if (inherits(cond, "message")) {
[10:22:48.329]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.329]                         if (muffled) 
[10:22:48.329]                           invokeRestart("muffleMessage")
[10:22:48.329]                       }
[10:22:48.329]                       else if (inherits(cond, "warning")) {
[10:22:48.329]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.329]                         if (muffled) 
[10:22:48.329]                           invokeRestart("muffleWarning")
[10:22:48.329]                       }
[10:22:48.329]                       else if (inherits(cond, "condition")) {
[10:22:48.329]                         if (!is.null(pattern)) {
[10:22:48.329]                           computeRestarts <- base::computeRestarts
[10:22:48.329]                           grepl <- base::grepl
[10:22:48.329]                           restarts <- computeRestarts(cond)
[10:22:48.329]                           for (restart in restarts) {
[10:22:48.329]                             name <- restart$name
[10:22:48.329]                             if (is.null(name)) 
[10:22:48.329]                               next
[10:22:48.329]                             if (!grepl(pattern, name)) 
[10:22:48.329]                               next
[10:22:48.329]                             invokeRestart(restart)
[10:22:48.329]                             muffled <- TRUE
[10:22:48.329]                             break
[10:22:48.329]                           }
[10:22:48.329]                         }
[10:22:48.329]                       }
[10:22:48.329]                       invisible(muffled)
[10:22:48.329]                     }
[10:22:48.329]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.329]                   }
[10:22:48.329]                 }
[10:22:48.329]                 else {
[10:22:48.329]                   if (TRUE) {
[10:22:48.329]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.329]                     {
[10:22:48.329]                       inherits <- base::inherits
[10:22:48.329]                       invokeRestart <- base::invokeRestart
[10:22:48.329]                       is.null <- base::is.null
[10:22:48.329]                       muffled <- FALSE
[10:22:48.329]                       if (inherits(cond, "message")) {
[10:22:48.329]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.329]                         if (muffled) 
[10:22:48.329]                           invokeRestart("muffleMessage")
[10:22:48.329]                       }
[10:22:48.329]                       else if (inherits(cond, "warning")) {
[10:22:48.329]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.329]                         if (muffled) 
[10:22:48.329]                           invokeRestart("muffleWarning")
[10:22:48.329]                       }
[10:22:48.329]                       else if (inherits(cond, "condition")) {
[10:22:48.329]                         if (!is.null(pattern)) {
[10:22:48.329]                           computeRestarts <- base::computeRestarts
[10:22:48.329]                           grepl <- base::grepl
[10:22:48.329]                           restarts <- computeRestarts(cond)
[10:22:48.329]                           for (restart in restarts) {
[10:22:48.329]                             name <- restart$name
[10:22:48.329]                             if (is.null(name)) 
[10:22:48.329]                               next
[10:22:48.329]                             if (!grepl(pattern, name)) 
[10:22:48.329]                               next
[10:22:48.329]                             invokeRestart(restart)
[10:22:48.329]                             muffled <- TRUE
[10:22:48.329]                             break
[10:22:48.329]                           }
[10:22:48.329]                         }
[10:22:48.329]                       }
[10:22:48.329]                       invisible(muffled)
[10:22:48.329]                     }
[10:22:48.329]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.329]                   }
[10:22:48.329]                 }
[10:22:48.329]             }
[10:22:48.329]         }))
[10:22:48.329]     }, error = function(ex) {
[10:22:48.329]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:48.329]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.329]                 ...future.rng), started = ...future.startTime, 
[10:22:48.329]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:48.329]             version = "1.8"), class = "FutureResult")
[10:22:48.329]     }, finally = {
[10:22:48.329]         if (!identical(...future.workdir, getwd())) 
[10:22:48.329]             setwd(...future.workdir)
[10:22:48.329]         {
[10:22:48.329]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:48.329]                 ...future.oldOptions$nwarnings <- NULL
[10:22:48.329]             }
[10:22:48.329]             base::options(...future.oldOptions)
[10:22:48.329]             if (.Platform$OS.type == "windows") {
[10:22:48.329]                 old_names <- names(...future.oldEnvVars)
[10:22:48.329]                 envs <- base::Sys.getenv()
[10:22:48.329]                 names <- names(envs)
[10:22:48.329]                 common <- intersect(names, old_names)
[10:22:48.329]                 added <- setdiff(names, old_names)
[10:22:48.329]                 removed <- setdiff(old_names, names)
[10:22:48.329]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:48.329]                   envs[common]]
[10:22:48.329]                 NAMES <- toupper(changed)
[10:22:48.329]                 args <- list()
[10:22:48.329]                 for (kk in seq_along(NAMES)) {
[10:22:48.329]                   name <- changed[[kk]]
[10:22:48.329]                   NAME <- NAMES[[kk]]
[10:22:48.329]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.329]                     next
[10:22:48.329]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.329]                 }
[10:22:48.329]                 NAMES <- toupper(added)
[10:22:48.329]                 for (kk in seq_along(NAMES)) {
[10:22:48.329]                   name <- added[[kk]]
[10:22:48.329]                   NAME <- NAMES[[kk]]
[10:22:48.329]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.329]                     next
[10:22:48.329]                   args[[name]] <- ""
[10:22:48.329]                 }
[10:22:48.329]                 NAMES <- toupper(removed)
[10:22:48.329]                 for (kk in seq_along(NAMES)) {
[10:22:48.329]                   name <- removed[[kk]]
[10:22:48.329]                   NAME <- NAMES[[kk]]
[10:22:48.329]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.329]                     next
[10:22:48.329]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.329]                 }
[10:22:48.329]                 if (length(args) > 0) 
[10:22:48.329]                   base::do.call(base::Sys.setenv, args = args)
[10:22:48.329]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:48.329]             }
[10:22:48.329]             else {
[10:22:48.329]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:48.329]             }
[10:22:48.329]             {
[10:22:48.329]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:48.329]                   0L) {
[10:22:48.329]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:48.329]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:48.329]                   base::options(opts)
[10:22:48.329]                 }
[10:22:48.329]                 {
[10:22:48.329]                   {
[10:22:48.329]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:48.329]                     NULL
[10:22:48.329]                   }
[10:22:48.329]                   options(future.plan = NULL)
[10:22:48.329]                   if (is.na(NA_character_)) 
[10:22:48.329]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.329]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:48.329]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:48.329]                     .init = FALSE)
[10:22:48.329]                 }
[10:22:48.329]             }
[10:22:48.329]         }
[10:22:48.329]     })
[10:22:48.329]     if (TRUE) {
[10:22:48.329]         base::sink(type = "output", split = FALSE)
[10:22:48.329]         if (TRUE) {
[10:22:48.329]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:48.329]         }
[10:22:48.329]         else {
[10:22:48.329]             ...future.result["stdout"] <- base::list(NULL)
[10:22:48.329]         }
[10:22:48.329]         base::close(...future.stdout)
[10:22:48.329]         ...future.stdout <- NULL
[10:22:48.329]     }
[10:22:48.329]     ...future.result$conditions <- ...future.conditions
[10:22:48.329]     ...future.result$finished <- base::Sys.time()
[10:22:48.329]     ...future.result
[10:22:48.329] }
[10:22:48.332] MultisessionFuture started
[10:22:48.332] - Launch lazy future ... done
[10:22:48.332] run() for ‘MultisessionFuture’ ... done
[10:22:48.347] receiveMessageFromWorker() for ClusterFuture ...
[10:22:48.347] - Validating connection of MultisessionFuture
[10:22:48.347] - received message: FutureResult
[10:22:48.347] - Received FutureResult
[10:22:48.347] - Erased future from FutureRegistry
[10:22:48.348] result() for ClusterFuture ...
[10:22:48.348] - result already collected: FutureResult
[10:22:48.348] result() for ClusterFuture ... done
[10:22:48.348] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:48.348] Future #2
[10:22:48.348]  length: 2 (resolved future 2)
[10:22:48.348]  length: 1 (resolved future 3)
[10:22:48.379] receiveMessageFromWorker() for ClusterFuture ...
[10:22:48.379] - Validating connection of MultisessionFuture
[10:22:48.380] - received message: FutureResult
[10:22:48.380] - Received FutureResult
[10:22:48.380] - Erased future from FutureRegistry
[10:22:48.380] result() for ClusterFuture ...
[10:22:48.380] - result already collected: FutureResult
[10:22:48.380] result() for ClusterFuture ... done
[10:22:48.380] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:48.380] Future #1
[10:22:48.380]  length: 0 (resolved future 1)
[10:22:48.381] resolve() on list ... DONE
[10:22:48.381] getGlobalsAndPackages() ...
[10:22:48.381] Searching for globals...
[10:22:48.381] 
[10:22:48.381] Searching for globals ... DONE
[10:22:48.381] - globals: [0] <none>
[10:22:48.381] getGlobalsAndPackages() ... DONE
[10:22:48.382] getGlobalsAndPackages() ...
[10:22:48.382] Searching for globals...
[10:22:48.382] 
[10:22:48.382] Searching for globals ... DONE
[10:22:48.382] - globals: [0] <none>
[10:22:48.382] getGlobalsAndPackages() ... DONE
[10:22:48.382] resolve() on list ...
[10:22:48.383]  recursive: 0
[10:22:48.383]  length: 3
[10:22:48.383]  elements: ‘a’, ‘b’, ‘’
[10:22:48.383] run() for ‘Future’ ...
[10:22:48.383] - state: ‘created’
[10:22:48.383] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:48.397] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:48.397] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:48.397]   - Field: ‘node’
[10:22:48.398]   - Field: ‘label’
[10:22:48.398]   - Field: ‘local’
[10:22:48.398]   - Field: ‘owner’
[10:22:48.398]   - Field: ‘envir’
[10:22:48.398]   - Field: ‘workers’
[10:22:48.398]   - Field: ‘packages’
[10:22:48.398]   - Field: ‘gc’
[10:22:48.398]   - Field: ‘conditions’
[10:22:48.398]   - Field: ‘persistent’
[10:22:48.398]   - Field: ‘expr’
[10:22:48.398]   - Field: ‘uuid’
[10:22:48.398]   - Field: ‘seed’
[10:22:48.399]   - Field: ‘version’
[10:22:48.399]   - Field: ‘result’
[10:22:48.399]   - Field: ‘asynchronous’
[10:22:48.399]   - Field: ‘calls’
[10:22:48.399]   - Field: ‘globals’
[10:22:48.399]   - Field: ‘stdout’
[10:22:48.399]   - Field: ‘earlySignal’
[10:22:48.399]   - Field: ‘lazy’
[10:22:48.399]   - Field: ‘state’
[10:22:48.399] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:48.399] - Launch lazy future ...
[10:22:48.400] Packages needed by the future expression (n = 0): <none>
[10:22:48.400] Packages needed by future strategies (n = 0): <none>
[10:22:48.400] {
[10:22:48.400]     {
[10:22:48.400]         {
[10:22:48.400]             ...future.startTime <- base::Sys.time()
[10:22:48.400]             {
[10:22:48.400]                 {
[10:22:48.400]                   {
[10:22:48.400]                     {
[10:22:48.400]                       base::local({
[10:22:48.400]                         has_future <- base::requireNamespace("future", 
[10:22:48.400]                           quietly = TRUE)
[10:22:48.400]                         if (has_future) {
[10:22:48.400]                           ns <- base::getNamespace("future")
[10:22:48.400]                           version <- ns[[".package"]][["version"]]
[10:22:48.400]                           if (is.null(version)) 
[10:22:48.400]                             version <- utils::packageVersion("future")
[10:22:48.400]                         }
[10:22:48.400]                         else {
[10:22:48.400]                           version <- NULL
[10:22:48.400]                         }
[10:22:48.400]                         if (!has_future || version < "1.8.0") {
[10:22:48.400]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:48.400]                             "", base::R.version$version.string), 
[10:22:48.400]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:48.400]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:48.400]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:48.400]                               "release", "version")], collapse = " "), 
[10:22:48.400]                             hostname = base::Sys.info()[["nodename"]])
[10:22:48.400]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:48.400]                             info)
[10:22:48.400]                           info <- base::paste(info, collapse = "; ")
[10:22:48.400]                           if (!has_future) {
[10:22:48.400]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:48.400]                               info)
[10:22:48.400]                           }
[10:22:48.400]                           else {
[10:22:48.400]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:48.400]                               info, version)
[10:22:48.400]                           }
[10:22:48.400]                           base::stop(msg)
[10:22:48.400]                         }
[10:22:48.400]                       })
[10:22:48.400]                     }
[10:22:48.400]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:48.400]                     base::options(mc.cores = 1L)
[10:22:48.400]                   }
[10:22:48.400]                   ...future.strategy.old <- future::plan("list")
[10:22:48.400]                   options(future.plan = NULL)
[10:22:48.400]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.400]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:48.400]                 }
[10:22:48.400]                 ...future.workdir <- getwd()
[10:22:48.400]             }
[10:22:48.400]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:48.400]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:48.400]         }
[10:22:48.400]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:48.400]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:48.400]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:48.400]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:48.400]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:48.400]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:48.400]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:48.400]             base::names(...future.oldOptions))
[10:22:48.400]     }
[10:22:48.400]     if (FALSE) {
[10:22:48.400]     }
[10:22:48.400]     else {
[10:22:48.400]         if (TRUE) {
[10:22:48.400]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:48.400]                 open = "w")
[10:22:48.400]         }
[10:22:48.400]         else {
[10:22:48.400]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:48.400]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:48.400]         }
[10:22:48.400]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:48.400]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:48.400]             base::sink(type = "output", split = FALSE)
[10:22:48.400]             base::close(...future.stdout)
[10:22:48.400]         }, add = TRUE)
[10:22:48.400]     }
[10:22:48.400]     ...future.frame <- base::sys.nframe()
[10:22:48.400]     ...future.conditions <- base::list()
[10:22:48.400]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:48.400]     if (FALSE) {
[10:22:48.400]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:48.400]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:48.400]     }
[10:22:48.400]     ...future.result <- base::tryCatch({
[10:22:48.400]         base::withCallingHandlers({
[10:22:48.400]             ...future.value <- base::withVisible(base::local({
[10:22:48.400]                 ...future.makeSendCondition <- base::local({
[10:22:48.400]                   sendCondition <- NULL
[10:22:48.400]                   function(frame = 1L) {
[10:22:48.400]                     if (is.function(sendCondition)) 
[10:22:48.400]                       return(sendCondition)
[10:22:48.400]                     ns <- getNamespace("parallel")
[10:22:48.400]                     if (exists("sendData", mode = "function", 
[10:22:48.400]                       envir = ns)) {
[10:22:48.400]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:48.400]                         envir = ns)
[10:22:48.400]                       envir <- sys.frame(frame)
[10:22:48.400]                       master <- NULL
[10:22:48.400]                       while (!identical(envir, .GlobalEnv) && 
[10:22:48.400]                         !identical(envir, emptyenv())) {
[10:22:48.400]                         if (exists("master", mode = "list", envir = envir, 
[10:22:48.400]                           inherits = FALSE)) {
[10:22:48.400]                           master <- get("master", mode = "list", 
[10:22:48.400]                             envir = envir, inherits = FALSE)
[10:22:48.400]                           if (inherits(master, c("SOCKnode", 
[10:22:48.400]                             "SOCK0node"))) {
[10:22:48.400]                             sendCondition <<- function(cond) {
[10:22:48.400]                               data <- list(type = "VALUE", value = cond, 
[10:22:48.400]                                 success = TRUE)
[10:22:48.400]                               parallel_sendData(master, data)
[10:22:48.400]                             }
[10:22:48.400]                             return(sendCondition)
[10:22:48.400]                           }
[10:22:48.400]                         }
[10:22:48.400]                         frame <- frame + 1L
[10:22:48.400]                         envir <- sys.frame(frame)
[10:22:48.400]                       }
[10:22:48.400]                     }
[10:22:48.400]                     sendCondition <<- function(cond) NULL
[10:22:48.400]                   }
[10:22:48.400]                 })
[10:22:48.400]                 withCallingHandlers({
[10:22:48.400]                   1
[10:22:48.400]                 }, immediateCondition = function(cond) {
[10:22:48.400]                   sendCondition <- ...future.makeSendCondition()
[10:22:48.400]                   sendCondition(cond)
[10:22:48.400]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.400]                   {
[10:22:48.400]                     inherits <- base::inherits
[10:22:48.400]                     invokeRestart <- base::invokeRestart
[10:22:48.400]                     is.null <- base::is.null
[10:22:48.400]                     muffled <- FALSE
[10:22:48.400]                     if (inherits(cond, "message")) {
[10:22:48.400]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:48.400]                       if (muffled) 
[10:22:48.400]                         invokeRestart("muffleMessage")
[10:22:48.400]                     }
[10:22:48.400]                     else if (inherits(cond, "warning")) {
[10:22:48.400]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:48.400]                       if (muffled) 
[10:22:48.400]                         invokeRestart("muffleWarning")
[10:22:48.400]                     }
[10:22:48.400]                     else if (inherits(cond, "condition")) {
[10:22:48.400]                       if (!is.null(pattern)) {
[10:22:48.400]                         computeRestarts <- base::computeRestarts
[10:22:48.400]                         grepl <- base::grepl
[10:22:48.400]                         restarts <- computeRestarts(cond)
[10:22:48.400]                         for (restart in restarts) {
[10:22:48.400]                           name <- restart$name
[10:22:48.400]                           if (is.null(name)) 
[10:22:48.400]                             next
[10:22:48.400]                           if (!grepl(pattern, name)) 
[10:22:48.400]                             next
[10:22:48.400]                           invokeRestart(restart)
[10:22:48.400]                           muffled <- TRUE
[10:22:48.400]                           break
[10:22:48.400]                         }
[10:22:48.400]                       }
[10:22:48.400]                     }
[10:22:48.400]                     invisible(muffled)
[10:22:48.400]                   }
[10:22:48.400]                   muffleCondition(cond)
[10:22:48.400]                 })
[10:22:48.400]             }))
[10:22:48.400]             future::FutureResult(value = ...future.value$value, 
[10:22:48.400]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.400]                   ...future.rng), globalenv = if (FALSE) 
[10:22:48.400]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:48.400]                     ...future.globalenv.names))
[10:22:48.400]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:48.400]         }, condition = base::local({
[10:22:48.400]             c <- base::c
[10:22:48.400]             inherits <- base::inherits
[10:22:48.400]             invokeRestart <- base::invokeRestart
[10:22:48.400]             length <- base::length
[10:22:48.400]             list <- base::list
[10:22:48.400]             seq.int <- base::seq.int
[10:22:48.400]             signalCondition <- base::signalCondition
[10:22:48.400]             sys.calls <- base::sys.calls
[10:22:48.400]             `[[` <- base::`[[`
[10:22:48.400]             `+` <- base::`+`
[10:22:48.400]             `<<-` <- base::`<<-`
[10:22:48.400]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:48.400]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:48.400]                   3L)]
[10:22:48.400]             }
[10:22:48.400]             function(cond) {
[10:22:48.400]                 is_error <- inherits(cond, "error")
[10:22:48.400]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:48.400]                   NULL)
[10:22:48.400]                 if (is_error) {
[10:22:48.400]                   sessionInformation <- function() {
[10:22:48.400]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:48.400]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:48.400]                       search = base::search(), system = base::Sys.info())
[10:22:48.400]                   }
[10:22:48.400]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.400]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:48.400]                     cond$call), session = sessionInformation(), 
[10:22:48.400]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:48.400]                   signalCondition(cond)
[10:22:48.400]                 }
[10:22:48.400]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:48.400]                 "immediateCondition"))) {
[10:22:48.400]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:48.400]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.400]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:48.400]                   if (TRUE && !signal) {
[10:22:48.400]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.400]                     {
[10:22:48.400]                       inherits <- base::inherits
[10:22:48.400]                       invokeRestart <- base::invokeRestart
[10:22:48.400]                       is.null <- base::is.null
[10:22:48.400]                       muffled <- FALSE
[10:22:48.400]                       if (inherits(cond, "message")) {
[10:22:48.400]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.400]                         if (muffled) 
[10:22:48.400]                           invokeRestart("muffleMessage")
[10:22:48.400]                       }
[10:22:48.400]                       else if (inherits(cond, "warning")) {
[10:22:48.400]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.400]                         if (muffled) 
[10:22:48.400]                           invokeRestart("muffleWarning")
[10:22:48.400]                       }
[10:22:48.400]                       else if (inherits(cond, "condition")) {
[10:22:48.400]                         if (!is.null(pattern)) {
[10:22:48.400]                           computeRestarts <- base::computeRestarts
[10:22:48.400]                           grepl <- base::grepl
[10:22:48.400]                           restarts <- computeRestarts(cond)
[10:22:48.400]                           for (restart in restarts) {
[10:22:48.400]                             name <- restart$name
[10:22:48.400]                             if (is.null(name)) 
[10:22:48.400]                               next
[10:22:48.400]                             if (!grepl(pattern, name)) 
[10:22:48.400]                               next
[10:22:48.400]                             invokeRestart(restart)
[10:22:48.400]                             muffled <- TRUE
[10:22:48.400]                             break
[10:22:48.400]                           }
[10:22:48.400]                         }
[10:22:48.400]                       }
[10:22:48.400]                       invisible(muffled)
[10:22:48.400]                     }
[10:22:48.400]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.400]                   }
[10:22:48.400]                 }
[10:22:48.400]                 else {
[10:22:48.400]                   if (TRUE) {
[10:22:48.400]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.400]                     {
[10:22:48.400]                       inherits <- base::inherits
[10:22:48.400]                       invokeRestart <- base::invokeRestart
[10:22:48.400]                       is.null <- base::is.null
[10:22:48.400]                       muffled <- FALSE
[10:22:48.400]                       if (inherits(cond, "message")) {
[10:22:48.400]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.400]                         if (muffled) 
[10:22:48.400]                           invokeRestart("muffleMessage")
[10:22:48.400]                       }
[10:22:48.400]                       else if (inherits(cond, "warning")) {
[10:22:48.400]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.400]                         if (muffled) 
[10:22:48.400]                           invokeRestart("muffleWarning")
[10:22:48.400]                       }
[10:22:48.400]                       else if (inherits(cond, "condition")) {
[10:22:48.400]                         if (!is.null(pattern)) {
[10:22:48.400]                           computeRestarts <- base::computeRestarts
[10:22:48.400]                           grepl <- base::grepl
[10:22:48.400]                           restarts <- computeRestarts(cond)
[10:22:48.400]                           for (restart in restarts) {
[10:22:48.400]                             name <- restart$name
[10:22:48.400]                             if (is.null(name)) 
[10:22:48.400]                               next
[10:22:48.400]                             if (!grepl(pattern, name)) 
[10:22:48.400]                               next
[10:22:48.400]                             invokeRestart(restart)
[10:22:48.400]                             muffled <- TRUE
[10:22:48.400]                             break
[10:22:48.400]                           }
[10:22:48.400]                         }
[10:22:48.400]                       }
[10:22:48.400]                       invisible(muffled)
[10:22:48.400]                     }
[10:22:48.400]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.400]                   }
[10:22:48.400]                 }
[10:22:48.400]             }
[10:22:48.400]         }))
[10:22:48.400]     }, error = function(ex) {
[10:22:48.400]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:48.400]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.400]                 ...future.rng), started = ...future.startTime, 
[10:22:48.400]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:48.400]             version = "1.8"), class = "FutureResult")
[10:22:48.400]     }, finally = {
[10:22:48.400]         if (!identical(...future.workdir, getwd())) 
[10:22:48.400]             setwd(...future.workdir)
[10:22:48.400]         {
[10:22:48.400]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:48.400]                 ...future.oldOptions$nwarnings <- NULL
[10:22:48.400]             }
[10:22:48.400]             base::options(...future.oldOptions)
[10:22:48.400]             if (.Platform$OS.type == "windows") {
[10:22:48.400]                 old_names <- names(...future.oldEnvVars)
[10:22:48.400]                 envs <- base::Sys.getenv()
[10:22:48.400]                 names <- names(envs)
[10:22:48.400]                 common <- intersect(names, old_names)
[10:22:48.400]                 added <- setdiff(names, old_names)
[10:22:48.400]                 removed <- setdiff(old_names, names)
[10:22:48.400]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:48.400]                   envs[common]]
[10:22:48.400]                 NAMES <- toupper(changed)
[10:22:48.400]                 args <- list()
[10:22:48.400]                 for (kk in seq_along(NAMES)) {
[10:22:48.400]                   name <- changed[[kk]]
[10:22:48.400]                   NAME <- NAMES[[kk]]
[10:22:48.400]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.400]                     next
[10:22:48.400]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.400]                 }
[10:22:48.400]                 NAMES <- toupper(added)
[10:22:48.400]                 for (kk in seq_along(NAMES)) {
[10:22:48.400]                   name <- added[[kk]]
[10:22:48.400]                   NAME <- NAMES[[kk]]
[10:22:48.400]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.400]                     next
[10:22:48.400]                   args[[name]] <- ""
[10:22:48.400]                 }
[10:22:48.400]                 NAMES <- toupper(removed)
[10:22:48.400]                 for (kk in seq_along(NAMES)) {
[10:22:48.400]                   name <- removed[[kk]]
[10:22:48.400]                   NAME <- NAMES[[kk]]
[10:22:48.400]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.400]                     next
[10:22:48.400]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.400]                 }
[10:22:48.400]                 if (length(args) > 0) 
[10:22:48.400]                   base::do.call(base::Sys.setenv, args = args)
[10:22:48.400]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:48.400]             }
[10:22:48.400]             else {
[10:22:48.400]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:48.400]             }
[10:22:48.400]             {
[10:22:48.400]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:48.400]                   0L) {
[10:22:48.400]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:48.400]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:48.400]                   base::options(opts)
[10:22:48.400]                 }
[10:22:48.400]                 {
[10:22:48.400]                   {
[10:22:48.400]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:48.400]                     NULL
[10:22:48.400]                   }
[10:22:48.400]                   options(future.plan = NULL)
[10:22:48.400]                   if (is.na(NA_character_)) 
[10:22:48.400]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.400]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:48.400]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:48.400]                     .init = FALSE)
[10:22:48.400]                 }
[10:22:48.400]             }
[10:22:48.400]         }
[10:22:48.400]     })
[10:22:48.400]     if (TRUE) {
[10:22:48.400]         base::sink(type = "output", split = FALSE)
[10:22:48.400]         if (TRUE) {
[10:22:48.400]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:48.400]         }
[10:22:48.400]         else {
[10:22:48.400]             ...future.result["stdout"] <- base::list(NULL)
[10:22:48.400]         }
[10:22:48.400]         base::close(...future.stdout)
[10:22:48.400]         ...future.stdout <- NULL
[10:22:48.400]     }
[10:22:48.400]     ...future.result$conditions <- ...future.conditions
[10:22:48.400]     ...future.result$finished <- base::Sys.time()
[10:22:48.400]     ...future.result
[10:22:48.400] }
[10:22:48.403] MultisessionFuture started
[10:22:48.404] - Launch lazy future ... done
[10:22:48.404] run() for ‘MultisessionFuture’ ... done
[10:22:48.414] run() for ‘Future’ ...
[10:22:48.414] - state: ‘created’
[10:22:48.414] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:48.428] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:48.428] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:48.428]   - Field: ‘node’
[10:22:48.428]   - Field: ‘label’
[10:22:48.428]   - Field: ‘local’
[10:22:48.429]   - Field: ‘owner’
[10:22:48.429]   - Field: ‘envir’
[10:22:48.429]   - Field: ‘workers’
[10:22:48.429]   - Field: ‘packages’
[10:22:48.429]   - Field: ‘gc’
[10:22:48.429]   - Field: ‘conditions’
[10:22:48.429]   - Field: ‘persistent’
[10:22:48.429]   - Field: ‘expr’
[10:22:48.429]   - Field: ‘uuid’
[10:22:48.429]   - Field: ‘seed’
[10:22:48.429]   - Field: ‘version’
[10:22:48.430]   - Field: ‘result’
[10:22:48.430]   - Field: ‘asynchronous’
[10:22:48.430]   - Field: ‘calls’
[10:22:48.430]   - Field: ‘globals’
[10:22:48.430]   - Field: ‘stdout’
[10:22:48.430]   - Field: ‘earlySignal’
[10:22:48.430]   - Field: ‘lazy’
[10:22:48.430]   - Field: ‘state’
[10:22:48.430] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:48.430] - Launch lazy future ...
[10:22:48.431] Packages needed by the future expression (n = 0): <none>
[10:22:48.431] Packages needed by future strategies (n = 0): <none>
[10:22:48.431] {
[10:22:48.431]     {
[10:22:48.431]         {
[10:22:48.431]             ...future.startTime <- base::Sys.time()
[10:22:48.431]             {
[10:22:48.431]                 {
[10:22:48.431]                   {
[10:22:48.431]                     {
[10:22:48.431]                       base::local({
[10:22:48.431]                         has_future <- base::requireNamespace("future", 
[10:22:48.431]                           quietly = TRUE)
[10:22:48.431]                         if (has_future) {
[10:22:48.431]                           ns <- base::getNamespace("future")
[10:22:48.431]                           version <- ns[[".package"]][["version"]]
[10:22:48.431]                           if (is.null(version)) 
[10:22:48.431]                             version <- utils::packageVersion("future")
[10:22:48.431]                         }
[10:22:48.431]                         else {
[10:22:48.431]                           version <- NULL
[10:22:48.431]                         }
[10:22:48.431]                         if (!has_future || version < "1.8.0") {
[10:22:48.431]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:48.431]                             "", base::R.version$version.string), 
[10:22:48.431]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:48.431]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:48.431]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:48.431]                               "release", "version")], collapse = " "), 
[10:22:48.431]                             hostname = base::Sys.info()[["nodename"]])
[10:22:48.431]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:48.431]                             info)
[10:22:48.431]                           info <- base::paste(info, collapse = "; ")
[10:22:48.431]                           if (!has_future) {
[10:22:48.431]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:48.431]                               info)
[10:22:48.431]                           }
[10:22:48.431]                           else {
[10:22:48.431]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:48.431]                               info, version)
[10:22:48.431]                           }
[10:22:48.431]                           base::stop(msg)
[10:22:48.431]                         }
[10:22:48.431]                       })
[10:22:48.431]                     }
[10:22:48.431]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:48.431]                     base::options(mc.cores = 1L)
[10:22:48.431]                   }
[10:22:48.431]                   ...future.strategy.old <- future::plan("list")
[10:22:48.431]                   options(future.plan = NULL)
[10:22:48.431]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.431]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:48.431]                 }
[10:22:48.431]                 ...future.workdir <- getwd()
[10:22:48.431]             }
[10:22:48.431]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:48.431]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:48.431]         }
[10:22:48.431]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:48.431]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:48.431]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:48.431]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:48.431]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:48.431]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:48.431]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:48.431]             base::names(...future.oldOptions))
[10:22:48.431]     }
[10:22:48.431]     if (FALSE) {
[10:22:48.431]     }
[10:22:48.431]     else {
[10:22:48.431]         if (TRUE) {
[10:22:48.431]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:48.431]                 open = "w")
[10:22:48.431]         }
[10:22:48.431]         else {
[10:22:48.431]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:48.431]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:48.431]         }
[10:22:48.431]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:48.431]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:48.431]             base::sink(type = "output", split = FALSE)
[10:22:48.431]             base::close(...future.stdout)
[10:22:48.431]         }, add = TRUE)
[10:22:48.431]     }
[10:22:48.431]     ...future.frame <- base::sys.nframe()
[10:22:48.431]     ...future.conditions <- base::list()
[10:22:48.431]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:48.431]     if (FALSE) {
[10:22:48.431]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:48.431]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:48.431]     }
[10:22:48.431]     ...future.result <- base::tryCatch({
[10:22:48.431]         base::withCallingHandlers({
[10:22:48.431]             ...future.value <- base::withVisible(base::local({
[10:22:48.431]                 ...future.makeSendCondition <- base::local({
[10:22:48.431]                   sendCondition <- NULL
[10:22:48.431]                   function(frame = 1L) {
[10:22:48.431]                     if (is.function(sendCondition)) 
[10:22:48.431]                       return(sendCondition)
[10:22:48.431]                     ns <- getNamespace("parallel")
[10:22:48.431]                     if (exists("sendData", mode = "function", 
[10:22:48.431]                       envir = ns)) {
[10:22:48.431]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:48.431]                         envir = ns)
[10:22:48.431]                       envir <- sys.frame(frame)
[10:22:48.431]                       master <- NULL
[10:22:48.431]                       while (!identical(envir, .GlobalEnv) && 
[10:22:48.431]                         !identical(envir, emptyenv())) {
[10:22:48.431]                         if (exists("master", mode = "list", envir = envir, 
[10:22:48.431]                           inherits = FALSE)) {
[10:22:48.431]                           master <- get("master", mode = "list", 
[10:22:48.431]                             envir = envir, inherits = FALSE)
[10:22:48.431]                           if (inherits(master, c("SOCKnode", 
[10:22:48.431]                             "SOCK0node"))) {
[10:22:48.431]                             sendCondition <<- function(cond) {
[10:22:48.431]                               data <- list(type = "VALUE", value = cond, 
[10:22:48.431]                                 success = TRUE)
[10:22:48.431]                               parallel_sendData(master, data)
[10:22:48.431]                             }
[10:22:48.431]                             return(sendCondition)
[10:22:48.431]                           }
[10:22:48.431]                         }
[10:22:48.431]                         frame <- frame + 1L
[10:22:48.431]                         envir <- sys.frame(frame)
[10:22:48.431]                       }
[10:22:48.431]                     }
[10:22:48.431]                     sendCondition <<- function(cond) NULL
[10:22:48.431]                   }
[10:22:48.431]                 })
[10:22:48.431]                 withCallingHandlers({
[10:22:48.431]                   2
[10:22:48.431]                 }, immediateCondition = function(cond) {
[10:22:48.431]                   sendCondition <- ...future.makeSendCondition()
[10:22:48.431]                   sendCondition(cond)
[10:22:48.431]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.431]                   {
[10:22:48.431]                     inherits <- base::inherits
[10:22:48.431]                     invokeRestart <- base::invokeRestart
[10:22:48.431]                     is.null <- base::is.null
[10:22:48.431]                     muffled <- FALSE
[10:22:48.431]                     if (inherits(cond, "message")) {
[10:22:48.431]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:48.431]                       if (muffled) 
[10:22:48.431]                         invokeRestart("muffleMessage")
[10:22:48.431]                     }
[10:22:48.431]                     else if (inherits(cond, "warning")) {
[10:22:48.431]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:48.431]                       if (muffled) 
[10:22:48.431]                         invokeRestart("muffleWarning")
[10:22:48.431]                     }
[10:22:48.431]                     else if (inherits(cond, "condition")) {
[10:22:48.431]                       if (!is.null(pattern)) {
[10:22:48.431]                         computeRestarts <- base::computeRestarts
[10:22:48.431]                         grepl <- base::grepl
[10:22:48.431]                         restarts <- computeRestarts(cond)
[10:22:48.431]                         for (restart in restarts) {
[10:22:48.431]                           name <- restart$name
[10:22:48.431]                           if (is.null(name)) 
[10:22:48.431]                             next
[10:22:48.431]                           if (!grepl(pattern, name)) 
[10:22:48.431]                             next
[10:22:48.431]                           invokeRestart(restart)
[10:22:48.431]                           muffled <- TRUE
[10:22:48.431]                           break
[10:22:48.431]                         }
[10:22:48.431]                       }
[10:22:48.431]                     }
[10:22:48.431]                     invisible(muffled)
[10:22:48.431]                   }
[10:22:48.431]                   muffleCondition(cond)
[10:22:48.431]                 })
[10:22:48.431]             }))
[10:22:48.431]             future::FutureResult(value = ...future.value$value, 
[10:22:48.431]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.431]                   ...future.rng), globalenv = if (FALSE) 
[10:22:48.431]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:48.431]                     ...future.globalenv.names))
[10:22:48.431]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:48.431]         }, condition = base::local({
[10:22:48.431]             c <- base::c
[10:22:48.431]             inherits <- base::inherits
[10:22:48.431]             invokeRestart <- base::invokeRestart
[10:22:48.431]             length <- base::length
[10:22:48.431]             list <- base::list
[10:22:48.431]             seq.int <- base::seq.int
[10:22:48.431]             signalCondition <- base::signalCondition
[10:22:48.431]             sys.calls <- base::sys.calls
[10:22:48.431]             `[[` <- base::`[[`
[10:22:48.431]             `+` <- base::`+`
[10:22:48.431]             `<<-` <- base::`<<-`
[10:22:48.431]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:48.431]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:48.431]                   3L)]
[10:22:48.431]             }
[10:22:48.431]             function(cond) {
[10:22:48.431]                 is_error <- inherits(cond, "error")
[10:22:48.431]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:48.431]                   NULL)
[10:22:48.431]                 if (is_error) {
[10:22:48.431]                   sessionInformation <- function() {
[10:22:48.431]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:48.431]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:48.431]                       search = base::search(), system = base::Sys.info())
[10:22:48.431]                   }
[10:22:48.431]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.431]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:48.431]                     cond$call), session = sessionInformation(), 
[10:22:48.431]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:48.431]                   signalCondition(cond)
[10:22:48.431]                 }
[10:22:48.431]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:48.431]                 "immediateCondition"))) {
[10:22:48.431]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:48.431]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.431]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:48.431]                   if (TRUE && !signal) {
[10:22:48.431]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.431]                     {
[10:22:48.431]                       inherits <- base::inherits
[10:22:48.431]                       invokeRestart <- base::invokeRestart
[10:22:48.431]                       is.null <- base::is.null
[10:22:48.431]                       muffled <- FALSE
[10:22:48.431]                       if (inherits(cond, "message")) {
[10:22:48.431]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.431]                         if (muffled) 
[10:22:48.431]                           invokeRestart("muffleMessage")
[10:22:48.431]                       }
[10:22:48.431]                       else if (inherits(cond, "warning")) {
[10:22:48.431]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.431]                         if (muffled) 
[10:22:48.431]                           invokeRestart("muffleWarning")
[10:22:48.431]                       }
[10:22:48.431]                       else if (inherits(cond, "condition")) {
[10:22:48.431]                         if (!is.null(pattern)) {
[10:22:48.431]                           computeRestarts <- base::computeRestarts
[10:22:48.431]                           grepl <- base::grepl
[10:22:48.431]                           restarts <- computeRestarts(cond)
[10:22:48.431]                           for (restart in restarts) {
[10:22:48.431]                             name <- restart$name
[10:22:48.431]                             if (is.null(name)) 
[10:22:48.431]                               next
[10:22:48.431]                             if (!grepl(pattern, name)) 
[10:22:48.431]                               next
[10:22:48.431]                             invokeRestart(restart)
[10:22:48.431]                             muffled <- TRUE
[10:22:48.431]                             break
[10:22:48.431]                           }
[10:22:48.431]                         }
[10:22:48.431]                       }
[10:22:48.431]                       invisible(muffled)
[10:22:48.431]                     }
[10:22:48.431]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.431]                   }
[10:22:48.431]                 }
[10:22:48.431]                 else {
[10:22:48.431]                   if (TRUE) {
[10:22:48.431]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.431]                     {
[10:22:48.431]                       inherits <- base::inherits
[10:22:48.431]                       invokeRestart <- base::invokeRestart
[10:22:48.431]                       is.null <- base::is.null
[10:22:48.431]                       muffled <- FALSE
[10:22:48.431]                       if (inherits(cond, "message")) {
[10:22:48.431]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.431]                         if (muffled) 
[10:22:48.431]                           invokeRestart("muffleMessage")
[10:22:48.431]                       }
[10:22:48.431]                       else if (inherits(cond, "warning")) {
[10:22:48.431]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.431]                         if (muffled) 
[10:22:48.431]                           invokeRestart("muffleWarning")
[10:22:48.431]                       }
[10:22:48.431]                       else if (inherits(cond, "condition")) {
[10:22:48.431]                         if (!is.null(pattern)) {
[10:22:48.431]                           computeRestarts <- base::computeRestarts
[10:22:48.431]                           grepl <- base::grepl
[10:22:48.431]                           restarts <- computeRestarts(cond)
[10:22:48.431]                           for (restart in restarts) {
[10:22:48.431]                             name <- restart$name
[10:22:48.431]                             if (is.null(name)) 
[10:22:48.431]                               next
[10:22:48.431]                             if (!grepl(pattern, name)) 
[10:22:48.431]                               next
[10:22:48.431]                             invokeRestart(restart)
[10:22:48.431]                             muffled <- TRUE
[10:22:48.431]                             break
[10:22:48.431]                           }
[10:22:48.431]                         }
[10:22:48.431]                       }
[10:22:48.431]                       invisible(muffled)
[10:22:48.431]                     }
[10:22:48.431]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.431]                   }
[10:22:48.431]                 }
[10:22:48.431]             }
[10:22:48.431]         }))
[10:22:48.431]     }, error = function(ex) {
[10:22:48.431]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:48.431]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.431]                 ...future.rng), started = ...future.startTime, 
[10:22:48.431]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:48.431]             version = "1.8"), class = "FutureResult")
[10:22:48.431]     }, finally = {
[10:22:48.431]         if (!identical(...future.workdir, getwd())) 
[10:22:48.431]             setwd(...future.workdir)
[10:22:48.431]         {
[10:22:48.431]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:48.431]                 ...future.oldOptions$nwarnings <- NULL
[10:22:48.431]             }
[10:22:48.431]             base::options(...future.oldOptions)
[10:22:48.431]             if (.Platform$OS.type == "windows") {
[10:22:48.431]                 old_names <- names(...future.oldEnvVars)
[10:22:48.431]                 envs <- base::Sys.getenv()
[10:22:48.431]                 names <- names(envs)
[10:22:48.431]                 common <- intersect(names, old_names)
[10:22:48.431]                 added <- setdiff(names, old_names)
[10:22:48.431]                 removed <- setdiff(old_names, names)
[10:22:48.431]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:48.431]                   envs[common]]
[10:22:48.431]                 NAMES <- toupper(changed)
[10:22:48.431]                 args <- list()
[10:22:48.431]                 for (kk in seq_along(NAMES)) {
[10:22:48.431]                   name <- changed[[kk]]
[10:22:48.431]                   NAME <- NAMES[[kk]]
[10:22:48.431]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.431]                     next
[10:22:48.431]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.431]                 }
[10:22:48.431]                 NAMES <- toupper(added)
[10:22:48.431]                 for (kk in seq_along(NAMES)) {
[10:22:48.431]                   name <- added[[kk]]
[10:22:48.431]                   NAME <- NAMES[[kk]]
[10:22:48.431]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.431]                     next
[10:22:48.431]                   args[[name]] <- ""
[10:22:48.431]                 }
[10:22:48.431]                 NAMES <- toupper(removed)
[10:22:48.431]                 for (kk in seq_along(NAMES)) {
[10:22:48.431]                   name <- removed[[kk]]
[10:22:48.431]                   NAME <- NAMES[[kk]]
[10:22:48.431]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.431]                     next
[10:22:48.431]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.431]                 }
[10:22:48.431]                 if (length(args) > 0) 
[10:22:48.431]                   base::do.call(base::Sys.setenv, args = args)
[10:22:48.431]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:48.431]             }
[10:22:48.431]             else {
[10:22:48.431]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:48.431]             }
[10:22:48.431]             {
[10:22:48.431]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:48.431]                   0L) {
[10:22:48.431]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:48.431]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:48.431]                   base::options(opts)
[10:22:48.431]                 }
[10:22:48.431]                 {
[10:22:48.431]                   {
[10:22:48.431]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:48.431]                     NULL
[10:22:48.431]                   }
[10:22:48.431]                   options(future.plan = NULL)
[10:22:48.431]                   if (is.na(NA_character_)) 
[10:22:48.431]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.431]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:48.431]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:48.431]                     .init = FALSE)
[10:22:48.431]                 }
[10:22:48.431]             }
[10:22:48.431]         }
[10:22:48.431]     })
[10:22:48.431]     if (TRUE) {
[10:22:48.431]         base::sink(type = "output", split = FALSE)
[10:22:48.431]         if (TRUE) {
[10:22:48.431]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:48.431]         }
[10:22:48.431]         else {
[10:22:48.431]             ...future.result["stdout"] <- base::list(NULL)
[10:22:48.431]         }
[10:22:48.431]         base::close(...future.stdout)
[10:22:48.431]         ...future.stdout <- NULL
[10:22:48.431]     }
[10:22:48.431]     ...future.result$conditions <- ...future.conditions
[10:22:48.431]     ...future.result$finished <- base::Sys.time()
[10:22:48.431]     ...future.result
[10:22:48.431] }
[10:22:48.434] MultisessionFuture started
[10:22:48.434] - Launch lazy future ... done
[10:22:48.434] run() for ‘MultisessionFuture’ ... done
[10:22:48.445]  length: 2 (resolved future 3)
[10:22:48.456] receiveMessageFromWorker() for ClusterFuture ...
[10:22:48.456] - Validating connection of MultisessionFuture
[10:22:48.456] - received message: FutureResult
[10:22:48.456] - Received FutureResult
[10:22:48.456] - Erased future from FutureRegistry
[10:22:48.456] result() for ClusterFuture ...
[10:22:48.457] - result already collected: FutureResult
[10:22:48.457] result() for ClusterFuture ... done
[10:22:48.457] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:48.457] Future #1
[10:22:48.457]  length: 1 (resolved future 1)
[10:22:48.478] receiveMessageFromWorker() for ClusterFuture ...
[10:22:48.478] - Validating connection of MultisessionFuture
[10:22:48.478] - received message: FutureResult
[10:22:48.478] - Received FutureResult
[10:22:48.479] - Erased future from FutureRegistry
[10:22:48.479] result() for ClusterFuture ...
[10:22:48.479] - result already collected: FutureResult
[10:22:48.479] result() for ClusterFuture ... done
[10:22:48.479] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:48.479] Future #2
[10:22:48.479]  length: 0 (resolved future 2)
[10:22:48.479] resolve() on list ... DONE
[10:22:48.479] getGlobalsAndPackages() ...
[10:22:48.479] Searching for globals...
[10:22:48.480] 
[10:22:48.480] Searching for globals ... DONE
[10:22:48.480] - globals: [0] <none>
[10:22:48.480] getGlobalsAndPackages() ... DONE
[10:22:48.480] run() for ‘Future’ ...
[10:22:48.480] - state: ‘created’
[10:22:48.480] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:48.494] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:48.494] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:48.494]   - Field: ‘node’
[10:22:48.494]   - Field: ‘label’
[10:22:48.494]   - Field: ‘local’
[10:22:48.495]   - Field: ‘owner’
[10:22:48.495]   - Field: ‘envir’
[10:22:48.495]   - Field: ‘workers’
[10:22:48.495]   - Field: ‘packages’
[10:22:48.495]   - Field: ‘gc’
[10:22:48.495]   - Field: ‘conditions’
[10:22:48.495]   - Field: ‘persistent’
[10:22:48.495]   - Field: ‘expr’
[10:22:48.495]   - Field: ‘uuid’
[10:22:48.495]   - Field: ‘seed’
[10:22:48.495]   - Field: ‘version’
[10:22:48.496]   - Field: ‘result’
[10:22:48.496]   - Field: ‘asynchronous’
[10:22:48.496]   - Field: ‘calls’
[10:22:48.496]   - Field: ‘globals’
[10:22:48.496]   - Field: ‘stdout’
[10:22:48.496]   - Field: ‘earlySignal’
[10:22:48.496]   - Field: ‘lazy’
[10:22:48.496]   - Field: ‘state’
[10:22:48.496] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:48.496] - Launch lazy future ...
[10:22:48.497] Packages needed by the future expression (n = 0): <none>
[10:22:48.497] Packages needed by future strategies (n = 0): <none>
[10:22:48.497] {
[10:22:48.497]     {
[10:22:48.497]         {
[10:22:48.497]             ...future.startTime <- base::Sys.time()
[10:22:48.497]             {
[10:22:48.497]                 {
[10:22:48.497]                   {
[10:22:48.497]                     {
[10:22:48.497]                       base::local({
[10:22:48.497]                         has_future <- base::requireNamespace("future", 
[10:22:48.497]                           quietly = TRUE)
[10:22:48.497]                         if (has_future) {
[10:22:48.497]                           ns <- base::getNamespace("future")
[10:22:48.497]                           version <- ns[[".package"]][["version"]]
[10:22:48.497]                           if (is.null(version)) 
[10:22:48.497]                             version <- utils::packageVersion("future")
[10:22:48.497]                         }
[10:22:48.497]                         else {
[10:22:48.497]                           version <- NULL
[10:22:48.497]                         }
[10:22:48.497]                         if (!has_future || version < "1.8.0") {
[10:22:48.497]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:48.497]                             "", base::R.version$version.string), 
[10:22:48.497]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:48.497]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:48.497]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:48.497]                               "release", "version")], collapse = " "), 
[10:22:48.497]                             hostname = base::Sys.info()[["nodename"]])
[10:22:48.497]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:48.497]                             info)
[10:22:48.497]                           info <- base::paste(info, collapse = "; ")
[10:22:48.497]                           if (!has_future) {
[10:22:48.497]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:48.497]                               info)
[10:22:48.497]                           }
[10:22:48.497]                           else {
[10:22:48.497]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:48.497]                               info, version)
[10:22:48.497]                           }
[10:22:48.497]                           base::stop(msg)
[10:22:48.497]                         }
[10:22:48.497]                       })
[10:22:48.497]                     }
[10:22:48.497]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:48.497]                     base::options(mc.cores = 1L)
[10:22:48.497]                   }
[10:22:48.497]                   ...future.strategy.old <- future::plan("list")
[10:22:48.497]                   options(future.plan = NULL)
[10:22:48.497]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.497]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:48.497]                 }
[10:22:48.497]                 ...future.workdir <- getwd()
[10:22:48.497]             }
[10:22:48.497]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:48.497]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:48.497]         }
[10:22:48.497]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:48.497]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:48.497]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:48.497]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:48.497]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:48.497]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:48.497]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:48.497]             base::names(...future.oldOptions))
[10:22:48.497]     }
[10:22:48.497]     if (FALSE) {
[10:22:48.497]     }
[10:22:48.497]     else {
[10:22:48.497]         if (TRUE) {
[10:22:48.497]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:48.497]                 open = "w")
[10:22:48.497]         }
[10:22:48.497]         else {
[10:22:48.497]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:48.497]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:48.497]         }
[10:22:48.497]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:48.497]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:48.497]             base::sink(type = "output", split = FALSE)
[10:22:48.497]             base::close(...future.stdout)
[10:22:48.497]         }, add = TRUE)
[10:22:48.497]     }
[10:22:48.497]     ...future.frame <- base::sys.nframe()
[10:22:48.497]     ...future.conditions <- base::list()
[10:22:48.497]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:48.497]     if (FALSE) {
[10:22:48.497]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:48.497]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:48.497]     }
[10:22:48.497]     ...future.result <- base::tryCatch({
[10:22:48.497]         base::withCallingHandlers({
[10:22:48.497]             ...future.value <- base::withVisible(base::local({
[10:22:48.497]                 ...future.makeSendCondition <- base::local({
[10:22:48.497]                   sendCondition <- NULL
[10:22:48.497]                   function(frame = 1L) {
[10:22:48.497]                     if (is.function(sendCondition)) 
[10:22:48.497]                       return(sendCondition)
[10:22:48.497]                     ns <- getNamespace("parallel")
[10:22:48.497]                     if (exists("sendData", mode = "function", 
[10:22:48.497]                       envir = ns)) {
[10:22:48.497]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:48.497]                         envir = ns)
[10:22:48.497]                       envir <- sys.frame(frame)
[10:22:48.497]                       master <- NULL
[10:22:48.497]                       while (!identical(envir, .GlobalEnv) && 
[10:22:48.497]                         !identical(envir, emptyenv())) {
[10:22:48.497]                         if (exists("master", mode = "list", envir = envir, 
[10:22:48.497]                           inherits = FALSE)) {
[10:22:48.497]                           master <- get("master", mode = "list", 
[10:22:48.497]                             envir = envir, inherits = FALSE)
[10:22:48.497]                           if (inherits(master, c("SOCKnode", 
[10:22:48.497]                             "SOCK0node"))) {
[10:22:48.497]                             sendCondition <<- function(cond) {
[10:22:48.497]                               data <- list(type = "VALUE", value = cond, 
[10:22:48.497]                                 success = TRUE)
[10:22:48.497]                               parallel_sendData(master, data)
[10:22:48.497]                             }
[10:22:48.497]                             return(sendCondition)
[10:22:48.497]                           }
[10:22:48.497]                         }
[10:22:48.497]                         frame <- frame + 1L
[10:22:48.497]                         envir <- sys.frame(frame)
[10:22:48.497]                       }
[10:22:48.497]                     }
[10:22:48.497]                     sendCondition <<- function(cond) NULL
[10:22:48.497]                   }
[10:22:48.497]                 })
[10:22:48.497]                 withCallingHandlers({
[10:22:48.497]                   1
[10:22:48.497]                 }, immediateCondition = function(cond) {
[10:22:48.497]                   sendCondition <- ...future.makeSendCondition()
[10:22:48.497]                   sendCondition(cond)
[10:22:48.497]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.497]                   {
[10:22:48.497]                     inherits <- base::inherits
[10:22:48.497]                     invokeRestart <- base::invokeRestart
[10:22:48.497]                     is.null <- base::is.null
[10:22:48.497]                     muffled <- FALSE
[10:22:48.497]                     if (inherits(cond, "message")) {
[10:22:48.497]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:48.497]                       if (muffled) 
[10:22:48.497]                         invokeRestart("muffleMessage")
[10:22:48.497]                     }
[10:22:48.497]                     else if (inherits(cond, "warning")) {
[10:22:48.497]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:48.497]                       if (muffled) 
[10:22:48.497]                         invokeRestart("muffleWarning")
[10:22:48.497]                     }
[10:22:48.497]                     else if (inherits(cond, "condition")) {
[10:22:48.497]                       if (!is.null(pattern)) {
[10:22:48.497]                         computeRestarts <- base::computeRestarts
[10:22:48.497]                         grepl <- base::grepl
[10:22:48.497]                         restarts <- computeRestarts(cond)
[10:22:48.497]                         for (restart in restarts) {
[10:22:48.497]                           name <- restart$name
[10:22:48.497]                           if (is.null(name)) 
[10:22:48.497]                             next
[10:22:48.497]                           if (!grepl(pattern, name)) 
[10:22:48.497]                             next
[10:22:48.497]                           invokeRestart(restart)
[10:22:48.497]                           muffled <- TRUE
[10:22:48.497]                           break
[10:22:48.497]                         }
[10:22:48.497]                       }
[10:22:48.497]                     }
[10:22:48.497]                     invisible(muffled)
[10:22:48.497]                   }
[10:22:48.497]                   muffleCondition(cond)
[10:22:48.497]                 })
[10:22:48.497]             }))
[10:22:48.497]             future::FutureResult(value = ...future.value$value, 
[10:22:48.497]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.497]                   ...future.rng), globalenv = if (FALSE) 
[10:22:48.497]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:48.497]                     ...future.globalenv.names))
[10:22:48.497]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:48.497]         }, condition = base::local({
[10:22:48.497]             c <- base::c
[10:22:48.497]             inherits <- base::inherits
[10:22:48.497]             invokeRestart <- base::invokeRestart
[10:22:48.497]             length <- base::length
[10:22:48.497]             list <- base::list
[10:22:48.497]             seq.int <- base::seq.int
[10:22:48.497]             signalCondition <- base::signalCondition
[10:22:48.497]             sys.calls <- base::sys.calls
[10:22:48.497]             `[[` <- base::`[[`
[10:22:48.497]             `+` <- base::`+`
[10:22:48.497]             `<<-` <- base::`<<-`
[10:22:48.497]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:48.497]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:48.497]                   3L)]
[10:22:48.497]             }
[10:22:48.497]             function(cond) {
[10:22:48.497]                 is_error <- inherits(cond, "error")
[10:22:48.497]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:48.497]                   NULL)
[10:22:48.497]                 if (is_error) {
[10:22:48.497]                   sessionInformation <- function() {
[10:22:48.497]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:48.497]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:48.497]                       search = base::search(), system = base::Sys.info())
[10:22:48.497]                   }
[10:22:48.497]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.497]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:48.497]                     cond$call), session = sessionInformation(), 
[10:22:48.497]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:48.497]                   signalCondition(cond)
[10:22:48.497]                 }
[10:22:48.497]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:48.497]                 "immediateCondition"))) {
[10:22:48.497]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:48.497]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.497]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:48.497]                   if (TRUE && !signal) {
[10:22:48.497]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.497]                     {
[10:22:48.497]                       inherits <- base::inherits
[10:22:48.497]                       invokeRestart <- base::invokeRestart
[10:22:48.497]                       is.null <- base::is.null
[10:22:48.497]                       muffled <- FALSE
[10:22:48.497]                       if (inherits(cond, "message")) {
[10:22:48.497]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.497]                         if (muffled) 
[10:22:48.497]                           invokeRestart("muffleMessage")
[10:22:48.497]                       }
[10:22:48.497]                       else if (inherits(cond, "warning")) {
[10:22:48.497]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.497]                         if (muffled) 
[10:22:48.497]                           invokeRestart("muffleWarning")
[10:22:48.497]                       }
[10:22:48.497]                       else if (inherits(cond, "condition")) {
[10:22:48.497]                         if (!is.null(pattern)) {
[10:22:48.497]                           computeRestarts <- base::computeRestarts
[10:22:48.497]                           grepl <- base::grepl
[10:22:48.497]                           restarts <- computeRestarts(cond)
[10:22:48.497]                           for (restart in restarts) {
[10:22:48.497]                             name <- restart$name
[10:22:48.497]                             if (is.null(name)) 
[10:22:48.497]                               next
[10:22:48.497]                             if (!grepl(pattern, name)) 
[10:22:48.497]                               next
[10:22:48.497]                             invokeRestart(restart)
[10:22:48.497]                             muffled <- TRUE
[10:22:48.497]                             break
[10:22:48.497]                           }
[10:22:48.497]                         }
[10:22:48.497]                       }
[10:22:48.497]                       invisible(muffled)
[10:22:48.497]                     }
[10:22:48.497]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.497]                   }
[10:22:48.497]                 }
[10:22:48.497]                 else {
[10:22:48.497]                   if (TRUE) {
[10:22:48.497]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.497]                     {
[10:22:48.497]                       inherits <- base::inherits
[10:22:48.497]                       invokeRestart <- base::invokeRestart
[10:22:48.497]                       is.null <- base::is.null
[10:22:48.497]                       muffled <- FALSE
[10:22:48.497]                       if (inherits(cond, "message")) {
[10:22:48.497]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.497]                         if (muffled) 
[10:22:48.497]                           invokeRestart("muffleMessage")
[10:22:48.497]                       }
[10:22:48.497]                       else if (inherits(cond, "warning")) {
[10:22:48.497]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.497]                         if (muffled) 
[10:22:48.497]                           invokeRestart("muffleWarning")
[10:22:48.497]                       }
[10:22:48.497]                       else if (inherits(cond, "condition")) {
[10:22:48.497]                         if (!is.null(pattern)) {
[10:22:48.497]                           computeRestarts <- base::computeRestarts
[10:22:48.497]                           grepl <- base::grepl
[10:22:48.497]                           restarts <- computeRestarts(cond)
[10:22:48.497]                           for (restart in restarts) {
[10:22:48.497]                             name <- restart$name
[10:22:48.497]                             if (is.null(name)) 
[10:22:48.497]                               next
[10:22:48.497]                             if (!grepl(pattern, name)) 
[10:22:48.497]                               next
[10:22:48.497]                             invokeRestart(restart)
[10:22:48.497]                             muffled <- TRUE
[10:22:48.497]                             break
[10:22:48.497]                           }
[10:22:48.497]                         }
[10:22:48.497]                       }
[10:22:48.497]                       invisible(muffled)
[10:22:48.497]                     }
[10:22:48.497]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.497]                   }
[10:22:48.497]                 }
[10:22:48.497]             }
[10:22:48.497]         }))
[10:22:48.497]     }, error = function(ex) {
[10:22:48.497]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:48.497]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.497]                 ...future.rng), started = ...future.startTime, 
[10:22:48.497]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:48.497]             version = "1.8"), class = "FutureResult")
[10:22:48.497]     }, finally = {
[10:22:48.497]         if (!identical(...future.workdir, getwd())) 
[10:22:48.497]             setwd(...future.workdir)
[10:22:48.497]         {
[10:22:48.497]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:48.497]                 ...future.oldOptions$nwarnings <- NULL
[10:22:48.497]             }
[10:22:48.497]             base::options(...future.oldOptions)
[10:22:48.497]             if (.Platform$OS.type == "windows") {
[10:22:48.497]                 old_names <- names(...future.oldEnvVars)
[10:22:48.497]                 envs <- base::Sys.getenv()
[10:22:48.497]                 names <- names(envs)
[10:22:48.497]                 common <- intersect(names, old_names)
[10:22:48.497]                 added <- setdiff(names, old_names)
[10:22:48.497]                 removed <- setdiff(old_names, names)
[10:22:48.497]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:48.497]                   envs[common]]
[10:22:48.497]                 NAMES <- toupper(changed)
[10:22:48.497]                 args <- list()
[10:22:48.497]                 for (kk in seq_along(NAMES)) {
[10:22:48.497]                   name <- changed[[kk]]
[10:22:48.497]                   NAME <- NAMES[[kk]]
[10:22:48.497]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.497]                     next
[10:22:48.497]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.497]                 }
[10:22:48.497]                 NAMES <- toupper(added)
[10:22:48.497]                 for (kk in seq_along(NAMES)) {
[10:22:48.497]                   name <- added[[kk]]
[10:22:48.497]                   NAME <- NAMES[[kk]]
[10:22:48.497]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.497]                     next
[10:22:48.497]                   args[[name]] <- ""
[10:22:48.497]                 }
[10:22:48.497]                 NAMES <- toupper(removed)
[10:22:48.497]                 for (kk in seq_along(NAMES)) {
[10:22:48.497]                   name <- removed[[kk]]
[10:22:48.497]                   NAME <- NAMES[[kk]]
[10:22:48.497]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.497]                     next
[10:22:48.497]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.497]                 }
[10:22:48.497]                 if (length(args) > 0) 
[10:22:48.497]                   base::do.call(base::Sys.setenv, args = args)
[10:22:48.497]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:48.497]             }
[10:22:48.497]             else {
[10:22:48.497]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:48.497]             }
[10:22:48.497]             {
[10:22:48.497]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:48.497]                   0L) {
[10:22:48.497]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:48.497]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:48.497]                   base::options(opts)
[10:22:48.497]                 }
[10:22:48.497]                 {
[10:22:48.497]                   {
[10:22:48.497]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:48.497]                     NULL
[10:22:48.497]                   }
[10:22:48.497]                   options(future.plan = NULL)
[10:22:48.497]                   if (is.na(NA_character_)) 
[10:22:48.497]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.497]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:48.497]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:48.497]                     .init = FALSE)
[10:22:48.497]                 }
[10:22:48.497]             }
[10:22:48.497]         }
[10:22:48.497]     })
[10:22:48.497]     if (TRUE) {
[10:22:48.497]         base::sink(type = "output", split = FALSE)
[10:22:48.497]         if (TRUE) {
[10:22:48.497]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:48.497]         }
[10:22:48.497]         else {
[10:22:48.497]             ...future.result["stdout"] <- base::list(NULL)
[10:22:48.497]         }
[10:22:48.497]         base::close(...future.stdout)
[10:22:48.497]         ...future.stdout <- NULL
[10:22:48.497]     }
[10:22:48.497]     ...future.result$conditions <- ...future.conditions
[10:22:48.497]     ...future.result$finished <- base::Sys.time()
[10:22:48.497]     ...future.result
[10:22:48.497] }
[10:22:48.500] MultisessionFuture started
[10:22:48.500] - Launch lazy future ... done
[10:22:48.500] run() for ‘MultisessionFuture’ ... done
[10:22:48.500] getGlobalsAndPackages() ...
[10:22:48.501] Searching for globals...
[10:22:48.501] - globals found: [2] ‘{’, ‘Sys.sleep’
[10:22:48.502] Searching for globals ... DONE
[10:22:48.502] Resolving globals: FALSE
[10:22:48.502] 
[10:22:48.502] 
[10:22:48.502] getGlobalsAndPackages() ... DONE
[10:22:48.502] run() for ‘Future’ ...
[10:22:48.502] - state: ‘created’
[10:22:48.503] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:48.516] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:48.516] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:48.516]   - Field: ‘node’
[10:22:48.517]   - Field: ‘label’
[10:22:48.517]   - Field: ‘local’
[10:22:48.517]   - Field: ‘owner’
[10:22:48.517]   - Field: ‘envir’
[10:22:48.517]   - Field: ‘workers’
[10:22:48.517]   - Field: ‘packages’
[10:22:48.517]   - Field: ‘gc’
[10:22:48.517]   - Field: ‘conditions’
[10:22:48.517]   - Field: ‘persistent’
[10:22:48.517]   - Field: ‘expr’
[10:22:48.517]   - Field: ‘uuid’
[10:22:48.517]   - Field: ‘seed’
[10:22:48.518]   - Field: ‘version’
[10:22:48.518]   - Field: ‘result’
[10:22:48.518]   - Field: ‘asynchronous’
[10:22:48.518]   - Field: ‘calls’
[10:22:48.518]   - Field: ‘globals’
[10:22:48.518]   - Field: ‘stdout’
[10:22:48.518]   - Field: ‘earlySignal’
[10:22:48.518]   - Field: ‘lazy’
[10:22:48.518]   - Field: ‘state’
[10:22:48.518] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:48.518] - Launch lazy future ...
[10:22:48.519] Packages needed by the future expression (n = 0): <none>
[10:22:48.519] Packages needed by future strategies (n = 0): <none>
[10:22:48.519] {
[10:22:48.519]     {
[10:22:48.519]         {
[10:22:48.519]             ...future.startTime <- base::Sys.time()
[10:22:48.519]             {
[10:22:48.519]                 {
[10:22:48.519]                   {
[10:22:48.519]                     {
[10:22:48.519]                       base::local({
[10:22:48.519]                         has_future <- base::requireNamespace("future", 
[10:22:48.519]                           quietly = TRUE)
[10:22:48.519]                         if (has_future) {
[10:22:48.519]                           ns <- base::getNamespace("future")
[10:22:48.519]                           version <- ns[[".package"]][["version"]]
[10:22:48.519]                           if (is.null(version)) 
[10:22:48.519]                             version <- utils::packageVersion("future")
[10:22:48.519]                         }
[10:22:48.519]                         else {
[10:22:48.519]                           version <- NULL
[10:22:48.519]                         }
[10:22:48.519]                         if (!has_future || version < "1.8.0") {
[10:22:48.519]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:48.519]                             "", base::R.version$version.string), 
[10:22:48.519]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:48.519]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:48.519]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:48.519]                               "release", "version")], collapse = " "), 
[10:22:48.519]                             hostname = base::Sys.info()[["nodename"]])
[10:22:48.519]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:48.519]                             info)
[10:22:48.519]                           info <- base::paste(info, collapse = "; ")
[10:22:48.519]                           if (!has_future) {
[10:22:48.519]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:48.519]                               info)
[10:22:48.519]                           }
[10:22:48.519]                           else {
[10:22:48.519]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:48.519]                               info, version)
[10:22:48.519]                           }
[10:22:48.519]                           base::stop(msg)
[10:22:48.519]                         }
[10:22:48.519]                       })
[10:22:48.519]                     }
[10:22:48.519]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:48.519]                     base::options(mc.cores = 1L)
[10:22:48.519]                   }
[10:22:48.519]                   ...future.strategy.old <- future::plan("list")
[10:22:48.519]                   options(future.plan = NULL)
[10:22:48.519]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.519]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:48.519]                 }
[10:22:48.519]                 ...future.workdir <- getwd()
[10:22:48.519]             }
[10:22:48.519]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:48.519]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:48.519]         }
[10:22:48.519]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:48.519]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:48.519]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:48.519]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:48.519]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:48.519]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:48.519]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:48.519]             base::names(...future.oldOptions))
[10:22:48.519]     }
[10:22:48.519]     if (FALSE) {
[10:22:48.519]     }
[10:22:48.519]     else {
[10:22:48.519]         if (TRUE) {
[10:22:48.519]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:48.519]                 open = "w")
[10:22:48.519]         }
[10:22:48.519]         else {
[10:22:48.519]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:48.519]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:48.519]         }
[10:22:48.519]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:48.519]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:48.519]             base::sink(type = "output", split = FALSE)
[10:22:48.519]             base::close(...future.stdout)
[10:22:48.519]         }, add = TRUE)
[10:22:48.519]     }
[10:22:48.519]     ...future.frame <- base::sys.nframe()
[10:22:48.519]     ...future.conditions <- base::list()
[10:22:48.519]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:48.519]     if (FALSE) {
[10:22:48.519]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:48.519]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:48.519]     }
[10:22:48.519]     ...future.result <- base::tryCatch({
[10:22:48.519]         base::withCallingHandlers({
[10:22:48.519]             ...future.value <- base::withVisible(base::local({
[10:22:48.519]                 ...future.makeSendCondition <- base::local({
[10:22:48.519]                   sendCondition <- NULL
[10:22:48.519]                   function(frame = 1L) {
[10:22:48.519]                     if (is.function(sendCondition)) 
[10:22:48.519]                       return(sendCondition)
[10:22:48.519]                     ns <- getNamespace("parallel")
[10:22:48.519]                     if (exists("sendData", mode = "function", 
[10:22:48.519]                       envir = ns)) {
[10:22:48.519]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:48.519]                         envir = ns)
[10:22:48.519]                       envir <- sys.frame(frame)
[10:22:48.519]                       master <- NULL
[10:22:48.519]                       while (!identical(envir, .GlobalEnv) && 
[10:22:48.519]                         !identical(envir, emptyenv())) {
[10:22:48.519]                         if (exists("master", mode = "list", envir = envir, 
[10:22:48.519]                           inherits = FALSE)) {
[10:22:48.519]                           master <- get("master", mode = "list", 
[10:22:48.519]                             envir = envir, inherits = FALSE)
[10:22:48.519]                           if (inherits(master, c("SOCKnode", 
[10:22:48.519]                             "SOCK0node"))) {
[10:22:48.519]                             sendCondition <<- function(cond) {
[10:22:48.519]                               data <- list(type = "VALUE", value = cond, 
[10:22:48.519]                                 success = TRUE)
[10:22:48.519]                               parallel_sendData(master, data)
[10:22:48.519]                             }
[10:22:48.519]                             return(sendCondition)
[10:22:48.519]                           }
[10:22:48.519]                         }
[10:22:48.519]                         frame <- frame + 1L
[10:22:48.519]                         envir <- sys.frame(frame)
[10:22:48.519]                       }
[10:22:48.519]                     }
[10:22:48.519]                     sendCondition <<- function(cond) NULL
[10:22:48.519]                   }
[10:22:48.519]                 })
[10:22:48.519]                 withCallingHandlers({
[10:22:48.519]                   {
[10:22:48.519]                     Sys.sleep(0.5)
[10:22:48.519]                     2
[10:22:48.519]                   }
[10:22:48.519]                 }, immediateCondition = function(cond) {
[10:22:48.519]                   sendCondition <- ...future.makeSendCondition()
[10:22:48.519]                   sendCondition(cond)
[10:22:48.519]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.519]                   {
[10:22:48.519]                     inherits <- base::inherits
[10:22:48.519]                     invokeRestart <- base::invokeRestart
[10:22:48.519]                     is.null <- base::is.null
[10:22:48.519]                     muffled <- FALSE
[10:22:48.519]                     if (inherits(cond, "message")) {
[10:22:48.519]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:48.519]                       if (muffled) 
[10:22:48.519]                         invokeRestart("muffleMessage")
[10:22:48.519]                     }
[10:22:48.519]                     else if (inherits(cond, "warning")) {
[10:22:48.519]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:48.519]                       if (muffled) 
[10:22:48.519]                         invokeRestart("muffleWarning")
[10:22:48.519]                     }
[10:22:48.519]                     else if (inherits(cond, "condition")) {
[10:22:48.519]                       if (!is.null(pattern)) {
[10:22:48.519]                         computeRestarts <- base::computeRestarts
[10:22:48.519]                         grepl <- base::grepl
[10:22:48.519]                         restarts <- computeRestarts(cond)
[10:22:48.519]                         for (restart in restarts) {
[10:22:48.519]                           name <- restart$name
[10:22:48.519]                           if (is.null(name)) 
[10:22:48.519]                             next
[10:22:48.519]                           if (!grepl(pattern, name)) 
[10:22:48.519]                             next
[10:22:48.519]                           invokeRestart(restart)
[10:22:48.519]                           muffled <- TRUE
[10:22:48.519]                           break
[10:22:48.519]                         }
[10:22:48.519]                       }
[10:22:48.519]                     }
[10:22:48.519]                     invisible(muffled)
[10:22:48.519]                   }
[10:22:48.519]                   muffleCondition(cond)
[10:22:48.519]                 })
[10:22:48.519]             }))
[10:22:48.519]             future::FutureResult(value = ...future.value$value, 
[10:22:48.519]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.519]                   ...future.rng), globalenv = if (FALSE) 
[10:22:48.519]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:48.519]                     ...future.globalenv.names))
[10:22:48.519]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:48.519]         }, condition = base::local({
[10:22:48.519]             c <- base::c
[10:22:48.519]             inherits <- base::inherits
[10:22:48.519]             invokeRestart <- base::invokeRestart
[10:22:48.519]             length <- base::length
[10:22:48.519]             list <- base::list
[10:22:48.519]             seq.int <- base::seq.int
[10:22:48.519]             signalCondition <- base::signalCondition
[10:22:48.519]             sys.calls <- base::sys.calls
[10:22:48.519]             `[[` <- base::`[[`
[10:22:48.519]             `+` <- base::`+`
[10:22:48.519]             `<<-` <- base::`<<-`
[10:22:48.519]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:48.519]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:48.519]                   3L)]
[10:22:48.519]             }
[10:22:48.519]             function(cond) {
[10:22:48.519]                 is_error <- inherits(cond, "error")
[10:22:48.519]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:48.519]                   NULL)
[10:22:48.519]                 if (is_error) {
[10:22:48.519]                   sessionInformation <- function() {
[10:22:48.519]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:48.519]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:48.519]                       search = base::search(), system = base::Sys.info())
[10:22:48.519]                   }
[10:22:48.519]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.519]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:48.519]                     cond$call), session = sessionInformation(), 
[10:22:48.519]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:48.519]                   signalCondition(cond)
[10:22:48.519]                 }
[10:22:48.519]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:48.519]                 "immediateCondition"))) {
[10:22:48.519]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:48.519]                   ...future.conditions[[length(...future.conditions) + 
[10:22:48.519]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:48.519]                   if (TRUE && !signal) {
[10:22:48.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.519]                     {
[10:22:48.519]                       inherits <- base::inherits
[10:22:48.519]                       invokeRestart <- base::invokeRestart
[10:22:48.519]                       is.null <- base::is.null
[10:22:48.519]                       muffled <- FALSE
[10:22:48.519]                       if (inherits(cond, "message")) {
[10:22:48.519]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.519]                         if (muffled) 
[10:22:48.519]                           invokeRestart("muffleMessage")
[10:22:48.519]                       }
[10:22:48.519]                       else if (inherits(cond, "warning")) {
[10:22:48.519]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.519]                         if (muffled) 
[10:22:48.519]                           invokeRestart("muffleWarning")
[10:22:48.519]                       }
[10:22:48.519]                       else if (inherits(cond, "condition")) {
[10:22:48.519]                         if (!is.null(pattern)) {
[10:22:48.519]                           computeRestarts <- base::computeRestarts
[10:22:48.519]                           grepl <- base::grepl
[10:22:48.519]                           restarts <- computeRestarts(cond)
[10:22:48.519]                           for (restart in restarts) {
[10:22:48.519]                             name <- restart$name
[10:22:48.519]                             if (is.null(name)) 
[10:22:48.519]                               next
[10:22:48.519]                             if (!grepl(pattern, name)) 
[10:22:48.519]                               next
[10:22:48.519]                             invokeRestart(restart)
[10:22:48.519]                             muffled <- TRUE
[10:22:48.519]                             break
[10:22:48.519]                           }
[10:22:48.519]                         }
[10:22:48.519]                       }
[10:22:48.519]                       invisible(muffled)
[10:22:48.519]                     }
[10:22:48.519]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.519]                   }
[10:22:48.519]                 }
[10:22:48.519]                 else {
[10:22:48.519]                   if (TRUE) {
[10:22:48.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:48.519]                     {
[10:22:48.519]                       inherits <- base::inherits
[10:22:48.519]                       invokeRestart <- base::invokeRestart
[10:22:48.519]                       is.null <- base::is.null
[10:22:48.519]                       muffled <- FALSE
[10:22:48.519]                       if (inherits(cond, "message")) {
[10:22:48.519]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:48.519]                         if (muffled) 
[10:22:48.519]                           invokeRestart("muffleMessage")
[10:22:48.519]                       }
[10:22:48.519]                       else if (inherits(cond, "warning")) {
[10:22:48.519]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:48.519]                         if (muffled) 
[10:22:48.519]                           invokeRestart("muffleWarning")
[10:22:48.519]                       }
[10:22:48.519]                       else if (inherits(cond, "condition")) {
[10:22:48.519]                         if (!is.null(pattern)) {
[10:22:48.519]                           computeRestarts <- base::computeRestarts
[10:22:48.519]                           grepl <- base::grepl
[10:22:48.519]                           restarts <- computeRestarts(cond)
[10:22:48.519]                           for (restart in restarts) {
[10:22:48.519]                             name <- restart$name
[10:22:48.519]                             if (is.null(name)) 
[10:22:48.519]                               next
[10:22:48.519]                             if (!grepl(pattern, name)) 
[10:22:48.519]                               next
[10:22:48.519]                             invokeRestart(restart)
[10:22:48.519]                             muffled <- TRUE
[10:22:48.519]                             break
[10:22:48.519]                           }
[10:22:48.519]                         }
[10:22:48.519]                       }
[10:22:48.519]                       invisible(muffled)
[10:22:48.519]                     }
[10:22:48.519]                     muffleCondition(cond, pattern = "^muffle")
[10:22:48.519]                   }
[10:22:48.519]                 }
[10:22:48.519]             }
[10:22:48.519]         }))
[10:22:48.519]     }, error = function(ex) {
[10:22:48.519]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:48.519]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:48.519]                 ...future.rng), started = ...future.startTime, 
[10:22:48.519]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:48.519]             version = "1.8"), class = "FutureResult")
[10:22:48.519]     }, finally = {
[10:22:48.519]         if (!identical(...future.workdir, getwd())) 
[10:22:48.519]             setwd(...future.workdir)
[10:22:48.519]         {
[10:22:48.519]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:48.519]                 ...future.oldOptions$nwarnings <- NULL
[10:22:48.519]             }
[10:22:48.519]             base::options(...future.oldOptions)
[10:22:48.519]             if (.Platform$OS.type == "windows") {
[10:22:48.519]                 old_names <- names(...future.oldEnvVars)
[10:22:48.519]                 envs <- base::Sys.getenv()
[10:22:48.519]                 names <- names(envs)
[10:22:48.519]                 common <- intersect(names, old_names)
[10:22:48.519]                 added <- setdiff(names, old_names)
[10:22:48.519]                 removed <- setdiff(old_names, names)
[10:22:48.519]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:48.519]                   envs[common]]
[10:22:48.519]                 NAMES <- toupper(changed)
[10:22:48.519]                 args <- list()
[10:22:48.519]                 for (kk in seq_along(NAMES)) {
[10:22:48.519]                   name <- changed[[kk]]
[10:22:48.519]                   NAME <- NAMES[[kk]]
[10:22:48.519]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.519]                     next
[10:22:48.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.519]                 }
[10:22:48.519]                 NAMES <- toupper(added)
[10:22:48.519]                 for (kk in seq_along(NAMES)) {
[10:22:48.519]                   name <- added[[kk]]
[10:22:48.519]                   NAME <- NAMES[[kk]]
[10:22:48.519]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.519]                     next
[10:22:48.519]                   args[[name]] <- ""
[10:22:48.519]                 }
[10:22:48.519]                 NAMES <- toupper(removed)
[10:22:48.519]                 for (kk in seq_along(NAMES)) {
[10:22:48.519]                   name <- removed[[kk]]
[10:22:48.519]                   NAME <- NAMES[[kk]]
[10:22:48.519]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:48.519]                     next
[10:22:48.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:48.519]                 }
[10:22:48.519]                 if (length(args) > 0) 
[10:22:48.519]                   base::do.call(base::Sys.setenv, args = args)
[10:22:48.519]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:48.519]             }
[10:22:48.519]             else {
[10:22:48.519]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:48.519]             }
[10:22:48.519]             {
[10:22:48.519]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:48.519]                   0L) {
[10:22:48.519]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:48.519]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:48.519]                   base::options(opts)
[10:22:48.519]                 }
[10:22:48.519]                 {
[10:22:48.519]                   {
[10:22:48.519]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:48.519]                     NULL
[10:22:48.519]                   }
[10:22:48.519]                   options(future.plan = NULL)
[10:22:48.519]                   if (is.na(NA_character_)) 
[10:22:48.519]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:48.519]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:48.519]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:48.519]                     .init = FALSE)
[10:22:48.519]                 }
[10:22:48.519]             }
[10:22:48.519]         }
[10:22:48.519]     })
[10:22:48.519]     if (TRUE) {
[10:22:48.519]         base::sink(type = "output", split = FALSE)
[10:22:48.519]         if (TRUE) {
[10:22:48.519]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:48.519]         }
[10:22:48.519]         else {
[10:22:48.519]             ...future.result["stdout"] <- base::list(NULL)
[10:22:48.519]         }
[10:22:48.519]         base::close(...future.stdout)
[10:22:48.519]         ...future.stdout <- NULL
[10:22:48.519]     }
[10:22:48.519]     ...future.result$conditions <- ...future.conditions
[10:22:48.519]     ...future.result$finished <- base::Sys.time()
[10:22:48.519]     ...future.result
[10:22:48.519] }
[10:22:48.522] MultisessionFuture started
[10:22:48.522] - Launch lazy future ... done
[10:22:48.522] run() for ‘MultisessionFuture’ ... done
[10:22:48.523] resolve() on list ...
[10:22:48.523]  recursive: 0
[10:22:48.523]  length: 1
[10:22:48.523] 
[10:22:48.544] receiveMessageFromWorker() for ClusterFuture ...
[10:22:48.544] - Validating connection of MultisessionFuture
[10:22:48.544] - received message: FutureResult
[10:22:48.544] - Received FutureResult
[10:22:48.544] - Erased future from FutureRegistry
[10:22:48.545] result() for ClusterFuture ...
[10:22:48.545] - result already collected: FutureResult
[10:22:48.545] result() for ClusterFuture ... done
[10:22:48.545] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:48.545] Future #1
[10:22:48.545]  length: 0 (resolved future 1)
[10:22:48.545] resolve() on list ... DONE
[10:22:48.545] resolve() on list ...
[10:22:48.545]  recursive: 0
[10:22:48.545]  length: 1
[10:22:48.546] 
[10:22:49.065] receiveMessageFromWorker() for ClusterFuture ...
[10:22:49.065] - Validating connection of MultisessionFuture
[10:22:49.065] - received message: FutureResult
[10:22:49.066] - Received FutureResult
[10:22:49.066] - Erased future from FutureRegistry
[10:22:49.066] result() for ClusterFuture ...
[10:22:49.066] - result already collected: FutureResult
[10:22:49.066] result() for ClusterFuture ... done
[10:22:49.066] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:49.066] Future #1
[10:22:49.066]  length: 0 (resolved future 1)
[10:22:49.066] resolve() on list ... DONE
[10:22:49.067] resolve() on list ...
[10:22:49.067]  recursive: 0
[10:22:49.067]  length: 1
[10:22:49.067] 
[10:22:49.067]  length: 0 (resolved future 1)
[10:22:49.067] resolve() on list ... DONE
[10:22:49.067] resolve() on list ...
[10:22:49.067]  recursive: 0
[10:22:49.067]  length: 4
[10:22:49.067] 
[10:22:49.068] Future #1
[10:22:49.068]  length: 3 (resolved future 1)
[10:22:49.068] Future #2
[10:22:49.068]  length: 2 (resolved future 2)
[10:22:49.068]  length: 1 (resolved future 3)
[10:22:49.068]  length: 0 (resolved future 4)
[10:22:49.068] resolve() on list ... DONE
[10:22:49.068] resolve() on list ...
[10:22:49.068]  recursive: 0
[10:22:49.068]  length: 4
[10:22:49.068] 
[10:22:49.069] Future #1
[10:22:49.069]  length: 3 (resolved future 1)
[10:22:49.069] Future #2
[10:22:49.069]  length: 2 (resolved future 2)
[10:22:49.069]  length: 1 (resolved future 3)
[10:22:49.069]  length: 0 (resolved future 4)
[10:22:49.069] resolve() on list ... DONE
[10:22:49.069] resolve() on list ...
[10:22:49.069]  recursive: 0
[10:22:49.070]  length: 1
[10:22:49.070] 
[10:22:49.070]  length: 0 (resolved future 1)
[10:22:49.070] resolve() on list ... DONE
[10:22:49.070] getGlobalsAndPackages() ...
[10:22:49.070] Searching for globals...
[10:22:49.071] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:22:49.071] Searching for globals ... DONE
[10:22:49.071] Resolving globals: FALSE
[10:22:49.072] The total size of the 1 globals is 35 bytes (35 bytes)
[10:22:49.072] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[10:22:49.072] - globals: [1] ‘kk’
[10:22:49.072] 
[10:22:49.072] getGlobalsAndPackages() ... DONE
[10:22:49.072] run() for ‘Future’ ...
[10:22:49.073] - state: ‘created’
[10:22:49.073] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:49.087] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:49.087] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:49.087]   - Field: ‘node’
[10:22:49.087]   - Field: ‘label’
[10:22:49.087]   - Field: ‘local’
[10:22:49.087]   - Field: ‘owner’
[10:22:49.087]   - Field: ‘envir’
[10:22:49.087]   - Field: ‘workers’
[10:22:49.088]   - Field: ‘packages’
[10:22:49.088]   - Field: ‘gc’
[10:22:49.088]   - Field: ‘conditions’
[10:22:49.088]   - Field: ‘persistent’
[10:22:49.088]   - Field: ‘expr’
[10:22:49.088]   - Field: ‘uuid’
[10:22:49.088]   - Field: ‘seed’
[10:22:49.088]   - Field: ‘version’
[10:22:49.088]   - Field: ‘result’
[10:22:49.088]   - Field: ‘asynchronous’
[10:22:49.088]   - Field: ‘calls’
[10:22:49.089]   - Field: ‘globals’
[10:22:49.089]   - Field: ‘stdout’
[10:22:49.089]   - Field: ‘earlySignal’
[10:22:49.089]   - Field: ‘lazy’
[10:22:49.089]   - Field: ‘state’
[10:22:49.089] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:49.089] - Launch lazy future ...
[10:22:49.089] Packages needed by the future expression (n = 0): <none>
[10:22:49.089] Packages needed by future strategies (n = 0): <none>
[10:22:49.090] {
[10:22:49.090]     {
[10:22:49.090]         {
[10:22:49.090]             ...future.startTime <- base::Sys.time()
[10:22:49.090]             {
[10:22:49.090]                 {
[10:22:49.090]                   {
[10:22:49.090]                     {
[10:22:49.090]                       base::local({
[10:22:49.090]                         has_future <- base::requireNamespace("future", 
[10:22:49.090]                           quietly = TRUE)
[10:22:49.090]                         if (has_future) {
[10:22:49.090]                           ns <- base::getNamespace("future")
[10:22:49.090]                           version <- ns[[".package"]][["version"]]
[10:22:49.090]                           if (is.null(version)) 
[10:22:49.090]                             version <- utils::packageVersion("future")
[10:22:49.090]                         }
[10:22:49.090]                         else {
[10:22:49.090]                           version <- NULL
[10:22:49.090]                         }
[10:22:49.090]                         if (!has_future || version < "1.8.0") {
[10:22:49.090]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:49.090]                             "", base::R.version$version.string), 
[10:22:49.090]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:49.090]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:49.090]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:49.090]                               "release", "version")], collapse = " "), 
[10:22:49.090]                             hostname = base::Sys.info()[["nodename"]])
[10:22:49.090]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:49.090]                             info)
[10:22:49.090]                           info <- base::paste(info, collapse = "; ")
[10:22:49.090]                           if (!has_future) {
[10:22:49.090]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:49.090]                               info)
[10:22:49.090]                           }
[10:22:49.090]                           else {
[10:22:49.090]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:49.090]                               info, version)
[10:22:49.090]                           }
[10:22:49.090]                           base::stop(msg)
[10:22:49.090]                         }
[10:22:49.090]                       })
[10:22:49.090]                     }
[10:22:49.090]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:49.090]                     base::options(mc.cores = 1L)
[10:22:49.090]                   }
[10:22:49.090]                   ...future.strategy.old <- future::plan("list")
[10:22:49.090]                   options(future.plan = NULL)
[10:22:49.090]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.090]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:49.090]                 }
[10:22:49.090]                 ...future.workdir <- getwd()
[10:22:49.090]             }
[10:22:49.090]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:49.090]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:49.090]         }
[10:22:49.090]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:49.090]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:49.090]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:49.090]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:49.090]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:49.090]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:49.090]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:49.090]             base::names(...future.oldOptions))
[10:22:49.090]     }
[10:22:49.090]     if (FALSE) {
[10:22:49.090]     }
[10:22:49.090]     else {
[10:22:49.090]         if (TRUE) {
[10:22:49.090]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:49.090]                 open = "w")
[10:22:49.090]         }
[10:22:49.090]         else {
[10:22:49.090]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:49.090]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:49.090]         }
[10:22:49.090]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:49.090]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:49.090]             base::sink(type = "output", split = FALSE)
[10:22:49.090]             base::close(...future.stdout)
[10:22:49.090]         }, add = TRUE)
[10:22:49.090]     }
[10:22:49.090]     ...future.frame <- base::sys.nframe()
[10:22:49.090]     ...future.conditions <- base::list()
[10:22:49.090]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:49.090]     if (FALSE) {
[10:22:49.090]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:49.090]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:49.090]     }
[10:22:49.090]     ...future.result <- base::tryCatch({
[10:22:49.090]         base::withCallingHandlers({
[10:22:49.090]             ...future.value <- base::withVisible(base::local({
[10:22:49.090]                 ...future.makeSendCondition <- base::local({
[10:22:49.090]                   sendCondition <- NULL
[10:22:49.090]                   function(frame = 1L) {
[10:22:49.090]                     if (is.function(sendCondition)) 
[10:22:49.090]                       return(sendCondition)
[10:22:49.090]                     ns <- getNamespace("parallel")
[10:22:49.090]                     if (exists("sendData", mode = "function", 
[10:22:49.090]                       envir = ns)) {
[10:22:49.090]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:49.090]                         envir = ns)
[10:22:49.090]                       envir <- sys.frame(frame)
[10:22:49.090]                       master <- NULL
[10:22:49.090]                       while (!identical(envir, .GlobalEnv) && 
[10:22:49.090]                         !identical(envir, emptyenv())) {
[10:22:49.090]                         if (exists("master", mode = "list", envir = envir, 
[10:22:49.090]                           inherits = FALSE)) {
[10:22:49.090]                           master <- get("master", mode = "list", 
[10:22:49.090]                             envir = envir, inherits = FALSE)
[10:22:49.090]                           if (inherits(master, c("SOCKnode", 
[10:22:49.090]                             "SOCK0node"))) {
[10:22:49.090]                             sendCondition <<- function(cond) {
[10:22:49.090]                               data <- list(type = "VALUE", value = cond, 
[10:22:49.090]                                 success = TRUE)
[10:22:49.090]                               parallel_sendData(master, data)
[10:22:49.090]                             }
[10:22:49.090]                             return(sendCondition)
[10:22:49.090]                           }
[10:22:49.090]                         }
[10:22:49.090]                         frame <- frame + 1L
[10:22:49.090]                         envir <- sys.frame(frame)
[10:22:49.090]                       }
[10:22:49.090]                     }
[10:22:49.090]                     sendCondition <<- function(cond) NULL
[10:22:49.090]                   }
[10:22:49.090]                 })
[10:22:49.090]                 withCallingHandlers({
[10:22:49.090]                   {
[10:22:49.090]                     Sys.sleep(0.1)
[10:22:49.090]                     kk
[10:22:49.090]                   }
[10:22:49.090]                 }, immediateCondition = function(cond) {
[10:22:49.090]                   sendCondition <- ...future.makeSendCondition()
[10:22:49.090]                   sendCondition(cond)
[10:22:49.090]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.090]                   {
[10:22:49.090]                     inherits <- base::inherits
[10:22:49.090]                     invokeRestart <- base::invokeRestart
[10:22:49.090]                     is.null <- base::is.null
[10:22:49.090]                     muffled <- FALSE
[10:22:49.090]                     if (inherits(cond, "message")) {
[10:22:49.090]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:49.090]                       if (muffled) 
[10:22:49.090]                         invokeRestart("muffleMessage")
[10:22:49.090]                     }
[10:22:49.090]                     else if (inherits(cond, "warning")) {
[10:22:49.090]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:49.090]                       if (muffled) 
[10:22:49.090]                         invokeRestart("muffleWarning")
[10:22:49.090]                     }
[10:22:49.090]                     else if (inherits(cond, "condition")) {
[10:22:49.090]                       if (!is.null(pattern)) {
[10:22:49.090]                         computeRestarts <- base::computeRestarts
[10:22:49.090]                         grepl <- base::grepl
[10:22:49.090]                         restarts <- computeRestarts(cond)
[10:22:49.090]                         for (restart in restarts) {
[10:22:49.090]                           name <- restart$name
[10:22:49.090]                           if (is.null(name)) 
[10:22:49.090]                             next
[10:22:49.090]                           if (!grepl(pattern, name)) 
[10:22:49.090]                             next
[10:22:49.090]                           invokeRestart(restart)
[10:22:49.090]                           muffled <- TRUE
[10:22:49.090]                           break
[10:22:49.090]                         }
[10:22:49.090]                       }
[10:22:49.090]                     }
[10:22:49.090]                     invisible(muffled)
[10:22:49.090]                   }
[10:22:49.090]                   muffleCondition(cond)
[10:22:49.090]                 })
[10:22:49.090]             }))
[10:22:49.090]             future::FutureResult(value = ...future.value$value, 
[10:22:49.090]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.090]                   ...future.rng), globalenv = if (FALSE) 
[10:22:49.090]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:49.090]                     ...future.globalenv.names))
[10:22:49.090]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:49.090]         }, condition = base::local({
[10:22:49.090]             c <- base::c
[10:22:49.090]             inherits <- base::inherits
[10:22:49.090]             invokeRestart <- base::invokeRestart
[10:22:49.090]             length <- base::length
[10:22:49.090]             list <- base::list
[10:22:49.090]             seq.int <- base::seq.int
[10:22:49.090]             signalCondition <- base::signalCondition
[10:22:49.090]             sys.calls <- base::sys.calls
[10:22:49.090]             `[[` <- base::`[[`
[10:22:49.090]             `+` <- base::`+`
[10:22:49.090]             `<<-` <- base::`<<-`
[10:22:49.090]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:49.090]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:49.090]                   3L)]
[10:22:49.090]             }
[10:22:49.090]             function(cond) {
[10:22:49.090]                 is_error <- inherits(cond, "error")
[10:22:49.090]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:49.090]                   NULL)
[10:22:49.090]                 if (is_error) {
[10:22:49.090]                   sessionInformation <- function() {
[10:22:49.090]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:49.090]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:49.090]                       search = base::search(), system = base::Sys.info())
[10:22:49.090]                   }
[10:22:49.090]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.090]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:49.090]                     cond$call), session = sessionInformation(), 
[10:22:49.090]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:49.090]                   signalCondition(cond)
[10:22:49.090]                 }
[10:22:49.090]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:49.090]                 "immediateCondition"))) {
[10:22:49.090]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:49.090]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.090]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:49.090]                   if (TRUE && !signal) {
[10:22:49.090]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.090]                     {
[10:22:49.090]                       inherits <- base::inherits
[10:22:49.090]                       invokeRestart <- base::invokeRestart
[10:22:49.090]                       is.null <- base::is.null
[10:22:49.090]                       muffled <- FALSE
[10:22:49.090]                       if (inherits(cond, "message")) {
[10:22:49.090]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.090]                         if (muffled) 
[10:22:49.090]                           invokeRestart("muffleMessage")
[10:22:49.090]                       }
[10:22:49.090]                       else if (inherits(cond, "warning")) {
[10:22:49.090]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.090]                         if (muffled) 
[10:22:49.090]                           invokeRestart("muffleWarning")
[10:22:49.090]                       }
[10:22:49.090]                       else if (inherits(cond, "condition")) {
[10:22:49.090]                         if (!is.null(pattern)) {
[10:22:49.090]                           computeRestarts <- base::computeRestarts
[10:22:49.090]                           grepl <- base::grepl
[10:22:49.090]                           restarts <- computeRestarts(cond)
[10:22:49.090]                           for (restart in restarts) {
[10:22:49.090]                             name <- restart$name
[10:22:49.090]                             if (is.null(name)) 
[10:22:49.090]                               next
[10:22:49.090]                             if (!grepl(pattern, name)) 
[10:22:49.090]                               next
[10:22:49.090]                             invokeRestart(restart)
[10:22:49.090]                             muffled <- TRUE
[10:22:49.090]                             break
[10:22:49.090]                           }
[10:22:49.090]                         }
[10:22:49.090]                       }
[10:22:49.090]                       invisible(muffled)
[10:22:49.090]                     }
[10:22:49.090]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.090]                   }
[10:22:49.090]                 }
[10:22:49.090]                 else {
[10:22:49.090]                   if (TRUE) {
[10:22:49.090]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.090]                     {
[10:22:49.090]                       inherits <- base::inherits
[10:22:49.090]                       invokeRestart <- base::invokeRestart
[10:22:49.090]                       is.null <- base::is.null
[10:22:49.090]                       muffled <- FALSE
[10:22:49.090]                       if (inherits(cond, "message")) {
[10:22:49.090]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.090]                         if (muffled) 
[10:22:49.090]                           invokeRestart("muffleMessage")
[10:22:49.090]                       }
[10:22:49.090]                       else if (inherits(cond, "warning")) {
[10:22:49.090]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.090]                         if (muffled) 
[10:22:49.090]                           invokeRestart("muffleWarning")
[10:22:49.090]                       }
[10:22:49.090]                       else if (inherits(cond, "condition")) {
[10:22:49.090]                         if (!is.null(pattern)) {
[10:22:49.090]                           computeRestarts <- base::computeRestarts
[10:22:49.090]                           grepl <- base::grepl
[10:22:49.090]                           restarts <- computeRestarts(cond)
[10:22:49.090]                           for (restart in restarts) {
[10:22:49.090]                             name <- restart$name
[10:22:49.090]                             if (is.null(name)) 
[10:22:49.090]                               next
[10:22:49.090]                             if (!grepl(pattern, name)) 
[10:22:49.090]                               next
[10:22:49.090]                             invokeRestart(restart)
[10:22:49.090]                             muffled <- TRUE
[10:22:49.090]                             break
[10:22:49.090]                           }
[10:22:49.090]                         }
[10:22:49.090]                       }
[10:22:49.090]                       invisible(muffled)
[10:22:49.090]                     }
[10:22:49.090]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.090]                   }
[10:22:49.090]                 }
[10:22:49.090]             }
[10:22:49.090]         }))
[10:22:49.090]     }, error = function(ex) {
[10:22:49.090]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:49.090]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.090]                 ...future.rng), started = ...future.startTime, 
[10:22:49.090]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:49.090]             version = "1.8"), class = "FutureResult")
[10:22:49.090]     }, finally = {
[10:22:49.090]         if (!identical(...future.workdir, getwd())) 
[10:22:49.090]             setwd(...future.workdir)
[10:22:49.090]         {
[10:22:49.090]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:49.090]                 ...future.oldOptions$nwarnings <- NULL
[10:22:49.090]             }
[10:22:49.090]             base::options(...future.oldOptions)
[10:22:49.090]             if (.Platform$OS.type == "windows") {
[10:22:49.090]                 old_names <- names(...future.oldEnvVars)
[10:22:49.090]                 envs <- base::Sys.getenv()
[10:22:49.090]                 names <- names(envs)
[10:22:49.090]                 common <- intersect(names, old_names)
[10:22:49.090]                 added <- setdiff(names, old_names)
[10:22:49.090]                 removed <- setdiff(old_names, names)
[10:22:49.090]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:49.090]                   envs[common]]
[10:22:49.090]                 NAMES <- toupper(changed)
[10:22:49.090]                 args <- list()
[10:22:49.090]                 for (kk in seq_along(NAMES)) {
[10:22:49.090]                   name <- changed[[kk]]
[10:22:49.090]                   NAME <- NAMES[[kk]]
[10:22:49.090]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.090]                     next
[10:22:49.090]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.090]                 }
[10:22:49.090]                 NAMES <- toupper(added)
[10:22:49.090]                 for (kk in seq_along(NAMES)) {
[10:22:49.090]                   name <- added[[kk]]
[10:22:49.090]                   NAME <- NAMES[[kk]]
[10:22:49.090]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.090]                     next
[10:22:49.090]                   args[[name]] <- ""
[10:22:49.090]                 }
[10:22:49.090]                 NAMES <- toupper(removed)
[10:22:49.090]                 for (kk in seq_along(NAMES)) {
[10:22:49.090]                   name <- removed[[kk]]
[10:22:49.090]                   NAME <- NAMES[[kk]]
[10:22:49.090]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.090]                     next
[10:22:49.090]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.090]                 }
[10:22:49.090]                 if (length(args) > 0) 
[10:22:49.090]                   base::do.call(base::Sys.setenv, args = args)
[10:22:49.090]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:49.090]             }
[10:22:49.090]             else {
[10:22:49.090]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:49.090]             }
[10:22:49.090]             {
[10:22:49.090]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:49.090]                   0L) {
[10:22:49.090]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:49.090]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:49.090]                   base::options(opts)
[10:22:49.090]                 }
[10:22:49.090]                 {
[10:22:49.090]                   {
[10:22:49.090]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:49.090]                     NULL
[10:22:49.090]                   }
[10:22:49.090]                   options(future.plan = NULL)
[10:22:49.090]                   if (is.na(NA_character_)) 
[10:22:49.090]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.090]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:49.090]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:49.090]                     .init = FALSE)
[10:22:49.090]                 }
[10:22:49.090]             }
[10:22:49.090]         }
[10:22:49.090]     })
[10:22:49.090]     if (TRUE) {
[10:22:49.090]         base::sink(type = "output", split = FALSE)
[10:22:49.090]         if (TRUE) {
[10:22:49.090]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:49.090]         }
[10:22:49.090]         else {
[10:22:49.090]             ...future.result["stdout"] <- base::list(NULL)
[10:22:49.090]         }
[10:22:49.090]         base::close(...future.stdout)
[10:22:49.090]         ...future.stdout <- NULL
[10:22:49.090]     }
[10:22:49.090]     ...future.result$conditions <- ...future.conditions
[10:22:49.090]     ...future.result$finished <- base::Sys.time()
[10:22:49.090]     ...future.result
[10:22:49.090] }
[10:22:49.095] Exporting 1 global objects (344 bytes) to cluster node #1 ...
[10:22:49.096] Exporting ‘kk’ (35 bytes) to cluster node #1 ...
[10:22:49.096] Exporting ‘kk’ (35 bytes) to cluster node #1 ... DONE
[10:22:49.096] Exporting 1 global objects (344 bytes) to cluster node #1 ... DONE
[10:22:49.097] MultisessionFuture started
[10:22:49.097] - Launch lazy future ... done
[10:22:49.097] run() for ‘MultisessionFuture’ ... done
[10:22:49.097] getGlobalsAndPackages() ...
[10:22:49.097] Searching for globals...
[10:22:49.098] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:22:49.099] Searching for globals ... DONE
[10:22:49.099] Resolving globals: FALSE
[10:22:49.099] The total size of the 1 globals is 35 bytes (35 bytes)
[10:22:49.099] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[10:22:49.099] - globals: [1] ‘kk’
[10:22:49.100] 
[10:22:49.100] getGlobalsAndPackages() ... DONE
[10:22:49.100] run() for ‘Future’ ...
[10:22:49.100] - state: ‘created’
[10:22:49.100] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:49.115] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:49.115] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:49.115]   - Field: ‘node’
[10:22:49.115]   - Field: ‘label’
[10:22:49.115]   - Field: ‘local’
[10:22:49.115]   - Field: ‘owner’
[10:22:49.115]   - Field: ‘envir’
[10:22:49.115]   - Field: ‘workers’
[10:22:49.115]   - Field: ‘packages’
[10:22:49.115]   - Field: ‘gc’
[10:22:49.115]   - Field: ‘conditions’
[10:22:49.116]   - Field: ‘persistent’
[10:22:49.116]   - Field: ‘expr’
[10:22:49.116]   - Field: ‘uuid’
[10:22:49.116]   - Field: ‘seed’
[10:22:49.116]   - Field: ‘version’
[10:22:49.116]   - Field: ‘result’
[10:22:49.116]   - Field: ‘asynchronous’
[10:22:49.116]   - Field: ‘calls’
[10:22:49.116]   - Field: ‘globals’
[10:22:49.116]   - Field: ‘stdout’
[10:22:49.116]   - Field: ‘earlySignal’
[10:22:49.116]   - Field: ‘lazy’
[10:22:49.117]   - Field: ‘state’
[10:22:49.117] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:49.117] - Launch lazy future ...
[10:22:49.117] Packages needed by the future expression (n = 0): <none>
[10:22:49.117] Packages needed by future strategies (n = 0): <none>
[10:22:49.118] {
[10:22:49.118]     {
[10:22:49.118]         {
[10:22:49.118]             ...future.startTime <- base::Sys.time()
[10:22:49.118]             {
[10:22:49.118]                 {
[10:22:49.118]                   {
[10:22:49.118]                     {
[10:22:49.118]                       base::local({
[10:22:49.118]                         has_future <- base::requireNamespace("future", 
[10:22:49.118]                           quietly = TRUE)
[10:22:49.118]                         if (has_future) {
[10:22:49.118]                           ns <- base::getNamespace("future")
[10:22:49.118]                           version <- ns[[".package"]][["version"]]
[10:22:49.118]                           if (is.null(version)) 
[10:22:49.118]                             version <- utils::packageVersion("future")
[10:22:49.118]                         }
[10:22:49.118]                         else {
[10:22:49.118]                           version <- NULL
[10:22:49.118]                         }
[10:22:49.118]                         if (!has_future || version < "1.8.0") {
[10:22:49.118]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:49.118]                             "", base::R.version$version.string), 
[10:22:49.118]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:49.118]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:49.118]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:49.118]                               "release", "version")], collapse = " "), 
[10:22:49.118]                             hostname = base::Sys.info()[["nodename"]])
[10:22:49.118]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:49.118]                             info)
[10:22:49.118]                           info <- base::paste(info, collapse = "; ")
[10:22:49.118]                           if (!has_future) {
[10:22:49.118]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:49.118]                               info)
[10:22:49.118]                           }
[10:22:49.118]                           else {
[10:22:49.118]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:49.118]                               info, version)
[10:22:49.118]                           }
[10:22:49.118]                           base::stop(msg)
[10:22:49.118]                         }
[10:22:49.118]                       })
[10:22:49.118]                     }
[10:22:49.118]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:49.118]                     base::options(mc.cores = 1L)
[10:22:49.118]                   }
[10:22:49.118]                   ...future.strategy.old <- future::plan("list")
[10:22:49.118]                   options(future.plan = NULL)
[10:22:49.118]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.118]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:49.118]                 }
[10:22:49.118]                 ...future.workdir <- getwd()
[10:22:49.118]             }
[10:22:49.118]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:49.118]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:49.118]         }
[10:22:49.118]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:49.118]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:49.118]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:49.118]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:49.118]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:49.118]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:49.118]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:49.118]             base::names(...future.oldOptions))
[10:22:49.118]     }
[10:22:49.118]     if (FALSE) {
[10:22:49.118]     }
[10:22:49.118]     else {
[10:22:49.118]         if (TRUE) {
[10:22:49.118]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:49.118]                 open = "w")
[10:22:49.118]         }
[10:22:49.118]         else {
[10:22:49.118]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:49.118]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:49.118]         }
[10:22:49.118]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:49.118]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:49.118]             base::sink(type = "output", split = FALSE)
[10:22:49.118]             base::close(...future.stdout)
[10:22:49.118]         }, add = TRUE)
[10:22:49.118]     }
[10:22:49.118]     ...future.frame <- base::sys.nframe()
[10:22:49.118]     ...future.conditions <- base::list()
[10:22:49.118]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:49.118]     if (FALSE) {
[10:22:49.118]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:49.118]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:49.118]     }
[10:22:49.118]     ...future.result <- base::tryCatch({
[10:22:49.118]         base::withCallingHandlers({
[10:22:49.118]             ...future.value <- base::withVisible(base::local({
[10:22:49.118]                 ...future.makeSendCondition <- base::local({
[10:22:49.118]                   sendCondition <- NULL
[10:22:49.118]                   function(frame = 1L) {
[10:22:49.118]                     if (is.function(sendCondition)) 
[10:22:49.118]                       return(sendCondition)
[10:22:49.118]                     ns <- getNamespace("parallel")
[10:22:49.118]                     if (exists("sendData", mode = "function", 
[10:22:49.118]                       envir = ns)) {
[10:22:49.118]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:49.118]                         envir = ns)
[10:22:49.118]                       envir <- sys.frame(frame)
[10:22:49.118]                       master <- NULL
[10:22:49.118]                       while (!identical(envir, .GlobalEnv) && 
[10:22:49.118]                         !identical(envir, emptyenv())) {
[10:22:49.118]                         if (exists("master", mode = "list", envir = envir, 
[10:22:49.118]                           inherits = FALSE)) {
[10:22:49.118]                           master <- get("master", mode = "list", 
[10:22:49.118]                             envir = envir, inherits = FALSE)
[10:22:49.118]                           if (inherits(master, c("SOCKnode", 
[10:22:49.118]                             "SOCK0node"))) {
[10:22:49.118]                             sendCondition <<- function(cond) {
[10:22:49.118]                               data <- list(type = "VALUE", value = cond, 
[10:22:49.118]                                 success = TRUE)
[10:22:49.118]                               parallel_sendData(master, data)
[10:22:49.118]                             }
[10:22:49.118]                             return(sendCondition)
[10:22:49.118]                           }
[10:22:49.118]                         }
[10:22:49.118]                         frame <- frame + 1L
[10:22:49.118]                         envir <- sys.frame(frame)
[10:22:49.118]                       }
[10:22:49.118]                     }
[10:22:49.118]                     sendCondition <<- function(cond) NULL
[10:22:49.118]                   }
[10:22:49.118]                 })
[10:22:49.118]                 withCallingHandlers({
[10:22:49.118]                   {
[10:22:49.118]                     Sys.sleep(0.1)
[10:22:49.118]                     kk
[10:22:49.118]                   }
[10:22:49.118]                 }, immediateCondition = function(cond) {
[10:22:49.118]                   sendCondition <- ...future.makeSendCondition()
[10:22:49.118]                   sendCondition(cond)
[10:22:49.118]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.118]                   {
[10:22:49.118]                     inherits <- base::inherits
[10:22:49.118]                     invokeRestart <- base::invokeRestart
[10:22:49.118]                     is.null <- base::is.null
[10:22:49.118]                     muffled <- FALSE
[10:22:49.118]                     if (inherits(cond, "message")) {
[10:22:49.118]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:49.118]                       if (muffled) 
[10:22:49.118]                         invokeRestart("muffleMessage")
[10:22:49.118]                     }
[10:22:49.118]                     else if (inherits(cond, "warning")) {
[10:22:49.118]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:49.118]                       if (muffled) 
[10:22:49.118]                         invokeRestart("muffleWarning")
[10:22:49.118]                     }
[10:22:49.118]                     else if (inherits(cond, "condition")) {
[10:22:49.118]                       if (!is.null(pattern)) {
[10:22:49.118]                         computeRestarts <- base::computeRestarts
[10:22:49.118]                         grepl <- base::grepl
[10:22:49.118]                         restarts <- computeRestarts(cond)
[10:22:49.118]                         for (restart in restarts) {
[10:22:49.118]                           name <- restart$name
[10:22:49.118]                           if (is.null(name)) 
[10:22:49.118]                             next
[10:22:49.118]                           if (!grepl(pattern, name)) 
[10:22:49.118]                             next
[10:22:49.118]                           invokeRestart(restart)
[10:22:49.118]                           muffled <- TRUE
[10:22:49.118]                           break
[10:22:49.118]                         }
[10:22:49.118]                       }
[10:22:49.118]                     }
[10:22:49.118]                     invisible(muffled)
[10:22:49.118]                   }
[10:22:49.118]                   muffleCondition(cond)
[10:22:49.118]                 })
[10:22:49.118]             }))
[10:22:49.118]             future::FutureResult(value = ...future.value$value, 
[10:22:49.118]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.118]                   ...future.rng), globalenv = if (FALSE) 
[10:22:49.118]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:49.118]                     ...future.globalenv.names))
[10:22:49.118]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:49.118]         }, condition = base::local({
[10:22:49.118]             c <- base::c
[10:22:49.118]             inherits <- base::inherits
[10:22:49.118]             invokeRestart <- base::invokeRestart
[10:22:49.118]             length <- base::length
[10:22:49.118]             list <- base::list
[10:22:49.118]             seq.int <- base::seq.int
[10:22:49.118]             signalCondition <- base::signalCondition
[10:22:49.118]             sys.calls <- base::sys.calls
[10:22:49.118]             `[[` <- base::`[[`
[10:22:49.118]             `+` <- base::`+`
[10:22:49.118]             `<<-` <- base::`<<-`
[10:22:49.118]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:49.118]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:49.118]                   3L)]
[10:22:49.118]             }
[10:22:49.118]             function(cond) {
[10:22:49.118]                 is_error <- inherits(cond, "error")
[10:22:49.118]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:49.118]                   NULL)
[10:22:49.118]                 if (is_error) {
[10:22:49.118]                   sessionInformation <- function() {
[10:22:49.118]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:49.118]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:49.118]                       search = base::search(), system = base::Sys.info())
[10:22:49.118]                   }
[10:22:49.118]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.118]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:49.118]                     cond$call), session = sessionInformation(), 
[10:22:49.118]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:49.118]                   signalCondition(cond)
[10:22:49.118]                 }
[10:22:49.118]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:49.118]                 "immediateCondition"))) {
[10:22:49.118]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:49.118]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.118]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:49.118]                   if (TRUE && !signal) {
[10:22:49.118]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.118]                     {
[10:22:49.118]                       inherits <- base::inherits
[10:22:49.118]                       invokeRestart <- base::invokeRestart
[10:22:49.118]                       is.null <- base::is.null
[10:22:49.118]                       muffled <- FALSE
[10:22:49.118]                       if (inherits(cond, "message")) {
[10:22:49.118]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.118]                         if (muffled) 
[10:22:49.118]                           invokeRestart("muffleMessage")
[10:22:49.118]                       }
[10:22:49.118]                       else if (inherits(cond, "warning")) {
[10:22:49.118]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.118]                         if (muffled) 
[10:22:49.118]                           invokeRestart("muffleWarning")
[10:22:49.118]                       }
[10:22:49.118]                       else if (inherits(cond, "condition")) {
[10:22:49.118]                         if (!is.null(pattern)) {
[10:22:49.118]                           computeRestarts <- base::computeRestarts
[10:22:49.118]                           grepl <- base::grepl
[10:22:49.118]                           restarts <- computeRestarts(cond)
[10:22:49.118]                           for (restart in restarts) {
[10:22:49.118]                             name <- restart$name
[10:22:49.118]                             if (is.null(name)) 
[10:22:49.118]                               next
[10:22:49.118]                             if (!grepl(pattern, name)) 
[10:22:49.118]                               next
[10:22:49.118]                             invokeRestart(restart)
[10:22:49.118]                             muffled <- TRUE
[10:22:49.118]                             break
[10:22:49.118]                           }
[10:22:49.118]                         }
[10:22:49.118]                       }
[10:22:49.118]                       invisible(muffled)
[10:22:49.118]                     }
[10:22:49.118]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.118]                   }
[10:22:49.118]                 }
[10:22:49.118]                 else {
[10:22:49.118]                   if (TRUE) {
[10:22:49.118]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.118]                     {
[10:22:49.118]                       inherits <- base::inherits
[10:22:49.118]                       invokeRestart <- base::invokeRestart
[10:22:49.118]                       is.null <- base::is.null
[10:22:49.118]                       muffled <- FALSE
[10:22:49.118]                       if (inherits(cond, "message")) {
[10:22:49.118]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.118]                         if (muffled) 
[10:22:49.118]                           invokeRestart("muffleMessage")
[10:22:49.118]                       }
[10:22:49.118]                       else if (inherits(cond, "warning")) {
[10:22:49.118]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.118]                         if (muffled) 
[10:22:49.118]                           invokeRestart("muffleWarning")
[10:22:49.118]                       }
[10:22:49.118]                       else if (inherits(cond, "condition")) {
[10:22:49.118]                         if (!is.null(pattern)) {
[10:22:49.118]                           computeRestarts <- base::computeRestarts
[10:22:49.118]                           grepl <- base::grepl
[10:22:49.118]                           restarts <- computeRestarts(cond)
[10:22:49.118]                           for (restart in restarts) {
[10:22:49.118]                             name <- restart$name
[10:22:49.118]                             if (is.null(name)) 
[10:22:49.118]                               next
[10:22:49.118]                             if (!grepl(pattern, name)) 
[10:22:49.118]                               next
[10:22:49.118]                             invokeRestart(restart)
[10:22:49.118]                             muffled <- TRUE
[10:22:49.118]                             break
[10:22:49.118]                           }
[10:22:49.118]                         }
[10:22:49.118]                       }
[10:22:49.118]                       invisible(muffled)
[10:22:49.118]                     }
[10:22:49.118]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.118]                   }
[10:22:49.118]                 }
[10:22:49.118]             }
[10:22:49.118]         }))
[10:22:49.118]     }, error = function(ex) {
[10:22:49.118]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:49.118]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.118]                 ...future.rng), started = ...future.startTime, 
[10:22:49.118]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:49.118]             version = "1.8"), class = "FutureResult")
[10:22:49.118]     }, finally = {
[10:22:49.118]         if (!identical(...future.workdir, getwd())) 
[10:22:49.118]             setwd(...future.workdir)
[10:22:49.118]         {
[10:22:49.118]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:49.118]                 ...future.oldOptions$nwarnings <- NULL
[10:22:49.118]             }
[10:22:49.118]             base::options(...future.oldOptions)
[10:22:49.118]             if (.Platform$OS.type == "windows") {
[10:22:49.118]                 old_names <- names(...future.oldEnvVars)
[10:22:49.118]                 envs <- base::Sys.getenv()
[10:22:49.118]                 names <- names(envs)
[10:22:49.118]                 common <- intersect(names, old_names)
[10:22:49.118]                 added <- setdiff(names, old_names)
[10:22:49.118]                 removed <- setdiff(old_names, names)
[10:22:49.118]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:49.118]                   envs[common]]
[10:22:49.118]                 NAMES <- toupper(changed)
[10:22:49.118]                 args <- list()
[10:22:49.118]                 for (kk in seq_along(NAMES)) {
[10:22:49.118]                   name <- changed[[kk]]
[10:22:49.118]                   NAME <- NAMES[[kk]]
[10:22:49.118]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.118]                     next
[10:22:49.118]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.118]                 }
[10:22:49.118]                 NAMES <- toupper(added)
[10:22:49.118]                 for (kk in seq_along(NAMES)) {
[10:22:49.118]                   name <- added[[kk]]
[10:22:49.118]                   NAME <- NAMES[[kk]]
[10:22:49.118]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.118]                     next
[10:22:49.118]                   args[[name]] <- ""
[10:22:49.118]                 }
[10:22:49.118]                 NAMES <- toupper(removed)
[10:22:49.118]                 for (kk in seq_along(NAMES)) {
[10:22:49.118]                   name <- removed[[kk]]
[10:22:49.118]                   NAME <- NAMES[[kk]]
[10:22:49.118]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.118]                     next
[10:22:49.118]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.118]                 }
[10:22:49.118]                 if (length(args) > 0) 
[10:22:49.118]                   base::do.call(base::Sys.setenv, args = args)
[10:22:49.118]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:49.118]             }
[10:22:49.118]             else {
[10:22:49.118]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:49.118]             }
[10:22:49.118]             {
[10:22:49.118]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:49.118]                   0L) {
[10:22:49.118]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:49.118]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:49.118]                   base::options(opts)
[10:22:49.118]                 }
[10:22:49.118]                 {
[10:22:49.118]                   {
[10:22:49.118]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:49.118]                     NULL
[10:22:49.118]                   }
[10:22:49.118]                   options(future.plan = NULL)
[10:22:49.118]                   if (is.na(NA_character_)) 
[10:22:49.118]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.118]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:49.118]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:49.118]                     .init = FALSE)
[10:22:49.118]                 }
[10:22:49.118]             }
[10:22:49.118]         }
[10:22:49.118]     })
[10:22:49.118]     if (TRUE) {
[10:22:49.118]         base::sink(type = "output", split = FALSE)
[10:22:49.118]         if (TRUE) {
[10:22:49.118]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:49.118]         }
[10:22:49.118]         else {
[10:22:49.118]             ...future.result["stdout"] <- base::list(NULL)
[10:22:49.118]         }
[10:22:49.118]         base::close(...future.stdout)
[10:22:49.118]         ...future.stdout <- NULL
[10:22:49.118]     }
[10:22:49.118]     ...future.result$conditions <- ...future.conditions
[10:22:49.118]     ...future.result$finished <- base::Sys.time()
[10:22:49.118]     ...future.result
[10:22:49.118] }
[10:22:49.120] Exporting 1 global objects (344 bytes) to cluster node #2 ...
[10:22:49.121] Exporting ‘kk’ (35 bytes) to cluster node #2 ...
[10:22:49.121] Exporting ‘kk’ (35 bytes) to cluster node #2 ... DONE
[10:22:49.121] Exporting 1 global objects (344 bytes) to cluster node #2 ... DONE
[10:22:49.121] MultisessionFuture started
[10:22:49.122] - Launch lazy future ... done
[10:22:49.122] run() for ‘MultisessionFuture’ ... done
[10:22:49.122] getGlobalsAndPackages() ...
[10:22:49.122] Searching for globals...
[10:22:49.123] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:22:49.123] Searching for globals ... DONE
[10:22:49.123] Resolving globals: FALSE
[10:22:49.123] The total size of the 1 globals is 35 bytes (35 bytes)
[10:22:49.124] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[10:22:49.124] - globals: [1] ‘kk’
[10:22:49.124] 
[10:22:49.124] getGlobalsAndPackages() ... DONE
[10:22:49.124] run() for ‘Future’ ...
[10:22:49.124] - state: ‘created’
[10:22:49.125] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:49.138] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:49.138] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:49.139]   - Field: ‘node’
[10:22:49.139]   - Field: ‘label’
[10:22:49.139]   - Field: ‘local’
[10:22:49.139]   - Field: ‘owner’
[10:22:49.139]   - Field: ‘envir’
[10:22:49.139]   - Field: ‘workers’
[10:22:49.139]   - Field: ‘packages’
[10:22:49.139]   - Field: ‘gc’
[10:22:49.140]   - Field: ‘conditions’
[10:22:49.140]   - Field: ‘persistent’
[10:22:49.140]   - Field: ‘expr’
[10:22:49.140]   - Field: ‘uuid’
[10:22:49.140]   - Field: ‘seed’
[10:22:49.140]   - Field: ‘version’
[10:22:49.140]   - Field: ‘result’
[10:22:49.140]   - Field: ‘asynchronous’
[10:22:49.140]   - Field: ‘calls’
[10:22:49.140]   - Field: ‘globals’
[10:22:49.140]   - Field: ‘stdout’
[10:22:49.141]   - Field: ‘earlySignal’
[10:22:49.141]   - Field: ‘lazy’
[10:22:49.141]   - Field: ‘state’
[10:22:49.141] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:49.141] - Launch lazy future ...
[10:22:49.141] Packages needed by the future expression (n = 0): <none>
[10:22:49.141] Packages needed by future strategies (n = 0): <none>
[10:22:49.142] {
[10:22:49.142]     {
[10:22:49.142]         {
[10:22:49.142]             ...future.startTime <- base::Sys.time()
[10:22:49.142]             {
[10:22:49.142]                 {
[10:22:49.142]                   {
[10:22:49.142]                     {
[10:22:49.142]                       base::local({
[10:22:49.142]                         has_future <- base::requireNamespace("future", 
[10:22:49.142]                           quietly = TRUE)
[10:22:49.142]                         if (has_future) {
[10:22:49.142]                           ns <- base::getNamespace("future")
[10:22:49.142]                           version <- ns[[".package"]][["version"]]
[10:22:49.142]                           if (is.null(version)) 
[10:22:49.142]                             version <- utils::packageVersion("future")
[10:22:49.142]                         }
[10:22:49.142]                         else {
[10:22:49.142]                           version <- NULL
[10:22:49.142]                         }
[10:22:49.142]                         if (!has_future || version < "1.8.0") {
[10:22:49.142]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:49.142]                             "", base::R.version$version.string), 
[10:22:49.142]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:49.142]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:49.142]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:49.142]                               "release", "version")], collapse = " "), 
[10:22:49.142]                             hostname = base::Sys.info()[["nodename"]])
[10:22:49.142]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:49.142]                             info)
[10:22:49.142]                           info <- base::paste(info, collapse = "; ")
[10:22:49.142]                           if (!has_future) {
[10:22:49.142]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:49.142]                               info)
[10:22:49.142]                           }
[10:22:49.142]                           else {
[10:22:49.142]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:49.142]                               info, version)
[10:22:49.142]                           }
[10:22:49.142]                           base::stop(msg)
[10:22:49.142]                         }
[10:22:49.142]                       })
[10:22:49.142]                     }
[10:22:49.142]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:49.142]                     base::options(mc.cores = 1L)
[10:22:49.142]                   }
[10:22:49.142]                   ...future.strategy.old <- future::plan("list")
[10:22:49.142]                   options(future.plan = NULL)
[10:22:49.142]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.142]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:49.142]                 }
[10:22:49.142]                 ...future.workdir <- getwd()
[10:22:49.142]             }
[10:22:49.142]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:49.142]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:49.142]         }
[10:22:49.142]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:49.142]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:49.142]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:49.142]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:49.142]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:49.142]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:49.142]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:49.142]             base::names(...future.oldOptions))
[10:22:49.142]     }
[10:22:49.142]     if (FALSE) {
[10:22:49.142]     }
[10:22:49.142]     else {
[10:22:49.142]         if (TRUE) {
[10:22:49.142]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:49.142]                 open = "w")
[10:22:49.142]         }
[10:22:49.142]         else {
[10:22:49.142]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:49.142]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:49.142]         }
[10:22:49.142]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:49.142]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:49.142]             base::sink(type = "output", split = FALSE)
[10:22:49.142]             base::close(...future.stdout)
[10:22:49.142]         }, add = TRUE)
[10:22:49.142]     }
[10:22:49.142]     ...future.frame <- base::sys.nframe()
[10:22:49.142]     ...future.conditions <- base::list()
[10:22:49.142]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:49.142]     if (FALSE) {
[10:22:49.142]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:49.142]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:49.142]     }
[10:22:49.142]     ...future.result <- base::tryCatch({
[10:22:49.142]         base::withCallingHandlers({
[10:22:49.142]             ...future.value <- base::withVisible(base::local({
[10:22:49.142]                 ...future.makeSendCondition <- base::local({
[10:22:49.142]                   sendCondition <- NULL
[10:22:49.142]                   function(frame = 1L) {
[10:22:49.142]                     if (is.function(sendCondition)) 
[10:22:49.142]                       return(sendCondition)
[10:22:49.142]                     ns <- getNamespace("parallel")
[10:22:49.142]                     if (exists("sendData", mode = "function", 
[10:22:49.142]                       envir = ns)) {
[10:22:49.142]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:49.142]                         envir = ns)
[10:22:49.142]                       envir <- sys.frame(frame)
[10:22:49.142]                       master <- NULL
[10:22:49.142]                       while (!identical(envir, .GlobalEnv) && 
[10:22:49.142]                         !identical(envir, emptyenv())) {
[10:22:49.142]                         if (exists("master", mode = "list", envir = envir, 
[10:22:49.142]                           inherits = FALSE)) {
[10:22:49.142]                           master <- get("master", mode = "list", 
[10:22:49.142]                             envir = envir, inherits = FALSE)
[10:22:49.142]                           if (inherits(master, c("SOCKnode", 
[10:22:49.142]                             "SOCK0node"))) {
[10:22:49.142]                             sendCondition <<- function(cond) {
[10:22:49.142]                               data <- list(type = "VALUE", value = cond, 
[10:22:49.142]                                 success = TRUE)
[10:22:49.142]                               parallel_sendData(master, data)
[10:22:49.142]                             }
[10:22:49.142]                             return(sendCondition)
[10:22:49.142]                           }
[10:22:49.142]                         }
[10:22:49.142]                         frame <- frame + 1L
[10:22:49.142]                         envir <- sys.frame(frame)
[10:22:49.142]                       }
[10:22:49.142]                     }
[10:22:49.142]                     sendCondition <<- function(cond) NULL
[10:22:49.142]                   }
[10:22:49.142]                 })
[10:22:49.142]                 withCallingHandlers({
[10:22:49.142]                   {
[10:22:49.142]                     Sys.sleep(0.1)
[10:22:49.142]                     kk
[10:22:49.142]                   }
[10:22:49.142]                 }, immediateCondition = function(cond) {
[10:22:49.142]                   sendCondition <- ...future.makeSendCondition()
[10:22:49.142]                   sendCondition(cond)
[10:22:49.142]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.142]                   {
[10:22:49.142]                     inherits <- base::inherits
[10:22:49.142]                     invokeRestart <- base::invokeRestart
[10:22:49.142]                     is.null <- base::is.null
[10:22:49.142]                     muffled <- FALSE
[10:22:49.142]                     if (inherits(cond, "message")) {
[10:22:49.142]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:49.142]                       if (muffled) 
[10:22:49.142]                         invokeRestart("muffleMessage")
[10:22:49.142]                     }
[10:22:49.142]                     else if (inherits(cond, "warning")) {
[10:22:49.142]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:49.142]                       if (muffled) 
[10:22:49.142]                         invokeRestart("muffleWarning")
[10:22:49.142]                     }
[10:22:49.142]                     else if (inherits(cond, "condition")) {
[10:22:49.142]                       if (!is.null(pattern)) {
[10:22:49.142]                         computeRestarts <- base::computeRestarts
[10:22:49.142]                         grepl <- base::grepl
[10:22:49.142]                         restarts <- computeRestarts(cond)
[10:22:49.142]                         for (restart in restarts) {
[10:22:49.142]                           name <- restart$name
[10:22:49.142]                           if (is.null(name)) 
[10:22:49.142]                             next
[10:22:49.142]                           if (!grepl(pattern, name)) 
[10:22:49.142]                             next
[10:22:49.142]                           invokeRestart(restart)
[10:22:49.142]                           muffled <- TRUE
[10:22:49.142]                           break
[10:22:49.142]                         }
[10:22:49.142]                       }
[10:22:49.142]                     }
[10:22:49.142]                     invisible(muffled)
[10:22:49.142]                   }
[10:22:49.142]                   muffleCondition(cond)
[10:22:49.142]                 })
[10:22:49.142]             }))
[10:22:49.142]             future::FutureResult(value = ...future.value$value, 
[10:22:49.142]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.142]                   ...future.rng), globalenv = if (FALSE) 
[10:22:49.142]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:49.142]                     ...future.globalenv.names))
[10:22:49.142]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:49.142]         }, condition = base::local({
[10:22:49.142]             c <- base::c
[10:22:49.142]             inherits <- base::inherits
[10:22:49.142]             invokeRestart <- base::invokeRestart
[10:22:49.142]             length <- base::length
[10:22:49.142]             list <- base::list
[10:22:49.142]             seq.int <- base::seq.int
[10:22:49.142]             signalCondition <- base::signalCondition
[10:22:49.142]             sys.calls <- base::sys.calls
[10:22:49.142]             `[[` <- base::`[[`
[10:22:49.142]             `+` <- base::`+`
[10:22:49.142]             `<<-` <- base::`<<-`
[10:22:49.142]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:49.142]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:49.142]                   3L)]
[10:22:49.142]             }
[10:22:49.142]             function(cond) {
[10:22:49.142]                 is_error <- inherits(cond, "error")
[10:22:49.142]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:49.142]                   NULL)
[10:22:49.142]                 if (is_error) {
[10:22:49.142]                   sessionInformation <- function() {
[10:22:49.142]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:49.142]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:49.142]                       search = base::search(), system = base::Sys.info())
[10:22:49.142]                   }
[10:22:49.142]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.142]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:49.142]                     cond$call), session = sessionInformation(), 
[10:22:49.142]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:49.142]                   signalCondition(cond)
[10:22:49.142]                 }
[10:22:49.142]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:49.142]                 "immediateCondition"))) {
[10:22:49.142]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:49.142]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.142]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:49.142]                   if (TRUE && !signal) {
[10:22:49.142]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.142]                     {
[10:22:49.142]                       inherits <- base::inherits
[10:22:49.142]                       invokeRestart <- base::invokeRestart
[10:22:49.142]                       is.null <- base::is.null
[10:22:49.142]                       muffled <- FALSE
[10:22:49.142]                       if (inherits(cond, "message")) {
[10:22:49.142]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.142]                         if (muffled) 
[10:22:49.142]                           invokeRestart("muffleMessage")
[10:22:49.142]                       }
[10:22:49.142]                       else if (inherits(cond, "warning")) {
[10:22:49.142]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.142]                         if (muffled) 
[10:22:49.142]                           invokeRestart("muffleWarning")
[10:22:49.142]                       }
[10:22:49.142]                       else if (inherits(cond, "condition")) {
[10:22:49.142]                         if (!is.null(pattern)) {
[10:22:49.142]                           computeRestarts <- base::computeRestarts
[10:22:49.142]                           grepl <- base::grepl
[10:22:49.142]                           restarts <- computeRestarts(cond)
[10:22:49.142]                           for (restart in restarts) {
[10:22:49.142]                             name <- restart$name
[10:22:49.142]                             if (is.null(name)) 
[10:22:49.142]                               next
[10:22:49.142]                             if (!grepl(pattern, name)) 
[10:22:49.142]                               next
[10:22:49.142]                             invokeRestart(restart)
[10:22:49.142]                             muffled <- TRUE
[10:22:49.142]                             break
[10:22:49.142]                           }
[10:22:49.142]                         }
[10:22:49.142]                       }
[10:22:49.142]                       invisible(muffled)
[10:22:49.142]                     }
[10:22:49.142]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.142]                   }
[10:22:49.142]                 }
[10:22:49.142]                 else {
[10:22:49.142]                   if (TRUE) {
[10:22:49.142]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.142]                     {
[10:22:49.142]                       inherits <- base::inherits
[10:22:49.142]                       invokeRestart <- base::invokeRestart
[10:22:49.142]                       is.null <- base::is.null
[10:22:49.142]                       muffled <- FALSE
[10:22:49.142]                       if (inherits(cond, "message")) {
[10:22:49.142]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.142]                         if (muffled) 
[10:22:49.142]                           invokeRestart("muffleMessage")
[10:22:49.142]                       }
[10:22:49.142]                       else if (inherits(cond, "warning")) {
[10:22:49.142]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.142]                         if (muffled) 
[10:22:49.142]                           invokeRestart("muffleWarning")
[10:22:49.142]                       }
[10:22:49.142]                       else if (inherits(cond, "condition")) {
[10:22:49.142]                         if (!is.null(pattern)) {
[10:22:49.142]                           computeRestarts <- base::computeRestarts
[10:22:49.142]                           grepl <- base::grepl
[10:22:49.142]                           restarts <- computeRestarts(cond)
[10:22:49.142]                           for (restart in restarts) {
[10:22:49.142]                             name <- restart$name
[10:22:49.142]                             if (is.null(name)) 
[10:22:49.142]                               next
[10:22:49.142]                             if (!grepl(pattern, name)) 
[10:22:49.142]                               next
[10:22:49.142]                             invokeRestart(restart)
[10:22:49.142]                             muffled <- TRUE
[10:22:49.142]                             break
[10:22:49.142]                           }
[10:22:49.142]                         }
[10:22:49.142]                       }
[10:22:49.142]                       invisible(muffled)
[10:22:49.142]                     }
[10:22:49.142]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.142]                   }
[10:22:49.142]                 }
[10:22:49.142]             }
[10:22:49.142]         }))
[10:22:49.142]     }, error = function(ex) {
[10:22:49.142]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:49.142]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.142]                 ...future.rng), started = ...future.startTime, 
[10:22:49.142]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:49.142]             version = "1.8"), class = "FutureResult")
[10:22:49.142]     }, finally = {
[10:22:49.142]         if (!identical(...future.workdir, getwd())) 
[10:22:49.142]             setwd(...future.workdir)
[10:22:49.142]         {
[10:22:49.142]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:49.142]                 ...future.oldOptions$nwarnings <- NULL
[10:22:49.142]             }
[10:22:49.142]             base::options(...future.oldOptions)
[10:22:49.142]             if (.Platform$OS.type == "windows") {
[10:22:49.142]                 old_names <- names(...future.oldEnvVars)
[10:22:49.142]                 envs <- base::Sys.getenv()
[10:22:49.142]                 names <- names(envs)
[10:22:49.142]                 common <- intersect(names, old_names)
[10:22:49.142]                 added <- setdiff(names, old_names)
[10:22:49.142]                 removed <- setdiff(old_names, names)
[10:22:49.142]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:49.142]                   envs[common]]
[10:22:49.142]                 NAMES <- toupper(changed)
[10:22:49.142]                 args <- list()
[10:22:49.142]                 for (kk in seq_along(NAMES)) {
[10:22:49.142]                   name <- changed[[kk]]
[10:22:49.142]                   NAME <- NAMES[[kk]]
[10:22:49.142]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.142]                     next
[10:22:49.142]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.142]                 }
[10:22:49.142]                 NAMES <- toupper(added)
[10:22:49.142]                 for (kk in seq_along(NAMES)) {
[10:22:49.142]                   name <- added[[kk]]
[10:22:49.142]                   NAME <- NAMES[[kk]]
[10:22:49.142]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.142]                     next
[10:22:49.142]                   args[[name]] <- ""
[10:22:49.142]                 }
[10:22:49.142]                 NAMES <- toupper(removed)
[10:22:49.142]                 for (kk in seq_along(NAMES)) {
[10:22:49.142]                   name <- removed[[kk]]
[10:22:49.142]                   NAME <- NAMES[[kk]]
[10:22:49.142]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.142]                     next
[10:22:49.142]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.142]                 }
[10:22:49.142]                 if (length(args) > 0) 
[10:22:49.142]                   base::do.call(base::Sys.setenv, args = args)
[10:22:49.142]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:49.142]             }
[10:22:49.142]             else {
[10:22:49.142]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:49.142]             }
[10:22:49.142]             {
[10:22:49.142]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:49.142]                   0L) {
[10:22:49.142]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:49.142]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:49.142]                   base::options(opts)
[10:22:49.142]                 }
[10:22:49.142]                 {
[10:22:49.142]                   {
[10:22:49.142]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:49.142]                     NULL
[10:22:49.142]                   }
[10:22:49.142]                   options(future.plan = NULL)
[10:22:49.142]                   if (is.na(NA_character_)) 
[10:22:49.142]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.142]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:49.142]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:49.142]                     .init = FALSE)
[10:22:49.142]                 }
[10:22:49.142]             }
[10:22:49.142]         }
[10:22:49.142]     })
[10:22:49.142]     if (TRUE) {
[10:22:49.142]         base::sink(type = "output", split = FALSE)
[10:22:49.142]         if (TRUE) {
[10:22:49.142]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:49.142]         }
[10:22:49.142]         else {
[10:22:49.142]             ...future.result["stdout"] <- base::list(NULL)
[10:22:49.142]         }
[10:22:49.142]         base::close(...future.stdout)
[10:22:49.142]         ...future.stdout <- NULL
[10:22:49.142]     }
[10:22:49.142]     ...future.result$conditions <- ...future.conditions
[10:22:49.142]     ...future.result$finished <- base::Sys.time()
[10:22:49.142]     ...future.result
[10:22:49.142] }
[10:22:49.144] Poll #1 (0): usedNodes() = 2, workers = 2
[10:22:49.175] Poll #2 (0.03 secs): usedNodes() = 2, workers = 2
[10:22:49.207] Poll #3 (0.06 secs): usedNodes() = 2, workers = 2
[10:22:49.239] Poll #4 (0.09 secs): usedNodes() = 2, workers = 2
[10:22:49.250] receiveMessageFromWorker() for ClusterFuture ...
[10:22:49.250] - Validating connection of MultisessionFuture
[10:22:49.250] - received message: FutureResult
[10:22:49.250] - Received FutureResult
[10:22:49.250] - Erased future from FutureRegistry
[10:22:49.250] result() for ClusterFuture ...
[10:22:49.250] - result already collected: FutureResult
[10:22:49.251] result() for ClusterFuture ... done
[10:22:49.251] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:49.251] result() for ClusterFuture ...
[10:22:49.251] - result already collected: FutureResult
[10:22:49.251] result() for ClusterFuture ... done
[10:22:49.251] result() for ClusterFuture ...
[10:22:49.251] - result already collected: FutureResult
[10:22:49.251] result() for ClusterFuture ... done
[10:22:49.252] Exporting 1 global objects (344 bytes) to cluster node #1 ...
[10:22:49.252] Exporting ‘kk’ (35 bytes) to cluster node #1 ...
[10:22:49.252] Exporting ‘kk’ (35 bytes) to cluster node #1 ... DONE
[10:22:49.252] Exporting 1 global objects (344 bytes) to cluster node #1 ... DONE
[10:22:49.253] MultisessionFuture started
[10:22:49.253] - Launch lazy future ... done
[10:22:49.253] run() for ‘MultisessionFuture’ ... done
[10:22:49.253] resolve() on list ...
[10:22:49.253]  recursive: 0
[10:22:49.254]  length: 3
[10:22:49.254] 
[10:22:49.254] Future #1
[10:22:49.254]  length: 2 (resolved future 1)
[10:22:49.286] receiveMessageFromWorker() for ClusterFuture ...
[10:22:49.286] - Validating connection of MultisessionFuture
[10:22:49.286] - received message: FutureResult
[10:22:49.286] - Received FutureResult
[10:22:49.286] - Erased future from FutureRegistry
[10:22:49.286] result() for ClusterFuture ...
[10:22:49.286] - result already collected: FutureResult
[10:22:49.287] result() for ClusterFuture ... done
[10:22:49.287] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:49.287] Future #2
[10:22:49.287]  length: 1 (resolved future 2)
[10:22:49.395] receiveMessageFromWorker() for ClusterFuture ...
[10:22:49.395] - Validating connection of MultisessionFuture
[10:22:49.396] - received message: FutureResult
[10:22:49.396] - Received FutureResult
[10:22:49.396] - Erased future from FutureRegistry
[10:22:49.396] result() for ClusterFuture ...
[10:22:49.396] - result already collected: FutureResult
[10:22:49.396] result() for ClusterFuture ... done
[10:22:49.396] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:49.396] Future #3
[10:22:49.396]  length: 0 (resolved future 3)
[10:22:49.397] resolve() on list ... DONE
[10:22:49.397] getGlobalsAndPackages() ...
[10:22:49.397] Searching for globals...
[10:22:49.398] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:22:49.398] Searching for globals ... DONE
[10:22:49.398] Resolving globals: FALSE
[10:22:49.398] The total size of the 1 globals is 35 bytes (35 bytes)
[10:22:49.399] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[10:22:49.399] - globals: [1] ‘kk’
[10:22:49.399] 
[10:22:49.399] getGlobalsAndPackages() ... DONE
[10:22:49.399] getGlobalsAndPackages() ...
[10:22:49.399] Searching for globals...
[10:22:49.400] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:22:49.400] Searching for globals ... DONE
[10:22:49.401] Resolving globals: FALSE
[10:22:49.401] The total size of the 1 globals is 35 bytes (35 bytes)
[10:22:49.401] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[10:22:49.401] - globals: [1] ‘kk’
[10:22:49.401] 
[10:22:49.402] getGlobalsAndPackages() ... DONE
[10:22:49.402] getGlobalsAndPackages() ...
[10:22:49.402] Searching for globals...
[10:22:49.403] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[10:22:49.403] Searching for globals ... DONE
[10:22:49.403] Resolving globals: FALSE
[10:22:49.403] The total size of the 1 globals is 35 bytes (35 bytes)
[10:22:49.404] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[10:22:49.404] - globals: [1] ‘kk’
[10:22:49.404] 
[10:22:49.404] getGlobalsAndPackages() ... DONE
[10:22:49.404] resolve() on list ...
[10:22:49.404]  recursive: 0
[10:22:49.404]  length: 3
[10:22:49.404] 
[10:22:49.404] run() for ‘Future’ ...
[10:22:49.405] - state: ‘created’
[10:22:49.405] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:49.419] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:49.419] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:49.419]   - Field: ‘node’
[10:22:49.419]   - Field: ‘label’
[10:22:49.419]   - Field: ‘local’
[10:22:49.419]   - Field: ‘owner’
[10:22:49.419]   - Field: ‘envir’
[10:22:49.419]   - Field: ‘workers’
[10:22:49.420]   - Field: ‘packages’
[10:22:49.420]   - Field: ‘gc’
[10:22:49.420]   - Field: ‘conditions’
[10:22:49.420]   - Field: ‘persistent’
[10:22:49.420]   - Field: ‘expr’
[10:22:49.420]   - Field: ‘uuid’
[10:22:49.420]   - Field: ‘seed’
[10:22:49.420]   - Field: ‘version’
[10:22:49.420]   - Field: ‘result’
[10:22:49.420]   - Field: ‘asynchronous’
[10:22:49.420]   - Field: ‘calls’
[10:22:49.420]   - Field: ‘globals’
[10:22:49.421]   - Field: ‘stdout’
[10:22:49.421]   - Field: ‘earlySignal’
[10:22:49.421]   - Field: ‘lazy’
[10:22:49.421]   - Field: ‘state’
[10:22:49.421] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:49.421] - Launch lazy future ...
[10:22:49.421] Packages needed by the future expression (n = 0): <none>
[10:22:49.421] Packages needed by future strategies (n = 0): <none>
[10:22:49.422] {
[10:22:49.422]     {
[10:22:49.422]         {
[10:22:49.422]             ...future.startTime <- base::Sys.time()
[10:22:49.422]             {
[10:22:49.422]                 {
[10:22:49.422]                   {
[10:22:49.422]                     {
[10:22:49.422]                       base::local({
[10:22:49.422]                         has_future <- base::requireNamespace("future", 
[10:22:49.422]                           quietly = TRUE)
[10:22:49.422]                         if (has_future) {
[10:22:49.422]                           ns <- base::getNamespace("future")
[10:22:49.422]                           version <- ns[[".package"]][["version"]]
[10:22:49.422]                           if (is.null(version)) 
[10:22:49.422]                             version <- utils::packageVersion("future")
[10:22:49.422]                         }
[10:22:49.422]                         else {
[10:22:49.422]                           version <- NULL
[10:22:49.422]                         }
[10:22:49.422]                         if (!has_future || version < "1.8.0") {
[10:22:49.422]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:49.422]                             "", base::R.version$version.string), 
[10:22:49.422]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:49.422]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:49.422]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:49.422]                               "release", "version")], collapse = " "), 
[10:22:49.422]                             hostname = base::Sys.info()[["nodename"]])
[10:22:49.422]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:49.422]                             info)
[10:22:49.422]                           info <- base::paste(info, collapse = "; ")
[10:22:49.422]                           if (!has_future) {
[10:22:49.422]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:49.422]                               info)
[10:22:49.422]                           }
[10:22:49.422]                           else {
[10:22:49.422]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:49.422]                               info, version)
[10:22:49.422]                           }
[10:22:49.422]                           base::stop(msg)
[10:22:49.422]                         }
[10:22:49.422]                       })
[10:22:49.422]                     }
[10:22:49.422]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:49.422]                     base::options(mc.cores = 1L)
[10:22:49.422]                   }
[10:22:49.422]                   ...future.strategy.old <- future::plan("list")
[10:22:49.422]                   options(future.plan = NULL)
[10:22:49.422]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.422]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:49.422]                 }
[10:22:49.422]                 ...future.workdir <- getwd()
[10:22:49.422]             }
[10:22:49.422]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:49.422]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:49.422]         }
[10:22:49.422]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:49.422]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:49.422]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:49.422]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:49.422]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:49.422]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:49.422]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:49.422]             base::names(...future.oldOptions))
[10:22:49.422]     }
[10:22:49.422]     if (FALSE) {
[10:22:49.422]     }
[10:22:49.422]     else {
[10:22:49.422]         if (TRUE) {
[10:22:49.422]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:49.422]                 open = "w")
[10:22:49.422]         }
[10:22:49.422]         else {
[10:22:49.422]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:49.422]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:49.422]         }
[10:22:49.422]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:49.422]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:49.422]             base::sink(type = "output", split = FALSE)
[10:22:49.422]             base::close(...future.stdout)
[10:22:49.422]         }, add = TRUE)
[10:22:49.422]     }
[10:22:49.422]     ...future.frame <- base::sys.nframe()
[10:22:49.422]     ...future.conditions <- base::list()
[10:22:49.422]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:49.422]     if (FALSE) {
[10:22:49.422]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:49.422]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:49.422]     }
[10:22:49.422]     ...future.result <- base::tryCatch({
[10:22:49.422]         base::withCallingHandlers({
[10:22:49.422]             ...future.value <- base::withVisible(base::local({
[10:22:49.422]                 ...future.makeSendCondition <- base::local({
[10:22:49.422]                   sendCondition <- NULL
[10:22:49.422]                   function(frame = 1L) {
[10:22:49.422]                     if (is.function(sendCondition)) 
[10:22:49.422]                       return(sendCondition)
[10:22:49.422]                     ns <- getNamespace("parallel")
[10:22:49.422]                     if (exists("sendData", mode = "function", 
[10:22:49.422]                       envir = ns)) {
[10:22:49.422]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:49.422]                         envir = ns)
[10:22:49.422]                       envir <- sys.frame(frame)
[10:22:49.422]                       master <- NULL
[10:22:49.422]                       while (!identical(envir, .GlobalEnv) && 
[10:22:49.422]                         !identical(envir, emptyenv())) {
[10:22:49.422]                         if (exists("master", mode = "list", envir = envir, 
[10:22:49.422]                           inherits = FALSE)) {
[10:22:49.422]                           master <- get("master", mode = "list", 
[10:22:49.422]                             envir = envir, inherits = FALSE)
[10:22:49.422]                           if (inherits(master, c("SOCKnode", 
[10:22:49.422]                             "SOCK0node"))) {
[10:22:49.422]                             sendCondition <<- function(cond) {
[10:22:49.422]                               data <- list(type = "VALUE", value = cond, 
[10:22:49.422]                                 success = TRUE)
[10:22:49.422]                               parallel_sendData(master, data)
[10:22:49.422]                             }
[10:22:49.422]                             return(sendCondition)
[10:22:49.422]                           }
[10:22:49.422]                         }
[10:22:49.422]                         frame <- frame + 1L
[10:22:49.422]                         envir <- sys.frame(frame)
[10:22:49.422]                       }
[10:22:49.422]                     }
[10:22:49.422]                     sendCondition <<- function(cond) NULL
[10:22:49.422]                   }
[10:22:49.422]                 })
[10:22:49.422]                 withCallingHandlers({
[10:22:49.422]                   {
[10:22:49.422]                     Sys.sleep(0.1)
[10:22:49.422]                     kk
[10:22:49.422]                   }
[10:22:49.422]                 }, immediateCondition = function(cond) {
[10:22:49.422]                   sendCondition <- ...future.makeSendCondition()
[10:22:49.422]                   sendCondition(cond)
[10:22:49.422]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.422]                   {
[10:22:49.422]                     inherits <- base::inherits
[10:22:49.422]                     invokeRestart <- base::invokeRestart
[10:22:49.422]                     is.null <- base::is.null
[10:22:49.422]                     muffled <- FALSE
[10:22:49.422]                     if (inherits(cond, "message")) {
[10:22:49.422]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:49.422]                       if (muffled) 
[10:22:49.422]                         invokeRestart("muffleMessage")
[10:22:49.422]                     }
[10:22:49.422]                     else if (inherits(cond, "warning")) {
[10:22:49.422]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:49.422]                       if (muffled) 
[10:22:49.422]                         invokeRestart("muffleWarning")
[10:22:49.422]                     }
[10:22:49.422]                     else if (inherits(cond, "condition")) {
[10:22:49.422]                       if (!is.null(pattern)) {
[10:22:49.422]                         computeRestarts <- base::computeRestarts
[10:22:49.422]                         grepl <- base::grepl
[10:22:49.422]                         restarts <- computeRestarts(cond)
[10:22:49.422]                         for (restart in restarts) {
[10:22:49.422]                           name <- restart$name
[10:22:49.422]                           if (is.null(name)) 
[10:22:49.422]                             next
[10:22:49.422]                           if (!grepl(pattern, name)) 
[10:22:49.422]                             next
[10:22:49.422]                           invokeRestart(restart)
[10:22:49.422]                           muffled <- TRUE
[10:22:49.422]                           break
[10:22:49.422]                         }
[10:22:49.422]                       }
[10:22:49.422]                     }
[10:22:49.422]                     invisible(muffled)
[10:22:49.422]                   }
[10:22:49.422]                   muffleCondition(cond)
[10:22:49.422]                 })
[10:22:49.422]             }))
[10:22:49.422]             future::FutureResult(value = ...future.value$value, 
[10:22:49.422]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.422]                   ...future.rng), globalenv = if (FALSE) 
[10:22:49.422]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:49.422]                     ...future.globalenv.names))
[10:22:49.422]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:49.422]         }, condition = base::local({
[10:22:49.422]             c <- base::c
[10:22:49.422]             inherits <- base::inherits
[10:22:49.422]             invokeRestart <- base::invokeRestart
[10:22:49.422]             length <- base::length
[10:22:49.422]             list <- base::list
[10:22:49.422]             seq.int <- base::seq.int
[10:22:49.422]             signalCondition <- base::signalCondition
[10:22:49.422]             sys.calls <- base::sys.calls
[10:22:49.422]             `[[` <- base::`[[`
[10:22:49.422]             `+` <- base::`+`
[10:22:49.422]             `<<-` <- base::`<<-`
[10:22:49.422]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:49.422]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:49.422]                   3L)]
[10:22:49.422]             }
[10:22:49.422]             function(cond) {
[10:22:49.422]                 is_error <- inherits(cond, "error")
[10:22:49.422]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:49.422]                   NULL)
[10:22:49.422]                 if (is_error) {
[10:22:49.422]                   sessionInformation <- function() {
[10:22:49.422]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:49.422]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:49.422]                       search = base::search(), system = base::Sys.info())
[10:22:49.422]                   }
[10:22:49.422]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.422]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:49.422]                     cond$call), session = sessionInformation(), 
[10:22:49.422]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:49.422]                   signalCondition(cond)
[10:22:49.422]                 }
[10:22:49.422]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:49.422]                 "immediateCondition"))) {
[10:22:49.422]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:49.422]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.422]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:49.422]                   if (TRUE && !signal) {
[10:22:49.422]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.422]                     {
[10:22:49.422]                       inherits <- base::inherits
[10:22:49.422]                       invokeRestart <- base::invokeRestart
[10:22:49.422]                       is.null <- base::is.null
[10:22:49.422]                       muffled <- FALSE
[10:22:49.422]                       if (inherits(cond, "message")) {
[10:22:49.422]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.422]                         if (muffled) 
[10:22:49.422]                           invokeRestart("muffleMessage")
[10:22:49.422]                       }
[10:22:49.422]                       else if (inherits(cond, "warning")) {
[10:22:49.422]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.422]                         if (muffled) 
[10:22:49.422]                           invokeRestart("muffleWarning")
[10:22:49.422]                       }
[10:22:49.422]                       else if (inherits(cond, "condition")) {
[10:22:49.422]                         if (!is.null(pattern)) {
[10:22:49.422]                           computeRestarts <- base::computeRestarts
[10:22:49.422]                           grepl <- base::grepl
[10:22:49.422]                           restarts <- computeRestarts(cond)
[10:22:49.422]                           for (restart in restarts) {
[10:22:49.422]                             name <- restart$name
[10:22:49.422]                             if (is.null(name)) 
[10:22:49.422]                               next
[10:22:49.422]                             if (!grepl(pattern, name)) 
[10:22:49.422]                               next
[10:22:49.422]                             invokeRestart(restart)
[10:22:49.422]                             muffled <- TRUE
[10:22:49.422]                             break
[10:22:49.422]                           }
[10:22:49.422]                         }
[10:22:49.422]                       }
[10:22:49.422]                       invisible(muffled)
[10:22:49.422]                     }
[10:22:49.422]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.422]                   }
[10:22:49.422]                 }
[10:22:49.422]                 else {
[10:22:49.422]                   if (TRUE) {
[10:22:49.422]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.422]                     {
[10:22:49.422]                       inherits <- base::inherits
[10:22:49.422]                       invokeRestart <- base::invokeRestart
[10:22:49.422]                       is.null <- base::is.null
[10:22:49.422]                       muffled <- FALSE
[10:22:49.422]                       if (inherits(cond, "message")) {
[10:22:49.422]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.422]                         if (muffled) 
[10:22:49.422]                           invokeRestart("muffleMessage")
[10:22:49.422]                       }
[10:22:49.422]                       else if (inherits(cond, "warning")) {
[10:22:49.422]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.422]                         if (muffled) 
[10:22:49.422]                           invokeRestart("muffleWarning")
[10:22:49.422]                       }
[10:22:49.422]                       else if (inherits(cond, "condition")) {
[10:22:49.422]                         if (!is.null(pattern)) {
[10:22:49.422]                           computeRestarts <- base::computeRestarts
[10:22:49.422]                           grepl <- base::grepl
[10:22:49.422]                           restarts <- computeRestarts(cond)
[10:22:49.422]                           for (restart in restarts) {
[10:22:49.422]                             name <- restart$name
[10:22:49.422]                             if (is.null(name)) 
[10:22:49.422]                               next
[10:22:49.422]                             if (!grepl(pattern, name)) 
[10:22:49.422]                               next
[10:22:49.422]                             invokeRestart(restart)
[10:22:49.422]                             muffled <- TRUE
[10:22:49.422]                             break
[10:22:49.422]                           }
[10:22:49.422]                         }
[10:22:49.422]                       }
[10:22:49.422]                       invisible(muffled)
[10:22:49.422]                     }
[10:22:49.422]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.422]                   }
[10:22:49.422]                 }
[10:22:49.422]             }
[10:22:49.422]         }))
[10:22:49.422]     }, error = function(ex) {
[10:22:49.422]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:49.422]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.422]                 ...future.rng), started = ...future.startTime, 
[10:22:49.422]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:49.422]             version = "1.8"), class = "FutureResult")
[10:22:49.422]     }, finally = {
[10:22:49.422]         if (!identical(...future.workdir, getwd())) 
[10:22:49.422]             setwd(...future.workdir)
[10:22:49.422]         {
[10:22:49.422]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:49.422]                 ...future.oldOptions$nwarnings <- NULL
[10:22:49.422]             }
[10:22:49.422]             base::options(...future.oldOptions)
[10:22:49.422]             if (.Platform$OS.type == "windows") {
[10:22:49.422]                 old_names <- names(...future.oldEnvVars)
[10:22:49.422]                 envs <- base::Sys.getenv()
[10:22:49.422]                 names <- names(envs)
[10:22:49.422]                 common <- intersect(names, old_names)
[10:22:49.422]                 added <- setdiff(names, old_names)
[10:22:49.422]                 removed <- setdiff(old_names, names)
[10:22:49.422]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:49.422]                   envs[common]]
[10:22:49.422]                 NAMES <- toupper(changed)
[10:22:49.422]                 args <- list()
[10:22:49.422]                 for (kk in seq_along(NAMES)) {
[10:22:49.422]                   name <- changed[[kk]]
[10:22:49.422]                   NAME <- NAMES[[kk]]
[10:22:49.422]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.422]                     next
[10:22:49.422]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.422]                 }
[10:22:49.422]                 NAMES <- toupper(added)
[10:22:49.422]                 for (kk in seq_along(NAMES)) {
[10:22:49.422]                   name <- added[[kk]]
[10:22:49.422]                   NAME <- NAMES[[kk]]
[10:22:49.422]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.422]                     next
[10:22:49.422]                   args[[name]] <- ""
[10:22:49.422]                 }
[10:22:49.422]                 NAMES <- toupper(removed)
[10:22:49.422]                 for (kk in seq_along(NAMES)) {
[10:22:49.422]                   name <- removed[[kk]]
[10:22:49.422]                   NAME <- NAMES[[kk]]
[10:22:49.422]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.422]                     next
[10:22:49.422]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.422]                 }
[10:22:49.422]                 if (length(args) > 0) 
[10:22:49.422]                   base::do.call(base::Sys.setenv, args = args)
[10:22:49.422]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:49.422]             }
[10:22:49.422]             else {
[10:22:49.422]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:49.422]             }
[10:22:49.422]             {
[10:22:49.422]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:49.422]                   0L) {
[10:22:49.422]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:49.422]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:49.422]                   base::options(opts)
[10:22:49.422]                 }
[10:22:49.422]                 {
[10:22:49.422]                   {
[10:22:49.422]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:49.422]                     NULL
[10:22:49.422]                   }
[10:22:49.422]                   options(future.plan = NULL)
[10:22:49.422]                   if (is.na(NA_character_)) 
[10:22:49.422]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.422]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:49.422]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:49.422]                     .init = FALSE)
[10:22:49.422]                 }
[10:22:49.422]             }
[10:22:49.422]         }
[10:22:49.422]     })
[10:22:49.422]     if (TRUE) {
[10:22:49.422]         base::sink(type = "output", split = FALSE)
[10:22:49.422]         if (TRUE) {
[10:22:49.422]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:49.422]         }
[10:22:49.422]         else {
[10:22:49.422]             ...future.result["stdout"] <- base::list(NULL)
[10:22:49.422]         }
[10:22:49.422]         base::close(...future.stdout)
[10:22:49.422]         ...future.stdout <- NULL
[10:22:49.422]     }
[10:22:49.422]     ...future.result$conditions <- ...future.conditions
[10:22:49.422]     ...future.result$finished <- base::Sys.time()
[10:22:49.422]     ...future.result
[10:22:49.422] }
[10:22:49.424] Exporting 1 global objects (344 bytes) to cluster node #1 ...
[10:22:49.425] Exporting ‘kk’ (35 bytes) to cluster node #1 ...
[10:22:49.425] Exporting ‘kk’ (35 bytes) to cluster node #1 ... DONE
[10:22:49.425] Exporting 1 global objects (344 bytes) to cluster node #1 ... DONE
[10:22:49.426] MultisessionFuture started
[10:22:49.426] - Launch lazy future ... done
[10:22:49.426] run() for ‘MultisessionFuture’ ... done
[10:22:49.436] run() for ‘Future’ ...
[10:22:49.436] - state: ‘created’
[10:22:49.437] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:49.450] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:49.450] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:49.450]   - Field: ‘node’
[10:22:49.450]   - Field: ‘label’
[10:22:49.451]   - Field: ‘local’
[10:22:49.451]   - Field: ‘owner’
[10:22:49.451]   - Field: ‘envir’
[10:22:49.451]   - Field: ‘workers’
[10:22:49.451]   - Field: ‘packages’
[10:22:49.451]   - Field: ‘gc’
[10:22:49.451]   - Field: ‘conditions’
[10:22:49.451]   - Field: ‘persistent’
[10:22:49.451]   - Field: ‘expr’
[10:22:49.451]   - Field: ‘uuid’
[10:22:49.451]   - Field: ‘seed’
[10:22:49.452]   - Field: ‘version’
[10:22:49.452]   - Field: ‘result’
[10:22:49.452]   - Field: ‘asynchronous’
[10:22:49.452]   - Field: ‘calls’
[10:22:49.452]   - Field: ‘globals’
[10:22:49.452]   - Field: ‘stdout’
[10:22:49.452]   - Field: ‘earlySignal’
[10:22:49.452]   - Field: ‘lazy’
[10:22:49.452]   - Field: ‘state’
[10:22:49.452] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:49.452] - Launch lazy future ...
[10:22:49.453] Packages needed by the future expression (n = 0): <none>
[10:22:49.453] Packages needed by future strategies (n = 0): <none>
[10:22:49.453] {
[10:22:49.453]     {
[10:22:49.453]         {
[10:22:49.453]             ...future.startTime <- base::Sys.time()
[10:22:49.453]             {
[10:22:49.453]                 {
[10:22:49.453]                   {
[10:22:49.453]                     {
[10:22:49.453]                       base::local({
[10:22:49.453]                         has_future <- base::requireNamespace("future", 
[10:22:49.453]                           quietly = TRUE)
[10:22:49.453]                         if (has_future) {
[10:22:49.453]                           ns <- base::getNamespace("future")
[10:22:49.453]                           version <- ns[[".package"]][["version"]]
[10:22:49.453]                           if (is.null(version)) 
[10:22:49.453]                             version <- utils::packageVersion("future")
[10:22:49.453]                         }
[10:22:49.453]                         else {
[10:22:49.453]                           version <- NULL
[10:22:49.453]                         }
[10:22:49.453]                         if (!has_future || version < "1.8.0") {
[10:22:49.453]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:49.453]                             "", base::R.version$version.string), 
[10:22:49.453]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:49.453]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:49.453]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:49.453]                               "release", "version")], collapse = " "), 
[10:22:49.453]                             hostname = base::Sys.info()[["nodename"]])
[10:22:49.453]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:49.453]                             info)
[10:22:49.453]                           info <- base::paste(info, collapse = "; ")
[10:22:49.453]                           if (!has_future) {
[10:22:49.453]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:49.453]                               info)
[10:22:49.453]                           }
[10:22:49.453]                           else {
[10:22:49.453]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:49.453]                               info, version)
[10:22:49.453]                           }
[10:22:49.453]                           base::stop(msg)
[10:22:49.453]                         }
[10:22:49.453]                       })
[10:22:49.453]                     }
[10:22:49.453]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:49.453]                     base::options(mc.cores = 1L)
[10:22:49.453]                   }
[10:22:49.453]                   ...future.strategy.old <- future::plan("list")
[10:22:49.453]                   options(future.plan = NULL)
[10:22:49.453]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.453]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:49.453]                 }
[10:22:49.453]                 ...future.workdir <- getwd()
[10:22:49.453]             }
[10:22:49.453]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:49.453]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:49.453]         }
[10:22:49.453]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:49.453]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:49.453]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:49.453]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:49.453]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:49.453]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:49.453]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:49.453]             base::names(...future.oldOptions))
[10:22:49.453]     }
[10:22:49.453]     if (FALSE) {
[10:22:49.453]     }
[10:22:49.453]     else {
[10:22:49.453]         if (TRUE) {
[10:22:49.453]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:49.453]                 open = "w")
[10:22:49.453]         }
[10:22:49.453]         else {
[10:22:49.453]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:49.453]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:49.453]         }
[10:22:49.453]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:49.453]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:49.453]             base::sink(type = "output", split = FALSE)
[10:22:49.453]             base::close(...future.stdout)
[10:22:49.453]         }, add = TRUE)
[10:22:49.453]     }
[10:22:49.453]     ...future.frame <- base::sys.nframe()
[10:22:49.453]     ...future.conditions <- base::list()
[10:22:49.453]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:49.453]     if (FALSE) {
[10:22:49.453]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:49.453]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:49.453]     }
[10:22:49.453]     ...future.result <- base::tryCatch({
[10:22:49.453]         base::withCallingHandlers({
[10:22:49.453]             ...future.value <- base::withVisible(base::local({
[10:22:49.453]                 ...future.makeSendCondition <- base::local({
[10:22:49.453]                   sendCondition <- NULL
[10:22:49.453]                   function(frame = 1L) {
[10:22:49.453]                     if (is.function(sendCondition)) 
[10:22:49.453]                       return(sendCondition)
[10:22:49.453]                     ns <- getNamespace("parallel")
[10:22:49.453]                     if (exists("sendData", mode = "function", 
[10:22:49.453]                       envir = ns)) {
[10:22:49.453]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:49.453]                         envir = ns)
[10:22:49.453]                       envir <- sys.frame(frame)
[10:22:49.453]                       master <- NULL
[10:22:49.453]                       while (!identical(envir, .GlobalEnv) && 
[10:22:49.453]                         !identical(envir, emptyenv())) {
[10:22:49.453]                         if (exists("master", mode = "list", envir = envir, 
[10:22:49.453]                           inherits = FALSE)) {
[10:22:49.453]                           master <- get("master", mode = "list", 
[10:22:49.453]                             envir = envir, inherits = FALSE)
[10:22:49.453]                           if (inherits(master, c("SOCKnode", 
[10:22:49.453]                             "SOCK0node"))) {
[10:22:49.453]                             sendCondition <<- function(cond) {
[10:22:49.453]                               data <- list(type = "VALUE", value = cond, 
[10:22:49.453]                                 success = TRUE)
[10:22:49.453]                               parallel_sendData(master, data)
[10:22:49.453]                             }
[10:22:49.453]                             return(sendCondition)
[10:22:49.453]                           }
[10:22:49.453]                         }
[10:22:49.453]                         frame <- frame + 1L
[10:22:49.453]                         envir <- sys.frame(frame)
[10:22:49.453]                       }
[10:22:49.453]                     }
[10:22:49.453]                     sendCondition <<- function(cond) NULL
[10:22:49.453]                   }
[10:22:49.453]                 })
[10:22:49.453]                 withCallingHandlers({
[10:22:49.453]                   {
[10:22:49.453]                     Sys.sleep(0.1)
[10:22:49.453]                     kk
[10:22:49.453]                   }
[10:22:49.453]                 }, immediateCondition = function(cond) {
[10:22:49.453]                   sendCondition <- ...future.makeSendCondition()
[10:22:49.453]                   sendCondition(cond)
[10:22:49.453]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.453]                   {
[10:22:49.453]                     inherits <- base::inherits
[10:22:49.453]                     invokeRestart <- base::invokeRestart
[10:22:49.453]                     is.null <- base::is.null
[10:22:49.453]                     muffled <- FALSE
[10:22:49.453]                     if (inherits(cond, "message")) {
[10:22:49.453]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:49.453]                       if (muffled) 
[10:22:49.453]                         invokeRestart("muffleMessage")
[10:22:49.453]                     }
[10:22:49.453]                     else if (inherits(cond, "warning")) {
[10:22:49.453]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:49.453]                       if (muffled) 
[10:22:49.453]                         invokeRestart("muffleWarning")
[10:22:49.453]                     }
[10:22:49.453]                     else if (inherits(cond, "condition")) {
[10:22:49.453]                       if (!is.null(pattern)) {
[10:22:49.453]                         computeRestarts <- base::computeRestarts
[10:22:49.453]                         grepl <- base::grepl
[10:22:49.453]                         restarts <- computeRestarts(cond)
[10:22:49.453]                         for (restart in restarts) {
[10:22:49.453]                           name <- restart$name
[10:22:49.453]                           if (is.null(name)) 
[10:22:49.453]                             next
[10:22:49.453]                           if (!grepl(pattern, name)) 
[10:22:49.453]                             next
[10:22:49.453]                           invokeRestart(restart)
[10:22:49.453]                           muffled <- TRUE
[10:22:49.453]                           break
[10:22:49.453]                         }
[10:22:49.453]                       }
[10:22:49.453]                     }
[10:22:49.453]                     invisible(muffled)
[10:22:49.453]                   }
[10:22:49.453]                   muffleCondition(cond)
[10:22:49.453]                 })
[10:22:49.453]             }))
[10:22:49.453]             future::FutureResult(value = ...future.value$value, 
[10:22:49.453]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.453]                   ...future.rng), globalenv = if (FALSE) 
[10:22:49.453]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:49.453]                     ...future.globalenv.names))
[10:22:49.453]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:49.453]         }, condition = base::local({
[10:22:49.453]             c <- base::c
[10:22:49.453]             inherits <- base::inherits
[10:22:49.453]             invokeRestart <- base::invokeRestart
[10:22:49.453]             length <- base::length
[10:22:49.453]             list <- base::list
[10:22:49.453]             seq.int <- base::seq.int
[10:22:49.453]             signalCondition <- base::signalCondition
[10:22:49.453]             sys.calls <- base::sys.calls
[10:22:49.453]             `[[` <- base::`[[`
[10:22:49.453]             `+` <- base::`+`
[10:22:49.453]             `<<-` <- base::`<<-`
[10:22:49.453]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:49.453]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:49.453]                   3L)]
[10:22:49.453]             }
[10:22:49.453]             function(cond) {
[10:22:49.453]                 is_error <- inherits(cond, "error")
[10:22:49.453]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:49.453]                   NULL)
[10:22:49.453]                 if (is_error) {
[10:22:49.453]                   sessionInformation <- function() {
[10:22:49.453]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:49.453]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:49.453]                       search = base::search(), system = base::Sys.info())
[10:22:49.453]                   }
[10:22:49.453]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.453]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:49.453]                     cond$call), session = sessionInformation(), 
[10:22:49.453]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:49.453]                   signalCondition(cond)
[10:22:49.453]                 }
[10:22:49.453]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:49.453]                 "immediateCondition"))) {
[10:22:49.453]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:49.453]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.453]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:49.453]                   if (TRUE && !signal) {
[10:22:49.453]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.453]                     {
[10:22:49.453]                       inherits <- base::inherits
[10:22:49.453]                       invokeRestart <- base::invokeRestart
[10:22:49.453]                       is.null <- base::is.null
[10:22:49.453]                       muffled <- FALSE
[10:22:49.453]                       if (inherits(cond, "message")) {
[10:22:49.453]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.453]                         if (muffled) 
[10:22:49.453]                           invokeRestart("muffleMessage")
[10:22:49.453]                       }
[10:22:49.453]                       else if (inherits(cond, "warning")) {
[10:22:49.453]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.453]                         if (muffled) 
[10:22:49.453]                           invokeRestart("muffleWarning")
[10:22:49.453]                       }
[10:22:49.453]                       else if (inherits(cond, "condition")) {
[10:22:49.453]                         if (!is.null(pattern)) {
[10:22:49.453]                           computeRestarts <- base::computeRestarts
[10:22:49.453]                           grepl <- base::grepl
[10:22:49.453]                           restarts <- computeRestarts(cond)
[10:22:49.453]                           for (restart in restarts) {
[10:22:49.453]                             name <- restart$name
[10:22:49.453]                             if (is.null(name)) 
[10:22:49.453]                               next
[10:22:49.453]                             if (!grepl(pattern, name)) 
[10:22:49.453]                               next
[10:22:49.453]                             invokeRestart(restart)
[10:22:49.453]                             muffled <- TRUE
[10:22:49.453]                             break
[10:22:49.453]                           }
[10:22:49.453]                         }
[10:22:49.453]                       }
[10:22:49.453]                       invisible(muffled)
[10:22:49.453]                     }
[10:22:49.453]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.453]                   }
[10:22:49.453]                 }
[10:22:49.453]                 else {
[10:22:49.453]                   if (TRUE) {
[10:22:49.453]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.453]                     {
[10:22:49.453]                       inherits <- base::inherits
[10:22:49.453]                       invokeRestart <- base::invokeRestart
[10:22:49.453]                       is.null <- base::is.null
[10:22:49.453]                       muffled <- FALSE
[10:22:49.453]                       if (inherits(cond, "message")) {
[10:22:49.453]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.453]                         if (muffled) 
[10:22:49.453]                           invokeRestart("muffleMessage")
[10:22:49.453]                       }
[10:22:49.453]                       else if (inherits(cond, "warning")) {
[10:22:49.453]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.453]                         if (muffled) 
[10:22:49.453]                           invokeRestart("muffleWarning")
[10:22:49.453]                       }
[10:22:49.453]                       else if (inherits(cond, "condition")) {
[10:22:49.453]                         if (!is.null(pattern)) {
[10:22:49.453]                           computeRestarts <- base::computeRestarts
[10:22:49.453]                           grepl <- base::grepl
[10:22:49.453]                           restarts <- computeRestarts(cond)
[10:22:49.453]                           for (restart in restarts) {
[10:22:49.453]                             name <- restart$name
[10:22:49.453]                             if (is.null(name)) 
[10:22:49.453]                               next
[10:22:49.453]                             if (!grepl(pattern, name)) 
[10:22:49.453]                               next
[10:22:49.453]                             invokeRestart(restart)
[10:22:49.453]                             muffled <- TRUE
[10:22:49.453]                             break
[10:22:49.453]                           }
[10:22:49.453]                         }
[10:22:49.453]                       }
[10:22:49.453]                       invisible(muffled)
[10:22:49.453]                     }
[10:22:49.453]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.453]                   }
[10:22:49.453]                 }
[10:22:49.453]             }
[10:22:49.453]         }))
[10:22:49.453]     }, error = function(ex) {
[10:22:49.453]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:49.453]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.453]                 ...future.rng), started = ...future.startTime, 
[10:22:49.453]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:49.453]             version = "1.8"), class = "FutureResult")
[10:22:49.453]     }, finally = {
[10:22:49.453]         if (!identical(...future.workdir, getwd())) 
[10:22:49.453]             setwd(...future.workdir)
[10:22:49.453]         {
[10:22:49.453]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:49.453]                 ...future.oldOptions$nwarnings <- NULL
[10:22:49.453]             }
[10:22:49.453]             base::options(...future.oldOptions)
[10:22:49.453]             if (.Platform$OS.type == "windows") {
[10:22:49.453]                 old_names <- names(...future.oldEnvVars)
[10:22:49.453]                 envs <- base::Sys.getenv()
[10:22:49.453]                 names <- names(envs)
[10:22:49.453]                 common <- intersect(names, old_names)
[10:22:49.453]                 added <- setdiff(names, old_names)
[10:22:49.453]                 removed <- setdiff(old_names, names)
[10:22:49.453]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:49.453]                   envs[common]]
[10:22:49.453]                 NAMES <- toupper(changed)
[10:22:49.453]                 args <- list()
[10:22:49.453]                 for (kk in seq_along(NAMES)) {
[10:22:49.453]                   name <- changed[[kk]]
[10:22:49.453]                   NAME <- NAMES[[kk]]
[10:22:49.453]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.453]                     next
[10:22:49.453]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.453]                 }
[10:22:49.453]                 NAMES <- toupper(added)
[10:22:49.453]                 for (kk in seq_along(NAMES)) {
[10:22:49.453]                   name <- added[[kk]]
[10:22:49.453]                   NAME <- NAMES[[kk]]
[10:22:49.453]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.453]                     next
[10:22:49.453]                   args[[name]] <- ""
[10:22:49.453]                 }
[10:22:49.453]                 NAMES <- toupper(removed)
[10:22:49.453]                 for (kk in seq_along(NAMES)) {
[10:22:49.453]                   name <- removed[[kk]]
[10:22:49.453]                   NAME <- NAMES[[kk]]
[10:22:49.453]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.453]                     next
[10:22:49.453]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.453]                 }
[10:22:49.453]                 if (length(args) > 0) 
[10:22:49.453]                   base::do.call(base::Sys.setenv, args = args)
[10:22:49.453]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:49.453]             }
[10:22:49.453]             else {
[10:22:49.453]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:49.453]             }
[10:22:49.453]             {
[10:22:49.453]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:49.453]                   0L) {
[10:22:49.453]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:49.453]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:49.453]                   base::options(opts)
[10:22:49.453]                 }
[10:22:49.453]                 {
[10:22:49.453]                   {
[10:22:49.453]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:49.453]                     NULL
[10:22:49.453]                   }
[10:22:49.453]                   options(future.plan = NULL)
[10:22:49.453]                   if (is.na(NA_character_)) 
[10:22:49.453]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.453]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:49.453]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:49.453]                     .init = FALSE)
[10:22:49.453]                 }
[10:22:49.453]             }
[10:22:49.453]         }
[10:22:49.453]     })
[10:22:49.453]     if (TRUE) {
[10:22:49.453]         base::sink(type = "output", split = FALSE)
[10:22:49.453]         if (TRUE) {
[10:22:49.453]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:49.453]         }
[10:22:49.453]         else {
[10:22:49.453]             ...future.result["stdout"] <- base::list(NULL)
[10:22:49.453]         }
[10:22:49.453]         base::close(...future.stdout)
[10:22:49.453]         ...future.stdout <- NULL
[10:22:49.453]     }
[10:22:49.453]     ...future.result$conditions <- ...future.conditions
[10:22:49.453]     ...future.result$finished <- base::Sys.time()
[10:22:49.453]     ...future.result
[10:22:49.453] }
[10:22:49.456] Exporting 1 global objects (344 bytes) to cluster node #2 ...
[10:22:49.456] Exporting ‘kk’ (35 bytes) to cluster node #2 ...
[10:22:49.456] Exporting ‘kk’ (35 bytes) to cluster node #2 ... DONE
[10:22:49.456] Exporting 1 global objects (344 bytes) to cluster node #2 ... DONE
[10:22:49.457] MultisessionFuture started
[10:22:49.457] - Launch lazy future ... done
[10:22:49.457] run() for ‘MultisessionFuture’ ... done
[10:22:49.468] run() for ‘Future’ ...
[10:22:49.468] - state: ‘created’
[10:22:49.468] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:49.482] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:49.482] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:49.482]   - Field: ‘node’
[10:22:49.482]   - Field: ‘label’
[10:22:49.482]   - Field: ‘local’
[10:22:49.482]   - Field: ‘owner’
[10:22:49.482]   - Field: ‘envir’
[10:22:49.482]   - Field: ‘workers’
[10:22:49.482]   - Field: ‘packages’
[10:22:49.483]   - Field: ‘gc’
[10:22:49.483]   - Field: ‘conditions’
[10:22:49.483]   - Field: ‘persistent’
[10:22:49.483]   - Field: ‘expr’
[10:22:49.483]   - Field: ‘uuid’
[10:22:49.483]   - Field: ‘seed’
[10:22:49.483]   - Field: ‘version’
[10:22:49.483]   - Field: ‘result’
[10:22:49.483]   - Field: ‘asynchronous’
[10:22:49.483]   - Field: ‘calls’
[10:22:49.483]   - Field: ‘globals’
[10:22:49.483]   - Field: ‘stdout’
[10:22:49.484]   - Field: ‘earlySignal’
[10:22:49.484]   - Field: ‘lazy’
[10:22:49.484]   - Field: ‘state’
[10:22:49.484] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:49.484] - Launch lazy future ...
[10:22:49.484] Packages needed by the future expression (n = 0): <none>
[10:22:49.484] Packages needed by future strategies (n = 0): <none>
[10:22:49.485] {
[10:22:49.485]     {
[10:22:49.485]         {
[10:22:49.485]             ...future.startTime <- base::Sys.time()
[10:22:49.485]             {
[10:22:49.485]                 {
[10:22:49.485]                   {
[10:22:49.485]                     {
[10:22:49.485]                       base::local({
[10:22:49.485]                         has_future <- base::requireNamespace("future", 
[10:22:49.485]                           quietly = TRUE)
[10:22:49.485]                         if (has_future) {
[10:22:49.485]                           ns <- base::getNamespace("future")
[10:22:49.485]                           version <- ns[[".package"]][["version"]]
[10:22:49.485]                           if (is.null(version)) 
[10:22:49.485]                             version <- utils::packageVersion("future")
[10:22:49.485]                         }
[10:22:49.485]                         else {
[10:22:49.485]                           version <- NULL
[10:22:49.485]                         }
[10:22:49.485]                         if (!has_future || version < "1.8.0") {
[10:22:49.485]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:49.485]                             "", base::R.version$version.string), 
[10:22:49.485]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:49.485]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:49.485]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:49.485]                               "release", "version")], collapse = " "), 
[10:22:49.485]                             hostname = base::Sys.info()[["nodename"]])
[10:22:49.485]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:49.485]                             info)
[10:22:49.485]                           info <- base::paste(info, collapse = "; ")
[10:22:49.485]                           if (!has_future) {
[10:22:49.485]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:49.485]                               info)
[10:22:49.485]                           }
[10:22:49.485]                           else {
[10:22:49.485]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:49.485]                               info, version)
[10:22:49.485]                           }
[10:22:49.485]                           base::stop(msg)
[10:22:49.485]                         }
[10:22:49.485]                       })
[10:22:49.485]                     }
[10:22:49.485]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:49.485]                     base::options(mc.cores = 1L)
[10:22:49.485]                   }
[10:22:49.485]                   ...future.strategy.old <- future::plan("list")
[10:22:49.485]                   options(future.plan = NULL)
[10:22:49.485]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.485]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:49.485]                 }
[10:22:49.485]                 ...future.workdir <- getwd()
[10:22:49.485]             }
[10:22:49.485]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:49.485]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:49.485]         }
[10:22:49.485]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:49.485]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:49.485]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:49.485]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:49.485]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:49.485]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:49.485]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:49.485]             base::names(...future.oldOptions))
[10:22:49.485]     }
[10:22:49.485]     if (FALSE) {
[10:22:49.485]     }
[10:22:49.485]     else {
[10:22:49.485]         if (TRUE) {
[10:22:49.485]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:49.485]                 open = "w")
[10:22:49.485]         }
[10:22:49.485]         else {
[10:22:49.485]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:49.485]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:49.485]         }
[10:22:49.485]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:49.485]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:49.485]             base::sink(type = "output", split = FALSE)
[10:22:49.485]             base::close(...future.stdout)
[10:22:49.485]         }, add = TRUE)
[10:22:49.485]     }
[10:22:49.485]     ...future.frame <- base::sys.nframe()
[10:22:49.485]     ...future.conditions <- base::list()
[10:22:49.485]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:49.485]     if (FALSE) {
[10:22:49.485]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:49.485]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:49.485]     }
[10:22:49.485]     ...future.result <- base::tryCatch({
[10:22:49.485]         base::withCallingHandlers({
[10:22:49.485]             ...future.value <- base::withVisible(base::local({
[10:22:49.485]                 ...future.makeSendCondition <- base::local({
[10:22:49.485]                   sendCondition <- NULL
[10:22:49.485]                   function(frame = 1L) {
[10:22:49.485]                     if (is.function(sendCondition)) 
[10:22:49.485]                       return(sendCondition)
[10:22:49.485]                     ns <- getNamespace("parallel")
[10:22:49.485]                     if (exists("sendData", mode = "function", 
[10:22:49.485]                       envir = ns)) {
[10:22:49.485]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:49.485]                         envir = ns)
[10:22:49.485]                       envir <- sys.frame(frame)
[10:22:49.485]                       master <- NULL
[10:22:49.485]                       while (!identical(envir, .GlobalEnv) && 
[10:22:49.485]                         !identical(envir, emptyenv())) {
[10:22:49.485]                         if (exists("master", mode = "list", envir = envir, 
[10:22:49.485]                           inherits = FALSE)) {
[10:22:49.485]                           master <- get("master", mode = "list", 
[10:22:49.485]                             envir = envir, inherits = FALSE)
[10:22:49.485]                           if (inherits(master, c("SOCKnode", 
[10:22:49.485]                             "SOCK0node"))) {
[10:22:49.485]                             sendCondition <<- function(cond) {
[10:22:49.485]                               data <- list(type = "VALUE", value = cond, 
[10:22:49.485]                                 success = TRUE)
[10:22:49.485]                               parallel_sendData(master, data)
[10:22:49.485]                             }
[10:22:49.485]                             return(sendCondition)
[10:22:49.485]                           }
[10:22:49.485]                         }
[10:22:49.485]                         frame <- frame + 1L
[10:22:49.485]                         envir <- sys.frame(frame)
[10:22:49.485]                       }
[10:22:49.485]                     }
[10:22:49.485]                     sendCondition <<- function(cond) NULL
[10:22:49.485]                   }
[10:22:49.485]                 })
[10:22:49.485]                 withCallingHandlers({
[10:22:49.485]                   {
[10:22:49.485]                     Sys.sleep(0.1)
[10:22:49.485]                     kk
[10:22:49.485]                   }
[10:22:49.485]                 }, immediateCondition = function(cond) {
[10:22:49.485]                   sendCondition <- ...future.makeSendCondition()
[10:22:49.485]                   sendCondition(cond)
[10:22:49.485]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.485]                   {
[10:22:49.485]                     inherits <- base::inherits
[10:22:49.485]                     invokeRestart <- base::invokeRestart
[10:22:49.485]                     is.null <- base::is.null
[10:22:49.485]                     muffled <- FALSE
[10:22:49.485]                     if (inherits(cond, "message")) {
[10:22:49.485]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:49.485]                       if (muffled) 
[10:22:49.485]                         invokeRestart("muffleMessage")
[10:22:49.485]                     }
[10:22:49.485]                     else if (inherits(cond, "warning")) {
[10:22:49.485]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:49.485]                       if (muffled) 
[10:22:49.485]                         invokeRestart("muffleWarning")
[10:22:49.485]                     }
[10:22:49.485]                     else if (inherits(cond, "condition")) {
[10:22:49.485]                       if (!is.null(pattern)) {
[10:22:49.485]                         computeRestarts <- base::computeRestarts
[10:22:49.485]                         grepl <- base::grepl
[10:22:49.485]                         restarts <- computeRestarts(cond)
[10:22:49.485]                         for (restart in restarts) {
[10:22:49.485]                           name <- restart$name
[10:22:49.485]                           if (is.null(name)) 
[10:22:49.485]                             next
[10:22:49.485]                           if (!grepl(pattern, name)) 
[10:22:49.485]                             next
[10:22:49.485]                           invokeRestart(restart)
[10:22:49.485]                           muffled <- TRUE
[10:22:49.485]                           break
[10:22:49.485]                         }
[10:22:49.485]                       }
[10:22:49.485]                     }
[10:22:49.485]                     invisible(muffled)
[10:22:49.485]                   }
[10:22:49.485]                   muffleCondition(cond)
[10:22:49.485]                 })
[10:22:49.485]             }))
[10:22:49.485]             future::FutureResult(value = ...future.value$value, 
[10:22:49.485]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.485]                   ...future.rng), globalenv = if (FALSE) 
[10:22:49.485]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:49.485]                     ...future.globalenv.names))
[10:22:49.485]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:49.485]         }, condition = base::local({
[10:22:49.485]             c <- base::c
[10:22:49.485]             inherits <- base::inherits
[10:22:49.485]             invokeRestart <- base::invokeRestart
[10:22:49.485]             length <- base::length
[10:22:49.485]             list <- base::list
[10:22:49.485]             seq.int <- base::seq.int
[10:22:49.485]             signalCondition <- base::signalCondition
[10:22:49.485]             sys.calls <- base::sys.calls
[10:22:49.485]             `[[` <- base::`[[`
[10:22:49.485]             `+` <- base::`+`
[10:22:49.485]             `<<-` <- base::`<<-`
[10:22:49.485]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:49.485]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:49.485]                   3L)]
[10:22:49.485]             }
[10:22:49.485]             function(cond) {
[10:22:49.485]                 is_error <- inherits(cond, "error")
[10:22:49.485]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:49.485]                   NULL)
[10:22:49.485]                 if (is_error) {
[10:22:49.485]                   sessionInformation <- function() {
[10:22:49.485]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:49.485]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:49.485]                       search = base::search(), system = base::Sys.info())
[10:22:49.485]                   }
[10:22:49.485]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.485]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:49.485]                     cond$call), session = sessionInformation(), 
[10:22:49.485]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:49.485]                   signalCondition(cond)
[10:22:49.485]                 }
[10:22:49.485]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:49.485]                 "immediateCondition"))) {
[10:22:49.485]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:49.485]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.485]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:49.485]                   if (TRUE && !signal) {
[10:22:49.485]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.485]                     {
[10:22:49.485]                       inherits <- base::inherits
[10:22:49.485]                       invokeRestart <- base::invokeRestart
[10:22:49.485]                       is.null <- base::is.null
[10:22:49.485]                       muffled <- FALSE
[10:22:49.485]                       if (inherits(cond, "message")) {
[10:22:49.485]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.485]                         if (muffled) 
[10:22:49.485]                           invokeRestart("muffleMessage")
[10:22:49.485]                       }
[10:22:49.485]                       else if (inherits(cond, "warning")) {
[10:22:49.485]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.485]                         if (muffled) 
[10:22:49.485]                           invokeRestart("muffleWarning")
[10:22:49.485]                       }
[10:22:49.485]                       else if (inherits(cond, "condition")) {
[10:22:49.485]                         if (!is.null(pattern)) {
[10:22:49.485]                           computeRestarts <- base::computeRestarts
[10:22:49.485]                           grepl <- base::grepl
[10:22:49.485]                           restarts <- computeRestarts(cond)
[10:22:49.485]                           for (restart in restarts) {
[10:22:49.485]                             name <- restart$name
[10:22:49.485]                             if (is.null(name)) 
[10:22:49.485]                               next
[10:22:49.485]                             if (!grepl(pattern, name)) 
[10:22:49.485]                               next
[10:22:49.485]                             invokeRestart(restart)
[10:22:49.485]                             muffled <- TRUE
[10:22:49.485]                             break
[10:22:49.485]                           }
[10:22:49.485]                         }
[10:22:49.485]                       }
[10:22:49.485]                       invisible(muffled)
[10:22:49.485]                     }
[10:22:49.485]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.485]                   }
[10:22:49.485]                 }
[10:22:49.485]                 else {
[10:22:49.485]                   if (TRUE) {
[10:22:49.485]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.485]                     {
[10:22:49.485]                       inherits <- base::inherits
[10:22:49.485]                       invokeRestart <- base::invokeRestart
[10:22:49.485]                       is.null <- base::is.null
[10:22:49.485]                       muffled <- FALSE
[10:22:49.485]                       if (inherits(cond, "message")) {
[10:22:49.485]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.485]                         if (muffled) 
[10:22:49.485]                           invokeRestart("muffleMessage")
[10:22:49.485]                       }
[10:22:49.485]                       else if (inherits(cond, "warning")) {
[10:22:49.485]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.485]                         if (muffled) 
[10:22:49.485]                           invokeRestart("muffleWarning")
[10:22:49.485]                       }
[10:22:49.485]                       else if (inherits(cond, "condition")) {
[10:22:49.485]                         if (!is.null(pattern)) {
[10:22:49.485]                           computeRestarts <- base::computeRestarts
[10:22:49.485]                           grepl <- base::grepl
[10:22:49.485]                           restarts <- computeRestarts(cond)
[10:22:49.485]                           for (restart in restarts) {
[10:22:49.485]                             name <- restart$name
[10:22:49.485]                             if (is.null(name)) 
[10:22:49.485]                               next
[10:22:49.485]                             if (!grepl(pattern, name)) 
[10:22:49.485]                               next
[10:22:49.485]                             invokeRestart(restart)
[10:22:49.485]                             muffled <- TRUE
[10:22:49.485]                             break
[10:22:49.485]                           }
[10:22:49.485]                         }
[10:22:49.485]                       }
[10:22:49.485]                       invisible(muffled)
[10:22:49.485]                     }
[10:22:49.485]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.485]                   }
[10:22:49.485]                 }
[10:22:49.485]             }
[10:22:49.485]         }))
[10:22:49.485]     }, error = function(ex) {
[10:22:49.485]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:49.485]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.485]                 ...future.rng), started = ...future.startTime, 
[10:22:49.485]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:49.485]             version = "1.8"), class = "FutureResult")
[10:22:49.485]     }, finally = {
[10:22:49.485]         if (!identical(...future.workdir, getwd())) 
[10:22:49.485]             setwd(...future.workdir)
[10:22:49.485]         {
[10:22:49.485]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:49.485]                 ...future.oldOptions$nwarnings <- NULL
[10:22:49.485]             }
[10:22:49.485]             base::options(...future.oldOptions)
[10:22:49.485]             if (.Platform$OS.type == "windows") {
[10:22:49.485]                 old_names <- names(...future.oldEnvVars)
[10:22:49.485]                 envs <- base::Sys.getenv()
[10:22:49.485]                 names <- names(envs)
[10:22:49.485]                 common <- intersect(names, old_names)
[10:22:49.485]                 added <- setdiff(names, old_names)
[10:22:49.485]                 removed <- setdiff(old_names, names)
[10:22:49.485]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:49.485]                   envs[common]]
[10:22:49.485]                 NAMES <- toupper(changed)
[10:22:49.485]                 args <- list()
[10:22:49.485]                 for (kk in seq_along(NAMES)) {
[10:22:49.485]                   name <- changed[[kk]]
[10:22:49.485]                   NAME <- NAMES[[kk]]
[10:22:49.485]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.485]                     next
[10:22:49.485]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.485]                 }
[10:22:49.485]                 NAMES <- toupper(added)
[10:22:49.485]                 for (kk in seq_along(NAMES)) {
[10:22:49.485]                   name <- added[[kk]]
[10:22:49.485]                   NAME <- NAMES[[kk]]
[10:22:49.485]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.485]                     next
[10:22:49.485]                   args[[name]] <- ""
[10:22:49.485]                 }
[10:22:49.485]                 NAMES <- toupper(removed)
[10:22:49.485]                 for (kk in seq_along(NAMES)) {
[10:22:49.485]                   name <- removed[[kk]]
[10:22:49.485]                   NAME <- NAMES[[kk]]
[10:22:49.485]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.485]                     next
[10:22:49.485]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.485]                 }
[10:22:49.485]                 if (length(args) > 0) 
[10:22:49.485]                   base::do.call(base::Sys.setenv, args = args)
[10:22:49.485]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:49.485]             }
[10:22:49.485]             else {
[10:22:49.485]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:49.485]             }
[10:22:49.485]             {
[10:22:49.485]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:49.485]                   0L) {
[10:22:49.485]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:49.485]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:49.485]                   base::options(opts)
[10:22:49.485]                 }
[10:22:49.485]                 {
[10:22:49.485]                   {
[10:22:49.485]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:49.485]                     NULL
[10:22:49.485]                   }
[10:22:49.485]                   options(future.plan = NULL)
[10:22:49.485]                   if (is.na(NA_character_)) 
[10:22:49.485]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.485]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:49.485]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:49.485]                     .init = FALSE)
[10:22:49.485]                 }
[10:22:49.485]             }
[10:22:49.485]         }
[10:22:49.485]     })
[10:22:49.485]     if (TRUE) {
[10:22:49.485]         base::sink(type = "output", split = FALSE)
[10:22:49.485]         if (TRUE) {
[10:22:49.485]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:49.485]         }
[10:22:49.485]         else {
[10:22:49.485]             ...future.result["stdout"] <- base::list(NULL)
[10:22:49.485]         }
[10:22:49.485]         base::close(...future.stdout)
[10:22:49.485]         ...future.stdout <- NULL
[10:22:49.485]     }
[10:22:49.485]     ...future.result$conditions <- ...future.conditions
[10:22:49.485]     ...future.result$finished <- base::Sys.time()
[10:22:49.485]     ...future.result
[10:22:49.485] }
[10:22:49.487] Poll #1 (0): usedNodes() = 2, workers = 2
[10:22:49.518] Poll #2 (0.03 secs): usedNodes() = 2, workers = 2
[10:22:49.550] Poll #3 (0.06 secs): usedNodes() = 2, workers = 2
[10:22:49.568] receiveMessageFromWorker() for ClusterFuture ...
[10:22:49.568] - Validating connection of MultisessionFuture
[10:22:49.569] - received message: FutureResult
[10:22:49.569] - Received FutureResult
[10:22:49.569] - Erased future from FutureRegistry
[10:22:49.569] result() for ClusterFuture ...
[10:22:49.569] - result already collected: FutureResult
[10:22:49.569] result() for ClusterFuture ... done
[10:22:49.569] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:49.569] result() for ClusterFuture ...
[10:22:49.569] - result already collected: FutureResult
[10:22:49.569] result() for ClusterFuture ... done
[10:22:49.570] result() for ClusterFuture ...
[10:22:49.570] - result already collected: FutureResult
[10:22:49.570] result() for ClusterFuture ... done
[10:22:49.570] Exporting 1 global objects (344 bytes) to cluster node #1 ...
[10:22:49.571] Exporting ‘kk’ (35 bytes) to cluster node #1 ...
[10:22:49.571] Exporting ‘kk’ (35 bytes) to cluster node #1 ... DONE
[10:22:49.571] Exporting 1 global objects (344 bytes) to cluster node #1 ... DONE
[10:22:49.572] MultisessionFuture started
[10:22:49.572] - Launch lazy future ... done
[10:22:49.572] run() for ‘MultisessionFuture’ ... done
[10:22:49.592] Future #1
[10:22:49.593]  length: 2 (resolved future 1)
[10:22:49.599] receiveMessageFromWorker() for ClusterFuture ...
[10:22:49.600] - Validating connection of MultisessionFuture
[10:22:49.600] - received message: FutureResult
[10:22:49.600] - Received FutureResult
[10:22:49.600] - Erased future from FutureRegistry
[10:22:49.600] result() for ClusterFuture ...
[10:22:49.600] - result already collected: FutureResult
[10:22:49.600] result() for ClusterFuture ... done
[10:22:49.600] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:49.601] Future #2
[10:22:49.601]  length: 1 (resolved future 2)
[10:22:49.714] receiveMessageFromWorker() for ClusterFuture ...
[10:22:49.714] - Validating connection of MultisessionFuture
[10:22:49.717] - received message: FutureResult
[10:22:49.718] - Received FutureResult
[10:22:49.718] - Erased future from FutureRegistry
[10:22:49.718] result() for ClusterFuture ...
[10:22:49.718] - result already collected: FutureResult
[10:22:49.718] result() for ClusterFuture ... done
[10:22:49.718] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:49.718] Future #3
[10:22:49.718]  length: 0 (resolved future 3)
[10:22:49.718] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[10:22:49.719] resolve() on environment ...
[10:22:49.719]  recursive: 0
[10:22:49.720]  elements: [2] ‘a’, ‘b’
[10:22:49.720]  length: 1 (resolved future 1)
[10:22:49.720]  length: 0 (resolved future 2)
[10:22:49.720] resolve() on environment ... DONE
[10:22:49.720] getGlobalsAndPackages() ...
[10:22:49.720] Searching for globals...
[10:22:49.721] 
[10:22:49.721] Searching for globals ... DONE
[10:22:49.721] - globals: [0] <none>
[10:22:49.721] getGlobalsAndPackages() ... DONE
[10:22:49.721] run() for ‘Future’ ...
[10:22:49.721] - state: ‘created’
[10:22:49.721] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:49.736] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:49.736] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:49.736]   - Field: ‘node’
[10:22:49.736]   - Field: ‘label’
[10:22:49.736]   - Field: ‘local’
[10:22:49.736]   - Field: ‘owner’
[10:22:49.736]   - Field: ‘envir’
[10:22:49.736]   - Field: ‘workers’
[10:22:49.737]   - Field: ‘packages’
[10:22:49.737]   - Field: ‘gc’
[10:22:49.737]   - Field: ‘conditions’
[10:22:49.737]   - Field: ‘persistent’
[10:22:49.737]   - Field: ‘expr’
[10:22:49.737]   - Field: ‘uuid’
[10:22:49.737]   - Field: ‘seed’
[10:22:49.737]   - Field: ‘version’
[10:22:49.737]   - Field: ‘result’
[10:22:49.737]   - Field: ‘asynchronous’
[10:22:49.737]   - Field: ‘calls’
[10:22:49.737]   - Field: ‘globals’
[10:22:49.738]   - Field: ‘stdout’
[10:22:49.738]   - Field: ‘earlySignal’
[10:22:49.738]   - Field: ‘lazy’
[10:22:49.738]   - Field: ‘state’
[10:22:49.738] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:49.738] - Launch lazy future ...
[10:22:49.738] Packages needed by the future expression (n = 0): <none>
[10:22:49.738] Packages needed by future strategies (n = 0): <none>
[10:22:49.739] {
[10:22:49.739]     {
[10:22:49.739]         {
[10:22:49.739]             ...future.startTime <- base::Sys.time()
[10:22:49.739]             {
[10:22:49.739]                 {
[10:22:49.739]                   {
[10:22:49.739]                     {
[10:22:49.739]                       base::local({
[10:22:49.739]                         has_future <- base::requireNamespace("future", 
[10:22:49.739]                           quietly = TRUE)
[10:22:49.739]                         if (has_future) {
[10:22:49.739]                           ns <- base::getNamespace("future")
[10:22:49.739]                           version <- ns[[".package"]][["version"]]
[10:22:49.739]                           if (is.null(version)) 
[10:22:49.739]                             version <- utils::packageVersion("future")
[10:22:49.739]                         }
[10:22:49.739]                         else {
[10:22:49.739]                           version <- NULL
[10:22:49.739]                         }
[10:22:49.739]                         if (!has_future || version < "1.8.0") {
[10:22:49.739]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:49.739]                             "", base::R.version$version.string), 
[10:22:49.739]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:49.739]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:49.739]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:49.739]                               "release", "version")], collapse = " "), 
[10:22:49.739]                             hostname = base::Sys.info()[["nodename"]])
[10:22:49.739]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:49.739]                             info)
[10:22:49.739]                           info <- base::paste(info, collapse = "; ")
[10:22:49.739]                           if (!has_future) {
[10:22:49.739]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:49.739]                               info)
[10:22:49.739]                           }
[10:22:49.739]                           else {
[10:22:49.739]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:49.739]                               info, version)
[10:22:49.739]                           }
[10:22:49.739]                           base::stop(msg)
[10:22:49.739]                         }
[10:22:49.739]                       })
[10:22:49.739]                     }
[10:22:49.739]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:49.739]                     base::options(mc.cores = 1L)
[10:22:49.739]                   }
[10:22:49.739]                   ...future.strategy.old <- future::plan("list")
[10:22:49.739]                   options(future.plan = NULL)
[10:22:49.739]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.739]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:49.739]                 }
[10:22:49.739]                 ...future.workdir <- getwd()
[10:22:49.739]             }
[10:22:49.739]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:49.739]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:49.739]         }
[10:22:49.739]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:49.739]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:49.739]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:49.739]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:49.739]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:49.739]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:49.739]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:49.739]             base::names(...future.oldOptions))
[10:22:49.739]     }
[10:22:49.739]     if (FALSE) {
[10:22:49.739]     }
[10:22:49.739]     else {
[10:22:49.739]         if (TRUE) {
[10:22:49.739]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:49.739]                 open = "w")
[10:22:49.739]         }
[10:22:49.739]         else {
[10:22:49.739]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:49.739]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:49.739]         }
[10:22:49.739]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:49.739]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:49.739]             base::sink(type = "output", split = FALSE)
[10:22:49.739]             base::close(...future.stdout)
[10:22:49.739]         }, add = TRUE)
[10:22:49.739]     }
[10:22:49.739]     ...future.frame <- base::sys.nframe()
[10:22:49.739]     ...future.conditions <- base::list()
[10:22:49.739]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:49.739]     if (FALSE) {
[10:22:49.739]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:49.739]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:49.739]     }
[10:22:49.739]     ...future.result <- base::tryCatch({
[10:22:49.739]         base::withCallingHandlers({
[10:22:49.739]             ...future.value <- base::withVisible(base::local({
[10:22:49.739]                 ...future.makeSendCondition <- base::local({
[10:22:49.739]                   sendCondition <- NULL
[10:22:49.739]                   function(frame = 1L) {
[10:22:49.739]                     if (is.function(sendCondition)) 
[10:22:49.739]                       return(sendCondition)
[10:22:49.739]                     ns <- getNamespace("parallel")
[10:22:49.739]                     if (exists("sendData", mode = "function", 
[10:22:49.739]                       envir = ns)) {
[10:22:49.739]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:49.739]                         envir = ns)
[10:22:49.739]                       envir <- sys.frame(frame)
[10:22:49.739]                       master <- NULL
[10:22:49.739]                       while (!identical(envir, .GlobalEnv) && 
[10:22:49.739]                         !identical(envir, emptyenv())) {
[10:22:49.739]                         if (exists("master", mode = "list", envir = envir, 
[10:22:49.739]                           inherits = FALSE)) {
[10:22:49.739]                           master <- get("master", mode = "list", 
[10:22:49.739]                             envir = envir, inherits = FALSE)
[10:22:49.739]                           if (inherits(master, c("SOCKnode", 
[10:22:49.739]                             "SOCK0node"))) {
[10:22:49.739]                             sendCondition <<- function(cond) {
[10:22:49.739]                               data <- list(type = "VALUE", value = cond, 
[10:22:49.739]                                 success = TRUE)
[10:22:49.739]                               parallel_sendData(master, data)
[10:22:49.739]                             }
[10:22:49.739]                             return(sendCondition)
[10:22:49.739]                           }
[10:22:49.739]                         }
[10:22:49.739]                         frame <- frame + 1L
[10:22:49.739]                         envir <- sys.frame(frame)
[10:22:49.739]                       }
[10:22:49.739]                     }
[10:22:49.739]                     sendCondition <<- function(cond) NULL
[10:22:49.739]                   }
[10:22:49.739]                 })
[10:22:49.739]                 withCallingHandlers({
[10:22:49.739]                   1
[10:22:49.739]                 }, immediateCondition = function(cond) {
[10:22:49.739]                   sendCondition <- ...future.makeSendCondition()
[10:22:49.739]                   sendCondition(cond)
[10:22:49.739]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.739]                   {
[10:22:49.739]                     inherits <- base::inherits
[10:22:49.739]                     invokeRestart <- base::invokeRestart
[10:22:49.739]                     is.null <- base::is.null
[10:22:49.739]                     muffled <- FALSE
[10:22:49.739]                     if (inherits(cond, "message")) {
[10:22:49.739]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:49.739]                       if (muffled) 
[10:22:49.739]                         invokeRestart("muffleMessage")
[10:22:49.739]                     }
[10:22:49.739]                     else if (inherits(cond, "warning")) {
[10:22:49.739]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:49.739]                       if (muffled) 
[10:22:49.739]                         invokeRestart("muffleWarning")
[10:22:49.739]                     }
[10:22:49.739]                     else if (inherits(cond, "condition")) {
[10:22:49.739]                       if (!is.null(pattern)) {
[10:22:49.739]                         computeRestarts <- base::computeRestarts
[10:22:49.739]                         grepl <- base::grepl
[10:22:49.739]                         restarts <- computeRestarts(cond)
[10:22:49.739]                         for (restart in restarts) {
[10:22:49.739]                           name <- restart$name
[10:22:49.739]                           if (is.null(name)) 
[10:22:49.739]                             next
[10:22:49.739]                           if (!grepl(pattern, name)) 
[10:22:49.739]                             next
[10:22:49.739]                           invokeRestart(restart)
[10:22:49.739]                           muffled <- TRUE
[10:22:49.739]                           break
[10:22:49.739]                         }
[10:22:49.739]                       }
[10:22:49.739]                     }
[10:22:49.739]                     invisible(muffled)
[10:22:49.739]                   }
[10:22:49.739]                   muffleCondition(cond)
[10:22:49.739]                 })
[10:22:49.739]             }))
[10:22:49.739]             future::FutureResult(value = ...future.value$value, 
[10:22:49.739]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.739]                   ...future.rng), globalenv = if (FALSE) 
[10:22:49.739]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:49.739]                     ...future.globalenv.names))
[10:22:49.739]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:49.739]         }, condition = base::local({
[10:22:49.739]             c <- base::c
[10:22:49.739]             inherits <- base::inherits
[10:22:49.739]             invokeRestart <- base::invokeRestart
[10:22:49.739]             length <- base::length
[10:22:49.739]             list <- base::list
[10:22:49.739]             seq.int <- base::seq.int
[10:22:49.739]             signalCondition <- base::signalCondition
[10:22:49.739]             sys.calls <- base::sys.calls
[10:22:49.739]             `[[` <- base::`[[`
[10:22:49.739]             `+` <- base::`+`
[10:22:49.739]             `<<-` <- base::`<<-`
[10:22:49.739]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:49.739]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:49.739]                   3L)]
[10:22:49.739]             }
[10:22:49.739]             function(cond) {
[10:22:49.739]                 is_error <- inherits(cond, "error")
[10:22:49.739]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:49.739]                   NULL)
[10:22:49.739]                 if (is_error) {
[10:22:49.739]                   sessionInformation <- function() {
[10:22:49.739]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:49.739]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:49.739]                       search = base::search(), system = base::Sys.info())
[10:22:49.739]                   }
[10:22:49.739]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.739]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:49.739]                     cond$call), session = sessionInformation(), 
[10:22:49.739]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:49.739]                   signalCondition(cond)
[10:22:49.739]                 }
[10:22:49.739]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:49.739]                 "immediateCondition"))) {
[10:22:49.739]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:49.739]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.739]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:49.739]                   if (TRUE && !signal) {
[10:22:49.739]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.739]                     {
[10:22:49.739]                       inherits <- base::inherits
[10:22:49.739]                       invokeRestart <- base::invokeRestart
[10:22:49.739]                       is.null <- base::is.null
[10:22:49.739]                       muffled <- FALSE
[10:22:49.739]                       if (inherits(cond, "message")) {
[10:22:49.739]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.739]                         if (muffled) 
[10:22:49.739]                           invokeRestart("muffleMessage")
[10:22:49.739]                       }
[10:22:49.739]                       else if (inherits(cond, "warning")) {
[10:22:49.739]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.739]                         if (muffled) 
[10:22:49.739]                           invokeRestart("muffleWarning")
[10:22:49.739]                       }
[10:22:49.739]                       else if (inherits(cond, "condition")) {
[10:22:49.739]                         if (!is.null(pattern)) {
[10:22:49.739]                           computeRestarts <- base::computeRestarts
[10:22:49.739]                           grepl <- base::grepl
[10:22:49.739]                           restarts <- computeRestarts(cond)
[10:22:49.739]                           for (restart in restarts) {
[10:22:49.739]                             name <- restart$name
[10:22:49.739]                             if (is.null(name)) 
[10:22:49.739]                               next
[10:22:49.739]                             if (!grepl(pattern, name)) 
[10:22:49.739]                               next
[10:22:49.739]                             invokeRestart(restart)
[10:22:49.739]                             muffled <- TRUE
[10:22:49.739]                             break
[10:22:49.739]                           }
[10:22:49.739]                         }
[10:22:49.739]                       }
[10:22:49.739]                       invisible(muffled)
[10:22:49.739]                     }
[10:22:49.739]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.739]                   }
[10:22:49.739]                 }
[10:22:49.739]                 else {
[10:22:49.739]                   if (TRUE) {
[10:22:49.739]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.739]                     {
[10:22:49.739]                       inherits <- base::inherits
[10:22:49.739]                       invokeRestart <- base::invokeRestart
[10:22:49.739]                       is.null <- base::is.null
[10:22:49.739]                       muffled <- FALSE
[10:22:49.739]                       if (inherits(cond, "message")) {
[10:22:49.739]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.739]                         if (muffled) 
[10:22:49.739]                           invokeRestart("muffleMessage")
[10:22:49.739]                       }
[10:22:49.739]                       else if (inherits(cond, "warning")) {
[10:22:49.739]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.739]                         if (muffled) 
[10:22:49.739]                           invokeRestart("muffleWarning")
[10:22:49.739]                       }
[10:22:49.739]                       else if (inherits(cond, "condition")) {
[10:22:49.739]                         if (!is.null(pattern)) {
[10:22:49.739]                           computeRestarts <- base::computeRestarts
[10:22:49.739]                           grepl <- base::grepl
[10:22:49.739]                           restarts <- computeRestarts(cond)
[10:22:49.739]                           for (restart in restarts) {
[10:22:49.739]                             name <- restart$name
[10:22:49.739]                             if (is.null(name)) 
[10:22:49.739]                               next
[10:22:49.739]                             if (!grepl(pattern, name)) 
[10:22:49.739]                               next
[10:22:49.739]                             invokeRestart(restart)
[10:22:49.739]                             muffled <- TRUE
[10:22:49.739]                             break
[10:22:49.739]                           }
[10:22:49.739]                         }
[10:22:49.739]                       }
[10:22:49.739]                       invisible(muffled)
[10:22:49.739]                     }
[10:22:49.739]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.739]                   }
[10:22:49.739]                 }
[10:22:49.739]             }
[10:22:49.739]         }))
[10:22:49.739]     }, error = function(ex) {
[10:22:49.739]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:49.739]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.739]                 ...future.rng), started = ...future.startTime, 
[10:22:49.739]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:49.739]             version = "1.8"), class = "FutureResult")
[10:22:49.739]     }, finally = {
[10:22:49.739]         if (!identical(...future.workdir, getwd())) 
[10:22:49.739]             setwd(...future.workdir)
[10:22:49.739]         {
[10:22:49.739]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:49.739]                 ...future.oldOptions$nwarnings <- NULL
[10:22:49.739]             }
[10:22:49.739]             base::options(...future.oldOptions)
[10:22:49.739]             if (.Platform$OS.type == "windows") {
[10:22:49.739]                 old_names <- names(...future.oldEnvVars)
[10:22:49.739]                 envs <- base::Sys.getenv()
[10:22:49.739]                 names <- names(envs)
[10:22:49.739]                 common <- intersect(names, old_names)
[10:22:49.739]                 added <- setdiff(names, old_names)
[10:22:49.739]                 removed <- setdiff(old_names, names)
[10:22:49.739]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:49.739]                   envs[common]]
[10:22:49.739]                 NAMES <- toupper(changed)
[10:22:49.739]                 args <- list()
[10:22:49.739]                 for (kk in seq_along(NAMES)) {
[10:22:49.739]                   name <- changed[[kk]]
[10:22:49.739]                   NAME <- NAMES[[kk]]
[10:22:49.739]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.739]                     next
[10:22:49.739]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.739]                 }
[10:22:49.739]                 NAMES <- toupper(added)
[10:22:49.739]                 for (kk in seq_along(NAMES)) {
[10:22:49.739]                   name <- added[[kk]]
[10:22:49.739]                   NAME <- NAMES[[kk]]
[10:22:49.739]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.739]                     next
[10:22:49.739]                   args[[name]] <- ""
[10:22:49.739]                 }
[10:22:49.739]                 NAMES <- toupper(removed)
[10:22:49.739]                 for (kk in seq_along(NAMES)) {
[10:22:49.739]                   name <- removed[[kk]]
[10:22:49.739]                   NAME <- NAMES[[kk]]
[10:22:49.739]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.739]                     next
[10:22:49.739]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.739]                 }
[10:22:49.739]                 if (length(args) > 0) 
[10:22:49.739]                   base::do.call(base::Sys.setenv, args = args)
[10:22:49.739]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:49.739]             }
[10:22:49.739]             else {
[10:22:49.739]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:49.739]             }
[10:22:49.739]             {
[10:22:49.739]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:49.739]                   0L) {
[10:22:49.739]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:49.739]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:49.739]                   base::options(opts)
[10:22:49.739]                 }
[10:22:49.739]                 {
[10:22:49.739]                   {
[10:22:49.739]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:49.739]                     NULL
[10:22:49.739]                   }
[10:22:49.739]                   options(future.plan = NULL)
[10:22:49.739]                   if (is.na(NA_character_)) 
[10:22:49.739]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.739]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:49.739]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:49.739]                     .init = FALSE)
[10:22:49.739]                 }
[10:22:49.739]             }
[10:22:49.739]         }
[10:22:49.739]     })
[10:22:49.739]     if (TRUE) {
[10:22:49.739]         base::sink(type = "output", split = FALSE)
[10:22:49.739]         if (TRUE) {
[10:22:49.739]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:49.739]         }
[10:22:49.739]         else {
[10:22:49.739]             ...future.result["stdout"] <- base::list(NULL)
[10:22:49.739]         }
[10:22:49.739]         base::close(...future.stdout)
[10:22:49.739]         ...future.stdout <- NULL
[10:22:49.739]     }
[10:22:49.739]     ...future.result$conditions <- ...future.conditions
[10:22:49.739]     ...future.result$finished <- base::Sys.time()
[10:22:49.739]     ...future.result
[10:22:49.739] }
[10:22:49.742] MultisessionFuture started
[10:22:49.742] - Launch lazy future ... done
[10:22:49.742] run() for ‘MultisessionFuture’ ... done
[10:22:49.742] getGlobalsAndPackages() ...
[10:22:49.742] Searching for globals...
[10:22:49.743] 
[10:22:49.743] Searching for globals ... DONE
[10:22:49.743] - globals: [0] <none>
[10:22:49.743] getGlobalsAndPackages() ... DONE
[10:22:49.743] run() for ‘Future’ ...
[10:22:49.743] - state: ‘created’
[10:22:49.743] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:49.757] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:49.757] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:49.757]   - Field: ‘node’
[10:22:49.757]   - Field: ‘label’
[10:22:49.757]   - Field: ‘local’
[10:22:49.757]   - Field: ‘owner’
[10:22:49.757]   - Field: ‘envir’
[10:22:49.757]   - Field: ‘workers’
[10:22:49.757]   - Field: ‘packages’
[10:22:49.757]   - Field: ‘gc’
[10:22:49.758]   - Field: ‘conditions’
[10:22:49.758]   - Field: ‘persistent’
[10:22:49.758]   - Field: ‘expr’
[10:22:49.758]   - Field: ‘uuid’
[10:22:49.758]   - Field: ‘seed’
[10:22:49.758]   - Field: ‘version’
[10:22:49.758]   - Field: ‘result’
[10:22:49.758]   - Field: ‘asynchronous’
[10:22:49.758]   - Field: ‘calls’
[10:22:49.758]   - Field: ‘globals’
[10:22:49.758]   - Field: ‘stdout’
[10:22:49.758]   - Field: ‘earlySignal’
[10:22:49.759]   - Field: ‘lazy’
[10:22:49.759]   - Field: ‘state’
[10:22:49.759] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:49.759] - Launch lazy future ...
[10:22:49.759] Packages needed by the future expression (n = 0): <none>
[10:22:49.759] Packages needed by future strategies (n = 0): <none>
[10:22:49.760] {
[10:22:49.760]     {
[10:22:49.760]         {
[10:22:49.760]             ...future.startTime <- base::Sys.time()
[10:22:49.760]             {
[10:22:49.760]                 {
[10:22:49.760]                   {
[10:22:49.760]                     {
[10:22:49.760]                       base::local({
[10:22:49.760]                         has_future <- base::requireNamespace("future", 
[10:22:49.760]                           quietly = TRUE)
[10:22:49.760]                         if (has_future) {
[10:22:49.760]                           ns <- base::getNamespace("future")
[10:22:49.760]                           version <- ns[[".package"]][["version"]]
[10:22:49.760]                           if (is.null(version)) 
[10:22:49.760]                             version <- utils::packageVersion("future")
[10:22:49.760]                         }
[10:22:49.760]                         else {
[10:22:49.760]                           version <- NULL
[10:22:49.760]                         }
[10:22:49.760]                         if (!has_future || version < "1.8.0") {
[10:22:49.760]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:49.760]                             "", base::R.version$version.string), 
[10:22:49.760]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:49.760]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:49.760]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:49.760]                               "release", "version")], collapse = " "), 
[10:22:49.760]                             hostname = base::Sys.info()[["nodename"]])
[10:22:49.760]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:49.760]                             info)
[10:22:49.760]                           info <- base::paste(info, collapse = "; ")
[10:22:49.760]                           if (!has_future) {
[10:22:49.760]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:49.760]                               info)
[10:22:49.760]                           }
[10:22:49.760]                           else {
[10:22:49.760]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:49.760]                               info, version)
[10:22:49.760]                           }
[10:22:49.760]                           base::stop(msg)
[10:22:49.760]                         }
[10:22:49.760]                       })
[10:22:49.760]                     }
[10:22:49.760]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:49.760]                     base::options(mc.cores = 1L)
[10:22:49.760]                   }
[10:22:49.760]                   ...future.strategy.old <- future::plan("list")
[10:22:49.760]                   options(future.plan = NULL)
[10:22:49.760]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.760]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:49.760]                 }
[10:22:49.760]                 ...future.workdir <- getwd()
[10:22:49.760]             }
[10:22:49.760]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:49.760]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:49.760]         }
[10:22:49.760]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:49.760]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:49.760]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:49.760]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:49.760]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:49.760]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:49.760]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:49.760]             base::names(...future.oldOptions))
[10:22:49.760]     }
[10:22:49.760]     if (FALSE) {
[10:22:49.760]     }
[10:22:49.760]     else {
[10:22:49.760]         if (TRUE) {
[10:22:49.760]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:49.760]                 open = "w")
[10:22:49.760]         }
[10:22:49.760]         else {
[10:22:49.760]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:49.760]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:49.760]         }
[10:22:49.760]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:49.760]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:49.760]             base::sink(type = "output", split = FALSE)
[10:22:49.760]             base::close(...future.stdout)
[10:22:49.760]         }, add = TRUE)
[10:22:49.760]     }
[10:22:49.760]     ...future.frame <- base::sys.nframe()
[10:22:49.760]     ...future.conditions <- base::list()
[10:22:49.760]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:49.760]     if (FALSE) {
[10:22:49.760]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:49.760]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:49.760]     }
[10:22:49.760]     ...future.result <- base::tryCatch({
[10:22:49.760]         base::withCallingHandlers({
[10:22:49.760]             ...future.value <- base::withVisible(base::local({
[10:22:49.760]                 ...future.makeSendCondition <- base::local({
[10:22:49.760]                   sendCondition <- NULL
[10:22:49.760]                   function(frame = 1L) {
[10:22:49.760]                     if (is.function(sendCondition)) 
[10:22:49.760]                       return(sendCondition)
[10:22:49.760]                     ns <- getNamespace("parallel")
[10:22:49.760]                     if (exists("sendData", mode = "function", 
[10:22:49.760]                       envir = ns)) {
[10:22:49.760]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:49.760]                         envir = ns)
[10:22:49.760]                       envir <- sys.frame(frame)
[10:22:49.760]                       master <- NULL
[10:22:49.760]                       while (!identical(envir, .GlobalEnv) && 
[10:22:49.760]                         !identical(envir, emptyenv())) {
[10:22:49.760]                         if (exists("master", mode = "list", envir = envir, 
[10:22:49.760]                           inherits = FALSE)) {
[10:22:49.760]                           master <- get("master", mode = "list", 
[10:22:49.760]                             envir = envir, inherits = FALSE)
[10:22:49.760]                           if (inherits(master, c("SOCKnode", 
[10:22:49.760]                             "SOCK0node"))) {
[10:22:49.760]                             sendCondition <<- function(cond) {
[10:22:49.760]                               data <- list(type = "VALUE", value = cond, 
[10:22:49.760]                                 success = TRUE)
[10:22:49.760]                               parallel_sendData(master, data)
[10:22:49.760]                             }
[10:22:49.760]                             return(sendCondition)
[10:22:49.760]                           }
[10:22:49.760]                         }
[10:22:49.760]                         frame <- frame + 1L
[10:22:49.760]                         envir <- sys.frame(frame)
[10:22:49.760]                       }
[10:22:49.760]                     }
[10:22:49.760]                     sendCondition <<- function(cond) NULL
[10:22:49.760]                   }
[10:22:49.760]                 })
[10:22:49.760]                 withCallingHandlers({
[10:22:49.760]                   2
[10:22:49.760]                 }, immediateCondition = function(cond) {
[10:22:49.760]                   sendCondition <- ...future.makeSendCondition()
[10:22:49.760]                   sendCondition(cond)
[10:22:49.760]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.760]                   {
[10:22:49.760]                     inherits <- base::inherits
[10:22:49.760]                     invokeRestart <- base::invokeRestart
[10:22:49.760]                     is.null <- base::is.null
[10:22:49.760]                     muffled <- FALSE
[10:22:49.760]                     if (inherits(cond, "message")) {
[10:22:49.760]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:49.760]                       if (muffled) 
[10:22:49.760]                         invokeRestart("muffleMessage")
[10:22:49.760]                     }
[10:22:49.760]                     else if (inherits(cond, "warning")) {
[10:22:49.760]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:49.760]                       if (muffled) 
[10:22:49.760]                         invokeRestart("muffleWarning")
[10:22:49.760]                     }
[10:22:49.760]                     else if (inherits(cond, "condition")) {
[10:22:49.760]                       if (!is.null(pattern)) {
[10:22:49.760]                         computeRestarts <- base::computeRestarts
[10:22:49.760]                         grepl <- base::grepl
[10:22:49.760]                         restarts <- computeRestarts(cond)
[10:22:49.760]                         for (restart in restarts) {
[10:22:49.760]                           name <- restart$name
[10:22:49.760]                           if (is.null(name)) 
[10:22:49.760]                             next
[10:22:49.760]                           if (!grepl(pattern, name)) 
[10:22:49.760]                             next
[10:22:49.760]                           invokeRestart(restart)
[10:22:49.760]                           muffled <- TRUE
[10:22:49.760]                           break
[10:22:49.760]                         }
[10:22:49.760]                       }
[10:22:49.760]                     }
[10:22:49.760]                     invisible(muffled)
[10:22:49.760]                   }
[10:22:49.760]                   muffleCondition(cond)
[10:22:49.760]                 })
[10:22:49.760]             }))
[10:22:49.760]             future::FutureResult(value = ...future.value$value, 
[10:22:49.760]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.760]                   ...future.rng), globalenv = if (FALSE) 
[10:22:49.760]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:49.760]                     ...future.globalenv.names))
[10:22:49.760]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:49.760]         }, condition = base::local({
[10:22:49.760]             c <- base::c
[10:22:49.760]             inherits <- base::inherits
[10:22:49.760]             invokeRestart <- base::invokeRestart
[10:22:49.760]             length <- base::length
[10:22:49.760]             list <- base::list
[10:22:49.760]             seq.int <- base::seq.int
[10:22:49.760]             signalCondition <- base::signalCondition
[10:22:49.760]             sys.calls <- base::sys.calls
[10:22:49.760]             `[[` <- base::`[[`
[10:22:49.760]             `+` <- base::`+`
[10:22:49.760]             `<<-` <- base::`<<-`
[10:22:49.760]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:49.760]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:49.760]                   3L)]
[10:22:49.760]             }
[10:22:49.760]             function(cond) {
[10:22:49.760]                 is_error <- inherits(cond, "error")
[10:22:49.760]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:49.760]                   NULL)
[10:22:49.760]                 if (is_error) {
[10:22:49.760]                   sessionInformation <- function() {
[10:22:49.760]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:49.760]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:49.760]                       search = base::search(), system = base::Sys.info())
[10:22:49.760]                   }
[10:22:49.760]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.760]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:49.760]                     cond$call), session = sessionInformation(), 
[10:22:49.760]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:49.760]                   signalCondition(cond)
[10:22:49.760]                 }
[10:22:49.760]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:49.760]                 "immediateCondition"))) {
[10:22:49.760]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:49.760]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.760]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:49.760]                   if (TRUE && !signal) {
[10:22:49.760]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.760]                     {
[10:22:49.760]                       inherits <- base::inherits
[10:22:49.760]                       invokeRestart <- base::invokeRestart
[10:22:49.760]                       is.null <- base::is.null
[10:22:49.760]                       muffled <- FALSE
[10:22:49.760]                       if (inherits(cond, "message")) {
[10:22:49.760]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.760]                         if (muffled) 
[10:22:49.760]                           invokeRestart("muffleMessage")
[10:22:49.760]                       }
[10:22:49.760]                       else if (inherits(cond, "warning")) {
[10:22:49.760]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.760]                         if (muffled) 
[10:22:49.760]                           invokeRestart("muffleWarning")
[10:22:49.760]                       }
[10:22:49.760]                       else if (inherits(cond, "condition")) {
[10:22:49.760]                         if (!is.null(pattern)) {
[10:22:49.760]                           computeRestarts <- base::computeRestarts
[10:22:49.760]                           grepl <- base::grepl
[10:22:49.760]                           restarts <- computeRestarts(cond)
[10:22:49.760]                           for (restart in restarts) {
[10:22:49.760]                             name <- restart$name
[10:22:49.760]                             if (is.null(name)) 
[10:22:49.760]                               next
[10:22:49.760]                             if (!grepl(pattern, name)) 
[10:22:49.760]                               next
[10:22:49.760]                             invokeRestart(restart)
[10:22:49.760]                             muffled <- TRUE
[10:22:49.760]                             break
[10:22:49.760]                           }
[10:22:49.760]                         }
[10:22:49.760]                       }
[10:22:49.760]                       invisible(muffled)
[10:22:49.760]                     }
[10:22:49.760]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.760]                   }
[10:22:49.760]                 }
[10:22:49.760]                 else {
[10:22:49.760]                   if (TRUE) {
[10:22:49.760]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.760]                     {
[10:22:49.760]                       inherits <- base::inherits
[10:22:49.760]                       invokeRestart <- base::invokeRestart
[10:22:49.760]                       is.null <- base::is.null
[10:22:49.760]                       muffled <- FALSE
[10:22:49.760]                       if (inherits(cond, "message")) {
[10:22:49.760]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.760]                         if (muffled) 
[10:22:49.760]                           invokeRestart("muffleMessage")
[10:22:49.760]                       }
[10:22:49.760]                       else if (inherits(cond, "warning")) {
[10:22:49.760]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.760]                         if (muffled) 
[10:22:49.760]                           invokeRestart("muffleWarning")
[10:22:49.760]                       }
[10:22:49.760]                       else if (inherits(cond, "condition")) {
[10:22:49.760]                         if (!is.null(pattern)) {
[10:22:49.760]                           computeRestarts <- base::computeRestarts
[10:22:49.760]                           grepl <- base::grepl
[10:22:49.760]                           restarts <- computeRestarts(cond)
[10:22:49.760]                           for (restart in restarts) {
[10:22:49.760]                             name <- restart$name
[10:22:49.760]                             if (is.null(name)) 
[10:22:49.760]                               next
[10:22:49.760]                             if (!grepl(pattern, name)) 
[10:22:49.760]                               next
[10:22:49.760]                             invokeRestart(restart)
[10:22:49.760]                             muffled <- TRUE
[10:22:49.760]                             break
[10:22:49.760]                           }
[10:22:49.760]                         }
[10:22:49.760]                       }
[10:22:49.760]                       invisible(muffled)
[10:22:49.760]                     }
[10:22:49.760]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.760]                   }
[10:22:49.760]                 }
[10:22:49.760]             }
[10:22:49.760]         }))
[10:22:49.760]     }, error = function(ex) {
[10:22:49.760]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:49.760]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.760]                 ...future.rng), started = ...future.startTime, 
[10:22:49.760]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:49.760]             version = "1.8"), class = "FutureResult")
[10:22:49.760]     }, finally = {
[10:22:49.760]         if (!identical(...future.workdir, getwd())) 
[10:22:49.760]             setwd(...future.workdir)
[10:22:49.760]         {
[10:22:49.760]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:49.760]                 ...future.oldOptions$nwarnings <- NULL
[10:22:49.760]             }
[10:22:49.760]             base::options(...future.oldOptions)
[10:22:49.760]             if (.Platform$OS.type == "windows") {
[10:22:49.760]                 old_names <- names(...future.oldEnvVars)
[10:22:49.760]                 envs <- base::Sys.getenv()
[10:22:49.760]                 names <- names(envs)
[10:22:49.760]                 common <- intersect(names, old_names)
[10:22:49.760]                 added <- setdiff(names, old_names)
[10:22:49.760]                 removed <- setdiff(old_names, names)
[10:22:49.760]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:49.760]                   envs[common]]
[10:22:49.760]                 NAMES <- toupper(changed)
[10:22:49.760]                 args <- list()
[10:22:49.760]                 for (kk in seq_along(NAMES)) {
[10:22:49.760]                   name <- changed[[kk]]
[10:22:49.760]                   NAME <- NAMES[[kk]]
[10:22:49.760]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.760]                     next
[10:22:49.760]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.760]                 }
[10:22:49.760]                 NAMES <- toupper(added)
[10:22:49.760]                 for (kk in seq_along(NAMES)) {
[10:22:49.760]                   name <- added[[kk]]
[10:22:49.760]                   NAME <- NAMES[[kk]]
[10:22:49.760]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.760]                     next
[10:22:49.760]                   args[[name]] <- ""
[10:22:49.760]                 }
[10:22:49.760]                 NAMES <- toupper(removed)
[10:22:49.760]                 for (kk in seq_along(NAMES)) {
[10:22:49.760]                   name <- removed[[kk]]
[10:22:49.760]                   NAME <- NAMES[[kk]]
[10:22:49.760]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.760]                     next
[10:22:49.760]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.760]                 }
[10:22:49.760]                 if (length(args) > 0) 
[10:22:49.760]                   base::do.call(base::Sys.setenv, args = args)
[10:22:49.760]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:49.760]             }
[10:22:49.760]             else {
[10:22:49.760]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:49.760]             }
[10:22:49.760]             {
[10:22:49.760]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:49.760]                   0L) {
[10:22:49.760]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:49.760]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:49.760]                   base::options(opts)
[10:22:49.760]                 }
[10:22:49.760]                 {
[10:22:49.760]                   {
[10:22:49.760]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:49.760]                     NULL
[10:22:49.760]                   }
[10:22:49.760]                   options(future.plan = NULL)
[10:22:49.760]                   if (is.na(NA_character_)) 
[10:22:49.760]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.760]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:49.760]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:49.760]                     .init = FALSE)
[10:22:49.760]                 }
[10:22:49.760]             }
[10:22:49.760]         }
[10:22:49.760]     })
[10:22:49.760]     if (TRUE) {
[10:22:49.760]         base::sink(type = "output", split = FALSE)
[10:22:49.760]         if (TRUE) {
[10:22:49.760]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:49.760]         }
[10:22:49.760]         else {
[10:22:49.760]             ...future.result["stdout"] <- base::list(NULL)
[10:22:49.760]         }
[10:22:49.760]         base::close(...future.stdout)
[10:22:49.760]         ...future.stdout <- NULL
[10:22:49.760]     }
[10:22:49.760]     ...future.result$conditions <- ...future.conditions
[10:22:49.760]     ...future.result$finished <- base::Sys.time()
[10:22:49.760]     ...future.result
[10:22:49.760] }
[10:22:49.763] MultisessionFuture started
[10:22:49.763] - Launch lazy future ... done
[10:22:49.763] run() for ‘MultisessionFuture’ ... done
[10:22:49.763] resolve() on environment ...
[10:22:49.763]  recursive: 0
[10:22:49.764]  elements: [3] ‘a’, ‘b’, ‘c’
[10:22:49.785]  length: 2 (resolved future 3)
[10:22:49.796] receiveMessageFromWorker() for ClusterFuture ...
[10:22:49.796] - Validating connection of MultisessionFuture
[10:22:49.796] - received message: FutureResult
[10:22:49.796] - Received FutureResult
[10:22:49.796] - Erased future from FutureRegistry
[10:22:49.796] result() for ClusterFuture ...
[10:22:49.796] - result already collected: FutureResult
[10:22:49.796] result() for ClusterFuture ... done
[10:22:49.797] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:49.797] Future #1
[10:22:49.797]  length: 1 (resolved future 1)
[10:22:49.805] receiveMessageFromWorker() for ClusterFuture ...
[10:22:49.805] - Validating connection of MultisessionFuture
[10:22:49.805] - received message: FutureResult
[10:22:49.806] - Received FutureResult
[10:22:49.806] - Erased future from FutureRegistry
[10:22:49.806] result() for ClusterFuture ...
[10:22:49.806] - result already collected: FutureResult
[10:22:49.806] result() for ClusterFuture ... done
[10:22:49.806] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:49.806] Future #2
[10:22:49.806]  length: 0 (resolved future 2)
[10:22:49.806] resolve() on environment ... DONE
[10:22:49.807] getGlobalsAndPackages() ...
[10:22:49.807] Searching for globals...
[10:22:49.808] - globals found: [1] ‘{’
[10:22:49.808] Searching for globals ... DONE
[10:22:49.808] Resolving globals: FALSE
[10:22:49.808] 
[10:22:49.808] 
[10:22:49.808] getGlobalsAndPackages() ... DONE
[10:22:49.809] run() for ‘Future’ ...
[10:22:49.809] - state: ‘created’
[10:22:49.809] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:49.822] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:49.823] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:49.823]   - Field: ‘node’
[10:22:49.823]   - Field: ‘label’
[10:22:49.823]   - Field: ‘local’
[10:22:49.823]   - Field: ‘owner’
[10:22:49.823]   - Field: ‘envir’
[10:22:49.823]   - Field: ‘workers’
[10:22:49.823]   - Field: ‘packages’
[10:22:49.823]   - Field: ‘gc’
[10:22:49.823]   - Field: ‘conditions’
[10:22:49.824]   - Field: ‘persistent’
[10:22:49.824]   - Field: ‘expr’
[10:22:49.824]   - Field: ‘uuid’
[10:22:49.824]   - Field: ‘seed’
[10:22:49.824]   - Field: ‘version’
[10:22:49.824]   - Field: ‘result’
[10:22:49.824]   - Field: ‘asynchronous’
[10:22:49.824]   - Field: ‘calls’
[10:22:49.824]   - Field: ‘globals’
[10:22:49.824]   - Field: ‘stdout’
[10:22:49.824]   - Field: ‘earlySignal’
[10:22:49.825]   - Field: ‘lazy’
[10:22:49.825]   - Field: ‘state’
[10:22:49.825] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:49.825] - Launch lazy future ...
[10:22:49.825] Packages needed by the future expression (n = 0): <none>
[10:22:49.825] Packages needed by future strategies (n = 0): <none>
[10:22:49.826] {
[10:22:49.826]     {
[10:22:49.826]         {
[10:22:49.826]             ...future.startTime <- base::Sys.time()
[10:22:49.826]             {
[10:22:49.826]                 {
[10:22:49.826]                   {
[10:22:49.826]                     {
[10:22:49.826]                       base::local({
[10:22:49.826]                         has_future <- base::requireNamespace("future", 
[10:22:49.826]                           quietly = TRUE)
[10:22:49.826]                         if (has_future) {
[10:22:49.826]                           ns <- base::getNamespace("future")
[10:22:49.826]                           version <- ns[[".package"]][["version"]]
[10:22:49.826]                           if (is.null(version)) 
[10:22:49.826]                             version <- utils::packageVersion("future")
[10:22:49.826]                         }
[10:22:49.826]                         else {
[10:22:49.826]                           version <- NULL
[10:22:49.826]                         }
[10:22:49.826]                         if (!has_future || version < "1.8.0") {
[10:22:49.826]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:49.826]                             "", base::R.version$version.string), 
[10:22:49.826]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:49.826]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:49.826]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:49.826]                               "release", "version")], collapse = " "), 
[10:22:49.826]                             hostname = base::Sys.info()[["nodename"]])
[10:22:49.826]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:49.826]                             info)
[10:22:49.826]                           info <- base::paste(info, collapse = "; ")
[10:22:49.826]                           if (!has_future) {
[10:22:49.826]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:49.826]                               info)
[10:22:49.826]                           }
[10:22:49.826]                           else {
[10:22:49.826]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:49.826]                               info, version)
[10:22:49.826]                           }
[10:22:49.826]                           base::stop(msg)
[10:22:49.826]                         }
[10:22:49.826]                       })
[10:22:49.826]                     }
[10:22:49.826]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:49.826]                     base::options(mc.cores = 1L)
[10:22:49.826]                   }
[10:22:49.826]                   ...future.strategy.old <- future::plan("list")
[10:22:49.826]                   options(future.plan = NULL)
[10:22:49.826]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.826]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:49.826]                 }
[10:22:49.826]                 ...future.workdir <- getwd()
[10:22:49.826]             }
[10:22:49.826]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:49.826]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:49.826]         }
[10:22:49.826]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:49.826]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:49.826]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:49.826]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:49.826]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:49.826]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:49.826]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:49.826]             base::names(...future.oldOptions))
[10:22:49.826]     }
[10:22:49.826]     if (FALSE) {
[10:22:49.826]     }
[10:22:49.826]     else {
[10:22:49.826]         if (TRUE) {
[10:22:49.826]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:49.826]                 open = "w")
[10:22:49.826]         }
[10:22:49.826]         else {
[10:22:49.826]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:49.826]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:49.826]         }
[10:22:49.826]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:49.826]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:49.826]             base::sink(type = "output", split = FALSE)
[10:22:49.826]             base::close(...future.stdout)
[10:22:49.826]         }, add = TRUE)
[10:22:49.826]     }
[10:22:49.826]     ...future.frame <- base::sys.nframe()
[10:22:49.826]     ...future.conditions <- base::list()
[10:22:49.826]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:49.826]     if (FALSE) {
[10:22:49.826]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:49.826]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:49.826]     }
[10:22:49.826]     ...future.result <- base::tryCatch({
[10:22:49.826]         base::withCallingHandlers({
[10:22:49.826]             ...future.value <- base::withVisible(base::local({
[10:22:49.826]                 ...future.makeSendCondition <- base::local({
[10:22:49.826]                   sendCondition <- NULL
[10:22:49.826]                   function(frame = 1L) {
[10:22:49.826]                     if (is.function(sendCondition)) 
[10:22:49.826]                       return(sendCondition)
[10:22:49.826]                     ns <- getNamespace("parallel")
[10:22:49.826]                     if (exists("sendData", mode = "function", 
[10:22:49.826]                       envir = ns)) {
[10:22:49.826]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:49.826]                         envir = ns)
[10:22:49.826]                       envir <- sys.frame(frame)
[10:22:49.826]                       master <- NULL
[10:22:49.826]                       while (!identical(envir, .GlobalEnv) && 
[10:22:49.826]                         !identical(envir, emptyenv())) {
[10:22:49.826]                         if (exists("master", mode = "list", envir = envir, 
[10:22:49.826]                           inherits = FALSE)) {
[10:22:49.826]                           master <- get("master", mode = "list", 
[10:22:49.826]                             envir = envir, inherits = FALSE)
[10:22:49.826]                           if (inherits(master, c("SOCKnode", 
[10:22:49.826]                             "SOCK0node"))) {
[10:22:49.826]                             sendCondition <<- function(cond) {
[10:22:49.826]                               data <- list(type = "VALUE", value = cond, 
[10:22:49.826]                                 success = TRUE)
[10:22:49.826]                               parallel_sendData(master, data)
[10:22:49.826]                             }
[10:22:49.826]                             return(sendCondition)
[10:22:49.826]                           }
[10:22:49.826]                         }
[10:22:49.826]                         frame <- frame + 1L
[10:22:49.826]                         envir <- sys.frame(frame)
[10:22:49.826]                       }
[10:22:49.826]                     }
[10:22:49.826]                     sendCondition <<- function(cond) NULL
[10:22:49.826]                   }
[10:22:49.826]                 })
[10:22:49.826]                 withCallingHandlers({
[10:22:49.826]                   {
[10:22:49.826]                     1
[10:22:49.826]                   }
[10:22:49.826]                 }, immediateCondition = function(cond) {
[10:22:49.826]                   sendCondition <- ...future.makeSendCondition()
[10:22:49.826]                   sendCondition(cond)
[10:22:49.826]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.826]                   {
[10:22:49.826]                     inherits <- base::inherits
[10:22:49.826]                     invokeRestart <- base::invokeRestart
[10:22:49.826]                     is.null <- base::is.null
[10:22:49.826]                     muffled <- FALSE
[10:22:49.826]                     if (inherits(cond, "message")) {
[10:22:49.826]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:49.826]                       if (muffled) 
[10:22:49.826]                         invokeRestart("muffleMessage")
[10:22:49.826]                     }
[10:22:49.826]                     else if (inherits(cond, "warning")) {
[10:22:49.826]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:49.826]                       if (muffled) 
[10:22:49.826]                         invokeRestart("muffleWarning")
[10:22:49.826]                     }
[10:22:49.826]                     else if (inherits(cond, "condition")) {
[10:22:49.826]                       if (!is.null(pattern)) {
[10:22:49.826]                         computeRestarts <- base::computeRestarts
[10:22:49.826]                         grepl <- base::grepl
[10:22:49.826]                         restarts <- computeRestarts(cond)
[10:22:49.826]                         for (restart in restarts) {
[10:22:49.826]                           name <- restart$name
[10:22:49.826]                           if (is.null(name)) 
[10:22:49.826]                             next
[10:22:49.826]                           if (!grepl(pattern, name)) 
[10:22:49.826]                             next
[10:22:49.826]                           invokeRestart(restart)
[10:22:49.826]                           muffled <- TRUE
[10:22:49.826]                           break
[10:22:49.826]                         }
[10:22:49.826]                       }
[10:22:49.826]                     }
[10:22:49.826]                     invisible(muffled)
[10:22:49.826]                   }
[10:22:49.826]                   muffleCondition(cond)
[10:22:49.826]                 })
[10:22:49.826]             }))
[10:22:49.826]             future::FutureResult(value = ...future.value$value, 
[10:22:49.826]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.826]                   ...future.rng), globalenv = if (FALSE) 
[10:22:49.826]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:49.826]                     ...future.globalenv.names))
[10:22:49.826]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:49.826]         }, condition = base::local({
[10:22:49.826]             c <- base::c
[10:22:49.826]             inherits <- base::inherits
[10:22:49.826]             invokeRestart <- base::invokeRestart
[10:22:49.826]             length <- base::length
[10:22:49.826]             list <- base::list
[10:22:49.826]             seq.int <- base::seq.int
[10:22:49.826]             signalCondition <- base::signalCondition
[10:22:49.826]             sys.calls <- base::sys.calls
[10:22:49.826]             `[[` <- base::`[[`
[10:22:49.826]             `+` <- base::`+`
[10:22:49.826]             `<<-` <- base::`<<-`
[10:22:49.826]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:49.826]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:49.826]                   3L)]
[10:22:49.826]             }
[10:22:49.826]             function(cond) {
[10:22:49.826]                 is_error <- inherits(cond, "error")
[10:22:49.826]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:49.826]                   NULL)
[10:22:49.826]                 if (is_error) {
[10:22:49.826]                   sessionInformation <- function() {
[10:22:49.826]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:49.826]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:49.826]                       search = base::search(), system = base::Sys.info())
[10:22:49.826]                   }
[10:22:49.826]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.826]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:49.826]                     cond$call), session = sessionInformation(), 
[10:22:49.826]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:49.826]                   signalCondition(cond)
[10:22:49.826]                 }
[10:22:49.826]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:49.826]                 "immediateCondition"))) {
[10:22:49.826]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:49.826]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.826]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:49.826]                   if (TRUE && !signal) {
[10:22:49.826]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.826]                     {
[10:22:49.826]                       inherits <- base::inherits
[10:22:49.826]                       invokeRestart <- base::invokeRestart
[10:22:49.826]                       is.null <- base::is.null
[10:22:49.826]                       muffled <- FALSE
[10:22:49.826]                       if (inherits(cond, "message")) {
[10:22:49.826]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.826]                         if (muffled) 
[10:22:49.826]                           invokeRestart("muffleMessage")
[10:22:49.826]                       }
[10:22:49.826]                       else if (inherits(cond, "warning")) {
[10:22:49.826]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.826]                         if (muffled) 
[10:22:49.826]                           invokeRestart("muffleWarning")
[10:22:49.826]                       }
[10:22:49.826]                       else if (inherits(cond, "condition")) {
[10:22:49.826]                         if (!is.null(pattern)) {
[10:22:49.826]                           computeRestarts <- base::computeRestarts
[10:22:49.826]                           grepl <- base::grepl
[10:22:49.826]                           restarts <- computeRestarts(cond)
[10:22:49.826]                           for (restart in restarts) {
[10:22:49.826]                             name <- restart$name
[10:22:49.826]                             if (is.null(name)) 
[10:22:49.826]                               next
[10:22:49.826]                             if (!grepl(pattern, name)) 
[10:22:49.826]                               next
[10:22:49.826]                             invokeRestart(restart)
[10:22:49.826]                             muffled <- TRUE
[10:22:49.826]                             break
[10:22:49.826]                           }
[10:22:49.826]                         }
[10:22:49.826]                       }
[10:22:49.826]                       invisible(muffled)
[10:22:49.826]                     }
[10:22:49.826]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.826]                   }
[10:22:49.826]                 }
[10:22:49.826]                 else {
[10:22:49.826]                   if (TRUE) {
[10:22:49.826]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.826]                     {
[10:22:49.826]                       inherits <- base::inherits
[10:22:49.826]                       invokeRestart <- base::invokeRestart
[10:22:49.826]                       is.null <- base::is.null
[10:22:49.826]                       muffled <- FALSE
[10:22:49.826]                       if (inherits(cond, "message")) {
[10:22:49.826]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.826]                         if (muffled) 
[10:22:49.826]                           invokeRestart("muffleMessage")
[10:22:49.826]                       }
[10:22:49.826]                       else if (inherits(cond, "warning")) {
[10:22:49.826]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.826]                         if (muffled) 
[10:22:49.826]                           invokeRestart("muffleWarning")
[10:22:49.826]                       }
[10:22:49.826]                       else if (inherits(cond, "condition")) {
[10:22:49.826]                         if (!is.null(pattern)) {
[10:22:49.826]                           computeRestarts <- base::computeRestarts
[10:22:49.826]                           grepl <- base::grepl
[10:22:49.826]                           restarts <- computeRestarts(cond)
[10:22:49.826]                           for (restart in restarts) {
[10:22:49.826]                             name <- restart$name
[10:22:49.826]                             if (is.null(name)) 
[10:22:49.826]                               next
[10:22:49.826]                             if (!grepl(pattern, name)) 
[10:22:49.826]                               next
[10:22:49.826]                             invokeRestart(restart)
[10:22:49.826]                             muffled <- TRUE
[10:22:49.826]                             break
[10:22:49.826]                           }
[10:22:49.826]                         }
[10:22:49.826]                       }
[10:22:49.826]                       invisible(muffled)
[10:22:49.826]                     }
[10:22:49.826]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.826]                   }
[10:22:49.826]                 }
[10:22:49.826]             }
[10:22:49.826]         }))
[10:22:49.826]     }, error = function(ex) {
[10:22:49.826]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:49.826]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.826]                 ...future.rng), started = ...future.startTime, 
[10:22:49.826]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:49.826]             version = "1.8"), class = "FutureResult")
[10:22:49.826]     }, finally = {
[10:22:49.826]         if (!identical(...future.workdir, getwd())) 
[10:22:49.826]             setwd(...future.workdir)
[10:22:49.826]         {
[10:22:49.826]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:49.826]                 ...future.oldOptions$nwarnings <- NULL
[10:22:49.826]             }
[10:22:49.826]             base::options(...future.oldOptions)
[10:22:49.826]             if (.Platform$OS.type == "windows") {
[10:22:49.826]                 old_names <- names(...future.oldEnvVars)
[10:22:49.826]                 envs <- base::Sys.getenv()
[10:22:49.826]                 names <- names(envs)
[10:22:49.826]                 common <- intersect(names, old_names)
[10:22:49.826]                 added <- setdiff(names, old_names)
[10:22:49.826]                 removed <- setdiff(old_names, names)
[10:22:49.826]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:49.826]                   envs[common]]
[10:22:49.826]                 NAMES <- toupper(changed)
[10:22:49.826]                 args <- list()
[10:22:49.826]                 for (kk in seq_along(NAMES)) {
[10:22:49.826]                   name <- changed[[kk]]
[10:22:49.826]                   NAME <- NAMES[[kk]]
[10:22:49.826]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.826]                     next
[10:22:49.826]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.826]                 }
[10:22:49.826]                 NAMES <- toupper(added)
[10:22:49.826]                 for (kk in seq_along(NAMES)) {
[10:22:49.826]                   name <- added[[kk]]
[10:22:49.826]                   NAME <- NAMES[[kk]]
[10:22:49.826]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.826]                     next
[10:22:49.826]                   args[[name]] <- ""
[10:22:49.826]                 }
[10:22:49.826]                 NAMES <- toupper(removed)
[10:22:49.826]                 for (kk in seq_along(NAMES)) {
[10:22:49.826]                   name <- removed[[kk]]
[10:22:49.826]                   NAME <- NAMES[[kk]]
[10:22:49.826]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.826]                     next
[10:22:49.826]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.826]                 }
[10:22:49.826]                 if (length(args) > 0) 
[10:22:49.826]                   base::do.call(base::Sys.setenv, args = args)
[10:22:49.826]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:49.826]             }
[10:22:49.826]             else {
[10:22:49.826]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:49.826]             }
[10:22:49.826]             {
[10:22:49.826]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:49.826]                   0L) {
[10:22:49.826]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:49.826]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:49.826]                   base::options(opts)
[10:22:49.826]                 }
[10:22:49.826]                 {
[10:22:49.826]                   {
[10:22:49.826]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:49.826]                     NULL
[10:22:49.826]                   }
[10:22:49.826]                   options(future.plan = NULL)
[10:22:49.826]                   if (is.na(NA_character_)) 
[10:22:49.826]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.826]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:49.826]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:49.826]                     .init = FALSE)
[10:22:49.826]                 }
[10:22:49.826]             }
[10:22:49.826]         }
[10:22:49.826]     })
[10:22:49.826]     if (TRUE) {
[10:22:49.826]         base::sink(type = "output", split = FALSE)
[10:22:49.826]         if (TRUE) {
[10:22:49.826]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:49.826]         }
[10:22:49.826]         else {
[10:22:49.826]             ...future.result["stdout"] <- base::list(NULL)
[10:22:49.826]         }
[10:22:49.826]         base::close(...future.stdout)
[10:22:49.826]         ...future.stdout <- NULL
[10:22:49.826]     }
[10:22:49.826]     ...future.result$conditions <- ...future.conditions
[10:22:49.826]     ...future.result$finished <- base::Sys.time()
[10:22:49.826]     ...future.result
[10:22:49.826] }
[10:22:49.829] MultisessionFuture started
[10:22:49.829] - Launch lazy future ... done
[10:22:49.829] run() for ‘MultisessionFuture’ ... done
[10:22:49.829] getGlobalsAndPackages() ...
[10:22:49.829] Searching for globals...
[10:22:49.830] - globals found: [1] ‘{’
[10:22:49.830] Searching for globals ... DONE
[10:22:49.830] Resolving globals: FALSE
[10:22:49.830] 
[10:22:49.830] 
[10:22:49.830] getGlobalsAndPackages() ... DONE
[10:22:49.831] run() for ‘Future’ ...
[10:22:49.831] - state: ‘created’
[10:22:49.831] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:49.845] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:49.845] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:49.845]   - Field: ‘node’
[10:22:49.845]   - Field: ‘label’
[10:22:49.845]   - Field: ‘local’
[10:22:49.845]   - Field: ‘owner’
[10:22:49.845]   - Field: ‘envir’
[10:22:49.845]   - Field: ‘workers’
[10:22:49.845]   - Field: ‘packages’
[10:22:49.846]   - Field: ‘gc’
[10:22:49.846]   - Field: ‘conditions’
[10:22:49.846]   - Field: ‘persistent’
[10:22:49.846]   - Field: ‘expr’
[10:22:49.846]   - Field: ‘uuid’
[10:22:49.846]   - Field: ‘seed’
[10:22:49.846]   - Field: ‘version’
[10:22:49.846]   - Field: ‘result’
[10:22:49.846]   - Field: ‘asynchronous’
[10:22:49.846]   - Field: ‘calls’
[10:22:49.846]   - Field: ‘globals’
[10:22:49.846]   - Field: ‘stdout’
[10:22:49.847]   - Field: ‘earlySignal’
[10:22:49.847]   - Field: ‘lazy’
[10:22:49.847]   - Field: ‘state’
[10:22:49.847] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:49.847] - Launch lazy future ...
[10:22:49.847] Packages needed by the future expression (n = 0): <none>
[10:22:49.847] Packages needed by future strategies (n = 0): <none>
[10:22:49.848] {
[10:22:49.848]     {
[10:22:49.848]         {
[10:22:49.848]             ...future.startTime <- base::Sys.time()
[10:22:49.848]             {
[10:22:49.848]                 {
[10:22:49.848]                   {
[10:22:49.848]                     {
[10:22:49.848]                       base::local({
[10:22:49.848]                         has_future <- base::requireNamespace("future", 
[10:22:49.848]                           quietly = TRUE)
[10:22:49.848]                         if (has_future) {
[10:22:49.848]                           ns <- base::getNamespace("future")
[10:22:49.848]                           version <- ns[[".package"]][["version"]]
[10:22:49.848]                           if (is.null(version)) 
[10:22:49.848]                             version <- utils::packageVersion("future")
[10:22:49.848]                         }
[10:22:49.848]                         else {
[10:22:49.848]                           version <- NULL
[10:22:49.848]                         }
[10:22:49.848]                         if (!has_future || version < "1.8.0") {
[10:22:49.848]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:49.848]                             "", base::R.version$version.string), 
[10:22:49.848]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:49.848]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:49.848]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:49.848]                               "release", "version")], collapse = " "), 
[10:22:49.848]                             hostname = base::Sys.info()[["nodename"]])
[10:22:49.848]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:49.848]                             info)
[10:22:49.848]                           info <- base::paste(info, collapse = "; ")
[10:22:49.848]                           if (!has_future) {
[10:22:49.848]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:49.848]                               info)
[10:22:49.848]                           }
[10:22:49.848]                           else {
[10:22:49.848]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:49.848]                               info, version)
[10:22:49.848]                           }
[10:22:49.848]                           base::stop(msg)
[10:22:49.848]                         }
[10:22:49.848]                       })
[10:22:49.848]                     }
[10:22:49.848]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:49.848]                     base::options(mc.cores = 1L)
[10:22:49.848]                   }
[10:22:49.848]                   ...future.strategy.old <- future::plan("list")
[10:22:49.848]                   options(future.plan = NULL)
[10:22:49.848]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.848]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:49.848]                 }
[10:22:49.848]                 ...future.workdir <- getwd()
[10:22:49.848]             }
[10:22:49.848]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:49.848]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:49.848]         }
[10:22:49.848]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:49.848]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:49.848]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:49.848]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:49.848]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:49.848]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:49.848]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:49.848]             base::names(...future.oldOptions))
[10:22:49.848]     }
[10:22:49.848]     if (FALSE) {
[10:22:49.848]     }
[10:22:49.848]     else {
[10:22:49.848]         if (TRUE) {
[10:22:49.848]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:49.848]                 open = "w")
[10:22:49.848]         }
[10:22:49.848]         else {
[10:22:49.848]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:49.848]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:49.848]         }
[10:22:49.848]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:49.848]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:49.848]             base::sink(type = "output", split = FALSE)
[10:22:49.848]             base::close(...future.stdout)
[10:22:49.848]         }, add = TRUE)
[10:22:49.848]     }
[10:22:49.848]     ...future.frame <- base::sys.nframe()
[10:22:49.848]     ...future.conditions <- base::list()
[10:22:49.848]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:49.848]     if (FALSE) {
[10:22:49.848]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:49.848]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:49.848]     }
[10:22:49.848]     ...future.result <- base::tryCatch({
[10:22:49.848]         base::withCallingHandlers({
[10:22:49.848]             ...future.value <- base::withVisible(base::local({
[10:22:49.848]                 ...future.makeSendCondition <- base::local({
[10:22:49.848]                   sendCondition <- NULL
[10:22:49.848]                   function(frame = 1L) {
[10:22:49.848]                     if (is.function(sendCondition)) 
[10:22:49.848]                       return(sendCondition)
[10:22:49.848]                     ns <- getNamespace("parallel")
[10:22:49.848]                     if (exists("sendData", mode = "function", 
[10:22:49.848]                       envir = ns)) {
[10:22:49.848]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:49.848]                         envir = ns)
[10:22:49.848]                       envir <- sys.frame(frame)
[10:22:49.848]                       master <- NULL
[10:22:49.848]                       while (!identical(envir, .GlobalEnv) && 
[10:22:49.848]                         !identical(envir, emptyenv())) {
[10:22:49.848]                         if (exists("master", mode = "list", envir = envir, 
[10:22:49.848]                           inherits = FALSE)) {
[10:22:49.848]                           master <- get("master", mode = "list", 
[10:22:49.848]                             envir = envir, inherits = FALSE)
[10:22:49.848]                           if (inherits(master, c("SOCKnode", 
[10:22:49.848]                             "SOCK0node"))) {
[10:22:49.848]                             sendCondition <<- function(cond) {
[10:22:49.848]                               data <- list(type = "VALUE", value = cond, 
[10:22:49.848]                                 success = TRUE)
[10:22:49.848]                               parallel_sendData(master, data)
[10:22:49.848]                             }
[10:22:49.848]                             return(sendCondition)
[10:22:49.848]                           }
[10:22:49.848]                         }
[10:22:49.848]                         frame <- frame + 1L
[10:22:49.848]                         envir <- sys.frame(frame)
[10:22:49.848]                       }
[10:22:49.848]                     }
[10:22:49.848]                     sendCondition <<- function(cond) NULL
[10:22:49.848]                   }
[10:22:49.848]                 })
[10:22:49.848]                 withCallingHandlers({
[10:22:49.848]                   {
[10:22:49.848]                     2
[10:22:49.848]                   }
[10:22:49.848]                 }, immediateCondition = function(cond) {
[10:22:49.848]                   sendCondition <- ...future.makeSendCondition()
[10:22:49.848]                   sendCondition(cond)
[10:22:49.848]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.848]                   {
[10:22:49.848]                     inherits <- base::inherits
[10:22:49.848]                     invokeRestart <- base::invokeRestart
[10:22:49.848]                     is.null <- base::is.null
[10:22:49.848]                     muffled <- FALSE
[10:22:49.848]                     if (inherits(cond, "message")) {
[10:22:49.848]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:49.848]                       if (muffled) 
[10:22:49.848]                         invokeRestart("muffleMessage")
[10:22:49.848]                     }
[10:22:49.848]                     else if (inherits(cond, "warning")) {
[10:22:49.848]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:49.848]                       if (muffled) 
[10:22:49.848]                         invokeRestart("muffleWarning")
[10:22:49.848]                     }
[10:22:49.848]                     else if (inherits(cond, "condition")) {
[10:22:49.848]                       if (!is.null(pattern)) {
[10:22:49.848]                         computeRestarts <- base::computeRestarts
[10:22:49.848]                         grepl <- base::grepl
[10:22:49.848]                         restarts <- computeRestarts(cond)
[10:22:49.848]                         for (restart in restarts) {
[10:22:49.848]                           name <- restart$name
[10:22:49.848]                           if (is.null(name)) 
[10:22:49.848]                             next
[10:22:49.848]                           if (!grepl(pattern, name)) 
[10:22:49.848]                             next
[10:22:49.848]                           invokeRestart(restart)
[10:22:49.848]                           muffled <- TRUE
[10:22:49.848]                           break
[10:22:49.848]                         }
[10:22:49.848]                       }
[10:22:49.848]                     }
[10:22:49.848]                     invisible(muffled)
[10:22:49.848]                   }
[10:22:49.848]                   muffleCondition(cond)
[10:22:49.848]                 })
[10:22:49.848]             }))
[10:22:49.848]             future::FutureResult(value = ...future.value$value, 
[10:22:49.848]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.848]                   ...future.rng), globalenv = if (FALSE) 
[10:22:49.848]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:49.848]                     ...future.globalenv.names))
[10:22:49.848]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:49.848]         }, condition = base::local({
[10:22:49.848]             c <- base::c
[10:22:49.848]             inherits <- base::inherits
[10:22:49.848]             invokeRestart <- base::invokeRestart
[10:22:49.848]             length <- base::length
[10:22:49.848]             list <- base::list
[10:22:49.848]             seq.int <- base::seq.int
[10:22:49.848]             signalCondition <- base::signalCondition
[10:22:49.848]             sys.calls <- base::sys.calls
[10:22:49.848]             `[[` <- base::`[[`
[10:22:49.848]             `+` <- base::`+`
[10:22:49.848]             `<<-` <- base::`<<-`
[10:22:49.848]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:49.848]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:49.848]                   3L)]
[10:22:49.848]             }
[10:22:49.848]             function(cond) {
[10:22:49.848]                 is_error <- inherits(cond, "error")
[10:22:49.848]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:49.848]                   NULL)
[10:22:49.848]                 if (is_error) {
[10:22:49.848]                   sessionInformation <- function() {
[10:22:49.848]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:49.848]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:49.848]                       search = base::search(), system = base::Sys.info())
[10:22:49.848]                   }
[10:22:49.848]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.848]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:49.848]                     cond$call), session = sessionInformation(), 
[10:22:49.848]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:49.848]                   signalCondition(cond)
[10:22:49.848]                 }
[10:22:49.848]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:49.848]                 "immediateCondition"))) {
[10:22:49.848]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:49.848]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.848]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:49.848]                   if (TRUE && !signal) {
[10:22:49.848]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.848]                     {
[10:22:49.848]                       inherits <- base::inherits
[10:22:49.848]                       invokeRestart <- base::invokeRestart
[10:22:49.848]                       is.null <- base::is.null
[10:22:49.848]                       muffled <- FALSE
[10:22:49.848]                       if (inherits(cond, "message")) {
[10:22:49.848]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.848]                         if (muffled) 
[10:22:49.848]                           invokeRestart("muffleMessage")
[10:22:49.848]                       }
[10:22:49.848]                       else if (inherits(cond, "warning")) {
[10:22:49.848]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.848]                         if (muffled) 
[10:22:49.848]                           invokeRestart("muffleWarning")
[10:22:49.848]                       }
[10:22:49.848]                       else if (inherits(cond, "condition")) {
[10:22:49.848]                         if (!is.null(pattern)) {
[10:22:49.848]                           computeRestarts <- base::computeRestarts
[10:22:49.848]                           grepl <- base::grepl
[10:22:49.848]                           restarts <- computeRestarts(cond)
[10:22:49.848]                           for (restart in restarts) {
[10:22:49.848]                             name <- restart$name
[10:22:49.848]                             if (is.null(name)) 
[10:22:49.848]                               next
[10:22:49.848]                             if (!grepl(pattern, name)) 
[10:22:49.848]                               next
[10:22:49.848]                             invokeRestart(restart)
[10:22:49.848]                             muffled <- TRUE
[10:22:49.848]                             break
[10:22:49.848]                           }
[10:22:49.848]                         }
[10:22:49.848]                       }
[10:22:49.848]                       invisible(muffled)
[10:22:49.848]                     }
[10:22:49.848]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.848]                   }
[10:22:49.848]                 }
[10:22:49.848]                 else {
[10:22:49.848]                   if (TRUE) {
[10:22:49.848]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.848]                     {
[10:22:49.848]                       inherits <- base::inherits
[10:22:49.848]                       invokeRestart <- base::invokeRestart
[10:22:49.848]                       is.null <- base::is.null
[10:22:49.848]                       muffled <- FALSE
[10:22:49.848]                       if (inherits(cond, "message")) {
[10:22:49.848]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.848]                         if (muffled) 
[10:22:49.848]                           invokeRestart("muffleMessage")
[10:22:49.848]                       }
[10:22:49.848]                       else if (inherits(cond, "warning")) {
[10:22:49.848]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.848]                         if (muffled) 
[10:22:49.848]                           invokeRestart("muffleWarning")
[10:22:49.848]                       }
[10:22:49.848]                       else if (inherits(cond, "condition")) {
[10:22:49.848]                         if (!is.null(pattern)) {
[10:22:49.848]                           computeRestarts <- base::computeRestarts
[10:22:49.848]                           grepl <- base::grepl
[10:22:49.848]                           restarts <- computeRestarts(cond)
[10:22:49.848]                           for (restart in restarts) {
[10:22:49.848]                             name <- restart$name
[10:22:49.848]                             if (is.null(name)) 
[10:22:49.848]                               next
[10:22:49.848]                             if (!grepl(pattern, name)) 
[10:22:49.848]                               next
[10:22:49.848]                             invokeRestart(restart)
[10:22:49.848]                             muffled <- TRUE
[10:22:49.848]                             break
[10:22:49.848]                           }
[10:22:49.848]                         }
[10:22:49.848]                       }
[10:22:49.848]                       invisible(muffled)
[10:22:49.848]                     }
[10:22:49.848]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.848]                   }
[10:22:49.848]                 }
[10:22:49.848]             }
[10:22:49.848]         }))
[10:22:49.848]     }, error = function(ex) {
[10:22:49.848]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:49.848]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.848]                 ...future.rng), started = ...future.startTime, 
[10:22:49.848]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:49.848]             version = "1.8"), class = "FutureResult")
[10:22:49.848]     }, finally = {
[10:22:49.848]         if (!identical(...future.workdir, getwd())) 
[10:22:49.848]             setwd(...future.workdir)
[10:22:49.848]         {
[10:22:49.848]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:49.848]                 ...future.oldOptions$nwarnings <- NULL
[10:22:49.848]             }
[10:22:49.848]             base::options(...future.oldOptions)
[10:22:49.848]             if (.Platform$OS.type == "windows") {
[10:22:49.848]                 old_names <- names(...future.oldEnvVars)
[10:22:49.848]                 envs <- base::Sys.getenv()
[10:22:49.848]                 names <- names(envs)
[10:22:49.848]                 common <- intersect(names, old_names)
[10:22:49.848]                 added <- setdiff(names, old_names)
[10:22:49.848]                 removed <- setdiff(old_names, names)
[10:22:49.848]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:49.848]                   envs[common]]
[10:22:49.848]                 NAMES <- toupper(changed)
[10:22:49.848]                 args <- list()
[10:22:49.848]                 for (kk in seq_along(NAMES)) {
[10:22:49.848]                   name <- changed[[kk]]
[10:22:49.848]                   NAME <- NAMES[[kk]]
[10:22:49.848]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.848]                     next
[10:22:49.848]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.848]                 }
[10:22:49.848]                 NAMES <- toupper(added)
[10:22:49.848]                 for (kk in seq_along(NAMES)) {
[10:22:49.848]                   name <- added[[kk]]
[10:22:49.848]                   NAME <- NAMES[[kk]]
[10:22:49.848]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.848]                     next
[10:22:49.848]                   args[[name]] <- ""
[10:22:49.848]                 }
[10:22:49.848]                 NAMES <- toupper(removed)
[10:22:49.848]                 for (kk in seq_along(NAMES)) {
[10:22:49.848]                   name <- removed[[kk]]
[10:22:49.848]                   NAME <- NAMES[[kk]]
[10:22:49.848]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.848]                     next
[10:22:49.848]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.848]                 }
[10:22:49.848]                 if (length(args) > 0) 
[10:22:49.848]                   base::do.call(base::Sys.setenv, args = args)
[10:22:49.848]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:49.848]             }
[10:22:49.848]             else {
[10:22:49.848]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:49.848]             }
[10:22:49.848]             {
[10:22:49.848]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:49.848]                   0L) {
[10:22:49.848]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:49.848]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:49.848]                   base::options(opts)
[10:22:49.848]                 }
[10:22:49.848]                 {
[10:22:49.848]                   {
[10:22:49.848]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:49.848]                     NULL
[10:22:49.848]                   }
[10:22:49.848]                   options(future.plan = NULL)
[10:22:49.848]                   if (is.na(NA_character_)) 
[10:22:49.848]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.848]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:49.848]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:49.848]                     .init = FALSE)
[10:22:49.848]                 }
[10:22:49.848]             }
[10:22:49.848]         }
[10:22:49.848]     })
[10:22:49.848]     if (TRUE) {
[10:22:49.848]         base::sink(type = "output", split = FALSE)
[10:22:49.848]         if (TRUE) {
[10:22:49.848]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:49.848]         }
[10:22:49.848]         else {
[10:22:49.848]             ...future.result["stdout"] <- base::list(NULL)
[10:22:49.848]         }
[10:22:49.848]         base::close(...future.stdout)
[10:22:49.848]         ...future.stdout <- NULL
[10:22:49.848]     }
[10:22:49.848]     ...future.result$conditions <- ...future.conditions
[10:22:49.848]     ...future.result$finished <- base::Sys.time()
[10:22:49.848]     ...future.result
[10:22:49.848] }
[10:22:49.851] MultisessionFuture started
[10:22:49.851] - Launch lazy future ... done
[10:22:49.851] run() for ‘MultisessionFuture’ ... done
[10:22:49.851] resolve() on environment ...
[10:22:49.851]  recursive: 0
[10:22:49.852]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[10:22:49.873]  length: 2 (resolved future 3)
[10:22:49.883] receiveMessageFromWorker() for ClusterFuture ...
[10:22:49.884] - Validating connection of MultisessionFuture
[10:22:49.884] - received message: FutureResult
[10:22:49.884] - Received FutureResult
[10:22:49.884] - Erased future from FutureRegistry
[10:22:49.884] result() for ClusterFuture ...
[10:22:49.884] - result already collected: FutureResult
[10:22:49.884] result() for ClusterFuture ... done
[10:22:49.885] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:49.885] Future #1
[10:22:49.885]  length: 1 (resolved future 1)
[10:22:49.893] receiveMessageFromWorker() for ClusterFuture ...
[10:22:49.893] - Validating connection of MultisessionFuture
[10:22:49.893] - received message: FutureResult
[10:22:49.893] - Received FutureResult
[10:22:49.894] - Erased future from FutureRegistry
[10:22:49.894] result() for ClusterFuture ...
[10:22:49.894] - result already collected: FutureResult
[10:22:49.894] result() for ClusterFuture ... done
[10:22:49.894] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:49.894] Future #2
[10:22:49.894]  length: 0 (resolved future 2)
[10:22:49.894] resolve() on environment ... DONE
[10:22:49.895] getGlobalsAndPackages() ...
[10:22:49.895] Searching for globals...
[10:22:49.895] - globals found: [1] ‘{’
[10:22:49.896] Searching for globals ... DONE
[10:22:49.896] Resolving globals: FALSE
[10:22:49.896] 
[10:22:49.896] 
[10:22:49.896] getGlobalsAndPackages() ... DONE
[10:22:49.896] run() for ‘Future’ ...
[10:22:49.896] - state: ‘created’
[10:22:49.897] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:49.910] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:49.910] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:49.910]   - Field: ‘node’
[10:22:49.910]   - Field: ‘label’
[10:22:49.910]   - Field: ‘local’
[10:22:49.911]   - Field: ‘owner’
[10:22:49.911]   - Field: ‘envir’
[10:22:49.911]   - Field: ‘workers’
[10:22:49.911]   - Field: ‘packages’
[10:22:49.911]   - Field: ‘gc’
[10:22:49.911]   - Field: ‘conditions’
[10:22:49.911]   - Field: ‘persistent’
[10:22:49.911]   - Field: ‘expr’
[10:22:49.911]   - Field: ‘uuid’
[10:22:49.911]   - Field: ‘seed’
[10:22:49.911]   - Field: ‘version’
[10:22:49.912]   - Field: ‘result’
[10:22:49.912]   - Field: ‘asynchronous’
[10:22:49.912]   - Field: ‘calls’
[10:22:49.912]   - Field: ‘globals’
[10:22:49.912]   - Field: ‘stdout’
[10:22:49.912]   - Field: ‘earlySignal’
[10:22:49.912]   - Field: ‘lazy’
[10:22:49.912]   - Field: ‘state’
[10:22:49.912] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:49.912] - Launch lazy future ...
[10:22:49.913] Packages needed by the future expression (n = 0): <none>
[10:22:49.913] Packages needed by future strategies (n = 0): <none>
[10:22:49.913] {
[10:22:49.913]     {
[10:22:49.913]         {
[10:22:49.913]             ...future.startTime <- base::Sys.time()
[10:22:49.913]             {
[10:22:49.913]                 {
[10:22:49.913]                   {
[10:22:49.913]                     {
[10:22:49.913]                       base::local({
[10:22:49.913]                         has_future <- base::requireNamespace("future", 
[10:22:49.913]                           quietly = TRUE)
[10:22:49.913]                         if (has_future) {
[10:22:49.913]                           ns <- base::getNamespace("future")
[10:22:49.913]                           version <- ns[[".package"]][["version"]]
[10:22:49.913]                           if (is.null(version)) 
[10:22:49.913]                             version <- utils::packageVersion("future")
[10:22:49.913]                         }
[10:22:49.913]                         else {
[10:22:49.913]                           version <- NULL
[10:22:49.913]                         }
[10:22:49.913]                         if (!has_future || version < "1.8.0") {
[10:22:49.913]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:49.913]                             "", base::R.version$version.string), 
[10:22:49.913]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:49.913]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:49.913]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:49.913]                               "release", "version")], collapse = " "), 
[10:22:49.913]                             hostname = base::Sys.info()[["nodename"]])
[10:22:49.913]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:49.913]                             info)
[10:22:49.913]                           info <- base::paste(info, collapse = "; ")
[10:22:49.913]                           if (!has_future) {
[10:22:49.913]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:49.913]                               info)
[10:22:49.913]                           }
[10:22:49.913]                           else {
[10:22:49.913]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:49.913]                               info, version)
[10:22:49.913]                           }
[10:22:49.913]                           base::stop(msg)
[10:22:49.913]                         }
[10:22:49.913]                       })
[10:22:49.913]                     }
[10:22:49.913]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:49.913]                     base::options(mc.cores = 1L)
[10:22:49.913]                   }
[10:22:49.913]                   ...future.strategy.old <- future::plan("list")
[10:22:49.913]                   options(future.plan = NULL)
[10:22:49.913]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.913]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:49.913]                 }
[10:22:49.913]                 ...future.workdir <- getwd()
[10:22:49.913]             }
[10:22:49.913]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:49.913]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:49.913]         }
[10:22:49.913]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:49.913]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:49.913]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:49.913]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:49.913]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:49.913]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:49.913]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:49.913]             base::names(...future.oldOptions))
[10:22:49.913]     }
[10:22:49.913]     if (FALSE) {
[10:22:49.913]     }
[10:22:49.913]     else {
[10:22:49.913]         if (TRUE) {
[10:22:49.913]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:49.913]                 open = "w")
[10:22:49.913]         }
[10:22:49.913]         else {
[10:22:49.913]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:49.913]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:49.913]         }
[10:22:49.913]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:49.913]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:49.913]             base::sink(type = "output", split = FALSE)
[10:22:49.913]             base::close(...future.stdout)
[10:22:49.913]         }, add = TRUE)
[10:22:49.913]     }
[10:22:49.913]     ...future.frame <- base::sys.nframe()
[10:22:49.913]     ...future.conditions <- base::list()
[10:22:49.913]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:49.913]     if (FALSE) {
[10:22:49.913]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:49.913]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:49.913]     }
[10:22:49.913]     ...future.result <- base::tryCatch({
[10:22:49.913]         base::withCallingHandlers({
[10:22:49.913]             ...future.value <- base::withVisible(base::local({
[10:22:49.913]                 ...future.makeSendCondition <- base::local({
[10:22:49.913]                   sendCondition <- NULL
[10:22:49.913]                   function(frame = 1L) {
[10:22:49.913]                     if (is.function(sendCondition)) 
[10:22:49.913]                       return(sendCondition)
[10:22:49.913]                     ns <- getNamespace("parallel")
[10:22:49.913]                     if (exists("sendData", mode = "function", 
[10:22:49.913]                       envir = ns)) {
[10:22:49.913]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:49.913]                         envir = ns)
[10:22:49.913]                       envir <- sys.frame(frame)
[10:22:49.913]                       master <- NULL
[10:22:49.913]                       while (!identical(envir, .GlobalEnv) && 
[10:22:49.913]                         !identical(envir, emptyenv())) {
[10:22:49.913]                         if (exists("master", mode = "list", envir = envir, 
[10:22:49.913]                           inherits = FALSE)) {
[10:22:49.913]                           master <- get("master", mode = "list", 
[10:22:49.913]                             envir = envir, inherits = FALSE)
[10:22:49.913]                           if (inherits(master, c("SOCKnode", 
[10:22:49.913]                             "SOCK0node"))) {
[10:22:49.913]                             sendCondition <<- function(cond) {
[10:22:49.913]                               data <- list(type = "VALUE", value = cond, 
[10:22:49.913]                                 success = TRUE)
[10:22:49.913]                               parallel_sendData(master, data)
[10:22:49.913]                             }
[10:22:49.913]                             return(sendCondition)
[10:22:49.913]                           }
[10:22:49.913]                         }
[10:22:49.913]                         frame <- frame + 1L
[10:22:49.913]                         envir <- sys.frame(frame)
[10:22:49.913]                       }
[10:22:49.913]                     }
[10:22:49.913]                     sendCondition <<- function(cond) NULL
[10:22:49.913]                   }
[10:22:49.913]                 })
[10:22:49.913]                 withCallingHandlers({
[10:22:49.913]                   {
[10:22:49.913]                     1
[10:22:49.913]                   }
[10:22:49.913]                 }, immediateCondition = function(cond) {
[10:22:49.913]                   sendCondition <- ...future.makeSendCondition()
[10:22:49.913]                   sendCondition(cond)
[10:22:49.913]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.913]                   {
[10:22:49.913]                     inherits <- base::inherits
[10:22:49.913]                     invokeRestart <- base::invokeRestart
[10:22:49.913]                     is.null <- base::is.null
[10:22:49.913]                     muffled <- FALSE
[10:22:49.913]                     if (inherits(cond, "message")) {
[10:22:49.913]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:49.913]                       if (muffled) 
[10:22:49.913]                         invokeRestart("muffleMessage")
[10:22:49.913]                     }
[10:22:49.913]                     else if (inherits(cond, "warning")) {
[10:22:49.913]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:49.913]                       if (muffled) 
[10:22:49.913]                         invokeRestart("muffleWarning")
[10:22:49.913]                     }
[10:22:49.913]                     else if (inherits(cond, "condition")) {
[10:22:49.913]                       if (!is.null(pattern)) {
[10:22:49.913]                         computeRestarts <- base::computeRestarts
[10:22:49.913]                         grepl <- base::grepl
[10:22:49.913]                         restarts <- computeRestarts(cond)
[10:22:49.913]                         for (restart in restarts) {
[10:22:49.913]                           name <- restart$name
[10:22:49.913]                           if (is.null(name)) 
[10:22:49.913]                             next
[10:22:49.913]                           if (!grepl(pattern, name)) 
[10:22:49.913]                             next
[10:22:49.913]                           invokeRestart(restart)
[10:22:49.913]                           muffled <- TRUE
[10:22:49.913]                           break
[10:22:49.913]                         }
[10:22:49.913]                       }
[10:22:49.913]                     }
[10:22:49.913]                     invisible(muffled)
[10:22:49.913]                   }
[10:22:49.913]                   muffleCondition(cond)
[10:22:49.913]                 })
[10:22:49.913]             }))
[10:22:49.913]             future::FutureResult(value = ...future.value$value, 
[10:22:49.913]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.913]                   ...future.rng), globalenv = if (FALSE) 
[10:22:49.913]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:49.913]                     ...future.globalenv.names))
[10:22:49.913]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:49.913]         }, condition = base::local({
[10:22:49.913]             c <- base::c
[10:22:49.913]             inherits <- base::inherits
[10:22:49.913]             invokeRestart <- base::invokeRestart
[10:22:49.913]             length <- base::length
[10:22:49.913]             list <- base::list
[10:22:49.913]             seq.int <- base::seq.int
[10:22:49.913]             signalCondition <- base::signalCondition
[10:22:49.913]             sys.calls <- base::sys.calls
[10:22:49.913]             `[[` <- base::`[[`
[10:22:49.913]             `+` <- base::`+`
[10:22:49.913]             `<<-` <- base::`<<-`
[10:22:49.913]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:49.913]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:49.913]                   3L)]
[10:22:49.913]             }
[10:22:49.913]             function(cond) {
[10:22:49.913]                 is_error <- inherits(cond, "error")
[10:22:49.913]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:49.913]                   NULL)
[10:22:49.913]                 if (is_error) {
[10:22:49.913]                   sessionInformation <- function() {
[10:22:49.913]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:49.913]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:49.913]                       search = base::search(), system = base::Sys.info())
[10:22:49.913]                   }
[10:22:49.913]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.913]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:49.913]                     cond$call), session = sessionInformation(), 
[10:22:49.913]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:49.913]                   signalCondition(cond)
[10:22:49.913]                 }
[10:22:49.913]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:49.913]                 "immediateCondition"))) {
[10:22:49.913]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:49.913]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.913]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:49.913]                   if (TRUE && !signal) {
[10:22:49.913]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.913]                     {
[10:22:49.913]                       inherits <- base::inherits
[10:22:49.913]                       invokeRestart <- base::invokeRestart
[10:22:49.913]                       is.null <- base::is.null
[10:22:49.913]                       muffled <- FALSE
[10:22:49.913]                       if (inherits(cond, "message")) {
[10:22:49.913]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.913]                         if (muffled) 
[10:22:49.913]                           invokeRestart("muffleMessage")
[10:22:49.913]                       }
[10:22:49.913]                       else if (inherits(cond, "warning")) {
[10:22:49.913]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.913]                         if (muffled) 
[10:22:49.913]                           invokeRestart("muffleWarning")
[10:22:49.913]                       }
[10:22:49.913]                       else if (inherits(cond, "condition")) {
[10:22:49.913]                         if (!is.null(pattern)) {
[10:22:49.913]                           computeRestarts <- base::computeRestarts
[10:22:49.913]                           grepl <- base::grepl
[10:22:49.913]                           restarts <- computeRestarts(cond)
[10:22:49.913]                           for (restart in restarts) {
[10:22:49.913]                             name <- restart$name
[10:22:49.913]                             if (is.null(name)) 
[10:22:49.913]                               next
[10:22:49.913]                             if (!grepl(pattern, name)) 
[10:22:49.913]                               next
[10:22:49.913]                             invokeRestart(restart)
[10:22:49.913]                             muffled <- TRUE
[10:22:49.913]                             break
[10:22:49.913]                           }
[10:22:49.913]                         }
[10:22:49.913]                       }
[10:22:49.913]                       invisible(muffled)
[10:22:49.913]                     }
[10:22:49.913]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.913]                   }
[10:22:49.913]                 }
[10:22:49.913]                 else {
[10:22:49.913]                   if (TRUE) {
[10:22:49.913]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.913]                     {
[10:22:49.913]                       inherits <- base::inherits
[10:22:49.913]                       invokeRestart <- base::invokeRestart
[10:22:49.913]                       is.null <- base::is.null
[10:22:49.913]                       muffled <- FALSE
[10:22:49.913]                       if (inherits(cond, "message")) {
[10:22:49.913]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.913]                         if (muffled) 
[10:22:49.913]                           invokeRestart("muffleMessage")
[10:22:49.913]                       }
[10:22:49.913]                       else if (inherits(cond, "warning")) {
[10:22:49.913]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.913]                         if (muffled) 
[10:22:49.913]                           invokeRestart("muffleWarning")
[10:22:49.913]                       }
[10:22:49.913]                       else if (inherits(cond, "condition")) {
[10:22:49.913]                         if (!is.null(pattern)) {
[10:22:49.913]                           computeRestarts <- base::computeRestarts
[10:22:49.913]                           grepl <- base::grepl
[10:22:49.913]                           restarts <- computeRestarts(cond)
[10:22:49.913]                           for (restart in restarts) {
[10:22:49.913]                             name <- restart$name
[10:22:49.913]                             if (is.null(name)) 
[10:22:49.913]                               next
[10:22:49.913]                             if (!grepl(pattern, name)) 
[10:22:49.913]                               next
[10:22:49.913]                             invokeRestart(restart)
[10:22:49.913]                             muffled <- TRUE
[10:22:49.913]                             break
[10:22:49.913]                           }
[10:22:49.913]                         }
[10:22:49.913]                       }
[10:22:49.913]                       invisible(muffled)
[10:22:49.913]                     }
[10:22:49.913]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.913]                   }
[10:22:49.913]                 }
[10:22:49.913]             }
[10:22:49.913]         }))
[10:22:49.913]     }, error = function(ex) {
[10:22:49.913]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:49.913]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.913]                 ...future.rng), started = ...future.startTime, 
[10:22:49.913]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:49.913]             version = "1.8"), class = "FutureResult")
[10:22:49.913]     }, finally = {
[10:22:49.913]         if (!identical(...future.workdir, getwd())) 
[10:22:49.913]             setwd(...future.workdir)
[10:22:49.913]         {
[10:22:49.913]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:49.913]                 ...future.oldOptions$nwarnings <- NULL
[10:22:49.913]             }
[10:22:49.913]             base::options(...future.oldOptions)
[10:22:49.913]             if (.Platform$OS.type == "windows") {
[10:22:49.913]                 old_names <- names(...future.oldEnvVars)
[10:22:49.913]                 envs <- base::Sys.getenv()
[10:22:49.913]                 names <- names(envs)
[10:22:49.913]                 common <- intersect(names, old_names)
[10:22:49.913]                 added <- setdiff(names, old_names)
[10:22:49.913]                 removed <- setdiff(old_names, names)
[10:22:49.913]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:49.913]                   envs[common]]
[10:22:49.913]                 NAMES <- toupper(changed)
[10:22:49.913]                 args <- list()
[10:22:49.913]                 for (kk in seq_along(NAMES)) {
[10:22:49.913]                   name <- changed[[kk]]
[10:22:49.913]                   NAME <- NAMES[[kk]]
[10:22:49.913]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.913]                     next
[10:22:49.913]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.913]                 }
[10:22:49.913]                 NAMES <- toupper(added)
[10:22:49.913]                 for (kk in seq_along(NAMES)) {
[10:22:49.913]                   name <- added[[kk]]
[10:22:49.913]                   NAME <- NAMES[[kk]]
[10:22:49.913]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.913]                     next
[10:22:49.913]                   args[[name]] <- ""
[10:22:49.913]                 }
[10:22:49.913]                 NAMES <- toupper(removed)
[10:22:49.913]                 for (kk in seq_along(NAMES)) {
[10:22:49.913]                   name <- removed[[kk]]
[10:22:49.913]                   NAME <- NAMES[[kk]]
[10:22:49.913]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.913]                     next
[10:22:49.913]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.913]                 }
[10:22:49.913]                 if (length(args) > 0) 
[10:22:49.913]                   base::do.call(base::Sys.setenv, args = args)
[10:22:49.913]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:49.913]             }
[10:22:49.913]             else {
[10:22:49.913]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:49.913]             }
[10:22:49.913]             {
[10:22:49.913]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:49.913]                   0L) {
[10:22:49.913]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:49.913]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:49.913]                   base::options(opts)
[10:22:49.913]                 }
[10:22:49.913]                 {
[10:22:49.913]                   {
[10:22:49.913]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:49.913]                     NULL
[10:22:49.913]                   }
[10:22:49.913]                   options(future.plan = NULL)
[10:22:49.913]                   if (is.na(NA_character_)) 
[10:22:49.913]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.913]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:49.913]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:49.913]                     .init = FALSE)
[10:22:49.913]                 }
[10:22:49.913]             }
[10:22:49.913]         }
[10:22:49.913]     })
[10:22:49.913]     if (TRUE) {
[10:22:49.913]         base::sink(type = "output", split = FALSE)
[10:22:49.913]         if (TRUE) {
[10:22:49.913]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:49.913]         }
[10:22:49.913]         else {
[10:22:49.913]             ...future.result["stdout"] <- base::list(NULL)
[10:22:49.913]         }
[10:22:49.913]         base::close(...future.stdout)
[10:22:49.913]         ...future.stdout <- NULL
[10:22:49.913]     }
[10:22:49.913]     ...future.result$conditions <- ...future.conditions
[10:22:49.913]     ...future.result$finished <- base::Sys.time()
[10:22:49.913]     ...future.result
[10:22:49.913] }
[10:22:49.916] MultisessionFuture started
[10:22:49.916] - Launch lazy future ... done
[10:22:49.916] run() for ‘MultisessionFuture’ ... done
[10:22:49.917] getGlobalsAndPackages() ...
[10:22:49.917] Searching for globals...
[10:22:49.917] - globals found: [1] ‘{’
[10:22:49.917] Searching for globals ... DONE
[10:22:49.917] Resolving globals: FALSE
[10:22:49.918] 
[10:22:49.918] 
[10:22:49.918] getGlobalsAndPackages() ... DONE
[10:22:49.918] run() for ‘Future’ ...
[10:22:49.918] - state: ‘created’
[10:22:49.918] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:49.932] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:49.932] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:49.932]   - Field: ‘node’
[10:22:49.932]   - Field: ‘label’
[10:22:49.932]   - Field: ‘local’
[10:22:49.932]   - Field: ‘owner’
[10:22:49.933]   - Field: ‘envir’
[10:22:49.933]   - Field: ‘workers’
[10:22:49.933]   - Field: ‘packages’
[10:22:49.933]   - Field: ‘gc’
[10:22:49.933]   - Field: ‘conditions’
[10:22:49.933]   - Field: ‘persistent’
[10:22:49.933]   - Field: ‘expr’
[10:22:49.933]   - Field: ‘uuid’
[10:22:49.933]   - Field: ‘seed’
[10:22:49.933]   - Field: ‘version’
[10:22:49.933]   - Field: ‘result’
[10:22:49.933]   - Field: ‘asynchronous’
[10:22:49.934]   - Field: ‘calls’
[10:22:49.934]   - Field: ‘globals’
[10:22:49.934]   - Field: ‘stdout’
[10:22:49.934]   - Field: ‘earlySignal’
[10:22:49.934]   - Field: ‘lazy’
[10:22:49.934]   - Field: ‘state’
[10:22:49.934] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:49.934] - Launch lazy future ...
[10:22:49.934] Packages needed by the future expression (n = 0): <none>
[10:22:49.935] Packages needed by future strategies (n = 0): <none>
[10:22:49.935] {
[10:22:49.935]     {
[10:22:49.935]         {
[10:22:49.935]             ...future.startTime <- base::Sys.time()
[10:22:49.935]             {
[10:22:49.935]                 {
[10:22:49.935]                   {
[10:22:49.935]                     {
[10:22:49.935]                       base::local({
[10:22:49.935]                         has_future <- base::requireNamespace("future", 
[10:22:49.935]                           quietly = TRUE)
[10:22:49.935]                         if (has_future) {
[10:22:49.935]                           ns <- base::getNamespace("future")
[10:22:49.935]                           version <- ns[[".package"]][["version"]]
[10:22:49.935]                           if (is.null(version)) 
[10:22:49.935]                             version <- utils::packageVersion("future")
[10:22:49.935]                         }
[10:22:49.935]                         else {
[10:22:49.935]                           version <- NULL
[10:22:49.935]                         }
[10:22:49.935]                         if (!has_future || version < "1.8.0") {
[10:22:49.935]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:49.935]                             "", base::R.version$version.string), 
[10:22:49.935]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:49.935]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:49.935]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:49.935]                               "release", "version")], collapse = " "), 
[10:22:49.935]                             hostname = base::Sys.info()[["nodename"]])
[10:22:49.935]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:49.935]                             info)
[10:22:49.935]                           info <- base::paste(info, collapse = "; ")
[10:22:49.935]                           if (!has_future) {
[10:22:49.935]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:49.935]                               info)
[10:22:49.935]                           }
[10:22:49.935]                           else {
[10:22:49.935]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:49.935]                               info, version)
[10:22:49.935]                           }
[10:22:49.935]                           base::stop(msg)
[10:22:49.935]                         }
[10:22:49.935]                       })
[10:22:49.935]                     }
[10:22:49.935]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:49.935]                     base::options(mc.cores = 1L)
[10:22:49.935]                   }
[10:22:49.935]                   ...future.strategy.old <- future::plan("list")
[10:22:49.935]                   options(future.plan = NULL)
[10:22:49.935]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.935]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:49.935]                 }
[10:22:49.935]                 ...future.workdir <- getwd()
[10:22:49.935]             }
[10:22:49.935]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:49.935]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:49.935]         }
[10:22:49.935]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:49.935]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:49.935]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:49.935]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:49.935]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:49.935]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:49.935]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:49.935]             base::names(...future.oldOptions))
[10:22:49.935]     }
[10:22:49.935]     if (FALSE) {
[10:22:49.935]     }
[10:22:49.935]     else {
[10:22:49.935]         if (TRUE) {
[10:22:49.935]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:49.935]                 open = "w")
[10:22:49.935]         }
[10:22:49.935]         else {
[10:22:49.935]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:49.935]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:49.935]         }
[10:22:49.935]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:49.935]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:49.935]             base::sink(type = "output", split = FALSE)
[10:22:49.935]             base::close(...future.stdout)
[10:22:49.935]         }, add = TRUE)
[10:22:49.935]     }
[10:22:49.935]     ...future.frame <- base::sys.nframe()
[10:22:49.935]     ...future.conditions <- base::list()
[10:22:49.935]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:49.935]     if (FALSE) {
[10:22:49.935]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:49.935]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:49.935]     }
[10:22:49.935]     ...future.result <- base::tryCatch({
[10:22:49.935]         base::withCallingHandlers({
[10:22:49.935]             ...future.value <- base::withVisible(base::local({
[10:22:49.935]                 ...future.makeSendCondition <- base::local({
[10:22:49.935]                   sendCondition <- NULL
[10:22:49.935]                   function(frame = 1L) {
[10:22:49.935]                     if (is.function(sendCondition)) 
[10:22:49.935]                       return(sendCondition)
[10:22:49.935]                     ns <- getNamespace("parallel")
[10:22:49.935]                     if (exists("sendData", mode = "function", 
[10:22:49.935]                       envir = ns)) {
[10:22:49.935]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:49.935]                         envir = ns)
[10:22:49.935]                       envir <- sys.frame(frame)
[10:22:49.935]                       master <- NULL
[10:22:49.935]                       while (!identical(envir, .GlobalEnv) && 
[10:22:49.935]                         !identical(envir, emptyenv())) {
[10:22:49.935]                         if (exists("master", mode = "list", envir = envir, 
[10:22:49.935]                           inherits = FALSE)) {
[10:22:49.935]                           master <- get("master", mode = "list", 
[10:22:49.935]                             envir = envir, inherits = FALSE)
[10:22:49.935]                           if (inherits(master, c("SOCKnode", 
[10:22:49.935]                             "SOCK0node"))) {
[10:22:49.935]                             sendCondition <<- function(cond) {
[10:22:49.935]                               data <- list(type = "VALUE", value = cond, 
[10:22:49.935]                                 success = TRUE)
[10:22:49.935]                               parallel_sendData(master, data)
[10:22:49.935]                             }
[10:22:49.935]                             return(sendCondition)
[10:22:49.935]                           }
[10:22:49.935]                         }
[10:22:49.935]                         frame <- frame + 1L
[10:22:49.935]                         envir <- sys.frame(frame)
[10:22:49.935]                       }
[10:22:49.935]                     }
[10:22:49.935]                     sendCondition <<- function(cond) NULL
[10:22:49.935]                   }
[10:22:49.935]                 })
[10:22:49.935]                 withCallingHandlers({
[10:22:49.935]                   {
[10:22:49.935]                     2
[10:22:49.935]                   }
[10:22:49.935]                 }, immediateCondition = function(cond) {
[10:22:49.935]                   sendCondition <- ...future.makeSendCondition()
[10:22:49.935]                   sendCondition(cond)
[10:22:49.935]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.935]                   {
[10:22:49.935]                     inherits <- base::inherits
[10:22:49.935]                     invokeRestart <- base::invokeRestart
[10:22:49.935]                     is.null <- base::is.null
[10:22:49.935]                     muffled <- FALSE
[10:22:49.935]                     if (inherits(cond, "message")) {
[10:22:49.935]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:49.935]                       if (muffled) 
[10:22:49.935]                         invokeRestart("muffleMessage")
[10:22:49.935]                     }
[10:22:49.935]                     else if (inherits(cond, "warning")) {
[10:22:49.935]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:49.935]                       if (muffled) 
[10:22:49.935]                         invokeRestart("muffleWarning")
[10:22:49.935]                     }
[10:22:49.935]                     else if (inherits(cond, "condition")) {
[10:22:49.935]                       if (!is.null(pattern)) {
[10:22:49.935]                         computeRestarts <- base::computeRestarts
[10:22:49.935]                         grepl <- base::grepl
[10:22:49.935]                         restarts <- computeRestarts(cond)
[10:22:49.935]                         for (restart in restarts) {
[10:22:49.935]                           name <- restart$name
[10:22:49.935]                           if (is.null(name)) 
[10:22:49.935]                             next
[10:22:49.935]                           if (!grepl(pattern, name)) 
[10:22:49.935]                             next
[10:22:49.935]                           invokeRestart(restart)
[10:22:49.935]                           muffled <- TRUE
[10:22:49.935]                           break
[10:22:49.935]                         }
[10:22:49.935]                       }
[10:22:49.935]                     }
[10:22:49.935]                     invisible(muffled)
[10:22:49.935]                   }
[10:22:49.935]                   muffleCondition(cond)
[10:22:49.935]                 })
[10:22:49.935]             }))
[10:22:49.935]             future::FutureResult(value = ...future.value$value, 
[10:22:49.935]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.935]                   ...future.rng), globalenv = if (FALSE) 
[10:22:49.935]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:49.935]                     ...future.globalenv.names))
[10:22:49.935]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:49.935]         }, condition = base::local({
[10:22:49.935]             c <- base::c
[10:22:49.935]             inherits <- base::inherits
[10:22:49.935]             invokeRestart <- base::invokeRestart
[10:22:49.935]             length <- base::length
[10:22:49.935]             list <- base::list
[10:22:49.935]             seq.int <- base::seq.int
[10:22:49.935]             signalCondition <- base::signalCondition
[10:22:49.935]             sys.calls <- base::sys.calls
[10:22:49.935]             `[[` <- base::`[[`
[10:22:49.935]             `+` <- base::`+`
[10:22:49.935]             `<<-` <- base::`<<-`
[10:22:49.935]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:49.935]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:49.935]                   3L)]
[10:22:49.935]             }
[10:22:49.935]             function(cond) {
[10:22:49.935]                 is_error <- inherits(cond, "error")
[10:22:49.935]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:49.935]                   NULL)
[10:22:49.935]                 if (is_error) {
[10:22:49.935]                   sessionInformation <- function() {
[10:22:49.935]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:49.935]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:49.935]                       search = base::search(), system = base::Sys.info())
[10:22:49.935]                   }
[10:22:49.935]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.935]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:49.935]                     cond$call), session = sessionInformation(), 
[10:22:49.935]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:49.935]                   signalCondition(cond)
[10:22:49.935]                 }
[10:22:49.935]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:49.935]                 "immediateCondition"))) {
[10:22:49.935]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:49.935]                   ...future.conditions[[length(...future.conditions) + 
[10:22:49.935]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:49.935]                   if (TRUE && !signal) {
[10:22:49.935]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.935]                     {
[10:22:49.935]                       inherits <- base::inherits
[10:22:49.935]                       invokeRestart <- base::invokeRestart
[10:22:49.935]                       is.null <- base::is.null
[10:22:49.935]                       muffled <- FALSE
[10:22:49.935]                       if (inherits(cond, "message")) {
[10:22:49.935]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.935]                         if (muffled) 
[10:22:49.935]                           invokeRestart("muffleMessage")
[10:22:49.935]                       }
[10:22:49.935]                       else if (inherits(cond, "warning")) {
[10:22:49.935]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.935]                         if (muffled) 
[10:22:49.935]                           invokeRestart("muffleWarning")
[10:22:49.935]                       }
[10:22:49.935]                       else if (inherits(cond, "condition")) {
[10:22:49.935]                         if (!is.null(pattern)) {
[10:22:49.935]                           computeRestarts <- base::computeRestarts
[10:22:49.935]                           grepl <- base::grepl
[10:22:49.935]                           restarts <- computeRestarts(cond)
[10:22:49.935]                           for (restart in restarts) {
[10:22:49.935]                             name <- restart$name
[10:22:49.935]                             if (is.null(name)) 
[10:22:49.935]                               next
[10:22:49.935]                             if (!grepl(pattern, name)) 
[10:22:49.935]                               next
[10:22:49.935]                             invokeRestart(restart)
[10:22:49.935]                             muffled <- TRUE
[10:22:49.935]                             break
[10:22:49.935]                           }
[10:22:49.935]                         }
[10:22:49.935]                       }
[10:22:49.935]                       invisible(muffled)
[10:22:49.935]                     }
[10:22:49.935]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.935]                   }
[10:22:49.935]                 }
[10:22:49.935]                 else {
[10:22:49.935]                   if (TRUE) {
[10:22:49.935]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:49.935]                     {
[10:22:49.935]                       inherits <- base::inherits
[10:22:49.935]                       invokeRestart <- base::invokeRestart
[10:22:49.935]                       is.null <- base::is.null
[10:22:49.935]                       muffled <- FALSE
[10:22:49.935]                       if (inherits(cond, "message")) {
[10:22:49.935]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:49.935]                         if (muffled) 
[10:22:49.935]                           invokeRestart("muffleMessage")
[10:22:49.935]                       }
[10:22:49.935]                       else if (inherits(cond, "warning")) {
[10:22:49.935]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:49.935]                         if (muffled) 
[10:22:49.935]                           invokeRestart("muffleWarning")
[10:22:49.935]                       }
[10:22:49.935]                       else if (inherits(cond, "condition")) {
[10:22:49.935]                         if (!is.null(pattern)) {
[10:22:49.935]                           computeRestarts <- base::computeRestarts
[10:22:49.935]                           grepl <- base::grepl
[10:22:49.935]                           restarts <- computeRestarts(cond)
[10:22:49.935]                           for (restart in restarts) {
[10:22:49.935]                             name <- restart$name
[10:22:49.935]                             if (is.null(name)) 
[10:22:49.935]                               next
[10:22:49.935]                             if (!grepl(pattern, name)) 
[10:22:49.935]                               next
[10:22:49.935]                             invokeRestart(restart)
[10:22:49.935]                             muffled <- TRUE
[10:22:49.935]                             break
[10:22:49.935]                           }
[10:22:49.935]                         }
[10:22:49.935]                       }
[10:22:49.935]                       invisible(muffled)
[10:22:49.935]                     }
[10:22:49.935]                     muffleCondition(cond, pattern = "^muffle")
[10:22:49.935]                   }
[10:22:49.935]                 }
[10:22:49.935]             }
[10:22:49.935]         }))
[10:22:49.935]     }, error = function(ex) {
[10:22:49.935]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:49.935]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:49.935]                 ...future.rng), started = ...future.startTime, 
[10:22:49.935]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:49.935]             version = "1.8"), class = "FutureResult")
[10:22:49.935]     }, finally = {
[10:22:49.935]         if (!identical(...future.workdir, getwd())) 
[10:22:49.935]             setwd(...future.workdir)
[10:22:49.935]         {
[10:22:49.935]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:49.935]                 ...future.oldOptions$nwarnings <- NULL
[10:22:49.935]             }
[10:22:49.935]             base::options(...future.oldOptions)
[10:22:49.935]             if (.Platform$OS.type == "windows") {
[10:22:49.935]                 old_names <- names(...future.oldEnvVars)
[10:22:49.935]                 envs <- base::Sys.getenv()
[10:22:49.935]                 names <- names(envs)
[10:22:49.935]                 common <- intersect(names, old_names)
[10:22:49.935]                 added <- setdiff(names, old_names)
[10:22:49.935]                 removed <- setdiff(old_names, names)
[10:22:49.935]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:49.935]                   envs[common]]
[10:22:49.935]                 NAMES <- toupper(changed)
[10:22:49.935]                 args <- list()
[10:22:49.935]                 for (kk in seq_along(NAMES)) {
[10:22:49.935]                   name <- changed[[kk]]
[10:22:49.935]                   NAME <- NAMES[[kk]]
[10:22:49.935]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.935]                     next
[10:22:49.935]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.935]                 }
[10:22:49.935]                 NAMES <- toupper(added)
[10:22:49.935]                 for (kk in seq_along(NAMES)) {
[10:22:49.935]                   name <- added[[kk]]
[10:22:49.935]                   NAME <- NAMES[[kk]]
[10:22:49.935]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.935]                     next
[10:22:49.935]                   args[[name]] <- ""
[10:22:49.935]                 }
[10:22:49.935]                 NAMES <- toupper(removed)
[10:22:49.935]                 for (kk in seq_along(NAMES)) {
[10:22:49.935]                   name <- removed[[kk]]
[10:22:49.935]                   NAME <- NAMES[[kk]]
[10:22:49.935]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:49.935]                     next
[10:22:49.935]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:49.935]                 }
[10:22:49.935]                 if (length(args) > 0) 
[10:22:49.935]                   base::do.call(base::Sys.setenv, args = args)
[10:22:49.935]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:49.935]             }
[10:22:49.935]             else {
[10:22:49.935]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:49.935]             }
[10:22:49.935]             {
[10:22:49.935]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:49.935]                   0L) {
[10:22:49.935]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:49.935]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:49.935]                   base::options(opts)
[10:22:49.935]                 }
[10:22:49.935]                 {
[10:22:49.935]                   {
[10:22:49.935]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:49.935]                     NULL
[10:22:49.935]                   }
[10:22:49.935]                   options(future.plan = NULL)
[10:22:49.935]                   if (is.na(NA_character_)) 
[10:22:49.935]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:49.935]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:49.935]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:49.935]                     .init = FALSE)
[10:22:49.935]                 }
[10:22:49.935]             }
[10:22:49.935]         }
[10:22:49.935]     })
[10:22:49.935]     if (TRUE) {
[10:22:49.935]         base::sink(type = "output", split = FALSE)
[10:22:49.935]         if (TRUE) {
[10:22:49.935]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:49.935]         }
[10:22:49.935]         else {
[10:22:49.935]             ...future.result["stdout"] <- base::list(NULL)
[10:22:49.935]         }
[10:22:49.935]         base::close(...future.stdout)
[10:22:49.935]         ...future.stdout <- NULL
[10:22:49.935]     }
[10:22:49.935]     ...future.result$conditions <- ...future.conditions
[10:22:49.935]     ...future.result$finished <- base::Sys.time()
[10:22:49.935]     ...future.result
[10:22:49.935] }
[10:22:49.938] MultisessionFuture started
[10:22:49.938] - Launch lazy future ... done
[10:22:49.938] run() for ‘MultisessionFuture’ ... done
[10:22:49.939] resolve() on environment ...
[10:22:49.939]  recursive: 0
[10:22:49.939]  elements: [3] ‘a’
[10:22:49.960]  length: 2 (resolved future 3)
[10:22:49.971] receiveMessageFromWorker() for ClusterFuture ...
[10:22:49.971] - Validating connection of MultisessionFuture
[10:22:49.971] - received message: FutureResult
[10:22:49.972] - Received FutureResult
[10:22:49.972] - Erased future from FutureRegistry
[10:22:49.972] result() for ClusterFuture ...
[10:22:49.972] - result already collected: FutureResult
[10:22:49.972] result() for ClusterFuture ... done
[10:22:49.972] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:49.972] Future #1
[10:22:49.972]  length: 1 (resolved future 1)
[10:22:49.980] receiveMessageFromWorker() for ClusterFuture ...
[10:22:49.980] - Validating connection of MultisessionFuture
[10:22:49.980] - received message: FutureResult
[10:22:49.980] - Received FutureResult
[10:22:49.980] - Erased future from FutureRegistry
[10:22:49.981] result() for ClusterFuture ...
[10:22:49.981] - result already collected: FutureResult
[10:22:49.981] result() for ClusterFuture ... done
[10:22:49.981] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:49.981] Future #2
[10:22:49.981]  length: 0 (resolved future 2)
[10:22:49.981] resolve() on environment ... DONE
[10:22:49.985] resolve() on environment ...
[10:22:49.985]  recursive: 0
[10:22:49.985]  elements: [3] ‘b’
[10:22:49.985] Future #1
[10:22:49.986]  length: 2 (resolved future 1)
[10:22:49.986] Future #2
[10:22:49.986]  length: 1 (resolved future 2)
[10:22:49.986]  length: 0 (resolved future 3)
[10:22:49.986] resolve() on environment ... DONE
[10:22:49.986] resolve() on environment ...
[10:22:49.987]  recursive: 0
[10:22:49.987]  elements: [3] ‘c’
[10:22:49.987] Future #1
[10:22:49.987]  length: 2 (resolved future 1)
[10:22:49.987] Future #2
[10:22:49.987]  length: 1 (resolved future 2)
[10:22:49.988]  length: 0 (resolved future 3)
[10:22:49.988] resolve() on environment ... DONE
[10:22:49.988] resolve() on environment ...
[10:22:49.988]  recursive: 0
[10:22:49.989]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[10:22:49.989] Future #1
[10:22:49.989] result() for ClusterFuture ...
[10:22:49.989] - result already collected: FutureResult
[10:22:49.989] result() for ClusterFuture ... done
[10:22:49.989] result() for ClusterFuture ...
[10:22:49.989] - result already collected: FutureResult
[10:22:49.989] result() for ClusterFuture ... done
[10:22:49.989]  length: 2 (resolved future 1)
[10:22:49.989] Future #2
[10:22:49.989] result() for ClusterFuture ...
[10:22:49.990] - result already collected: FutureResult
[10:22:49.990] result() for ClusterFuture ... done
[10:22:49.990] result() for ClusterFuture ...
[10:22:49.990] - result already collected: FutureResult
[10:22:49.990] result() for ClusterFuture ... done
[10:22:49.990]  length: 1 (resolved future 2)
[10:22:49.990]  length: 0 (resolved future 3)
[10:22:49.990] resolve() on environment ... DONE
[10:22:49.991] resolve() on environment ...
[10:22:49.991]  recursive: 99
[10:22:49.991]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[10:22:49.991] Future #1
[10:22:49.991] result() for ClusterFuture ...
[10:22:49.991] - result already collected: FutureResult
[10:22:49.991] result() for ClusterFuture ... done
[10:22:49.992] result() for ClusterFuture ...
[10:22:49.992] - result already collected: FutureResult
[10:22:49.992] result() for ClusterFuture ... done
[10:22:49.992] A MultisessionFuture was resolved
[10:22:49.992]  length: 2 (resolved future 1)
[10:22:49.992] Future #2
[10:22:49.992] result() for ClusterFuture ...
[10:22:49.992] - result already collected: FutureResult
[10:22:49.992] result() for ClusterFuture ... done
[10:22:49.992] result() for ClusterFuture ...
[10:22:49.992] - result already collected: FutureResult
[10:22:49.993] result() for ClusterFuture ... done
[10:22:49.993] A MultisessionFuture was resolved
[10:22:49.993]  length: 1 (resolved future 2)
[10:22:49.993]  length: 0 (resolved future 3)
[10:22:49.993] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[10:22:49.994] resolve() on list environment ...
[10:22:49.994]  recursive: 0
[10:22:49.994]  length: 2
[10:22:49.994]  elements: ‘a’, ‘b’
[10:22:49.994]  length: 1 (resolved future 1)
[10:22:49.994]  length: 0 (resolved future 2)
[10:22:49.995] resolve() on list environment ... DONE
[10:22:49.995] getGlobalsAndPackages() ...
[10:22:49.995] Searching for globals...
[10:22:49.995] 
[10:22:49.995] Searching for globals ... DONE
[10:22:49.995] - globals: [0] <none>
[10:22:49.995] getGlobalsAndPackages() ... DONE
[10:22:49.995] run() for ‘Future’ ...
[10:22:49.996] - state: ‘created’
[10:22:49.996] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:50.009] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:50.009] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:50.010]   - Field: ‘node’
[10:22:50.010]   - Field: ‘label’
[10:22:50.010]   - Field: ‘local’
[10:22:50.010]   - Field: ‘owner’
[10:22:50.010]   - Field: ‘envir’
[10:22:50.010]   - Field: ‘workers’
[10:22:50.010]   - Field: ‘packages’
[10:22:50.010]   - Field: ‘gc’
[10:22:50.010]   - Field: ‘conditions’
[10:22:50.010]   - Field: ‘persistent’
[10:22:50.010]   - Field: ‘expr’
[10:22:50.010]   - Field: ‘uuid’
[10:22:50.011]   - Field: ‘seed’
[10:22:50.011]   - Field: ‘version’
[10:22:50.011]   - Field: ‘result’
[10:22:50.011]   - Field: ‘asynchronous’
[10:22:50.011]   - Field: ‘calls’
[10:22:50.011]   - Field: ‘globals’
[10:22:50.011]   - Field: ‘stdout’
[10:22:50.011]   - Field: ‘earlySignal’
[10:22:50.011]   - Field: ‘lazy’
[10:22:50.011]   - Field: ‘state’
[10:22:50.011] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:50.011] - Launch lazy future ...
[10:22:50.012] Packages needed by the future expression (n = 0): <none>
[10:22:50.012] Packages needed by future strategies (n = 0): <none>
[10:22:50.012] {
[10:22:50.012]     {
[10:22:50.012]         {
[10:22:50.012]             ...future.startTime <- base::Sys.time()
[10:22:50.012]             {
[10:22:50.012]                 {
[10:22:50.012]                   {
[10:22:50.012]                     {
[10:22:50.012]                       base::local({
[10:22:50.012]                         has_future <- base::requireNamespace("future", 
[10:22:50.012]                           quietly = TRUE)
[10:22:50.012]                         if (has_future) {
[10:22:50.012]                           ns <- base::getNamespace("future")
[10:22:50.012]                           version <- ns[[".package"]][["version"]]
[10:22:50.012]                           if (is.null(version)) 
[10:22:50.012]                             version <- utils::packageVersion("future")
[10:22:50.012]                         }
[10:22:50.012]                         else {
[10:22:50.012]                           version <- NULL
[10:22:50.012]                         }
[10:22:50.012]                         if (!has_future || version < "1.8.0") {
[10:22:50.012]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:50.012]                             "", base::R.version$version.string), 
[10:22:50.012]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:50.012]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:50.012]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:50.012]                               "release", "version")], collapse = " "), 
[10:22:50.012]                             hostname = base::Sys.info()[["nodename"]])
[10:22:50.012]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:50.012]                             info)
[10:22:50.012]                           info <- base::paste(info, collapse = "; ")
[10:22:50.012]                           if (!has_future) {
[10:22:50.012]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:50.012]                               info)
[10:22:50.012]                           }
[10:22:50.012]                           else {
[10:22:50.012]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:50.012]                               info, version)
[10:22:50.012]                           }
[10:22:50.012]                           base::stop(msg)
[10:22:50.012]                         }
[10:22:50.012]                       })
[10:22:50.012]                     }
[10:22:50.012]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:50.012]                     base::options(mc.cores = 1L)
[10:22:50.012]                   }
[10:22:50.012]                   ...future.strategy.old <- future::plan("list")
[10:22:50.012]                   options(future.plan = NULL)
[10:22:50.012]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:50.012]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:50.012]                 }
[10:22:50.012]                 ...future.workdir <- getwd()
[10:22:50.012]             }
[10:22:50.012]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:50.012]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:50.012]         }
[10:22:50.012]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:50.012]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:50.012]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:50.012]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:50.012]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:50.012]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:50.012]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:50.012]             base::names(...future.oldOptions))
[10:22:50.012]     }
[10:22:50.012]     if (FALSE) {
[10:22:50.012]     }
[10:22:50.012]     else {
[10:22:50.012]         if (TRUE) {
[10:22:50.012]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:50.012]                 open = "w")
[10:22:50.012]         }
[10:22:50.012]         else {
[10:22:50.012]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:50.012]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:50.012]         }
[10:22:50.012]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:50.012]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:50.012]             base::sink(type = "output", split = FALSE)
[10:22:50.012]             base::close(...future.stdout)
[10:22:50.012]         }, add = TRUE)
[10:22:50.012]     }
[10:22:50.012]     ...future.frame <- base::sys.nframe()
[10:22:50.012]     ...future.conditions <- base::list()
[10:22:50.012]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:50.012]     if (FALSE) {
[10:22:50.012]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:50.012]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:50.012]     }
[10:22:50.012]     ...future.result <- base::tryCatch({
[10:22:50.012]         base::withCallingHandlers({
[10:22:50.012]             ...future.value <- base::withVisible(base::local({
[10:22:50.012]                 ...future.makeSendCondition <- base::local({
[10:22:50.012]                   sendCondition <- NULL
[10:22:50.012]                   function(frame = 1L) {
[10:22:50.012]                     if (is.function(sendCondition)) 
[10:22:50.012]                       return(sendCondition)
[10:22:50.012]                     ns <- getNamespace("parallel")
[10:22:50.012]                     if (exists("sendData", mode = "function", 
[10:22:50.012]                       envir = ns)) {
[10:22:50.012]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:50.012]                         envir = ns)
[10:22:50.012]                       envir <- sys.frame(frame)
[10:22:50.012]                       master <- NULL
[10:22:50.012]                       while (!identical(envir, .GlobalEnv) && 
[10:22:50.012]                         !identical(envir, emptyenv())) {
[10:22:50.012]                         if (exists("master", mode = "list", envir = envir, 
[10:22:50.012]                           inherits = FALSE)) {
[10:22:50.012]                           master <- get("master", mode = "list", 
[10:22:50.012]                             envir = envir, inherits = FALSE)
[10:22:50.012]                           if (inherits(master, c("SOCKnode", 
[10:22:50.012]                             "SOCK0node"))) {
[10:22:50.012]                             sendCondition <<- function(cond) {
[10:22:50.012]                               data <- list(type = "VALUE", value = cond, 
[10:22:50.012]                                 success = TRUE)
[10:22:50.012]                               parallel_sendData(master, data)
[10:22:50.012]                             }
[10:22:50.012]                             return(sendCondition)
[10:22:50.012]                           }
[10:22:50.012]                         }
[10:22:50.012]                         frame <- frame + 1L
[10:22:50.012]                         envir <- sys.frame(frame)
[10:22:50.012]                       }
[10:22:50.012]                     }
[10:22:50.012]                     sendCondition <<- function(cond) NULL
[10:22:50.012]                   }
[10:22:50.012]                 })
[10:22:50.012]                 withCallingHandlers({
[10:22:50.012]                   1
[10:22:50.012]                 }, immediateCondition = function(cond) {
[10:22:50.012]                   sendCondition <- ...future.makeSendCondition()
[10:22:50.012]                   sendCondition(cond)
[10:22:50.012]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.012]                   {
[10:22:50.012]                     inherits <- base::inherits
[10:22:50.012]                     invokeRestart <- base::invokeRestart
[10:22:50.012]                     is.null <- base::is.null
[10:22:50.012]                     muffled <- FALSE
[10:22:50.012]                     if (inherits(cond, "message")) {
[10:22:50.012]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:50.012]                       if (muffled) 
[10:22:50.012]                         invokeRestart("muffleMessage")
[10:22:50.012]                     }
[10:22:50.012]                     else if (inherits(cond, "warning")) {
[10:22:50.012]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:50.012]                       if (muffled) 
[10:22:50.012]                         invokeRestart("muffleWarning")
[10:22:50.012]                     }
[10:22:50.012]                     else if (inherits(cond, "condition")) {
[10:22:50.012]                       if (!is.null(pattern)) {
[10:22:50.012]                         computeRestarts <- base::computeRestarts
[10:22:50.012]                         grepl <- base::grepl
[10:22:50.012]                         restarts <- computeRestarts(cond)
[10:22:50.012]                         for (restart in restarts) {
[10:22:50.012]                           name <- restart$name
[10:22:50.012]                           if (is.null(name)) 
[10:22:50.012]                             next
[10:22:50.012]                           if (!grepl(pattern, name)) 
[10:22:50.012]                             next
[10:22:50.012]                           invokeRestart(restart)
[10:22:50.012]                           muffled <- TRUE
[10:22:50.012]                           break
[10:22:50.012]                         }
[10:22:50.012]                       }
[10:22:50.012]                     }
[10:22:50.012]                     invisible(muffled)
[10:22:50.012]                   }
[10:22:50.012]                   muffleCondition(cond)
[10:22:50.012]                 })
[10:22:50.012]             }))
[10:22:50.012]             future::FutureResult(value = ...future.value$value, 
[10:22:50.012]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:50.012]                   ...future.rng), globalenv = if (FALSE) 
[10:22:50.012]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:50.012]                     ...future.globalenv.names))
[10:22:50.012]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:50.012]         }, condition = base::local({
[10:22:50.012]             c <- base::c
[10:22:50.012]             inherits <- base::inherits
[10:22:50.012]             invokeRestart <- base::invokeRestart
[10:22:50.012]             length <- base::length
[10:22:50.012]             list <- base::list
[10:22:50.012]             seq.int <- base::seq.int
[10:22:50.012]             signalCondition <- base::signalCondition
[10:22:50.012]             sys.calls <- base::sys.calls
[10:22:50.012]             `[[` <- base::`[[`
[10:22:50.012]             `+` <- base::`+`
[10:22:50.012]             `<<-` <- base::`<<-`
[10:22:50.012]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:50.012]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:50.012]                   3L)]
[10:22:50.012]             }
[10:22:50.012]             function(cond) {
[10:22:50.012]                 is_error <- inherits(cond, "error")
[10:22:50.012]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:50.012]                   NULL)
[10:22:50.012]                 if (is_error) {
[10:22:50.012]                   sessionInformation <- function() {
[10:22:50.012]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:50.012]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:50.012]                       search = base::search(), system = base::Sys.info())
[10:22:50.012]                   }
[10:22:50.012]                   ...future.conditions[[length(...future.conditions) + 
[10:22:50.012]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:50.012]                     cond$call), session = sessionInformation(), 
[10:22:50.012]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:50.012]                   signalCondition(cond)
[10:22:50.012]                 }
[10:22:50.012]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:50.012]                 "immediateCondition"))) {
[10:22:50.012]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:50.012]                   ...future.conditions[[length(...future.conditions) + 
[10:22:50.012]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:50.012]                   if (TRUE && !signal) {
[10:22:50.012]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.012]                     {
[10:22:50.012]                       inherits <- base::inherits
[10:22:50.012]                       invokeRestart <- base::invokeRestart
[10:22:50.012]                       is.null <- base::is.null
[10:22:50.012]                       muffled <- FALSE
[10:22:50.012]                       if (inherits(cond, "message")) {
[10:22:50.012]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:50.012]                         if (muffled) 
[10:22:50.012]                           invokeRestart("muffleMessage")
[10:22:50.012]                       }
[10:22:50.012]                       else if (inherits(cond, "warning")) {
[10:22:50.012]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:50.012]                         if (muffled) 
[10:22:50.012]                           invokeRestart("muffleWarning")
[10:22:50.012]                       }
[10:22:50.012]                       else if (inherits(cond, "condition")) {
[10:22:50.012]                         if (!is.null(pattern)) {
[10:22:50.012]                           computeRestarts <- base::computeRestarts
[10:22:50.012]                           grepl <- base::grepl
[10:22:50.012]                           restarts <- computeRestarts(cond)
[10:22:50.012]                           for (restart in restarts) {
[10:22:50.012]                             name <- restart$name
[10:22:50.012]                             if (is.null(name)) 
[10:22:50.012]                               next
[10:22:50.012]                             if (!grepl(pattern, name)) 
[10:22:50.012]                               next
[10:22:50.012]                             invokeRestart(restart)
[10:22:50.012]                             muffled <- TRUE
[10:22:50.012]                             break
[10:22:50.012]                           }
[10:22:50.012]                         }
[10:22:50.012]                       }
[10:22:50.012]                       invisible(muffled)
[10:22:50.012]                     }
[10:22:50.012]                     muffleCondition(cond, pattern = "^muffle")
[10:22:50.012]                   }
[10:22:50.012]                 }
[10:22:50.012]                 else {
[10:22:50.012]                   if (TRUE) {
[10:22:50.012]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.012]                     {
[10:22:50.012]                       inherits <- base::inherits
[10:22:50.012]                       invokeRestart <- base::invokeRestart
[10:22:50.012]                       is.null <- base::is.null
[10:22:50.012]                       muffled <- FALSE
[10:22:50.012]                       if (inherits(cond, "message")) {
[10:22:50.012]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:50.012]                         if (muffled) 
[10:22:50.012]                           invokeRestart("muffleMessage")
[10:22:50.012]                       }
[10:22:50.012]                       else if (inherits(cond, "warning")) {
[10:22:50.012]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:50.012]                         if (muffled) 
[10:22:50.012]                           invokeRestart("muffleWarning")
[10:22:50.012]                       }
[10:22:50.012]                       else if (inherits(cond, "condition")) {
[10:22:50.012]                         if (!is.null(pattern)) {
[10:22:50.012]                           computeRestarts <- base::computeRestarts
[10:22:50.012]                           grepl <- base::grepl
[10:22:50.012]                           restarts <- computeRestarts(cond)
[10:22:50.012]                           for (restart in restarts) {
[10:22:50.012]                             name <- restart$name
[10:22:50.012]                             if (is.null(name)) 
[10:22:50.012]                               next
[10:22:50.012]                             if (!grepl(pattern, name)) 
[10:22:50.012]                               next
[10:22:50.012]                             invokeRestart(restart)
[10:22:50.012]                             muffled <- TRUE
[10:22:50.012]                             break
[10:22:50.012]                           }
[10:22:50.012]                         }
[10:22:50.012]                       }
[10:22:50.012]                       invisible(muffled)
[10:22:50.012]                     }
[10:22:50.012]                     muffleCondition(cond, pattern = "^muffle")
[10:22:50.012]                   }
[10:22:50.012]                 }
[10:22:50.012]             }
[10:22:50.012]         }))
[10:22:50.012]     }, error = function(ex) {
[10:22:50.012]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:50.012]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:50.012]                 ...future.rng), started = ...future.startTime, 
[10:22:50.012]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:50.012]             version = "1.8"), class = "FutureResult")
[10:22:50.012]     }, finally = {
[10:22:50.012]         if (!identical(...future.workdir, getwd())) 
[10:22:50.012]             setwd(...future.workdir)
[10:22:50.012]         {
[10:22:50.012]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:50.012]                 ...future.oldOptions$nwarnings <- NULL
[10:22:50.012]             }
[10:22:50.012]             base::options(...future.oldOptions)
[10:22:50.012]             if (.Platform$OS.type == "windows") {
[10:22:50.012]                 old_names <- names(...future.oldEnvVars)
[10:22:50.012]                 envs <- base::Sys.getenv()
[10:22:50.012]                 names <- names(envs)
[10:22:50.012]                 common <- intersect(names, old_names)
[10:22:50.012]                 added <- setdiff(names, old_names)
[10:22:50.012]                 removed <- setdiff(old_names, names)
[10:22:50.012]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:50.012]                   envs[common]]
[10:22:50.012]                 NAMES <- toupper(changed)
[10:22:50.012]                 args <- list()
[10:22:50.012]                 for (kk in seq_along(NAMES)) {
[10:22:50.012]                   name <- changed[[kk]]
[10:22:50.012]                   NAME <- NAMES[[kk]]
[10:22:50.012]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.012]                     next
[10:22:50.012]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:50.012]                 }
[10:22:50.012]                 NAMES <- toupper(added)
[10:22:50.012]                 for (kk in seq_along(NAMES)) {
[10:22:50.012]                   name <- added[[kk]]
[10:22:50.012]                   NAME <- NAMES[[kk]]
[10:22:50.012]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.012]                     next
[10:22:50.012]                   args[[name]] <- ""
[10:22:50.012]                 }
[10:22:50.012]                 NAMES <- toupper(removed)
[10:22:50.012]                 for (kk in seq_along(NAMES)) {
[10:22:50.012]                   name <- removed[[kk]]
[10:22:50.012]                   NAME <- NAMES[[kk]]
[10:22:50.012]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.012]                     next
[10:22:50.012]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:50.012]                 }
[10:22:50.012]                 if (length(args) > 0) 
[10:22:50.012]                   base::do.call(base::Sys.setenv, args = args)
[10:22:50.012]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:50.012]             }
[10:22:50.012]             else {
[10:22:50.012]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:50.012]             }
[10:22:50.012]             {
[10:22:50.012]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:50.012]                   0L) {
[10:22:50.012]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:50.012]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:50.012]                   base::options(opts)
[10:22:50.012]                 }
[10:22:50.012]                 {
[10:22:50.012]                   {
[10:22:50.012]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:50.012]                     NULL
[10:22:50.012]                   }
[10:22:50.012]                   options(future.plan = NULL)
[10:22:50.012]                   if (is.na(NA_character_)) 
[10:22:50.012]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:50.012]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:50.012]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:50.012]                     .init = FALSE)
[10:22:50.012]                 }
[10:22:50.012]             }
[10:22:50.012]         }
[10:22:50.012]     })
[10:22:50.012]     if (TRUE) {
[10:22:50.012]         base::sink(type = "output", split = FALSE)
[10:22:50.012]         if (TRUE) {
[10:22:50.012]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:50.012]         }
[10:22:50.012]         else {
[10:22:50.012]             ...future.result["stdout"] <- base::list(NULL)
[10:22:50.012]         }
[10:22:50.012]         base::close(...future.stdout)
[10:22:50.012]         ...future.stdout <- NULL
[10:22:50.012]     }
[10:22:50.012]     ...future.result$conditions <- ...future.conditions
[10:22:50.012]     ...future.result$finished <- base::Sys.time()
[10:22:50.012]     ...future.result
[10:22:50.012] }
[10:22:50.015] MultisessionFuture started
[10:22:50.015] - Launch lazy future ... done
[10:22:50.015] run() for ‘MultisessionFuture’ ... done
[10:22:50.016] getGlobalsAndPackages() ...
[10:22:50.016] Searching for globals...
[10:22:50.016] 
[10:22:50.016] Searching for globals ... DONE
[10:22:50.016] - globals: [0] <none>
[10:22:50.016] getGlobalsAndPackages() ... DONE
[10:22:50.016] run() for ‘Future’ ...
[10:22:50.017] - state: ‘created’
[10:22:50.017] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:50.032] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:50.032] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:50.032]   - Field: ‘node’
[10:22:50.032]   - Field: ‘label’
[10:22:50.032]   - Field: ‘local’
[10:22:50.032]   - Field: ‘owner’
[10:22:50.032]   - Field: ‘envir’
[10:22:50.032]   - Field: ‘workers’
[10:22:50.032]   - Field: ‘packages’
[10:22:50.032]   - Field: ‘gc’
[10:22:50.033]   - Field: ‘conditions’
[10:22:50.033]   - Field: ‘persistent’
[10:22:50.033]   - Field: ‘expr’
[10:22:50.033]   - Field: ‘uuid’
[10:22:50.033]   - Field: ‘seed’
[10:22:50.033]   - Field: ‘version’
[10:22:50.033]   - Field: ‘result’
[10:22:50.033]   - Field: ‘asynchronous’
[10:22:50.033]   - Field: ‘calls’
[10:22:50.033]   - Field: ‘globals’
[10:22:50.033]   - Field: ‘stdout’
[10:22:50.033]   - Field: ‘earlySignal’
[10:22:50.034]   - Field: ‘lazy’
[10:22:50.034]   - Field: ‘state’
[10:22:50.034] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:50.034] - Launch lazy future ...
[10:22:50.034] Packages needed by the future expression (n = 0): <none>
[10:22:50.034] Packages needed by future strategies (n = 0): <none>
[10:22:50.035] {
[10:22:50.035]     {
[10:22:50.035]         {
[10:22:50.035]             ...future.startTime <- base::Sys.time()
[10:22:50.035]             {
[10:22:50.035]                 {
[10:22:50.035]                   {
[10:22:50.035]                     {
[10:22:50.035]                       base::local({
[10:22:50.035]                         has_future <- base::requireNamespace("future", 
[10:22:50.035]                           quietly = TRUE)
[10:22:50.035]                         if (has_future) {
[10:22:50.035]                           ns <- base::getNamespace("future")
[10:22:50.035]                           version <- ns[[".package"]][["version"]]
[10:22:50.035]                           if (is.null(version)) 
[10:22:50.035]                             version <- utils::packageVersion("future")
[10:22:50.035]                         }
[10:22:50.035]                         else {
[10:22:50.035]                           version <- NULL
[10:22:50.035]                         }
[10:22:50.035]                         if (!has_future || version < "1.8.0") {
[10:22:50.035]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:50.035]                             "", base::R.version$version.string), 
[10:22:50.035]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:50.035]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:50.035]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:50.035]                               "release", "version")], collapse = " "), 
[10:22:50.035]                             hostname = base::Sys.info()[["nodename"]])
[10:22:50.035]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:50.035]                             info)
[10:22:50.035]                           info <- base::paste(info, collapse = "; ")
[10:22:50.035]                           if (!has_future) {
[10:22:50.035]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:50.035]                               info)
[10:22:50.035]                           }
[10:22:50.035]                           else {
[10:22:50.035]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:50.035]                               info, version)
[10:22:50.035]                           }
[10:22:50.035]                           base::stop(msg)
[10:22:50.035]                         }
[10:22:50.035]                       })
[10:22:50.035]                     }
[10:22:50.035]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:50.035]                     base::options(mc.cores = 1L)
[10:22:50.035]                   }
[10:22:50.035]                   ...future.strategy.old <- future::plan("list")
[10:22:50.035]                   options(future.plan = NULL)
[10:22:50.035]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:50.035]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:50.035]                 }
[10:22:50.035]                 ...future.workdir <- getwd()
[10:22:50.035]             }
[10:22:50.035]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:50.035]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:50.035]         }
[10:22:50.035]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:50.035]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:50.035]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:50.035]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:50.035]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:50.035]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:50.035]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:50.035]             base::names(...future.oldOptions))
[10:22:50.035]     }
[10:22:50.035]     if (FALSE) {
[10:22:50.035]     }
[10:22:50.035]     else {
[10:22:50.035]         if (TRUE) {
[10:22:50.035]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:50.035]                 open = "w")
[10:22:50.035]         }
[10:22:50.035]         else {
[10:22:50.035]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:50.035]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:50.035]         }
[10:22:50.035]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:50.035]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:50.035]             base::sink(type = "output", split = FALSE)
[10:22:50.035]             base::close(...future.stdout)
[10:22:50.035]         }, add = TRUE)
[10:22:50.035]     }
[10:22:50.035]     ...future.frame <- base::sys.nframe()
[10:22:50.035]     ...future.conditions <- base::list()
[10:22:50.035]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:50.035]     if (FALSE) {
[10:22:50.035]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:50.035]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:50.035]     }
[10:22:50.035]     ...future.result <- base::tryCatch({
[10:22:50.035]         base::withCallingHandlers({
[10:22:50.035]             ...future.value <- base::withVisible(base::local({
[10:22:50.035]                 ...future.makeSendCondition <- base::local({
[10:22:50.035]                   sendCondition <- NULL
[10:22:50.035]                   function(frame = 1L) {
[10:22:50.035]                     if (is.function(sendCondition)) 
[10:22:50.035]                       return(sendCondition)
[10:22:50.035]                     ns <- getNamespace("parallel")
[10:22:50.035]                     if (exists("sendData", mode = "function", 
[10:22:50.035]                       envir = ns)) {
[10:22:50.035]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:50.035]                         envir = ns)
[10:22:50.035]                       envir <- sys.frame(frame)
[10:22:50.035]                       master <- NULL
[10:22:50.035]                       while (!identical(envir, .GlobalEnv) && 
[10:22:50.035]                         !identical(envir, emptyenv())) {
[10:22:50.035]                         if (exists("master", mode = "list", envir = envir, 
[10:22:50.035]                           inherits = FALSE)) {
[10:22:50.035]                           master <- get("master", mode = "list", 
[10:22:50.035]                             envir = envir, inherits = FALSE)
[10:22:50.035]                           if (inherits(master, c("SOCKnode", 
[10:22:50.035]                             "SOCK0node"))) {
[10:22:50.035]                             sendCondition <<- function(cond) {
[10:22:50.035]                               data <- list(type = "VALUE", value = cond, 
[10:22:50.035]                                 success = TRUE)
[10:22:50.035]                               parallel_sendData(master, data)
[10:22:50.035]                             }
[10:22:50.035]                             return(sendCondition)
[10:22:50.035]                           }
[10:22:50.035]                         }
[10:22:50.035]                         frame <- frame + 1L
[10:22:50.035]                         envir <- sys.frame(frame)
[10:22:50.035]                       }
[10:22:50.035]                     }
[10:22:50.035]                     sendCondition <<- function(cond) NULL
[10:22:50.035]                   }
[10:22:50.035]                 })
[10:22:50.035]                 withCallingHandlers({
[10:22:50.035]                   2
[10:22:50.035]                 }, immediateCondition = function(cond) {
[10:22:50.035]                   sendCondition <- ...future.makeSendCondition()
[10:22:50.035]                   sendCondition(cond)
[10:22:50.035]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.035]                   {
[10:22:50.035]                     inherits <- base::inherits
[10:22:50.035]                     invokeRestart <- base::invokeRestart
[10:22:50.035]                     is.null <- base::is.null
[10:22:50.035]                     muffled <- FALSE
[10:22:50.035]                     if (inherits(cond, "message")) {
[10:22:50.035]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:50.035]                       if (muffled) 
[10:22:50.035]                         invokeRestart("muffleMessage")
[10:22:50.035]                     }
[10:22:50.035]                     else if (inherits(cond, "warning")) {
[10:22:50.035]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:50.035]                       if (muffled) 
[10:22:50.035]                         invokeRestart("muffleWarning")
[10:22:50.035]                     }
[10:22:50.035]                     else if (inherits(cond, "condition")) {
[10:22:50.035]                       if (!is.null(pattern)) {
[10:22:50.035]                         computeRestarts <- base::computeRestarts
[10:22:50.035]                         grepl <- base::grepl
[10:22:50.035]                         restarts <- computeRestarts(cond)
[10:22:50.035]                         for (restart in restarts) {
[10:22:50.035]                           name <- restart$name
[10:22:50.035]                           if (is.null(name)) 
[10:22:50.035]                             next
[10:22:50.035]                           if (!grepl(pattern, name)) 
[10:22:50.035]                             next
[10:22:50.035]                           invokeRestart(restart)
[10:22:50.035]                           muffled <- TRUE
[10:22:50.035]                           break
[10:22:50.035]                         }
[10:22:50.035]                       }
[10:22:50.035]                     }
[10:22:50.035]                     invisible(muffled)
[10:22:50.035]                   }
[10:22:50.035]                   muffleCondition(cond)
[10:22:50.035]                 })
[10:22:50.035]             }))
[10:22:50.035]             future::FutureResult(value = ...future.value$value, 
[10:22:50.035]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:50.035]                   ...future.rng), globalenv = if (FALSE) 
[10:22:50.035]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:50.035]                     ...future.globalenv.names))
[10:22:50.035]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:50.035]         }, condition = base::local({
[10:22:50.035]             c <- base::c
[10:22:50.035]             inherits <- base::inherits
[10:22:50.035]             invokeRestart <- base::invokeRestart
[10:22:50.035]             length <- base::length
[10:22:50.035]             list <- base::list
[10:22:50.035]             seq.int <- base::seq.int
[10:22:50.035]             signalCondition <- base::signalCondition
[10:22:50.035]             sys.calls <- base::sys.calls
[10:22:50.035]             `[[` <- base::`[[`
[10:22:50.035]             `+` <- base::`+`
[10:22:50.035]             `<<-` <- base::`<<-`
[10:22:50.035]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:50.035]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:50.035]                   3L)]
[10:22:50.035]             }
[10:22:50.035]             function(cond) {
[10:22:50.035]                 is_error <- inherits(cond, "error")
[10:22:50.035]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:50.035]                   NULL)
[10:22:50.035]                 if (is_error) {
[10:22:50.035]                   sessionInformation <- function() {
[10:22:50.035]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:50.035]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:50.035]                       search = base::search(), system = base::Sys.info())
[10:22:50.035]                   }
[10:22:50.035]                   ...future.conditions[[length(...future.conditions) + 
[10:22:50.035]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:50.035]                     cond$call), session = sessionInformation(), 
[10:22:50.035]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:50.035]                   signalCondition(cond)
[10:22:50.035]                 }
[10:22:50.035]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:50.035]                 "immediateCondition"))) {
[10:22:50.035]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:50.035]                   ...future.conditions[[length(...future.conditions) + 
[10:22:50.035]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:50.035]                   if (TRUE && !signal) {
[10:22:50.035]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.035]                     {
[10:22:50.035]                       inherits <- base::inherits
[10:22:50.035]                       invokeRestart <- base::invokeRestart
[10:22:50.035]                       is.null <- base::is.null
[10:22:50.035]                       muffled <- FALSE
[10:22:50.035]                       if (inherits(cond, "message")) {
[10:22:50.035]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:50.035]                         if (muffled) 
[10:22:50.035]                           invokeRestart("muffleMessage")
[10:22:50.035]                       }
[10:22:50.035]                       else if (inherits(cond, "warning")) {
[10:22:50.035]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:50.035]                         if (muffled) 
[10:22:50.035]                           invokeRestart("muffleWarning")
[10:22:50.035]                       }
[10:22:50.035]                       else if (inherits(cond, "condition")) {
[10:22:50.035]                         if (!is.null(pattern)) {
[10:22:50.035]                           computeRestarts <- base::computeRestarts
[10:22:50.035]                           grepl <- base::grepl
[10:22:50.035]                           restarts <- computeRestarts(cond)
[10:22:50.035]                           for (restart in restarts) {
[10:22:50.035]                             name <- restart$name
[10:22:50.035]                             if (is.null(name)) 
[10:22:50.035]                               next
[10:22:50.035]                             if (!grepl(pattern, name)) 
[10:22:50.035]                               next
[10:22:50.035]                             invokeRestart(restart)
[10:22:50.035]                             muffled <- TRUE
[10:22:50.035]                             break
[10:22:50.035]                           }
[10:22:50.035]                         }
[10:22:50.035]                       }
[10:22:50.035]                       invisible(muffled)
[10:22:50.035]                     }
[10:22:50.035]                     muffleCondition(cond, pattern = "^muffle")
[10:22:50.035]                   }
[10:22:50.035]                 }
[10:22:50.035]                 else {
[10:22:50.035]                   if (TRUE) {
[10:22:50.035]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.035]                     {
[10:22:50.035]                       inherits <- base::inherits
[10:22:50.035]                       invokeRestart <- base::invokeRestart
[10:22:50.035]                       is.null <- base::is.null
[10:22:50.035]                       muffled <- FALSE
[10:22:50.035]                       if (inherits(cond, "message")) {
[10:22:50.035]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:50.035]                         if (muffled) 
[10:22:50.035]                           invokeRestart("muffleMessage")
[10:22:50.035]                       }
[10:22:50.035]                       else if (inherits(cond, "warning")) {
[10:22:50.035]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:50.035]                         if (muffled) 
[10:22:50.035]                           invokeRestart("muffleWarning")
[10:22:50.035]                       }
[10:22:50.035]                       else if (inherits(cond, "condition")) {
[10:22:50.035]                         if (!is.null(pattern)) {
[10:22:50.035]                           computeRestarts <- base::computeRestarts
[10:22:50.035]                           grepl <- base::grepl
[10:22:50.035]                           restarts <- computeRestarts(cond)
[10:22:50.035]                           for (restart in restarts) {
[10:22:50.035]                             name <- restart$name
[10:22:50.035]                             if (is.null(name)) 
[10:22:50.035]                               next
[10:22:50.035]                             if (!grepl(pattern, name)) 
[10:22:50.035]                               next
[10:22:50.035]                             invokeRestart(restart)
[10:22:50.035]                             muffled <- TRUE
[10:22:50.035]                             break
[10:22:50.035]                           }
[10:22:50.035]                         }
[10:22:50.035]                       }
[10:22:50.035]                       invisible(muffled)
[10:22:50.035]                     }
[10:22:50.035]                     muffleCondition(cond, pattern = "^muffle")
[10:22:50.035]                   }
[10:22:50.035]                 }
[10:22:50.035]             }
[10:22:50.035]         }))
[10:22:50.035]     }, error = function(ex) {
[10:22:50.035]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:50.035]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:50.035]                 ...future.rng), started = ...future.startTime, 
[10:22:50.035]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:50.035]             version = "1.8"), class = "FutureResult")
[10:22:50.035]     }, finally = {
[10:22:50.035]         if (!identical(...future.workdir, getwd())) 
[10:22:50.035]             setwd(...future.workdir)
[10:22:50.035]         {
[10:22:50.035]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:50.035]                 ...future.oldOptions$nwarnings <- NULL
[10:22:50.035]             }
[10:22:50.035]             base::options(...future.oldOptions)
[10:22:50.035]             if (.Platform$OS.type == "windows") {
[10:22:50.035]                 old_names <- names(...future.oldEnvVars)
[10:22:50.035]                 envs <- base::Sys.getenv()
[10:22:50.035]                 names <- names(envs)
[10:22:50.035]                 common <- intersect(names, old_names)
[10:22:50.035]                 added <- setdiff(names, old_names)
[10:22:50.035]                 removed <- setdiff(old_names, names)
[10:22:50.035]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:50.035]                   envs[common]]
[10:22:50.035]                 NAMES <- toupper(changed)
[10:22:50.035]                 args <- list()
[10:22:50.035]                 for (kk in seq_along(NAMES)) {
[10:22:50.035]                   name <- changed[[kk]]
[10:22:50.035]                   NAME <- NAMES[[kk]]
[10:22:50.035]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.035]                     next
[10:22:50.035]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:50.035]                 }
[10:22:50.035]                 NAMES <- toupper(added)
[10:22:50.035]                 for (kk in seq_along(NAMES)) {
[10:22:50.035]                   name <- added[[kk]]
[10:22:50.035]                   NAME <- NAMES[[kk]]
[10:22:50.035]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.035]                     next
[10:22:50.035]                   args[[name]] <- ""
[10:22:50.035]                 }
[10:22:50.035]                 NAMES <- toupper(removed)
[10:22:50.035]                 for (kk in seq_along(NAMES)) {
[10:22:50.035]                   name <- removed[[kk]]
[10:22:50.035]                   NAME <- NAMES[[kk]]
[10:22:50.035]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.035]                     next
[10:22:50.035]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:50.035]                 }
[10:22:50.035]                 if (length(args) > 0) 
[10:22:50.035]                   base::do.call(base::Sys.setenv, args = args)
[10:22:50.035]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:50.035]             }
[10:22:50.035]             else {
[10:22:50.035]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:50.035]             }
[10:22:50.035]             {
[10:22:50.035]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:50.035]                   0L) {
[10:22:50.035]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:50.035]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:50.035]                   base::options(opts)
[10:22:50.035]                 }
[10:22:50.035]                 {
[10:22:50.035]                   {
[10:22:50.035]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:50.035]                     NULL
[10:22:50.035]                   }
[10:22:50.035]                   options(future.plan = NULL)
[10:22:50.035]                   if (is.na(NA_character_)) 
[10:22:50.035]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:50.035]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:50.035]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:50.035]                     .init = FALSE)
[10:22:50.035]                 }
[10:22:50.035]             }
[10:22:50.035]         }
[10:22:50.035]     })
[10:22:50.035]     if (TRUE) {
[10:22:50.035]         base::sink(type = "output", split = FALSE)
[10:22:50.035]         if (TRUE) {
[10:22:50.035]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:50.035]         }
[10:22:50.035]         else {
[10:22:50.035]             ...future.result["stdout"] <- base::list(NULL)
[10:22:50.035]         }
[10:22:50.035]         base::close(...future.stdout)
[10:22:50.035]         ...future.stdout <- NULL
[10:22:50.035]     }
[10:22:50.035]     ...future.result$conditions <- ...future.conditions
[10:22:50.035]     ...future.result$finished <- base::Sys.time()
[10:22:50.035]     ...future.result
[10:22:50.035] }
[10:22:50.038] MultisessionFuture started
[10:22:50.038] - Launch lazy future ... done
[10:22:50.038] run() for ‘MultisessionFuture’ ... done
[10:22:50.038] resolve() on list environment ...
[10:22:50.038]  recursive: 0
[10:22:50.039]  length: 3
[10:22:50.039]  elements: ‘a’, ‘b’, ‘c’
[10:22:50.060]  length: 2 (resolved future 3)
[10:22:50.071] receiveMessageFromWorker() for ClusterFuture ...
[10:22:50.071] - Validating connection of MultisessionFuture
[10:22:50.071] - received message: FutureResult
[10:22:50.071] - Received FutureResult
[10:22:50.072] - Erased future from FutureRegistry
[10:22:50.072] result() for ClusterFuture ...
[10:22:50.072] - result already collected: FutureResult
[10:22:50.072] result() for ClusterFuture ... done
[10:22:50.072] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:50.072] Future #1
[10:22:50.072]  length: 1 (resolved future 1)
[10:22:50.080] receiveMessageFromWorker() for ClusterFuture ...
[10:22:50.080] - Validating connection of MultisessionFuture
[10:22:50.080] - received message: FutureResult
[10:22:50.081] - Received FutureResult
[10:22:50.081] - Erased future from FutureRegistry
[10:22:50.081] result() for ClusterFuture ...
[10:22:50.081] - result already collected: FutureResult
[10:22:50.081] result() for ClusterFuture ... done
[10:22:50.081] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:50.081] Future #2
[10:22:50.081]  length: 0 (resolved future 2)
[10:22:50.081] resolve() on list environment ... DONE
[10:22:50.082] getGlobalsAndPackages() ...
[10:22:50.082] Searching for globals...
[10:22:50.083] - globals found: [1] ‘{’
[10:22:50.083] Searching for globals ... DONE
[10:22:50.083] Resolving globals: FALSE
[10:22:50.083] 
[10:22:50.083] 
[10:22:50.083] getGlobalsAndPackages() ... DONE
[10:22:50.083] run() for ‘Future’ ...
[10:22:50.084] - state: ‘created’
[10:22:50.084] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:50.098] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:50.098] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:50.098]   - Field: ‘node’
[10:22:50.098]   - Field: ‘label’
[10:22:50.098]   - Field: ‘local’
[10:22:50.098]   - Field: ‘owner’
[10:22:50.098]   - Field: ‘envir’
[10:22:50.098]   - Field: ‘workers’
[10:22:50.098]   - Field: ‘packages’
[10:22:50.098]   - Field: ‘gc’
[10:22:50.099]   - Field: ‘conditions’
[10:22:50.099]   - Field: ‘persistent’
[10:22:50.099]   - Field: ‘expr’
[10:22:50.099]   - Field: ‘uuid’
[10:22:50.099]   - Field: ‘seed’
[10:22:50.099]   - Field: ‘version’
[10:22:50.099]   - Field: ‘result’
[10:22:50.099]   - Field: ‘asynchronous’
[10:22:50.099]   - Field: ‘calls’
[10:22:50.099]   - Field: ‘globals’
[10:22:50.099]   - Field: ‘stdout’
[10:22:50.099]   - Field: ‘earlySignal’
[10:22:50.100]   - Field: ‘lazy’
[10:22:50.100]   - Field: ‘state’
[10:22:50.100] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:50.100] - Launch lazy future ...
[10:22:50.100] Packages needed by the future expression (n = 0): <none>
[10:22:50.100] Packages needed by future strategies (n = 0): <none>
[10:22:50.101] {
[10:22:50.101]     {
[10:22:50.101]         {
[10:22:50.101]             ...future.startTime <- base::Sys.time()
[10:22:50.101]             {
[10:22:50.101]                 {
[10:22:50.101]                   {
[10:22:50.101]                     {
[10:22:50.101]                       base::local({
[10:22:50.101]                         has_future <- base::requireNamespace("future", 
[10:22:50.101]                           quietly = TRUE)
[10:22:50.101]                         if (has_future) {
[10:22:50.101]                           ns <- base::getNamespace("future")
[10:22:50.101]                           version <- ns[[".package"]][["version"]]
[10:22:50.101]                           if (is.null(version)) 
[10:22:50.101]                             version <- utils::packageVersion("future")
[10:22:50.101]                         }
[10:22:50.101]                         else {
[10:22:50.101]                           version <- NULL
[10:22:50.101]                         }
[10:22:50.101]                         if (!has_future || version < "1.8.0") {
[10:22:50.101]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:50.101]                             "", base::R.version$version.string), 
[10:22:50.101]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:50.101]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:50.101]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:50.101]                               "release", "version")], collapse = " "), 
[10:22:50.101]                             hostname = base::Sys.info()[["nodename"]])
[10:22:50.101]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:50.101]                             info)
[10:22:50.101]                           info <- base::paste(info, collapse = "; ")
[10:22:50.101]                           if (!has_future) {
[10:22:50.101]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:50.101]                               info)
[10:22:50.101]                           }
[10:22:50.101]                           else {
[10:22:50.101]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:50.101]                               info, version)
[10:22:50.101]                           }
[10:22:50.101]                           base::stop(msg)
[10:22:50.101]                         }
[10:22:50.101]                       })
[10:22:50.101]                     }
[10:22:50.101]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:50.101]                     base::options(mc.cores = 1L)
[10:22:50.101]                   }
[10:22:50.101]                   ...future.strategy.old <- future::plan("list")
[10:22:50.101]                   options(future.plan = NULL)
[10:22:50.101]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:50.101]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:50.101]                 }
[10:22:50.101]                 ...future.workdir <- getwd()
[10:22:50.101]             }
[10:22:50.101]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:50.101]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:50.101]         }
[10:22:50.101]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:50.101]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:50.101]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:50.101]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:50.101]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:50.101]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:50.101]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:50.101]             base::names(...future.oldOptions))
[10:22:50.101]     }
[10:22:50.101]     if (FALSE) {
[10:22:50.101]     }
[10:22:50.101]     else {
[10:22:50.101]         if (TRUE) {
[10:22:50.101]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:50.101]                 open = "w")
[10:22:50.101]         }
[10:22:50.101]         else {
[10:22:50.101]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:50.101]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:50.101]         }
[10:22:50.101]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:50.101]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:50.101]             base::sink(type = "output", split = FALSE)
[10:22:50.101]             base::close(...future.stdout)
[10:22:50.101]         }, add = TRUE)
[10:22:50.101]     }
[10:22:50.101]     ...future.frame <- base::sys.nframe()
[10:22:50.101]     ...future.conditions <- base::list()
[10:22:50.101]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:50.101]     if (FALSE) {
[10:22:50.101]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:50.101]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:50.101]     }
[10:22:50.101]     ...future.result <- base::tryCatch({
[10:22:50.101]         base::withCallingHandlers({
[10:22:50.101]             ...future.value <- base::withVisible(base::local({
[10:22:50.101]                 ...future.makeSendCondition <- base::local({
[10:22:50.101]                   sendCondition <- NULL
[10:22:50.101]                   function(frame = 1L) {
[10:22:50.101]                     if (is.function(sendCondition)) 
[10:22:50.101]                       return(sendCondition)
[10:22:50.101]                     ns <- getNamespace("parallel")
[10:22:50.101]                     if (exists("sendData", mode = "function", 
[10:22:50.101]                       envir = ns)) {
[10:22:50.101]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:50.101]                         envir = ns)
[10:22:50.101]                       envir <- sys.frame(frame)
[10:22:50.101]                       master <- NULL
[10:22:50.101]                       while (!identical(envir, .GlobalEnv) && 
[10:22:50.101]                         !identical(envir, emptyenv())) {
[10:22:50.101]                         if (exists("master", mode = "list", envir = envir, 
[10:22:50.101]                           inherits = FALSE)) {
[10:22:50.101]                           master <- get("master", mode = "list", 
[10:22:50.101]                             envir = envir, inherits = FALSE)
[10:22:50.101]                           if (inherits(master, c("SOCKnode", 
[10:22:50.101]                             "SOCK0node"))) {
[10:22:50.101]                             sendCondition <<- function(cond) {
[10:22:50.101]                               data <- list(type = "VALUE", value = cond, 
[10:22:50.101]                                 success = TRUE)
[10:22:50.101]                               parallel_sendData(master, data)
[10:22:50.101]                             }
[10:22:50.101]                             return(sendCondition)
[10:22:50.101]                           }
[10:22:50.101]                         }
[10:22:50.101]                         frame <- frame + 1L
[10:22:50.101]                         envir <- sys.frame(frame)
[10:22:50.101]                       }
[10:22:50.101]                     }
[10:22:50.101]                     sendCondition <<- function(cond) NULL
[10:22:50.101]                   }
[10:22:50.101]                 })
[10:22:50.101]                 withCallingHandlers({
[10:22:50.101]                   {
[10:22:50.101]                     1
[10:22:50.101]                   }
[10:22:50.101]                 }, immediateCondition = function(cond) {
[10:22:50.101]                   sendCondition <- ...future.makeSendCondition()
[10:22:50.101]                   sendCondition(cond)
[10:22:50.101]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.101]                   {
[10:22:50.101]                     inherits <- base::inherits
[10:22:50.101]                     invokeRestart <- base::invokeRestart
[10:22:50.101]                     is.null <- base::is.null
[10:22:50.101]                     muffled <- FALSE
[10:22:50.101]                     if (inherits(cond, "message")) {
[10:22:50.101]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:50.101]                       if (muffled) 
[10:22:50.101]                         invokeRestart("muffleMessage")
[10:22:50.101]                     }
[10:22:50.101]                     else if (inherits(cond, "warning")) {
[10:22:50.101]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:50.101]                       if (muffled) 
[10:22:50.101]                         invokeRestart("muffleWarning")
[10:22:50.101]                     }
[10:22:50.101]                     else if (inherits(cond, "condition")) {
[10:22:50.101]                       if (!is.null(pattern)) {
[10:22:50.101]                         computeRestarts <- base::computeRestarts
[10:22:50.101]                         grepl <- base::grepl
[10:22:50.101]                         restarts <- computeRestarts(cond)
[10:22:50.101]                         for (restart in restarts) {
[10:22:50.101]                           name <- restart$name
[10:22:50.101]                           if (is.null(name)) 
[10:22:50.101]                             next
[10:22:50.101]                           if (!grepl(pattern, name)) 
[10:22:50.101]                             next
[10:22:50.101]                           invokeRestart(restart)
[10:22:50.101]                           muffled <- TRUE
[10:22:50.101]                           break
[10:22:50.101]                         }
[10:22:50.101]                       }
[10:22:50.101]                     }
[10:22:50.101]                     invisible(muffled)
[10:22:50.101]                   }
[10:22:50.101]                   muffleCondition(cond)
[10:22:50.101]                 })
[10:22:50.101]             }))
[10:22:50.101]             future::FutureResult(value = ...future.value$value, 
[10:22:50.101]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:50.101]                   ...future.rng), globalenv = if (FALSE) 
[10:22:50.101]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:50.101]                     ...future.globalenv.names))
[10:22:50.101]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:50.101]         }, condition = base::local({
[10:22:50.101]             c <- base::c
[10:22:50.101]             inherits <- base::inherits
[10:22:50.101]             invokeRestart <- base::invokeRestart
[10:22:50.101]             length <- base::length
[10:22:50.101]             list <- base::list
[10:22:50.101]             seq.int <- base::seq.int
[10:22:50.101]             signalCondition <- base::signalCondition
[10:22:50.101]             sys.calls <- base::sys.calls
[10:22:50.101]             `[[` <- base::`[[`
[10:22:50.101]             `+` <- base::`+`
[10:22:50.101]             `<<-` <- base::`<<-`
[10:22:50.101]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:50.101]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:50.101]                   3L)]
[10:22:50.101]             }
[10:22:50.101]             function(cond) {
[10:22:50.101]                 is_error <- inherits(cond, "error")
[10:22:50.101]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:50.101]                   NULL)
[10:22:50.101]                 if (is_error) {
[10:22:50.101]                   sessionInformation <- function() {
[10:22:50.101]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:50.101]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:50.101]                       search = base::search(), system = base::Sys.info())
[10:22:50.101]                   }
[10:22:50.101]                   ...future.conditions[[length(...future.conditions) + 
[10:22:50.101]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:50.101]                     cond$call), session = sessionInformation(), 
[10:22:50.101]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:50.101]                   signalCondition(cond)
[10:22:50.101]                 }
[10:22:50.101]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:50.101]                 "immediateCondition"))) {
[10:22:50.101]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:50.101]                   ...future.conditions[[length(...future.conditions) + 
[10:22:50.101]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:50.101]                   if (TRUE && !signal) {
[10:22:50.101]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.101]                     {
[10:22:50.101]                       inherits <- base::inherits
[10:22:50.101]                       invokeRestart <- base::invokeRestart
[10:22:50.101]                       is.null <- base::is.null
[10:22:50.101]                       muffled <- FALSE
[10:22:50.101]                       if (inherits(cond, "message")) {
[10:22:50.101]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:50.101]                         if (muffled) 
[10:22:50.101]                           invokeRestart("muffleMessage")
[10:22:50.101]                       }
[10:22:50.101]                       else if (inherits(cond, "warning")) {
[10:22:50.101]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:50.101]                         if (muffled) 
[10:22:50.101]                           invokeRestart("muffleWarning")
[10:22:50.101]                       }
[10:22:50.101]                       else if (inherits(cond, "condition")) {
[10:22:50.101]                         if (!is.null(pattern)) {
[10:22:50.101]                           computeRestarts <- base::computeRestarts
[10:22:50.101]                           grepl <- base::grepl
[10:22:50.101]                           restarts <- computeRestarts(cond)
[10:22:50.101]                           for (restart in restarts) {
[10:22:50.101]                             name <- restart$name
[10:22:50.101]                             if (is.null(name)) 
[10:22:50.101]                               next
[10:22:50.101]                             if (!grepl(pattern, name)) 
[10:22:50.101]                               next
[10:22:50.101]                             invokeRestart(restart)
[10:22:50.101]                             muffled <- TRUE
[10:22:50.101]                             break
[10:22:50.101]                           }
[10:22:50.101]                         }
[10:22:50.101]                       }
[10:22:50.101]                       invisible(muffled)
[10:22:50.101]                     }
[10:22:50.101]                     muffleCondition(cond, pattern = "^muffle")
[10:22:50.101]                   }
[10:22:50.101]                 }
[10:22:50.101]                 else {
[10:22:50.101]                   if (TRUE) {
[10:22:50.101]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.101]                     {
[10:22:50.101]                       inherits <- base::inherits
[10:22:50.101]                       invokeRestart <- base::invokeRestart
[10:22:50.101]                       is.null <- base::is.null
[10:22:50.101]                       muffled <- FALSE
[10:22:50.101]                       if (inherits(cond, "message")) {
[10:22:50.101]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:50.101]                         if (muffled) 
[10:22:50.101]                           invokeRestart("muffleMessage")
[10:22:50.101]                       }
[10:22:50.101]                       else if (inherits(cond, "warning")) {
[10:22:50.101]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:50.101]                         if (muffled) 
[10:22:50.101]                           invokeRestart("muffleWarning")
[10:22:50.101]                       }
[10:22:50.101]                       else if (inherits(cond, "condition")) {
[10:22:50.101]                         if (!is.null(pattern)) {
[10:22:50.101]                           computeRestarts <- base::computeRestarts
[10:22:50.101]                           grepl <- base::grepl
[10:22:50.101]                           restarts <- computeRestarts(cond)
[10:22:50.101]                           for (restart in restarts) {
[10:22:50.101]                             name <- restart$name
[10:22:50.101]                             if (is.null(name)) 
[10:22:50.101]                               next
[10:22:50.101]                             if (!grepl(pattern, name)) 
[10:22:50.101]                               next
[10:22:50.101]                             invokeRestart(restart)
[10:22:50.101]                             muffled <- TRUE
[10:22:50.101]                             break
[10:22:50.101]                           }
[10:22:50.101]                         }
[10:22:50.101]                       }
[10:22:50.101]                       invisible(muffled)
[10:22:50.101]                     }
[10:22:50.101]                     muffleCondition(cond, pattern = "^muffle")
[10:22:50.101]                   }
[10:22:50.101]                 }
[10:22:50.101]             }
[10:22:50.101]         }))
[10:22:50.101]     }, error = function(ex) {
[10:22:50.101]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:50.101]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:50.101]                 ...future.rng), started = ...future.startTime, 
[10:22:50.101]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:50.101]             version = "1.8"), class = "FutureResult")
[10:22:50.101]     }, finally = {
[10:22:50.101]         if (!identical(...future.workdir, getwd())) 
[10:22:50.101]             setwd(...future.workdir)
[10:22:50.101]         {
[10:22:50.101]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:50.101]                 ...future.oldOptions$nwarnings <- NULL
[10:22:50.101]             }
[10:22:50.101]             base::options(...future.oldOptions)
[10:22:50.101]             if (.Platform$OS.type == "windows") {
[10:22:50.101]                 old_names <- names(...future.oldEnvVars)
[10:22:50.101]                 envs <- base::Sys.getenv()
[10:22:50.101]                 names <- names(envs)
[10:22:50.101]                 common <- intersect(names, old_names)
[10:22:50.101]                 added <- setdiff(names, old_names)
[10:22:50.101]                 removed <- setdiff(old_names, names)
[10:22:50.101]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:50.101]                   envs[common]]
[10:22:50.101]                 NAMES <- toupper(changed)
[10:22:50.101]                 args <- list()
[10:22:50.101]                 for (kk in seq_along(NAMES)) {
[10:22:50.101]                   name <- changed[[kk]]
[10:22:50.101]                   NAME <- NAMES[[kk]]
[10:22:50.101]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.101]                     next
[10:22:50.101]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:50.101]                 }
[10:22:50.101]                 NAMES <- toupper(added)
[10:22:50.101]                 for (kk in seq_along(NAMES)) {
[10:22:50.101]                   name <- added[[kk]]
[10:22:50.101]                   NAME <- NAMES[[kk]]
[10:22:50.101]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.101]                     next
[10:22:50.101]                   args[[name]] <- ""
[10:22:50.101]                 }
[10:22:50.101]                 NAMES <- toupper(removed)
[10:22:50.101]                 for (kk in seq_along(NAMES)) {
[10:22:50.101]                   name <- removed[[kk]]
[10:22:50.101]                   NAME <- NAMES[[kk]]
[10:22:50.101]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.101]                     next
[10:22:50.101]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:50.101]                 }
[10:22:50.101]                 if (length(args) > 0) 
[10:22:50.101]                   base::do.call(base::Sys.setenv, args = args)
[10:22:50.101]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:50.101]             }
[10:22:50.101]             else {
[10:22:50.101]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:50.101]             }
[10:22:50.101]             {
[10:22:50.101]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:50.101]                   0L) {
[10:22:50.101]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:50.101]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:50.101]                   base::options(opts)
[10:22:50.101]                 }
[10:22:50.101]                 {
[10:22:50.101]                   {
[10:22:50.101]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:50.101]                     NULL
[10:22:50.101]                   }
[10:22:50.101]                   options(future.plan = NULL)
[10:22:50.101]                   if (is.na(NA_character_)) 
[10:22:50.101]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:50.101]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:50.101]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:50.101]                     .init = FALSE)
[10:22:50.101]                 }
[10:22:50.101]             }
[10:22:50.101]         }
[10:22:50.101]     })
[10:22:50.101]     if (TRUE) {
[10:22:50.101]         base::sink(type = "output", split = FALSE)
[10:22:50.101]         if (TRUE) {
[10:22:50.101]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:50.101]         }
[10:22:50.101]         else {
[10:22:50.101]             ...future.result["stdout"] <- base::list(NULL)
[10:22:50.101]         }
[10:22:50.101]         base::close(...future.stdout)
[10:22:50.101]         ...future.stdout <- NULL
[10:22:50.101]     }
[10:22:50.101]     ...future.result$conditions <- ...future.conditions
[10:22:50.101]     ...future.result$finished <- base::Sys.time()
[10:22:50.101]     ...future.result
[10:22:50.101] }
[10:22:50.104] MultisessionFuture started
[10:22:50.104] - Launch lazy future ... done
[10:22:50.104] run() for ‘MultisessionFuture’ ... done
[10:22:50.104] getGlobalsAndPackages() ...
[10:22:50.105] Searching for globals...
[10:22:50.105] - globals found: [1] ‘{’
[10:22:50.105] Searching for globals ... DONE
[10:22:50.105] Resolving globals: FALSE
[10:22:50.106] 
[10:22:50.106] 
[10:22:50.106] getGlobalsAndPackages() ... DONE
[10:22:50.106] run() for ‘Future’ ...
[10:22:50.106] - state: ‘created’
[10:22:50.106] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:50.120] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:50.120] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:50.120]   - Field: ‘node’
[10:22:50.120]   - Field: ‘label’
[10:22:50.120]   - Field: ‘local’
[10:22:50.120]   - Field: ‘owner’
[10:22:50.121]   - Field: ‘envir’
[10:22:50.121]   - Field: ‘workers’
[10:22:50.121]   - Field: ‘packages’
[10:22:50.121]   - Field: ‘gc’
[10:22:50.121]   - Field: ‘conditions’
[10:22:50.121]   - Field: ‘persistent’
[10:22:50.121]   - Field: ‘expr’
[10:22:50.121]   - Field: ‘uuid’
[10:22:50.121]   - Field: ‘seed’
[10:22:50.121]   - Field: ‘version’
[10:22:50.121]   - Field: ‘result’
[10:22:50.121]   - Field: ‘asynchronous’
[10:22:50.122]   - Field: ‘calls’
[10:22:50.122]   - Field: ‘globals’
[10:22:50.122]   - Field: ‘stdout’
[10:22:50.122]   - Field: ‘earlySignal’
[10:22:50.122]   - Field: ‘lazy’
[10:22:50.122]   - Field: ‘state’
[10:22:50.122] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:50.122] - Launch lazy future ...
[10:22:50.122] Packages needed by the future expression (n = 0): <none>
[10:22:50.123] Packages needed by future strategies (n = 0): <none>
[10:22:50.123] {
[10:22:50.123]     {
[10:22:50.123]         {
[10:22:50.123]             ...future.startTime <- base::Sys.time()
[10:22:50.123]             {
[10:22:50.123]                 {
[10:22:50.123]                   {
[10:22:50.123]                     {
[10:22:50.123]                       base::local({
[10:22:50.123]                         has_future <- base::requireNamespace("future", 
[10:22:50.123]                           quietly = TRUE)
[10:22:50.123]                         if (has_future) {
[10:22:50.123]                           ns <- base::getNamespace("future")
[10:22:50.123]                           version <- ns[[".package"]][["version"]]
[10:22:50.123]                           if (is.null(version)) 
[10:22:50.123]                             version <- utils::packageVersion("future")
[10:22:50.123]                         }
[10:22:50.123]                         else {
[10:22:50.123]                           version <- NULL
[10:22:50.123]                         }
[10:22:50.123]                         if (!has_future || version < "1.8.0") {
[10:22:50.123]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:50.123]                             "", base::R.version$version.string), 
[10:22:50.123]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:50.123]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:50.123]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:50.123]                               "release", "version")], collapse = " "), 
[10:22:50.123]                             hostname = base::Sys.info()[["nodename"]])
[10:22:50.123]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:50.123]                             info)
[10:22:50.123]                           info <- base::paste(info, collapse = "; ")
[10:22:50.123]                           if (!has_future) {
[10:22:50.123]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:50.123]                               info)
[10:22:50.123]                           }
[10:22:50.123]                           else {
[10:22:50.123]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:50.123]                               info, version)
[10:22:50.123]                           }
[10:22:50.123]                           base::stop(msg)
[10:22:50.123]                         }
[10:22:50.123]                       })
[10:22:50.123]                     }
[10:22:50.123]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:50.123]                     base::options(mc.cores = 1L)
[10:22:50.123]                   }
[10:22:50.123]                   ...future.strategy.old <- future::plan("list")
[10:22:50.123]                   options(future.plan = NULL)
[10:22:50.123]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:50.123]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:50.123]                 }
[10:22:50.123]                 ...future.workdir <- getwd()
[10:22:50.123]             }
[10:22:50.123]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:50.123]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:50.123]         }
[10:22:50.123]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:50.123]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:50.123]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:50.123]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:50.123]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:50.123]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:50.123]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:50.123]             base::names(...future.oldOptions))
[10:22:50.123]     }
[10:22:50.123]     if (FALSE) {
[10:22:50.123]     }
[10:22:50.123]     else {
[10:22:50.123]         if (TRUE) {
[10:22:50.123]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:50.123]                 open = "w")
[10:22:50.123]         }
[10:22:50.123]         else {
[10:22:50.123]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:50.123]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:50.123]         }
[10:22:50.123]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:50.123]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:50.123]             base::sink(type = "output", split = FALSE)
[10:22:50.123]             base::close(...future.stdout)
[10:22:50.123]         }, add = TRUE)
[10:22:50.123]     }
[10:22:50.123]     ...future.frame <- base::sys.nframe()
[10:22:50.123]     ...future.conditions <- base::list()
[10:22:50.123]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:50.123]     if (FALSE) {
[10:22:50.123]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:50.123]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:50.123]     }
[10:22:50.123]     ...future.result <- base::tryCatch({
[10:22:50.123]         base::withCallingHandlers({
[10:22:50.123]             ...future.value <- base::withVisible(base::local({
[10:22:50.123]                 ...future.makeSendCondition <- base::local({
[10:22:50.123]                   sendCondition <- NULL
[10:22:50.123]                   function(frame = 1L) {
[10:22:50.123]                     if (is.function(sendCondition)) 
[10:22:50.123]                       return(sendCondition)
[10:22:50.123]                     ns <- getNamespace("parallel")
[10:22:50.123]                     if (exists("sendData", mode = "function", 
[10:22:50.123]                       envir = ns)) {
[10:22:50.123]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:50.123]                         envir = ns)
[10:22:50.123]                       envir <- sys.frame(frame)
[10:22:50.123]                       master <- NULL
[10:22:50.123]                       while (!identical(envir, .GlobalEnv) && 
[10:22:50.123]                         !identical(envir, emptyenv())) {
[10:22:50.123]                         if (exists("master", mode = "list", envir = envir, 
[10:22:50.123]                           inherits = FALSE)) {
[10:22:50.123]                           master <- get("master", mode = "list", 
[10:22:50.123]                             envir = envir, inherits = FALSE)
[10:22:50.123]                           if (inherits(master, c("SOCKnode", 
[10:22:50.123]                             "SOCK0node"))) {
[10:22:50.123]                             sendCondition <<- function(cond) {
[10:22:50.123]                               data <- list(type = "VALUE", value = cond, 
[10:22:50.123]                                 success = TRUE)
[10:22:50.123]                               parallel_sendData(master, data)
[10:22:50.123]                             }
[10:22:50.123]                             return(sendCondition)
[10:22:50.123]                           }
[10:22:50.123]                         }
[10:22:50.123]                         frame <- frame + 1L
[10:22:50.123]                         envir <- sys.frame(frame)
[10:22:50.123]                       }
[10:22:50.123]                     }
[10:22:50.123]                     sendCondition <<- function(cond) NULL
[10:22:50.123]                   }
[10:22:50.123]                 })
[10:22:50.123]                 withCallingHandlers({
[10:22:50.123]                   {
[10:22:50.123]                     2
[10:22:50.123]                   }
[10:22:50.123]                 }, immediateCondition = function(cond) {
[10:22:50.123]                   sendCondition <- ...future.makeSendCondition()
[10:22:50.123]                   sendCondition(cond)
[10:22:50.123]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.123]                   {
[10:22:50.123]                     inherits <- base::inherits
[10:22:50.123]                     invokeRestart <- base::invokeRestart
[10:22:50.123]                     is.null <- base::is.null
[10:22:50.123]                     muffled <- FALSE
[10:22:50.123]                     if (inherits(cond, "message")) {
[10:22:50.123]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:50.123]                       if (muffled) 
[10:22:50.123]                         invokeRestart("muffleMessage")
[10:22:50.123]                     }
[10:22:50.123]                     else if (inherits(cond, "warning")) {
[10:22:50.123]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:50.123]                       if (muffled) 
[10:22:50.123]                         invokeRestart("muffleWarning")
[10:22:50.123]                     }
[10:22:50.123]                     else if (inherits(cond, "condition")) {
[10:22:50.123]                       if (!is.null(pattern)) {
[10:22:50.123]                         computeRestarts <- base::computeRestarts
[10:22:50.123]                         grepl <- base::grepl
[10:22:50.123]                         restarts <- computeRestarts(cond)
[10:22:50.123]                         for (restart in restarts) {
[10:22:50.123]                           name <- restart$name
[10:22:50.123]                           if (is.null(name)) 
[10:22:50.123]                             next
[10:22:50.123]                           if (!grepl(pattern, name)) 
[10:22:50.123]                             next
[10:22:50.123]                           invokeRestart(restart)
[10:22:50.123]                           muffled <- TRUE
[10:22:50.123]                           break
[10:22:50.123]                         }
[10:22:50.123]                       }
[10:22:50.123]                     }
[10:22:50.123]                     invisible(muffled)
[10:22:50.123]                   }
[10:22:50.123]                   muffleCondition(cond)
[10:22:50.123]                 })
[10:22:50.123]             }))
[10:22:50.123]             future::FutureResult(value = ...future.value$value, 
[10:22:50.123]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:50.123]                   ...future.rng), globalenv = if (FALSE) 
[10:22:50.123]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:50.123]                     ...future.globalenv.names))
[10:22:50.123]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:50.123]         }, condition = base::local({
[10:22:50.123]             c <- base::c
[10:22:50.123]             inherits <- base::inherits
[10:22:50.123]             invokeRestart <- base::invokeRestart
[10:22:50.123]             length <- base::length
[10:22:50.123]             list <- base::list
[10:22:50.123]             seq.int <- base::seq.int
[10:22:50.123]             signalCondition <- base::signalCondition
[10:22:50.123]             sys.calls <- base::sys.calls
[10:22:50.123]             `[[` <- base::`[[`
[10:22:50.123]             `+` <- base::`+`
[10:22:50.123]             `<<-` <- base::`<<-`
[10:22:50.123]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:50.123]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:50.123]                   3L)]
[10:22:50.123]             }
[10:22:50.123]             function(cond) {
[10:22:50.123]                 is_error <- inherits(cond, "error")
[10:22:50.123]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:50.123]                   NULL)
[10:22:50.123]                 if (is_error) {
[10:22:50.123]                   sessionInformation <- function() {
[10:22:50.123]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:50.123]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:50.123]                       search = base::search(), system = base::Sys.info())
[10:22:50.123]                   }
[10:22:50.123]                   ...future.conditions[[length(...future.conditions) + 
[10:22:50.123]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:50.123]                     cond$call), session = sessionInformation(), 
[10:22:50.123]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:50.123]                   signalCondition(cond)
[10:22:50.123]                 }
[10:22:50.123]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:50.123]                 "immediateCondition"))) {
[10:22:50.123]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:50.123]                   ...future.conditions[[length(...future.conditions) + 
[10:22:50.123]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:50.123]                   if (TRUE && !signal) {
[10:22:50.123]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.123]                     {
[10:22:50.123]                       inherits <- base::inherits
[10:22:50.123]                       invokeRestart <- base::invokeRestart
[10:22:50.123]                       is.null <- base::is.null
[10:22:50.123]                       muffled <- FALSE
[10:22:50.123]                       if (inherits(cond, "message")) {
[10:22:50.123]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:50.123]                         if (muffled) 
[10:22:50.123]                           invokeRestart("muffleMessage")
[10:22:50.123]                       }
[10:22:50.123]                       else if (inherits(cond, "warning")) {
[10:22:50.123]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:50.123]                         if (muffled) 
[10:22:50.123]                           invokeRestart("muffleWarning")
[10:22:50.123]                       }
[10:22:50.123]                       else if (inherits(cond, "condition")) {
[10:22:50.123]                         if (!is.null(pattern)) {
[10:22:50.123]                           computeRestarts <- base::computeRestarts
[10:22:50.123]                           grepl <- base::grepl
[10:22:50.123]                           restarts <- computeRestarts(cond)
[10:22:50.123]                           for (restart in restarts) {
[10:22:50.123]                             name <- restart$name
[10:22:50.123]                             if (is.null(name)) 
[10:22:50.123]                               next
[10:22:50.123]                             if (!grepl(pattern, name)) 
[10:22:50.123]                               next
[10:22:50.123]                             invokeRestart(restart)
[10:22:50.123]                             muffled <- TRUE
[10:22:50.123]                             break
[10:22:50.123]                           }
[10:22:50.123]                         }
[10:22:50.123]                       }
[10:22:50.123]                       invisible(muffled)
[10:22:50.123]                     }
[10:22:50.123]                     muffleCondition(cond, pattern = "^muffle")
[10:22:50.123]                   }
[10:22:50.123]                 }
[10:22:50.123]                 else {
[10:22:50.123]                   if (TRUE) {
[10:22:50.123]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.123]                     {
[10:22:50.123]                       inherits <- base::inherits
[10:22:50.123]                       invokeRestart <- base::invokeRestart
[10:22:50.123]                       is.null <- base::is.null
[10:22:50.123]                       muffled <- FALSE
[10:22:50.123]                       if (inherits(cond, "message")) {
[10:22:50.123]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:50.123]                         if (muffled) 
[10:22:50.123]                           invokeRestart("muffleMessage")
[10:22:50.123]                       }
[10:22:50.123]                       else if (inherits(cond, "warning")) {
[10:22:50.123]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:50.123]                         if (muffled) 
[10:22:50.123]                           invokeRestart("muffleWarning")
[10:22:50.123]                       }
[10:22:50.123]                       else if (inherits(cond, "condition")) {
[10:22:50.123]                         if (!is.null(pattern)) {
[10:22:50.123]                           computeRestarts <- base::computeRestarts
[10:22:50.123]                           grepl <- base::grepl
[10:22:50.123]                           restarts <- computeRestarts(cond)
[10:22:50.123]                           for (restart in restarts) {
[10:22:50.123]                             name <- restart$name
[10:22:50.123]                             if (is.null(name)) 
[10:22:50.123]                               next
[10:22:50.123]                             if (!grepl(pattern, name)) 
[10:22:50.123]                               next
[10:22:50.123]                             invokeRestart(restart)
[10:22:50.123]                             muffled <- TRUE
[10:22:50.123]                             break
[10:22:50.123]                           }
[10:22:50.123]                         }
[10:22:50.123]                       }
[10:22:50.123]                       invisible(muffled)
[10:22:50.123]                     }
[10:22:50.123]                     muffleCondition(cond, pattern = "^muffle")
[10:22:50.123]                   }
[10:22:50.123]                 }
[10:22:50.123]             }
[10:22:50.123]         }))
[10:22:50.123]     }, error = function(ex) {
[10:22:50.123]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:50.123]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:50.123]                 ...future.rng), started = ...future.startTime, 
[10:22:50.123]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:50.123]             version = "1.8"), class = "FutureResult")
[10:22:50.123]     }, finally = {
[10:22:50.123]         if (!identical(...future.workdir, getwd())) 
[10:22:50.123]             setwd(...future.workdir)
[10:22:50.123]         {
[10:22:50.123]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:50.123]                 ...future.oldOptions$nwarnings <- NULL
[10:22:50.123]             }
[10:22:50.123]             base::options(...future.oldOptions)
[10:22:50.123]             if (.Platform$OS.type == "windows") {
[10:22:50.123]                 old_names <- names(...future.oldEnvVars)
[10:22:50.123]                 envs <- base::Sys.getenv()
[10:22:50.123]                 names <- names(envs)
[10:22:50.123]                 common <- intersect(names, old_names)
[10:22:50.123]                 added <- setdiff(names, old_names)
[10:22:50.123]                 removed <- setdiff(old_names, names)
[10:22:50.123]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:50.123]                   envs[common]]
[10:22:50.123]                 NAMES <- toupper(changed)
[10:22:50.123]                 args <- list()
[10:22:50.123]                 for (kk in seq_along(NAMES)) {
[10:22:50.123]                   name <- changed[[kk]]
[10:22:50.123]                   NAME <- NAMES[[kk]]
[10:22:50.123]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.123]                     next
[10:22:50.123]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:50.123]                 }
[10:22:50.123]                 NAMES <- toupper(added)
[10:22:50.123]                 for (kk in seq_along(NAMES)) {
[10:22:50.123]                   name <- added[[kk]]
[10:22:50.123]                   NAME <- NAMES[[kk]]
[10:22:50.123]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.123]                     next
[10:22:50.123]                   args[[name]] <- ""
[10:22:50.123]                 }
[10:22:50.123]                 NAMES <- toupper(removed)
[10:22:50.123]                 for (kk in seq_along(NAMES)) {
[10:22:50.123]                   name <- removed[[kk]]
[10:22:50.123]                   NAME <- NAMES[[kk]]
[10:22:50.123]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.123]                     next
[10:22:50.123]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:50.123]                 }
[10:22:50.123]                 if (length(args) > 0) 
[10:22:50.123]                   base::do.call(base::Sys.setenv, args = args)
[10:22:50.123]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:50.123]             }
[10:22:50.123]             else {
[10:22:50.123]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:50.123]             }
[10:22:50.123]             {
[10:22:50.123]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:50.123]                   0L) {
[10:22:50.123]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:50.123]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:50.123]                   base::options(opts)
[10:22:50.123]                 }
[10:22:50.123]                 {
[10:22:50.123]                   {
[10:22:50.123]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:50.123]                     NULL
[10:22:50.123]                   }
[10:22:50.123]                   options(future.plan = NULL)
[10:22:50.123]                   if (is.na(NA_character_)) 
[10:22:50.123]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:50.123]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:50.123]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:50.123]                     .init = FALSE)
[10:22:50.123]                 }
[10:22:50.123]             }
[10:22:50.123]         }
[10:22:50.123]     })
[10:22:50.123]     if (TRUE) {
[10:22:50.123]         base::sink(type = "output", split = FALSE)
[10:22:50.123]         if (TRUE) {
[10:22:50.123]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:50.123]         }
[10:22:50.123]         else {
[10:22:50.123]             ...future.result["stdout"] <- base::list(NULL)
[10:22:50.123]         }
[10:22:50.123]         base::close(...future.stdout)
[10:22:50.123]         ...future.stdout <- NULL
[10:22:50.123]     }
[10:22:50.123]     ...future.result$conditions <- ...future.conditions
[10:22:50.123]     ...future.result$finished <- base::Sys.time()
[10:22:50.123]     ...future.result
[10:22:50.123] }
[10:22:50.126] MultisessionFuture started
[10:22:50.126] - Launch lazy future ... done
[10:22:50.126] run() for ‘MultisessionFuture’ ... done
[10:22:50.127] resolve() on list environment ...
[10:22:50.127]  recursive: 0
[10:22:50.127]  length: 3
[10:22:50.127]  elements: ‘a’, ‘b’, ‘c’
[10:22:50.148]  length: 2 (resolved future 3)
[10:22:50.159] receiveMessageFromWorker() for ClusterFuture ...
[10:22:50.159] - Validating connection of MultisessionFuture
[10:22:50.160] - received message: FutureResult
[10:22:50.160] - Received FutureResult
[10:22:50.160] - Erased future from FutureRegistry
[10:22:50.160] result() for ClusterFuture ...
[10:22:50.160] - result already collected: FutureResult
[10:22:50.160] result() for ClusterFuture ... done
[10:22:50.160] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:50.160] Future #1
[10:22:50.160]  length: 1 (resolved future 1)
[10:22:50.168] receiveMessageFromWorker() for ClusterFuture ...
[10:22:50.168] - Validating connection of MultisessionFuture
[10:22:50.168] - received message: FutureResult
[10:22:50.168] - Received FutureResult
[10:22:50.168] - Erased future from FutureRegistry
[10:22:50.169] result() for ClusterFuture ...
[10:22:50.169] - result already collected: FutureResult
[10:22:50.169] result() for ClusterFuture ... done
[10:22:50.169] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:50.169] Future #2
[10:22:50.169]  length: 0 (resolved future 2)
[10:22:50.169] resolve() on list environment ... DONE
[10:22:50.170] getGlobalsAndPackages() ...
[10:22:50.170] Searching for globals...
[10:22:50.170] - globals found: [1] ‘{’
[10:22:50.170] Searching for globals ... DONE
[10:22:50.170] Resolving globals: FALSE
[10:22:50.171] 
[10:22:50.171] 
[10:22:50.171] getGlobalsAndPackages() ... DONE
[10:22:50.171] run() for ‘Future’ ...
[10:22:50.171] - state: ‘created’
[10:22:50.171] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:50.185] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:50.185] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:50.185]   - Field: ‘node’
[10:22:50.185]   - Field: ‘label’
[10:22:50.186]   - Field: ‘local’
[10:22:50.186]   - Field: ‘owner’
[10:22:50.186]   - Field: ‘envir’
[10:22:50.186]   - Field: ‘workers’
[10:22:50.186]   - Field: ‘packages’
[10:22:50.186]   - Field: ‘gc’
[10:22:50.186]   - Field: ‘conditions’
[10:22:50.186]   - Field: ‘persistent’
[10:22:50.186]   - Field: ‘expr’
[10:22:50.186]   - Field: ‘uuid’
[10:22:50.186]   - Field: ‘seed’
[10:22:50.187]   - Field: ‘version’
[10:22:50.187]   - Field: ‘result’
[10:22:50.187]   - Field: ‘asynchronous’
[10:22:50.187]   - Field: ‘calls’
[10:22:50.187]   - Field: ‘globals’
[10:22:50.187]   - Field: ‘stdout’
[10:22:50.187]   - Field: ‘earlySignal’
[10:22:50.187]   - Field: ‘lazy’
[10:22:50.187]   - Field: ‘state’
[10:22:50.187] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:50.187] - Launch lazy future ...
[10:22:50.188] Packages needed by the future expression (n = 0): <none>
[10:22:50.188] Packages needed by future strategies (n = 0): <none>
[10:22:50.188] {
[10:22:50.188]     {
[10:22:50.188]         {
[10:22:50.188]             ...future.startTime <- base::Sys.time()
[10:22:50.188]             {
[10:22:50.188]                 {
[10:22:50.188]                   {
[10:22:50.188]                     {
[10:22:50.188]                       base::local({
[10:22:50.188]                         has_future <- base::requireNamespace("future", 
[10:22:50.188]                           quietly = TRUE)
[10:22:50.188]                         if (has_future) {
[10:22:50.188]                           ns <- base::getNamespace("future")
[10:22:50.188]                           version <- ns[[".package"]][["version"]]
[10:22:50.188]                           if (is.null(version)) 
[10:22:50.188]                             version <- utils::packageVersion("future")
[10:22:50.188]                         }
[10:22:50.188]                         else {
[10:22:50.188]                           version <- NULL
[10:22:50.188]                         }
[10:22:50.188]                         if (!has_future || version < "1.8.0") {
[10:22:50.188]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:50.188]                             "", base::R.version$version.string), 
[10:22:50.188]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:50.188]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:50.188]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:50.188]                               "release", "version")], collapse = " "), 
[10:22:50.188]                             hostname = base::Sys.info()[["nodename"]])
[10:22:50.188]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:50.188]                             info)
[10:22:50.188]                           info <- base::paste(info, collapse = "; ")
[10:22:50.188]                           if (!has_future) {
[10:22:50.188]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:50.188]                               info)
[10:22:50.188]                           }
[10:22:50.188]                           else {
[10:22:50.188]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:50.188]                               info, version)
[10:22:50.188]                           }
[10:22:50.188]                           base::stop(msg)
[10:22:50.188]                         }
[10:22:50.188]                       })
[10:22:50.188]                     }
[10:22:50.188]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:50.188]                     base::options(mc.cores = 1L)
[10:22:50.188]                   }
[10:22:50.188]                   ...future.strategy.old <- future::plan("list")
[10:22:50.188]                   options(future.plan = NULL)
[10:22:50.188]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:50.188]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:50.188]                 }
[10:22:50.188]                 ...future.workdir <- getwd()
[10:22:50.188]             }
[10:22:50.188]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:50.188]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:50.188]         }
[10:22:50.188]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:50.188]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:50.188]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:50.188]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:50.188]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:50.188]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:50.188]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:50.188]             base::names(...future.oldOptions))
[10:22:50.188]     }
[10:22:50.188]     if (FALSE) {
[10:22:50.188]     }
[10:22:50.188]     else {
[10:22:50.188]         if (TRUE) {
[10:22:50.188]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:50.188]                 open = "w")
[10:22:50.188]         }
[10:22:50.188]         else {
[10:22:50.188]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:50.188]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:50.188]         }
[10:22:50.188]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:50.188]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:50.188]             base::sink(type = "output", split = FALSE)
[10:22:50.188]             base::close(...future.stdout)
[10:22:50.188]         }, add = TRUE)
[10:22:50.188]     }
[10:22:50.188]     ...future.frame <- base::sys.nframe()
[10:22:50.188]     ...future.conditions <- base::list()
[10:22:50.188]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:50.188]     if (FALSE) {
[10:22:50.188]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:50.188]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:50.188]     }
[10:22:50.188]     ...future.result <- base::tryCatch({
[10:22:50.188]         base::withCallingHandlers({
[10:22:50.188]             ...future.value <- base::withVisible(base::local({
[10:22:50.188]                 ...future.makeSendCondition <- base::local({
[10:22:50.188]                   sendCondition <- NULL
[10:22:50.188]                   function(frame = 1L) {
[10:22:50.188]                     if (is.function(sendCondition)) 
[10:22:50.188]                       return(sendCondition)
[10:22:50.188]                     ns <- getNamespace("parallel")
[10:22:50.188]                     if (exists("sendData", mode = "function", 
[10:22:50.188]                       envir = ns)) {
[10:22:50.188]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:50.188]                         envir = ns)
[10:22:50.188]                       envir <- sys.frame(frame)
[10:22:50.188]                       master <- NULL
[10:22:50.188]                       while (!identical(envir, .GlobalEnv) && 
[10:22:50.188]                         !identical(envir, emptyenv())) {
[10:22:50.188]                         if (exists("master", mode = "list", envir = envir, 
[10:22:50.188]                           inherits = FALSE)) {
[10:22:50.188]                           master <- get("master", mode = "list", 
[10:22:50.188]                             envir = envir, inherits = FALSE)
[10:22:50.188]                           if (inherits(master, c("SOCKnode", 
[10:22:50.188]                             "SOCK0node"))) {
[10:22:50.188]                             sendCondition <<- function(cond) {
[10:22:50.188]                               data <- list(type = "VALUE", value = cond, 
[10:22:50.188]                                 success = TRUE)
[10:22:50.188]                               parallel_sendData(master, data)
[10:22:50.188]                             }
[10:22:50.188]                             return(sendCondition)
[10:22:50.188]                           }
[10:22:50.188]                         }
[10:22:50.188]                         frame <- frame + 1L
[10:22:50.188]                         envir <- sys.frame(frame)
[10:22:50.188]                       }
[10:22:50.188]                     }
[10:22:50.188]                     sendCondition <<- function(cond) NULL
[10:22:50.188]                   }
[10:22:50.188]                 })
[10:22:50.188]                 withCallingHandlers({
[10:22:50.188]                   {
[10:22:50.188]                     1
[10:22:50.188]                   }
[10:22:50.188]                 }, immediateCondition = function(cond) {
[10:22:50.188]                   sendCondition <- ...future.makeSendCondition()
[10:22:50.188]                   sendCondition(cond)
[10:22:50.188]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.188]                   {
[10:22:50.188]                     inherits <- base::inherits
[10:22:50.188]                     invokeRestart <- base::invokeRestart
[10:22:50.188]                     is.null <- base::is.null
[10:22:50.188]                     muffled <- FALSE
[10:22:50.188]                     if (inherits(cond, "message")) {
[10:22:50.188]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:50.188]                       if (muffled) 
[10:22:50.188]                         invokeRestart("muffleMessage")
[10:22:50.188]                     }
[10:22:50.188]                     else if (inherits(cond, "warning")) {
[10:22:50.188]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:50.188]                       if (muffled) 
[10:22:50.188]                         invokeRestart("muffleWarning")
[10:22:50.188]                     }
[10:22:50.188]                     else if (inherits(cond, "condition")) {
[10:22:50.188]                       if (!is.null(pattern)) {
[10:22:50.188]                         computeRestarts <- base::computeRestarts
[10:22:50.188]                         grepl <- base::grepl
[10:22:50.188]                         restarts <- computeRestarts(cond)
[10:22:50.188]                         for (restart in restarts) {
[10:22:50.188]                           name <- restart$name
[10:22:50.188]                           if (is.null(name)) 
[10:22:50.188]                             next
[10:22:50.188]                           if (!grepl(pattern, name)) 
[10:22:50.188]                             next
[10:22:50.188]                           invokeRestart(restart)
[10:22:50.188]                           muffled <- TRUE
[10:22:50.188]                           break
[10:22:50.188]                         }
[10:22:50.188]                       }
[10:22:50.188]                     }
[10:22:50.188]                     invisible(muffled)
[10:22:50.188]                   }
[10:22:50.188]                   muffleCondition(cond)
[10:22:50.188]                 })
[10:22:50.188]             }))
[10:22:50.188]             future::FutureResult(value = ...future.value$value, 
[10:22:50.188]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:50.188]                   ...future.rng), globalenv = if (FALSE) 
[10:22:50.188]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:50.188]                     ...future.globalenv.names))
[10:22:50.188]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:50.188]         }, condition = base::local({
[10:22:50.188]             c <- base::c
[10:22:50.188]             inherits <- base::inherits
[10:22:50.188]             invokeRestart <- base::invokeRestart
[10:22:50.188]             length <- base::length
[10:22:50.188]             list <- base::list
[10:22:50.188]             seq.int <- base::seq.int
[10:22:50.188]             signalCondition <- base::signalCondition
[10:22:50.188]             sys.calls <- base::sys.calls
[10:22:50.188]             `[[` <- base::`[[`
[10:22:50.188]             `+` <- base::`+`
[10:22:50.188]             `<<-` <- base::`<<-`
[10:22:50.188]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:50.188]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:50.188]                   3L)]
[10:22:50.188]             }
[10:22:50.188]             function(cond) {
[10:22:50.188]                 is_error <- inherits(cond, "error")
[10:22:50.188]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:50.188]                   NULL)
[10:22:50.188]                 if (is_error) {
[10:22:50.188]                   sessionInformation <- function() {
[10:22:50.188]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:50.188]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:50.188]                       search = base::search(), system = base::Sys.info())
[10:22:50.188]                   }
[10:22:50.188]                   ...future.conditions[[length(...future.conditions) + 
[10:22:50.188]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:50.188]                     cond$call), session = sessionInformation(), 
[10:22:50.188]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:50.188]                   signalCondition(cond)
[10:22:50.188]                 }
[10:22:50.188]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:50.188]                 "immediateCondition"))) {
[10:22:50.188]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:50.188]                   ...future.conditions[[length(...future.conditions) + 
[10:22:50.188]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:50.188]                   if (TRUE && !signal) {
[10:22:50.188]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.188]                     {
[10:22:50.188]                       inherits <- base::inherits
[10:22:50.188]                       invokeRestart <- base::invokeRestart
[10:22:50.188]                       is.null <- base::is.null
[10:22:50.188]                       muffled <- FALSE
[10:22:50.188]                       if (inherits(cond, "message")) {
[10:22:50.188]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:50.188]                         if (muffled) 
[10:22:50.188]                           invokeRestart("muffleMessage")
[10:22:50.188]                       }
[10:22:50.188]                       else if (inherits(cond, "warning")) {
[10:22:50.188]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:50.188]                         if (muffled) 
[10:22:50.188]                           invokeRestart("muffleWarning")
[10:22:50.188]                       }
[10:22:50.188]                       else if (inherits(cond, "condition")) {
[10:22:50.188]                         if (!is.null(pattern)) {
[10:22:50.188]                           computeRestarts <- base::computeRestarts
[10:22:50.188]                           grepl <- base::grepl
[10:22:50.188]                           restarts <- computeRestarts(cond)
[10:22:50.188]                           for (restart in restarts) {
[10:22:50.188]                             name <- restart$name
[10:22:50.188]                             if (is.null(name)) 
[10:22:50.188]                               next
[10:22:50.188]                             if (!grepl(pattern, name)) 
[10:22:50.188]                               next
[10:22:50.188]                             invokeRestart(restart)
[10:22:50.188]                             muffled <- TRUE
[10:22:50.188]                             break
[10:22:50.188]                           }
[10:22:50.188]                         }
[10:22:50.188]                       }
[10:22:50.188]                       invisible(muffled)
[10:22:50.188]                     }
[10:22:50.188]                     muffleCondition(cond, pattern = "^muffle")
[10:22:50.188]                   }
[10:22:50.188]                 }
[10:22:50.188]                 else {
[10:22:50.188]                   if (TRUE) {
[10:22:50.188]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.188]                     {
[10:22:50.188]                       inherits <- base::inherits
[10:22:50.188]                       invokeRestart <- base::invokeRestart
[10:22:50.188]                       is.null <- base::is.null
[10:22:50.188]                       muffled <- FALSE
[10:22:50.188]                       if (inherits(cond, "message")) {
[10:22:50.188]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:50.188]                         if (muffled) 
[10:22:50.188]                           invokeRestart("muffleMessage")
[10:22:50.188]                       }
[10:22:50.188]                       else if (inherits(cond, "warning")) {
[10:22:50.188]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:50.188]                         if (muffled) 
[10:22:50.188]                           invokeRestart("muffleWarning")
[10:22:50.188]                       }
[10:22:50.188]                       else if (inherits(cond, "condition")) {
[10:22:50.188]                         if (!is.null(pattern)) {
[10:22:50.188]                           computeRestarts <- base::computeRestarts
[10:22:50.188]                           grepl <- base::grepl
[10:22:50.188]                           restarts <- computeRestarts(cond)
[10:22:50.188]                           for (restart in restarts) {
[10:22:50.188]                             name <- restart$name
[10:22:50.188]                             if (is.null(name)) 
[10:22:50.188]                               next
[10:22:50.188]                             if (!grepl(pattern, name)) 
[10:22:50.188]                               next
[10:22:50.188]                             invokeRestart(restart)
[10:22:50.188]                             muffled <- TRUE
[10:22:50.188]                             break
[10:22:50.188]                           }
[10:22:50.188]                         }
[10:22:50.188]                       }
[10:22:50.188]                       invisible(muffled)
[10:22:50.188]                     }
[10:22:50.188]                     muffleCondition(cond, pattern = "^muffle")
[10:22:50.188]                   }
[10:22:50.188]                 }
[10:22:50.188]             }
[10:22:50.188]         }))
[10:22:50.188]     }, error = function(ex) {
[10:22:50.188]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:50.188]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:50.188]                 ...future.rng), started = ...future.startTime, 
[10:22:50.188]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:50.188]             version = "1.8"), class = "FutureResult")
[10:22:50.188]     }, finally = {
[10:22:50.188]         if (!identical(...future.workdir, getwd())) 
[10:22:50.188]             setwd(...future.workdir)
[10:22:50.188]         {
[10:22:50.188]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:50.188]                 ...future.oldOptions$nwarnings <- NULL
[10:22:50.188]             }
[10:22:50.188]             base::options(...future.oldOptions)
[10:22:50.188]             if (.Platform$OS.type == "windows") {
[10:22:50.188]                 old_names <- names(...future.oldEnvVars)
[10:22:50.188]                 envs <- base::Sys.getenv()
[10:22:50.188]                 names <- names(envs)
[10:22:50.188]                 common <- intersect(names, old_names)
[10:22:50.188]                 added <- setdiff(names, old_names)
[10:22:50.188]                 removed <- setdiff(old_names, names)
[10:22:50.188]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:50.188]                   envs[common]]
[10:22:50.188]                 NAMES <- toupper(changed)
[10:22:50.188]                 args <- list()
[10:22:50.188]                 for (kk in seq_along(NAMES)) {
[10:22:50.188]                   name <- changed[[kk]]
[10:22:50.188]                   NAME <- NAMES[[kk]]
[10:22:50.188]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.188]                     next
[10:22:50.188]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:50.188]                 }
[10:22:50.188]                 NAMES <- toupper(added)
[10:22:50.188]                 for (kk in seq_along(NAMES)) {
[10:22:50.188]                   name <- added[[kk]]
[10:22:50.188]                   NAME <- NAMES[[kk]]
[10:22:50.188]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.188]                     next
[10:22:50.188]                   args[[name]] <- ""
[10:22:50.188]                 }
[10:22:50.188]                 NAMES <- toupper(removed)
[10:22:50.188]                 for (kk in seq_along(NAMES)) {
[10:22:50.188]                   name <- removed[[kk]]
[10:22:50.188]                   NAME <- NAMES[[kk]]
[10:22:50.188]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.188]                     next
[10:22:50.188]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:50.188]                 }
[10:22:50.188]                 if (length(args) > 0) 
[10:22:50.188]                   base::do.call(base::Sys.setenv, args = args)
[10:22:50.188]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:50.188]             }
[10:22:50.188]             else {
[10:22:50.188]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:50.188]             }
[10:22:50.188]             {
[10:22:50.188]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:50.188]                   0L) {
[10:22:50.188]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:50.188]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:50.188]                   base::options(opts)
[10:22:50.188]                 }
[10:22:50.188]                 {
[10:22:50.188]                   {
[10:22:50.188]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:50.188]                     NULL
[10:22:50.188]                   }
[10:22:50.188]                   options(future.plan = NULL)
[10:22:50.188]                   if (is.na(NA_character_)) 
[10:22:50.188]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:50.188]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:50.188]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:50.188]                     .init = FALSE)
[10:22:50.188]                 }
[10:22:50.188]             }
[10:22:50.188]         }
[10:22:50.188]     })
[10:22:50.188]     if (TRUE) {
[10:22:50.188]         base::sink(type = "output", split = FALSE)
[10:22:50.188]         if (TRUE) {
[10:22:50.188]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:50.188]         }
[10:22:50.188]         else {
[10:22:50.188]             ...future.result["stdout"] <- base::list(NULL)
[10:22:50.188]         }
[10:22:50.188]         base::close(...future.stdout)
[10:22:50.188]         ...future.stdout <- NULL
[10:22:50.188]     }
[10:22:50.188]     ...future.result$conditions <- ...future.conditions
[10:22:50.188]     ...future.result$finished <- base::Sys.time()
[10:22:50.188]     ...future.result
[10:22:50.188] }
[10:22:50.191] MultisessionFuture started
[10:22:50.191] - Launch lazy future ... done
[10:22:50.191] run() for ‘MultisessionFuture’ ... done
[10:22:50.192] getGlobalsAndPackages() ...
[10:22:50.192] Searching for globals...
[10:22:50.193] - globals found: [2] ‘{’, ‘Sys.sleep’
[10:22:50.193] Searching for globals ... DONE
[10:22:50.193] Resolving globals: FALSE
[10:22:50.193] 
[10:22:50.193] 
[10:22:50.193] getGlobalsAndPackages() ... DONE
[10:22:50.194] run() for ‘Future’ ...
[10:22:50.194] - state: ‘created’
[10:22:50.194] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:50.218] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:50.218] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:50.218]   - Field: ‘node’
[10:22:50.218]   - Field: ‘label’
[10:22:50.218]   - Field: ‘local’
[10:22:50.218]   - Field: ‘owner’
[10:22:50.218]   - Field: ‘envir’
[10:22:50.218]   - Field: ‘workers’
[10:22:50.219]   - Field: ‘packages’
[10:22:50.219]   - Field: ‘gc’
[10:22:50.219]   - Field: ‘conditions’
[10:22:50.219]   - Field: ‘persistent’
[10:22:50.219]   - Field: ‘expr’
[10:22:50.219]   - Field: ‘uuid’
[10:22:50.219]   - Field: ‘seed’
[10:22:50.219]   - Field: ‘version’
[10:22:50.219]   - Field: ‘result’
[10:22:50.219]   - Field: ‘asynchronous’
[10:22:50.219]   - Field: ‘calls’
[10:22:50.219]   - Field: ‘globals’
[10:22:50.220]   - Field: ‘stdout’
[10:22:50.220]   - Field: ‘earlySignal’
[10:22:50.220]   - Field: ‘lazy’
[10:22:50.220]   - Field: ‘state’
[10:22:50.220] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:50.220] - Launch lazy future ...
[10:22:50.220] Packages needed by the future expression (n = 0): <none>
[10:22:50.220] Packages needed by future strategies (n = 0): <none>
[10:22:50.221] {
[10:22:50.221]     {
[10:22:50.221]         {
[10:22:50.221]             ...future.startTime <- base::Sys.time()
[10:22:50.221]             {
[10:22:50.221]                 {
[10:22:50.221]                   {
[10:22:50.221]                     {
[10:22:50.221]                       base::local({
[10:22:50.221]                         has_future <- base::requireNamespace("future", 
[10:22:50.221]                           quietly = TRUE)
[10:22:50.221]                         if (has_future) {
[10:22:50.221]                           ns <- base::getNamespace("future")
[10:22:50.221]                           version <- ns[[".package"]][["version"]]
[10:22:50.221]                           if (is.null(version)) 
[10:22:50.221]                             version <- utils::packageVersion("future")
[10:22:50.221]                         }
[10:22:50.221]                         else {
[10:22:50.221]                           version <- NULL
[10:22:50.221]                         }
[10:22:50.221]                         if (!has_future || version < "1.8.0") {
[10:22:50.221]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:50.221]                             "", base::R.version$version.string), 
[10:22:50.221]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:50.221]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:50.221]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:50.221]                               "release", "version")], collapse = " "), 
[10:22:50.221]                             hostname = base::Sys.info()[["nodename"]])
[10:22:50.221]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:50.221]                             info)
[10:22:50.221]                           info <- base::paste(info, collapse = "; ")
[10:22:50.221]                           if (!has_future) {
[10:22:50.221]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:50.221]                               info)
[10:22:50.221]                           }
[10:22:50.221]                           else {
[10:22:50.221]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:50.221]                               info, version)
[10:22:50.221]                           }
[10:22:50.221]                           base::stop(msg)
[10:22:50.221]                         }
[10:22:50.221]                       })
[10:22:50.221]                     }
[10:22:50.221]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:50.221]                     base::options(mc.cores = 1L)
[10:22:50.221]                   }
[10:22:50.221]                   ...future.strategy.old <- future::plan("list")
[10:22:50.221]                   options(future.plan = NULL)
[10:22:50.221]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:50.221]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:50.221]                 }
[10:22:50.221]                 ...future.workdir <- getwd()
[10:22:50.221]             }
[10:22:50.221]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:50.221]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:50.221]         }
[10:22:50.221]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:50.221]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:50.221]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:50.221]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:50.221]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:50.221]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:50.221]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:50.221]             base::names(...future.oldOptions))
[10:22:50.221]     }
[10:22:50.221]     if (FALSE) {
[10:22:50.221]     }
[10:22:50.221]     else {
[10:22:50.221]         if (TRUE) {
[10:22:50.221]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:50.221]                 open = "w")
[10:22:50.221]         }
[10:22:50.221]         else {
[10:22:50.221]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:50.221]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:50.221]         }
[10:22:50.221]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:50.221]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:50.221]             base::sink(type = "output", split = FALSE)
[10:22:50.221]             base::close(...future.stdout)
[10:22:50.221]         }, add = TRUE)
[10:22:50.221]     }
[10:22:50.221]     ...future.frame <- base::sys.nframe()
[10:22:50.221]     ...future.conditions <- base::list()
[10:22:50.221]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:50.221]     if (FALSE) {
[10:22:50.221]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:50.221]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:50.221]     }
[10:22:50.221]     ...future.result <- base::tryCatch({
[10:22:50.221]         base::withCallingHandlers({
[10:22:50.221]             ...future.value <- base::withVisible(base::local({
[10:22:50.221]                 ...future.makeSendCondition <- base::local({
[10:22:50.221]                   sendCondition <- NULL
[10:22:50.221]                   function(frame = 1L) {
[10:22:50.221]                     if (is.function(sendCondition)) 
[10:22:50.221]                       return(sendCondition)
[10:22:50.221]                     ns <- getNamespace("parallel")
[10:22:50.221]                     if (exists("sendData", mode = "function", 
[10:22:50.221]                       envir = ns)) {
[10:22:50.221]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:50.221]                         envir = ns)
[10:22:50.221]                       envir <- sys.frame(frame)
[10:22:50.221]                       master <- NULL
[10:22:50.221]                       while (!identical(envir, .GlobalEnv) && 
[10:22:50.221]                         !identical(envir, emptyenv())) {
[10:22:50.221]                         if (exists("master", mode = "list", envir = envir, 
[10:22:50.221]                           inherits = FALSE)) {
[10:22:50.221]                           master <- get("master", mode = "list", 
[10:22:50.221]                             envir = envir, inherits = FALSE)
[10:22:50.221]                           if (inherits(master, c("SOCKnode", 
[10:22:50.221]                             "SOCK0node"))) {
[10:22:50.221]                             sendCondition <<- function(cond) {
[10:22:50.221]                               data <- list(type = "VALUE", value = cond, 
[10:22:50.221]                                 success = TRUE)
[10:22:50.221]                               parallel_sendData(master, data)
[10:22:50.221]                             }
[10:22:50.221]                             return(sendCondition)
[10:22:50.221]                           }
[10:22:50.221]                         }
[10:22:50.221]                         frame <- frame + 1L
[10:22:50.221]                         envir <- sys.frame(frame)
[10:22:50.221]                       }
[10:22:50.221]                     }
[10:22:50.221]                     sendCondition <<- function(cond) NULL
[10:22:50.221]                   }
[10:22:50.221]                 })
[10:22:50.221]                 withCallingHandlers({
[10:22:50.221]                   {
[10:22:50.221]                     Sys.sleep(0.5)
[10:22:50.221]                     2
[10:22:50.221]                   }
[10:22:50.221]                 }, immediateCondition = function(cond) {
[10:22:50.221]                   sendCondition <- ...future.makeSendCondition()
[10:22:50.221]                   sendCondition(cond)
[10:22:50.221]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.221]                   {
[10:22:50.221]                     inherits <- base::inherits
[10:22:50.221]                     invokeRestart <- base::invokeRestart
[10:22:50.221]                     is.null <- base::is.null
[10:22:50.221]                     muffled <- FALSE
[10:22:50.221]                     if (inherits(cond, "message")) {
[10:22:50.221]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:50.221]                       if (muffled) 
[10:22:50.221]                         invokeRestart("muffleMessage")
[10:22:50.221]                     }
[10:22:50.221]                     else if (inherits(cond, "warning")) {
[10:22:50.221]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:50.221]                       if (muffled) 
[10:22:50.221]                         invokeRestart("muffleWarning")
[10:22:50.221]                     }
[10:22:50.221]                     else if (inherits(cond, "condition")) {
[10:22:50.221]                       if (!is.null(pattern)) {
[10:22:50.221]                         computeRestarts <- base::computeRestarts
[10:22:50.221]                         grepl <- base::grepl
[10:22:50.221]                         restarts <- computeRestarts(cond)
[10:22:50.221]                         for (restart in restarts) {
[10:22:50.221]                           name <- restart$name
[10:22:50.221]                           if (is.null(name)) 
[10:22:50.221]                             next
[10:22:50.221]                           if (!grepl(pattern, name)) 
[10:22:50.221]                             next
[10:22:50.221]                           invokeRestart(restart)
[10:22:50.221]                           muffled <- TRUE
[10:22:50.221]                           break
[10:22:50.221]                         }
[10:22:50.221]                       }
[10:22:50.221]                     }
[10:22:50.221]                     invisible(muffled)
[10:22:50.221]                   }
[10:22:50.221]                   muffleCondition(cond)
[10:22:50.221]                 })
[10:22:50.221]             }))
[10:22:50.221]             future::FutureResult(value = ...future.value$value, 
[10:22:50.221]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:50.221]                   ...future.rng), globalenv = if (FALSE) 
[10:22:50.221]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:50.221]                     ...future.globalenv.names))
[10:22:50.221]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:50.221]         }, condition = base::local({
[10:22:50.221]             c <- base::c
[10:22:50.221]             inherits <- base::inherits
[10:22:50.221]             invokeRestart <- base::invokeRestart
[10:22:50.221]             length <- base::length
[10:22:50.221]             list <- base::list
[10:22:50.221]             seq.int <- base::seq.int
[10:22:50.221]             signalCondition <- base::signalCondition
[10:22:50.221]             sys.calls <- base::sys.calls
[10:22:50.221]             `[[` <- base::`[[`
[10:22:50.221]             `+` <- base::`+`
[10:22:50.221]             `<<-` <- base::`<<-`
[10:22:50.221]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:50.221]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:50.221]                   3L)]
[10:22:50.221]             }
[10:22:50.221]             function(cond) {
[10:22:50.221]                 is_error <- inherits(cond, "error")
[10:22:50.221]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:50.221]                   NULL)
[10:22:50.221]                 if (is_error) {
[10:22:50.221]                   sessionInformation <- function() {
[10:22:50.221]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:50.221]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:50.221]                       search = base::search(), system = base::Sys.info())
[10:22:50.221]                   }
[10:22:50.221]                   ...future.conditions[[length(...future.conditions) + 
[10:22:50.221]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:50.221]                     cond$call), session = sessionInformation(), 
[10:22:50.221]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:50.221]                   signalCondition(cond)
[10:22:50.221]                 }
[10:22:50.221]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:50.221]                 "immediateCondition"))) {
[10:22:50.221]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:50.221]                   ...future.conditions[[length(...future.conditions) + 
[10:22:50.221]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:50.221]                   if (TRUE && !signal) {
[10:22:50.221]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.221]                     {
[10:22:50.221]                       inherits <- base::inherits
[10:22:50.221]                       invokeRestart <- base::invokeRestart
[10:22:50.221]                       is.null <- base::is.null
[10:22:50.221]                       muffled <- FALSE
[10:22:50.221]                       if (inherits(cond, "message")) {
[10:22:50.221]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:50.221]                         if (muffled) 
[10:22:50.221]                           invokeRestart("muffleMessage")
[10:22:50.221]                       }
[10:22:50.221]                       else if (inherits(cond, "warning")) {
[10:22:50.221]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:50.221]                         if (muffled) 
[10:22:50.221]                           invokeRestart("muffleWarning")
[10:22:50.221]                       }
[10:22:50.221]                       else if (inherits(cond, "condition")) {
[10:22:50.221]                         if (!is.null(pattern)) {
[10:22:50.221]                           computeRestarts <- base::computeRestarts
[10:22:50.221]                           grepl <- base::grepl
[10:22:50.221]                           restarts <- computeRestarts(cond)
[10:22:50.221]                           for (restart in restarts) {
[10:22:50.221]                             name <- restart$name
[10:22:50.221]                             if (is.null(name)) 
[10:22:50.221]                               next
[10:22:50.221]                             if (!grepl(pattern, name)) 
[10:22:50.221]                               next
[10:22:50.221]                             invokeRestart(restart)
[10:22:50.221]                             muffled <- TRUE
[10:22:50.221]                             break
[10:22:50.221]                           }
[10:22:50.221]                         }
[10:22:50.221]                       }
[10:22:50.221]                       invisible(muffled)
[10:22:50.221]                     }
[10:22:50.221]                     muffleCondition(cond, pattern = "^muffle")
[10:22:50.221]                   }
[10:22:50.221]                 }
[10:22:50.221]                 else {
[10:22:50.221]                   if (TRUE) {
[10:22:50.221]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.221]                     {
[10:22:50.221]                       inherits <- base::inherits
[10:22:50.221]                       invokeRestart <- base::invokeRestart
[10:22:50.221]                       is.null <- base::is.null
[10:22:50.221]                       muffled <- FALSE
[10:22:50.221]                       if (inherits(cond, "message")) {
[10:22:50.221]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:50.221]                         if (muffled) 
[10:22:50.221]                           invokeRestart("muffleMessage")
[10:22:50.221]                       }
[10:22:50.221]                       else if (inherits(cond, "warning")) {
[10:22:50.221]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:50.221]                         if (muffled) 
[10:22:50.221]                           invokeRestart("muffleWarning")
[10:22:50.221]                       }
[10:22:50.221]                       else if (inherits(cond, "condition")) {
[10:22:50.221]                         if (!is.null(pattern)) {
[10:22:50.221]                           computeRestarts <- base::computeRestarts
[10:22:50.221]                           grepl <- base::grepl
[10:22:50.221]                           restarts <- computeRestarts(cond)
[10:22:50.221]                           for (restart in restarts) {
[10:22:50.221]                             name <- restart$name
[10:22:50.221]                             if (is.null(name)) 
[10:22:50.221]                               next
[10:22:50.221]                             if (!grepl(pattern, name)) 
[10:22:50.221]                               next
[10:22:50.221]                             invokeRestart(restart)
[10:22:50.221]                             muffled <- TRUE
[10:22:50.221]                             break
[10:22:50.221]                           }
[10:22:50.221]                         }
[10:22:50.221]                       }
[10:22:50.221]                       invisible(muffled)
[10:22:50.221]                     }
[10:22:50.221]                     muffleCondition(cond, pattern = "^muffle")
[10:22:50.221]                   }
[10:22:50.221]                 }
[10:22:50.221]             }
[10:22:50.221]         }))
[10:22:50.221]     }, error = function(ex) {
[10:22:50.221]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:50.221]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:50.221]                 ...future.rng), started = ...future.startTime, 
[10:22:50.221]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:50.221]             version = "1.8"), class = "FutureResult")
[10:22:50.221]     }, finally = {
[10:22:50.221]         if (!identical(...future.workdir, getwd())) 
[10:22:50.221]             setwd(...future.workdir)
[10:22:50.221]         {
[10:22:50.221]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:50.221]                 ...future.oldOptions$nwarnings <- NULL
[10:22:50.221]             }
[10:22:50.221]             base::options(...future.oldOptions)
[10:22:50.221]             if (.Platform$OS.type == "windows") {
[10:22:50.221]                 old_names <- names(...future.oldEnvVars)
[10:22:50.221]                 envs <- base::Sys.getenv()
[10:22:50.221]                 names <- names(envs)
[10:22:50.221]                 common <- intersect(names, old_names)
[10:22:50.221]                 added <- setdiff(names, old_names)
[10:22:50.221]                 removed <- setdiff(old_names, names)
[10:22:50.221]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:50.221]                   envs[common]]
[10:22:50.221]                 NAMES <- toupper(changed)
[10:22:50.221]                 args <- list()
[10:22:50.221]                 for (kk in seq_along(NAMES)) {
[10:22:50.221]                   name <- changed[[kk]]
[10:22:50.221]                   NAME <- NAMES[[kk]]
[10:22:50.221]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.221]                     next
[10:22:50.221]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:50.221]                 }
[10:22:50.221]                 NAMES <- toupper(added)
[10:22:50.221]                 for (kk in seq_along(NAMES)) {
[10:22:50.221]                   name <- added[[kk]]
[10:22:50.221]                   NAME <- NAMES[[kk]]
[10:22:50.221]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.221]                     next
[10:22:50.221]                   args[[name]] <- ""
[10:22:50.221]                 }
[10:22:50.221]                 NAMES <- toupper(removed)
[10:22:50.221]                 for (kk in seq_along(NAMES)) {
[10:22:50.221]                   name <- removed[[kk]]
[10:22:50.221]                   NAME <- NAMES[[kk]]
[10:22:50.221]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.221]                     next
[10:22:50.221]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:50.221]                 }
[10:22:50.221]                 if (length(args) > 0) 
[10:22:50.221]                   base::do.call(base::Sys.setenv, args = args)
[10:22:50.221]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:50.221]             }
[10:22:50.221]             else {
[10:22:50.221]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:50.221]             }
[10:22:50.221]             {
[10:22:50.221]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:50.221]                   0L) {
[10:22:50.221]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:50.221]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:50.221]                   base::options(opts)
[10:22:50.221]                 }
[10:22:50.221]                 {
[10:22:50.221]                   {
[10:22:50.221]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:50.221]                     NULL
[10:22:50.221]                   }
[10:22:50.221]                   options(future.plan = NULL)
[10:22:50.221]                   if (is.na(NA_character_)) 
[10:22:50.221]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:50.221]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:50.221]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:50.221]                     .init = FALSE)
[10:22:50.221]                 }
[10:22:50.221]             }
[10:22:50.221]         }
[10:22:50.221]     })
[10:22:50.221]     if (TRUE) {
[10:22:50.221]         base::sink(type = "output", split = FALSE)
[10:22:50.221]         if (TRUE) {
[10:22:50.221]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:50.221]         }
[10:22:50.221]         else {
[10:22:50.221]             ...future.result["stdout"] <- base::list(NULL)
[10:22:50.221]         }
[10:22:50.221]         base::close(...future.stdout)
[10:22:50.221]         ...future.stdout <- NULL
[10:22:50.221]     }
[10:22:50.221]     ...future.result$conditions <- ...future.conditions
[10:22:50.221]     ...future.result$finished <- base::Sys.time()
[10:22:50.221]     ...future.result
[10:22:50.221] }
[10:22:50.224] MultisessionFuture started
[10:22:50.224] - Launch lazy future ... done
[10:22:50.224] run() for ‘MultisessionFuture’ ... done
[10:22:50.224] getGlobalsAndPackages() ...
[10:22:50.224] Searching for globals...
[10:22:50.225] - globals found: [1] ‘{’
[10:22:50.225] Searching for globals ... DONE
[10:22:50.225] Resolving globals: FALSE
[10:22:50.225] 
[10:22:50.225] 
[10:22:50.226] getGlobalsAndPackages() ... DONE
[10:22:50.226] run() for ‘Future’ ...
[10:22:50.226] - state: ‘created’
[10:22:50.226] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:50.240] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:50.241] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:50.241]   - Field: ‘node’
[10:22:50.241]   - Field: ‘label’
[10:22:50.241]   - Field: ‘local’
[10:22:50.241]   - Field: ‘owner’
[10:22:50.241]   - Field: ‘envir’
[10:22:50.241]   - Field: ‘workers’
[10:22:50.241]   - Field: ‘packages’
[10:22:50.241]   - Field: ‘gc’
[10:22:50.241]   - Field: ‘conditions’
[10:22:50.241]   - Field: ‘persistent’
[10:22:50.242]   - Field: ‘expr’
[10:22:50.242]   - Field: ‘uuid’
[10:22:50.242]   - Field: ‘seed’
[10:22:50.242]   - Field: ‘version’
[10:22:50.242]   - Field: ‘result’
[10:22:50.242]   - Field: ‘asynchronous’
[10:22:50.242]   - Field: ‘calls’
[10:22:50.242]   - Field: ‘globals’
[10:22:50.242]   - Field: ‘stdout’
[10:22:50.242]   - Field: ‘earlySignal’
[10:22:50.242]   - Field: ‘lazy’
[10:22:50.242]   - Field: ‘state’
[10:22:50.243] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:50.243] - Launch lazy future ...
[10:22:50.243] Packages needed by the future expression (n = 0): <none>
[10:22:50.243] Packages needed by future strategies (n = 0): <none>
[10:22:50.243] {
[10:22:50.243]     {
[10:22:50.243]         {
[10:22:50.243]             ...future.startTime <- base::Sys.time()
[10:22:50.243]             {
[10:22:50.243]                 {
[10:22:50.243]                   {
[10:22:50.243]                     {
[10:22:50.243]                       base::local({
[10:22:50.243]                         has_future <- base::requireNamespace("future", 
[10:22:50.243]                           quietly = TRUE)
[10:22:50.243]                         if (has_future) {
[10:22:50.243]                           ns <- base::getNamespace("future")
[10:22:50.243]                           version <- ns[[".package"]][["version"]]
[10:22:50.243]                           if (is.null(version)) 
[10:22:50.243]                             version <- utils::packageVersion("future")
[10:22:50.243]                         }
[10:22:50.243]                         else {
[10:22:50.243]                           version <- NULL
[10:22:50.243]                         }
[10:22:50.243]                         if (!has_future || version < "1.8.0") {
[10:22:50.243]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:50.243]                             "", base::R.version$version.string), 
[10:22:50.243]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:50.243]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:50.243]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:50.243]                               "release", "version")], collapse = " "), 
[10:22:50.243]                             hostname = base::Sys.info()[["nodename"]])
[10:22:50.243]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:50.243]                             info)
[10:22:50.243]                           info <- base::paste(info, collapse = "; ")
[10:22:50.243]                           if (!has_future) {
[10:22:50.243]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:50.243]                               info)
[10:22:50.243]                           }
[10:22:50.243]                           else {
[10:22:50.243]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:50.243]                               info, version)
[10:22:50.243]                           }
[10:22:50.243]                           base::stop(msg)
[10:22:50.243]                         }
[10:22:50.243]                       })
[10:22:50.243]                     }
[10:22:50.243]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:50.243]                     base::options(mc.cores = 1L)
[10:22:50.243]                   }
[10:22:50.243]                   ...future.strategy.old <- future::plan("list")
[10:22:50.243]                   options(future.plan = NULL)
[10:22:50.243]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:50.243]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:50.243]                 }
[10:22:50.243]                 ...future.workdir <- getwd()
[10:22:50.243]             }
[10:22:50.243]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:50.243]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:50.243]         }
[10:22:50.243]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:50.243]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:50.243]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:50.243]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:50.243]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:50.243]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:50.243]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:50.243]             base::names(...future.oldOptions))
[10:22:50.243]     }
[10:22:50.243]     if (FALSE) {
[10:22:50.243]     }
[10:22:50.243]     else {
[10:22:50.243]         if (TRUE) {
[10:22:50.243]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:50.243]                 open = "w")
[10:22:50.243]         }
[10:22:50.243]         else {
[10:22:50.243]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:50.243]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:50.243]         }
[10:22:50.243]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:50.243]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:50.243]             base::sink(type = "output", split = FALSE)
[10:22:50.243]             base::close(...future.stdout)
[10:22:50.243]         }, add = TRUE)
[10:22:50.243]     }
[10:22:50.243]     ...future.frame <- base::sys.nframe()
[10:22:50.243]     ...future.conditions <- base::list()
[10:22:50.243]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:50.243]     if (FALSE) {
[10:22:50.243]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:50.243]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:50.243]     }
[10:22:50.243]     ...future.result <- base::tryCatch({
[10:22:50.243]         base::withCallingHandlers({
[10:22:50.243]             ...future.value <- base::withVisible(base::local({
[10:22:50.243]                 ...future.makeSendCondition <- base::local({
[10:22:50.243]                   sendCondition <- NULL
[10:22:50.243]                   function(frame = 1L) {
[10:22:50.243]                     if (is.function(sendCondition)) 
[10:22:50.243]                       return(sendCondition)
[10:22:50.243]                     ns <- getNamespace("parallel")
[10:22:50.243]                     if (exists("sendData", mode = "function", 
[10:22:50.243]                       envir = ns)) {
[10:22:50.243]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:50.243]                         envir = ns)
[10:22:50.243]                       envir <- sys.frame(frame)
[10:22:50.243]                       master <- NULL
[10:22:50.243]                       while (!identical(envir, .GlobalEnv) && 
[10:22:50.243]                         !identical(envir, emptyenv())) {
[10:22:50.243]                         if (exists("master", mode = "list", envir = envir, 
[10:22:50.243]                           inherits = FALSE)) {
[10:22:50.243]                           master <- get("master", mode = "list", 
[10:22:50.243]                             envir = envir, inherits = FALSE)
[10:22:50.243]                           if (inherits(master, c("SOCKnode", 
[10:22:50.243]                             "SOCK0node"))) {
[10:22:50.243]                             sendCondition <<- function(cond) {
[10:22:50.243]                               data <- list(type = "VALUE", value = cond, 
[10:22:50.243]                                 success = TRUE)
[10:22:50.243]                               parallel_sendData(master, data)
[10:22:50.243]                             }
[10:22:50.243]                             return(sendCondition)
[10:22:50.243]                           }
[10:22:50.243]                         }
[10:22:50.243]                         frame <- frame + 1L
[10:22:50.243]                         envir <- sys.frame(frame)
[10:22:50.243]                       }
[10:22:50.243]                     }
[10:22:50.243]                     sendCondition <<- function(cond) NULL
[10:22:50.243]                   }
[10:22:50.243]                 })
[10:22:50.243]                 withCallingHandlers({
[10:22:50.243]                   {
[10:22:50.243]                     3
[10:22:50.243]                   }
[10:22:50.243]                 }, immediateCondition = function(cond) {
[10:22:50.243]                   sendCondition <- ...future.makeSendCondition()
[10:22:50.243]                   sendCondition(cond)
[10:22:50.243]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.243]                   {
[10:22:50.243]                     inherits <- base::inherits
[10:22:50.243]                     invokeRestart <- base::invokeRestart
[10:22:50.243]                     is.null <- base::is.null
[10:22:50.243]                     muffled <- FALSE
[10:22:50.243]                     if (inherits(cond, "message")) {
[10:22:50.243]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:50.243]                       if (muffled) 
[10:22:50.243]                         invokeRestart("muffleMessage")
[10:22:50.243]                     }
[10:22:50.243]                     else if (inherits(cond, "warning")) {
[10:22:50.243]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:50.243]                       if (muffled) 
[10:22:50.243]                         invokeRestart("muffleWarning")
[10:22:50.243]                     }
[10:22:50.243]                     else if (inherits(cond, "condition")) {
[10:22:50.243]                       if (!is.null(pattern)) {
[10:22:50.243]                         computeRestarts <- base::computeRestarts
[10:22:50.243]                         grepl <- base::grepl
[10:22:50.243]                         restarts <- computeRestarts(cond)
[10:22:50.243]                         for (restart in restarts) {
[10:22:50.243]                           name <- restart$name
[10:22:50.243]                           if (is.null(name)) 
[10:22:50.243]                             next
[10:22:50.243]                           if (!grepl(pattern, name)) 
[10:22:50.243]                             next
[10:22:50.243]                           invokeRestart(restart)
[10:22:50.243]                           muffled <- TRUE
[10:22:50.243]                           break
[10:22:50.243]                         }
[10:22:50.243]                       }
[10:22:50.243]                     }
[10:22:50.243]                     invisible(muffled)
[10:22:50.243]                   }
[10:22:50.243]                   muffleCondition(cond)
[10:22:50.243]                 })
[10:22:50.243]             }))
[10:22:50.243]             future::FutureResult(value = ...future.value$value, 
[10:22:50.243]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:50.243]                   ...future.rng), globalenv = if (FALSE) 
[10:22:50.243]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:50.243]                     ...future.globalenv.names))
[10:22:50.243]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:50.243]         }, condition = base::local({
[10:22:50.243]             c <- base::c
[10:22:50.243]             inherits <- base::inherits
[10:22:50.243]             invokeRestart <- base::invokeRestart
[10:22:50.243]             length <- base::length
[10:22:50.243]             list <- base::list
[10:22:50.243]             seq.int <- base::seq.int
[10:22:50.243]             signalCondition <- base::signalCondition
[10:22:50.243]             sys.calls <- base::sys.calls
[10:22:50.243]             `[[` <- base::`[[`
[10:22:50.243]             `+` <- base::`+`
[10:22:50.243]             `<<-` <- base::`<<-`
[10:22:50.243]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:50.243]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:50.243]                   3L)]
[10:22:50.243]             }
[10:22:50.243]             function(cond) {
[10:22:50.243]                 is_error <- inherits(cond, "error")
[10:22:50.243]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:50.243]                   NULL)
[10:22:50.243]                 if (is_error) {
[10:22:50.243]                   sessionInformation <- function() {
[10:22:50.243]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:50.243]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:50.243]                       search = base::search(), system = base::Sys.info())
[10:22:50.243]                   }
[10:22:50.243]                   ...future.conditions[[length(...future.conditions) + 
[10:22:50.243]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:50.243]                     cond$call), session = sessionInformation(), 
[10:22:50.243]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:50.243]                   signalCondition(cond)
[10:22:50.243]                 }
[10:22:50.243]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:50.243]                 "immediateCondition"))) {
[10:22:50.243]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:50.243]                   ...future.conditions[[length(...future.conditions) + 
[10:22:50.243]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:50.243]                   if (TRUE && !signal) {
[10:22:50.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.243]                     {
[10:22:50.243]                       inherits <- base::inherits
[10:22:50.243]                       invokeRestart <- base::invokeRestart
[10:22:50.243]                       is.null <- base::is.null
[10:22:50.243]                       muffled <- FALSE
[10:22:50.243]                       if (inherits(cond, "message")) {
[10:22:50.243]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:50.243]                         if (muffled) 
[10:22:50.243]                           invokeRestart("muffleMessage")
[10:22:50.243]                       }
[10:22:50.243]                       else if (inherits(cond, "warning")) {
[10:22:50.243]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:50.243]                         if (muffled) 
[10:22:50.243]                           invokeRestart("muffleWarning")
[10:22:50.243]                       }
[10:22:50.243]                       else if (inherits(cond, "condition")) {
[10:22:50.243]                         if (!is.null(pattern)) {
[10:22:50.243]                           computeRestarts <- base::computeRestarts
[10:22:50.243]                           grepl <- base::grepl
[10:22:50.243]                           restarts <- computeRestarts(cond)
[10:22:50.243]                           for (restart in restarts) {
[10:22:50.243]                             name <- restart$name
[10:22:50.243]                             if (is.null(name)) 
[10:22:50.243]                               next
[10:22:50.243]                             if (!grepl(pattern, name)) 
[10:22:50.243]                               next
[10:22:50.243]                             invokeRestart(restart)
[10:22:50.243]                             muffled <- TRUE
[10:22:50.243]                             break
[10:22:50.243]                           }
[10:22:50.243]                         }
[10:22:50.243]                       }
[10:22:50.243]                       invisible(muffled)
[10:22:50.243]                     }
[10:22:50.243]                     muffleCondition(cond, pattern = "^muffle")
[10:22:50.243]                   }
[10:22:50.243]                 }
[10:22:50.243]                 else {
[10:22:50.243]                   if (TRUE) {
[10:22:50.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:50.243]                     {
[10:22:50.243]                       inherits <- base::inherits
[10:22:50.243]                       invokeRestart <- base::invokeRestart
[10:22:50.243]                       is.null <- base::is.null
[10:22:50.243]                       muffled <- FALSE
[10:22:50.243]                       if (inherits(cond, "message")) {
[10:22:50.243]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:50.243]                         if (muffled) 
[10:22:50.243]                           invokeRestart("muffleMessage")
[10:22:50.243]                       }
[10:22:50.243]                       else if (inherits(cond, "warning")) {
[10:22:50.243]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:50.243]                         if (muffled) 
[10:22:50.243]                           invokeRestart("muffleWarning")
[10:22:50.243]                       }
[10:22:50.243]                       else if (inherits(cond, "condition")) {
[10:22:50.243]                         if (!is.null(pattern)) {
[10:22:50.243]                           computeRestarts <- base::computeRestarts
[10:22:50.243]                           grepl <- base::grepl
[10:22:50.243]                           restarts <- computeRestarts(cond)
[10:22:50.243]                           for (restart in restarts) {
[10:22:50.243]                             name <- restart$name
[10:22:50.243]                             if (is.null(name)) 
[10:22:50.243]                               next
[10:22:50.243]                             if (!grepl(pattern, name)) 
[10:22:50.243]                               next
[10:22:50.243]                             invokeRestart(restart)
[10:22:50.243]                             muffled <- TRUE
[10:22:50.243]                             break
[10:22:50.243]                           }
[10:22:50.243]                         }
[10:22:50.243]                       }
[10:22:50.243]                       invisible(muffled)
[10:22:50.243]                     }
[10:22:50.243]                     muffleCondition(cond, pattern = "^muffle")
[10:22:50.243]                   }
[10:22:50.243]                 }
[10:22:50.243]             }
[10:22:50.243]         }))
[10:22:50.243]     }, error = function(ex) {
[10:22:50.243]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:50.243]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:50.243]                 ...future.rng), started = ...future.startTime, 
[10:22:50.243]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:50.243]             version = "1.8"), class = "FutureResult")
[10:22:50.243]     }, finally = {
[10:22:50.243]         if (!identical(...future.workdir, getwd())) 
[10:22:50.243]             setwd(...future.workdir)
[10:22:50.243]         {
[10:22:50.243]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:50.243]                 ...future.oldOptions$nwarnings <- NULL
[10:22:50.243]             }
[10:22:50.243]             base::options(...future.oldOptions)
[10:22:50.243]             if (.Platform$OS.type == "windows") {
[10:22:50.243]                 old_names <- names(...future.oldEnvVars)
[10:22:50.243]                 envs <- base::Sys.getenv()
[10:22:50.243]                 names <- names(envs)
[10:22:50.243]                 common <- intersect(names, old_names)
[10:22:50.243]                 added <- setdiff(names, old_names)
[10:22:50.243]                 removed <- setdiff(old_names, names)
[10:22:50.243]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:50.243]                   envs[common]]
[10:22:50.243]                 NAMES <- toupper(changed)
[10:22:50.243]                 args <- list()
[10:22:50.243]                 for (kk in seq_along(NAMES)) {
[10:22:50.243]                   name <- changed[[kk]]
[10:22:50.243]                   NAME <- NAMES[[kk]]
[10:22:50.243]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.243]                     next
[10:22:50.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:50.243]                 }
[10:22:50.243]                 NAMES <- toupper(added)
[10:22:50.243]                 for (kk in seq_along(NAMES)) {
[10:22:50.243]                   name <- added[[kk]]
[10:22:50.243]                   NAME <- NAMES[[kk]]
[10:22:50.243]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.243]                     next
[10:22:50.243]                   args[[name]] <- ""
[10:22:50.243]                 }
[10:22:50.243]                 NAMES <- toupper(removed)
[10:22:50.243]                 for (kk in seq_along(NAMES)) {
[10:22:50.243]                   name <- removed[[kk]]
[10:22:50.243]                   NAME <- NAMES[[kk]]
[10:22:50.243]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:50.243]                     next
[10:22:50.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:50.243]                 }
[10:22:50.243]                 if (length(args) > 0) 
[10:22:50.243]                   base::do.call(base::Sys.setenv, args = args)
[10:22:50.243]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:50.243]             }
[10:22:50.243]             else {
[10:22:50.243]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:50.243]             }
[10:22:50.243]             {
[10:22:50.243]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:50.243]                   0L) {
[10:22:50.243]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:50.243]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:50.243]                   base::options(opts)
[10:22:50.243]                 }
[10:22:50.243]                 {
[10:22:50.243]                   {
[10:22:50.243]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:50.243]                     NULL
[10:22:50.243]                   }
[10:22:50.243]                   options(future.plan = NULL)
[10:22:50.243]                   if (is.na(NA_character_)) 
[10:22:50.243]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:50.243]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:50.243]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:50.243]                     .init = FALSE)
[10:22:50.243]                 }
[10:22:50.243]             }
[10:22:50.243]         }
[10:22:50.243]     })
[10:22:50.243]     if (TRUE) {
[10:22:50.243]         base::sink(type = "output", split = FALSE)
[10:22:50.243]         if (TRUE) {
[10:22:50.243]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:50.243]         }
[10:22:50.243]         else {
[10:22:50.243]             ...future.result["stdout"] <- base::list(NULL)
[10:22:50.243]         }
[10:22:50.243]         base::close(...future.stdout)
[10:22:50.243]         ...future.stdout <- NULL
[10:22:50.243]     }
[10:22:50.243]     ...future.result$conditions <- ...future.conditions
[10:22:50.243]     ...future.result$finished <- base::Sys.time()
[10:22:50.243]     ...future.result
[10:22:50.243] }
[10:22:50.246] Poll #1 (0): usedNodes() = 2, workers = 2
[10:22:50.256] receiveMessageFromWorker() for ClusterFuture ...
[10:22:50.256] - Validating connection of MultisessionFuture
[10:22:50.257] - received message: FutureResult
[10:22:50.257] - Received FutureResult
[10:22:50.257] - Erased future from FutureRegistry
[10:22:50.257] result() for ClusterFuture ...
[10:22:50.257] - result already collected: FutureResult
[10:22:50.257] result() for ClusterFuture ... done
[10:22:50.257] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:50.257] result() for ClusterFuture ...
[10:22:50.257] - result already collected: FutureResult
[10:22:50.257] result() for ClusterFuture ... done
[10:22:50.258] result() for ClusterFuture ...
[10:22:50.258] - result already collected: FutureResult
[10:22:50.258] result() for ClusterFuture ... done
[10:22:50.259] MultisessionFuture started
[10:22:50.259] - Launch lazy future ... done
[10:22:50.259] run() for ‘MultisessionFuture’ ... done
[10:22:50.260] resolve() on list environment ...
[10:22:50.260]  recursive: 0
[10:22:50.260]  length: 4
[10:22:50.260]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:22:50.261] Future #1
[10:22:50.261]  length: 3 (resolved future 1)
[10:22:50.282]  length: 2 (resolved future 4)
[10:22:50.303] receiveMessageFromWorker() for ClusterFuture ...
[10:22:50.303] - Validating connection of MultisessionFuture
[10:22:50.303] - received message: FutureResult
[10:22:50.303] - Received FutureResult
[10:22:50.303] - Erased future from FutureRegistry
[10:22:50.303] result() for ClusterFuture ...
[10:22:50.304] - result already collected: FutureResult
[10:22:50.304] result() for ClusterFuture ... done
[10:22:50.304] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:50.304] Future #3
[10:22:50.304]  length: 1 (resolved future 3)
[10:22:50.769] receiveMessageFromWorker() for ClusterFuture ...
[10:22:50.769] - Validating connection of MultisessionFuture
[10:22:50.769] - received message: FutureResult
[10:22:50.769] - Received FutureResult
[10:22:50.769] - Erased future from FutureRegistry
[10:22:50.770] result() for ClusterFuture ...
[10:22:50.770] - result already collected: FutureResult
[10:22:50.770] result() for ClusterFuture ... done
[10:22:50.770] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:50.770] Future #2
[10:22:50.770]  length: 0 (resolved future 2)
[10:22:50.770] resolve() on list environment ... DONE
[10:22:50.770] resolve() on list environment ...
[10:22:50.771]  recursive: 0
[10:22:50.771]  length: 4
[10:22:50.771]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:22:50.771] Future #1
[10:22:50.772]  length: 3 (resolved future 1)
[10:22:50.772] Future #2
[10:22:50.772]  length: 2 (resolved future 2)
[10:22:50.772] Future #3
[10:22:50.772]  length: 1 (resolved future 3)
[10:22:50.772]  length: 0 (resolved future 4)
[10:22:50.772] resolve() on list environment ... DONE
[10:22:50.773] resolve() on list environment ...
[10:22:50.773]  recursive: 0
[10:22:50.773]  length: 4
[10:22:50.773]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:22:50.774] Future #1
[10:22:50.774]  length: 3 (resolved future 1)
[10:22:50.774] Future #2
[10:22:50.774]  length: 2 (resolved future 2)
[10:22:50.774] Future #3
[10:22:50.774]  length: 1 (resolved future 3)
[10:22:50.774]  length: 0 (resolved future 4)
[10:22:50.774] resolve() on list environment ... DONE
[10:22:50.775] resolve() on list environment ...
[10:22:50.775]  recursive: 0
[10:22:50.775]  length: 4
[10:22:50.775]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:22:50.776] Future #1
[10:22:50.776]  length: 3 (resolved future 1)
[10:22:50.776] Future #2
[10:22:50.776]  length: 2 (resolved future 2)
[10:22:50.776] Future #3
[10:22:50.776]  length: 1 (resolved future 3)
[10:22:50.776]  length: 0 (resolved future 4)
[10:22:50.776] resolve() on list environment ... DONE
[10:22:50.777] resolve() on list environment ...
[10:22:50.777]  recursive: 0
[10:22:50.777]  length: 4
[10:22:50.777]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:22:50.778] Future #1
[10:22:50.778] result() for ClusterFuture ...
[10:22:50.778] - result already collected: FutureResult
[10:22:50.778] result() for ClusterFuture ... done
[10:22:50.778] result() for ClusterFuture ...
[10:22:50.778] - result already collected: FutureResult
[10:22:50.778] result() for ClusterFuture ... done
[10:22:50.778]  length: 3 (resolved future 1)
[10:22:50.778] Future #2
[10:22:50.778] result() for ClusterFuture ...
[10:22:50.779] - result already collected: FutureResult
[10:22:50.779] result() for ClusterFuture ... done
[10:22:50.779] result() for ClusterFuture ...
[10:22:50.779] - result already collected: FutureResult
[10:22:50.779] result() for ClusterFuture ... done
[10:22:50.779]  length: 2 (resolved future 2)
[10:22:50.779] Future #3
[10:22:50.779] result() for ClusterFuture ...
[10:22:50.779] - result already collected: FutureResult
[10:22:50.779] result() for ClusterFuture ... done
[10:22:50.779] result() for ClusterFuture ...
[10:22:50.780] - result already collected: FutureResult
[10:22:50.780] result() for ClusterFuture ... done
[10:22:50.780]  length: 1 (resolved future 3)
[10:22:50.780]  length: 0 (resolved future 4)
[10:22:50.780] resolve() on list environment ... DONE
[10:22:50.780] resolve() on list environment ...
[10:22:50.780]  recursive: 99
[10:22:50.781]  length: 4
[10:22:50.781]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[10:22:50.781] Future #1
[10:22:50.781] result() for ClusterFuture ...
[10:22:50.781] - result already collected: FutureResult
[10:22:50.782] result() for ClusterFuture ... done
[10:22:50.782] result() for ClusterFuture ...
[10:22:50.782] - result already collected: FutureResult
[10:22:50.782] result() for ClusterFuture ... done
[10:22:50.782] A MultisessionFuture was resolved
[10:22:50.782]  length: 3 (resolved future 1)
[10:22:50.782] Future #2
[10:22:50.782] result() for ClusterFuture ...
[10:22:50.782] - result already collected: FutureResult
[10:22:50.782] result() for ClusterFuture ... done
[10:22:50.782] result() for ClusterFuture ...
[10:22:50.783] - result already collected: FutureResult
[10:22:50.783] result() for ClusterFuture ... done
[10:22:50.783] A MultisessionFuture was resolved
[10:22:50.783]  length: 2 (resolved future 2)
[10:22:50.783] Future #3
[10:22:50.783] result() for ClusterFuture ...
[10:22:50.783] - result already collected: FutureResult
[10:22:50.783] result() for ClusterFuture ... done
[10:22:50.783] result() for ClusterFuture ...
[10:22:50.783] - result already collected: FutureResult
[10:22:50.783] result() for ClusterFuture ... done
[10:22:50.784] A MultisessionFuture was resolved
[10:22:50.784]  length: 1 (resolved future 3)
[10:22:50.784]  length: 0 (resolved future 4)
[10:22:50.784] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('multisession') ...
> 
> 
> message("*** resolve() - globals with non-trustful length() ...")
*** resolve() - globals with non-trustful length() ...
> 
> length.CantTrustLength <- function(x) length(unclass(x)) + 1L
> 
> .length <- future:::.length
> 
> x <- structure(as.list(1:3), class = c("CantTrustLength", "list"))
> str(list(n = length(x), n_true = .length(x)))
List of 2
 $ n     : int 4
 $ n_true: int 3
> stopifnot(length(x) > .length(x))
> x <- resolve(x)
[10:22:50.787] resolve() on list ...
[10:22:50.787]  recursive: 0
[10:22:50.787]  length: 3
[10:22:50.787] 
[10:22:50.787]  length: 2 (resolved future 1)
[10:22:50.788]  length: 1 (resolved future 2)
[10:22:50.788]  length: 0 (resolved future 3)
[10:22:50.788] resolve() on list ... DONE
> 
> message("*** resolve() - globals with non-trustful length() ... DONE")
*** resolve() - globals with non-trustful length() ... DONE
> 
> 
> message("*** resolved() - default ...")
*** resolved() - default ...
> 
> res <- resolved(42L)
> stopifnot(isTRUE(res))
> 
> message("*** resolved() - default ... DONE")
*** resolved() - default ... DONE
> 
> 
> message("*** resolve() ... DONE")
*** resolve() ... DONE
> 
> source("incl/end.R")
[10:22:50.789] plan(): Setting new future strategy stack:
[10:22:50.789] List of future strategies:
[10:22:50.789] 1. FutureStrategy:
[10:22:50.789]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:50.789]    - tweaked: FALSE
[10:22:50.789]    - call: future::plan(oplan)
[10:22:50.790] plan(): nbrOfWorkers() = 1
> 
