
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[11:02:35.979] plan(): Setting new future strategy stack:
[11:02:35.980] List of future strategies:
[11:02:35.980] 1. sequential:
[11:02:35.980]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:35.980]    - tweaked: FALSE
[11:02:35.980]    - call: future::plan("sequential")
[11:02:35.993] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> strategies <- supportedStrategies()
> 
> message("*** resolve() ...")
*** resolve() ...
> 
> message("*** resolve() for default ...")
*** resolve() for default ...
> 
> x <- 1
> y <- resolve(x)
> stopifnot(identical(y, x))
> 
> message("*** resolve() for default ... DONE")
*** resolve() for default ... DONE
> 
> 
> for (strategy in strategies) {
+   message(sprintf("- plan('%s') ...", strategy))
+   plan(strategy)
+ 
+   if (strategy == "multisession" && availableCores() >= 2) {
+     message("*** resolve() for Future objects ...")
+     
+     for (result in c(FALSE, TRUE)) {
+       for (recursive in list(FALSE, TRUE, -1, 0, 1, 2, Inf)) {
+         message(sprintf("- result = %s, recursive = %s ...", result, recursive))
+       
+         f <- future({
+           Sys.sleep(0.5)
+           list(a = 1, b = 42L)
+         })
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         f <- future({
+           Sys.sleep(0.5)
+           list(a = 1, b = 42L)
+         }, lazy = TRUE)
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         message("- w/ exception ...")
+         f <- future(list(a = 1, b = 42L, c = stop("Nah!")))
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         f <- future(list(a = 1, b = 42L, c = stop("Nah!")), lazy = TRUE)
+         res <- resolve(f, result = result, recursive = recursive)
+         stopifnot(identical(res, f))
+     
+         message(sprintf("- result = %s, recursive = %s ... DONE", result, recursive))
+       } ## for (resolve ...)
+     } ## for (result ...)
+     
+     message("*** resolve() for Future objects ... DONE")
+   } ## if (strategy == "multisession" && availableCores() >= 2)
+   
+   message("*** resolve() for lists ...")
+ 
+   x <- list()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   x$a <- 1
+   x$b <- 2
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   x$a <- future(1)
+   x$b <- future(2)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1, lazy = TRUE)
+   x$b <- future(2)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1, lazy = TRUE)
+   x$b <- future(2, lazy = TRUE)
+   x[[3]] <- 3
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x[["b"]]))
+ 
+   x <- list()
+   x$a <- future(1)
+   x$b <- future({Sys.sleep(0.5); 2})
+   x[[4]] <- 4
+   dim(x) <- c(2, 2)
+   y <- resolve(x, idxs = 1)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x[[1]]))
+   y <- resolve(x, idxs = 2)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x[[2]]))
+   y <- resolve(x, idxs = 3)
+   stopifnot(identical(y, x))
+   y <- resolve(x, idxs = seq_along(x))
+   stopifnot(identical(y, x))
+   y <- resolve(x, idxs = names(x))
+   stopifnot(identical(y, x))
+ 
+   y <- resolve(x, idxs = matrix(c(1, 2), ncol = 2L), result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   for (kk in 1:3) x[[kk]] <- future({ Sys.sleep(0.1); kk })
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- list()
+   for (kk in 1:3) x[[kk]] <- future({ Sys.sleep(0.1); kk }, lazy = TRUE)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   x <- list()
+   x$a <- 1
+   x$b <- 2
+ 
+   res <- tryCatch(y <- resolve(x, idxs = 0L), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   x <- list(1, 2)
+   res <- tryCatch(x <- resolve(x, idxs = "a"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for lists ... DONE")
+ 
+ 
+   message("*** resolve() for environments ...")
+ 
+   x <- new.env()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- new.env()
+   x$a <- 1
+   x$b <- 2
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 0L)
+ 
+   x <- new.env()
+   x$a <- future(1)
+   x$b <- future(2)
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(resolved(x$b))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- new.env()
+   x$a %<-% { 1 }
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)  ## FIXME: Should not do value()!
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- new.env()
+   x$a <- future({ 1 })
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "a")
+   stopifnot(identical(y, x))
+   stopifnot(resolved(x$a))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "b")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = "c")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, idxs = names(x), result = TRUE)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x, recursive = TRUE, result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for environments ... DONE")
+ 
+ 
+   message("*** resolve() for list environments ...")
+ 
+   x <- listenv()
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- listenv()
+   x$a <- 1
+   x$b <- 2
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 0L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+ 
+   x <- listenv()
+   x$a <- future(1)
+   x$b <- future(2)
+   x$c <- 3
+   names <- names(x)
+   dim(x) <- c(1, 3)
+   names(x) <- names
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- listenv()
+   x$a %<-% { 1 }
+   x$b %<-% { 2 }
+   x$c <- 3
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+   y <- resolve(x)  ## FIXME: Should not do value()!
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x$a, mustExist = FALSE)))
+   #stopifnot(is.na(futureOf(x$b, mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 2L)
+ 
+   x <- listenv()
+   x$a <- future({ 1 })
+   x$b %<-% { Sys.sleep(0.5); 2 }
+   x$c %<-% { 3 }
+   x$d <- 4
+   names <- names(x)
+   dim(x) <- c(2, 2)
+   names(x) <- names
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+   y <- resolve(x, idxs = "a")
+   stopifnot(identical(y, x))
+   stopifnot(identical(futureOf(x$a, mustExist = FALSE), x$a))
+   stopifnot(resolved(x$a))
+   y <- resolve(x, idxs = "b")
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   idxs <- matrix(c(1, 2), ncol = 2L)
+   y <- resolve(x, idxs = idxs)
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x$c, mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, idxs = 4L)
+   stopifnot(identical(y, x))
+   #stopifnot(is.na(futureOf(x[[4L]], mustExist = FALSE)))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, idxs = names(x), result = TRUE)
+   stopifnot(identical(y, x))
+   stopifnot(length(futureOf(envir = x, drop = TRUE)) == 3L)
+ 
+   y <- resolve(x, recursive = TRUE, result = TRUE)
+   stopifnot(identical(y, x))
+ 
+   ## Exceptions
+   res <- tryCatch(y <- resolve(x, idxs = 0L), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   res <- tryCatch(y <- resolve(x, idxs = "unknown"), error = identity)
+   stopifnot(inherits(res, "error"))
+ 
+   message("*** resolve() for list environments ... DONE")
+ 
+   message(sprintf("- plan('%s') ...", strategy))
+ } ## for (strategy ...)
- plan('sequential') ...
[11:02:36.178] plan(): Setting new future strategy stack:
[11:02:36.178] List of future strategies:
[11:02:36.178] 1. sequential:
[11:02:36.178]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:36.178]    - tweaked: FALSE
[11:02:36.178]    - call: plan(strategy)
[11:02:36.190] plan(): nbrOfWorkers() = 1
*** resolve() for lists ...
[11:02:36.190] resolve() on list ...
[11:02:36.190]  recursive: 0
[11:02:36.190]  length: 2
[11:02:36.191]  elements: ‘a’, ‘b’
[11:02:36.191]  length: 1 (resolved future 1)
[11:02:36.191]  length: 0 (resolved future 2)
[11:02:36.191] resolve() on list ... DONE
[11:02:36.191] getGlobalsAndPackages() ...
[11:02:36.191] Searching for globals...
[11:02:36.193] 
[11:02:36.193] Searching for globals ... DONE
[11:02:36.193] - globals: [0] <none>
[11:02:36.194] getGlobalsAndPackages() ... DONE
[11:02:36.194] run() for ‘Future’ ...
[11:02:36.194] - state: ‘created’
[11:02:36.194] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:02:36.195] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:36.195] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:36.195]   - Field: ‘label’
[11:02:36.195]   - Field: ‘local’
[11:02:36.195]   - Field: ‘owner’
[11:02:36.195]   - Field: ‘envir’
[11:02:36.195]   - Field: ‘packages’
[11:02:36.195]   - Field: ‘gc’
[11:02:36.195]   - Field: ‘conditions’
[11:02:36.196]   - Field: ‘expr’
[11:02:36.196]   - Field: ‘uuid’
[11:02:36.196]   - Field: ‘seed’
[11:02:36.196]   - Field: ‘version’
[11:02:36.196]   - Field: ‘result’
[11:02:36.196]   - Field: ‘asynchronous’
[11:02:36.196]   - Field: ‘calls’
[11:02:36.196]   - Field: ‘globals’
[11:02:36.196]   - Field: ‘stdout’
[11:02:36.196]   - Field: ‘earlySignal’
[11:02:36.196]   - Field: ‘lazy’
[11:02:36.196]   - Field: ‘state’
[11:02:36.196] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:36.197] - Launch lazy future ...
[11:02:36.197] Packages needed by the future expression (n = 0): <none>
[11:02:36.197] Packages needed by future strategies (n = 0): <none>
[11:02:36.198] {
[11:02:36.198]     {
[11:02:36.198]         {
[11:02:36.198]             ...future.startTime <- base::Sys.time()
[11:02:36.198]             {
[11:02:36.198]                 {
[11:02:36.198]                   {
[11:02:36.198]                     base::local({
[11:02:36.198]                       has_future <- base::requireNamespace("future", 
[11:02:36.198]                         quietly = TRUE)
[11:02:36.198]                       if (has_future) {
[11:02:36.198]                         ns <- base::getNamespace("future")
[11:02:36.198]                         version <- ns[[".package"]][["version"]]
[11:02:36.198]                         if (is.null(version)) 
[11:02:36.198]                           version <- utils::packageVersion("future")
[11:02:36.198]                       }
[11:02:36.198]                       else {
[11:02:36.198]                         version <- NULL
[11:02:36.198]                       }
[11:02:36.198]                       if (!has_future || version < "1.8.0") {
[11:02:36.198]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:36.198]                           "", base::R.version$version.string), 
[11:02:36.198]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:36.198]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:36.198]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:36.198]                             "release", "version")], collapse = " "), 
[11:02:36.198]                           hostname = base::Sys.info()[["nodename"]])
[11:02:36.198]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:36.198]                           info)
[11:02:36.198]                         info <- base::paste(info, collapse = "; ")
[11:02:36.198]                         if (!has_future) {
[11:02:36.198]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:36.198]                             info)
[11:02:36.198]                         }
[11:02:36.198]                         else {
[11:02:36.198]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:36.198]                             info, version)
[11:02:36.198]                         }
[11:02:36.198]                         base::stop(msg)
[11:02:36.198]                       }
[11:02:36.198]                     })
[11:02:36.198]                   }
[11:02:36.198]                   ...future.strategy.old <- future::plan("list")
[11:02:36.198]                   options(future.plan = NULL)
[11:02:36.198]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:36.198]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:36.198]                 }
[11:02:36.198]                 ...future.workdir <- getwd()
[11:02:36.198]             }
[11:02:36.198]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:36.198]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:36.198]         }
[11:02:36.198]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:36.198]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:36.198]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:36.198]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:36.198]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:36.198]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:36.198]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:36.198]             base::names(...future.oldOptions))
[11:02:36.198]     }
[11:02:36.198]     if (FALSE) {
[11:02:36.198]     }
[11:02:36.198]     else {
[11:02:36.198]         if (TRUE) {
[11:02:36.198]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:36.198]                 open = "w")
[11:02:36.198]         }
[11:02:36.198]         else {
[11:02:36.198]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:36.198]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:36.198]         }
[11:02:36.198]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:36.198]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:36.198]             base::sink(type = "output", split = FALSE)
[11:02:36.198]             base::close(...future.stdout)
[11:02:36.198]         }, add = TRUE)
[11:02:36.198]     }
[11:02:36.198]     ...future.frame <- base::sys.nframe()
[11:02:36.198]     ...future.conditions <- base::list()
[11:02:36.198]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:36.198]     if (FALSE) {
[11:02:36.198]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:36.198]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:36.198]     }
[11:02:36.198]     ...future.result <- base::tryCatch({
[11:02:36.198]         base::withCallingHandlers({
[11:02:36.198]             ...future.value <- base::withVisible(base::local(1))
[11:02:36.198]             future::FutureResult(value = ...future.value$value, 
[11:02:36.198]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:36.198]                   ...future.rng), globalenv = if (FALSE) 
[11:02:36.198]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:36.198]                     ...future.globalenv.names))
[11:02:36.198]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:36.198]         }, condition = base::local({
[11:02:36.198]             c <- base::c
[11:02:36.198]             inherits <- base::inherits
[11:02:36.198]             invokeRestart <- base::invokeRestart
[11:02:36.198]             length <- base::length
[11:02:36.198]             list <- base::list
[11:02:36.198]             seq.int <- base::seq.int
[11:02:36.198]             signalCondition <- base::signalCondition
[11:02:36.198]             sys.calls <- base::sys.calls
[11:02:36.198]             `[[` <- base::`[[`
[11:02:36.198]             `+` <- base::`+`
[11:02:36.198]             `<<-` <- base::`<<-`
[11:02:36.198]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:36.198]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:36.198]                   3L)]
[11:02:36.198]             }
[11:02:36.198]             function(cond) {
[11:02:36.198]                 is_error <- inherits(cond, "error")
[11:02:36.198]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:36.198]                   NULL)
[11:02:36.198]                 if (is_error) {
[11:02:36.198]                   sessionInformation <- function() {
[11:02:36.198]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:36.198]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:36.198]                       search = base::search(), system = base::Sys.info())
[11:02:36.198]                   }
[11:02:36.198]                   ...future.conditions[[length(...future.conditions) + 
[11:02:36.198]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:36.198]                     cond$call), session = sessionInformation(), 
[11:02:36.198]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:36.198]                   signalCondition(cond)
[11:02:36.198]                 }
[11:02:36.198]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:36.198]                 "immediateCondition"))) {
[11:02:36.198]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:36.198]                   ...future.conditions[[length(...future.conditions) + 
[11:02:36.198]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:36.198]                   if (TRUE && !signal) {
[11:02:36.198]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:36.198]                     {
[11:02:36.198]                       inherits <- base::inherits
[11:02:36.198]                       invokeRestart <- base::invokeRestart
[11:02:36.198]                       is.null <- base::is.null
[11:02:36.198]                       muffled <- FALSE
[11:02:36.198]                       if (inherits(cond, "message")) {
[11:02:36.198]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:36.198]                         if (muffled) 
[11:02:36.198]                           invokeRestart("muffleMessage")
[11:02:36.198]                       }
[11:02:36.198]                       else if (inherits(cond, "warning")) {
[11:02:36.198]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:36.198]                         if (muffled) 
[11:02:36.198]                           invokeRestart("muffleWarning")
[11:02:36.198]                       }
[11:02:36.198]                       else if (inherits(cond, "condition")) {
[11:02:36.198]                         if (!is.null(pattern)) {
[11:02:36.198]                           computeRestarts <- base::computeRestarts
[11:02:36.198]                           grepl <- base::grepl
[11:02:36.198]                           restarts <- computeRestarts(cond)
[11:02:36.198]                           for (restart in restarts) {
[11:02:36.198]                             name <- restart$name
[11:02:36.198]                             if (is.null(name)) 
[11:02:36.198]                               next
[11:02:36.198]                             if (!grepl(pattern, name)) 
[11:02:36.198]                               next
[11:02:36.198]                             invokeRestart(restart)
[11:02:36.198]                             muffled <- TRUE
[11:02:36.198]                             break
[11:02:36.198]                           }
[11:02:36.198]                         }
[11:02:36.198]                       }
[11:02:36.198]                       invisible(muffled)
[11:02:36.198]                     }
[11:02:36.198]                     muffleCondition(cond, pattern = "^muffle")
[11:02:36.198]                   }
[11:02:36.198]                 }
[11:02:36.198]                 else {
[11:02:36.198]                   if (TRUE) {
[11:02:36.198]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:36.198]                     {
[11:02:36.198]                       inherits <- base::inherits
[11:02:36.198]                       invokeRestart <- base::invokeRestart
[11:02:36.198]                       is.null <- base::is.null
[11:02:36.198]                       muffled <- FALSE
[11:02:36.198]                       if (inherits(cond, "message")) {
[11:02:36.198]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:36.198]                         if (muffled) 
[11:02:36.198]                           invokeRestart("muffleMessage")
[11:02:36.198]                       }
[11:02:36.198]                       else if (inherits(cond, "warning")) {
[11:02:36.198]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:36.198]                         if (muffled) 
[11:02:36.198]                           invokeRestart("muffleWarning")
[11:02:36.198]                       }
[11:02:36.198]                       else if (inherits(cond, "condition")) {
[11:02:36.198]                         if (!is.null(pattern)) {
[11:02:36.198]                           computeRestarts <- base::computeRestarts
[11:02:36.198]                           grepl <- base::grepl
[11:02:36.198]                           restarts <- computeRestarts(cond)
[11:02:36.198]                           for (restart in restarts) {
[11:02:36.198]                             name <- restart$name
[11:02:36.198]                             if (is.null(name)) 
[11:02:36.198]                               next
[11:02:36.198]                             if (!grepl(pattern, name)) 
[11:02:36.198]                               next
[11:02:36.198]                             invokeRestart(restart)
[11:02:36.198]                             muffled <- TRUE
[11:02:36.198]                             break
[11:02:36.198]                           }
[11:02:36.198]                         }
[11:02:36.198]                       }
[11:02:36.198]                       invisible(muffled)
[11:02:36.198]                     }
[11:02:36.198]                     muffleCondition(cond, pattern = "^muffle")
[11:02:36.198]                   }
[11:02:36.198]                 }
[11:02:36.198]             }
[11:02:36.198]         }))
[11:02:36.198]     }, error = function(ex) {
[11:02:36.198]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:36.198]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:36.198]                 ...future.rng), started = ...future.startTime, 
[11:02:36.198]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:36.198]             version = "1.8"), class = "FutureResult")
[11:02:36.198]     }, finally = {
[11:02:36.198]         if (!identical(...future.workdir, getwd())) 
[11:02:36.198]             setwd(...future.workdir)
[11:02:36.198]         {
[11:02:36.198]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:36.198]                 ...future.oldOptions$nwarnings <- NULL
[11:02:36.198]             }
[11:02:36.198]             base::options(...future.oldOptions)
[11:02:36.198]             if (.Platform$OS.type == "windows") {
[11:02:36.198]                 old_names <- names(...future.oldEnvVars)
[11:02:36.198]                 envs <- base::Sys.getenv()
[11:02:36.198]                 names <- names(envs)
[11:02:36.198]                 common <- intersect(names, old_names)
[11:02:36.198]                 added <- setdiff(names, old_names)
[11:02:36.198]                 removed <- setdiff(old_names, names)
[11:02:36.198]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:36.198]                   envs[common]]
[11:02:36.198]                 NAMES <- toupper(changed)
[11:02:36.198]                 args <- list()
[11:02:36.198]                 for (kk in seq_along(NAMES)) {
[11:02:36.198]                   name <- changed[[kk]]
[11:02:36.198]                   NAME <- NAMES[[kk]]
[11:02:36.198]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:36.198]                     next
[11:02:36.198]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:36.198]                 }
[11:02:36.198]                 NAMES <- toupper(added)
[11:02:36.198]                 for (kk in seq_along(NAMES)) {
[11:02:36.198]                   name <- added[[kk]]
[11:02:36.198]                   NAME <- NAMES[[kk]]
[11:02:36.198]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:36.198]                     next
[11:02:36.198]                   args[[name]] <- ""
[11:02:36.198]                 }
[11:02:36.198]                 NAMES <- toupper(removed)
[11:02:36.198]                 for (kk in seq_along(NAMES)) {
[11:02:36.198]                   name <- removed[[kk]]
[11:02:36.198]                   NAME <- NAMES[[kk]]
[11:02:36.198]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:36.198]                     next
[11:02:36.198]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:36.198]                 }
[11:02:36.198]                 if (length(args) > 0) 
[11:02:36.198]                   base::do.call(base::Sys.setenv, args = args)
[11:02:36.198]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:36.198]             }
[11:02:36.198]             else {
[11:02:36.198]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:36.198]             }
[11:02:36.198]             {
[11:02:36.198]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:36.198]                   0L) {
[11:02:36.198]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:36.198]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:36.198]                   base::options(opts)
[11:02:36.198]                 }
[11:02:36.198]                 {
[11:02:36.198]                   {
[11:02:36.198]                     NULL
[11:02:36.198]                     RNGkind("Mersenne-Twister")
[11:02:36.198]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:36.198]                       inherits = FALSE)
[11:02:36.198]                   }
[11:02:36.198]                   options(future.plan = NULL)
[11:02:36.198]                   if (is.na(NA_character_)) 
[11:02:36.198]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:36.198]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:36.198]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:36.198]                     .init = FALSE)
[11:02:36.198]                 }
[11:02:36.198]             }
[11:02:36.198]         }
[11:02:36.198]     })
[11:02:36.198]     if (TRUE) {
[11:02:36.198]         base::sink(type = "output", split = FALSE)
[11:02:36.198]         if (TRUE) {
[11:02:36.198]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:36.198]         }
[11:02:36.198]         else {
[11:02:36.198]             ...future.result["stdout"] <- base::list(NULL)
[11:02:36.198]         }
[11:02:36.198]         base::close(...future.stdout)
[11:02:36.198]         ...future.stdout <- NULL
[11:02:36.198]     }
[11:02:36.198]     ...future.result$conditions <- ...future.conditions
[11:02:36.198]     ...future.result$finished <- base::Sys.time()
[11:02:36.198]     ...future.result
[11:02:36.198] }
[11:02:36.200] plan(): Setting new future strategy stack:
[11:02:36.200] List of future strategies:
[11:02:36.200] 1. sequential:
[11:02:36.200]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:36.200]    - tweaked: FALSE
[11:02:36.200]    - call: NULL
[11:02:36.200] plan(): nbrOfWorkers() = 1
[11:02:36.201] plan(): Setting new future strategy stack:
[11:02:36.202] List of future strategies:
[11:02:36.202] 1. sequential:
[11:02:36.202]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:36.202]    - tweaked: FALSE
[11:02:36.202]    - call: plan(strategy)
[11:02:36.202] plan(): nbrOfWorkers() = 1
[11:02:36.202] SequentialFuture started (and completed)
[11:02:36.203] - Launch lazy future ... done
[11:02:36.203] run() for ‘SequentialFuture’ ... done
[11:02:36.203] getGlobalsAndPackages() ...
[11:02:36.203] Searching for globals...
[11:02:36.203] 
[11:02:36.203] Searching for globals ... DONE
[11:02:36.203] - globals: [0] <none>
[11:02:36.203] getGlobalsAndPackages() ... DONE
[11:02:36.204] run() for ‘Future’ ...
[11:02:36.204] - state: ‘created’
[11:02:36.204] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:02:36.204] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:36.204] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:36.204]   - Field: ‘label’
[11:02:36.204]   - Field: ‘local’
[11:02:36.204]   - Field: ‘owner’
[11:02:36.204]   - Field: ‘envir’
[11:02:36.204]   - Field: ‘packages’
[11:02:36.205]   - Field: ‘gc’
[11:02:36.205]   - Field: ‘conditions’
[11:02:36.205]   - Field: ‘expr’
[11:02:36.205]   - Field: ‘uuid’
[11:02:36.205]   - Field: ‘seed’
[11:02:36.205]   - Field: ‘version’
[11:02:36.205]   - Field: ‘result’
[11:02:36.205]   - Field: ‘asynchronous’
[11:02:36.205]   - Field: ‘calls’
[11:02:36.205]   - Field: ‘globals’
[11:02:36.205]   - Field: ‘stdout’
[11:02:36.205]   - Field: ‘earlySignal’
[11:02:36.206]   - Field: ‘lazy’
[11:02:36.206]   - Field: ‘state’
[11:02:36.206] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:36.206] - Launch lazy future ...
[11:02:36.206] Packages needed by the future expression (n = 0): <none>
[11:02:36.206] Packages needed by future strategies (n = 0): <none>
[11:02:36.206] {
[11:02:36.206]     {
[11:02:36.206]         {
[11:02:36.206]             ...future.startTime <- base::Sys.time()
[11:02:36.206]             {
[11:02:36.206]                 {
[11:02:36.206]                   {
[11:02:36.206]                     base::local({
[11:02:36.206]                       has_future <- base::requireNamespace("future", 
[11:02:36.206]                         quietly = TRUE)
[11:02:36.206]                       if (has_future) {
[11:02:36.206]                         ns <- base::getNamespace("future")
[11:02:36.206]                         version <- ns[[".package"]][["version"]]
[11:02:36.206]                         if (is.null(version)) 
[11:02:36.206]                           version <- utils::packageVersion("future")
[11:02:36.206]                       }
[11:02:36.206]                       else {
[11:02:36.206]                         version <- NULL
[11:02:36.206]                       }
[11:02:36.206]                       if (!has_future || version < "1.8.0") {
[11:02:36.206]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:36.206]                           "", base::R.version$version.string), 
[11:02:36.206]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:36.206]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:36.206]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:36.206]                             "release", "version")], collapse = " "), 
[11:02:36.206]                           hostname = base::Sys.info()[["nodename"]])
[11:02:36.206]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:36.206]                           info)
[11:02:36.206]                         info <- base::paste(info, collapse = "; ")
[11:02:36.206]                         if (!has_future) {
[11:02:36.206]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:36.206]                             info)
[11:02:36.206]                         }
[11:02:36.206]                         else {
[11:02:36.206]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:36.206]                             info, version)
[11:02:36.206]                         }
[11:02:36.206]                         base::stop(msg)
[11:02:36.206]                       }
[11:02:36.206]                     })
[11:02:36.206]                   }
[11:02:36.206]                   ...future.strategy.old <- future::plan("list")
[11:02:36.206]                   options(future.plan = NULL)
[11:02:36.206]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:36.206]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:36.206]                 }
[11:02:36.206]                 ...future.workdir <- getwd()
[11:02:36.206]             }
[11:02:36.206]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:36.206]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:36.206]         }
[11:02:36.206]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:36.206]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:36.206]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:36.206]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:36.206]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:36.206]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:36.206]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:36.206]             base::names(...future.oldOptions))
[11:02:36.206]     }
[11:02:36.206]     if (FALSE) {
[11:02:36.206]     }
[11:02:36.206]     else {
[11:02:36.206]         if (TRUE) {
[11:02:36.206]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:36.206]                 open = "w")
[11:02:36.206]         }
[11:02:36.206]         else {
[11:02:36.206]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:36.206]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:36.206]         }
[11:02:36.206]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:36.206]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:36.206]             base::sink(type = "output", split = FALSE)
[11:02:36.206]             base::close(...future.stdout)
[11:02:36.206]         }, add = TRUE)
[11:02:36.206]     }
[11:02:36.206]     ...future.frame <- base::sys.nframe()
[11:02:36.206]     ...future.conditions <- base::list()
[11:02:36.206]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:36.206]     if (FALSE) {
[11:02:36.206]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:36.206]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:36.206]     }
[11:02:36.206]     ...future.result <- base::tryCatch({
[11:02:36.206]         base::withCallingHandlers({
[11:02:36.206]             ...future.value <- base::withVisible(base::local(2))
[11:02:36.206]             future::FutureResult(value = ...future.value$value, 
[11:02:36.206]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:36.206]                   ...future.rng), globalenv = if (FALSE) 
[11:02:36.206]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:36.206]                     ...future.globalenv.names))
[11:02:36.206]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:36.206]         }, condition = base::local({
[11:02:36.206]             c <- base::c
[11:02:36.206]             inherits <- base::inherits
[11:02:36.206]             invokeRestart <- base::invokeRestart
[11:02:36.206]             length <- base::length
[11:02:36.206]             list <- base::list
[11:02:36.206]             seq.int <- base::seq.int
[11:02:36.206]             signalCondition <- base::signalCondition
[11:02:36.206]             sys.calls <- base::sys.calls
[11:02:36.206]             `[[` <- base::`[[`
[11:02:36.206]             `+` <- base::`+`
[11:02:36.206]             `<<-` <- base::`<<-`
[11:02:36.206]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:36.206]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:36.206]                   3L)]
[11:02:36.206]             }
[11:02:36.206]             function(cond) {
[11:02:36.206]                 is_error <- inherits(cond, "error")
[11:02:36.206]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:36.206]                   NULL)
[11:02:36.206]                 if (is_error) {
[11:02:36.206]                   sessionInformation <- function() {
[11:02:36.206]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:36.206]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:36.206]                       search = base::search(), system = base::Sys.info())
[11:02:36.206]                   }
[11:02:36.206]                   ...future.conditions[[length(...future.conditions) + 
[11:02:36.206]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:36.206]                     cond$call), session = sessionInformation(), 
[11:02:36.206]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:36.206]                   signalCondition(cond)
[11:02:36.206]                 }
[11:02:36.206]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:36.206]                 "immediateCondition"))) {
[11:02:36.206]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:36.206]                   ...future.conditions[[length(...future.conditions) + 
[11:02:36.206]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:36.206]                   if (TRUE && !signal) {
[11:02:36.206]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:36.206]                     {
[11:02:36.206]                       inherits <- base::inherits
[11:02:36.206]                       invokeRestart <- base::invokeRestart
[11:02:36.206]                       is.null <- base::is.null
[11:02:36.206]                       muffled <- FALSE
[11:02:36.206]                       if (inherits(cond, "message")) {
[11:02:36.206]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:36.206]                         if (muffled) 
[11:02:36.206]                           invokeRestart("muffleMessage")
[11:02:36.206]                       }
[11:02:36.206]                       else if (inherits(cond, "warning")) {
[11:02:36.206]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:36.206]                         if (muffled) 
[11:02:36.206]                           invokeRestart("muffleWarning")
[11:02:36.206]                       }
[11:02:36.206]                       else if (inherits(cond, "condition")) {
[11:02:36.206]                         if (!is.null(pattern)) {
[11:02:36.206]                           computeRestarts <- base::computeRestarts
[11:02:36.206]                           grepl <- base::grepl
[11:02:36.206]                           restarts <- computeRestarts(cond)
[11:02:36.206]                           for (restart in restarts) {
[11:02:36.206]                             name <- restart$name
[11:02:36.206]                             if (is.null(name)) 
[11:02:36.206]                               next
[11:02:36.206]                             if (!grepl(pattern, name)) 
[11:02:36.206]                               next
[11:02:36.206]                             invokeRestart(restart)
[11:02:36.206]                             muffled <- TRUE
[11:02:36.206]                             break
[11:02:36.206]                           }
[11:02:36.206]                         }
[11:02:36.206]                       }
[11:02:36.206]                       invisible(muffled)
[11:02:36.206]                     }
[11:02:36.206]                     muffleCondition(cond, pattern = "^muffle")
[11:02:36.206]                   }
[11:02:36.206]                 }
[11:02:36.206]                 else {
[11:02:36.206]                   if (TRUE) {
[11:02:36.206]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:36.206]                     {
[11:02:36.206]                       inherits <- base::inherits
[11:02:36.206]                       invokeRestart <- base::invokeRestart
[11:02:36.206]                       is.null <- base::is.null
[11:02:36.206]                       muffled <- FALSE
[11:02:36.206]                       if (inherits(cond, "message")) {
[11:02:36.206]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:36.206]                         if (muffled) 
[11:02:36.206]                           invokeRestart("muffleMessage")
[11:02:36.206]                       }
[11:02:36.206]                       else if (inherits(cond, "warning")) {
[11:02:36.206]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:36.206]                         if (muffled) 
[11:02:36.206]                           invokeRestart("muffleWarning")
[11:02:36.206]                       }
[11:02:36.206]                       else if (inherits(cond, "condition")) {
[11:02:36.206]                         if (!is.null(pattern)) {
[11:02:36.206]                           computeRestarts <- base::computeRestarts
[11:02:36.206]                           grepl <- base::grepl
[11:02:36.206]                           restarts <- computeRestarts(cond)
[11:02:36.206]                           for (restart in restarts) {
[11:02:36.206]                             name <- restart$name
[11:02:36.206]                             if (is.null(name)) 
[11:02:36.206]                               next
[11:02:36.206]                             if (!grepl(pattern, name)) 
[11:02:36.206]                               next
[11:02:36.206]                             invokeRestart(restart)
[11:02:36.206]                             muffled <- TRUE
[11:02:36.206]                             break
[11:02:36.206]                           }
[11:02:36.206]                         }
[11:02:36.206]                       }
[11:02:36.206]                       invisible(muffled)
[11:02:36.206]                     }
[11:02:36.206]                     muffleCondition(cond, pattern = "^muffle")
[11:02:36.206]                   }
[11:02:36.206]                 }
[11:02:36.206]             }
[11:02:36.206]         }))
[11:02:36.206]     }, error = function(ex) {
[11:02:36.206]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:36.206]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:36.206]                 ...future.rng), started = ...future.startTime, 
[11:02:36.206]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:36.206]             version = "1.8"), class = "FutureResult")
[11:02:36.206]     }, finally = {
[11:02:36.206]         if (!identical(...future.workdir, getwd())) 
[11:02:36.206]             setwd(...future.workdir)
[11:02:36.206]         {
[11:02:36.206]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:36.206]                 ...future.oldOptions$nwarnings <- NULL
[11:02:36.206]             }
[11:02:36.206]             base::options(...future.oldOptions)
[11:02:36.206]             if (.Platform$OS.type == "windows") {
[11:02:36.206]                 old_names <- names(...future.oldEnvVars)
[11:02:36.206]                 envs <- base::Sys.getenv()
[11:02:36.206]                 names <- names(envs)
[11:02:36.206]                 common <- intersect(names, old_names)
[11:02:36.206]                 added <- setdiff(names, old_names)
[11:02:36.206]                 removed <- setdiff(old_names, names)
[11:02:36.206]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:36.206]                   envs[common]]
[11:02:36.206]                 NAMES <- toupper(changed)
[11:02:36.206]                 args <- list()
[11:02:36.206]                 for (kk in seq_along(NAMES)) {
[11:02:36.206]                   name <- changed[[kk]]
[11:02:36.206]                   NAME <- NAMES[[kk]]
[11:02:36.206]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:36.206]                     next
[11:02:36.206]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:36.206]                 }
[11:02:36.206]                 NAMES <- toupper(added)
[11:02:36.206]                 for (kk in seq_along(NAMES)) {
[11:02:36.206]                   name <- added[[kk]]
[11:02:36.206]                   NAME <- NAMES[[kk]]
[11:02:36.206]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:36.206]                     next
[11:02:36.206]                   args[[name]] <- ""
[11:02:36.206]                 }
[11:02:36.206]                 NAMES <- toupper(removed)
[11:02:36.206]                 for (kk in seq_along(NAMES)) {
[11:02:36.206]                   name <- removed[[kk]]
[11:02:36.206]                   NAME <- NAMES[[kk]]
[11:02:36.206]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:36.206]                     next
[11:02:36.206]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:36.206]                 }
[11:02:36.206]                 if (length(args) > 0) 
[11:02:36.206]                   base::do.call(base::Sys.setenv, args = args)
[11:02:36.206]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:36.206]             }
[11:02:36.206]             else {
[11:02:36.206]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:36.206]             }
[11:02:36.206]             {
[11:02:36.206]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:36.206]                   0L) {
[11:02:36.206]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:36.206]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:36.206]                   base::options(opts)
[11:02:36.206]                 }
[11:02:36.206]                 {
[11:02:36.206]                   {
[11:02:36.206]                     NULL
[11:02:36.206]                     RNGkind("Mersenne-Twister")
[11:02:36.206]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:36.206]                       inherits = FALSE)
[11:02:36.206]                   }
[11:02:36.206]                   options(future.plan = NULL)
[11:02:36.206]                   if (is.na(NA_character_)) 
[11:02:36.206]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:36.206]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:36.206]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:36.206]                     .init = FALSE)
[11:02:36.206]                 }
[11:02:36.206]             }
[11:02:36.206]         }
[11:02:36.206]     })
[11:02:36.206]     if (TRUE) {
[11:02:36.206]         base::sink(type = "output", split = FALSE)
[11:02:36.206]         if (TRUE) {
[11:02:36.206]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:36.206]         }
[11:02:36.206]         else {
[11:02:36.206]             ...future.result["stdout"] <- base::list(NULL)
[11:02:36.206]         }
[11:02:36.206]         base::close(...future.stdout)
[11:02:36.206]         ...future.stdout <- NULL
[11:02:36.206]     }
[11:02:36.206]     ...future.result$conditions <- ...future.conditions
[11:02:36.206]     ...future.result$finished <- base::Sys.time()
[11:02:36.206]     ...future.result
[11:02:36.206] }
[11:02:36.208] plan(): Setting new future strategy stack:
[11:02:36.208] List of future strategies:
[11:02:36.208] 1. sequential:
[11:02:36.208]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:36.208]    - tweaked: FALSE
[11:02:36.208]    - call: NULL
[11:02:36.209] plan(): nbrOfWorkers() = 1
[11:02:36.209] plan(): Setting new future strategy stack:
[11:02:36.209] List of future strategies:
[11:02:36.209] 1. sequential:
[11:02:36.209]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:36.209]    - tweaked: FALSE
[11:02:36.209]    - call: plan(strategy)
[11:02:36.210] plan(): nbrOfWorkers() = 1
[11:02:36.210] SequentialFuture started (and completed)
[11:02:36.210] - Launch lazy future ... done
[11:02:36.210] run() for ‘SequentialFuture’ ... done
[11:02:36.210] resolve() on list ...
[11:02:36.210]  recursive: 0
[11:02:36.210]  length: 3
[11:02:36.211]  elements: ‘a’, ‘b’, ‘’
[11:02:36.211] resolved() for ‘SequentialFuture’ ...
[11:02:36.211] - state: ‘finished’
[11:02:36.211] - run: TRUE
[11:02:36.211] - result: ‘FutureResult’
[11:02:36.211] resolved() for ‘SequentialFuture’ ... done
[11:02:36.211] Future #1
[11:02:36.211]  length: 2 (resolved future 1)
[11:02:36.211] resolved() for ‘SequentialFuture’ ...
[11:02:36.212] - state: ‘finished’
[11:02:36.212] - run: TRUE
[11:02:36.212] - result: ‘FutureResult’
[11:02:36.212] resolved() for ‘SequentialFuture’ ... done
[11:02:36.212] Future #2
[11:02:36.212]  length: 1 (resolved future 2)
[11:02:36.212]  length: 0 (resolved future 3)
[11:02:36.212] resolve() on list ... DONE
[11:02:36.212] resolved() for ‘SequentialFuture’ ...
[11:02:36.212] - state: ‘finished’
[11:02:36.212] - run: TRUE
[11:02:36.213] - result: ‘FutureResult’
[11:02:36.213] resolved() for ‘SequentialFuture’ ... done
[11:02:36.213] resolved() for ‘SequentialFuture’ ...
[11:02:36.213] - state: ‘finished’
[11:02:36.213] - run: TRUE
[11:02:36.213] - result: ‘FutureResult’
[11:02:36.213] resolved() for ‘SequentialFuture’ ... done
[11:02:36.213] getGlobalsAndPackages() ...
[11:02:36.213] Searching for globals...
[11:02:36.213] 
[11:02:36.214] Searching for globals ... DONE
[11:02:36.214] - globals: [0] <none>
[11:02:36.214] getGlobalsAndPackages() ... DONE
[11:02:36.214] getGlobalsAndPackages() ...
[11:02:36.214] Searching for globals...
[11:02:36.214] 
[11:02:36.214] Searching for globals ... DONE
[11:02:36.214] - globals: [0] <none>
[11:02:36.216] getGlobalsAndPackages() ... DONE
[11:02:36.216] run() for ‘Future’ ...
[11:02:36.216] - state: ‘created’
[11:02:36.216] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:02:36.217] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:36.217] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:36.217]   - Field: ‘label’
[11:02:36.217]   - Field: ‘local’
[11:02:36.217]   - Field: ‘owner’
[11:02:36.217]   - Field: ‘envir’
[11:02:36.217]   - Field: ‘packages’
[11:02:36.217]   - Field: ‘gc’
[11:02:36.217]   - Field: ‘conditions’
[11:02:36.217]   - Field: ‘expr’
[11:02:36.217]   - Field: ‘uuid’
[11:02:36.217]   - Field: ‘seed’
[11:02:36.218]   - Field: ‘version’
[11:02:36.218]   - Field: ‘result’
[11:02:36.218]   - Field: ‘asynchronous’
[11:02:36.218]   - Field: ‘calls’
[11:02:36.218]   - Field: ‘globals’
[11:02:36.218]   - Field: ‘stdout’
[11:02:36.218]   - Field: ‘earlySignal’
[11:02:36.218]   - Field: ‘lazy’
[11:02:36.218]   - Field: ‘state’
[11:02:36.218] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:36.218] - Launch lazy future ...
[11:02:36.219] Packages needed by the future expression (n = 0): <none>
[11:02:36.219] Packages needed by future strategies (n = 0): <none>
[11:02:36.219] {
[11:02:36.219]     {
[11:02:36.219]         {
[11:02:36.219]             ...future.startTime <- base::Sys.time()
[11:02:36.219]             {
[11:02:36.219]                 {
[11:02:36.219]                   {
[11:02:36.219]                     base::local({
[11:02:36.219]                       has_future <- base::requireNamespace("future", 
[11:02:36.219]                         quietly = TRUE)
[11:02:36.219]                       if (has_future) {
[11:02:36.219]                         ns <- base::getNamespace("future")
[11:02:36.219]                         version <- ns[[".package"]][["version"]]
[11:02:36.219]                         if (is.null(version)) 
[11:02:36.219]                           version <- utils::packageVersion("future")
[11:02:36.219]                       }
[11:02:36.219]                       else {
[11:02:36.219]                         version <- NULL
[11:02:36.219]                       }
[11:02:36.219]                       if (!has_future || version < "1.8.0") {
[11:02:36.219]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:36.219]                           "", base::R.version$version.string), 
[11:02:36.219]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:36.219]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:36.219]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:36.219]                             "release", "version")], collapse = " "), 
[11:02:36.219]                           hostname = base::Sys.info()[["nodename"]])
[11:02:36.219]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:36.219]                           info)
[11:02:36.219]                         info <- base::paste(info, collapse = "; ")
[11:02:36.219]                         if (!has_future) {
[11:02:36.219]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:36.219]                             info)
[11:02:36.219]                         }
[11:02:36.219]                         else {
[11:02:36.219]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:36.219]                             info, version)
[11:02:36.219]                         }
[11:02:36.219]                         base::stop(msg)
[11:02:36.219]                       }
[11:02:36.219]                     })
[11:02:36.219]                   }
[11:02:36.219]                   ...future.strategy.old <- future::plan("list")
[11:02:36.219]                   options(future.plan = NULL)
[11:02:36.219]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:36.219]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:36.219]                 }
[11:02:36.219]                 ...future.workdir <- getwd()
[11:02:36.219]             }
[11:02:36.219]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:36.219]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:36.219]         }
[11:02:36.219]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:36.219]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:36.219]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:36.219]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:36.219]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:36.219]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:36.219]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:36.219]             base::names(...future.oldOptions))
[11:02:36.219]     }
[11:02:36.219]     if (FALSE) {
[11:02:36.219]     }
[11:02:36.219]     else {
[11:02:36.219]         if (TRUE) {
[11:02:36.219]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:36.219]                 open = "w")
[11:02:36.219]         }
[11:02:36.219]         else {
[11:02:36.219]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:36.219]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:36.219]         }
[11:02:36.219]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:36.219]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:36.219]             base::sink(type = "output", split = FALSE)
[11:02:36.219]             base::close(...future.stdout)
[11:02:36.219]         }, add = TRUE)
[11:02:36.219]     }
[11:02:36.219]     ...future.frame <- base::sys.nframe()
[11:02:36.219]     ...future.conditions <- base::list()
[11:02:36.219]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:36.219]     if (FALSE) {
[11:02:36.219]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:36.219]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:36.219]     }
[11:02:36.219]     ...future.result <- base::tryCatch({
[11:02:36.219]         base::withCallingHandlers({
[11:02:36.219]             ...future.value <- base::withVisible(base::local(2))
[11:02:36.219]             future::FutureResult(value = ...future.value$value, 
[11:02:36.219]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:36.219]                   ...future.rng), globalenv = if (FALSE) 
[11:02:36.219]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:36.219]                     ...future.globalenv.names))
[11:02:36.219]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:36.219]         }, condition = base::local({
[11:02:36.219]             c <- base::c
[11:02:36.219]             inherits <- base::inherits
[11:02:36.219]             invokeRestart <- base::invokeRestart
[11:02:36.219]             length <- base::length
[11:02:36.219]             list <- base::list
[11:02:36.219]             seq.int <- base::seq.int
[11:02:36.219]             signalCondition <- base::signalCondition
[11:02:36.219]             sys.calls <- base::sys.calls
[11:02:36.219]             `[[` <- base::`[[`
[11:02:36.219]             `+` <- base::`+`
[11:02:36.219]             `<<-` <- base::`<<-`
[11:02:36.219]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:36.219]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:36.219]                   3L)]
[11:02:36.219]             }
[11:02:36.219]             function(cond) {
[11:02:36.219]                 is_error <- inherits(cond, "error")
[11:02:36.219]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:36.219]                   NULL)
[11:02:36.219]                 if (is_error) {
[11:02:36.219]                   sessionInformation <- function() {
[11:02:36.219]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:36.219]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:36.219]                       search = base::search(), system = base::Sys.info())
[11:02:36.219]                   }
[11:02:36.219]                   ...future.conditions[[length(...future.conditions) + 
[11:02:36.219]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:36.219]                     cond$call), session = sessionInformation(), 
[11:02:36.219]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:36.219]                   signalCondition(cond)
[11:02:36.219]                 }
[11:02:36.219]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:36.219]                 "immediateCondition"))) {
[11:02:36.219]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:36.219]                   ...future.conditions[[length(...future.conditions) + 
[11:02:36.219]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:36.219]                   if (TRUE && !signal) {
[11:02:36.219]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:36.219]                     {
[11:02:36.219]                       inherits <- base::inherits
[11:02:36.219]                       invokeRestart <- base::invokeRestart
[11:02:36.219]                       is.null <- base::is.null
[11:02:36.219]                       muffled <- FALSE
[11:02:36.219]                       if (inherits(cond, "message")) {
[11:02:36.219]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:36.219]                         if (muffled) 
[11:02:36.219]                           invokeRestart("muffleMessage")
[11:02:36.219]                       }
[11:02:36.219]                       else if (inherits(cond, "warning")) {
[11:02:36.219]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:36.219]                         if (muffled) 
[11:02:36.219]                           invokeRestart("muffleWarning")
[11:02:36.219]                       }
[11:02:36.219]                       else if (inherits(cond, "condition")) {
[11:02:36.219]                         if (!is.null(pattern)) {
[11:02:36.219]                           computeRestarts <- base::computeRestarts
[11:02:36.219]                           grepl <- base::grepl
[11:02:36.219]                           restarts <- computeRestarts(cond)
[11:02:36.219]                           for (restart in restarts) {
[11:02:36.219]                             name <- restart$name
[11:02:36.219]                             if (is.null(name)) 
[11:02:36.219]                               next
[11:02:36.219]                             if (!grepl(pattern, name)) 
[11:02:36.219]                               next
[11:02:36.219]                             invokeRestart(restart)
[11:02:36.219]                             muffled <- TRUE
[11:02:36.219]                             break
[11:02:36.219]                           }
[11:02:36.219]                         }
[11:02:36.219]                       }
[11:02:36.219]                       invisible(muffled)
[11:02:36.219]                     }
[11:02:36.219]                     muffleCondition(cond, pattern = "^muffle")
[11:02:36.219]                   }
[11:02:36.219]                 }
[11:02:36.219]                 else {
[11:02:36.219]                   if (TRUE) {
[11:02:36.219]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:36.219]                     {
[11:02:36.219]                       inherits <- base::inherits
[11:02:36.219]                       invokeRestart <- base::invokeRestart
[11:02:36.219]                       is.null <- base::is.null
[11:02:36.219]                       muffled <- FALSE
[11:02:36.219]                       if (inherits(cond, "message")) {
[11:02:36.219]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:36.219]                         if (muffled) 
[11:02:36.219]                           invokeRestart("muffleMessage")
[11:02:36.219]                       }
[11:02:36.219]                       else if (inherits(cond, "warning")) {
[11:02:36.219]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:36.219]                         if (muffled) 
[11:02:36.219]                           invokeRestart("muffleWarning")
[11:02:36.219]                       }
[11:02:36.219]                       else if (inherits(cond, "condition")) {
[11:02:36.219]                         if (!is.null(pattern)) {
[11:02:36.219]                           computeRestarts <- base::computeRestarts
[11:02:36.219]                           grepl <- base::grepl
[11:02:36.219]                           restarts <- computeRestarts(cond)
[11:02:36.219]                           for (restart in restarts) {
[11:02:36.219]                             name <- restart$name
[11:02:36.219]                             if (is.null(name)) 
[11:02:36.219]                               next
[11:02:36.219]                             if (!grepl(pattern, name)) 
[11:02:36.219]                               next
[11:02:36.219]                             invokeRestart(restart)
[11:02:36.219]                             muffled <- TRUE
[11:02:36.219]                             break
[11:02:36.219]                           }
[11:02:36.219]                         }
[11:02:36.219]                       }
[11:02:36.219]                       invisible(muffled)
[11:02:36.219]                     }
[11:02:36.219]                     muffleCondition(cond, pattern = "^muffle")
[11:02:36.219]                   }
[11:02:36.219]                 }
[11:02:36.219]             }
[11:02:36.219]         }))
[11:02:36.219]     }, error = function(ex) {
[11:02:36.219]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:36.219]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:36.219]                 ...future.rng), started = ...future.startTime, 
[11:02:36.219]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:36.219]             version = "1.8"), class = "FutureResult")
[11:02:36.219]     }, finally = {
[11:02:36.219]         if (!identical(...future.workdir, getwd())) 
[11:02:36.219]             setwd(...future.workdir)
[11:02:36.219]         {
[11:02:36.219]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:36.219]                 ...future.oldOptions$nwarnings <- NULL
[11:02:36.219]             }
[11:02:36.219]             base::options(...future.oldOptions)
[11:02:36.219]             if (.Platform$OS.type == "windows") {
[11:02:36.219]                 old_names <- names(...future.oldEnvVars)
[11:02:36.219]                 envs <- base::Sys.getenv()
[11:02:36.219]                 names <- names(envs)
[11:02:36.219]                 common <- intersect(names, old_names)
[11:02:36.219]                 added <- setdiff(names, old_names)
[11:02:36.219]                 removed <- setdiff(old_names, names)
[11:02:36.219]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:36.219]                   envs[common]]
[11:02:36.219]                 NAMES <- toupper(changed)
[11:02:36.219]                 args <- list()
[11:02:36.219]                 for (kk in seq_along(NAMES)) {
[11:02:36.219]                   name <- changed[[kk]]
[11:02:36.219]                   NAME <- NAMES[[kk]]
[11:02:36.219]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:36.219]                     next
[11:02:36.219]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:36.219]                 }
[11:02:36.219]                 NAMES <- toupper(added)
[11:02:36.219]                 for (kk in seq_along(NAMES)) {
[11:02:36.219]                   name <- added[[kk]]
[11:02:36.219]                   NAME <- NAMES[[kk]]
[11:02:36.219]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:36.219]                     next
[11:02:36.219]                   args[[name]] <- ""
[11:02:36.219]                 }
[11:02:36.219]                 NAMES <- toupper(removed)
[11:02:36.219]                 for (kk in seq_along(NAMES)) {
[11:02:36.219]                   name <- removed[[kk]]
[11:02:36.219]                   NAME <- NAMES[[kk]]
[11:02:36.219]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:36.219]                     next
[11:02:36.219]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:36.219]                 }
[11:02:36.219]                 if (length(args) > 0) 
[11:02:36.219]                   base::do.call(base::Sys.setenv, args = args)
[11:02:36.219]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:36.219]             }
[11:02:36.219]             else {
[11:02:36.219]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:36.219]             }
[11:02:36.219]             {
[11:02:36.219]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:36.219]                   0L) {
[11:02:36.219]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:36.219]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:36.219]                   base::options(opts)
[11:02:36.219]                 }
[11:02:36.219]                 {
[11:02:36.219]                   {
[11:02:36.219]                     NULL
[11:02:36.219]                     RNGkind("Mersenne-Twister")
[11:02:36.219]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:36.219]                       inherits = FALSE)
[11:02:36.219]                   }
[11:02:36.219]                   options(future.plan = NULL)
[11:02:36.219]                   if (is.na(NA_character_)) 
[11:02:36.219]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:36.219]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:36.219]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:36.219]                     .init = FALSE)
[11:02:36.219]                 }
[11:02:36.219]             }
[11:02:36.219]         }
[11:02:36.219]     })
[11:02:36.219]     if (TRUE) {
[11:02:36.219]         base::sink(type = "output", split = FALSE)
[11:02:36.219]         if (TRUE) {
[11:02:36.219]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:36.219]         }
[11:02:36.219]         else {
[11:02:36.219]             ...future.result["stdout"] <- base::list(NULL)
[11:02:36.219]         }
[11:02:36.219]         base::close(...future.stdout)
[11:02:36.219]         ...future.stdout <- NULL
[11:02:36.219]     }
[11:02:36.219]     ...future.result$conditions <- ...future.conditions
[11:02:36.219]     ...future.result$finished <- base::Sys.time()
[11:02:36.219]     ...future.result
[11:02:36.219] }
[11:02:36.221] plan(): Setting new future strategy stack:
[11:02:36.221] List of future strategies:
[11:02:36.221] 1. sequential:
[11:02:36.221]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:36.221]    - tweaked: FALSE
[11:02:36.221]    - call: NULL
[11:02:36.221] plan(): nbrOfWorkers() = 1
[11:02:36.222] plan(): Setting new future strategy stack:
[11:02:36.222] List of future strategies:
[11:02:36.222] 1. sequential:
[11:02:36.222]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:36.222]    - tweaked: FALSE
[11:02:36.222]    - call: plan(strategy)
[11:02:36.222] plan(): nbrOfWorkers() = 1
[11:02:36.223] SequentialFuture started (and completed)
[11:02:36.223] - Launch lazy future ... done
[11:02:36.223] run() for ‘SequentialFuture’ ... done
[11:02:36.223] resolve() on list ...
[11:02:36.223]  recursive: 0
[11:02:36.223]  length: 3
[11:02:36.223]  elements: ‘a’, ‘b’, ‘’
[11:02:36.223] run() for ‘Future’ ...
[11:02:36.223] - state: ‘created’
[11:02:36.224] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:02:36.224] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:36.224] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:36.224]   - Field: ‘label’
[11:02:36.224]   - Field: ‘local’
[11:02:36.224]   - Field: ‘owner’
[11:02:36.224]   - Field: ‘envir’
[11:02:36.224]   - Field: ‘packages’
[11:02:36.224]   - Field: ‘gc’
[11:02:36.224]   - Field: ‘conditions’
[11:02:36.225]   - Field: ‘expr’
[11:02:36.225]   - Field: ‘uuid’
[11:02:36.225]   - Field: ‘seed’
[11:02:36.225]   - Field: ‘version’
[11:02:36.225]   - Field: ‘result’
[11:02:36.225]   - Field: ‘asynchronous’
[11:02:36.225]   - Field: ‘calls’
[11:02:36.225]   - Field: ‘globals’
[11:02:36.225]   - Field: ‘stdout’
[11:02:36.225]   - Field: ‘earlySignal’
[11:02:36.225]   - Field: ‘lazy’
[11:02:36.225]   - Field: ‘state’
[11:02:36.226] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:36.226] - Launch lazy future ...
[11:02:36.226] Packages needed by the future expression (n = 0): <none>
[11:02:36.226] Packages needed by future strategies (n = 0): <none>
[11:02:36.226] {
[11:02:36.226]     {
[11:02:36.226]         {
[11:02:36.226]             ...future.startTime <- base::Sys.time()
[11:02:36.226]             {
[11:02:36.226]                 {
[11:02:36.226]                   {
[11:02:36.226]                     base::local({
[11:02:36.226]                       has_future <- base::requireNamespace("future", 
[11:02:36.226]                         quietly = TRUE)
[11:02:36.226]                       if (has_future) {
[11:02:36.226]                         ns <- base::getNamespace("future")
[11:02:36.226]                         version <- ns[[".package"]][["version"]]
[11:02:36.226]                         if (is.null(version)) 
[11:02:36.226]                           version <- utils::packageVersion("future")
[11:02:36.226]                       }
[11:02:36.226]                       else {
[11:02:36.226]                         version <- NULL
[11:02:36.226]                       }
[11:02:36.226]                       if (!has_future || version < "1.8.0") {
[11:02:36.226]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:36.226]                           "", base::R.version$version.string), 
[11:02:36.226]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:36.226]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:36.226]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:36.226]                             "release", "version")], collapse = " "), 
[11:02:36.226]                           hostname = base::Sys.info()[["nodename"]])
[11:02:36.226]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:36.226]                           info)
[11:02:36.226]                         info <- base::paste(info, collapse = "; ")
[11:02:36.226]                         if (!has_future) {
[11:02:36.226]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:36.226]                             info)
[11:02:36.226]                         }
[11:02:36.226]                         else {
[11:02:36.226]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:36.226]                             info, version)
[11:02:36.226]                         }
[11:02:36.226]                         base::stop(msg)
[11:02:36.226]                       }
[11:02:36.226]                     })
[11:02:36.226]                   }
[11:02:36.226]                   ...future.strategy.old <- future::plan("list")
[11:02:36.226]                   options(future.plan = NULL)
[11:02:36.226]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:36.226]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:36.226]                 }
[11:02:36.226]                 ...future.workdir <- getwd()
[11:02:36.226]             }
[11:02:36.226]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:36.226]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:36.226]         }
[11:02:36.226]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:36.226]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:36.226]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:36.226]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:36.226]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:36.226]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:36.226]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:36.226]             base::names(...future.oldOptions))
[11:02:36.226]     }
[11:02:36.226]     if (FALSE) {
[11:02:36.226]     }
[11:02:36.226]     else {
[11:02:36.226]         if (TRUE) {
[11:02:36.226]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:36.226]                 open = "w")
[11:02:36.226]         }
[11:02:36.226]         else {
[11:02:36.226]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:36.226]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:36.226]         }
[11:02:36.226]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:36.226]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:36.226]             base::sink(type = "output", split = FALSE)
[11:02:36.226]             base::close(...future.stdout)
[11:02:36.226]         }, add = TRUE)
[11:02:36.226]     }
[11:02:36.226]     ...future.frame <- base::sys.nframe()
[11:02:36.226]     ...future.conditions <- base::list()
[11:02:36.226]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:36.226]     if (FALSE) {
[11:02:36.226]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:36.226]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:36.226]     }
[11:02:36.226]     ...future.result <- base::tryCatch({
[11:02:36.226]         base::withCallingHandlers({
[11:02:36.226]             ...future.value <- base::withVisible(base::local(1))
[11:02:36.226]             future::FutureResult(value = ...future.value$value, 
[11:02:36.226]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:36.226]                   ...future.rng), globalenv = if (FALSE) 
[11:02:36.226]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:36.226]                     ...future.globalenv.names))
[11:02:36.226]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:36.226]         }, condition = base::local({
[11:02:36.226]             c <- base::c
[11:02:36.226]             inherits <- base::inherits
[11:02:36.226]             invokeRestart <- base::invokeRestart
[11:02:36.226]             length <- base::length
[11:02:36.226]             list <- base::list
[11:02:36.226]             seq.int <- base::seq.int
[11:02:36.226]             signalCondition <- base::signalCondition
[11:02:36.226]             sys.calls <- base::sys.calls
[11:02:36.226]             `[[` <- base::`[[`
[11:02:36.226]             `+` <- base::`+`
[11:02:36.226]             `<<-` <- base::`<<-`
[11:02:36.226]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:36.226]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:36.226]                   3L)]
[11:02:36.226]             }
[11:02:36.226]             function(cond) {
[11:02:36.226]                 is_error <- inherits(cond, "error")
[11:02:36.226]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:36.226]                   NULL)
[11:02:36.226]                 if (is_error) {
[11:02:36.226]                   sessionInformation <- function() {
[11:02:36.226]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:36.226]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:36.226]                       search = base::search(), system = base::Sys.info())
[11:02:36.226]                   }
[11:02:36.226]                   ...future.conditions[[length(...future.conditions) + 
[11:02:36.226]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:36.226]                     cond$call), session = sessionInformation(), 
[11:02:36.226]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:36.226]                   signalCondition(cond)
[11:02:36.226]                 }
[11:02:36.226]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:36.226]                 "immediateCondition"))) {
[11:02:36.226]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:36.226]                   ...future.conditions[[length(...future.conditions) + 
[11:02:36.226]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:36.226]                   if (TRUE && !signal) {
[11:02:36.226]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:36.226]                     {
[11:02:36.226]                       inherits <- base::inherits
[11:02:36.226]                       invokeRestart <- base::invokeRestart
[11:02:36.226]                       is.null <- base::is.null
[11:02:36.226]                       muffled <- FALSE
[11:02:36.226]                       if (inherits(cond, "message")) {
[11:02:36.226]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:36.226]                         if (muffled) 
[11:02:36.226]                           invokeRestart("muffleMessage")
[11:02:36.226]                       }
[11:02:36.226]                       else if (inherits(cond, "warning")) {
[11:02:36.226]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:36.226]                         if (muffled) 
[11:02:36.226]                           invokeRestart("muffleWarning")
[11:02:36.226]                       }
[11:02:36.226]                       else if (inherits(cond, "condition")) {
[11:02:36.226]                         if (!is.null(pattern)) {
[11:02:36.226]                           computeRestarts <- base::computeRestarts
[11:02:36.226]                           grepl <- base::grepl
[11:02:36.226]                           restarts <- computeRestarts(cond)
[11:02:36.226]                           for (restart in restarts) {
[11:02:36.226]                             name <- restart$name
[11:02:36.226]                             if (is.null(name)) 
[11:02:36.226]                               next
[11:02:36.226]                             if (!grepl(pattern, name)) 
[11:02:36.226]                               next
[11:02:36.226]                             invokeRestart(restart)
[11:02:36.226]                             muffled <- TRUE
[11:02:36.226]                             break
[11:02:36.226]                           }
[11:02:36.226]                         }
[11:02:36.226]                       }
[11:02:36.226]                       invisible(muffled)
[11:02:36.226]                     }
[11:02:36.226]                     muffleCondition(cond, pattern = "^muffle")
[11:02:36.226]                   }
[11:02:36.226]                 }
[11:02:36.226]                 else {
[11:02:36.226]                   if (TRUE) {
[11:02:36.226]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:36.226]                     {
[11:02:36.226]                       inherits <- base::inherits
[11:02:36.226]                       invokeRestart <- base::invokeRestart
[11:02:36.226]                       is.null <- base::is.null
[11:02:36.226]                       muffled <- FALSE
[11:02:36.226]                       if (inherits(cond, "message")) {
[11:02:36.226]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:36.226]                         if (muffled) 
[11:02:36.226]                           invokeRestart("muffleMessage")
[11:02:36.226]                       }
[11:02:36.226]                       else if (inherits(cond, "warning")) {
[11:02:36.226]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:36.226]                         if (muffled) 
[11:02:36.226]                           invokeRestart("muffleWarning")
[11:02:36.226]                       }
[11:02:36.226]                       else if (inherits(cond, "condition")) {
[11:02:36.226]                         if (!is.null(pattern)) {
[11:02:36.226]                           computeRestarts <- base::computeRestarts
[11:02:36.226]                           grepl <- base::grepl
[11:02:36.226]                           restarts <- computeRestarts(cond)
[11:02:36.226]                           for (restart in restarts) {
[11:02:36.226]                             name <- restart$name
[11:02:36.226]                             if (is.null(name)) 
[11:02:36.226]                               next
[11:02:36.226]                             if (!grepl(pattern, name)) 
[11:02:36.226]                               next
[11:02:36.226]                             invokeRestart(restart)
[11:02:36.226]                             muffled <- TRUE
[11:02:36.226]                             break
[11:02:36.226]                           }
[11:02:36.226]                         }
[11:02:36.226]                       }
[11:02:36.226]                       invisible(muffled)
[11:02:36.226]                     }
[11:02:36.226]                     muffleCondition(cond, pattern = "^muffle")
[11:02:36.226]                   }
[11:02:36.226]                 }
[11:02:36.226]             }
[11:02:36.226]         }))
[11:02:36.226]     }, error = function(ex) {
[11:02:36.226]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:36.226]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:36.226]                 ...future.rng), started = ...future.startTime, 
[11:02:36.226]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:36.226]             version = "1.8"), class = "FutureResult")
[11:02:36.226]     }, finally = {
[11:02:36.226]         if (!identical(...future.workdir, getwd())) 
[11:02:36.226]             setwd(...future.workdir)
[11:02:36.226]         {
[11:02:36.226]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:36.226]                 ...future.oldOptions$nwarnings <- NULL
[11:02:36.226]             }
[11:02:36.226]             base::options(...future.oldOptions)
[11:02:36.226]             if (.Platform$OS.type == "windows") {
[11:02:36.226]                 old_names <- names(...future.oldEnvVars)
[11:02:36.226]                 envs <- base::Sys.getenv()
[11:02:36.226]                 names <- names(envs)
[11:02:36.226]                 common <- intersect(names, old_names)
[11:02:36.226]                 added <- setdiff(names, old_names)
[11:02:36.226]                 removed <- setdiff(old_names, names)
[11:02:36.226]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:36.226]                   envs[common]]
[11:02:36.226]                 NAMES <- toupper(changed)
[11:02:36.226]                 args <- list()
[11:02:36.226]                 for (kk in seq_along(NAMES)) {
[11:02:36.226]                   name <- changed[[kk]]
[11:02:36.226]                   NAME <- NAMES[[kk]]
[11:02:36.226]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:36.226]                     next
[11:02:36.226]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:36.226]                 }
[11:02:36.226]                 NAMES <- toupper(added)
[11:02:36.226]                 for (kk in seq_along(NAMES)) {
[11:02:36.226]                   name <- added[[kk]]
[11:02:36.226]                   NAME <- NAMES[[kk]]
[11:02:36.226]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:36.226]                     next
[11:02:36.226]                   args[[name]] <- ""
[11:02:36.226]                 }
[11:02:36.226]                 NAMES <- toupper(removed)
[11:02:36.226]                 for (kk in seq_along(NAMES)) {
[11:02:36.226]                   name <- removed[[kk]]
[11:02:36.226]                   NAME <- NAMES[[kk]]
[11:02:36.226]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:36.226]                     next
[11:02:36.226]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:36.226]                 }
[11:02:36.226]                 if (length(args) > 0) 
[11:02:36.226]                   base::do.call(base::Sys.setenv, args = args)
[11:02:36.226]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:36.226]             }
[11:02:36.226]             else {
[11:02:36.226]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:36.226]             }
[11:02:36.226]             {
[11:02:36.226]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:36.226]                   0L) {
[11:02:36.226]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:36.226]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:36.226]                   base::options(opts)
[11:02:36.226]                 }
[11:02:36.226]                 {
[11:02:36.226]                   {
[11:02:36.226]                     NULL
[11:02:36.226]                     RNGkind("Mersenne-Twister")
[11:02:36.226]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:36.226]                       inherits = FALSE)
[11:02:36.226]                   }
[11:02:36.226]                   options(future.plan = NULL)
[11:02:36.226]                   if (is.na(NA_character_)) 
[11:02:36.226]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:36.226]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:36.226]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:36.226]                     .init = FALSE)
[11:02:36.226]                 }
[11:02:36.226]             }
[11:02:36.226]         }
[11:02:36.226]     })
[11:02:36.226]     if (TRUE) {
[11:02:36.226]         base::sink(type = "output", split = FALSE)
[11:02:36.226]         if (TRUE) {
[11:02:36.226]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:36.226]         }
[11:02:36.226]         else {
[11:02:36.226]             ...future.result["stdout"] <- base::list(NULL)
[11:02:36.226]         }
[11:02:36.226]         base::close(...future.stdout)
[11:02:36.226]         ...future.stdout <- NULL
[11:02:36.226]     }
[11:02:36.226]     ...future.result$conditions <- ...future.conditions
[11:02:36.226]     ...future.result$finished <- base::Sys.time()
[11:02:36.226]     ...future.result
[11:02:36.226] }
[11:02:36.228] plan(): Setting new future strategy stack:
[11:02:36.228] List of future strategies:
[11:02:36.228] 1. sequential:
[11:02:36.228]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:36.228]    - tweaked: FALSE
[11:02:36.228]    - call: NULL
[11:02:36.229] plan(): nbrOfWorkers() = 1
[11:02:36.229] plan(): Setting new future strategy stack:
[11:02:36.229] List of future strategies:
[11:02:36.229] 1. sequential:
[11:02:36.229]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:36.229]    - tweaked: FALSE
[11:02:36.229]    - call: plan(strategy)
[11:02:36.230] plan(): nbrOfWorkers() = 1
[11:02:36.230] SequentialFuture started (and completed)
[11:02:36.230] - Launch lazy future ... done
[11:02:36.230] run() for ‘SequentialFuture’ ... done
[11:02:36.230] resolved() for ‘SequentialFuture’ ...
[11:02:36.230] - state: ‘finished’
[11:02:36.230] - run: TRUE
[11:02:36.230] - result: ‘FutureResult’
[11:02:36.230] resolved() for ‘SequentialFuture’ ... done
[11:02:36.231] Future #1
[11:02:36.231]  length: 2 (resolved future 1)
[11:02:36.231] resolved() for ‘SequentialFuture’ ...
[11:02:36.231] - state: ‘finished’
[11:02:36.231] - run: TRUE
[11:02:36.231] - result: ‘FutureResult’
[11:02:36.231] resolved() for ‘SequentialFuture’ ... done
[11:02:36.231] Future #2
[11:02:36.231]  length: 1 (resolved future 2)
[11:02:36.231]  length: 0 (resolved future 3)
[11:02:36.231] resolve() on list ... DONE
[11:02:36.231] resolved() for ‘SequentialFuture’ ...
[11:02:36.232] - state: ‘finished’
[11:02:36.232] - run: TRUE
[11:02:36.232] - result: ‘FutureResult’
[11:02:36.232] resolved() for ‘SequentialFuture’ ... done
[11:02:36.232] resolved() for ‘SequentialFuture’ ...
[11:02:36.232] - state: ‘finished’
[11:02:36.232] - run: TRUE
[11:02:36.232] - result: ‘FutureResult’
[11:02:36.232] resolved() for ‘SequentialFuture’ ... done
[11:02:36.232] getGlobalsAndPackages() ...
[11:02:36.232] Searching for globals...
[11:02:36.233] 
[11:02:36.233] Searching for globals ... DONE
[11:02:36.233] - globals: [0] <none>
[11:02:36.233] getGlobalsAndPackages() ... DONE
[11:02:36.233] getGlobalsAndPackages() ...
[11:02:36.233] Searching for globals...
[11:02:36.233] 
[11:02:36.234] Searching for globals ... DONE
[11:02:36.234] - globals: [0] <none>
[11:02:36.234] getGlobalsAndPackages() ... DONE
[11:02:36.234] resolve() on list ...
[11:02:36.234]  recursive: 0
[11:02:36.234]  length: 3
[11:02:36.234]  elements: ‘a’, ‘b’, ‘’
[11:02:36.234] run() for ‘Future’ ...
[11:02:36.234] - state: ‘created’
[11:02:36.234] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:02:36.235] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:36.235] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:36.235]   - Field: ‘label’
[11:02:36.235]   - Field: ‘local’
[11:02:36.235]   - Field: ‘owner’
[11:02:36.235]   - Field: ‘envir’
[11:02:36.235]   - Field: ‘packages’
[11:02:36.235]   - Field: ‘gc’
[11:02:36.235]   - Field: ‘conditions’
[11:02:36.235]   - Field: ‘expr’
[11:02:36.236]   - Field: ‘uuid’
[11:02:36.236]   - Field: ‘seed’
[11:02:36.236]   - Field: ‘version’
[11:02:36.236]   - Field: ‘result’
[11:02:36.236]   - Field: ‘asynchronous’
[11:02:36.236]   - Field: ‘calls’
[11:02:36.236]   - Field: ‘globals’
[11:02:36.236]   - Field: ‘stdout’
[11:02:36.236]   - Field: ‘earlySignal’
[11:02:36.236]   - Field: ‘lazy’
[11:02:36.236]   - Field: ‘state’
[11:02:36.236] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:36.236] - Launch lazy future ...
[11:02:36.237] Packages needed by the future expression (n = 0): <none>
[11:02:36.237] Packages needed by future strategies (n = 0): <none>
[11:02:36.237] {
[11:02:36.237]     {
[11:02:36.237]         {
[11:02:36.237]             ...future.startTime <- base::Sys.time()
[11:02:36.237]             {
[11:02:36.237]                 {
[11:02:36.237]                   {
[11:02:36.237]                     base::local({
[11:02:36.237]                       has_future <- base::requireNamespace("future", 
[11:02:36.237]                         quietly = TRUE)
[11:02:36.237]                       if (has_future) {
[11:02:36.237]                         ns <- base::getNamespace("future")
[11:02:36.237]                         version <- ns[[".package"]][["version"]]
[11:02:36.237]                         if (is.null(version)) 
[11:02:36.237]                           version <- utils::packageVersion("future")
[11:02:36.237]                       }
[11:02:36.237]                       else {
[11:02:36.237]                         version <- NULL
[11:02:36.237]                       }
[11:02:36.237]                       if (!has_future || version < "1.8.0") {
[11:02:36.237]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:36.237]                           "", base::R.version$version.string), 
[11:02:36.237]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:36.237]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:36.237]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:36.237]                             "release", "version")], collapse = " "), 
[11:02:36.237]                           hostname = base::Sys.info()[["nodename"]])
[11:02:36.237]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:36.237]                           info)
[11:02:36.237]                         info <- base::paste(info, collapse = "; ")
[11:02:36.237]                         if (!has_future) {
[11:02:36.237]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:36.237]                             info)
[11:02:36.237]                         }
[11:02:36.237]                         else {
[11:02:36.237]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:36.237]                             info, version)
[11:02:36.237]                         }
[11:02:36.237]                         base::stop(msg)
[11:02:36.237]                       }
[11:02:36.237]                     })
[11:02:36.237]                   }
[11:02:36.237]                   ...future.strategy.old <- future::plan("list")
[11:02:36.237]                   options(future.plan = NULL)
[11:02:36.237]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:36.237]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:36.237]                 }
[11:02:36.237]                 ...future.workdir <- getwd()
[11:02:36.237]             }
[11:02:36.237]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:36.237]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:36.237]         }
[11:02:36.237]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:36.237]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:36.237]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:36.237]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:36.237]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:36.237]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:36.237]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:36.237]             base::names(...future.oldOptions))
[11:02:36.237]     }
[11:02:36.237]     if (FALSE) {
[11:02:36.237]     }
[11:02:36.237]     else {
[11:02:36.237]         if (TRUE) {
[11:02:36.237]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:36.237]                 open = "w")
[11:02:36.237]         }
[11:02:36.237]         else {
[11:02:36.237]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:36.237]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:36.237]         }
[11:02:36.237]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:36.237]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:36.237]             base::sink(type = "output", split = FALSE)
[11:02:36.237]             base::close(...future.stdout)
[11:02:36.237]         }, add = TRUE)
[11:02:36.237]     }
[11:02:36.237]     ...future.frame <- base::sys.nframe()
[11:02:36.237]     ...future.conditions <- base::list()
[11:02:36.237]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:36.237]     if (FALSE) {
[11:02:36.237]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:36.237]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:36.237]     }
[11:02:36.237]     ...future.result <- base::tryCatch({
[11:02:36.237]         base::withCallingHandlers({
[11:02:36.237]             ...future.value <- base::withVisible(base::local(1))
[11:02:36.237]             future::FutureResult(value = ...future.value$value, 
[11:02:36.237]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:36.237]                   ...future.rng), globalenv = if (FALSE) 
[11:02:36.237]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:36.237]                     ...future.globalenv.names))
[11:02:36.237]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:36.237]         }, condition = base::local({
[11:02:36.237]             c <- base::c
[11:02:36.237]             inherits <- base::inherits
[11:02:36.237]             invokeRestart <- base::invokeRestart
[11:02:36.237]             length <- base::length
[11:02:36.237]             list <- base::list
[11:02:36.237]             seq.int <- base::seq.int
[11:02:36.237]             signalCondition <- base::signalCondition
[11:02:36.237]             sys.calls <- base::sys.calls
[11:02:36.237]             `[[` <- base::`[[`
[11:02:36.237]             `+` <- base::`+`
[11:02:36.237]             `<<-` <- base::`<<-`
[11:02:36.237]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:36.237]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:36.237]                   3L)]
[11:02:36.237]             }
[11:02:36.237]             function(cond) {
[11:02:36.237]                 is_error <- inherits(cond, "error")
[11:02:36.237]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:36.237]                   NULL)
[11:02:36.237]                 if (is_error) {
[11:02:36.237]                   sessionInformation <- function() {
[11:02:36.237]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:36.237]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:36.237]                       search = base::search(), system = base::Sys.info())
[11:02:36.237]                   }
[11:02:36.237]                   ...future.conditions[[length(...future.conditions) + 
[11:02:36.237]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:36.237]                     cond$call), session = sessionInformation(), 
[11:02:36.237]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:36.237]                   signalCondition(cond)
[11:02:36.237]                 }
[11:02:36.237]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:36.237]                 "immediateCondition"))) {
[11:02:36.237]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:36.237]                   ...future.conditions[[length(...future.conditions) + 
[11:02:36.237]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:36.237]                   if (TRUE && !signal) {
[11:02:36.237]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:36.237]                     {
[11:02:36.237]                       inherits <- base::inherits
[11:02:36.237]                       invokeRestart <- base::invokeRestart
[11:02:36.237]                       is.null <- base::is.null
[11:02:36.237]                       muffled <- FALSE
[11:02:36.237]                       if (inherits(cond, "message")) {
[11:02:36.237]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:36.237]                         if (muffled) 
[11:02:36.237]                           invokeRestart("muffleMessage")
[11:02:36.237]                       }
[11:02:36.237]                       else if (inherits(cond, "warning")) {
[11:02:36.237]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:36.237]                         if (muffled) 
[11:02:36.237]                           invokeRestart("muffleWarning")
[11:02:36.237]                       }
[11:02:36.237]                       else if (inherits(cond, "condition")) {
[11:02:36.237]                         if (!is.null(pattern)) {
[11:02:36.237]                           computeRestarts <- base::computeRestarts
[11:02:36.237]                           grepl <- base::grepl
[11:02:36.237]                           restarts <- computeRestarts(cond)
[11:02:36.237]                           for (restart in restarts) {
[11:02:36.237]                             name <- restart$name
[11:02:36.237]                             if (is.null(name)) 
[11:02:36.237]                               next
[11:02:36.237]                             if (!grepl(pattern, name)) 
[11:02:36.237]                               next
[11:02:36.237]                             invokeRestart(restart)
[11:02:36.237]                             muffled <- TRUE
[11:02:36.237]                             break
[11:02:36.237]                           }
[11:02:36.237]                         }
[11:02:36.237]                       }
[11:02:36.237]                       invisible(muffled)
[11:02:36.237]                     }
[11:02:36.237]                     muffleCondition(cond, pattern = "^muffle")
[11:02:36.237]                   }
[11:02:36.237]                 }
[11:02:36.237]                 else {
[11:02:36.237]                   if (TRUE) {
[11:02:36.237]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:36.237]                     {
[11:02:36.237]                       inherits <- base::inherits
[11:02:36.237]                       invokeRestart <- base::invokeRestart
[11:02:36.237]                       is.null <- base::is.null
[11:02:36.237]                       muffled <- FALSE
[11:02:36.237]                       if (inherits(cond, "message")) {
[11:02:36.237]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:36.237]                         if (muffled) 
[11:02:36.237]                           invokeRestart("muffleMessage")
[11:02:36.237]                       }
[11:02:36.237]                       else if (inherits(cond, "warning")) {
[11:02:36.237]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:36.237]                         if (muffled) 
[11:02:36.237]                           invokeRestart("muffleWarning")
[11:02:36.237]                       }
[11:02:36.237]                       else if (inherits(cond, "condition")) {
[11:02:36.237]                         if (!is.null(pattern)) {
[11:02:36.237]                           computeRestarts <- base::computeRestarts
[11:02:36.237]                           grepl <- base::grepl
[11:02:36.237]                           restarts <- computeRestarts(cond)
[11:02:36.237]                           for (restart in restarts) {
[11:02:36.237]                             name <- restart$name
[11:02:36.237]                             if (is.null(name)) 
[11:02:36.237]                               next
[11:02:36.237]                             if (!grepl(pattern, name)) 
[11:02:36.237]                               next
[11:02:36.237]                             invokeRestart(restart)
[11:02:36.237]                             muffled <- TRUE
[11:02:36.237]                             break
[11:02:36.237]                           }
[11:02:36.237]                         }
[11:02:36.237]                       }
[11:02:36.237]                       invisible(muffled)
[11:02:36.237]                     }
[11:02:36.237]                     muffleCondition(cond, pattern = "^muffle")
[11:02:36.237]                   }
[11:02:36.237]                 }
[11:02:36.237]             }
[11:02:36.237]         }))
[11:02:36.237]     }, error = function(ex) {
[11:02:36.237]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:36.237]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:36.237]                 ...future.rng), started = ...future.startTime, 
[11:02:36.237]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:36.237]             version = "1.8"), class = "FutureResult")
[11:02:36.237]     }, finally = {
[11:02:36.237]         if (!identical(...future.workdir, getwd())) 
[11:02:36.237]             setwd(...future.workdir)
[11:02:36.237]         {
[11:02:36.237]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:36.237]                 ...future.oldOptions$nwarnings <- NULL
[11:02:36.237]             }
[11:02:36.237]             base::options(...future.oldOptions)
[11:02:36.237]             if (.Platform$OS.type == "windows") {
[11:02:36.237]                 old_names <- names(...future.oldEnvVars)
[11:02:36.237]                 envs <- base::Sys.getenv()
[11:02:36.237]                 names <- names(envs)
[11:02:36.237]                 common <- intersect(names, old_names)
[11:02:36.237]                 added <- setdiff(names, old_names)
[11:02:36.237]                 removed <- setdiff(old_names, names)
[11:02:36.237]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:36.237]                   envs[common]]
[11:02:36.237]                 NAMES <- toupper(changed)
[11:02:36.237]                 args <- list()
[11:02:36.237]                 for (kk in seq_along(NAMES)) {
[11:02:36.237]                   name <- changed[[kk]]
[11:02:36.237]                   NAME <- NAMES[[kk]]
[11:02:36.237]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:36.237]                     next
[11:02:36.237]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:36.237]                 }
[11:02:36.237]                 NAMES <- toupper(added)
[11:02:36.237]                 for (kk in seq_along(NAMES)) {
[11:02:36.237]                   name <- added[[kk]]
[11:02:36.237]                   NAME <- NAMES[[kk]]
[11:02:36.237]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:36.237]                     next
[11:02:36.237]                   args[[name]] <- ""
[11:02:36.237]                 }
[11:02:36.237]                 NAMES <- toupper(removed)
[11:02:36.237]                 for (kk in seq_along(NAMES)) {
[11:02:36.237]                   name <- removed[[kk]]
[11:02:36.237]                   NAME <- NAMES[[kk]]
[11:02:36.237]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:36.237]                     next
[11:02:36.237]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:36.237]                 }
[11:02:36.237]                 if (length(args) > 0) 
[11:02:36.237]                   base::do.call(base::Sys.setenv, args = args)
[11:02:36.237]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:36.237]             }
[11:02:36.237]             else {
[11:02:36.237]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:36.237]             }
[11:02:36.237]             {
[11:02:36.237]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:36.237]                   0L) {
[11:02:36.237]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:36.237]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:36.237]                   base::options(opts)
[11:02:36.237]                 }
[11:02:36.237]                 {
[11:02:36.237]                   {
[11:02:36.237]                     NULL
[11:02:36.237]                     RNGkind("Mersenne-Twister")
[11:02:36.237]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:36.237]                       inherits = FALSE)
[11:02:36.237]                   }
[11:02:36.237]                   options(future.plan = NULL)
[11:02:36.237]                   if (is.na(NA_character_)) 
[11:02:36.237]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:36.237]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:36.237]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:36.237]                     .init = FALSE)
[11:02:36.237]                 }
[11:02:36.237]             }
[11:02:36.237]         }
[11:02:36.237]     })
[11:02:36.237]     if (TRUE) {
[11:02:36.237]         base::sink(type = "output", split = FALSE)
[11:02:36.237]         if (TRUE) {
[11:02:36.237]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:36.237]         }
[11:02:36.237]         else {
[11:02:36.237]             ...future.result["stdout"] <- base::list(NULL)
[11:02:36.237]         }
[11:02:36.237]         base::close(...future.stdout)
[11:02:36.237]         ...future.stdout <- NULL
[11:02:36.237]     }
[11:02:36.237]     ...future.result$conditions <- ...future.conditions
[11:02:36.237]     ...future.result$finished <- base::Sys.time()
[11:02:36.237]     ...future.result
[11:02:36.237] }
[11:02:36.239] plan(): Setting new future strategy stack:
[11:02:36.239] List of future strategies:
[11:02:36.239] 1. sequential:
[11:02:36.239]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:36.239]    - tweaked: FALSE
[11:02:36.239]    - call: NULL
[11:02:36.239] plan(): nbrOfWorkers() = 1
[11:02:36.240] plan(): Setting new future strategy stack:
[11:02:36.240] List of future strategies:
[11:02:36.240] 1. sequential:
[11:02:36.240]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:36.240]    - tweaked: FALSE
[11:02:36.240]    - call: plan(strategy)
[11:02:36.241] plan(): nbrOfWorkers() = 1
[11:02:36.241] SequentialFuture started (and completed)
[11:02:36.241] - Launch lazy future ... done
[11:02:36.241] run() for ‘SequentialFuture’ ... done
[11:02:36.241] resolved() for ‘SequentialFuture’ ...
[11:02:36.241] - state: ‘finished’
[11:02:36.241] - run: TRUE
[11:02:36.241] - result: ‘FutureResult’
[11:02:36.241] resolved() for ‘SequentialFuture’ ... done
[11:02:36.241] Future #1
[11:02:36.242]  length: 2 (resolved future 1)
[11:02:36.242] run() for ‘Future’ ...
[11:02:36.242] - state: ‘created’
[11:02:36.242] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:02:36.242] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:36.242] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:36.242]   - Field: ‘label’
[11:02:36.242]   - Field: ‘local’
[11:02:36.243]   - Field: ‘owner’
[11:02:36.243]   - Field: ‘envir’
[11:02:36.243]   - Field: ‘packages’
[11:02:36.243]   - Field: ‘gc’
[11:02:36.243]   - Field: ‘conditions’
[11:02:36.243]   - Field: ‘expr’
[11:02:36.243]   - Field: ‘uuid’
[11:02:36.243]   - Field: ‘seed’
[11:02:36.243]   - Field: ‘version’
[11:02:36.243]   - Field: ‘result’
[11:02:36.243]   - Field: ‘asynchronous’
[11:02:36.243]   - Field: ‘calls’
[11:02:36.243]   - Field: ‘globals’
[11:02:36.244]   - Field: ‘stdout’
[11:02:36.244]   - Field: ‘earlySignal’
[11:02:36.244]   - Field: ‘lazy’
[11:02:36.244]   - Field: ‘state’
[11:02:36.244] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:36.244] - Launch lazy future ...
[11:02:36.244] Packages needed by the future expression (n = 0): <none>
[11:02:36.244] Packages needed by future strategies (n = 0): <none>
[11:02:36.245] {
[11:02:36.245]     {
[11:02:36.245]         {
[11:02:36.245]             ...future.startTime <- base::Sys.time()
[11:02:36.245]             {
[11:02:36.245]                 {
[11:02:36.245]                   {
[11:02:36.245]                     base::local({
[11:02:36.245]                       has_future <- base::requireNamespace("future", 
[11:02:36.245]                         quietly = TRUE)
[11:02:36.245]                       if (has_future) {
[11:02:36.245]                         ns <- base::getNamespace("future")
[11:02:36.245]                         version <- ns[[".package"]][["version"]]
[11:02:36.245]                         if (is.null(version)) 
[11:02:36.245]                           version <- utils::packageVersion("future")
[11:02:36.245]                       }
[11:02:36.245]                       else {
[11:02:36.245]                         version <- NULL
[11:02:36.245]                       }
[11:02:36.245]                       if (!has_future || version < "1.8.0") {
[11:02:36.245]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:36.245]                           "", base::R.version$version.string), 
[11:02:36.245]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:36.245]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:36.245]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:36.245]                             "release", "version")], collapse = " "), 
[11:02:36.245]                           hostname = base::Sys.info()[["nodename"]])
[11:02:36.245]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:36.245]                           info)
[11:02:36.245]                         info <- base::paste(info, collapse = "; ")
[11:02:36.245]                         if (!has_future) {
[11:02:36.245]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:36.245]                             info)
[11:02:36.245]                         }
[11:02:36.245]                         else {
[11:02:36.245]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:36.245]                             info, version)
[11:02:36.245]                         }
[11:02:36.245]                         base::stop(msg)
[11:02:36.245]                       }
[11:02:36.245]                     })
[11:02:36.245]                   }
[11:02:36.245]                   ...future.strategy.old <- future::plan("list")
[11:02:36.245]                   options(future.plan = NULL)
[11:02:36.245]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:36.245]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:36.245]                 }
[11:02:36.245]                 ...future.workdir <- getwd()
[11:02:36.245]             }
[11:02:36.245]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:36.245]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:36.245]         }
[11:02:36.245]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:36.245]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:36.245]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:36.245]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:36.245]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:36.245]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:36.245]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:36.245]             base::names(...future.oldOptions))
[11:02:36.245]     }
[11:02:36.245]     if (FALSE) {
[11:02:36.245]     }
[11:02:36.245]     else {
[11:02:36.245]         if (TRUE) {
[11:02:36.245]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:36.245]                 open = "w")
[11:02:36.245]         }
[11:02:36.245]         else {
[11:02:36.245]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:36.245]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:36.245]         }
[11:02:36.245]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:36.245]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:36.245]             base::sink(type = "output", split = FALSE)
[11:02:36.245]             base::close(...future.stdout)
[11:02:36.245]         }, add = TRUE)
[11:02:36.245]     }
[11:02:36.245]     ...future.frame <- base::sys.nframe()
[11:02:36.245]     ...future.conditions <- base::list()
[11:02:36.245]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:36.245]     if (FALSE) {
[11:02:36.245]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:36.245]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:36.245]     }
[11:02:36.245]     ...future.result <- base::tryCatch({
[11:02:36.245]         base::withCallingHandlers({
[11:02:36.245]             ...future.value <- base::withVisible(base::local(2))
[11:02:36.245]             future::FutureResult(value = ...future.value$value, 
[11:02:36.245]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:36.245]                   ...future.rng), globalenv = if (FALSE) 
[11:02:36.245]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:36.245]                     ...future.globalenv.names))
[11:02:36.245]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:36.245]         }, condition = base::local({
[11:02:36.245]             c <- base::c
[11:02:36.245]             inherits <- base::inherits
[11:02:36.245]             invokeRestart <- base::invokeRestart
[11:02:36.245]             length <- base::length
[11:02:36.245]             list <- base::list
[11:02:36.245]             seq.int <- base::seq.int
[11:02:36.245]             signalCondition <- base::signalCondition
[11:02:36.245]             sys.calls <- base::sys.calls
[11:02:36.245]             `[[` <- base::`[[`
[11:02:36.245]             `+` <- base::`+`
[11:02:36.245]             `<<-` <- base::`<<-`
[11:02:36.245]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:36.245]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:36.245]                   3L)]
[11:02:36.245]             }
[11:02:36.245]             function(cond) {
[11:02:36.245]                 is_error <- inherits(cond, "error")
[11:02:36.245]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:36.245]                   NULL)
[11:02:36.245]                 if (is_error) {
[11:02:36.245]                   sessionInformation <- function() {
[11:02:36.245]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:36.245]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:36.245]                       search = base::search(), system = base::Sys.info())
[11:02:36.245]                   }
[11:02:36.245]                   ...future.conditions[[length(...future.conditions) + 
[11:02:36.245]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:36.245]                     cond$call), session = sessionInformation(), 
[11:02:36.245]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:36.245]                   signalCondition(cond)
[11:02:36.245]                 }
[11:02:36.245]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:36.245]                 "immediateCondition"))) {
[11:02:36.245]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:36.245]                   ...future.conditions[[length(...future.conditions) + 
[11:02:36.245]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:36.245]                   if (TRUE && !signal) {
[11:02:36.245]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:36.245]                     {
[11:02:36.245]                       inherits <- base::inherits
[11:02:36.245]                       invokeRestart <- base::invokeRestart
[11:02:36.245]                       is.null <- base::is.null
[11:02:36.245]                       muffled <- FALSE
[11:02:36.245]                       if (inherits(cond, "message")) {
[11:02:36.245]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:36.245]                         if (muffled) 
[11:02:36.245]                           invokeRestart("muffleMessage")
[11:02:36.245]                       }
[11:02:36.245]                       else if (inherits(cond, "warning")) {
[11:02:36.245]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:36.245]                         if (muffled) 
[11:02:36.245]                           invokeRestart("muffleWarning")
[11:02:36.245]                       }
[11:02:36.245]                       else if (inherits(cond, "condition")) {
[11:02:36.245]                         if (!is.null(pattern)) {
[11:02:36.245]                           computeRestarts <- base::computeRestarts
[11:02:36.245]                           grepl <- base::grepl
[11:02:36.245]                           restarts <- computeRestarts(cond)
[11:02:36.245]                           for (restart in restarts) {
[11:02:36.245]                             name <- restart$name
[11:02:36.245]                             if (is.null(name)) 
[11:02:36.245]                               next
[11:02:36.245]                             if (!grepl(pattern, name)) 
[11:02:36.245]                               next
[11:02:36.245]                             invokeRestart(restart)
[11:02:36.245]                             muffled <- TRUE
[11:02:36.245]                             break
[11:02:36.245]                           }
[11:02:36.245]                         }
[11:02:36.245]                       }
[11:02:36.245]                       invisible(muffled)
[11:02:36.245]                     }
[11:02:36.245]                     muffleCondition(cond, pattern = "^muffle")
[11:02:36.245]                   }
[11:02:36.245]                 }
[11:02:36.245]                 else {
[11:02:36.245]                   if (TRUE) {
[11:02:36.245]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:36.245]                     {
[11:02:36.245]                       inherits <- base::inherits
[11:02:36.245]                       invokeRestart <- base::invokeRestart
[11:02:36.245]                       is.null <- base::is.null
[11:02:36.245]                       muffled <- FALSE
[11:02:36.245]                       if (inherits(cond, "message")) {
[11:02:36.245]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:36.245]                         if (muffled) 
[11:02:36.245]                           invokeRestart("muffleMessage")
[11:02:36.245]                       }
[11:02:36.245]                       else if (inherits(cond, "warning")) {
[11:02:36.245]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:36.245]                         if (muffled) 
[11:02:36.245]                           invokeRestart("muffleWarning")
[11:02:36.245]                       }
[11:02:36.245]                       else if (inherits(cond, "condition")) {
[11:02:36.245]                         if (!is.null(pattern)) {
[11:02:36.245]                           computeRestarts <- base::computeRestarts
[11:02:36.245]                           grepl <- base::grepl
[11:02:36.245]                           restarts <- computeRestarts(cond)
[11:02:36.245]                           for (restart in restarts) {
[11:02:36.245]                             name <- restart$name
[11:02:36.245]                             if (is.null(name)) 
[11:02:36.245]                               next
[11:02:36.245]                             if (!grepl(pattern, name)) 
[11:02:36.245]                               next
[11:02:36.245]                             invokeRestart(restart)
[11:02:36.245]                             muffled <- TRUE
[11:02:36.245]                             break
[11:02:36.245]                           }
[11:02:36.245]                         }
[11:02:36.245]                       }
[11:02:36.245]                       invisible(muffled)
[11:02:36.245]                     }
[11:02:36.245]                     muffleCondition(cond, pattern = "^muffle")
[11:02:36.245]                   }
[11:02:36.245]                 }
[11:02:36.245]             }
[11:02:36.245]         }))
[11:02:36.245]     }, error = function(ex) {
[11:02:36.245]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:36.245]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:36.245]                 ...future.rng), started = ...future.startTime, 
[11:02:36.245]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:36.245]             version = "1.8"), class = "FutureResult")
[11:02:36.245]     }, finally = {
[11:02:36.245]         if (!identical(...future.workdir, getwd())) 
[11:02:36.245]             setwd(...future.workdir)
[11:02:36.245]         {
[11:02:36.245]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:36.245]                 ...future.oldOptions$nwarnings <- NULL
[11:02:36.245]             }
[11:02:36.245]             base::options(...future.oldOptions)
[11:02:36.245]             if (.Platform$OS.type == "windows") {
[11:02:36.245]                 old_names <- names(...future.oldEnvVars)
[11:02:36.245]                 envs <- base::Sys.getenv()
[11:02:36.245]                 names <- names(envs)
[11:02:36.245]                 common <- intersect(names, old_names)
[11:02:36.245]                 added <- setdiff(names, old_names)
[11:02:36.245]                 removed <- setdiff(old_names, names)
[11:02:36.245]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:36.245]                   envs[common]]
[11:02:36.245]                 NAMES <- toupper(changed)
[11:02:36.245]                 args <- list()
[11:02:36.245]                 for (kk in seq_along(NAMES)) {
[11:02:36.245]                   name <- changed[[kk]]
[11:02:36.245]                   NAME <- NAMES[[kk]]
[11:02:36.245]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:36.245]                     next
[11:02:36.245]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:36.245]                 }
[11:02:36.245]                 NAMES <- toupper(added)
[11:02:36.245]                 for (kk in seq_along(NAMES)) {
[11:02:36.245]                   name <- added[[kk]]
[11:02:36.245]                   NAME <- NAMES[[kk]]
[11:02:36.245]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:36.245]                     next
[11:02:36.245]                   args[[name]] <- ""
[11:02:36.245]                 }
[11:02:36.245]                 NAMES <- toupper(removed)
[11:02:36.245]                 for (kk in seq_along(NAMES)) {
[11:02:36.245]                   name <- removed[[kk]]
[11:02:36.245]                   NAME <- NAMES[[kk]]
[11:02:36.245]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:36.245]                     next
[11:02:36.245]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:36.245]                 }
[11:02:36.245]                 if (length(args) > 0) 
[11:02:36.245]                   base::do.call(base::Sys.setenv, args = args)
[11:02:36.245]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:36.245]             }
[11:02:36.245]             else {
[11:02:36.245]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:36.245]             }
[11:02:36.245]             {
[11:02:36.245]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:36.245]                   0L) {
[11:02:36.245]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:36.245]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:36.245]                   base::options(opts)
[11:02:36.245]                 }
[11:02:36.245]                 {
[11:02:36.245]                   {
[11:02:36.245]                     NULL
[11:02:36.245]                     RNGkind("Mersenne-Twister")
[11:02:36.245]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:36.245]                       inherits = FALSE)
[11:02:36.245]                   }
[11:02:36.245]                   options(future.plan = NULL)
[11:02:36.245]                   if (is.na(NA_character_)) 
[11:02:36.245]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:36.245]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:36.245]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:36.245]                     .init = FALSE)
[11:02:36.245]                 }
[11:02:36.245]             }
[11:02:36.245]         }
[11:02:36.245]     })
[11:02:36.245]     if (TRUE) {
[11:02:36.245]         base::sink(type = "output", split = FALSE)
[11:02:36.245]         if (TRUE) {
[11:02:36.245]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:36.245]         }
[11:02:36.245]         else {
[11:02:36.245]             ...future.result["stdout"] <- base::list(NULL)
[11:02:36.245]         }
[11:02:36.245]         base::close(...future.stdout)
[11:02:36.245]         ...future.stdout <- NULL
[11:02:36.245]     }
[11:02:36.245]     ...future.result$conditions <- ...future.conditions
[11:02:36.245]     ...future.result$finished <- base::Sys.time()
[11:02:36.245]     ...future.result
[11:02:36.245] }
[11:02:36.246] plan(): Setting new future strategy stack:
[11:02:36.246] List of future strategies:
[11:02:36.246] 1. sequential:
[11:02:36.246]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:36.246]    - tweaked: FALSE
[11:02:36.246]    - call: NULL
[11:02:36.247] plan(): nbrOfWorkers() = 1
[11:02:36.249] plan(): Setting new future strategy stack:
[11:02:36.249] List of future strategies:
[11:02:36.249] 1. sequential:
[11:02:36.249]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:36.249]    - tweaked: FALSE
[11:02:36.249]    - call: plan(strategy)
[11:02:36.249] plan(): nbrOfWorkers() = 1
[11:02:36.249] SequentialFuture started (and completed)
[11:02:36.249] - Launch lazy future ... done
[11:02:36.249] run() for ‘SequentialFuture’ ... done
[11:02:36.250] resolved() for ‘SequentialFuture’ ...
[11:02:36.250] - state: ‘finished’
[11:02:36.250] - run: TRUE
[11:02:36.250] - result: ‘FutureResult’
[11:02:36.250] resolved() for ‘SequentialFuture’ ... done
[11:02:36.250] Future #2
[11:02:36.250]  length: 1 (resolved future 2)
[11:02:36.250]  length: 0 (resolved future 3)
[11:02:36.250] resolve() on list ... DONE
[11:02:36.250] resolved() for ‘SequentialFuture’ ...
[11:02:36.250] - state: ‘finished’
[11:02:36.251] - run: TRUE
[11:02:36.251] - result: ‘FutureResult’
[11:02:36.251] resolved() for ‘SequentialFuture’ ... done
[11:02:36.251] resolved() for ‘SequentialFuture’ ...
[11:02:36.251] - state: ‘finished’
[11:02:36.251] - run: TRUE
[11:02:36.251] - result: ‘FutureResult’
[11:02:36.251] resolved() for ‘SequentialFuture’ ... done
[11:02:36.251] getGlobalsAndPackages() ...
[11:02:36.251] Searching for globals...
[11:02:36.252] 
[11:02:36.252] Searching for globals ... DONE
[11:02:36.252] - globals: [0] <none>
[11:02:36.252] getGlobalsAndPackages() ... DONE
[11:02:36.252] run() for ‘Future’ ...
[11:02:36.252] - state: ‘created’
[11:02:36.252] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:02:36.252] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:36.253] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:36.253]   - Field: ‘label’
[11:02:36.253]   - Field: ‘local’
[11:02:36.253]   - Field: ‘owner’
[11:02:36.253]   - Field: ‘envir’
[11:02:36.253]   - Field: ‘packages’
[11:02:36.253]   - Field: ‘gc’
[11:02:36.253]   - Field: ‘conditions’
[11:02:36.253]   - Field: ‘expr’
[11:02:36.253]   - Field: ‘uuid’
[11:02:36.253]   - Field: ‘seed’
[11:02:36.253]   - Field: ‘version’
[11:02:36.254]   - Field: ‘result’
[11:02:36.254]   - Field: ‘asynchronous’
[11:02:36.254]   - Field: ‘calls’
[11:02:36.254]   - Field: ‘globals’
[11:02:36.254]   - Field: ‘stdout’
[11:02:36.254]   - Field: ‘earlySignal’
[11:02:36.254]   - Field: ‘lazy’
[11:02:36.254]   - Field: ‘state’
[11:02:36.254] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:36.254] - Launch lazy future ...
[11:02:36.254] Packages needed by the future expression (n = 0): <none>
[11:02:36.255] Packages needed by future strategies (n = 0): <none>
[11:02:36.255] {
[11:02:36.255]     {
[11:02:36.255]         {
[11:02:36.255]             ...future.startTime <- base::Sys.time()
[11:02:36.255]             {
[11:02:36.255]                 {
[11:02:36.255]                   {
[11:02:36.255]                     base::local({
[11:02:36.255]                       has_future <- base::requireNamespace("future", 
[11:02:36.255]                         quietly = TRUE)
[11:02:36.255]                       if (has_future) {
[11:02:36.255]                         ns <- base::getNamespace("future")
[11:02:36.255]                         version <- ns[[".package"]][["version"]]
[11:02:36.255]                         if (is.null(version)) 
[11:02:36.255]                           version <- utils::packageVersion("future")
[11:02:36.255]                       }
[11:02:36.255]                       else {
[11:02:36.255]                         version <- NULL
[11:02:36.255]                       }
[11:02:36.255]                       if (!has_future || version < "1.8.0") {
[11:02:36.255]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:36.255]                           "", base::R.version$version.string), 
[11:02:36.255]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:36.255]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:36.255]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:36.255]                             "release", "version")], collapse = " "), 
[11:02:36.255]                           hostname = base::Sys.info()[["nodename"]])
[11:02:36.255]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:36.255]                           info)
[11:02:36.255]                         info <- base::paste(info, collapse = "; ")
[11:02:36.255]                         if (!has_future) {
[11:02:36.255]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:36.255]                             info)
[11:02:36.255]                         }
[11:02:36.255]                         else {
[11:02:36.255]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:36.255]                             info, version)
[11:02:36.255]                         }
[11:02:36.255]                         base::stop(msg)
[11:02:36.255]                       }
[11:02:36.255]                     })
[11:02:36.255]                   }
[11:02:36.255]                   ...future.strategy.old <- future::plan("list")
[11:02:36.255]                   options(future.plan = NULL)
[11:02:36.255]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:36.255]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:36.255]                 }
[11:02:36.255]                 ...future.workdir <- getwd()
[11:02:36.255]             }
[11:02:36.255]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:36.255]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:36.255]         }
[11:02:36.255]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:36.255]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:36.255]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:36.255]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:36.255]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:36.255]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:36.255]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:36.255]             base::names(...future.oldOptions))
[11:02:36.255]     }
[11:02:36.255]     if (FALSE) {
[11:02:36.255]     }
[11:02:36.255]     else {
[11:02:36.255]         if (TRUE) {
[11:02:36.255]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:36.255]                 open = "w")
[11:02:36.255]         }
[11:02:36.255]         else {
[11:02:36.255]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:36.255]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:36.255]         }
[11:02:36.255]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:36.255]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:36.255]             base::sink(type = "output", split = FALSE)
[11:02:36.255]             base::close(...future.stdout)
[11:02:36.255]         }, add = TRUE)
[11:02:36.255]     }
[11:02:36.255]     ...future.frame <- base::sys.nframe()
[11:02:36.255]     ...future.conditions <- base::list()
[11:02:36.255]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:36.255]     if (FALSE) {
[11:02:36.255]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:36.255]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:36.255]     }
[11:02:36.255]     ...future.result <- base::tryCatch({
[11:02:36.255]         base::withCallingHandlers({
[11:02:36.255]             ...future.value <- base::withVisible(base::local(1))
[11:02:36.255]             future::FutureResult(value = ...future.value$value, 
[11:02:36.255]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:36.255]                   ...future.rng), globalenv = if (FALSE) 
[11:02:36.255]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:36.255]                     ...future.globalenv.names))
[11:02:36.255]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:36.255]         }, condition = base::local({
[11:02:36.255]             c <- base::c
[11:02:36.255]             inherits <- base::inherits
[11:02:36.255]             invokeRestart <- base::invokeRestart
[11:02:36.255]             length <- base::length
[11:02:36.255]             list <- base::list
[11:02:36.255]             seq.int <- base::seq.int
[11:02:36.255]             signalCondition <- base::signalCondition
[11:02:36.255]             sys.calls <- base::sys.calls
[11:02:36.255]             `[[` <- base::`[[`
[11:02:36.255]             `+` <- base::`+`
[11:02:36.255]             `<<-` <- base::`<<-`
[11:02:36.255]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:36.255]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:36.255]                   3L)]
[11:02:36.255]             }
[11:02:36.255]             function(cond) {
[11:02:36.255]                 is_error <- inherits(cond, "error")
[11:02:36.255]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:36.255]                   NULL)
[11:02:36.255]                 if (is_error) {
[11:02:36.255]                   sessionInformation <- function() {
[11:02:36.255]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:36.255]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:36.255]                       search = base::search(), system = base::Sys.info())
[11:02:36.255]                   }
[11:02:36.255]                   ...future.conditions[[length(...future.conditions) + 
[11:02:36.255]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:36.255]                     cond$call), session = sessionInformation(), 
[11:02:36.255]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:36.255]                   signalCondition(cond)
[11:02:36.255]                 }
[11:02:36.255]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:36.255]                 "immediateCondition"))) {
[11:02:36.255]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:36.255]                   ...future.conditions[[length(...future.conditions) + 
[11:02:36.255]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:36.255]                   if (TRUE && !signal) {
[11:02:36.255]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:36.255]                     {
[11:02:36.255]                       inherits <- base::inherits
[11:02:36.255]                       invokeRestart <- base::invokeRestart
[11:02:36.255]                       is.null <- base::is.null
[11:02:36.255]                       muffled <- FALSE
[11:02:36.255]                       if (inherits(cond, "message")) {
[11:02:36.255]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:36.255]                         if (muffled) 
[11:02:36.255]                           invokeRestart("muffleMessage")
[11:02:36.255]                       }
[11:02:36.255]                       else if (inherits(cond, "warning")) {
[11:02:36.255]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:36.255]                         if (muffled) 
[11:02:36.255]                           invokeRestart("muffleWarning")
[11:02:36.255]                       }
[11:02:36.255]                       else if (inherits(cond, "condition")) {
[11:02:36.255]                         if (!is.null(pattern)) {
[11:02:36.255]                           computeRestarts <- base::computeRestarts
[11:02:36.255]                           grepl <- base::grepl
[11:02:36.255]                           restarts <- computeRestarts(cond)
[11:02:36.255]                           for (restart in restarts) {
[11:02:36.255]                             name <- restart$name
[11:02:36.255]                             if (is.null(name)) 
[11:02:36.255]                               next
[11:02:36.255]                             if (!grepl(pattern, name)) 
[11:02:36.255]                               next
[11:02:36.255]                             invokeRestart(restart)
[11:02:36.255]                             muffled <- TRUE
[11:02:36.255]                             break
[11:02:36.255]                           }
[11:02:36.255]                         }
[11:02:36.255]                       }
[11:02:36.255]                       invisible(muffled)
[11:02:36.255]                     }
[11:02:36.255]                     muffleCondition(cond, pattern = "^muffle")
[11:02:36.255]                   }
[11:02:36.255]                 }
[11:02:36.255]                 else {
[11:02:36.255]                   if (TRUE) {
[11:02:36.255]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:36.255]                     {
[11:02:36.255]                       inherits <- base::inherits
[11:02:36.255]                       invokeRestart <- base::invokeRestart
[11:02:36.255]                       is.null <- base::is.null
[11:02:36.255]                       muffled <- FALSE
[11:02:36.255]                       if (inherits(cond, "message")) {
[11:02:36.255]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:36.255]                         if (muffled) 
[11:02:36.255]                           invokeRestart("muffleMessage")
[11:02:36.255]                       }
[11:02:36.255]                       else if (inherits(cond, "warning")) {
[11:02:36.255]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:36.255]                         if (muffled) 
[11:02:36.255]                           invokeRestart("muffleWarning")
[11:02:36.255]                       }
[11:02:36.255]                       else if (inherits(cond, "condition")) {
[11:02:36.255]                         if (!is.null(pattern)) {
[11:02:36.255]                           computeRestarts <- base::computeRestarts
[11:02:36.255]                           grepl <- base::grepl
[11:02:36.255]                           restarts <- computeRestarts(cond)
[11:02:36.255]                           for (restart in restarts) {
[11:02:36.255]                             name <- restart$name
[11:02:36.255]                             if (is.null(name)) 
[11:02:36.255]                               next
[11:02:36.255]                             if (!grepl(pattern, name)) 
[11:02:36.255]                               next
[11:02:36.255]                             invokeRestart(restart)
[11:02:36.255]                             muffled <- TRUE
[11:02:36.255]                             break
[11:02:36.255]                           }
[11:02:36.255]                         }
[11:02:36.255]                       }
[11:02:36.255]                       invisible(muffled)
[11:02:36.255]                     }
[11:02:36.255]                     muffleCondition(cond, pattern = "^muffle")
[11:02:36.255]                   }
[11:02:36.255]                 }
[11:02:36.255]             }
[11:02:36.255]         }))
[11:02:36.255]     }, error = function(ex) {
[11:02:36.255]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:36.255]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:36.255]                 ...future.rng), started = ...future.startTime, 
[11:02:36.255]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:36.255]             version = "1.8"), class = "FutureResult")
[11:02:36.255]     }, finally = {
[11:02:36.255]         if (!identical(...future.workdir, getwd())) 
[11:02:36.255]             setwd(...future.workdir)
[11:02:36.255]         {
[11:02:36.255]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:36.255]                 ...future.oldOptions$nwarnings <- NULL
[11:02:36.255]             }
[11:02:36.255]             base::options(...future.oldOptions)
[11:02:36.255]             if (.Platform$OS.type == "windows") {
[11:02:36.255]                 old_names <- names(...future.oldEnvVars)
[11:02:36.255]                 envs <- base::Sys.getenv()
[11:02:36.255]                 names <- names(envs)
[11:02:36.255]                 common <- intersect(names, old_names)
[11:02:36.255]                 added <- setdiff(names, old_names)
[11:02:36.255]                 removed <- setdiff(old_names, names)
[11:02:36.255]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:36.255]                   envs[common]]
[11:02:36.255]                 NAMES <- toupper(changed)
[11:02:36.255]                 args <- list()
[11:02:36.255]                 for (kk in seq_along(NAMES)) {
[11:02:36.255]                   name <- changed[[kk]]
[11:02:36.255]                   NAME <- NAMES[[kk]]
[11:02:36.255]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:36.255]                     next
[11:02:36.255]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:36.255]                 }
[11:02:36.255]                 NAMES <- toupper(added)
[11:02:36.255]                 for (kk in seq_along(NAMES)) {
[11:02:36.255]                   name <- added[[kk]]
[11:02:36.255]                   NAME <- NAMES[[kk]]
[11:02:36.255]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:36.255]                     next
[11:02:36.255]                   args[[name]] <- ""
[11:02:36.255]                 }
[11:02:36.255]                 NAMES <- toupper(removed)
[11:02:36.255]                 for (kk in seq_along(NAMES)) {
[11:02:36.255]                   name <- removed[[kk]]
[11:02:36.255]                   NAME <- NAMES[[kk]]
[11:02:36.255]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:36.255]                     next
[11:02:36.255]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:36.255]                 }
[11:02:36.255]                 if (length(args) > 0) 
[11:02:36.255]                   base::do.call(base::Sys.setenv, args = args)
[11:02:36.255]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:36.255]             }
[11:02:36.255]             else {
[11:02:36.255]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:36.255]             }
[11:02:36.255]             {
[11:02:36.255]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:36.255]                   0L) {
[11:02:36.255]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:36.255]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:36.255]                   base::options(opts)
[11:02:36.255]                 }
[11:02:36.255]                 {
[11:02:36.255]                   {
[11:02:36.255]                     NULL
[11:02:36.255]                     RNGkind("Mersenne-Twister")
[11:02:36.255]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:36.255]                       inherits = FALSE)
[11:02:36.255]                   }
[11:02:36.255]                   options(future.plan = NULL)
[11:02:36.255]                   if (is.na(NA_character_)) 
[11:02:36.255]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:36.255]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:36.255]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:36.255]                     .init = FALSE)
[11:02:36.255]                 }
[11:02:36.255]             }
[11:02:36.255]         }
[11:02:36.255]     })
[11:02:36.255]     if (TRUE) {
[11:02:36.255]         base::sink(type = "output", split = FALSE)
[11:02:36.255]         if (TRUE) {
[11:02:36.255]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:36.255]         }
[11:02:36.255]         else {
[11:02:36.255]             ...future.result["stdout"] <- base::list(NULL)
[11:02:36.255]         }
[11:02:36.255]         base::close(...future.stdout)
[11:02:36.255]         ...future.stdout <- NULL
[11:02:36.255]     }
[11:02:36.255]     ...future.result$conditions <- ...future.conditions
[11:02:36.255]     ...future.result$finished <- base::Sys.time()
[11:02:36.255]     ...future.result
[11:02:36.255] }
[11:02:36.257] plan(): Setting new future strategy stack:
[11:02:36.257] List of future strategies:
[11:02:36.257] 1. sequential:
[11:02:36.257]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:36.257]    - tweaked: FALSE
[11:02:36.257]    - call: NULL
[11:02:36.257] plan(): nbrOfWorkers() = 1
[11:02:36.258] plan(): Setting new future strategy stack:
[11:02:36.258] List of future strategies:
[11:02:36.258] 1. sequential:
[11:02:36.258]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:36.258]    - tweaked: FALSE
[11:02:36.258]    - call: plan(strategy)
[11:02:36.258] plan(): nbrOfWorkers() = 1
[11:02:36.258] SequentialFuture started (and completed)
[11:02:36.259] - Launch lazy future ... done
[11:02:36.259] run() for ‘SequentialFuture’ ... done
[11:02:36.259] getGlobalsAndPackages() ...
[11:02:36.259] Searching for globals...
[11:02:36.263] - globals found: [2] ‘{’, ‘Sys.sleep’
[11:02:36.263] Searching for globals ... DONE
[11:02:36.263] Resolving globals: FALSE
[11:02:36.264] 
[11:02:36.264] 
[11:02:36.264] getGlobalsAndPackages() ... DONE
[11:02:36.264] run() for ‘Future’ ...
[11:02:36.264] - state: ‘created’
[11:02:36.264] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:02:36.264] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:36.265] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:36.265]   - Field: ‘label’
[11:02:36.265]   - Field: ‘local’
[11:02:36.265]   - Field: ‘owner’
[11:02:36.265]   - Field: ‘envir’
[11:02:36.265]   - Field: ‘packages’
[11:02:36.265]   - Field: ‘gc’
[11:02:36.265]   - Field: ‘conditions’
[11:02:36.265]   - Field: ‘expr’
[11:02:36.265]   - Field: ‘uuid’
[11:02:36.265]   - Field: ‘seed’
[11:02:36.265]   - Field: ‘version’
[11:02:36.266]   - Field: ‘result’
[11:02:36.266]   - Field: ‘asynchronous’
[11:02:36.266]   - Field: ‘calls’
[11:02:36.266]   - Field: ‘globals’
[11:02:36.266]   - Field: ‘stdout’
[11:02:36.266]   - Field: ‘earlySignal’
[11:02:36.266]   - Field: ‘lazy’
[11:02:36.266]   - Field: ‘state’
[11:02:36.266] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:36.266] - Launch lazy future ...
[11:02:36.266] Packages needed by the future expression (n = 0): <none>
[11:02:36.267] Packages needed by future strategies (n = 0): <none>
[11:02:36.267] {
[11:02:36.267]     {
[11:02:36.267]         {
[11:02:36.267]             ...future.startTime <- base::Sys.time()
[11:02:36.267]             {
[11:02:36.267]                 {
[11:02:36.267]                   {
[11:02:36.267]                     base::local({
[11:02:36.267]                       has_future <- base::requireNamespace("future", 
[11:02:36.267]                         quietly = TRUE)
[11:02:36.267]                       if (has_future) {
[11:02:36.267]                         ns <- base::getNamespace("future")
[11:02:36.267]                         version <- ns[[".package"]][["version"]]
[11:02:36.267]                         if (is.null(version)) 
[11:02:36.267]                           version <- utils::packageVersion("future")
[11:02:36.267]                       }
[11:02:36.267]                       else {
[11:02:36.267]                         version <- NULL
[11:02:36.267]                       }
[11:02:36.267]                       if (!has_future || version < "1.8.0") {
[11:02:36.267]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:36.267]                           "", base::R.version$version.string), 
[11:02:36.267]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:36.267]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:36.267]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:36.267]                             "release", "version")], collapse = " "), 
[11:02:36.267]                           hostname = base::Sys.info()[["nodename"]])
[11:02:36.267]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:36.267]                           info)
[11:02:36.267]                         info <- base::paste(info, collapse = "; ")
[11:02:36.267]                         if (!has_future) {
[11:02:36.267]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:36.267]                             info)
[11:02:36.267]                         }
[11:02:36.267]                         else {
[11:02:36.267]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:36.267]                             info, version)
[11:02:36.267]                         }
[11:02:36.267]                         base::stop(msg)
[11:02:36.267]                       }
[11:02:36.267]                     })
[11:02:36.267]                   }
[11:02:36.267]                   ...future.strategy.old <- future::plan("list")
[11:02:36.267]                   options(future.plan = NULL)
[11:02:36.267]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:36.267]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:36.267]                 }
[11:02:36.267]                 ...future.workdir <- getwd()
[11:02:36.267]             }
[11:02:36.267]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:36.267]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:36.267]         }
[11:02:36.267]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:36.267]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:36.267]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:36.267]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:36.267]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:36.267]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:36.267]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:36.267]             base::names(...future.oldOptions))
[11:02:36.267]     }
[11:02:36.267]     if (FALSE) {
[11:02:36.267]     }
[11:02:36.267]     else {
[11:02:36.267]         if (TRUE) {
[11:02:36.267]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:36.267]                 open = "w")
[11:02:36.267]         }
[11:02:36.267]         else {
[11:02:36.267]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:36.267]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:36.267]         }
[11:02:36.267]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:36.267]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:36.267]             base::sink(type = "output", split = FALSE)
[11:02:36.267]             base::close(...future.stdout)
[11:02:36.267]         }, add = TRUE)
[11:02:36.267]     }
[11:02:36.267]     ...future.frame <- base::sys.nframe()
[11:02:36.267]     ...future.conditions <- base::list()
[11:02:36.267]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:36.267]     if (FALSE) {
[11:02:36.267]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:36.267]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:36.267]     }
[11:02:36.267]     ...future.result <- base::tryCatch({
[11:02:36.267]         base::withCallingHandlers({
[11:02:36.267]             ...future.value <- base::withVisible(base::local({
[11:02:36.267]                 Sys.sleep(0.5)
[11:02:36.267]                 2
[11:02:36.267]             }))
[11:02:36.267]             future::FutureResult(value = ...future.value$value, 
[11:02:36.267]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:36.267]                   ...future.rng), globalenv = if (FALSE) 
[11:02:36.267]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:36.267]                     ...future.globalenv.names))
[11:02:36.267]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:36.267]         }, condition = base::local({
[11:02:36.267]             c <- base::c
[11:02:36.267]             inherits <- base::inherits
[11:02:36.267]             invokeRestart <- base::invokeRestart
[11:02:36.267]             length <- base::length
[11:02:36.267]             list <- base::list
[11:02:36.267]             seq.int <- base::seq.int
[11:02:36.267]             signalCondition <- base::signalCondition
[11:02:36.267]             sys.calls <- base::sys.calls
[11:02:36.267]             `[[` <- base::`[[`
[11:02:36.267]             `+` <- base::`+`
[11:02:36.267]             `<<-` <- base::`<<-`
[11:02:36.267]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:36.267]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:36.267]                   3L)]
[11:02:36.267]             }
[11:02:36.267]             function(cond) {
[11:02:36.267]                 is_error <- inherits(cond, "error")
[11:02:36.267]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:36.267]                   NULL)
[11:02:36.267]                 if (is_error) {
[11:02:36.267]                   sessionInformation <- function() {
[11:02:36.267]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:36.267]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:36.267]                       search = base::search(), system = base::Sys.info())
[11:02:36.267]                   }
[11:02:36.267]                   ...future.conditions[[length(...future.conditions) + 
[11:02:36.267]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:36.267]                     cond$call), session = sessionInformation(), 
[11:02:36.267]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:36.267]                   signalCondition(cond)
[11:02:36.267]                 }
[11:02:36.267]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:36.267]                 "immediateCondition"))) {
[11:02:36.267]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:36.267]                   ...future.conditions[[length(...future.conditions) + 
[11:02:36.267]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:36.267]                   if (TRUE && !signal) {
[11:02:36.267]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:36.267]                     {
[11:02:36.267]                       inherits <- base::inherits
[11:02:36.267]                       invokeRestart <- base::invokeRestart
[11:02:36.267]                       is.null <- base::is.null
[11:02:36.267]                       muffled <- FALSE
[11:02:36.267]                       if (inherits(cond, "message")) {
[11:02:36.267]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:36.267]                         if (muffled) 
[11:02:36.267]                           invokeRestart("muffleMessage")
[11:02:36.267]                       }
[11:02:36.267]                       else if (inherits(cond, "warning")) {
[11:02:36.267]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:36.267]                         if (muffled) 
[11:02:36.267]                           invokeRestart("muffleWarning")
[11:02:36.267]                       }
[11:02:36.267]                       else if (inherits(cond, "condition")) {
[11:02:36.267]                         if (!is.null(pattern)) {
[11:02:36.267]                           computeRestarts <- base::computeRestarts
[11:02:36.267]                           grepl <- base::grepl
[11:02:36.267]                           restarts <- computeRestarts(cond)
[11:02:36.267]                           for (restart in restarts) {
[11:02:36.267]                             name <- restart$name
[11:02:36.267]                             if (is.null(name)) 
[11:02:36.267]                               next
[11:02:36.267]                             if (!grepl(pattern, name)) 
[11:02:36.267]                               next
[11:02:36.267]                             invokeRestart(restart)
[11:02:36.267]                             muffled <- TRUE
[11:02:36.267]                             break
[11:02:36.267]                           }
[11:02:36.267]                         }
[11:02:36.267]                       }
[11:02:36.267]                       invisible(muffled)
[11:02:36.267]                     }
[11:02:36.267]                     muffleCondition(cond, pattern = "^muffle")
[11:02:36.267]                   }
[11:02:36.267]                 }
[11:02:36.267]                 else {
[11:02:36.267]                   if (TRUE) {
[11:02:36.267]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:36.267]                     {
[11:02:36.267]                       inherits <- base::inherits
[11:02:36.267]                       invokeRestart <- base::invokeRestart
[11:02:36.267]                       is.null <- base::is.null
[11:02:36.267]                       muffled <- FALSE
[11:02:36.267]                       if (inherits(cond, "message")) {
[11:02:36.267]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:36.267]                         if (muffled) 
[11:02:36.267]                           invokeRestart("muffleMessage")
[11:02:36.267]                       }
[11:02:36.267]                       else if (inherits(cond, "warning")) {
[11:02:36.267]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:36.267]                         if (muffled) 
[11:02:36.267]                           invokeRestart("muffleWarning")
[11:02:36.267]                       }
[11:02:36.267]                       else if (inherits(cond, "condition")) {
[11:02:36.267]                         if (!is.null(pattern)) {
[11:02:36.267]                           computeRestarts <- base::computeRestarts
[11:02:36.267]                           grepl <- base::grepl
[11:02:36.267]                           restarts <- computeRestarts(cond)
[11:02:36.267]                           for (restart in restarts) {
[11:02:36.267]                             name <- restart$name
[11:02:36.267]                             if (is.null(name)) 
[11:02:36.267]                               next
[11:02:36.267]                             if (!grepl(pattern, name)) 
[11:02:36.267]                               next
[11:02:36.267]                             invokeRestart(restart)
[11:02:36.267]                             muffled <- TRUE
[11:02:36.267]                             break
[11:02:36.267]                           }
[11:02:36.267]                         }
[11:02:36.267]                       }
[11:02:36.267]                       invisible(muffled)
[11:02:36.267]                     }
[11:02:36.267]                     muffleCondition(cond, pattern = "^muffle")
[11:02:36.267]                   }
[11:02:36.267]                 }
[11:02:36.267]             }
[11:02:36.267]         }))
[11:02:36.267]     }, error = function(ex) {
[11:02:36.267]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:36.267]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:36.267]                 ...future.rng), started = ...future.startTime, 
[11:02:36.267]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:36.267]             version = "1.8"), class = "FutureResult")
[11:02:36.267]     }, finally = {
[11:02:36.267]         if (!identical(...future.workdir, getwd())) 
[11:02:36.267]             setwd(...future.workdir)
[11:02:36.267]         {
[11:02:36.267]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:36.267]                 ...future.oldOptions$nwarnings <- NULL
[11:02:36.267]             }
[11:02:36.267]             base::options(...future.oldOptions)
[11:02:36.267]             if (.Platform$OS.type == "windows") {
[11:02:36.267]                 old_names <- names(...future.oldEnvVars)
[11:02:36.267]                 envs <- base::Sys.getenv()
[11:02:36.267]                 names <- names(envs)
[11:02:36.267]                 common <- intersect(names, old_names)
[11:02:36.267]                 added <- setdiff(names, old_names)
[11:02:36.267]                 removed <- setdiff(old_names, names)
[11:02:36.267]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:36.267]                   envs[common]]
[11:02:36.267]                 NAMES <- toupper(changed)
[11:02:36.267]                 args <- list()
[11:02:36.267]                 for (kk in seq_along(NAMES)) {
[11:02:36.267]                   name <- changed[[kk]]
[11:02:36.267]                   NAME <- NAMES[[kk]]
[11:02:36.267]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:36.267]                     next
[11:02:36.267]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:36.267]                 }
[11:02:36.267]                 NAMES <- toupper(added)
[11:02:36.267]                 for (kk in seq_along(NAMES)) {
[11:02:36.267]                   name <- added[[kk]]
[11:02:36.267]                   NAME <- NAMES[[kk]]
[11:02:36.267]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:36.267]                     next
[11:02:36.267]                   args[[name]] <- ""
[11:02:36.267]                 }
[11:02:36.267]                 NAMES <- toupper(removed)
[11:02:36.267]                 for (kk in seq_along(NAMES)) {
[11:02:36.267]                   name <- removed[[kk]]
[11:02:36.267]                   NAME <- NAMES[[kk]]
[11:02:36.267]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:36.267]                     next
[11:02:36.267]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:36.267]                 }
[11:02:36.267]                 if (length(args) > 0) 
[11:02:36.267]                   base::do.call(base::Sys.setenv, args = args)
[11:02:36.267]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:36.267]             }
[11:02:36.267]             else {
[11:02:36.267]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:36.267]             }
[11:02:36.267]             {
[11:02:36.267]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:36.267]                   0L) {
[11:02:36.267]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:36.267]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:36.267]                   base::options(opts)
[11:02:36.267]                 }
[11:02:36.267]                 {
[11:02:36.267]                   {
[11:02:36.267]                     NULL
[11:02:36.267]                     RNGkind("Mersenne-Twister")
[11:02:36.267]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:36.267]                       inherits = FALSE)
[11:02:36.267]                   }
[11:02:36.267]                   options(future.plan = NULL)
[11:02:36.267]                   if (is.na(NA_character_)) 
[11:02:36.267]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:36.267]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:36.267]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:36.267]                     .init = FALSE)
[11:02:36.267]                 }
[11:02:36.267]             }
[11:02:36.267]         }
[11:02:36.267]     })
[11:02:36.267]     if (TRUE) {
[11:02:36.267]         base::sink(type = "output", split = FALSE)
[11:02:36.267]         if (TRUE) {
[11:02:36.267]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:36.267]         }
[11:02:36.267]         else {
[11:02:36.267]             ...future.result["stdout"] <- base::list(NULL)
[11:02:36.267]         }
[11:02:36.267]         base::close(...future.stdout)
[11:02:36.267]         ...future.stdout <- NULL
[11:02:36.267]     }
[11:02:36.267]     ...future.result$conditions <- ...future.conditions
[11:02:36.267]     ...future.result$finished <- base::Sys.time()
[11:02:36.267]     ...future.result
[11:02:36.267] }
[11:02:36.269] plan(): Setting new future strategy stack:
[11:02:36.269] List of future strategies:
[11:02:36.269] 1. sequential:
[11:02:36.269]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:36.269]    - tweaked: FALSE
[11:02:36.269]    - call: NULL
[11:02:36.269] plan(): nbrOfWorkers() = 1
[11:02:36.771] plan(): Setting new future strategy stack:
[11:02:36.771] List of future strategies:
[11:02:36.771] 1. sequential:
[11:02:36.771]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:36.771]    - tweaked: FALSE
[11:02:36.771]    - call: plan(strategy)
[11:02:36.771] plan(): nbrOfWorkers() = 1
[11:02:36.772] SequentialFuture started (and completed)
[11:02:36.772] - Launch lazy future ... done
[11:02:36.772] run() for ‘SequentialFuture’ ... done
[11:02:36.772] resolve() on list ...
[11:02:36.772]  recursive: 0
[11:02:36.772]  length: 1
[11:02:36.772] 
[11:02:36.773] resolved() for ‘SequentialFuture’ ...
[11:02:36.773] - state: ‘finished’
[11:02:36.773] - run: TRUE
[11:02:36.773] - result: ‘FutureResult’
[11:02:36.773] resolved() for ‘SequentialFuture’ ... done
[11:02:36.773] Future #1
[11:02:36.773]  length: 0 (resolved future 1)
[11:02:36.773] resolve() on list ... DONE
[11:02:36.773] resolved() for ‘SequentialFuture’ ...
[11:02:36.773] - state: ‘finished’
[11:02:36.773] - run: TRUE
[11:02:36.774] - result: ‘FutureResult’
[11:02:36.774] resolved() for ‘SequentialFuture’ ... done
[11:02:36.774] resolve() on list ...
[11:02:36.774]  recursive: 0
[11:02:36.774]  length: 1
[11:02:36.774] 
[11:02:36.774] resolved() for ‘SequentialFuture’ ...
[11:02:36.774] - state: ‘finished’
[11:02:36.774] - run: TRUE
[11:02:36.774] - result: ‘FutureResult’
[11:02:36.775] resolved() for ‘SequentialFuture’ ... done
[11:02:36.775] Future #1
[11:02:36.775]  length: 0 (resolved future 1)
[11:02:36.775] resolve() on list ... DONE
[11:02:36.775] resolved() for ‘SequentialFuture’ ...
[11:02:36.775] - state: ‘finished’
[11:02:36.775] - run: TRUE
[11:02:36.775] - result: ‘FutureResult’
[11:02:36.775] resolved() for ‘SequentialFuture’ ... done
[11:02:36.775] resolve() on list ...
[11:02:36.775]  recursive: 0
[11:02:36.776]  length: 1
[11:02:36.776] 
[11:02:36.776]  length: 0 (resolved future 1)
[11:02:36.776] resolve() on list ... DONE
[11:02:36.776] resolve() on list ...
[11:02:36.776]  recursive: 0
[11:02:36.776]  length: 4
[11:02:36.776] 
[11:02:36.776] resolved() for ‘SequentialFuture’ ...
[11:02:36.776] - state: ‘finished’
[11:02:36.776] - run: TRUE
[11:02:36.777] - result: ‘FutureResult’
[11:02:36.777] resolved() for ‘SequentialFuture’ ... done
[11:02:36.777] Future #1
[11:02:36.777]  length: 3 (resolved future 1)
[11:02:36.777] resolved() for ‘SequentialFuture’ ...
[11:02:36.777] - state: ‘finished’
[11:02:36.777] - run: TRUE
[11:02:36.777] - result: ‘FutureResult’
[11:02:36.777] resolved() for ‘SequentialFuture’ ... done
[11:02:36.779] Future #2
[11:02:36.779]  length: 2 (resolved future 2)
[11:02:36.779]  length: 1 (resolved future 3)
[11:02:36.779]  length: 0 (resolved future 4)
[11:02:36.779] resolve() on list ... DONE
[11:02:36.780] resolve() on list ...
[11:02:36.780]  recursive: 0
[11:02:36.780]  length: 4
[11:02:36.780] 
[11:02:36.780] resolved() for ‘SequentialFuture’ ...
[11:02:36.780] - state: ‘finished’
[11:02:36.780] - run: TRUE
[11:02:36.780] - result: ‘FutureResult’
[11:02:36.780] resolved() for ‘SequentialFuture’ ... done
[11:02:36.780] Future #1
[11:02:36.780]  length: 3 (resolved future 1)
[11:02:36.781] resolved() for ‘SequentialFuture’ ...
[11:02:36.781] - state: ‘finished’
[11:02:36.781] - run: TRUE
[11:02:36.781] - result: ‘FutureResult’
[11:02:36.781] resolved() for ‘SequentialFuture’ ... done
[11:02:36.781] Future #2
[11:02:36.781]  length: 2 (resolved future 2)
[11:02:36.781]  length: 1 (resolved future 3)
[11:02:36.781]  length: 0 (resolved future 4)
[11:02:36.781] resolve() on list ... DONE
[11:02:36.782] resolve() on list ...
[11:02:36.782]  recursive: 0
[11:02:36.782]  length: 1
[11:02:36.782] 
[11:02:36.782]  length: 0 (resolved future 1)
[11:02:36.782] resolve() on list ... DONE
[11:02:36.782] getGlobalsAndPackages() ...
[11:02:36.782] Searching for globals...
[11:02:36.783] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[11:02:36.783] Searching for globals ... DONE
[11:02:36.783] Resolving globals: FALSE
[11:02:36.784] The total size of the 1 globals is 35 bytes (35 bytes)
[11:02:36.784] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[11:02:36.785] - globals: [1] ‘kk’
[11:02:36.785] 
[11:02:36.785] getGlobalsAndPackages() ... DONE
[11:02:36.785] run() for ‘Future’ ...
[11:02:36.785] - state: ‘created’
[11:02:36.785] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:02:36.785] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:36.786] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:36.786]   - Field: ‘label’
[11:02:36.786]   - Field: ‘local’
[11:02:36.786]   - Field: ‘owner’
[11:02:36.786]   - Field: ‘envir’
[11:02:36.786]   - Field: ‘packages’
[11:02:36.786]   - Field: ‘gc’
[11:02:36.786]   - Field: ‘conditions’
[11:02:36.786]   - Field: ‘expr’
[11:02:36.786]   - Field: ‘uuid’
[11:02:36.786]   - Field: ‘seed’
[11:02:36.787]   - Field: ‘version’
[11:02:36.787]   - Field: ‘result’
[11:02:36.787]   - Field: ‘asynchronous’
[11:02:36.787]   - Field: ‘calls’
[11:02:36.787]   - Field: ‘globals’
[11:02:36.787]   - Field: ‘stdout’
[11:02:36.787]   - Field: ‘earlySignal’
[11:02:36.787]   - Field: ‘lazy’
[11:02:36.787]   - Field: ‘state’
[11:02:36.787] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:36.787] - Launch lazy future ...
[11:02:36.788] Packages needed by the future expression (n = 0): <none>
[11:02:36.788] Packages needed by future strategies (n = 0): <none>
[11:02:36.788] {
[11:02:36.788]     {
[11:02:36.788]         {
[11:02:36.788]             ...future.startTime <- base::Sys.time()
[11:02:36.788]             {
[11:02:36.788]                 {
[11:02:36.788]                   {
[11:02:36.788]                     base::local({
[11:02:36.788]                       has_future <- base::requireNamespace("future", 
[11:02:36.788]                         quietly = TRUE)
[11:02:36.788]                       if (has_future) {
[11:02:36.788]                         ns <- base::getNamespace("future")
[11:02:36.788]                         version <- ns[[".package"]][["version"]]
[11:02:36.788]                         if (is.null(version)) 
[11:02:36.788]                           version <- utils::packageVersion("future")
[11:02:36.788]                       }
[11:02:36.788]                       else {
[11:02:36.788]                         version <- NULL
[11:02:36.788]                       }
[11:02:36.788]                       if (!has_future || version < "1.8.0") {
[11:02:36.788]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:36.788]                           "", base::R.version$version.string), 
[11:02:36.788]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:36.788]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:36.788]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:36.788]                             "release", "version")], collapse = " "), 
[11:02:36.788]                           hostname = base::Sys.info()[["nodename"]])
[11:02:36.788]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:36.788]                           info)
[11:02:36.788]                         info <- base::paste(info, collapse = "; ")
[11:02:36.788]                         if (!has_future) {
[11:02:36.788]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:36.788]                             info)
[11:02:36.788]                         }
[11:02:36.788]                         else {
[11:02:36.788]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:36.788]                             info, version)
[11:02:36.788]                         }
[11:02:36.788]                         base::stop(msg)
[11:02:36.788]                       }
[11:02:36.788]                     })
[11:02:36.788]                   }
[11:02:36.788]                   ...future.strategy.old <- future::plan("list")
[11:02:36.788]                   options(future.plan = NULL)
[11:02:36.788]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:36.788]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:36.788]                 }
[11:02:36.788]                 ...future.workdir <- getwd()
[11:02:36.788]             }
[11:02:36.788]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:36.788]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:36.788]         }
[11:02:36.788]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:36.788]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:36.788]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:36.788]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:36.788]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:36.788]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:36.788]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:36.788]             base::names(...future.oldOptions))
[11:02:36.788]     }
[11:02:36.788]     if (FALSE) {
[11:02:36.788]     }
[11:02:36.788]     else {
[11:02:36.788]         if (TRUE) {
[11:02:36.788]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:36.788]                 open = "w")
[11:02:36.788]         }
[11:02:36.788]         else {
[11:02:36.788]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:36.788]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:36.788]         }
[11:02:36.788]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:36.788]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:36.788]             base::sink(type = "output", split = FALSE)
[11:02:36.788]             base::close(...future.stdout)
[11:02:36.788]         }, add = TRUE)
[11:02:36.788]     }
[11:02:36.788]     ...future.frame <- base::sys.nframe()
[11:02:36.788]     ...future.conditions <- base::list()
[11:02:36.788]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:36.788]     if (FALSE) {
[11:02:36.788]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:36.788]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:36.788]     }
[11:02:36.788]     ...future.result <- base::tryCatch({
[11:02:36.788]         base::withCallingHandlers({
[11:02:36.788]             ...future.value <- base::withVisible(base::local({
[11:02:36.788]                 Sys.sleep(0.1)
[11:02:36.788]                 kk
[11:02:36.788]             }))
[11:02:36.788]             future::FutureResult(value = ...future.value$value, 
[11:02:36.788]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:36.788]                   ...future.rng), globalenv = if (FALSE) 
[11:02:36.788]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:36.788]                     ...future.globalenv.names))
[11:02:36.788]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:36.788]         }, condition = base::local({
[11:02:36.788]             c <- base::c
[11:02:36.788]             inherits <- base::inherits
[11:02:36.788]             invokeRestart <- base::invokeRestart
[11:02:36.788]             length <- base::length
[11:02:36.788]             list <- base::list
[11:02:36.788]             seq.int <- base::seq.int
[11:02:36.788]             signalCondition <- base::signalCondition
[11:02:36.788]             sys.calls <- base::sys.calls
[11:02:36.788]             `[[` <- base::`[[`
[11:02:36.788]             `+` <- base::`+`
[11:02:36.788]             `<<-` <- base::`<<-`
[11:02:36.788]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:36.788]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:36.788]                   3L)]
[11:02:36.788]             }
[11:02:36.788]             function(cond) {
[11:02:36.788]                 is_error <- inherits(cond, "error")
[11:02:36.788]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:36.788]                   NULL)
[11:02:36.788]                 if (is_error) {
[11:02:36.788]                   sessionInformation <- function() {
[11:02:36.788]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:36.788]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:36.788]                       search = base::search(), system = base::Sys.info())
[11:02:36.788]                   }
[11:02:36.788]                   ...future.conditions[[length(...future.conditions) + 
[11:02:36.788]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:36.788]                     cond$call), session = sessionInformation(), 
[11:02:36.788]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:36.788]                   signalCondition(cond)
[11:02:36.788]                 }
[11:02:36.788]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:36.788]                 "immediateCondition"))) {
[11:02:36.788]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:36.788]                   ...future.conditions[[length(...future.conditions) + 
[11:02:36.788]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:36.788]                   if (TRUE && !signal) {
[11:02:36.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:36.788]                     {
[11:02:36.788]                       inherits <- base::inherits
[11:02:36.788]                       invokeRestart <- base::invokeRestart
[11:02:36.788]                       is.null <- base::is.null
[11:02:36.788]                       muffled <- FALSE
[11:02:36.788]                       if (inherits(cond, "message")) {
[11:02:36.788]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:36.788]                         if (muffled) 
[11:02:36.788]                           invokeRestart("muffleMessage")
[11:02:36.788]                       }
[11:02:36.788]                       else if (inherits(cond, "warning")) {
[11:02:36.788]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:36.788]                         if (muffled) 
[11:02:36.788]                           invokeRestart("muffleWarning")
[11:02:36.788]                       }
[11:02:36.788]                       else if (inherits(cond, "condition")) {
[11:02:36.788]                         if (!is.null(pattern)) {
[11:02:36.788]                           computeRestarts <- base::computeRestarts
[11:02:36.788]                           grepl <- base::grepl
[11:02:36.788]                           restarts <- computeRestarts(cond)
[11:02:36.788]                           for (restart in restarts) {
[11:02:36.788]                             name <- restart$name
[11:02:36.788]                             if (is.null(name)) 
[11:02:36.788]                               next
[11:02:36.788]                             if (!grepl(pattern, name)) 
[11:02:36.788]                               next
[11:02:36.788]                             invokeRestart(restart)
[11:02:36.788]                             muffled <- TRUE
[11:02:36.788]                             break
[11:02:36.788]                           }
[11:02:36.788]                         }
[11:02:36.788]                       }
[11:02:36.788]                       invisible(muffled)
[11:02:36.788]                     }
[11:02:36.788]                     muffleCondition(cond, pattern = "^muffle")
[11:02:36.788]                   }
[11:02:36.788]                 }
[11:02:36.788]                 else {
[11:02:36.788]                   if (TRUE) {
[11:02:36.788]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:36.788]                     {
[11:02:36.788]                       inherits <- base::inherits
[11:02:36.788]                       invokeRestart <- base::invokeRestart
[11:02:36.788]                       is.null <- base::is.null
[11:02:36.788]                       muffled <- FALSE
[11:02:36.788]                       if (inherits(cond, "message")) {
[11:02:36.788]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:36.788]                         if (muffled) 
[11:02:36.788]                           invokeRestart("muffleMessage")
[11:02:36.788]                       }
[11:02:36.788]                       else if (inherits(cond, "warning")) {
[11:02:36.788]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:36.788]                         if (muffled) 
[11:02:36.788]                           invokeRestart("muffleWarning")
[11:02:36.788]                       }
[11:02:36.788]                       else if (inherits(cond, "condition")) {
[11:02:36.788]                         if (!is.null(pattern)) {
[11:02:36.788]                           computeRestarts <- base::computeRestarts
[11:02:36.788]                           grepl <- base::grepl
[11:02:36.788]                           restarts <- computeRestarts(cond)
[11:02:36.788]                           for (restart in restarts) {
[11:02:36.788]                             name <- restart$name
[11:02:36.788]                             if (is.null(name)) 
[11:02:36.788]                               next
[11:02:36.788]                             if (!grepl(pattern, name)) 
[11:02:36.788]                               next
[11:02:36.788]                             invokeRestart(restart)
[11:02:36.788]                             muffled <- TRUE
[11:02:36.788]                             break
[11:02:36.788]                           }
[11:02:36.788]                         }
[11:02:36.788]                       }
[11:02:36.788]                       invisible(muffled)
[11:02:36.788]                     }
[11:02:36.788]                     muffleCondition(cond, pattern = "^muffle")
[11:02:36.788]                   }
[11:02:36.788]                 }
[11:02:36.788]             }
[11:02:36.788]         }))
[11:02:36.788]     }, error = function(ex) {
[11:02:36.788]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:36.788]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:36.788]                 ...future.rng), started = ...future.startTime, 
[11:02:36.788]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:36.788]             version = "1.8"), class = "FutureResult")
[11:02:36.788]     }, finally = {
[11:02:36.788]         if (!identical(...future.workdir, getwd())) 
[11:02:36.788]             setwd(...future.workdir)
[11:02:36.788]         {
[11:02:36.788]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:36.788]                 ...future.oldOptions$nwarnings <- NULL
[11:02:36.788]             }
[11:02:36.788]             base::options(...future.oldOptions)
[11:02:36.788]             if (.Platform$OS.type == "windows") {
[11:02:36.788]                 old_names <- names(...future.oldEnvVars)
[11:02:36.788]                 envs <- base::Sys.getenv()
[11:02:36.788]                 names <- names(envs)
[11:02:36.788]                 common <- intersect(names, old_names)
[11:02:36.788]                 added <- setdiff(names, old_names)
[11:02:36.788]                 removed <- setdiff(old_names, names)
[11:02:36.788]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:36.788]                   envs[common]]
[11:02:36.788]                 NAMES <- toupper(changed)
[11:02:36.788]                 args <- list()
[11:02:36.788]                 for (kk in seq_along(NAMES)) {
[11:02:36.788]                   name <- changed[[kk]]
[11:02:36.788]                   NAME <- NAMES[[kk]]
[11:02:36.788]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:36.788]                     next
[11:02:36.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:36.788]                 }
[11:02:36.788]                 NAMES <- toupper(added)
[11:02:36.788]                 for (kk in seq_along(NAMES)) {
[11:02:36.788]                   name <- added[[kk]]
[11:02:36.788]                   NAME <- NAMES[[kk]]
[11:02:36.788]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:36.788]                     next
[11:02:36.788]                   args[[name]] <- ""
[11:02:36.788]                 }
[11:02:36.788]                 NAMES <- toupper(removed)
[11:02:36.788]                 for (kk in seq_along(NAMES)) {
[11:02:36.788]                   name <- removed[[kk]]
[11:02:36.788]                   NAME <- NAMES[[kk]]
[11:02:36.788]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:36.788]                     next
[11:02:36.788]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:36.788]                 }
[11:02:36.788]                 if (length(args) > 0) 
[11:02:36.788]                   base::do.call(base::Sys.setenv, args = args)
[11:02:36.788]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:36.788]             }
[11:02:36.788]             else {
[11:02:36.788]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:36.788]             }
[11:02:36.788]             {
[11:02:36.788]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:36.788]                   0L) {
[11:02:36.788]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:36.788]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:36.788]                   base::options(opts)
[11:02:36.788]                 }
[11:02:36.788]                 {
[11:02:36.788]                   {
[11:02:36.788]                     NULL
[11:02:36.788]                     RNGkind("Mersenne-Twister")
[11:02:36.788]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:36.788]                       inherits = FALSE)
[11:02:36.788]                   }
[11:02:36.788]                   options(future.plan = NULL)
[11:02:36.788]                   if (is.na(NA_character_)) 
[11:02:36.788]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:36.788]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:36.788]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:36.788]                     .init = FALSE)
[11:02:36.788]                 }
[11:02:36.788]             }
[11:02:36.788]         }
[11:02:36.788]     })
[11:02:36.788]     if (TRUE) {
[11:02:36.788]         base::sink(type = "output", split = FALSE)
[11:02:36.788]         if (TRUE) {
[11:02:36.788]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:36.788]         }
[11:02:36.788]         else {
[11:02:36.788]             ...future.result["stdout"] <- base::list(NULL)
[11:02:36.788]         }
[11:02:36.788]         base::close(...future.stdout)
[11:02:36.788]         ...future.stdout <- NULL
[11:02:36.788]     }
[11:02:36.788]     ...future.result$conditions <- ...future.conditions
[11:02:36.788]     ...future.result$finished <- base::Sys.time()
[11:02:36.788]     ...future.result
[11:02:36.788] }
[11:02:36.790] assign_globals() ...
[11:02:36.790] List of 1
[11:02:36.790]  $ kk: int 1
[11:02:36.790]  - attr(*, "where")=List of 1
[11:02:36.790]   ..$ kk:<environment: R_EmptyEnv> 
[11:02:36.790]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:02:36.790]  - attr(*, "resolved")= logi FALSE
[11:02:36.790]  - attr(*, "total_size")= num 35
[11:02:36.790]  - attr(*, "already-done")= logi TRUE
[11:02:36.794] - copied ‘kk’ to environment
[11:02:36.794] assign_globals() ... done
[11:02:36.794] plan(): Setting new future strategy stack:
[11:02:36.794] List of future strategies:
[11:02:36.794] 1. sequential:
[11:02:36.794]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:36.794]    - tweaked: FALSE
[11:02:36.794]    - call: NULL
[11:02:36.795] plan(): nbrOfWorkers() = 1
[11:02:36.896] plan(): Setting new future strategy stack:
[11:02:36.896] List of future strategies:
[11:02:36.896] 1. sequential:
[11:02:36.896]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:36.896]    - tweaked: FALSE
[11:02:36.896]    - call: plan(strategy)
[11:02:36.896] plan(): nbrOfWorkers() = 1
[11:02:36.897] SequentialFuture started (and completed)
[11:02:36.897] - Launch lazy future ... done
[11:02:36.897] run() for ‘SequentialFuture’ ... done
[11:02:36.897] getGlobalsAndPackages() ...
[11:02:36.897] Searching for globals...
[11:02:36.898] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[11:02:36.898] Searching for globals ... DONE
[11:02:36.898] Resolving globals: FALSE
[11:02:36.898] The total size of the 1 globals is 35 bytes (35 bytes)
[11:02:36.899] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[11:02:36.899] - globals: [1] ‘kk’
[11:02:36.899] 
[11:02:36.899] getGlobalsAndPackages() ... DONE
[11:02:36.899] run() for ‘Future’ ...
[11:02:36.899] - state: ‘created’
[11:02:36.899] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:02:36.900] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:36.900] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:36.900]   - Field: ‘label’
[11:02:36.900]   - Field: ‘local’
[11:02:36.900]   - Field: ‘owner’
[11:02:36.900]   - Field: ‘envir’
[11:02:36.900]   - Field: ‘packages’
[11:02:36.900]   - Field: ‘gc’
[11:02:36.900]   - Field: ‘conditions’
[11:02:36.900]   - Field: ‘expr’
[11:02:36.901]   - Field: ‘uuid’
[11:02:36.901]   - Field: ‘seed’
[11:02:36.901]   - Field: ‘version’
[11:02:36.901]   - Field: ‘result’
[11:02:36.901]   - Field: ‘asynchronous’
[11:02:36.901]   - Field: ‘calls’
[11:02:36.901]   - Field: ‘globals’
[11:02:36.901]   - Field: ‘stdout’
[11:02:36.901]   - Field: ‘earlySignal’
[11:02:36.901]   - Field: ‘lazy’
[11:02:36.901]   - Field: ‘state’
[11:02:36.901] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:36.902] - Launch lazy future ...
[11:02:36.902] Packages needed by the future expression (n = 0): <none>
[11:02:36.902] Packages needed by future strategies (n = 0): <none>
[11:02:36.902] {
[11:02:36.902]     {
[11:02:36.902]         {
[11:02:36.902]             ...future.startTime <- base::Sys.time()
[11:02:36.902]             {
[11:02:36.902]                 {
[11:02:36.902]                   {
[11:02:36.902]                     base::local({
[11:02:36.902]                       has_future <- base::requireNamespace("future", 
[11:02:36.902]                         quietly = TRUE)
[11:02:36.902]                       if (has_future) {
[11:02:36.902]                         ns <- base::getNamespace("future")
[11:02:36.902]                         version <- ns[[".package"]][["version"]]
[11:02:36.902]                         if (is.null(version)) 
[11:02:36.902]                           version <- utils::packageVersion("future")
[11:02:36.902]                       }
[11:02:36.902]                       else {
[11:02:36.902]                         version <- NULL
[11:02:36.902]                       }
[11:02:36.902]                       if (!has_future || version < "1.8.0") {
[11:02:36.902]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:36.902]                           "", base::R.version$version.string), 
[11:02:36.902]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:36.902]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:36.902]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:36.902]                             "release", "version")], collapse = " "), 
[11:02:36.902]                           hostname = base::Sys.info()[["nodename"]])
[11:02:36.902]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:36.902]                           info)
[11:02:36.902]                         info <- base::paste(info, collapse = "; ")
[11:02:36.902]                         if (!has_future) {
[11:02:36.902]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:36.902]                             info)
[11:02:36.902]                         }
[11:02:36.902]                         else {
[11:02:36.902]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:36.902]                             info, version)
[11:02:36.902]                         }
[11:02:36.902]                         base::stop(msg)
[11:02:36.902]                       }
[11:02:36.902]                     })
[11:02:36.902]                   }
[11:02:36.902]                   ...future.strategy.old <- future::plan("list")
[11:02:36.902]                   options(future.plan = NULL)
[11:02:36.902]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:36.902]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:36.902]                 }
[11:02:36.902]                 ...future.workdir <- getwd()
[11:02:36.902]             }
[11:02:36.902]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:36.902]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:36.902]         }
[11:02:36.902]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:36.902]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:36.902]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:36.902]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:36.902]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:36.902]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:36.902]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:36.902]             base::names(...future.oldOptions))
[11:02:36.902]     }
[11:02:36.902]     if (FALSE) {
[11:02:36.902]     }
[11:02:36.902]     else {
[11:02:36.902]         if (TRUE) {
[11:02:36.902]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:36.902]                 open = "w")
[11:02:36.902]         }
[11:02:36.902]         else {
[11:02:36.902]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:36.902]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:36.902]         }
[11:02:36.902]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:36.902]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:36.902]             base::sink(type = "output", split = FALSE)
[11:02:36.902]             base::close(...future.stdout)
[11:02:36.902]         }, add = TRUE)
[11:02:36.902]     }
[11:02:36.902]     ...future.frame <- base::sys.nframe()
[11:02:36.902]     ...future.conditions <- base::list()
[11:02:36.902]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:36.902]     if (FALSE) {
[11:02:36.902]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:36.902]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:36.902]     }
[11:02:36.902]     ...future.result <- base::tryCatch({
[11:02:36.902]         base::withCallingHandlers({
[11:02:36.902]             ...future.value <- base::withVisible(base::local({
[11:02:36.902]                 Sys.sleep(0.1)
[11:02:36.902]                 kk
[11:02:36.902]             }))
[11:02:36.902]             future::FutureResult(value = ...future.value$value, 
[11:02:36.902]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:36.902]                   ...future.rng), globalenv = if (FALSE) 
[11:02:36.902]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:36.902]                     ...future.globalenv.names))
[11:02:36.902]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:36.902]         }, condition = base::local({
[11:02:36.902]             c <- base::c
[11:02:36.902]             inherits <- base::inherits
[11:02:36.902]             invokeRestart <- base::invokeRestart
[11:02:36.902]             length <- base::length
[11:02:36.902]             list <- base::list
[11:02:36.902]             seq.int <- base::seq.int
[11:02:36.902]             signalCondition <- base::signalCondition
[11:02:36.902]             sys.calls <- base::sys.calls
[11:02:36.902]             `[[` <- base::`[[`
[11:02:36.902]             `+` <- base::`+`
[11:02:36.902]             `<<-` <- base::`<<-`
[11:02:36.902]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:36.902]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:36.902]                   3L)]
[11:02:36.902]             }
[11:02:36.902]             function(cond) {
[11:02:36.902]                 is_error <- inherits(cond, "error")
[11:02:36.902]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:36.902]                   NULL)
[11:02:36.902]                 if (is_error) {
[11:02:36.902]                   sessionInformation <- function() {
[11:02:36.902]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:36.902]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:36.902]                       search = base::search(), system = base::Sys.info())
[11:02:36.902]                   }
[11:02:36.902]                   ...future.conditions[[length(...future.conditions) + 
[11:02:36.902]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:36.902]                     cond$call), session = sessionInformation(), 
[11:02:36.902]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:36.902]                   signalCondition(cond)
[11:02:36.902]                 }
[11:02:36.902]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:36.902]                 "immediateCondition"))) {
[11:02:36.902]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:36.902]                   ...future.conditions[[length(...future.conditions) + 
[11:02:36.902]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:36.902]                   if (TRUE && !signal) {
[11:02:36.902]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:36.902]                     {
[11:02:36.902]                       inherits <- base::inherits
[11:02:36.902]                       invokeRestart <- base::invokeRestart
[11:02:36.902]                       is.null <- base::is.null
[11:02:36.902]                       muffled <- FALSE
[11:02:36.902]                       if (inherits(cond, "message")) {
[11:02:36.902]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:36.902]                         if (muffled) 
[11:02:36.902]                           invokeRestart("muffleMessage")
[11:02:36.902]                       }
[11:02:36.902]                       else if (inherits(cond, "warning")) {
[11:02:36.902]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:36.902]                         if (muffled) 
[11:02:36.902]                           invokeRestart("muffleWarning")
[11:02:36.902]                       }
[11:02:36.902]                       else if (inherits(cond, "condition")) {
[11:02:36.902]                         if (!is.null(pattern)) {
[11:02:36.902]                           computeRestarts <- base::computeRestarts
[11:02:36.902]                           grepl <- base::grepl
[11:02:36.902]                           restarts <- computeRestarts(cond)
[11:02:36.902]                           for (restart in restarts) {
[11:02:36.902]                             name <- restart$name
[11:02:36.902]                             if (is.null(name)) 
[11:02:36.902]                               next
[11:02:36.902]                             if (!grepl(pattern, name)) 
[11:02:36.902]                               next
[11:02:36.902]                             invokeRestart(restart)
[11:02:36.902]                             muffled <- TRUE
[11:02:36.902]                             break
[11:02:36.902]                           }
[11:02:36.902]                         }
[11:02:36.902]                       }
[11:02:36.902]                       invisible(muffled)
[11:02:36.902]                     }
[11:02:36.902]                     muffleCondition(cond, pattern = "^muffle")
[11:02:36.902]                   }
[11:02:36.902]                 }
[11:02:36.902]                 else {
[11:02:36.902]                   if (TRUE) {
[11:02:36.902]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:36.902]                     {
[11:02:36.902]                       inherits <- base::inherits
[11:02:36.902]                       invokeRestart <- base::invokeRestart
[11:02:36.902]                       is.null <- base::is.null
[11:02:36.902]                       muffled <- FALSE
[11:02:36.902]                       if (inherits(cond, "message")) {
[11:02:36.902]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:36.902]                         if (muffled) 
[11:02:36.902]                           invokeRestart("muffleMessage")
[11:02:36.902]                       }
[11:02:36.902]                       else if (inherits(cond, "warning")) {
[11:02:36.902]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:36.902]                         if (muffled) 
[11:02:36.902]                           invokeRestart("muffleWarning")
[11:02:36.902]                       }
[11:02:36.902]                       else if (inherits(cond, "condition")) {
[11:02:36.902]                         if (!is.null(pattern)) {
[11:02:36.902]                           computeRestarts <- base::computeRestarts
[11:02:36.902]                           grepl <- base::grepl
[11:02:36.902]                           restarts <- computeRestarts(cond)
[11:02:36.902]                           for (restart in restarts) {
[11:02:36.902]                             name <- restart$name
[11:02:36.902]                             if (is.null(name)) 
[11:02:36.902]                               next
[11:02:36.902]                             if (!grepl(pattern, name)) 
[11:02:36.902]                               next
[11:02:36.902]                             invokeRestart(restart)
[11:02:36.902]                             muffled <- TRUE
[11:02:36.902]                             break
[11:02:36.902]                           }
[11:02:36.902]                         }
[11:02:36.902]                       }
[11:02:36.902]                       invisible(muffled)
[11:02:36.902]                     }
[11:02:36.902]                     muffleCondition(cond, pattern = "^muffle")
[11:02:36.902]                   }
[11:02:36.902]                 }
[11:02:36.902]             }
[11:02:36.902]         }))
[11:02:36.902]     }, error = function(ex) {
[11:02:36.902]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:36.902]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:36.902]                 ...future.rng), started = ...future.startTime, 
[11:02:36.902]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:36.902]             version = "1.8"), class = "FutureResult")
[11:02:36.902]     }, finally = {
[11:02:36.902]         if (!identical(...future.workdir, getwd())) 
[11:02:36.902]             setwd(...future.workdir)
[11:02:36.902]         {
[11:02:36.902]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:36.902]                 ...future.oldOptions$nwarnings <- NULL
[11:02:36.902]             }
[11:02:36.902]             base::options(...future.oldOptions)
[11:02:36.902]             if (.Platform$OS.type == "windows") {
[11:02:36.902]                 old_names <- names(...future.oldEnvVars)
[11:02:36.902]                 envs <- base::Sys.getenv()
[11:02:36.902]                 names <- names(envs)
[11:02:36.902]                 common <- intersect(names, old_names)
[11:02:36.902]                 added <- setdiff(names, old_names)
[11:02:36.902]                 removed <- setdiff(old_names, names)
[11:02:36.902]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:36.902]                   envs[common]]
[11:02:36.902]                 NAMES <- toupper(changed)
[11:02:36.902]                 args <- list()
[11:02:36.902]                 for (kk in seq_along(NAMES)) {
[11:02:36.902]                   name <- changed[[kk]]
[11:02:36.902]                   NAME <- NAMES[[kk]]
[11:02:36.902]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:36.902]                     next
[11:02:36.902]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:36.902]                 }
[11:02:36.902]                 NAMES <- toupper(added)
[11:02:36.902]                 for (kk in seq_along(NAMES)) {
[11:02:36.902]                   name <- added[[kk]]
[11:02:36.902]                   NAME <- NAMES[[kk]]
[11:02:36.902]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:36.902]                     next
[11:02:36.902]                   args[[name]] <- ""
[11:02:36.902]                 }
[11:02:36.902]                 NAMES <- toupper(removed)
[11:02:36.902]                 for (kk in seq_along(NAMES)) {
[11:02:36.902]                   name <- removed[[kk]]
[11:02:36.902]                   NAME <- NAMES[[kk]]
[11:02:36.902]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:36.902]                     next
[11:02:36.902]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:36.902]                 }
[11:02:36.902]                 if (length(args) > 0) 
[11:02:36.902]                   base::do.call(base::Sys.setenv, args = args)
[11:02:36.902]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:36.902]             }
[11:02:36.902]             else {
[11:02:36.902]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:36.902]             }
[11:02:36.902]             {
[11:02:36.902]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:36.902]                   0L) {
[11:02:36.902]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:36.902]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:36.902]                   base::options(opts)
[11:02:36.902]                 }
[11:02:36.902]                 {
[11:02:36.902]                   {
[11:02:36.902]                     NULL
[11:02:36.902]                     RNGkind("Mersenne-Twister")
[11:02:36.902]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:36.902]                       inherits = FALSE)
[11:02:36.902]                   }
[11:02:36.902]                   options(future.plan = NULL)
[11:02:36.902]                   if (is.na(NA_character_)) 
[11:02:36.902]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:36.902]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:36.902]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:36.902]                     .init = FALSE)
[11:02:36.902]                 }
[11:02:36.902]             }
[11:02:36.902]         }
[11:02:36.902]     })
[11:02:36.902]     if (TRUE) {
[11:02:36.902]         base::sink(type = "output", split = FALSE)
[11:02:36.902]         if (TRUE) {
[11:02:36.902]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:36.902]         }
[11:02:36.902]         else {
[11:02:36.902]             ...future.result["stdout"] <- base::list(NULL)
[11:02:36.902]         }
[11:02:36.902]         base::close(...future.stdout)
[11:02:36.902]         ...future.stdout <- NULL
[11:02:36.902]     }
[11:02:36.902]     ...future.result$conditions <- ...future.conditions
[11:02:36.902]     ...future.result$finished <- base::Sys.time()
[11:02:36.902]     ...future.result
[11:02:36.902] }
[11:02:36.904] assign_globals() ...
[11:02:36.904] List of 1
[11:02:36.904]  $ kk: int 2
[11:02:36.904]  - attr(*, "where")=List of 1
[11:02:36.904]   ..$ kk:<environment: R_EmptyEnv> 
[11:02:36.904]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:02:36.904]  - attr(*, "resolved")= logi FALSE
[11:02:36.904]  - attr(*, "total_size")= num 35
[11:02:36.904]  - attr(*, "already-done")= logi TRUE
[11:02:36.906] - copied ‘kk’ to environment
[11:02:36.906] assign_globals() ... done
[11:02:36.906] plan(): Setting new future strategy stack:
[11:02:36.907] List of future strategies:
[11:02:36.907] 1. sequential:
[11:02:36.907]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:36.907]    - tweaked: FALSE
[11:02:36.907]    - call: NULL
[11:02:36.907] plan(): nbrOfWorkers() = 1
[11:02:37.009] plan(): Setting new future strategy stack:
[11:02:37.010] List of future strategies:
[11:02:37.010] 1. sequential:
[11:02:37.010]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:37.010]    - tweaked: FALSE
[11:02:37.010]    - call: plan(strategy)
[11:02:37.010] plan(): nbrOfWorkers() = 1
[11:02:37.010] SequentialFuture started (and completed)
[11:02:37.011] - Launch lazy future ... done
[11:02:37.011] run() for ‘SequentialFuture’ ... done
[11:02:37.011] getGlobalsAndPackages() ...
[11:02:37.011] Searching for globals...
[11:02:37.012] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[11:02:37.012] Searching for globals ... DONE
[11:02:37.012] Resolving globals: FALSE
[11:02:37.012] The total size of the 1 globals is 35 bytes (35 bytes)
[11:02:37.013] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[11:02:37.013] - globals: [1] ‘kk’
[11:02:37.013] 
[11:02:37.013] getGlobalsAndPackages() ... DONE
[11:02:37.013] run() for ‘Future’ ...
[11:02:37.013] - state: ‘created’
[11:02:37.013] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:02:37.013] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:37.014] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:37.014]   - Field: ‘label’
[11:02:37.014]   - Field: ‘local’
[11:02:37.014]   - Field: ‘owner’
[11:02:37.014]   - Field: ‘envir’
[11:02:37.014]   - Field: ‘packages’
[11:02:37.014]   - Field: ‘gc’
[11:02:37.014]   - Field: ‘conditions’
[11:02:37.014]   - Field: ‘expr’
[11:02:37.014]   - Field: ‘uuid’
[11:02:37.014]   - Field: ‘seed’
[11:02:37.015]   - Field: ‘version’
[11:02:37.015]   - Field: ‘result’
[11:02:37.015]   - Field: ‘asynchronous’
[11:02:37.015]   - Field: ‘calls’
[11:02:37.015]   - Field: ‘globals’
[11:02:37.015]   - Field: ‘stdout’
[11:02:37.015]   - Field: ‘earlySignal’
[11:02:37.015]   - Field: ‘lazy’
[11:02:37.015]   - Field: ‘state’
[11:02:37.015] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:37.015] - Launch lazy future ...
[11:02:37.016] Packages needed by the future expression (n = 0): <none>
[11:02:37.016] Packages needed by future strategies (n = 0): <none>
[11:02:37.016] {
[11:02:37.016]     {
[11:02:37.016]         {
[11:02:37.016]             ...future.startTime <- base::Sys.time()
[11:02:37.016]             {
[11:02:37.016]                 {
[11:02:37.016]                   {
[11:02:37.016]                     base::local({
[11:02:37.016]                       has_future <- base::requireNamespace("future", 
[11:02:37.016]                         quietly = TRUE)
[11:02:37.016]                       if (has_future) {
[11:02:37.016]                         ns <- base::getNamespace("future")
[11:02:37.016]                         version <- ns[[".package"]][["version"]]
[11:02:37.016]                         if (is.null(version)) 
[11:02:37.016]                           version <- utils::packageVersion("future")
[11:02:37.016]                       }
[11:02:37.016]                       else {
[11:02:37.016]                         version <- NULL
[11:02:37.016]                       }
[11:02:37.016]                       if (!has_future || version < "1.8.0") {
[11:02:37.016]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:37.016]                           "", base::R.version$version.string), 
[11:02:37.016]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:37.016]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:37.016]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:37.016]                             "release", "version")], collapse = " "), 
[11:02:37.016]                           hostname = base::Sys.info()[["nodename"]])
[11:02:37.016]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:37.016]                           info)
[11:02:37.016]                         info <- base::paste(info, collapse = "; ")
[11:02:37.016]                         if (!has_future) {
[11:02:37.016]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:37.016]                             info)
[11:02:37.016]                         }
[11:02:37.016]                         else {
[11:02:37.016]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:37.016]                             info, version)
[11:02:37.016]                         }
[11:02:37.016]                         base::stop(msg)
[11:02:37.016]                       }
[11:02:37.016]                     })
[11:02:37.016]                   }
[11:02:37.016]                   ...future.strategy.old <- future::plan("list")
[11:02:37.016]                   options(future.plan = NULL)
[11:02:37.016]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:37.016]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:37.016]                 }
[11:02:37.016]                 ...future.workdir <- getwd()
[11:02:37.016]             }
[11:02:37.016]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:37.016]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:37.016]         }
[11:02:37.016]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:37.016]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:37.016]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:37.016]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:37.016]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:37.016]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:37.016]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:37.016]             base::names(...future.oldOptions))
[11:02:37.016]     }
[11:02:37.016]     if (FALSE) {
[11:02:37.016]     }
[11:02:37.016]     else {
[11:02:37.016]         if (TRUE) {
[11:02:37.016]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:37.016]                 open = "w")
[11:02:37.016]         }
[11:02:37.016]         else {
[11:02:37.016]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:37.016]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:37.016]         }
[11:02:37.016]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:37.016]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:37.016]             base::sink(type = "output", split = FALSE)
[11:02:37.016]             base::close(...future.stdout)
[11:02:37.016]         }, add = TRUE)
[11:02:37.016]     }
[11:02:37.016]     ...future.frame <- base::sys.nframe()
[11:02:37.016]     ...future.conditions <- base::list()
[11:02:37.016]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:37.016]     if (FALSE) {
[11:02:37.016]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:37.016]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:37.016]     }
[11:02:37.016]     ...future.result <- base::tryCatch({
[11:02:37.016]         base::withCallingHandlers({
[11:02:37.016]             ...future.value <- base::withVisible(base::local({
[11:02:37.016]                 Sys.sleep(0.1)
[11:02:37.016]                 kk
[11:02:37.016]             }))
[11:02:37.016]             future::FutureResult(value = ...future.value$value, 
[11:02:37.016]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:37.016]                   ...future.rng), globalenv = if (FALSE) 
[11:02:37.016]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:37.016]                     ...future.globalenv.names))
[11:02:37.016]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:37.016]         }, condition = base::local({
[11:02:37.016]             c <- base::c
[11:02:37.016]             inherits <- base::inherits
[11:02:37.016]             invokeRestart <- base::invokeRestart
[11:02:37.016]             length <- base::length
[11:02:37.016]             list <- base::list
[11:02:37.016]             seq.int <- base::seq.int
[11:02:37.016]             signalCondition <- base::signalCondition
[11:02:37.016]             sys.calls <- base::sys.calls
[11:02:37.016]             `[[` <- base::`[[`
[11:02:37.016]             `+` <- base::`+`
[11:02:37.016]             `<<-` <- base::`<<-`
[11:02:37.016]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:37.016]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:37.016]                   3L)]
[11:02:37.016]             }
[11:02:37.016]             function(cond) {
[11:02:37.016]                 is_error <- inherits(cond, "error")
[11:02:37.016]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:37.016]                   NULL)
[11:02:37.016]                 if (is_error) {
[11:02:37.016]                   sessionInformation <- function() {
[11:02:37.016]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:37.016]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:37.016]                       search = base::search(), system = base::Sys.info())
[11:02:37.016]                   }
[11:02:37.016]                   ...future.conditions[[length(...future.conditions) + 
[11:02:37.016]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:37.016]                     cond$call), session = sessionInformation(), 
[11:02:37.016]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:37.016]                   signalCondition(cond)
[11:02:37.016]                 }
[11:02:37.016]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:37.016]                 "immediateCondition"))) {
[11:02:37.016]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:37.016]                   ...future.conditions[[length(...future.conditions) + 
[11:02:37.016]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:37.016]                   if (TRUE && !signal) {
[11:02:37.016]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:37.016]                     {
[11:02:37.016]                       inherits <- base::inherits
[11:02:37.016]                       invokeRestart <- base::invokeRestart
[11:02:37.016]                       is.null <- base::is.null
[11:02:37.016]                       muffled <- FALSE
[11:02:37.016]                       if (inherits(cond, "message")) {
[11:02:37.016]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:37.016]                         if (muffled) 
[11:02:37.016]                           invokeRestart("muffleMessage")
[11:02:37.016]                       }
[11:02:37.016]                       else if (inherits(cond, "warning")) {
[11:02:37.016]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:37.016]                         if (muffled) 
[11:02:37.016]                           invokeRestart("muffleWarning")
[11:02:37.016]                       }
[11:02:37.016]                       else if (inherits(cond, "condition")) {
[11:02:37.016]                         if (!is.null(pattern)) {
[11:02:37.016]                           computeRestarts <- base::computeRestarts
[11:02:37.016]                           grepl <- base::grepl
[11:02:37.016]                           restarts <- computeRestarts(cond)
[11:02:37.016]                           for (restart in restarts) {
[11:02:37.016]                             name <- restart$name
[11:02:37.016]                             if (is.null(name)) 
[11:02:37.016]                               next
[11:02:37.016]                             if (!grepl(pattern, name)) 
[11:02:37.016]                               next
[11:02:37.016]                             invokeRestart(restart)
[11:02:37.016]                             muffled <- TRUE
[11:02:37.016]                             break
[11:02:37.016]                           }
[11:02:37.016]                         }
[11:02:37.016]                       }
[11:02:37.016]                       invisible(muffled)
[11:02:37.016]                     }
[11:02:37.016]                     muffleCondition(cond, pattern = "^muffle")
[11:02:37.016]                   }
[11:02:37.016]                 }
[11:02:37.016]                 else {
[11:02:37.016]                   if (TRUE) {
[11:02:37.016]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:37.016]                     {
[11:02:37.016]                       inherits <- base::inherits
[11:02:37.016]                       invokeRestart <- base::invokeRestart
[11:02:37.016]                       is.null <- base::is.null
[11:02:37.016]                       muffled <- FALSE
[11:02:37.016]                       if (inherits(cond, "message")) {
[11:02:37.016]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:37.016]                         if (muffled) 
[11:02:37.016]                           invokeRestart("muffleMessage")
[11:02:37.016]                       }
[11:02:37.016]                       else if (inherits(cond, "warning")) {
[11:02:37.016]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:37.016]                         if (muffled) 
[11:02:37.016]                           invokeRestart("muffleWarning")
[11:02:37.016]                       }
[11:02:37.016]                       else if (inherits(cond, "condition")) {
[11:02:37.016]                         if (!is.null(pattern)) {
[11:02:37.016]                           computeRestarts <- base::computeRestarts
[11:02:37.016]                           grepl <- base::grepl
[11:02:37.016]                           restarts <- computeRestarts(cond)
[11:02:37.016]                           for (restart in restarts) {
[11:02:37.016]                             name <- restart$name
[11:02:37.016]                             if (is.null(name)) 
[11:02:37.016]                               next
[11:02:37.016]                             if (!grepl(pattern, name)) 
[11:02:37.016]                               next
[11:02:37.016]                             invokeRestart(restart)
[11:02:37.016]                             muffled <- TRUE
[11:02:37.016]                             break
[11:02:37.016]                           }
[11:02:37.016]                         }
[11:02:37.016]                       }
[11:02:37.016]                       invisible(muffled)
[11:02:37.016]                     }
[11:02:37.016]                     muffleCondition(cond, pattern = "^muffle")
[11:02:37.016]                   }
[11:02:37.016]                 }
[11:02:37.016]             }
[11:02:37.016]         }))
[11:02:37.016]     }, error = function(ex) {
[11:02:37.016]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:37.016]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:37.016]                 ...future.rng), started = ...future.startTime, 
[11:02:37.016]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:37.016]             version = "1.8"), class = "FutureResult")
[11:02:37.016]     }, finally = {
[11:02:37.016]         if (!identical(...future.workdir, getwd())) 
[11:02:37.016]             setwd(...future.workdir)
[11:02:37.016]         {
[11:02:37.016]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:37.016]                 ...future.oldOptions$nwarnings <- NULL
[11:02:37.016]             }
[11:02:37.016]             base::options(...future.oldOptions)
[11:02:37.016]             if (.Platform$OS.type == "windows") {
[11:02:37.016]                 old_names <- names(...future.oldEnvVars)
[11:02:37.016]                 envs <- base::Sys.getenv()
[11:02:37.016]                 names <- names(envs)
[11:02:37.016]                 common <- intersect(names, old_names)
[11:02:37.016]                 added <- setdiff(names, old_names)
[11:02:37.016]                 removed <- setdiff(old_names, names)
[11:02:37.016]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:37.016]                   envs[common]]
[11:02:37.016]                 NAMES <- toupper(changed)
[11:02:37.016]                 args <- list()
[11:02:37.016]                 for (kk in seq_along(NAMES)) {
[11:02:37.016]                   name <- changed[[kk]]
[11:02:37.016]                   NAME <- NAMES[[kk]]
[11:02:37.016]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.016]                     next
[11:02:37.016]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:37.016]                 }
[11:02:37.016]                 NAMES <- toupper(added)
[11:02:37.016]                 for (kk in seq_along(NAMES)) {
[11:02:37.016]                   name <- added[[kk]]
[11:02:37.016]                   NAME <- NAMES[[kk]]
[11:02:37.016]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.016]                     next
[11:02:37.016]                   args[[name]] <- ""
[11:02:37.016]                 }
[11:02:37.016]                 NAMES <- toupper(removed)
[11:02:37.016]                 for (kk in seq_along(NAMES)) {
[11:02:37.016]                   name <- removed[[kk]]
[11:02:37.016]                   NAME <- NAMES[[kk]]
[11:02:37.016]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.016]                     next
[11:02:37.016]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:37.016]                 }
[11:02:37.016]                 if (length(args) > 0) 
[11:02:37.016]                   base::do.call(base::Sys.setenv, args = args)
[11:02:37.016]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:37.016]             }
[11:02:37.016]             else {
[11:02:37.016]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:37.016]             }
[11:02:37.016]             {
[11:02:37.016]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:37.016]                   0L) {
[11:02:37.016]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:37.016]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:37.016]                   base::options(opts)
[11:02:37.016]                 }
[11:02:37.016]                 {
[11:02:37.016]                   {
[11:02:37.016]                     NULL
[11:02:37.016]                     RNGkind("Mersenne-Twister")
[11:02:37.016]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:37.016]                       inherits = FALSE)
[11:02:37.016]                   }
[11:02:37.016]                   options(future.plan = NULL)
[11:02:37.016]                   if (is.na(NA_character_)) 
[11:02:37.016]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:37.016]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:37.016]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:37.016]                     .init = FALSE)
[11:02:37.016]                 }
[11:02:37.016]             }
[11:02:37.016]         }
[11:02:37.016]     })
[11:02:37.016]     if (TRUE) {
[11:02:37.016]         base::sink(type = "output", split = FALSE)
[11:02:37.016]         if (TRUE) {
[11:02:37.016]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:37.016]         }
[11:02:37.016]         else {
[11:02:37.016]             ...future.result["stdout"] <- base::list(NULL)
[11:02:37.016]         }
[11:02:37.016]         base::close(...future.stdout)
[11:02:37.016]         ...future.stdout <- NULL
[11:02:37.016]     }
[11:02:37.016]     ...future.result$conditions <- ...future.conditions
[11:02:37.016]     ...future.result$finished <- base::Sys.time()
[11:02:37.016]     ...future.result
[11:02:37.016] }
[11:02:37.018] assign_globals() ...
[11:02:37.018] List of 1
[11:02:37.018]  $ kk: int 3
[11:02:37.018]  - attr(*, "where")=List of 1
[11:02:37.018]   ..$ kk:<environment: R_EmptyEnv> 
[11:02:37.018]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:02:37.018]  - attr(*, "resolved")= logi FALSE
[11:02:37.018]  - attr(*, "total_size")= num 35
[11:02:37.018]  - attr(*, "already-done")= logi TRUE
[11:02:37.020] - copied ‘kk’ to environment
[11:02:37.020] assign_globals() ... done
[11:02:37.020] plan(): Setting new future strategy stack:
[11:02:37.020] List of future strategies:
[11:02:37.020] 1. sequential:
[11:02:37.020]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:37.020]    - tweaked: FALSE
[11:02:37.020]    - call: NULL
[11:02:37.021] plan(): nbrOfWorkers() = 1
[11:02:37.122] plan(): Setting new future strategy stack:
[11:02:37.122] List of future strategies:
[11:02:37.122] 1. sequential:
[11:02:37.122]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:37.122]    - tweaked: FALSE
[11:02:37.122]    - call: plan(strategy)
[11:02:37.122] plan(): nbrOfWorkers() = 1
[11:02:37.123] SequentialFuture started (and completed)
[11:02:37.123] - Launch lazy future ... done
[11:02:37.123] run() for ‘SequentialFuture’ ... done
[11:02:37.123] resolve() on list ...
[11:02:37.123]  recursive: 0
[11:02:37.123]  length: 3
[11:02:37.123] 
[11:02:37.123] resolved() for ‘SequentialFuture’ ...
[11:02:37.123] - state: ‘finished’
[11:02:37.123] - run: TRUE
[11:02:37.124] - result: ‘FutureResult’
[11:02:37.124] resolved() for ‘SequentialFuture’ ... done
[11:02:37.124] Future #1
[11:02:37.124]  length: 2 (resolved future 1)
[11:02:37.124] resolved() for ‘SequentialFuture’ ...
[11:02:37.124] - state: ‘finished’
[11:02:37.124] - run: TRUE
[11:02:37.124] - result: ‘FutureResult’
[11:02:37.124] resolved() for ‘SequentialFuture’ ... done
[11:02:37.124] Future #2
[11:02:37.124]  length: 1 (resolved future 2)
[11:02:37.125] resolved() for ‘SequentialFuture’ ...
[11:02:37.125] - state: ‘finished’
[11:02:37.125] - run: TRUE
[11:02:37.125] - result: ‘FutureResult’
[11:02:37.125] resolved() for ‘SequentialFuture’ ... done
[11:02:37.125] Future #3
[11:02:37.125]  length: 0 (resolved future 3)
[11:02:37.125] resolve() on list ... DONE
[11:02:37.125] getGlobalsAndPackages() ...
[11:02:37.125] Searching for globals...
[11:02:37.126] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[11:02:37.126] Searching for globals ... DONE
[11:02:37.126] Resolving globals: FALSE
[11:02:37.127] The total size of the 1 globals is 35 bytes (35 bytes)
[11:02:37.127] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[11:02:37.127] - globals: [1] ‘kk’
[11:02:37.127] 
[11:02:37.127] getGlobalsAndPackages() ... DONE
[11:02:37.127] getGlobalsAndPackages() ...
[11:02:37.128] Searching for globals...
[11:02:37.128] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[11:02:37.128] Searching for globals ... DONE
[11:02:37.129] Resolving globals: FALSE
[11:02:37.129] The total size of the 1 globals is 35 bytes (35 bytes)
[11:02:37.129] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[11:02:37.129] - globals: [1] ‘kk’
[11:02:37.129] 
[11:02:37.129] getGlobalsAndPackages() ... DONE
[11:02:37.130] getGlobalsAndPackages() ...
[11:02:37.130] Searching for globals...
[11:02:37.131] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[11:02:37.131] Searching for globals ... DONE
[11:02:37.131] Resolving globals: FALSE
[11:02:37.131] The total size of the 1 globals is 35 bytes (35 bytes)
[11:02:37.131] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[11:02:37.131] - globals: [1] ‘kk’
[11:02:37.132] 
[11:02:37.132] getGlobalsAndPackages() ... DONE
[11:02:37.132] resolve() on list ...
[11:02:37.132]  recursive: 0
[11:02:37.132]  length: 3
[11:02:37.132] 
[11:02:37.132] run() for ‘Future’ ...
[11:02:37.132] - state: ‘created’
[11:02:37.132] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:02:37.133] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:37.133] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:37.133]   - Field: ‘label’
[11:02:37.133]   - Field: ‘local’
[11:02:37.133]   - Field: ‘owner’
[11:02:37.133]   - Field: ‘envir’
[11:02:37.133]   - Field: ‘packages’
[11:02:37.133]   - Field: ‘gc’
[11:02:37.134]   - Field: ‘conditions’
[11:02:37.134]   - Field: ‘expr’
[11:02:37.135]   - Field: ‘uuid’
[11:02:37.135]   - Field: ‘seed’
[11:02:37.135]   - Field: ‘version’
[11:02:37.135]   - Field: ‘result’
[11:02:37.135]   - Field: ‘asynchronous’
[11:02:37.135]   - Field: ‘calls’
[11:02:37.135]   - Field: ‘globals’
[11:02:37.135]   - Field: ‘stdout’
[11:02:37.135]   - Field: ‘earlySignal’
[11:02:37.135]   - Field: ‘lazy’
[11:02:37.135]   - Field: ‘state’
[11:02:37.135] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:37.136] - Launch lazy future ...
[11:02:37.136] Packages needed by the future expression (n = 0): <none>
[11:02:37.136] Packages needed by future strategies (n = 0): <none>
[11:02:37.136] {
[11:02:37.136]     {
[11:02:37.136]         {
[11:02:37.136]             ...future.startTime <- base::Sys.time()
[11:02:37.136]             {
[11:02:37.136]                 {
[11:02:37.136]                   {
[11:02:37.136]                     base::local({
[11:02:37.136]                       has_future <- base::requireNamespace("future", 
[11:02:37.136]                         quietly = TRUE)
[11:02:37.136]                       if (has_future) {
[11:02:37.136]                         ns <- base::getNamespace("future")
[11:02:37.136]                         version <- ns[[".package"]][["version"]]
[11:02:37.136]                         if (is.null(version)) 
[11:02:37.136]                           version <- utils::packageVersion("future")
[11:02:37.136]                       }
[11:02:37.136]                       else {
[11:02:37.136]                         version <- NULL
[11:02:37.136]                       }
[11:02:37.136]                       if (!has_future || version < "1.8.0") {
[11:02:37.136]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:37.136]                           "", base::R.version$version.string), 
[11:02:37.136]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:37.136]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:37.136]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:37.136]                             "release", "version")], collapse = " "), 
[11:02:37.136]                           hostname = base::Sys.info()[["nodename"]])
[11:02:37.136]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:37.136]                           info)
[11:02:37.136]                         info <- base::paste(info, collapse = "; ")
[11:02:37.136]                         if (!has_future) {
[11:02:37.136]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:37.136]                             info)
[11:02:37.136]                         }
[11:02:37.136]                         else {
[11:02:37.136]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:37.136]                             info, version)
[11:02:37.136]                         }
[11:02:37.136]                         base::stop(msg)
[11:02:37.136]                       }
[11:02:37.136]                     })
[11:02:37.136]                   }
[11:02:37.136]                   ...future.strategy.old <- future::plan("list")
[11:02:37.136]                   options(future.plan = NULL)
[11:02:37.136]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:37.136]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:37.136]                 }
[11:02:37.136]                 ...future.workdir <- getwd()
[11:02:37.136]             }
[11:02:37.136]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:37.136]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:37.136]         }
[11:02:37.136]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:37.136]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:37.136]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:37.136]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:37.136]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:37.136]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:37.136]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:37.136]             base::names(...future.oldOptions))
[11:02:37.136]     }
[11:02:37.136]     if (FALSE) {
[11:02:37.136]     }
[11:02:37.136]     else {
[11:02:37.136]         if (TRUE) {
[11:02:37.136]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:37.136]                 open = "w")
[11:02:37.136]         }
[11:02:37.136]         else {
[11:02:37.136]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:37.136]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:37.136]         }
[11:02:37.136]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:37.136]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:37.136]             base::sink(type = "output", split = FALSE)
[11:02:37.136]             base::close(...future.stdout)
[11:02:37.136]         }, add = TRUE)
[11:02:37.136]     }
[11:02:37.136]     ...future.frame <- base::sys.nframe()
[11:02:37.136]     ...future.conditions <- base::list()
[11:02:37.136]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:37.136]     if (FALSE) {
[11:02:37.136]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:37.136]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:37.136]     }
[11:02:37.136]     ...future.result <- base::tryCatch({
[11:02:37.136]         base::withCallingHandlers({
[11:02:37.136]             ...future.value <- base::withVisible(base::local({
[11:02:37.136]                 Sys.sleep(0.1)
[11:02:37.136]                 kk
[11:02:37.136]             }))
[11:02:37.136]             future::FutureResult(value = ...future.value$value, 
[11:02:37.136]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:37.136]                   ...future.rng), globalenv = if (FALSE) 
[11:02:37.136]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:37.136]                     ...future.globalenv.names))
[11:02:37.136]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:37.136]         }, condition = base::local({
[11:02:37.136]             c <- base::c
[11:02:37.136]             inherits <- base::inherits
[11:02:37.136]             invokeRestart <- base::invokeRestart
[11:02:37.136]             length <- base::length
[11:02:37.136]             list <- base::list
[11:02:37.136]             seq.int <- base::seq.int
[11:02:37.136]             signalCondition <- base::signalCondition
[11:02:37.136]             sys.calls <- base::sys.calls
[11:02:37.136]             `[[` <- base::`[[`
[11:02:37.136]             `+` <- base::`+`
[11:02:37.136]             `<<-` <- base::`<<-`
[11:02:37.136]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:37.136]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:37.136]                   3L)]
[11:02:37.136]             }
[11:02:37.136]             function(cond) {
[11:02:37.136]                 is_error <- inherits(cond, "error")
[11:02:37.136]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:37.136]                   NULL)
[11:02:37.136]                 if (is_error) {
[11:02:37.136]                   sessionInformation <- function() {
[11:02:37.136]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:37.136]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:37.136]                       search = base::search(), system = base::Sys.info())
[11:02:37.136]                   }
[11:02:37.136]                   ...future.conditions[[length(...future.conditions) + 
[11:02:37.136]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:37.136]                     cond$call), session = sessionInformation(), 
[11:02:37.136]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:37.136]                   signalCondition(cond)
[11:02:37.136]                 }
[11:02:37.136]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:37.136]                 "immediateCondition"))) {
[11:02:37.136]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:37.136]                   ...future.conditions[[length(...future.conditions) + 
[11:02:37.136]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:37.136]                   if (TRUE && !signal) {
[11:02:37.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:37.136]                     {
[11:02:37.136]                       inherits <- base::inherits
[11:02:37.136]                       invokeRestart <- base::invokeRestart
[11:02:37.136]                       is.null <- base::is.null
[11:02:37.136]                       muffled <- FALSE
[11:02:37.136]                       if (inherits(cond, "message")) {
[11:02:37.136]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:37.136]                         if (muffled) 
[11:02:37.136]                           invokeRestart("muffleMessage")
[11:02:37.136]                       }
[11:02:37.136]                       else if (inherits(cond, "warning")) {
[11:02:37.136]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:37.136]                         if (muffled) 
[11:02:37.136]                           invokeRestart("muffleWarning")
[11:02:37.136]                       }
[11:02:37.136]                       else if (inherits(cond, "condition")) {
[11:02:37.136]                         if (!is.null(pattern)) {
[11:02:37.136]                           computeRestarts <- base::computeRestarts
[11:02:37.136]                           grepl <- base::grepl
[11:02:37.136]                           restarts <- computeRestarts(cond)
[11:02:37.136]                           for (restart in restarts) {
[11:02:37.136]                             name <- restart$name
[11:02:37.136]                             if (is.null(name)) 
[11:02:37.136]                               next
[11:02:37.136]                             if (!grepl(pattern, name)) 
[11:02:37.136]                               next
[11:02:37.136]                             invokeRestart(restart)
[11:02:37.136]                             muffled <- TRUE
[11:02:37.136]                             break
[11:02:37.136]                           }
[11:02:37.136]                         }
[11:02:37.136]                       }
[11:02:37.136]                       invisible(muffled)
[11:02:37.136]                     }
[11:02:37.136]                     muffleCondition(cond, pattern = "^muffle")
[11:02:37.136]                   }
[11:02:37.136]                 }
[11:02:37.136]                 else {
[11:02:37.136]                   if (TRUE) {
[11:02:37.136]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:37.136]                     {
[11:02:37.136]                       inherits <- base::inherits
[11:02:37.136]                       invokeRestart <- base::invokeRestart
[11:02:37.136]                       is.null <- base::is.null
[11:02:37.136]                       muffled <- FALSE
[11:02:37.136]                       if (inherits(cond, "message")) {
[11:02:37.136]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:37.136]                         if (muffled) 
[11:02:37.136]                           invokeRestart("muffleMessage")
[11:02:37.136]                       }
[11:02:37.136]                       else if (inherits(cond, "warning")) {
[11:02:37.136]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:37.136]                         if (muffled) 
[11:02:37.136]                           invokeRestart("muffleWarning")
[11:02:37.136]                       }
[11:02:37.136]                       else if (inherits(cond, "condition")) {
[11:02:37.136]                         if (!is.null(pattern)) {
[11:02:37.136]                           computeRestarts <- base::computeRestarts
[11:02:37.136]                           grepl <- base::grepl
[11:02:37.136]                           restarts <- computeRestarts(cond)
[11:02:37.136]                           for (restart in restarts) {
[11:02:37.136]                             name <- restart$name
[11:02:37.136]                             if (is.null(name)) 
[11:02:37.136]                               next
[11:02:37.136]                             if (!grepl(pattern, name)) 
[11:02:37.136]                               next
[11:02:37.136]                             invokeRestart(restart)
[11:02:37.136]                             muffled <- TRUE
[11:02:37.136]                             break
[11:02:37.136]                           }
[11:02:37.136]                         }
[11:02:37.136]                       }
[11:02:37.136]                       invisible(muffled)
[11:02:37.136]                     }
[11:02:37.136]                     muffleCondition(cond, pattern = "^muffle")
[11:02:37.136]                   }
[11:02:37.136]                 }
[11:02:37.136]             }
[11:02:37.136]         }))
[11:02:37.136]     }, error = function(ex) {
[11:02:37.136]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:37.136]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:37.136]                 ...future.rng), started = ...future.startTime, 
[11:02:37.136]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:37.136]             version = "1.8"), class = "FutureResult")
[11:02:37.136]     }, finally = {
[11:02:37.136]         if (!identical(...future.workdir, getwd())) 
[11:02:37.136]             setwd(...future.workdir)
[11:02:37.136]         {
[11:02:37.136]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:37.136]                 ...future.oldOptions$nwarnings <- NULL
[11:02:37.136]             }
[11:02:37.136]             base::options(...future.oldOptions)
[11:02:37.136]             if (.Platform$OS.type == "windows") {
[11:02:37.136]                 old_names <- names(...future.oldEnvVars)
[11:02:37.136]                 envs <- base::Sys.getenv()
[11:02:37.136]                 names <- names(envs)
[11:02:37.136]                 common <- intersect(names, old_names)
[11:02:37.136]                 added <- setdiff(names, old_names)
[11:02:37.136]                 removed <- setdiff(old_names, names)
[11:02:37.136]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:37.136]                   envs[common]]
[11:02:37.136]                 NAMES <- toupper(changed)
[11:02:37.136]                 args <- list()
[11:02:37.136]                 for (kk in seq_along(NAMES)) {
[11:02:37.136]                   name <- changed[[kk]]
[11:02:37.136]                   NAME <- NAMES[[kk]]
[11:02:37.136]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.136]                     next
[11:02:37.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:37.136]                 }
[11:02:37.136]                 NAMES <- toupper(added)
[11:02:37.136]                 for (kk in seq_along(NAMES)) {
[11:02:37.136]                   name <- added[[kk]]
[11:02:37.136]                   NAME <- NAMES[[kk]]
[11:02:37.136]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.136]                     next
[11:02:37.136]                   args[[name]] <- ""
[11:02:37.136]                 }
[11:02:37.136]                 NAMES <- toupper(removed)
[11:02:37.136]                 for (kk in seq_along(NAMES)) {
[11:02:37.136]                   name <- removed[[kk]]
[11:02:37.136]                   NAME <- NAMES[[kk]]
[11:02:37.136]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.136]                     next
[11:02:37.136]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:37.136]                 }
[11:02:37.136]                 if (length(args) > 0) 
[11:02:37.136]                   base::do.call(base::Sys.setenv, args = args)
[11:02:37.136]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:37.136]             }
[11:02:37.136]             else {
[11:02:37.136]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:37.136]             }
[11:02:37.136]             {
[11:02:37.136]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:37.136]                   0L) {
[11:02:37.136]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:37.136]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:37.136]                   base::options(opts)
[11:02:37.136]                 }
[11:02:37.136]                 {
[11:02:37.136]                   {
[11:02:37.136]                     NULL
[11:02:37.136]                     RNGkind("Mersenne-Twister")
[11:02:37.136]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:37.136]                       inherits = FALSE)
[11:02:37.136]                   }
[11:02:37.136]                   options(future.plan = NULL)
[11:02:37.136]                   if (is.na(NA_character_)) 
[11:02:37.136]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:37.136]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:37.136]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:37.136]                     .init = FALSE)
[11:02:37.136]                 }
[11:02:37.136]             }
[11:02:37.136]         }
[11:02:37.136]     })
[11:02:37.136]     if (TRUE) {
[11:02:37.136]         base::sink(type = "output", split = FALSE)
[11:02:37.136]         if (TRUE) {
[11:02:37.136]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:37.136]         }
[11:02:37.136]         else {
[11:02:37.136]             ...future.result["stdout"] <- base::list(NULL)
[11:02:37.136]         }
[11:02:37.136]         base::close(...future.stdout)
[11:02:37.136]         ...future.stdout <- NULL
[11:02:37.136]     }
[11:02:37.136]     ...future.result$conditions <- ...future.conditions
[11:02:37.136]     ...future.result$finished <- base::Sys.time()
[11:02:37.136]     ...future.result
[11:02:37.136] }
[11:02:37.138] assign_globals() ...
[11:02:37.138] List of 1
[11:02:37.138]  $ kk: int 1
[11:02:37.138]  - attr(*, "where")=List of 1
[11:02:37.138]   ..$ kk:<environment: R_EmptyEnv> 
[11:02:37.138]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:02:37.138]  - attr(*, "resolved")= logi FALSE
[11:02:37.138]  - attr(*, "total_size")= num 35
[11:02:37.138]  - attr(*, "already-done")= logi TRUE
[11:02:37.140] - copied ‘kk’ to environment
[11:02:37.140] assign_globals() ... done
[11:02:37.140] plan(): Setting new future strategy stack:
[11:02:37.141] List of future strategies:
[11:02:37.141] 1. sequential:
[11:02:37.141]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:37.141]    - tweaked: FALSE
[11:02:37.141]    - call: NULL
[11:02:37.141] plan(): nbrOfWorkers() = 1
[11:02:37.242] plan(): Setting new future strategy stack:
[11:02:37.242] List of future strategies:
[11:02:37.242] 1. sequential:
[11:02:37.242]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:37.242]    - tweaked: FALSE
[11:02:37.242]    - call: plan(strategy)
[11:02:37.242] plan(): nbrOfWorkers() = 1
[11:02:37.243] SequentialFuture started (and completed)
[11:02:37.243] - Launch lazy future ... done
[11:02:37.243] run() for ‘SequentialFuture’ ... done
[11:02:37.243] resolved() for ‘SequentialFuture’ ...
[11:02:37.243] - state: ‘finished’
[11:02:37.243] - run: TRUE
[11:02:37.243] - result: ‘FutureResult’
[11:02:37.243] resolved() for ‘SequentialFuture’ ... done
[11:02:37.243] Future #1
[11:02:37.243]  length: 2 (resolved future 1)
[11:02:37.244] run() for ‘Future’ ...
[11:02:37.244] - state: ‘created’
[11:02:37.244] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:02:37.244] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:37.244] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:37.244]   - Field: ‘label’
[11:02:37.244]   - Field: ‘local’
[11:02:37.244]   - Field: ‘owner’
[11:02:37.245]   - Field: ‘envir’
[11:02:37.245]   - Field: ‘packages’
[11:02:37.245]   - Field: ‘gc’
[11:02:37.245]   - Field: ‘conditions’
[11:02:37.245]   - Field: ‘expr’
[11:02:37.245]   - Field: ‘uuid’
[11:02:37.245]   - Field: ‘seed’
[11:02:37.245]   - Field: ‘version’
[11:02:37.245]   - Field: ‘result’
[11:02:37.245]   - Field: ‘asynchronous’
[11:02:37.245]   - Field: ‘calls’
[11:02:37.245]   - Field: ‘globals’
[11:02:37.245]   - Field: ‘stdout’
[11:02:37.246]   - Field: ‘earlySignal’
[11:02:37.246]   - Field: ‘lazy’
[11:02:37.246]   - Field: ‘state’
[11:02:37.246] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:37.246] - Launch lazy future ...
[11:02:37.246] Packages needed by the future expression (n = 0): <none>
[11:02:37.246] Packages needed by future strategies (n = 0): <none>
[11:02:37.247] {
[11:02:37.247]     {
[11:02:37.247]         {
[11:02:37.247]             ...future.startTime <- base::Sys.time()
[11:02:37.247]             {
[11:02:37.247]                 {
[11:02:37.247]                   {
[11:02:37.247]                     base::local({
[11:02:37.247]                       has_future <- base::requireNamespace("future", 
[11:02:37.247]                         quietly = TRUE)
[11:02:37.247]                       if (has_future) {
[11:02:37.247]                         ns <- base::getNamespace("future")
[11:02:37.247]                         version <- ns[[".package"]][["version"]]
[11:02:37.247]                         if (is.null(version)) 
[11:02:37.247]                           version <- utils::packageVersion("future")
[11:02:37.247]                       }
[11:02:37.247]                       else {
[11:02:37.247]                         version <- NULL
[11:02:37.247]                       }
[11:02:37.247]                       if (!has_future || version < "1.8.0") {
[11:02:37.247]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:37.247]                           "", base::R.version$version.string), 
[11:02:37.247]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:37.247]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:37.247]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:37.247]                             "release", "version")], collapse = " "), 
[11:02:37.247]                           hostname = base::Sys.info()[["nodename"]])
[11:02:37.247]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:37.247]                           info)
[11:02:37.247]                         info <- base::paste(info, collapse = "; ")
[11:02:37.247]                         if (!has_future) {
[11:02:37.247]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:37.247]                             info)
[11:02:37.247]                         }
[11:02:37.247]                         else {
[11:02:37.247]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:37.247]                             info, version)
[11:02:37.247]                         }
[11:02:37.247]                         base::stop(msg)
[11:02:37.247]                       }
[11:02:37.247]                     })
[11:02:37.247]                   }
[11:02:37.247]                   ...future.strategy.old <- future::plan("list")
[11:02:37.247]                   options(future.plan = NULL)
[11:02:37.247]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:37.247]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:37.247]                 }
[11:02:37.247]                 ...future.workdir <- getwd()
[11:02:37.247]             }
[11:02:37.247]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:37.247]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:37.247]         }
[11:02:37.247]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:37.247]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:37.247]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:37.247]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:37.247]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:37.247]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:37.247]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:37.247]             base::names(...future.oldOptions))
[11:02:37.247]     }
[11:02:37.247]     if (FALSE) {
[11:02:37.247]     }
[11:02:37.247]     else {
[11:02:37.247]         if (TRUE) {
[11:02:37.247]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:37.247]                 open = "w")
[11:02:37.247]         }
[11:02:37.247]         else {
[11:02:37.247]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:37.247]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:37.247]         }
[11:02:37.247]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:37.247]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:37.247]             base::sink(type = "output", split = FALSE)
[11:02:37.247]             base::close(...future.stdout)
[11:02:37.247]         }, add = TRUE)
[11:02:37.247]     }
[11:02:37.247]     ...future.frame <- base::sys.nframe()
[11:02:37.247]     ...future.conditions <- base::list()
[11:02:37.247]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:37.247]     if (FALSE) {
[11:02:37.247]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:37.247]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:37.247]     }
[11:02:37.247]     ...future.result <- base::tryCatch({
[11:02:37.247]         base::withCallingHandlers({
[11:02:37.247]             ...future.value <- base::withVisible(base::local({
[11:02:37.247]                 Sys.sleep(0.1)
[11:02:37.247]                 kk
[11:02:37.247]             }))
[11:02:37.247]             future::FutureResult(value = ...future.value$value, 
[11:02:37.247]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:37.247]                   ...future.rng), globalenv = if (FALSE) 
[11:02:37.247]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:37.247]                     ...future.globalenv.names))
[11:02:37.247]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:37.247]         }, condition = base::local({
[11:02:37.247]             c <- base::c
[11:02:37.247]             inherits <- base::inherits
[11:02:37.247]             invokeRestart <- base::invokeRestart
[11:02:37.247]             length <- base::length
[11:02:37.247]             list <- base::list
[11:02:37.247]             seq.int <- base::seq.int
[11:02:37.247]             signalCondition <- base::signalCondition
[11:02:37.247]             sys.calls <- base::sys.calls
[11:02:37.247]             `[[` <- base::`[[`
[11:02:37.247]             `+` <- base::`+`
[11:02:37.247]             `<<-` <- base::`<<-`
[11:02:37.247]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:37.247]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:37.247]                   3L)]
[11:02:37.247]             }
[11:02:37.247]             function(cond) {
[11:02:37.247]                 is_error <- inherits(cond, "error")
[11:02:37.247]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:37.247]                   NULL)
[11:02:37.247]                 if (is_error) {
[11:02:37.247]                   sessionInformation <- function() {
[11:02:37.247]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:37.247]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:37.247]                       search = base::search(), system = base::Sys.info())
[11:02:37.247]                   }
[11:02:37.247]                   ...future.conditions[[length(...future.conditions) + 
[11:02:37.247]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:37.247]                     cond$call), session = sessionInformation(), 
[11:02:37.247]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:37.247]                   signalCondition(cond)
[11:02:37.247]                 }
[11:02:37.247]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:37.247]                 "immediateCondition"))) {
[11:02:37.247]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:37.247]                   ...future.conditions[[length(...future.conditions) + 
[11:02:37.247]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:37.247]                   if (TRUE && !signal) {
[11:02:37.247]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:37.247]                     {
[11:02:37.247]                       inherits <- base::inherits
[11:02:37.247]                       invokeRestart <- base::invokeRestart
[11:02:37.247]                       is.null <- base::is.null
[11:02:37.247]                       muffled <- FALSE
[11:02:37.247]                       if (inherits(cond, "message")) {
[11:02:37.247]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:37.247]                         if (muffled) 
[11:02:37.247]                           invokeRestart("muffleMessage")
[11:02:37.247]                       }
[11:02:37.247]                       else if (inherits(cond, "warning")) {
[11:02:37.247]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:37.247]                         if (muffled) 
[11:02:37.247]                           invokeRestart("muffleWarning")
[11:02:37.247]                       }
[11:02:37.247]                       else if (inherits(cond, "condition")) {
[11:02:37.247]                         if (!is.null(pattern)) {
[11:02:37.247]                           computeRestarts <- base::computeRestarts
[11:02:37.247]                           grepl <- base::grepl
[11:02:37.247]                           restarts <- computeRestarts(cond)
[11:02:37.247]                           for (restart in restarts) {
[11:02:37.247]                             name <- restart$name
[11:02:37.247]                             if (is.null(name)) 
[11:02:37.247]                               next
[11:02:37.247]                             if (!grepl(pattern, name)) 
[11:02:37.247]                               next
[11:02:37.247]                             invokeRestart(restart)
[11:02:37.247]                             muffled <- TRUE
[11:02:37.247]                             break
[11:02:37.247]                           }
[11:02:37.247]                         }
[11:02:37.247]                       }
[11:02:37.247]                       invisible(muffled)
[11:02:37.247]                     }
[11:02:37.247]                     muffleCondition(cond, pattern = "^muffle")
[11:02:37.247]                   }
[11:02:37.247]                 }
[11:02:37.247]                 else {
[11:02:37.247]                   if (TRUE) {
[11:02:37.247]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:37.247]                     {
[11:02:37.247]                       inherits <- base::inherits
[11:02:37.247]                       invokeRestart <- base::invokeRestart
[11:02:37.247]                       is.null <- base::is.null
[11:02:37.247]                       muffled <- FALSE
[11:02:37.247]                       if (inherits(cond, "message")) {
[11:02:37.247]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:37.247]                         if (muffled) 
[11:02:37.247]                           invokeRestart("muffleMessage")
[11:02:37.247]                       }
[11:02:37.247]                       else if (inherits(cond, "warning")) {
[11:02:37.247]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:37.247]                         if (muffled) 
[11:02:37.247]                           invokeRestart("muffleWarning")
[11:02:37.247]                       }
[11:02:37.247]                       else if (inherits(cond, "condition")) {
[11:02:37.247]                         if (!is.null(pattern)) {
[11:02:37.247]                           computeRestarts <- base::computeRestarts
[11:02:37.247]                           grepl <- base::grepl
[11:02:37.247]                           restarts <- computeRestarts(cond)
[11:02:37.247]                           for (restart in restarts) {
[11:02:37.247]                             name <- restart$name
[11:02:37.247]                             if (is.null(name)) 
[11:02:37.247]                               next
[11:02:37.247]                             if (!grepl(pattern, name)) 
[11:02:37.247]                               next
[11:02:37.247]                             invokeRestart(restart)
[11:02:37.247]                             muffled <- TRUE
[11:02:37.247]                             break
[11:02:37.247]                           }
[11:02:37.247]                         }
[11:02:37.247]                       }
[11:02:37.247]                       invisible(muffled)
[11:02:37.247]                     }
[11:02:37.247]                     muffleCondition(cond, pattern = "^muffle")
[11:02:37.247]                   }
[11:02:37.247]                 }
[11:02:37.247]             }
[11:02:37.247]         }))
[11:02:37.247]     }, error = function(ex) {
[11:02:37.247]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:37.247]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:37.247]                 ...future.rng), started = ...future.startTime, 
[11:02:37.247]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:37.247]             version = "1.8"), class = "FutureResult")
[11:02:37.247]     }, finally = {
[11:02:37.247]         if (!identical(...future.workdir, getwd())) 
[11:02:37.247]             setwd(...future.workdir)
[11:02:37.247]         {
[11:02:37.247]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:37.247]                 ...future.oldOptions$nwarnings <- NULL
[11:02:37.247]             }
[11:02:37.247]             base::options(...future.oldOptions)
[11:02:37.247]             if (.Platform$OS.type == "windows") {
[11:02:37.247]                 old_names <- names(...future.oldEnvVars)
[11:02:37.247]                 envs <- base::Sys.getenv()
[11:02:37.247]                 names <- names(envs)
[11:02:37.247]                 common <- intersect(names, old_names)
[11:02:37.247]                 added <- setdiff(names, old_names)
[11:02:37.247]                 removed <- setdiff(old_names, names)
[11:02:37.247]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:37.247]                   envs[common]]
[11:02:37.247]                 NAMES <- toupper(changed)
[11:02:37.247]                 args <- list()
[11:02:37.247]                 for (kk in seq_along(NAMES)) {
[11:02:37.247]                   name <- changed[[kk]]
[11:02:37.247]                   NAME <- NAMES[[kk]]
[11:02:37.247]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.247]                     next
[11:02:37.247]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:37.247]                 }
[11:02:37.247]                 NAMES <- toupper(added)
[11:02:37.247]                 for (kk in seq_along(NAMES)) {
[11:02:37.247]                   name <- added[[kk]]
[11:02:37.247]                   NAME <- NAMES[[kk]]
[11:02:37.247]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.247]                     next
[11:02:37.247]                   args[[name]] <- ""
[11:02:37.247]                 }
[11:02:37.247]                 NAMES <- toupper(removed)
[11:02:37.247]                 for (kk in seq_along(NAMES)) {
[11:02:37.247]                   name <- removed[[kk]]
[11:02:37.247]                   NAME <- NAMES[[kk]]
[11:02:37.247]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.247]                     next
[11:02:37.247]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:37.247]                 }
[11:02:37.247]                 if (length(args) > 0) 
[11:02:37.247]                   base::do.call(base::Sys.setenv, args = args)
[11:02:37.247]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:37.247]             }
[11:02:37.247]             else {
[11:02:37.247]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:37.247]             }
[11:02:37.247]             {
[11:02:37.247]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:37.247]                   0L) {
[11:02:37.247]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:37.247]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:37.247]                   base::options(opts)
[11:02:37.247]                 }
[11:02:37.247]                 {
[11:02:37.247]                   {
[11:02:37.247]                     NULL
[11:02:37.247]                     RNGkind("Mersenne-Twister")
[11:02:37.247]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:37.247]                       inherits = FALSE)
[11:02:37.247]                   }
[11:02:37.247]                   options(future.plan = NULL)
[11:02:37.247]                   if (is.na(NA_character_)) 
[11:02:37.247]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:37.247]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:37.247]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:37.247]                     .init = FALSE)
[11:02:37.247]                 }
[11:02:37.247]             }
[11:02:37.247]         }
[11:02:37.247]     })
[11:02:37.247]     if (TRUE) {
[11:02:37.247]         base::sink(type = "output", split = FALSE)
[11:02:37.247]         if (TRUE) {
[11:02:37.247]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:37.247]         }
[11:02:37.247]         else {
[11:02:37.247]             ...future.result["stdout"] <- base::list(NULL)
[11:02:37.247]         }
[11:02:37.247]         base::close(...future.stdout)
[11:02:37.247]         ...future.stdout <- NULL
[11:02:37.247]     }
[11:02:37.247]     ...future.result$conditions <- ...future.conditions
[11:02:37.247]     ...future.result$finished <- base::Sys.time()
[11:02:37.247]     ...future.result
[11:02:37.247] }
[11:02:37.248] assign_globals() ...
[11:02:37.248] List of 1
[11:02:37.248]  $ kk: int 2
[11:02:37.248]  - attr(*, "where")=List of 1
[11:02:37.248]   ..$ kk:<environment: R_EmptyEnv> 
[11:02:37.248]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:02:37.248]  - attr(*, "resolved")= logi FALSE
[11:02:37.248]  - attr(*, "total_size")= num 35
[11:02:37.248]  - attr(*, "already-done")= logi TRUE
[11:02:37.250] - copied ‘kk’ to environment
[11:02:37.251] assign_globals() ... done
[11:02:37.251] plan(): Setting new future strategy stack:
[11:02:37.251] List of future strategies:
[11:02:37.251] 1. sequential:
[11:02:37.251]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:37.251]    - tweaked: FALSE
[11:02:37.251]    - call: NULL
[11:02:37.251] plan(): nbrOfWorkers() = 1
[11:02:37.352] plan(): Setting new future strategy stack:
[11:02:37.352] List of future strategies:
[11:02:37.352] 1. sequential:
[11:02:37.352]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:37.352]    - tweaked: FALSE
[11:02:37.352]    - call: plan(strategy)
[11:02:37.353] plan(): nbrOfWorkers() = 1
[11:02:37.353] SequentialFuture started (and completed)
[11:02:37.353] - Launch lazy future ... done
[11:02:37.353] run() for ‘SequentialFuture’ ... done
[11:02:37.353] resolved() for ‘SequentialFuture’ ...
[11:02:37.354] - state: ‘finished’
[11:02:37.354] - run: TRUE
[11:02:37.354] - result: ‘FutureResult’
[11:02:37.354] resolved() for ‘SequentialFuture’ ... done
[11:02:37.354] Future #2
[11:02:37.354]  length: 1 (resolved future 2)
[11:02:37.354] run() for ‘Future’ ...
[11:02:37.354] - state: ‘created’
[11:02:37.354] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:02:37.355] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:37.355] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:37.355]   - Field: ‘label’
[11:02:37.355]   - Field: ‘local’
[11:02:37.355]   - Field: ‘owner’
[11:02:37.355]   - Field: ‘envir’
[11:02:37.355]   - Field: ‘packages’
[11:02:37.355]   - Field: ‘gc’
[11:02:37.355]   - Field: ‘conditions’
[11:02:37.355]   - Field: ‘expr’
[11:02:37.355]   - Field: ‘uuid’
[11:02:37.355]   - Field: ‘seed’
[11:02:37.356]   - Field: ‘version’
[11:02:37.356]   - Field: ‘result’
[11:02:37.356]   - Field: ‘asynchronous’
[11:02:37.356]   - Field: ‘calls’
[11:02:37.356]   - Field: ‘globals’
[11:02:37.356]   - Field: ‘stdout’
[11:02:37.356]   - Field: ‘earlySignal’
[11:02:37.356]   - Field: ‘lazy’
[11:02:37.356]   - Field: ‘state’
[11:02:37.356] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:37.356] - Launch lazy future ...
[11:02:37.357] Packages needed by the future expression (n = 0): <none>
[11:02:37.357] Packages needed by future strategies (n = 0): <none>
[11:02:37.357] {
[11:02:37.357]     {
[11:02:37.357]         {
[11:02:37.357]             ...future.startTime <- base::Sys.time()
[11:02:37.357]             {
[11:02:37.357]                 {
[11:02:37.357]                   {
[11:02:37.357]                     base::local({
[11:02:37.357]                       has_future <- base::requireNamespace("future", 
[11:02:37.357]                         quietly = TRUE)
[11:02:37.357]                       if (has_future) {
[11:02:37.357]                         ns <- base::getNamespace("future")
[11:02:37.357]                         version <- ns[[".package"]][["version"]]
[11:02:37.357]                         if (is.null(version)) 
[11:02:37.357]                           version <- utils::packageVersion("future")
[11:02:37.357]                       }
[11:02:37.357]                       else {
[11:02:37.357]                         version <- NULL
[11:02:37.357]                       }
[11:02:37.357]                       if (!has_future || version < "1.8.0") {
[11:02:37.357]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:37.357]                           "", base::R.version$version.string), 
[11:02:37.357]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:37.357]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:37.357]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:37.357]                             "release", "version")], collapse = " "), 
[11:02:37.357]                           hostname = base::Sys.info()[["nodename"]])
[11:02:37.357]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:37.357]                           info)
[11:02:37.357]                         info <- base::paste(info, collapse = "; ")
[11:02:37.357]                         if (!has_future) {
[11:02:37.357]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:37.357]                             info)
[11:02:37.357]                         }
[11:02:37.357]                         else {
[11:02:37.357]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:37.357]                             info, version)
[11:02:37.357]                         }
[11:02:37.357]                         base::stop(msg)
[11:02:37.357]                       }
[11:02:37.357]                     })
[11:02:37.357]                   }
[11:02:37.357]                   ...future.strategy.old <- future::plan("list")
[11:02:37.357]                   options(future.plan = NULL)
[11:02:37.357]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:37.357]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:37.357]                 }
[11:02:37.357]                 ...future.workdir <- getwd()
[11:02:37.357]             }
[11:02:37.357]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:37.357]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:37.357]         }
[11:02:37.357]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:37.357]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:37.357]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:37.357]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:37.357]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:37.357]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:37.357]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:37.357]             base::names(...future.oldOptions))
[11:02:37.357]     }
[11:02:37.357]     if (FALSE) {
[11:02:37.357]     }
[11:02:37.357]     else {
[11:02:37.357]         if (TRUE) {
[11:02:37.357]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:37.357]                 open = "w")
[11:02:37.357]         }
[11:02:37.357]         else {
[11:02:37.357]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:37.357]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:37.357]         }
[11:02:37.357]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:37.357]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:37.357]             base::sink(type = "output", split = FALSE)
[11:02:37.357]             base::close(...future.stdout)
[11:02:37.357]         }, add = TRUE)
[11:02:37.357]     }
[11:02:37.357]     ...future.frame <- base::sys.nframe()
[11:02:37.357]     ...future.conditions <- base::list()
[11:02:37.357]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:37.357]     if (FALSE) {
[11:02:37.357]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:37.357]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:37.357]     }
[11:02:37.357]     ...future.result <- base::tryCatch({
[11:02:37.357]         base::withCallingHandlers({
[11:02:37.357]             ...future.value <- base::withVisible(base::local({
[11:02:37.357]                 Sys.sleep(0.1)
[11:02:37.357]                 kk
[11:02:37.357]             }))
[11:02:37.357]             future::FutureResult(value = ...future.value$value, 
[11:02:37.357]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:37.357]                   ...future.rng), globalenv = if (FALSE) 
[11:02:37.357]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:37.357]                     ...future.globalenv.names))
[11:02:37.357]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:37.357]         }, condition = base::local({
[11:02:37.357]             c <- base::c
[11:02:37.357]             inherits <- base::inherits
[11:02:37.357]             invokeRestart <- base::invokeRestart
[11:02:37.357]             length <- base::length
[11:02:37.357]             list <- base::list
[11:02:37.357]             seq.int <- base::seq.int
[11:02:37.357]             signalCondition <- base::signalCondition
[11:02:37.357]             sys.calls <- base::sys.calls
[11:02:37.357]             `[[` <- base::`[[`
[11:02:37.357]             `+` <- base::`+`
[11:02:37.357]             `<<-` <- base::`<<-`
[11:02:37.357]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:37.357]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:37.357]                   3L)]
[11:02:37.357]             }
[11:02:37.357]             function(cond) {
[11:02:37.357]                 is_error <- inherits(cond, "error")
[11:02:37.357]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:37.357]                   NULL)
[11:02:37.357]                 if (is_error) {
[11:02:37.357]                   sessionInformation <- function() {
[11:02:37.357]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:37.357]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:37.357]                       search = base::search(), system = base::Sys.info())
[11:02:37.357]                   }
[11:02:37.357]                   ...future.conditions[[length(...future.conditions) + 
[11:02:37.357]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:37.357]                     cond$call), session = sessionInformation(), 
[11:02:37.357]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:37.357]                   signalCondition(cond)
[11:02:37.357]                 }
[11:02:37.357]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:37.357]                 "immediateCondition"))) {
[11:02:37.357]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:37.357]                   ...future.conditions[[length(...future.conditions) + 
[11:02:37.357]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:37.357]                   if (TRUE && !signal) {
[11:02:37.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:37.357]                     {
[11:02:37.357]                       inherits <- base::inherits
[11:02:37.357]                       invokeRestart <- base::invokeRestart
[11:02:37.357]                       is.null <- base::is.null
[11:02:37.357]                       muffled <- FALSE
[11:02:37.357]                       if (inherits(cond, "message")) {
[11:02:37.357]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:37.357]                         if (muffled) 
[11:02:37.357]                           invokeRestart("muffleMessage")
[11:02:37.357]                       }
[11:02:37.357]                       else if (inherits(cond, "warning")) {
[11:02:37.357]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:37.357]                         if (muffled) 
[11:02:37.357]                           invokeRestart("muffleWarning")
[11:02:37.357]                       }
[11:02:37.357]                       else if (inherits(cond, "condition")) {
[11:02:37.357]                         if (!is.null(pattern)) {
[11:02:37.357]                           computeRestarts <- base::computeRestarts
[11:02:37.357]                           grepl <- base::grepl
[11:02:37.357]                           restarts <- computeRestarts(cond)
[11:02:37.357]                           for (restart in restarts) {
[11:02:37.357]                             name <- restart$name
[11:02:37.357]                             if (is.null(name)) 
[11:02:37.357]                               next
[11:02:37.357]                             if (!grepl(pattern, name)) 
[11:02:37.357]                               next
[11:02:37.357]                             invokeRestart(restart)
[11:02:37.357]                             muffled <- TRUE
[11:02:37.357]                             break
[11:02:37.357]                           }
[11:02:37.357]                         }
[11:02:37.357]                       }
[11:02:37.357]                       invisible(muffled)
[11:02:37.357]                     }
[11:02:37.357]                     muffleCondition(cond, pattern = "^muffle")
[11:02:37.357]                   }
[11:02:37.357]                 }
[11:02:37.357]                 else {
[11:02:37.357]                   if (TRUE) {
[11:02:37.357]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:37.357]                     {
[11:02:37.357]                       inherits <- base::inherits
[11:02:37.357]                       invokeRestart <- base::invokeRestart
[11:02:37.357]                       is.null <- base::is.null
[11:02:37.357]                       muffled <- FALSE
[11:02:37.357]                       if (inherits(cond, "message")) {
[11:02:37.357]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:37.357]                         if (muffled) 
[11:02:37.357]                           invokeRestart("muffleMessage")
[11:02:37.357]                       }
[11:02:37.357]                       else if (inherits(cond, "warning")) {
[11:02:37.357]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:37.357]                         if (muffled) 
[11:02:37.357]                           invokeRestart("muffleWarning")
[11:02:37.357]                       }
[11:02:37.357]                       else if (inherits(cond, "condition")) {
[11:02:37.357]                         if (!is.null(pattern)) {
[11:02:37.357]                           computeRestarts <- base::computeRestarts
[11:02:37.357]                           grepl <- base::grepl
[11:02:37.357]                           restarts <- computeRestarts(cond)
[11:02:37.357]                           for (restart in restarts) {
[11:02:37.357]                             name <- restart$name
[11:02:37.357]                             if (is.null(name)) 
[11:02:37.357]                               next
[11:02:37.357]                             if (!grepl(pattern, name)) 
[11:02:37.357]                               next
[11:02:37.357]                             invokeRestart(restart)
[11:02:37.357]                             muffled <- TRUE
[11:02:37.357]                             break
[11:02:37.357]                           }
[11:02:37.357]                         }
[11:02:37.357]                       }
[11:02:37.357]                       invisible(muffled)
[11:02:37.357]                     }
[11:02:37.357]                     muffleCondition(cond, pattern = "^muffle")
[11:02:37.357]                   }
[11:02:37.357]                 }
[11:02:37.357]             }
[11:02:37.357]         }))
[11:02:37.357]     }, error = function(ex) {
[11:02:37.357]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:37.357]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:37.357]                 ...future.rng), started = ...future.startTime, 
[11:02:37.357]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:37.357]             version = "1.8"), class = "FutureResult")
[11:02:37.357]     }, finally = {
[11:02:37.357]         if (!identical(...future.workdir, getwd())) 
[11:02:37.357]             setwd(...future.workdir)
[11:02:37.357]         {
[11:02:37.357]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:37.357]                 ...future.oldOptions$nwarnings <- NULL
[11:02:37.357]             }
[11:02:37.357]             base::options(...future.oldOptions)
[11:02:37.357]             if (.Platform$OS.type == "windows") {
[11:02:37.357]                 old_names <- names(...future.oldEnvVars)
[11:02:37.357]                 envs <- base::Sys.getenv()
[11:02:37.357]                 names <- names(envs)
[11:02:37.357]                 common <- intersect(names, old_names)
[11:02:37.357]                 added <- setdiff(names, old_names)
[11:02:37.357]                 removed <- setdiff(old_names, names)
[11:02:37.357]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:37.357]                   envs[common]]
[11:02:37.357]                 NAMES <- toupper(changed)
[11:02:37.357]                 args <- list()
[11:02:37.357]                 for (kk in seq_along(NAMES)) {
[11:02:37.357]                   name <- changed[[kk]]
[11:02:37.357]                   NAME <- NAMES[[kk]]
[11:02:37.357]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.357]                     next
[11:02:37.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:37.357]                 }
[11:02:37.357]                 NAMES <- toupper(added)
[11:02:37.357]                 for (kk in seq_along(NAMES)) {
[11:02:37.357]                   name <- added[[kk]]
[11:02:37.357]                   NAME <- NAMES[[kk]]
[11:02:37.357]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.357]                     next
[11:02:37.357]                   args[[name]] <- ""
[11:02:37.357]                 }
[11:02:37.357]                 NAMES <- toupper(removed)
[11:02:37.357]                 for (kk in seq_along(NAMES)) {
[11:02:37.357]                   name <- removed[[kk]]
[11:02:37.357]                   NAME <- NAMES[[kk]]
[11:02:37.357]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.357]                     next
[11:02:37.357]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:37.357]                 }
[11:02:37.357]                 if (length(args) > 0) 
[11:02:37.357]                   base::do.call(base::Sys.setenv, args = args)
[11:02:37.357]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:37.357]             }
[11:02:37.357]             else {
[11:02:37.357]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:37.357]             }
[11:02:37.357]             {
[11:02:37.357]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:37.357]                   0L) {
[11:02:37.357]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:37.357]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:37.357]                   base::options(opts)
[11:02:37.357]                 }
[11:02:37.357]                 {
[11:02:37.357]                   {
[11:02:37.357]                     NULL
[11:02:37.357]                     RNGkind("Mersenne-Twister")
[11:02:37.357]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:37.357]                       inherits = FALSE)
[11:02:37.357]                   }
[11:02:37.357]                   options(future.plan = NULL)
[11:02:37.357]                   if (is.na(NA_character_)) 
[11:02:37.357]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:37.357]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:37.357]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:37.357]                     .init = FALSE)
[11:02:37.357]                 }
[11:02:37.357]             }
[11:02:37.357]         }
[11:02:37.357]     })
[11:02:37.357]     if (TRUE) {
[11:02:37.357]         base::sink(type = "output", split = FALSE)
[11:02:37.357]         if (TRUE) {
[11:02:37.357]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:37.357]         }
[11:02:37.357]         else {
[11:02:37.357]             ...future.result["stdout"] <- base::list(NULL)
[11:02:37.357]         }
[11:02:37.357]         base::close(...future.stdout)
[11:02:37.357]         ...future.stdout <- NULL
[11:02:37.357]     }
[11:02:37.357]     ...future.result$conditions <- ...future.conditions
[11:02:37.357]     ...future.result$finished <- base::Sys.time()
[11:02:37.357]     ...future.result
[11:02:37.357] }
[11:02:37.359] assign_globals() ...
[11:02:37.359] List of 1
[11:02:37.359]  $ kk: int 3
[11:02:37.359]  - attr(*, "where")=List of 1
[11:02:37.359]   ..$ kk:<environment: R_EmptyEnv> 
[11:02:37.359]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:02:37.359]  - attr(*, "resolved")= logi FALSE
[11:02:37.359]  - attr(*, "total_size")= num 35
[11:02:37.359]  - attr(*, "already-done")= logi TRUE
[11:02:37.361] - copied ‘kk’ to environment
[11:02:37.361] assign_globals() ... done
[11:02:37.361] plan(): Setting new future strategy stack:
[11:02:37.361] List of future strategies:
[11:02:37.361] 1. sequential:
[11:02:37.361]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:37.361]    - tweaked: FALSE
[11:02:37.361]    - call: NULL
[11:02:37.363] plan(): nbrOfWorkers() = 1
[11:02:37.464] plan(): Setting new future strategy stack:
[11:02:37.464] List of future strategies:
[11:02:37.464] 1. sequential:
[11:02:37.464]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:37.464]    - tweaked: FALSE
[11:02:37.464]    - call: plan(strategy)
[11:02:37.465] plan(): nbrOfWorkers() = 1
[11:02:37.465] SequentialFuture started (and completed)
[11:02:37.465] - Launch lazy future ... done
[11:02:37.465] run() for ‘SequentialFuture’ ... done
[11:02:37.466] resolved() for ‘SequentialFuture’ ...
[11:02:37.466] - state: ‘finished’
[11:02:37.466] - run: TRUE
[11:02:37.466] - result: ‘FutureResult’
[11:02:37.466] resolved() for ‘SequentialFuture’ ... done
[11:02:37.466] Future #3
[11:02:37.466]  length: 0 (resolved future 3)
[11:02:37.466] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[11:02:37.467] resolve() on environment ...
[11:02:37.467]  recursive: 0
[11:02:37.468]  elements: [2] ‘a’, ‘b’
[11:02:37.468]  length: 1 (resolved future 1)
[11:02:37.468]  length: 0 (resolved future 2)
[11:02:37.468] resolve() on environment ... DONE
[11:02:37.469] getGlobalsAndPackages() ...
[11:02:37.469] Searching for globals...
[11:02:37.469] 
[11:02:37.469] Searching for globals ... DONE
[11:02:37.469] - globals: [0] <none>
[11:02:37.469] getGlobalsAndPackages() ... DONE
[11:02:37.469] run() for ‘Future’ ...
[11:02:37.470] - state: ‘created’
[11:02:37.470] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:02:37.470] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:37.470] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:37.470]   - Field: ‘label’
[11:02:37.470]   - Field: ‘local’
[11:02:37.470]   - Field: ‘owner’
[11:02:37.470]   - Field: ‘envir’
[11:02:37.470]   - Field: ‘packages’
[11:02:37.471]   - Field: ‘gc’
[11:02:37.471]   - Field: ‘conditions’
[11:02:37.471]   - Field: ‘expr’
[11:02:37.471]   - Field: ‘uuid’
[11:02:37.471]   - Field: ‘seed’
[11:02:37.471]   - Field: ‘version’
[11:02:37.471]   - Field: ‘result’
[11:02:37.471]   - Field: ‘asynchronous’
[11:02:37.471]   - Field: ‘calls’
[11:02:37.471]   - Field: ‘globals’
[11:02:37.471]   - Field: ‘stdout’
[11:02:37.471]   - Field: ‘earlySignal’
[11:02:37.471]   - Field: ‘lazy’
[11:02:37.472]   - Field: ‘state’
[11:02:37.472] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:37.472] - Launch lazy future ...
[11:02:37.472] Packages needed by the future expression (n = 0): <none>
[11:02:37.472] Packages needed by future strategies (n = 0): <none>
[11:02:37.472] {
[11:02:37.472]     {
[11:02:37.472]         {
[11:02:37.472]             ...future.startTime <- base::Sys.time()
[11:02:37.472]             {
[11:02:37.472]                 {
[11:02:37.472]                   {
[11:02:37.472]                     base::local({
[11:02:37.472]                       has_future <- base::requireNamespace("future", 
[11:02:37.472]                         quietly = TRUE)
[11:02:37.472]                       if (has_future) {
[11:02:37.472]                         ns <- base::getNamespace("future")
[11:02:37.472]                         version <- ns[[".package"]][["version"]]
[11:02:37.472]                         if (is.null(version)) 
[11:02:37.472]                           version <- utils::packageVersion("future")
[11:02:37.472]                       }
[11:02:37.472]                       else {
[11:02:37.472]                         version <- NULL
[11:02:37.472]                       }
[11:02:37.472]                       if (!has_future || version < "1.8.0") {
[11:02:37.472]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:37.472]                           "", base::R.version$version.string), 
[11:02:37.472]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:37.472]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:37.472]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:37.472]                             "release", "version")], collapse = " "), 
[11:02:37.472]                           hostname = base::Sys.info()[["nodename"]])
[11:02:37.472]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:37.472]                           info)
[11:02:37.472]                         info <- base::paste(info, collapse = "; ")
[11:02:37.472]                         if (!has_future) {
[11:02:37.472]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:37.472]                             info)
[11:02:37.472]                         }
[11:02:37.472]                         else {
[11:02:37.472]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:37.472]                             info, version)
[11:02:37.472]                         }
[11:02:37.472]                         base::stop(msg)
[11:02:37.472]                       }
[11:02:37.472]                     })
[11:02:37.472]                   }
[11:02:37.472]                   ...future.strategy.old <- future::plan("list")
[11:02:37.472]                   options(future.plan = NULL)
[11:02:37.472]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:37.472]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:37.472]                 }
[11:02:37.472]                 ...future.workdir <- getwd()
[11:02:37.472]             }
[11:02:37.472]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:37.472]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:37.472]         }
[11:02:37.472]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:37.472]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:37.472]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:37.472]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:37.472]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:37.472]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:37.472]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:37.472]             base::names(...future.oldOptions))
[11:02:37.472]     }
[11:02:37.472]     if (FALSE) {
[11:02:37.472]     }
[11:02:37.472]     else {
[11:02:37.472]         if (TRUE) {
[11:02:37.472]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:37.472]                 open = "w")
[11:02:37.472]         }
[11:02:37.472]         else {
[11:02:37.472]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:37.472]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:37.472]         }
[11:02:37.472]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:37.472]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:37.472]             base::sink(type = "output", split = FALSE)
[11:02:37.472]             base::close(...future.stdout)
[11:02:37.472]         }, add = TRUE)
[11:02:37.472]     }
[11:02:37.472]     ...future.frame <- base::sys.nframe()
[11:02:37.472]     ...future.conditions <- base::list()
[11:02:37.472]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:37.472]     if (FALSE) {
[11:02:37.472]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:37.472]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:37.472]     }
[11:02:37.472]     ...future.result <- base::tryCatch({
[11:02:37.472]         base::withCallingHandlers({
[11:02:37.472]             ...future.value <- base::withVisible(base::local(1))
[11:02:37.472]             future::FutureResult(value = ...future.value$value, 
[11:02:37.472]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:37.472]                   ...future.rng), globalenv = if (FALSE) 
[11:02:37.472]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:37.472]                     ...future.globalenv.names))
[11:02:37.472]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:37.472]         }, condition = base::local({
[11:02:37.472]             c <- base::c
[11:02:37.472]             inherits <- base::inherits
[11:02:37.472]             invokeRestart <- base::invokeRestart
[11:02:37.472]             length <- base::length
[11:02:37.472]             list <- base::list
[11:02:37.472]             seq.int <- base::seq.int
[11:02:37.472]             signalCondition <- base::signalCondition
[11:02:37.472]             sys.calls <- base::sys.calls
[11:02:37.472]             `[[` <- base::`[[`
[11:02:37.472]             `+` <- base::`+`
[11:02:37.472]             `<<-` <- base::`<<-`
[11:02:37.472]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:37.472]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:37.472]                   3L)]
[11:02:37.472]             }
[11:02:37.472]             function(cond) {
[11:02:37.472]                 is_error <- inherits(cond, "error")
[11:02:37.472]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:37.472]                   NULL)
[11:02:37.472]                 if (is_error) {
[11:02:37.472]                   sessionInformation <- function() {
[11:02:37.472]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:37.472]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:37.472]                       search = base::search(), system = base::Sys.info())
[11:02:37.472]                   }
[11:02:37.472]                   ...future.conditions[[length(...future.conditions) + 
[11:02:37.472]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:37.472]                     cond$call), session = sessionInformation(), 
[11:02:37.472]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:37.472]                   signalCondition(cond)
[11:02:37.472]                 }
[11:02:37.472]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:37.472]                 "immediateCondition"))) {
[11:02:37.472]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:37.472]                   ...future.conditions[[length(...future.conditions) + 
[11:02:37.472]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:37.472]                   if (TRUE && !signal) {
[11:02:37.472]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:37.472]                     {
[11:02:37.472]                       inherits <- base::inherits
[11:02:37.472]                       invokeRestart <- base::invokeRestart
[11:02:37.472]                       is.null <- base::is.null
[11:02:37.472]                       muffled <- FALSE
[11:02:37.472]                       if (inherits(cond, "message")) {
[11:02:37.472]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:37.472]                         if (muffled) 
[11:02:37.472]                           invokeRestart("muffleMessage")
[11:02:37.472]                       }
[11:02:37.472]                       else if (inherits(cond, "warning")) {
[11:02:37.472]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:37.472]                         if (muffled) 
[11:02:37.472]                           invokeRestart("muffleWarning")
[11:02:37.472]                       }
[11:02:37.472]                       else if (inherits(cond, "condition")) {
[11:02:37.472]                         if (!is.null(pattern)) {
[11:02:37.472]                           computeRestarts <- base::computeRestarts
[11:02:37.472]                           grepl <- base::grepl
[11:02:37.472]                           restarts <- computeRestarts(cond)
[11:02:37.472]                           for (restart in restarts) {
[11:02:37.472]                             name <- restart$name
[11:02:37.472]                             if (is.null(name)) 
[11:02:37.472]                               next
[11:02:37.472]                             if (!grepl(pattern, name)) 
[11:02:37.472]                               next
[11:02:37.472]                             invokeRestart(restart)
[11:02:37.472]                             muffled <- TRUE
[11:02:37.472]                             break
[11:02:37.472]                           }
[11:02:37.472]                         }
[11:02:37.472]                       }
[11:02:37.472]                       invisible(muffled)
[11:02:37.472]                     }
[11:02:37.472]                     muffleCondition(cond, pattern = "^muffle")
[11:02:37.472]                   }
[11:02:37.472]                 }
[11:02:37.472]                 else {
[11:02:37.472]                   if (TRUE) {
[11:02:37.472]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:37.472]                     {
[11:02:37.472]                       inherits <- base::inherits
[11:02:37.472]                       invokeRestart <- base::invokeRestart
[11:02:37.472]                       is.null <- base::is.null
[11:02:37.472]                       muffled <- FALSE
[11:02:37.472]                       if (inherits(cond, "message")) {
[11:02:37.472]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:37.472]                         if (muffled) 
[11:02:37.472]                           invokeRestart("muffleMessage")
[11:02:37.472]                       }
[11:02:37.472]                       else if (inherits(cond, "warning")) {
[11:02:37.472]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:37.472]                         if (muffled) 
[11:02:37.472]                           invokeRestart("muffleWarning")
[11:02:37.472]                       }
[11:02:37.472]                       else if (inherits(cond, "condition")) {
[11:02:37.472]                         if (!is.null(pattern)) {
[11:02:37.472]                           computeRestarts <- base::computeRestarts
[11:02:37.472]                           grepl <- base::grepl
[11:02:37.472]                           restarts <- computeRestarts(cond)
[11:02:37.472]                           for (restart in restarts) {
[11:02:37.472]                             name <- restart$name
[11:02:37.472]                             if (is.null(name)) 
[11:02:37.472]                               next
[11:02:37.472]                             if (!grepl(pattern, name)) 
[11:02:37.472]                               next
[11:02:37.472]                             invokeRestart(restart)
[11:02:37.472]                             muffled <- TRUE
[11:02:37.472]                             break
[11:02:37.472]                           }
[11:02:37.472]                         }
[11:02:37.472]                       }
[11:02:37.472]                       invisible(muffled)
[11:02:37.472]                     }
[11:02:37.472]                     muffleCondition(cond, pattern = "^muffle")
[11:02:37.472]                   }
[11:02:37.472]                 }
[11:02:37.472]             }
[11:02:37.472]         }))
[11:02:37.472]     }, error = function(ex) {
[11:02:37.472]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:37.472]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:37.472]                 ...future.rng), started = ...future.startTime, 
[11:02:37.472]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:37.472]             version = "1.8"), class = "FutureResult")
[11:02:37.472]     }, finally = {
[11:02:37.472]         if (!identical(...future.workdir, getwd())) 
[11:02:37.472]             setwd(...future.workdir)
[11:02:37.472]         {
[11:02:37.472]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:37.472]                 ...future.oldOptions$nwarnings <- NULL
[11:02:37.472]             }
[11:02:37.472]             base::options(...future.oldOptions)
[11:02:37.472]             if (.Platform$OS.type == "windows") {
[11:02:37.472]                 old_names <- names(...future.oldEnvVars)
[11:02:37.472]                 envs <- base::Sys.getenv()
[11:02:37.472]                 names <- names(envs)
[11:02:37.472]                 common <- intersect(names, old_names)
[11:02:37.472]                 added <- setdiff(names, old_names)
[11:02:37.472]                 removed <- setdiff(old_names, names)
[11:02:37.472]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:37.472]                   envs[common]]
[11:02:37.472]                 NAMES <- toupper(changed)
[11:02:37.472]                 args <- list()
[11:02:37.472]                 for (kk in seq_along(NAMES)) {
[11:02:37.472]                   name <- changed[[kk]]
[11:02:37.472]                   NAME <- NAMES[[kk]]
[11:02:37.472]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.472]                     next
[11:02:37.472]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:37.472]                 }
[11:02:37.472]                 NAMES <- toupper(added)
[11:02:37.472]                 for (kk in seq_along(NAMES)) {
[11:02:37.472]                   name <- added[[kk]]
[11:02:37.472]                   NAME <- NAMES[[kk]]
[11:02:37.472]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.472]                     next
[11:02:37.472]                   args[[name]] <- ""
[11:02:37.472]                 }
[11:02:37.472]                 NAMES <- toupper(removed)
[11:02:37.472]                 for (kk in seq_along(NAMES)) {
[11:02:37.472]                   name <- removed[[kk]]
[11:02:37.472]                   NAME <- NAMES[[kk]]
[11:02:37.472]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.472]                     next
[11:02:37.472]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:37.472]                 }
[11:02:37.472]                 if (length(args) > 0) 
[11:02:37.472]                   base::do.call(base::Sys.setenv, args = args)
[11:02:37.472]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:37.472]             }
[11:02:37.472]             else {
[11:02:37.472]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:37.472]             }
[11:02:37.472]             {
[11:02:37.472]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:37.472]                   0L) {
[11:02:37.472]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:37.472]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:37.472]                   base::options(opts)
[11:02:37.472]                 }
[11:02:37.472]                 {
[11:02:37.472]                   {
[11:02:37.472]                     NULL
[11:02:37.472]                     RNGkind("Mersenne-Twister")
[11:02:37.472]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:37.472]                       inherits = FALSE)
[11:02:37.472]                   }
[11:02:37.472]                   options(future.plan = NULL)
[11:02:37.472]                   if (is.na(NA_character_)) 
[11:02:37.472]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:37.472]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:37.472]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:37.472]                     .init = FALSE)
[11:02:37.472]                 }
[11:02:37.472]             }
[11:02:37.472]         }
[11:02:37.472]     })
[11:02:37.472]     if (TRUE) {
[11:02:37.472]         base::sink(type = "output", split = FALSE)
[11:02:37.472]         if (TRUE) {
[11:02:37.472]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:37.472]         }
[11:02:37.472]         else {
[11:02:37.472]             ...future.result["stdout"] <- base::list(NULL)
[11:02:37.472]         }
[11:02:37.472]         base::close(...future.stdout)
[11:02:37.472]         ...future.stdout <- NULL
[11:02:37.472]     }
[11:02:37.472]     ...future.result$conditions <- ...future.conditions
[11:02:37.472]     ...future.result$finished <- base::Sys.time()
[11:02:37.472]     ...future.result
[11:02:37.472] }
[11:02:37.474] plan(): Setting new future strategy stack:
[11:02:37.474] List of future strategies:
[11:02:37.474] 1. sequential:
[11:02:37.474]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:37.474]    - tweaked: FALSE
[11:02:37.474]    - call: NULL
[11:02:37.475] plan(): nbrOfWorkers() = 1
[11:02:37.475] plan(): Setting new future strategy stack:
[11:02:37.475] List of future strategies:
[11:02:37.475] 1. sequential:
[11:02:37.475]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:37.475]    - tweaked: FALSE
[11:02:37.475]    - call: plan(strategy)
[11:02:37.476] plan(): nbrOfWorkers() = 1
[11:02:37.476] SequentialFuture started (and completed)
[11:02:37.476] - Launch lazy future ... done
[11:02:37.476] run() for ‘SequentialFuture’ ... done
[11:02:37.476] getGlobalsAndPackages() ...
[11:02:37.476] Searching for globals...
[11:02:37.477] 
[11:02:37.477] Searching for globals ... DONE
[11:02:37.477] - globals: [0] <none>
[11:02:37.477] getGlobalsAndPackages() ... DONE
[11:02:37.477] run() for ‘Future’ ...
[11:02:37.477] - state: ‘created’
[11:02:37.477] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:02:37.478] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:37.478] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:37.478]   - Field: ‘label’
[11:02:37.478]   - Field: ‘local’
[11:02:37.478]   - Field: ‘owner’
[11:02:37.478]   - Field: ‘envir’
[11:02:37.478]   - Field: ‘packages’
[11:02:37.478]   - Field: ‘gc’
[11:02:37.478]   - Field: ‘conditions’
[11:02:37.478]   - Field: ‘expr’
[11:02:37.478]   - Field: ‘uuid’
[11:02:37.478]   - Field: ‘seed’
[11:02:37.479]   - Field: ‘version’
[11:02:37.479]   - Field: ‘result’
[11:02:37.479]   - Field: ‘asynchronous’
[11:02:37.479]   - Field: ‘calls’
[11:02:37.479]   - Field: ‘globals’
[11:02:37.479]   - Field: ‘stdout’
[11:02:37.479]   - Field: ‘earlySignal’
[11:02:37.479]   - Field: ‘lazy’
[11:02:37.479]   - Field: ‘state’
[11:02:37.479] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:37.479] - Launch lazy future ...
[11:02:37.480] Packages needed by the future expression (n = 0): <none>
[11:02:37.480] Packages needed by future strategies (n = 0): <none>
[11:02:37.480] {
[11:02:37.480]     {
[11:02:37.480]         {
[11:02:37.480]             ...future.startTime <- base::Sys.time()
[11:02:37.480]             {
[11:02:37.480]                 {
[11:02:37.480]                   {
[11:02:37.480]                     base::local({
[11:02:37.480]                       has_future <- base::requireNamespace("future", 
[11:02:37.480]                         quietly = TRUE)
[11:02:37.480]                       if (has_future) {
[11:02:37.480]                         ns <- base::getNamespace("future")
[11:02:37.480]                         version <- ns[[".package"]][["version"]]
[11:02:37.480]                         if (is.null(version)) 
[11:02:37.480]                           version <- utils::packageVersion("future")
[11:02:37.480]                       }
[11:02:37.480]                       else {
[11:02:37.480]                         version <- NULL
[11:02:37.480]                       }
[11:02:37.480]                       if (!has_future || version < "1.8.0") {
[11:02:37.480]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:37.480]                           "", base::R.version$version.string), 
[11:02:37.480]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:37.480]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:37.480]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:37.480]                             "release", "version")], collapse = " "), 
[11:02:37.480]                           hostname = base::Sys.info()[["nodename"]])
[11:02:37.480]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:37.480]                           info)
[11:02:37.480]                         info <- base::paste(info, collapse = "; ")
[11:02:37.480]                         if (!has_future) {
[11:02:37.480]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:37.480]                             info)
[11:02:37.480]                         }
[11:02:37.480]                         else {
[11:02:37.480]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:37.480]                             info, version)
[11:02:37.480]                         }
[11:02:37.480]                         base::stop(msg)
[11:02:37.480]                       }
[11:02:37.480]                     })
[11:02:37.480]                   }
[11:02:37.480]                   ...future.strategy.old <- future::plan("list")
[11:02:37.480]                   options(future.plan = NULL)
[11:02:37.480]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:37.480]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:37.480]                 }
[11:02:37.480]                 ...future.workdir <- getwd()
[11:02:37.480]             }
[11:02:37.480]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:37.480]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:37.480]         }
[11:02:37.480]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:37.480]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:37.480]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:37.480]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:37.480]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:37.480]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:37.480]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:37.480]             base::names(...future.oldOptions))
[11:02:37.480]     }
[11:02:37.480]     if (FALSE) {
[11:02:37.480]     }
[11:02:37.480]     else {
[11:02:37.480]         if (TRUE) {
[11:02:37.480]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:37.480]                 open = "w")
[11:02:37.480]         }
[11:02:37.480]         else {
[11:02:37.480]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:37.480]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:37.480]         }
[11:02:37.480]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:37.480]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:37.480]             base::sink(type = "output", split = FALSE)
[11:02:37.480]             base::close(...future.stdout)
[11:02:37.480]         }, add = TRUE)
[11:02:37.480]     }
[11:02:37.480]     ...future.frame <- base::sys.nframe()
[11:02:37.480]     ...future.conditions <- base::list()
[11:02:37.480]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:37.480]     if (FALSE) {
[11:02:37.480]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:37.480]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:37.480]     }
[11:02:37.480]     ...future.result <- base::tryCatch({
[11:02:37.480]         base::withCallingHandlers({
[11:02:37.480]             ...future.value <- base::withVisible(base::local(2))
[11:02:37.480]             future::FutureResult(value = ...future.value$value, 
[11:02:37.480]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:37.480]                   ...future.rng), globalenv = if (FALSE) 
[11:02:37.480]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:37.480]                     ...future.globalenv.names))
[11:02:37.480]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:37.480]         }, condition = base::local({
[11:02:37.480]             c <- base::c
[11:02:37.480]             inherits <- base::inherits
[11:02:37.480]             invokeRestart <- base::invokeRestart
[11:02:37.480]             length <- base::length
[11:02:37.480]             list <- base::list
[11:02:37.480]             seq.int <- base::seq.int
[11:02:37.480]             signalCondition <- base::signalCondition
[11:02:37.480]             sys.calls <- base::sys.calls
[11:02:37.480]             `[[` <- base::`[[`
[11:02:37.480]             `+` <- base::`+`
[11:02:37.480]             `<<-` <- base::`<<-`
[11:02:37.480]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:37.480]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:37.480]                   3L)]
[11:02:37.480]             }
[11:02:37.480]             function(cond) {
[11:02:37.480]                 is_error <- inherits(cond, "error")
[11:02:37.480]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:37.480]                   NULL)
[11:02:37.480]                 if (is_error) {
[11:02:37.480]                   sessionInformation <- function() {
[11:02:37.480]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:37.480]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:37.480]                       search = base::search(), system = base::Sys.info())
[11:02:37.480]                   }
[11:02:37.480]                   ...future.conditions[[length(...future.conditions) + 
[11:02:37.480]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:37.480]                     cond$call), session = sessionInformation(), 
[11:02:37.480]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:37.480]                   signalCondition(cond)
[11:02:37.480]                 }
[11:02:37.480]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:37.480]                 "immediateCondition"))) {
[11:02:37.480]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:37.480]                   ...future.conditions[[length(...future.conditions) + 
[11:02:37.480]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:37.480]                   if (TRUE && !signal) {
[11:02:37.480]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:37.480]                     {
[11:02:37.480]                       inherits <- base::inherits
[11:02:37.480]                       invokeRestart <- base::invokeRestart
[11:02:37.480]                       is.null <- base::is.null
[11:02:37.480]                       muffled <- FALSE
[11:02:37.480]                       if (inherits(cond, "message")) {
[11:02:37.480]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:37.480]                         if (muffled) 
[11:02:37.480]                           invokeRestart("muffleMessage")
[11:02:37.480]                       }
[11:02:37.480]                       else if (inherits(cond, "warning")) {
[11:02:37.480]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:37.480]                         if (muffled) 
[11:02:37.480]                           invokeRestart("muffleWarning")
[11:02:37.480]                       }
[11:02:37.480]                       else if (inherits(cond, "condition")) {
[11:02:37.480]                         if (!is.null(pattern)) {
[11:02:37.480]                           computeRestarts <- base::computeRestarts
[11:02:37.480]                           grepl <- base::grepl
[11:02:37.480]                           restarts <- computeRestarts(cond)
[11:02:37.480]                           for (restart in restarts) {
[11:02:37.480]                             name <- restart$name
[11:02:37.480]                             if (is.null(name)) 
[11:02:37.480]                               next
[11:02:37.480]                             if (!grepl(pattern, name)) 
[11:02:37.480]                               next
[11:02:37.480]                             invokeRestart(restart)
[11:02:37.480]                             muffled <- TRUE
[11:02:37.480]                             break
[11:02:37.480]                           }
[11:02:37.480]                         }
[11:02:37.480]                       }
[11:02:37.480]                       invisible(muffled)
[11:02:37.480]                     }
[11:02:37.480]                     muffleCondition(cond, pattern = "^muffle")
[11:02:37.480]                   }
[11:02:37.480]                 }
[11:02:37.480]                 else {
[11:02:37.480]                   if (TRUE) {
[11:02:37.480]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:37.480]                     {
[11:02:37.480]                       inherits <- base::inherits
[11:02:37.480]                       invokeRestart <- base::invokeRestart
[11:02:37.480]                       is.null <- base::is.null
[11:02:37.480]                       muffled <- FALSE
[11:02:37.480]                       if (inherits(cond, "message")) {
[11:02:37.480]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:37.480]                         if (muffled) 
[11:02:37.480]                           invokeRestart("muffleMessage")
[11:02:37.480]                       }
[11:02:37.480]                       else if (inherits(cond, "warning")) {
[11:02:37.480]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:37.480]                         if (muffled) 
[11:02:37.480]                           invokeRestart("muffleWarning")
[11:02:37.480]                       }
[11:02:37.480]                       else if (inherits(cond, "condition")) {
[11:02:37.480]                         if (!is.null(pattern)) {
[11:02:37.480]                           computeRestarts <- base::computeRestarts
[11:02:37.480]                           grepl <- base::grepl
[11:02:37.480]                           restarts <- computeRestarts(cond)
[11:02:37.480]                           for (restart in restarts) {
[11:02:37.480]                             name <- restart$name
[11:02:37.480]                             if (is.null(name)) 
[11:02:37.480]                               next
[11:02:37.480]                             if (!grepl(pattern, name)) 
[11:02:37.480]                               next
[11:02:37.480]                             invokeRestart(restart)
[11:02:37.480]                             muffled <- TRUE
[11:02:37.480]                             break
[11:02:37.480]                           }
[11:02:37.480]                         }
[11:02:37.480]                       }
[11:02:37.480]                       invisible(muffled)
[11:02:37.480]                     }
[11:02:37.480]                     muffleCondition(cond, pattern = "^muffle")
[11:02:37.480]                   }
[11:02:37.480]                 }
[11:02:37.480]             }
[11:02:37.480]         }))
[11:02:37.480]     }, error = function(ex) {
[11:02:37.480]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:37.480]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:37.480]                 ...future.rng), started = ...future.startTime, 
[11:02:37.480]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:37.480]             version = "1.8"), class = "FutureResult")
[11:02:37.480]     }, finally = {
[11:02:37.480]         if (!identical(...future.workdir, getwd())) 
[11:02:37.480]             setwd(...future.workdir)
[11:02:37.480]         {
[11:02:37.480]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:37.480]                 ...future.oldOptions$nwarnings <- NULL
[11:02:37.480]             }
[11:02:37.480]             base::options(...future.oldOptions)
[11:02:37.480]             if (.Platform$OS.type == "windows") {
[11:02:37.480]                 old_names <- names(...future.oldEnvVars)
[11:02:37.480]                 envs <- base::Sys.getenv()
[11:02:37.480]                 names <- names(envs)
[11:02:37.480]                 common <- intersect(names, old_names)
[11:02:37.480]                 added <- setdiff(names, old_names)
[11:02:37.480]                 removed <- setdiff(old_names, names)
[11:02:37.480]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:37.480]                   envs[common]]
[11:02:37.480]                 NAMES <- toupper(changed)
[11:02:37.480]                 args <- list()
[11:02:37.480]                 for (kk in seq_along(NAMES)) {
[11:02:37.480]                   name <- changed[[kk]]
[11:02:37.480]                   NAME <- NAMES[[kk]]
[11:02:37.480]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.480]                     next
[11:02:37.480]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:37.480]                 }
[11:02:37.480]                 NAMES <- toupper(added)
[11:02:37.480]                 for (kk in seq_along(NAMES)) {
[11:02:37.480]                   name <- added[[kk]]
[11:02:37.480]                   NAME <- NAMES[[kk]]
[11:02:37.480]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.480]                     next
[11:02:37.480]                   args[[name]] <- ""
[11:02:37.480]                 }
[11:02:37.480]                 NAMES <- toupper(removed)
[11:02:37.480]                 for (kk in seq_along(NAMES)) {
[11:02:37.480]                   name <- removed[[kk]]
[11:02:37.480]                   NAME <- NAMES[[kk]]
[11:02:37.480]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.480]                     next
[11:02:37.480]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:37.480]                 }
[11:02:37.480]                 if (length(args) > 0) 
[11:02:37.480]                   base::do.call(base::Sys.setenv, args = args)
[11:02:37.480]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:37.480]             }
[11:02:37.480]             else {
[11:02:37.480]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:37.480]             }
[11:02:37.480]             {
[11:02:37.480]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:37.480]                   0L) {
[11:02:37.480]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:37.480]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:37.480]                   base::options(opts)
[11:02:37.480]                 }
[11:02:37.480]                 {
[11:02:37.480]                   {
[11:02:37.480]                     NULL
[11:02:37.480]                     RNGkind("Mersenne-Twister")
[11:02:37.480]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:37.480]                       inherits = FALSE)
[11:02:37.480]                   }
[11:02:37.480]                   options(future.plan = NULL)
[11:02:37.480]                   if (is.na(NA_character_)) 
[11:02:37.480]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:37.480]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:37.480]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:37.480]                     .init = FALSE)
[11:02:37.480]                 }
[11:02:37.480]             }
[11:02:37.480]         }
[11:02:37.480]     })
[11:02:37.480]     if (TRUE) {
[11:02:37.480]         base::sink(type = "output", split = FALSE)
[11:02:37.480]         if (TRUE) {
[11:02:37.480]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:37.480]         }
[11:02:37.480]         else {
[11:02:37.480]             ...future.result["stdout"] <- base::list(NULL)
[11:02:37.480]         }
[11:02:37.480]         base::close(...future.stdout)
[11:02:37.480]         ...future.stdout <- NULL
[11:02:37.480]     }
[11:02:37.480]     ...future.result$conditions <- ...future.conditions
[11:02:37.480]     ...future.result$finished <- base::Sys.time()
[11:02:37.480]     ...future.result
[11:02:37.480] }
[11:02:37.482] plan(): Setting new future strategy stack:
[11:02:37.482] List of future strategies:
[11:02:37.482] 1. sequential:
[11:02:37.482]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:37.482]    - tweaked: FALSE
[11:02:37.482]    - call: NULL
[11:02:37.482] plan(): nbrOfWorkers() = 1
[11:02:37.483] plan(): Setting new future strategy stack:
[11:02:37.483] List of future strategies:
[11:02:37.483] 1. sequential:
[11:02:37.483]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:37.483]    - tweaked: FALSE
[11:02:37.483]    - call: plan(strategy)
[11:02:37.483] plan(): nbrOfWorkers() = 1
[11:02:37.484] SequentialFuture started (and completed)
[11:02:37.484] - Launch lazy future ... done
[11:02:37.484] run() for ‘SequentialFuture’ ... done
[11:02:37.484] resolve() on environment ...
[11:02:37.484]  recursive: 0
[11:02:37.485]  elements: [3] ‘a’, ‘b’, ‘c’
[11:02:37.485] resolved() for ‘SequentialFuture’ ...
[11:02:37.485] - state: ‘finished’
[11:02:37.485] - run: TRUE
[11:02:37.485] - result: ‘FutureResult’
[11:02:37.485] resolved() for ‘SequentialFuture’ ... done
[11:02:37.485] Future #1
[11:02:37.485]  length: 2 (resolved future 1)
[11:02:37.485] resolved() for ‘SequentialFuture’ ...
[11:02:37.485] - state: ‘finished’
[11:02:37.486] - run: TRUE
[11:02:37.486] - result: ‘FutureResult’
[11:02:37.486] resolved() for ‘SequentialFuture’ ... done
[11:02:37.486] Future #2
[11:02:37.486]  length: 1 (resolved future 2)
[11:02:37.486]  length: 0 (resolved future 3)
[11:02:37.486] resolve() on environment ... DONE
[11:02:37.486] resolved() for ‘SequentialFuture’ ...
[11:02:37.486] - state: ‘finished’
[11:02:37.486] - run: TRUE
[11:02:37.486] - result: ‘FutureResult’
[11:02:37.487] resolved() for ‘SequentialFuture’ ... done
[11:02:37.487] resolved() for ‘SequentialFuture’ ...
[11:02:37.487] - state: ‘finished’
[11:02:37.487] - run: TRUE
[11:02:37.487] - result: ‘FutureResult’
[11:02:37.487] resolved() for ‘SequentialFuture’ ... done
[11:02:37.488] getGlobalsAndPackages() ...
[11:02:37.488] Searching for globals...
[11:02:37.488] - globals found: [1] ‘{’
[11:02:37.488] Searching for globals ... DONE
[11:02:37.488] Resolving globals: FALSE
[11:02:37.489] 
[11:02:37.489] 
[11:02:37.489] getGlobalsAndPackages() ... DONE
[11:02:37.490] run() for ‘Future’ ...
[11:02:37.490] - state: ‘created’
[11:02:37.491] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:02:37.491] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:37.491] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:37.491]   - Field: ‘label’
[11:02:37.491]   - Field: ‘local’
[11:02:37.491]   - Field: ‘owner’
[11:02:37.491]   - Field: ‘envir’
[11:02:37.491]   - Field: ‘packages’
[11:02:37.491]   - Field: ‘gc’
[11:02:37.491]   - Field: ‘conditions’
[11:02:37.492]   - Field: ‘expr’
[11:02:37.492]   - Field: ‘uuid’
[11:02:37.492]   - Field: ‘seed’
[11:02:37.492]   - Field: ‘version’
[11:02:37.492]   - Field: ‘result’
[11:02:37.492]   - Field: ‘asynchronous’
[11:02:37.492]   - Field: ‘calls’
[11:02:37.492]   - Field: ‘globals’
[11:02:37.492]   - Field: ‘stdout’
[11:02:37.492]   - Field: ‘earlySignal’
[11:02:37.492]   - Field: ‘lazy’
[11:02:37.492]   - Field: ‘state’
[11:02:37.493] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:37.493] - Launch lazy future ...
[11:02:37.493] Packages needed by the future expression (n = 0): <none>
[11:02:37.493] Packages needed by future strategies (n = 0): <none>
[11:02:37.493] {
[11:02:37.493]     {
[11:02:37.493]         {
[11:02:37.493]             ...future.startTime <- base::Sys.time()
[11:02:37.493]             {
[11:02:37.493]                 {
[11:02:37.493]                   {
[11:02:37.493]                     base::local({
[11:02:37.493]                       has_future <- base::requireNamespace("future", 
[11:02:37.493]                         quietly = TRUE)
[11:02:37.493]                       if (has_future) {
[11:02:37.493]                         ns <- base::getNamespace("future")
[11:02:37.493]                         version <- ns[[".package"]][["version"]]
[11:02:37.493]                         if (is.null(version)) 
[11:02:37.493]                           version <- utils::packageVersion("future")
[11:02:37.493]                       }
[11:02:37.493]                       else {
[11:02:37.493]                         version <- NULL
[11:02:37.493]                       }
[11:02:37.493]                       if (!has_future || version < "1.8.0") {
[11:02:37.493]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:37.493]                           "", base::R.version$version.string), 
[11:02:37.493]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:37.493]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:37.493]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:37.493]                             "release", "version")], collapse = " "), 
[11:02:37.493]                           hostname = base::Sys.info()[["nodename"]])
[11:02:37.493]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:37.493]                           info)
[11:02:37.493]                         info <- base::paste(info, collapse = "; ")
[11:02:37.493]                         if (!has_future) {
[11:02:37.493]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:37.493]                             info)
[11:02:37.493]                         }
[11:02:37.493]                         else {
[11:02:37.493]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:37.493]                             info, version)
[11:02:37.493]                         }
[11:02:37.493]                         base::stop(msg)
[11:02:37.493]                       }
[11:02:37.493]                     })
[11:02:37.493]                   }
[11:02:37.493]                   ...future.strategy.old <- future::plan("list")
[11:02:37.493]                   options(future.plan = NULL)
[11:02:37.493]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:37.493]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:37.493]                 }
[11:02:37.493]                 ...future.workdir <- getwd()
[11:02:37.493]             }
[11:02:37.493]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:37.493]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:37.493]         }
[11:02:37.493]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:37.493]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:37.493]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:37.493]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:37.493]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:37.493]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:37.493]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:37.493]             base::names(...future.oldOptions))
[11:02:37.493]     }
[11:02:37.493]     if (FALSE) {
[11:02:37.493]     }
[11:02:37.493]     else {
[11:02:37.493]         if (TRUE) {
[11:02:37.493]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:37.493]                 open = "w")
[11:02:37.493]         }
[11:02:37.493]         else {
[11:02:37.493]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:37.493]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:37.493]         }
[11:02:37.493]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:37.493]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:37.493]             base::sink(type = "output", split = FALSE)
[11:02:37.493]             base::close(...future.stdout)
[11:02:37.493]         }, add = TRUE)
[11:02:37.493]     }
[11:02:37.493]     ...future.frame <- base::sys.nframe()
[11:02:37.493]     ...future.conditions <- base::list()
[11:02:37.493]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:37.493]     if (FALSE) {
[11:02:37.493]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:37.493]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:37.493]     }
[11:02:37.493]     ...future.result <- base::tryCatch({
[11:02:37.493]         base::withCallingHandlers({
[11:02:37.493]             ...future.value <- base::withVisible(base::local({
[11:02:37.493]                 1
[11:02:37.493]             }))
[11:02:37.493]             future::FutureResult(value = ...future.value$value, 
[11:02:37.493]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:37.493]                   ...future.rng), globalenv = if (FALSE) 
[11:02:37.493]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:37.493]                     ...future.globalenv.names))
[11:02:37.493]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:37.493]         }, condition = base::local({
[11:02:37.493]             c <- base::c
[11:02:37.493]             inherits <- base::inherits
[11:02:37.493]             invokeRestart <- base::invokeRestart
[11:02:37.493]             length <- base::length
[11:02:37.493]             list <- base::list
[11:02:37.493]             seq.int <- base::seq.int
[11:02:37.493]             signalCondition <- base::signalCondition
[11:02:37.493]             sys.calls <- base::sys.calls
[11:02:37.493]             `[[` <- base::`[[`
[11:02:37.493]             `+` <- base::`+`
[11:02:37.493]             `<<-` <- base::`<<-`
[11:02:37.493]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:37.493]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:37.493]                   3L)]
[11:02:37.493]             }
[11:02:37.493]             function(cond) {
[11:02:37.493]                 is_error <- inherits(cond, "error")
[11:02:37.493]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:37.493]                   NULL)
[11:02:37.493]                 if (is_error) {
[11:02:37.493]                   sessionInformation <- function() {
[11:02:37.493]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:37.493]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:37.493]                       search = base::search(), system = base::Sys.info())
[11:02:37.493]                   }
[11:02:37.493]                   ...future.conditions[[length(...future.conditions) + 
[11:02:37.493]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:37.493]                     cond$call), session = sessionInformation(), 
[11:02:37.493]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:37.493]                   signalCondition(cond)
[11:02:37.493]                 }
[11:02:37.493]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:37.493]                 "immediateCondition"))) {
[11:02:37.493]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:37.493]                   ...future.conditions[[length(...future.conditions) + 
[11:02:37.493]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:37.493]                   if (TRUE && !signal) {
[11:02:37.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:37.493]                     {
[11:02:37.493]                       inherits <- base::inherits
[11:02:37.493]                       invokeRestart <- base::invokeRestart
[11:02:37.493]                       is.null <- base::is.null
[11:02:37.493]                       muffled <- FALSE
[11:02:37.493]                       if (inherits(cond, "message")) {
[11:02:37.493]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:37.493]                         if (muffled) 
[11:02:37.493]                           invokeRestart("muffleMessage")
[11:02:37.493]                       }
[11:02:37.493]                       else if (inherits(cond, "warning")) {
[11:02:37.493]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:37.493]                         if (muffled) 
[11:02:37.493]                           invokeRestart("muffleWarning")
[11:02:37.493]                       }
[11:02:37.493]                       else if (inherits(cond, "condition")) {
[11:02:37.493]                         if (!is.null(pattern)) {
[11:02:37.493]                           computeRestarts <- base::computeRestarts
[11:02:37.493]                           grepl <- base::grepl
[11:02:37.493]                           restarts <- computeRestarts(cond)
[11:02:37.493]                           for (restart in restarts) {
[11:02:37.493]                             name <- restart$name
[11:02:37.493]                             if (is.null(name)) 
[11:02:37.493]                               next
[11:02:37.493]                             if (!grepl(pattern, name)) 
[11:02:37.493]                               next
[11:02:37.493]                             invokeRestart(restart)
[11:02:37.493]                             muffled <- TRUE
[11:02:37.493]                             break
[11:02:37.493]                           }
[11:02:37.493]                         }
[11:02:37.493]                       }
[11:02:37.493]                       invisible(muffled)
[11:02:37.493]                     }
[11:02:37.493]                     muffleCondition(cond, pattern = "^muffle")
[11:02:37.493]                   }
[11:02:37.493]                 }
[11:02:37.493]                 else {
[11:02:37.493]                   if (TRUE) {
[11:02:37.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:37.493]                     {
[11:02:37.493]                       inherits <- base::inherits
[11:02:37.493]                       invokeRestart <- base::invokeRestart
[11:02:37.493]                       is.null <- base::is.null
[11:02:37.493]                       muffled <- FALSE
[11:02:37.493]                       if (inherits(cond, "message")) {
[11:02:37.493]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:37.493]                         if (muffled) 
[11:02:37.493]                           invokeRestart("muffleMessage")
[11:02:37.493]                       }
[11:02:37.493]                       else if (inherits(cond, "warning")) {
[11:02:37.493]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:37.493]                         if (muffled) 
[11:02:37.493]                           invokeRestart("muffleWarning")
[11:02:37.493]                       }
[11:02:37.493]                       else if (inherits(cond, "condition")) {
[11:02:37.493]                         if (!is.null(pattern)) {
[11:02:37.493]                           computeRestarts <- base::computeRestarts
[11:02:37.493]                           grepl <- base::grepl
[11:02:37.493]                           restarts <- computeRestarts(cond)
[11:02:37.493]                           for (restart in restarts) {
[11:02:37.493]                             name <- restart$name
[11:02:37.493]                             if (is.null(name)) 
[11:02:37.493]                               next
[11:02:37.493]                             if (!grepl(pattern, name)) 
[11:02:37.493]                               next
[11:02:37.493]                             invokeRestart(restart)
[11:02:37.493]                             muffled <- TRUE
[11:02:37.493]                             break
[11:02:37.493]                           }
[11:02:37.493]                         }
[11:02:37.493]                       }
[11:02:37.493]                       invisible(muffled)
[11:02:37.493]                     }
[11:02:37.493]                     muffleCondition(cond, pattern = "^muffle")
[11:02:37.493]                   }
[11:02:37.493]                 }
[11:02:37.493]             }
[11:02:37.493]         }))
[11:02:37.493]     }, error = function(ex) {
[11:02:37.493]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:37.493]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:37.493]                 ...future.rng), started = ...future.startTime, 
[11:02:37.493]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:37.493]             version = "1.8"), class = "FutureResult")
[11:02:37.493]     }, finally = {
[11:02:37.493]         if (!identical(...future.workdir, getwd())) 
[11:02:37.493]             setwd(...future.workdir)
[11:02:37.493]         {
[11:02:37.493]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:37.493]                 ...future.oldOptions$nwarnings <- NULL
[11:02:37.493]             }
[11:02:37.493]             base::options(...future.oldOptions)
[11:02:37.493]             if (.Platform$OS.type == "windows") {
[11:02:37.493]                 old_names <- names(...future.oldEnvVars)
[11:02:37.493]                 envs <- base::Sys.getenv()
[11:02:37.493]                 names <- names(envs)
[11:02:37.493]                 common <- intersect(names, old_names)
[11:02:37.493]                 added <- setdiff(names, old_names)
[11:02:37.493]                 removed <- setdiff(old_names, names)
[11:02:37.493]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:37.493]                   envs[common]]
[11:02:37.493]                 NAMES <- toupper(changed)
[11:02:37.493]                 args <- list()
[11:02:37.493]                 for (kk in seq_along(NAMES)) {
[11:02:37.493]                   name <- changed[[kk]]
[11:02:37.493]                   NAME <- NAMES[[kk]]
[11:02:37.493]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.493]                     next
[11:02:37.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:37.493]                 }
[11:02:37.493]                 NAMES <- toupper(added)
[11:02:37.493]                 for (kk in seq_along(NAMES)) {
[11:02:37.493]                   name <- added[[kk]]
[11:02:37.493]                   NAME <- NAMES[[kk]]
[11:02:37.493]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.493]                     next
[11:02:37.493]                   args[[name]] <- ""
[11:02:37.493]                 }
[11:02:37.493]                 NAMES <- toupper(removed)
[11:02:37.493]                 for (kk in seq_along(NAMES)) {
[11:02:37.493]                   name <- removed[[kk]]
[11:02:37.493]                   NAME <- NAMES[[kk]]
[11:02:37.493]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.493]                     next
[11:02:37.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:37.493]                 }
[11:02:37.493]                 if (length(args) > 0) 
[11:02:37.493]                   base::do.call(base::Sys.setenv, args = args)
[11:02:37.493]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:37.493]             }
[11:02:37.493]             else {
[11:02:37.493]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:37.493]             }
[11:02:37.493]             {
[11:02:37.493]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:37.493]                   0L) {
[11:02:37.493]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:37.493]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:37.493]                   base::options(opts)
[11:02:37.493]                 }
[11:02:37.493]                 {
[11:02:37.493]                   {
[11:02:37.493]                     NULL
[11:02:37.493]                     RNGkind("Mersenne-Twister")
[11:02:37.493]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:37.493]                       inherits = FALSE)
[11:02:37.493]                   }
[11:02:37.493]                   options(future.plan = NULL)
[11:02:37.493]                   if (is.na(NA_character_)) 
[11:02:37.493]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:37.493]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:37.493]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:37.493]                     .init = FALSE)
[11:02:37.493]                 }
[11:02:37.493]             }
[11:02:37.493]         }
[11:02:37.493]     })
[11:02:37.493]     if (TRUE) {
[11:02:37.493]         base::sink(type = "output", split = FALSE)
[11:02:37.493]         if (TRUE) {
[11:02:37.493]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:37.493]         }
[11:02:37.493]         else {
[11:02:37.493]             ...future.result["stdout"] <- base::list(NULL)
[11:02:37.493]         }
[11:02:37.493]         base::close(...future.stdout)
[11:02:37.493]         ...future.stdout <- NULL
[11:02:37.493]     }
[11:02:37.493]     ...future.result$conditions <- ...future.conditions
[11:02:37.493]     ...future.result$finished <- base::Sys.time()
[11:02:37.493]     ...future.result
[11:02:37.493] }
[11:02:37.495] plan(): Setting new future strategy stack:
[11:02:37.495] List of future strategies:
[11:02:37.495] 1. sequential:
[11:02:37.495]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:37.495]    - tweaked: FALSE
[11:02:37.495]    - call: NULL
[11:02:37.495] plan(): nbrOfWorkers() = 1
[11:02:37.496] plan(): Setting new future strategy stack:
[11:02:37.496] List of future strategies:
[11:02:37.496] 1. sequential:
[11:02:37.496]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:37.496]    - tweaked: FALSE
[11:02:37.496]    - call: plan(strategy)
[11:02:37.497] plan(): nbrOfWorkers() = 1
[11:02:37.497] SequentialFuture started (and completed)
[11:02:37.497] - Launch lazy future ... done
[11:02:37.497] run() for ‘SequentialFuture’ ... done
[11:02:37.497] getGlobalsAndPackages() ...
[11:02:37.497] Searching for globals...
[11:02:37.498] - globals found: [1] ‘{’
[11:02:37.498] Searching for globals ... DONE
[11:02:37.498] Resolving globals: FALSE
[11:02:37.498] 
[11:02:37.498] 
[11:02:37.498] getGlobalsAndPackages() ... DONE
[11:02:37.499] run() for ‘Future’ ...
[11:02:37.499] - state: ‘created’
[11:02:37.499] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:02:37.499] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:37.499] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:37.499]   - Field: ‘label’
[11:02:37.499]   - Field: ‘local’
[11:02:37.499]   - Field: ‘owner’
[11:02:37.500]   - Field: ‘envir’
[11:02:37.500]   - Field: ‘packages’
[11:02:37.500]   - Field: ‘gc’
[11:02:37.500]   - Field: ‘conditions’
[11:02:37.500]   - Field: ‘expr’
[11:02:37.500]   - Field: ‘uuid’
[11:02:37.500]   - Field: ‘seed’
[11:02:37.500]   - Field: ‘version’
[11:02:37.500]   - Field: ‘result’
[11:02:37.500]   - Field: ‘asynchronous’
[11:02:37.500]   - Field: ‘calls’
[11:02:37.500]   - Field: ‘globals’
[11:02:37.500]   - Field: ‘stdout’
[11:02:37.501]   - Field: ‘earlySignal’
[11:02:37.501]   - Field: ‘lazy’
[11:02:37.501]   - Field: ‘state’
[11:02:37.501] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:37.501] - Launch lazy future ...
[11:02:37.501] Packages needed by the future expression (n = 0): <none>
[11:02:37.501] Packages needed by future strategies (n = 0): <none>
[11:02:37.501] {
[11:02:37.501]     {
[11:02:37.501]         {
[11:02:37.501]             ...future.startTime <- base::Sys.time()
[11:02:37.501]             {
[11:02:37.501]                 {
[11:02:37.501]                   {
[11:02:37.501]                     base::local({
[11:02:37.501]                       has_future <- base::requireNamespace("future", 
[11:02:37.501]                         quietly = TRUE)
[11:02:37.501]                       if (has_future) {
[11:02:37.501]                         ns <- base::getNamespace("future")
[11:02:37.501]                         version <- ns[[".package"]][["version"]]
[11:02:37.501]                         if (is.null(version)) 
[11:02:37.501]                           version <- utils::packageVersion("future")
[11:02:37.501]                       }
[11:02:37.501]                       else {
[11:02:37.501]                         version <- NULL
[11:02:37.501]                       }
[11:02:37.501]                       if (!has_future || version < "1.8.0") {
[11:02:37.501]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:37.501]                           "", base::R.version$version.string), 
[11:02:37.501]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:37.501]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:37.501]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:37.501]                             "release", "version")], collapse = " "), 
[11:02:37.501]                           hostname = base::Sys.info()[["nodename"]])
[11:02:37.501]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:37.501]                           info)
[11:02:37.501]                         info <- base::paste(info, collapse = "; ")
[11:02:37.501]                         if (!has_future) {
[11:02:37.501]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:37.501]                             info)
[11:02:37.501]                         }
[11:02:37.501]                         else {
[11:02:37.501]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:37.501]                             info, version)
[11:02:37.501]                         }
[11:02:37.501]                         base::stop(msg)
[11:02:37.501]                       }
[11:02:37.501]                     })
[11:02:37.501]                   }
[11:02:37.501]                   ...future.strategy.old <- future::plan("list")
[11:02:37.501]                   options(future.plan = NULL)
[11:02:37.501]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:37.501]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:37.501]                 }
[11:02:37.501]                 ...future.workdir <- getwd()
[11:02:37.501]             }
[11:02:37.501]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:37.501]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:37.501]         }
[11:02:37.501]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:37.501]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:37.501]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:37.501]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:37.501]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:37.501]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:37.501]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:37.501]             base::names(...future.oldOptions))
[11:02:37.501]     }
[11:02:37.501]     if (FALSE) {
[11:02:37.501]     }
[11:02:37.501]     else {
[11:02:37.501]         if (TRUE) {
[11:02:37.501]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:37.501]                 open = "w")
[11:02:37.501]         }
[11:02:37.501]         else {
[11:02:37.501]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:37.501]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:37.501]         }
[11:02:37.501]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:37.501]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:37.501]             base::sink(type = "output", split = FALSE)
[11:02:37.501]             base::close(...future.stdout)
[11:02:37.501]         }, add = TRUE)
[11:02:37.501]     }
[11:02:37.501]     ...future.frame <- base::sys.nframe()
[11:02:37.501]     ...future.conditions <- base::list()
[11:02:37.501]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:37.501]     if (FALSE) {
[11:02:37.501]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:37.501]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:37.501]     }
[11:02:37.501]     ...future.result <- base::tryCatch({
[11:02:37.501]         base::withCallingHandlers({
[11:02:37.501]             ...future.value <- base::withVisible(base::local({
[11:02:37.501]                 2
[11:02:37.501]             }))
[11:02:37.501]             future::FutureResult(value = ...future.value$value, 
[11:02:37.501]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:37.501]                   ...future.rng), globalenv = if (FALSE) 
[11:02:37.501]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:37.501]                     ...future.globalenv.names))
[11:02:37.501]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:37.501]         }, condition = base::local({
[11:02:37.501]             c <- base::c
[11:02:37.501]             inherits <- base::inherits
[11:02:37.501]             invokeRestart <- base::invokeRestart
[11:02:37.501]             length <- base::length
[11:02:37.501]             list <- base::list
[11:02:37.501]             seq.int <- base::seq.int
[11:02:37.501]             signalCondition <- base::signalCondition
[11:02:37.501]             sys.calls <- base::sys.calls
[11:02:37.501]             `[[` <- base::`[[`
[11:02:37.501]             `+` <- base::`+`
[11:02:37.501]             `<<-` <- base::`<<-`
[11:02:37.501]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:37.501]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:37.501]                   3L)]
[11:02:37.501]             }
[11:02:37.501]             function(cond) {
[11:02:37.501]                 is_error <- inherits(cond, "error")
[11:02:37.501]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:37.501]                   NULL)
[11:02:37.501]                 if (is_error) {
[11:02:37.501]                   sessionInformation <- function() {
[11:02:37.501]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:37.501]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:37.501]                       search = base::search(), system = base::Sys.info())
[11:02:37.501]                   }
[11:02:37.501]                   ...future.conditions[[length(...future.conditions) + 
[11:02:37.501]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:37.501]                     cond$call), session = sessionInformation(), 
[11:02:37.501]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:37.501]                   signalCondition(cond)
[11:02:37.501]                 }
[11:02:37.501]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:37.501]                 "immediateCondition"))) {
[11:02:37.501]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:37.501]                   ...future.conditions[[length(...future.conditions) + 
[11:02:37.501]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:37.501]                   if (TRUE && !signal) {
[11:02:37.501]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:37.501]                     {
[11:02:37.501]                       inherits <- base::inherits
[11:02:37.501]                       invokeRestart <- base::invokeRestart
[11:02:37.501]                       is.null <- base::is.null
[11:02:37.501]                       muffled <- FALSE
[11:02:37.501]                       if (inherits(cond, "message")) {
[11:02:37.501]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:37.501]                         if (muffled) 
[11:02:37.501]                           invokeRestart("muffleMessage")
[11:02:37.501]                       }
[11:02:37.501]                       else if (inherits(cond, "warning")) {
[11:02:37.501]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:37.501]                         if (muffled) 
[11:02:37.501]                           invokeRestart("muffleWarning")
[11:02:37.501]                       }
[11:02:37.501]                       else if (inherits(cond, "condition")) {
[11:02:37.501]                         if (!is.null(pattern)) {
[11:02:37.501]                           computeRestarts <- base::computeRestarts
[11:02:37.501]                           grepl <- base::grepl
[11:02:37.501]                           restarts <- computeRestarts(cond)
[11:02:37.501]                           for (restart in restarts) {
[11:02:37.501]                             name <- restart$name
[11:02:37.501]                             if (is.null(name)) 
[11:02:37.501]                               next
[11:02:37.501]                             if (!grepl(pattern, name)) 
[11:02:37.501]                               next
[11:02:37.501]                             invokeRestart(restart)
[11:02:37.501]                             muffled <- TRUE
[11:02:37.501]                             break
[11:02:37.501]                           }
[11:02:37.501]                         }
[11:02:37.501]                       }
[11:02:37.501]                       invisible(muffled)
[11:02:37.501]                     }
[11:02:37.501]                     muffleCondition(cond, pattern = "^muffle")
[11:02:37.501]                   }
[11:02:37.501]                 }
[11:02:37.501]                 else {
[11:02:37.501]                   if (TRUE) {
[11:02:37.501]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:37.501]                     {
[11:02:37.501]                       inherits <- base::inherits
[11:02:37.501]                       invokeRestart <- base::invokeRestart
[11:02:37.501]                       is.null <- base::is.null
[11:02:37.501]                       muffled <- FALSE
[11:02:37.501]                       if (inherits(cond, "message")) {
[11:02:37.501]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:37.501]                         if (muffled) 
[11:02:37.501]                           invokeRestart("muffleMessage")
[11:02:37.501]                       }
[11:02:37.501]                       else if (inherits(cond, "warning")) {
[11:02:37.501]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:37.501]                         if (muffled) 
[11:02:37.501]                           invokeRestart("muffleWarning")
[11:02:37.501]                       }
[11:02:37.501]                       else if (inherits(cond, "condition")) {
[11:02:37.501]                         if (!is.null(pattern)) {
[11:02:37.501]                           computeRestarts <- base::computeRestarts
[11:02:37.501]                           grepl <- base::grepl
[11:02:37.501]                           restarts <- computeRestarts(cond)
[11:02:37.501]                           for (restart in restarts) {
[11:02:37.501]                             name <- restart$name
[11:02:37.501]                             if (is.null(name)) 
[11:02:37.501]                               next
[11:02:37.501]                             if (!grepl(pattern, name)) 
[11:02:37.501]                               next
[11:02:37.501]                             invokeRestart(restart)
[11:02:37.501]                             muffled <- TRUE
[11:02:37.501]                             break
[11:02:37.501]                           }
[11:02:37.501]                         }
[11:02:37.501]                       }
[11:02:37.501]                       invisible(muffled)
[11:02:37.501]                     }
[11:02:37.501]                     muffleCondition(cond, pattern = "^muffle")
[11:02:37.501]                   }
[11:02:37.501]                 }
[11:02:37.501]             }
[11:02:37.501]         }))
[11:02:37.501]     }, error = function(ex) {
[11:02:37.501]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:37.501]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:37.501]                 ...future.rng), started = ...future.startTime, 
[11:02:37.501]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:37.501]             version = "1.8"), class = "FutureResult")
[11:02:37.501]     }, finally = {
[11:02:37.501]         if (!identical(...future.workdir, getwd())) 
[11:02:37.501]             setwd(...future.workdir)
[11:02:37.501]         {
[11:02:37.501]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:37.501]                 ...future.oldOptions$nwarnings <- NULL
[11:02:37.501]             }
[11:02:37.501]             base::options(...future.oldOptions)
[11:02:37.501]             if (.Platform$OS.type == "windows") {
[11:02:37.501]                 old_names <- names(...future.oldEnvVars)
[11:02:37.501]                 envs <- base::Sys.getenv()
[11:02:37.501]                 names <- names(envs)
[11:02:37.501]                 common <- intersect(names, old_names)
[11:02:37.501]                 added <- setdiff(names, old_names)
[11:02:37.501]                 removed <- setdiff(old_names, names)
[11:02:37.501]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:37.501]                   envs[common]]
[11:02:37.501]                 NAMES <- toupper(changed)
[11:02:37.501]                 args <- list()
[11:02:37.501]                 for (kk in seq_along(NAMES)) {
[11:02:37.501]                   name <- changed[[kk]]
[11:02:37.501]                   NAME <- NAMES[[kk]]
[11:02:37.501]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.501]                     next
[11:02:37.501]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:37.501]                 }
[11:02:37.501]                 NAMES <- toupper(added)
[11:02:37.501]                 for (kk in seq_along(NAMES)) {
[11:02:37.501]                   name <- added[[kk]]
[11:02:37.501]                   NAME <- NAMES[[kk]]
[11:02:37.501]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.501]                     next
[11:02:37.501]                   args[[name]] <- ""
[11:02:37.501]                 }
[11:02:37.501]                 NAMES <- toupper(removed)
[11:02:37.501]                 for (kk in seq_along(NAMES)) {
[11:02:37.501]                   name <- removed[[kk]]
[11:02:37.501]                   NAME <- NAMES[[kk]]
[11:02:37.501]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.501]                     next
[11:02:37.501]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:37.501]                 }
[11:02:37.501]                 if (length(args) > 0) 
[11:02:37.501]                   base::do.call(base::Sys.setenv, args = args)
[11:02:37.501]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:37.501]             }
[11:02:37.501]             else {
[11:02:37.501]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:37.501]             }
[11:02:37.501]             {
[11:02:37.501]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:37.501]                   0L) {
[11:02:37.501]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:37.501]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:37.501]                   base::options(opts)
[11:02:37.501]                 }
[11:02:37.501]                 {
[11:02:37.501]                   {
[11:02:37.501]                     NULL
[11:02:37.501]                     RNGkind("Mersenne-Twister")
[11:02:37.501]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:37.501]                       inherits = FALSE)
[11:02:37.501]                   }
[11:02:37.501]                   options(future.plan = NULL)
[11:02:37.501]                   if (is.na(NA_character_)) 
[11:02:37.501]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:37.501]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:37.501]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:37.501]                     .init = FALSE)
[11:02:37.501]                 }
[11:02:37.501]             }
[11:02:37.501]         }
[11:02:37.501]     })
[11:02:37.501]     if (TRUE) {
[11:02:37.501]         base::sink(type = "output", split = FALSE)
[11:02:37.501]         if (TRUE) {
[11:02:37.501]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:37.501]         }
[11:02:37.501]         else {
[11:02:37.501]             ...future.result["stdout"] <- base::list(NULL)
[11:02:37.501]         }
[11:02:37.501]         base::close(...future.stdout)
[11:02:37.501]         ...future.stdout <- NULL
[11:02:37.501]     }
[11:02:37.501]     ...future.result$conditions <- ...future.conditions
[11:02:37.501]     ...future.result$finished <- base::Sys.time()
[11:02:37.501]     ...future.result
[11:02:37.501] }
[11:02:37.503] plan(): Setting new future strategy stack:
[11:02:37.503] List of future strategies:
[11:02:37.503] 1. sequential:
[11:02:37.503]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:37.503]    - tweaked: FALSE
[11:02:37.503]    - call: NULL
[11:02:37.504] plan(): nbrOfWorkers() = 1
[11:02:37.504] plan(): Setting new future strategy stack:
[11:02:37.504] List of future strategies:
[11:02:37.504] 1. sequential:
[11:02:37.504]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:37.504]    - tweaked: FALSE
[11:02:37.504]    - call: plan(strategy)
[11:02:37.505] plan(): nbrOfWorkers() = 1
[11:02:37.505] SequentialFuture started (and completed)
[11:02:37.505] - Launch lazy future ... done
[11:02:37.505] run() for ‘SequentialFuture’ ... done
[11:02:37.506] resolve() on environment ...
[11:02:37.506]  recursive: 0
[11:02:37.506]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[11:02:37.506] resolved() for ‘SequentialFuture’ ...
[11:02:37.506] - state: ‘finished’
[11:02:37.506] - run: TRUE
[11:02:37.507] - result: ‘FutureResult’
[11:02:37.507] resolved() for ‘SequentialFuture’ ... done
[11:02:37.507] Future #1
[11:02:37.507]  length: 2 (resolved future 1)
[11:02:37.507] resolved() for ‘SequentialFuture’ ...
[11:02:37.507] - state: ‘finished’
[11:02:37.507] - run: TRUE
[11:02:37.507] - result: ‘FutureResult’
[11:02:37.507] resolved() for ‘SequentialFuture’ ... done
[11:02:37.507] Future #2
[11:02:37.507]  length: 1 (resolved future 2)
[11:02:37.507]  length: 0 (resolved future 3)
[11:02:37.508] resolve() on environment ... DONE
[11:02:37.508] getGlobalsAndPackages() ...
[11:02:37.508] Searching for globals...
[11:02:37.509] - globals found: [1] ‘{’
[11:02:37.509] Searching for globals ... DONE
[11:02:37.509] Resolving globals: FALSE
[11:02:37.509] 
[11:02:37.509] 
[11:02:37.509] getGlobalsAndPackages() ... DONE
[11:02:37.509] run() for ‘Future’ ...
[11:02:37.509] - state: ‘created’
[11:02:37.510] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:02:37.510] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:37.510] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:37.510]   - Field: ‘label’
[11:02:37.510]   - Field: ‘local’
[11:02:37.510]   - Field: ‘owner’
[11:02:37.510]   - Field: ‘envir’
[11:02:37.510]   - Field: ‘packages’
[11:02:37.510]   - Field: ‘gc’
[11:02:37.510]   - Field: ‘conditions’
[11:02:37.511]   - Field: ‘expr’
[11:02:37.511]   - Field: ‘uuid’
[11:02:37.511]   - Field: ‘seed’
[11:02:37.511]   - Field: ‘version’
[11:02:37.511]   - Field: ‘result’
[11:02:37.511]   - Field: ‘asynchronous’
[11:02:37.511]   - Field: ‘calls’
[11:02:37.511]   - Field: ‘globals’
[11:02:37.511]   - Field: ‘stdout’
[11:02:37.511]   - Field: ‘earlySignal’
[11:02:37.511]   - Field: ‘lazy’
[11:02:37.511]   - Field: ‘state’
[11:02:37.511] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:37.512] - Launch lazy future ...
[11:02:37.512] Packages needed by the future expression (n = 0): <none>
[11:02:37.512] Packages needed by future strategies (n = 0): <none>
[11:02:37.512] {
[11:02:37.512]     {
[11:02:37.512]         {
[11:02:37.512]             ...future.startTime <- base::Sys.time()
[11:02:37.512]             {
[11:02:37.512]                 {
[11:02:37.512]                   {
[11:02:37.512]                     base::local({
[11:02:37.512]                       has_future <- base::requireNamespace("future", 
[11:02:37.512]                         quietly = TRUE)
[11:02:37.512]                       if (has_future) {
[11:02:37.512]                         ns <- base::getNamespace("future")
[11:02:37.512]                         version <- ns[[".package"]][["version"]]
[11:02:37.512]                         if (is.null(version)) 
[11:02:37.512]                           version <- utils::packageVersion("future")
[11:02:37.512]                       }
[11:02:37.512]                       else {
[11:02:37.512]                         version <- NULL
[11:02:37.512]                       }
[11:02:37.512]                       if (!has_future || version < "1.8.0") {
[11:02:37.512]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:37.512]                           "", base::R.version$version.string), 
[11:02:37.512]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:37.512]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:37.512]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:37.512]                             "release", "version")], collapse = " "), 
[11:02:37.512]                           hostname = base::Sys.info()[["nodename"]])
[11:02:37.512]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:37.512]                           info)
[11:02:37.512]                         info <- base::paste(info, collapse = "; ")
[11:02:37.512]                         if (!has_future) {
[11:02:37.512]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:37.512]                             info)
[11:02:37.512]                         }
[11:02:37.512]                         else {
[11:02:37.512]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:37.512]                             info, version)
[11:02:37.512]                         }
[11:02:37.512]                         base::stop(msg)
[11:02:37.512]                       }
[11:02:37.512]                     })
[11:02:37.512]                   }
[11:02:37.512]                   ...future.strategy.old <- future::plan("list")
[11:02:37.512]                   options(future.plan = NULL)
[11:02:37.512]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:37.512]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:37.512]                 }
[11:02:37.512]                 ...future.workdir <- getwd()
[11:02:37.512]             }
[11:02:37.512]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:37.512]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:37.512]         }
[11:02:37.512]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:37.512]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:37.512]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:37.512]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:37.512]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:37.512]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:37.512]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:37.512]             base::names(...future.oldOptions))
[11:02:37.512]     }
[11:02:37.512]     if (FALSE) {
[11:02:37.512]     }
[11:02:37.512]     else {
[11:02:37.512]         if (TRUE) {
[11:02:37.512]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:37.512]                 open = "w")
[11:02:37.512]         }
[11:02:37.512]         else {
[11:02:37.512]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:37.512]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:37.512]         }
[11:02:37.512]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:37.512]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:37.512]             base::sink(type = "output", split = FALSE)
[11:02:37.512]             base::close(...future.stdout)
[11:02:37.512]         }, add = TRUE)
[11:02:37.512]     }
[11:02:37.512]     ...future.frame <- base::sys.nframe()
[11:02:37.512]     ...future.conditions <- base::list()
[11:02:37.512]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:37.512]     if (FALSE) {
[11:02:37.512]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:37.512]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:37.512]     }
[11:02:37.512]     ...future.result <- base::tryCatch({
[11:02:37.512]         base::withCallingHandlers({
[11:02:37.512]             ...future.value <- base::withVisible(base::local({
[11:02:37.512]                 1
[11:02:37.512]             }))
[11:02:37.512]             future::FutureResult(value = ...future.value$value, 
[11:02:37.512]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:37.512]                   ...future.rng), globalenv = if (FALSE) 
[11:02:37.512]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:37.512]                     ...future.globalenv.names))
[11:02:37.512]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:37.512]         }, condition = base::local({
[11:02:37.512]             c <- base::c
[11:02:37.512]             inherits <- base::inherits
[11:02:37.512]             invokeRestart <- base::invokeRestart
[11:02:37.512]             length <- base::length
[11:02:37.512]             list <- base::list
[11:02:37.512]             seq.int <- base::seq.int
[11:02:37.512]             signalCondition <- base::signalCondition
[11:02:37.512]             sys.calls <- base::sys.calls
[11:02:37.512]             `[[` <- base::`[[`
[11:02:37.512]             `+` <- base::`+`
[11:02:37.512]             `<<-` <- base::`<<-`
[11:02:37.512]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:37.512]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:37.512]                   3L)]
[11:02:37.512]             }
[11:02:37.512]             function(cond) {
[11:02:37.512]                 is_error <- inherits(cond, "error")
[11:02:37.512]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:37.512]                   NULL)
[11:02:37.512]                 if (is_error) {
[11:02:37.512]                   sessionInformation <- function() {
[11:02:37.512]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:37.512]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:37.512]                       search = base::search(), system = base::Sys.info())
[11:02:37.512]                   }
[11:02:37.512]                   ...future.conditions[[length(...future.conditions) + 
[11:02:37.512]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:37.512]                     cond$call), session = sessionInformation(), 
[11:02:37.512]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:37.512]                   signalCondition(cond)
[11:02:37.512]                 }
[11:02:37.512]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:37.512]                 "immediateCondition"))) {
[11:02:37.512]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:37.512]                   ...future.conditions[[length(...future.conditions) + 
[11:02:37.512]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:37.512]                   if (TRUE && !signal) {
[11:02:37.512]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:37.512]                     {
[11:02:37.512]                       inherits <- base::inherits
[11:02:37.512]                       invokeRestart <- base::invokeRestart
[11:02:37.512]                       is.null <- base::is.null
[11:02:37.512]                       muffled <- FALSE
[11:02:37.512]                       if (inherits(cond, "message")) {
[11:02:37.512]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:37.512]                         if (muffled) 
[11:02:37.512]                           invokeRestart("muffleMessage")
[11:02:37.512]                       }
[11:02:37.512]                       else if (inherits(cond, "warning")) {
[11:02:37.512]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:37.512]                         if (muffled) 
[11:02:37.512]                           invokeRestart("muffleWarning")
[11:02:37.512]                       }
[11:02:37.512]                       else if (inherits(cond, "condition")) {
[11:02:37.512]                         if (!is.null(pattern)) {
[11:02:37.512]                           computeRestarts <- base::computeRestarts
[11:02:37.512]                           grepl <- base::grepl
[11:02:37.512]                           restarts <- computeRestarts(cond)
[11:02:37.512]                           for (restart in restarts) {
[11:02:37.512]                             name <- restart$name
[11:02:37.512]                             if (is.null(name)) 
[11:02:37.512]                               next
[11:02:37.512]                             if (!grepl(pattern, name)) 
[11:02:37.512]                               next
[11:02:37.512]                             invokeRestart(restart)
[11:02:37.512]                             muffled <- TRUE
[11:02:37.512]                             break
[11:02:37.512]                           }
[11:02:37.512]                         }
[11:02:37.512]                       }
[11:02:37.512]                       invisible(muffled)
[11:02:37.512]                     }
[11:02:37.512]                     muffleCondition(cond, pattern = "^muffle")
[11:02:37.512]                   }
[11:02:37.512]                 }
[11:02:37.512]                 else {
[11:02:37.512]                   if (TRUE) {
[11:02:37.512]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:37.512]                     {
[11:02:37.512]                       inherits <- base::inherits
[11:02:37.512]                       invokeRestart <- base::invokeRestart
[11:02:37.512]                       is.null <- base::is.null
[11:02:37.512]                       muffled <- FALSE
[11:02:37.512]                       if (inherits(cond, "message")) {
[11:02:37.512]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:37.512]                         if (muffled) 
[11:02:37.512]                           invokeRestart("muffleMessage")
[11:02:37.512]                       }
[11:02:37.512]                       else if (inherits(cond, "warning")) {
[11:02:37.512]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:37.512]                         if (muffled) 
[11:02:37.512]                           invokeRestart("muffleWarning")
[11:02:37.512]                       }
[11:02:37.512]                       else if (inherits(cond, "condition")) {
[11:02:37.512]                         if (!is.null(pattern)) {
[11:02:37.512]                           computeRestarts <- base::computeRestarts
[11:02:37.512]                           grepl <- base::grepl
[11:02:37.512]                           restarts <- computeRestarts(cond)
[11:02:37.512]                           for (restart in restarts) {
[11:02:37.512]                             name <- restart$name
[11:02:37.512]                             if (is.null(name)) 
[11:02:37.512]                               next
[11:02:37.512]                             if (!grepl(pattern, name)) 
[11:02:37.512]                               next
[11:02:37.512]                             invokeRestart(restart)
[11:02:37.512]                             muffled <- TRUE
[11:02:37.512]                             break
[11:02:37.512]                           }
[11:02:37.512]                         }
[11:02:37.512]                       }
[11:02:37.512]                       invisible(muffled)
[11:02:37.512]                     }
[11:02:37.512]                     muffleCondition(cond, pattern = "^muffle")
[11:02:37.512]                   }
[11:02:37.512]                 }
[11:02:37.512]             }
[11:02:37.512]         }))
[11:02:37.512]     }, error = function(ex) {
[11:02:37.512]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:37.512]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:37.512]                 ...future.rng), started = ...future.startTime, 
[11:02:37.512]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:37.512]             version = "1.8"), class = "FutureResult")
[11:02:37.512]     }, finally = {
[11:02:37.512]         if (!identical(...future.workdir, getwd())) 
[11:02:37.512]             setwd(...future.workdir)
[11:02:37.512]         {
[11:02:37.512]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:37.512]                 ...future.oldOptions$nwarnings <- NULL
[11:02:37.512]             }
[11:02:37.512]             base::options(...future.oldOptions)
[11:02:37.512]             if (.Platform$OS.type == "windows") {
[11:02:37.512]                 old_names <- names(...future.oldEnvVars)
[11:02:37.512]                 envs <- base::Sys.getenv()
[11:02:37.512]                 names <- names(envs)
[11:02:37.512]                 common <- intersect(names, old_names)
[11:02:37.512]                 added <- setdiff(names, old_names)
[11:02:37.512]                 removed <- setdiff(old_names, names)
[11:02:37.512]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:37.512]                   envs[common]]
[11:02:37.512]                 NAMES <- toupper(changed)
[11:02:37.512]                 args <- list()
[11:02:37.512]                 for (kk in seq_along(NAMES)) {
[11:02:37.512]                   name <- changed[[kk]]
[11:02:37.512]                   NAME <- NAMES[[kk]]
[11:02:37.512]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.512]                     next
[11:02:37.512]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:37.512]                 }
[11:02:37.512]                 NAMES <- toupper(added)
[11:02:37.512]                 for (kk in seq_along(NAMES)) {
[11:02:37.512]                   name <- added[[kk]]
[11:02:37.512]                   NAME <- NAMES[[kk]]
[11:02:37.512]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.512]                     next
[11:02:37.512]                   args[[name]] <- ""
[11:02:37.512]                 }
[11:02:37.512]                 NAMES <- toupper(removed)
[11:02:37.512]                 for (kk in seq_along(NAMES)) {
[11:02:37.512]                   name <- removed[[kk]]
[11:02:37.512]                   NAME <- NAMES[[kk]]
[11:02:37.512]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.512]                     next
[11:02:37.512]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:37.512]                 }
[11:02:37.512]                 if (length(args) > 0) 
[11:02:37.512]                   base::do.call(base::Sys.setenv, args = args)
[11:02:37.512]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:37.512]             }
[11:02:37.512]             else {
[11:02:37.512]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:37.512]             }
[11:02:37.512]             {
[11:02:37.512]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:37.512]                   0L) {
[11:02:37.512]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:37.512]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:37.512]                   base::options(opts)
[11:02:37.512]                 }
[11:02:37.512]                 {
[11:02:37.512]                   {
[11:02:37.512]                     NULL
[11:02:37.512]                     RNGkind("Mersenne-Twister")
[11:02:37.512]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:37.512]                       inherits = FALSE)
[11:02:37.512]                   }
[11:02:37.512]                   options(future.plan = NULL)
[11:02:37.512]                   if (is.na(NA_character_)) 
[11:02:37.512]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:37.512]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:37.512]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:37.512]                     .init = FALSE)
[11:02:37.512]                 }
[11:02:37.512]             }
[11:02:37.512]         }
[11:02:37.512]     })
[11:02:37.512]     if (TRUE) {
[11:02:37.512]         base::sink(type = "output", split = FALSE)
[11:02:37.512]         if (TRUE) {
[11:02:37.512]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:37.512]         }
[11:02:37.512]         else {
[11:02:37.512]             ...future.result["stdout"] <- base::list(NULL)
[11:02:37.512]         }
[11:02:37.512]         base::close(...future.stdout)
[11:02:37.512]         ...future.stdout <- NULL
[11:02:37.512]     }
[11:02:37.512]     ...future.result$conditions <- ...future.conditions
[11:02:37.512]     ...future.result$finished <- base::Sys.time()
[11:02:37.512]     ...future.result
[11:02:37.512] }
[11:02:37.514] plan(): Setting new future strategy stack:
[11:02:37.514] List of future strategies:
[11:02:37.514] 1. sequential:
[11:02:37.514]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:37.514]    - tweaked: FALSE
[11:02:37.514]    - call: NULL
[11:02:37.514] plan(): nbrOfWorkers() = 1
[11:02:37.515] plan(): Setting new future strategy stack:
[11:02:37.515] List of future strategies:
[11:02:37.515] 1. sequential:
[11:02:37.515]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:37.515]    - tweaked: FALSE
[11:02:37.515]    - call: plan(strategy)
[11:02:37.517] plan(): nbrOfWorkers() = 1
[11:02:37.517] SequentialFuture started (and completed)
[11:02:37.517] - Launch lazy future ... done
[11:02:37.517] run() for ‘SequentialFuture’ ... done
[11:02:37.517] getGlobalsAndPackages() ...
[11:02:37.517] Searching for globals...
[11:02:37.518] - globals found: [1] ‘{’
[11:02:37.518] Searching for globals ... DONE
[11:02:37.518] Resolving globals: FALSE
[11:02:37.518] 
[11:02:37.518] 
[11:02:37.518] getGlobalsAndPackages() ... DONE
[11:02:37.519] run() for ‘Future’ ...
[11:02:37.519] - state: ‘created’
[11:02:37.519] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:02:37.519] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:37.519] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:37.519]   - Field: ‘label’
[11:02:37.519]   - Field: ‘local’
[11:02:37.519]   - Field: ‘owner’
[11:02:37.520]   - Field: ‘envir’
[11:02:37.520]   - Field: ‘packages’
[11:02:37.520]   - Field: ‘gc’
[11:02:37.520]   - Field: ‘conditions’
[11:02:37.520]   - Field: ‘expr’
[11:02:37.520]   - Field: ‘uuid’
[11:02:37.520]   - Field: ‘seed’
[11:02:37.520]   - Field: ‘version’
[11:02:37.520]   - Field: ‘result’
[11:02:37.520]   - Field: ‘asynchronous’
[11:02:37.520]   - Field: ‘calls’
[11:02:37.520]   - Field: ‘globals’
[11:02:37.521]   - Field: ‘stdout’
[11:02:37.521]   - Field: ‘earlySignal’
[11:02:37.521]   - Field: ‘lazy’
[11:02:37.521]   - Field: ‘state’
[11:02:37.521] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:37.521] - Launch lazy future ...
[11:02:37.521] Packages needed by the future expression (n = 0): <none>
[11:02:37.521] Packages needed by future strategies (n = 0): <none>
[11:02:37.522] {
[11:02:37.522]     {
[11:02:37.522]         {
[11:02:37.522]             ...future.startTime <- base::Sys.time()
[11:02:37.522]             {
[11:02:37.522]                 {
[11:02:37.522]                   {
[11:02:37.522]                     base::local({
[11:02:37.522]                       has_future <- base::requireNamespace("future", 
[11:02:37.522]                         quietly = TRUE)
[11:02:37.522]                       if (has_future) {
[11:02:37.522]                         ns <- base::getNamespace("future")
[11:02:37.522]                         version <- ns[[".package"]][["version"]]
[11:02:37.522]                         if (is.null(version)) 
[11:02:37.522]                           version <- utils::packageVersion("future")
[11:02:37.522]                       }
[11:02:37.522]                       else {
[11:02:37.522]                         version <- NULL
[11:02:37.522]                       }
[11:02:37.522]                       if (!has_future || version < "1.8.0") {
[11:02:37.522]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:37.522]                           "", base::R.version$version.string), 
[11:02:37.522]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:37.522]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:37.522]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:37.522]                             "release", "version")], collapse = " "), 
[11:02:37.522]                           hostname = base::Sys.info()[["nodename"]])
[11:02:37.522]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:37.522]                           info)
[11:02:37.522]                         info <- base::paste(info, collapse = "; ")
[11:02:37.522]                         if (!has_future) {
[11:02:37.522]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:37.522]                             info)
[11:02:37.522]                         }
[11:02:37.522]                         else {
[11:02:37.522]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:37.522]                             info, version)
[11:02:37.522]                         }
[11:02:37.522]                         base::stop(msg)
[11:02:37.522]                       }
[11:02:37.522]                     })
[11:02:37.522]                   }
[11:02:37.522]                   ...future.strategy.old <- future::plan("list")
[11:02:37.522]                   options(future.plan = NULL)
[11:02:37.522]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:37.522]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:37.522]                 }
[11:02:37.522]                 ...future.workdir <- getwd()
[11:02:37.522]             }
[11:02:37.522]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:37.522]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:37.522]         }
[11:02:37.522]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:37.522]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:37.522]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:37.522]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:37.522]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:37.522]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:37.522]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:37.522]             base::names(...future.oldOptions))
[11:02:37.522]     }
[11:02:37.522]     if (FALSE) {
[11:02:37.522]     }
[11:02:37.522]     else {
[11:02:37.522]         if (TRUE) {
[11:02:37.522]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:37.522]                 open = "w")
[11:02:37.522]         }
[11:02:37.522]         else {
[11:02:37.522]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:37.522]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:37.522]         }
[11:02:37.522]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:37.522]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:37.522]             base::sink(type = "output", split = FALSE)
[11:02:37.522]             base::close(...future.stdout)
[11:02:37.522]         }, add = TRUE)
[11:02:37.522]     }
[11:02:37.522]     ...future.frame <- base::sys.nframe()
[11:02:37.522]     ...future.conditions <- base::list()
[11:02:37.522]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:37.522]     if (FALSE) {
[11:02:37.522]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:37.522]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:37.522]     }
[11:02:37.522]     ...future.result <- base::tryCatch({
[11:02:37.522]         base::withCallingHandlers({
[11:02:37.522]             ...future.value <- base::withVisible(base::local({
[11:02:37.522]                 2
[11:02:37.522]             }))
[11:02:37.522]             future::FutureResult(value = ...future.value$value, 
[11:02:37.522]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:37.522]                   ...future.rng), globalenv = if (FALSE) 
[11:02:37.522]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:37.522]                     ...future.globalenv.names))
[11:02:37.522]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:37.522]         }, condition = base::local({
[11:02:37.522]             c <- base::c
[11:02:37.522]             inherits <- base::inherits
[11:02:37.522]             invokeRestart <- base::invokeRestart
[11:02:37.522]             length <- base::length
[11:02:37.522]             list <- base::list
[11:02:37.522]             seq.int <- base::seq.int
[11:02:37.522]             signalCondition <- base::signalCondition
[11:02:37.522]             sys.calls <- base::sys.calls
[11:02:37.522]             `[[` <- base::`[[`
[11:02:37.522]             `+` <- base::`+`
[11:02:37.522]             `<<-` <- base::`<<-`
[11:02:37.522]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:37.522]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:37.522]                   3L)]
[11:02:37.522]             }
[11:02:37.522]             function(cond) {
[11:02:37.522]                 is_error <- inherits(cond, "error")
[11:02:37.522]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:37.522]                   NULL)
[11:02:37.522]                 if (is_error) {
[11:02:37.522]                   sessionInformation <- function() {
[11:02:37.522]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:37.522]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:37.522]                       search = base::search(), system = base::Sys.info())
[11:02:37.522]                   }
[11:02:37.522]                   ...future.conditions[[length(...future.conditions) + 
[11:02:37.522]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:37.522]                     cond$call), session = sessionInformation(), 
[11:02:37.522]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:37.522]                   signalCondition(cond)
[11:02:37.522]                 }
[11:02:37.522]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:37.522]                 "immediateCondition"))) {
[11:02:37.522]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:37.522]                   ...future.conditions[[length(...future.conditions) + 
[11:02:37.522]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:37.522]                   if (TRUE && !signal) {
[11:02:37.522]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:37.522]                     {
[11:02:37.522]                       inherits <- base::inherits
[11:02:37.522]                       invokeRestart <- base::invokeRestart
[11:02:37.522]                       is.null <- base::is.null
[11:02:37.522]                       muffled <- FALSE
[11:02:37.522]                       if (inherits(cond, "message")) {
[11:02:37.522]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:37.522]                         if (muffled) 
[11:02:37.522]                           invokeRestart("muffleMessage")
[11:02:37.522]                       }
[11:02:37.522]                       else if (inherits(cond, "warning")) {
[11:02:37.522]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:37.522]                         if (muffled) 
[11:02:37.522]                           invokeRestart("muffleWarning")
[11:02:37.522]                       }
[11:02:37.522]                       else if (inherits(cond, "condition")) {
[11:02:37.522]                         if (!is.null(pattern)) {
[11:02:37.522]                           computeRestarts <- base::computeRestarts
[11:02:37.522]                           grepl <- base::grepl
[11:02:37.522]                           restarts <- computeRestarts(cond)
[11:02:37.522]                           for (restart in restarts) {
[11:02:37.522]                             name <- restart$name
[11:02:37.522]                             if (is.null(name)) 
[11:02:37.522]                               next
[11:02:37.522]                             if (!grepl(pattern, name)) 
[11:02:37.522]                               next
[11:02:37.522]                             invokeRestart(restart)
[11:02:37.522]                             muffled <- TRUE
[11:02:37.522]                             break
[11:02:37.522]                           }
[11:02:37.522]                         }
[11:02:37.522]                       }
[11:02:37.522]                       invisible(muffled)
[11:02:37.522]                     }
[11:02:37.522]                     muffleCondition(cond, pattern = "^muffle")
[11:02:37.522]                   }
[11:02:37.522]                 }
[11:02:37.522]                 else {
[11:02:37.522]                   if (TRUE) {
[11:02:37.522]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:37.522]                     {
[11:02:37.522]                       inherits <- base::inherits
[11:02:37.522]                       invokeRestart <- base::invokeRestart
[11:02:37.522]                       is.null <- base::is.null
[11:02:37.522]                       muffled <- FALSE
[11:02:37.522]                       if (inherits(cond, "message")) {
[11:02:37.522]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:37.522]                         if (muffled) 
[11:02:37.522]                           invokeRestart("muffleMessage")
[11:02:37.522]                       }
[11:02:37.522]                       else if (inherits(cond, "warning")) {
[11:02:37.522]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:37.522]                         if (muffled) 
[11:02:37.522]                           invokeRestart("muffleWarning")
[11:02:37.522]                       }
[11:02:37.522]                       else if (inherits(cond, "condition")) {
[11:02:37.522]                         if (!is.null(pattern)) {
[11:02:37.522]                           computeRestarts <- base::computeRestarts
[11:02:37.522]                           grepl <- base::grepl
[11:02:37.522]                           restarts <- computeRestarts(cond)
[11:02:37.522]                           for (restart in restarts) {
[11:02:37.522]                             name <- restart$name
[11:02:37.522]                             if (is.null(name)) 
[11:02:37.522]                               next
[11:02:37.522]                             if (!grepl(pattern, name)) 
[11:02:37.522]                               next
[11:02:37.522]                             invokeRestart(restart)
[11:02:37.522]                             muffled <- TRUE
[11:02:37.522]                             break
[11:02:37.522]                           }
[11:02:37.522]                         }
[11:02:37.522]                       }
[11:02:37.522]                       invisible(muffled)
[11:02:37.522]                     }
[11:02:37.522]                     muffleCondition(cond, pattern = "^muffle")
[11:02:37.522]                   }
[11:02:37.522]                 }
[11:02:37.522]             }
[11:02:37.522]         }))
[11:02:37.522]     }, error = function(ex) {
[11:02:37.522]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:37.522]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:37.522]                 ...future.rng), started = ...future.startTime, 
[11:02:37.522]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:37.522]             version = "1.8"), class = "FutureResult")
[11:02:37.522]     }, finally = {
[11:02:37.522]         if (!identical(...future.workdir, getwd())) 
[11:02:37.522]             setwd(...future.workdir)
[11:02:37.522]         {
[11:02:37.522]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:37.522]                 ...future.oldOptions$nwarnings <- NULL
[11:02:37.522]             }
[11:02:37.522]             base::options(...future.oldOptions)
[11:02:37.522]             if (.Platform$OS.type == "windows") {
[11:02:37.522]                 old_names <- names(...future.oldEnvVars)
[11:02:37.522]                 envs <- base::Sys.getenv()
[11:02:37.522]                 names <- names(envs)
[11:02:37.522]                 common <- intersect(names, old_names)
[11:02:37.522]                 added <- setdiff(names, old_names)
[11:02:37.522]                 removed <- setdiff(old_names, names)
[11:02:37.522]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:37.522]                   envs[common]]
[11:02:37.522]                 NAMES <- toupper(changed)
[11:02:37.522]                 args <- list()
[11:02:37.522]                 for (kk in seq_along(NAMES)) {
[11:02:37.522]                   name <- changed[[kk]]
[11:02:37.522]                   NAME <- NAMES[[kk]]
[11:02:37.522]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.522]                     next
[11:02:37.522]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:37.522]                 }
[11:02:37.522]                 NAMES <- toupper(added)
[11:02:37.522]                 for (kk in seq_along(NAMES)) {
[11:02:37.522]                   name <- added[[kk]]
[11:02:37.522]                   NAME <- NAMES[[kk]]
[11:02:37.522]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.522]                     next
[11:02:37.522]                   args[[name]] <- ""
[11:02:37.522]                 }
[11:02:37.522]                 NAMES <- toupper(removed)
[11:02:37.522]                 for (kk in seq_along(NAMES)) {
[11:02:37.522]                   name <- removed[[kk]]
[11:02:37.522]                   NAME <- NAMES[[kk]]
[11:02:37.522]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.522]                     next
[11:02:37.522]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:37.522]                 }
[11:02:37.522]                 if (length(args) > 0) 
[11:02:37.522]                   base::do.call(base::Sys.setenv, args = args)
[11:02:37.522]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:37.522]             }
[11:02:37.522]             else {
[11:02:37.522]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:37.522]             }
[11:02:37.522]             {
[11:02:37.522]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:37.522]                   0L) {
[11:02:37.522]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:37.522]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:37.522]                   base::options(opts)
[11:02:37.522]                 }
[11:02:37.522]                 {
[11:02:37.522]                   {
[11:02:37.522]                     NULL
[11:02:37.522]                     RNGkind("Mersenne-Twister")
[11:02:37.522]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:37.522]                       inherits = FALSE)
[11:02:37.522]                   }
[11:02:37.522]                   options(future.plan = NULL)
[11:02:37.522]                   if (is.na(NA_character_)) 
[11:02:37.522]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:37.522]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:37.522]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:37.522]                     .init = FALSE)
[11:02:37.522]                 }
[11:02:37.522]             }
[11:02:37.522]         }
[11:02:37.522]     })
[11:02:37.522]     if (TRUE) {
[11:02:37.522]         base::sink(type = "output", split = FALSE)
[11:02:37.522]         if (TRUE) {
[11:02:37.522]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:37.522]         }
[11:02:37.522]         else {
[11:02:37.522]             ...future.result["stdout"] <- base::list(NULL)
[11:02:37.522]         }
[11:02:37.522]         base::close(...future.stdout)
[11:02:37.522]         ...future.stdout <- NULL
[11:02:37.522]     }
[11:02:37.522]     ...future.result$conditions <- ...future.conditions
[11:02:37.522]     ...future.result$finished <- base::Sys.time()
[11:02:37.522]     ...future.result
[11:02:37.522] }
[11:02:37.523] plan(): Setting new future strategy stack:
[11:02:37.523] List of future strategies:
[11:02:37.523] 1. sequential:
[11:02:37.523]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:37.523]    - tweaked: FALSE
[11:02:37.523]    - call: NULL
[11:02:37.524] plan(): nbrOfWorkers() = 1
[11:02:37.524] plan(): Setting new future strategy stack:
[11:02:37.525] List of future strategies:
[11:02:37.525] 1. sequential:
[11:02:37.525]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:37.525]    - tweaked: FALSE
[11:02:37.525]    - call: plan(strategy)
[11:02:37.525] plan(): nbrOfWorkers() = 1
[11:02:37.525] SequentialFuture started (and completed)
[11:02:37.525] - Launch lazy future ... done
[11:02:37.525] run() for ‘SequentialFuture’ ... done
[11:02:37.526] resolve() on environment ...
[11:02:37.526]  recursive: 0
[11:02:37.526]  elements: [3] ‘a’
[11:02:37.526] resolved() for ‘SequentialFuture’ ...
[11:02:37.526] - state: ‘finished’
[11:02:37.527] - run: TRUE
[11:02:37.527] - result: ‘FutureResult’
[11:02:37.527] resolved() for ‘SequentialFuture’ ... done
[11:02:37.527] Future #1
[11:02:37.527]  length: 2 (resolved future 1)
[11:02:37.527] resolved() for ‘SequentialFuture’ ...
[11:02:37.527] - state: ‘finished’
[11:02:37.527] - run: TRUE
[11:02:37.527] - result: ‘FutureResult’
[11:02:37.527] resolved() for ‘SequentialFuture’ ... done
[11:02:37.527] Future #2
[11:02:37.527]  length: 1 (resolved future 2)
[11:02:37.528]  length: 0 (resolved future 3)
[11:02:37.528] resolve() on environment ... DONE
[11:02:37.528] resolved() for ‘SequentialFuture’ ...
[11:02:37.528] - state: ‘finished’
[11:02:37.528] - run: TRUE
[11:02:37.528] - result: ‘FutureResult’
[11:02:37.528] resolved() for ‘SequentialFuture’ ... done
[11:02:37.528] resolve() on environment ...
[11:02:37.529]  recursive: 0
[11:02:37.529]  elements: [3] ‘b’
[11:02:37.529] resolved() for ‘SequentialFuture’ ...
[11:02:37.529] - state: ‘finished’
[11:02:37.529] - run: TRUE
[11:02:37.529] - result: ‘FutureResult’
[11:02:37.529] resolved() for ‘SequentialFuture’ ... done
[11:02:37.529] Future #1
[11:02:37.530]  length: 2 (resolved future 1)
[11:02:37.530] resolved() for ‘SequentialFuture’ ...
[11:02:37.530] - state: ‘finished’
[11:02:37.530] - run: TRUE
[11:02:37.530] - result: ‘FutureResult’
[11:02:37.530] resolved() for ‘SequentialFuture’ ... done
[11:02:37.530] Future #2
[11:02:37.530]  length: 1 (resolved future 2)
[11:02:37.530]  length: 0 (resolved future 3)
[11:02:37.530] resolve() on environment ... DONE
[11:02:37.531] resolve() on environment ...
[11:02:37.531]  recursive: 0
[11:02:37.531]  elements: [3] ‘c’
[11:02:37.531] resolved() for ‘SequentialFuture’ ...
[11:02:37.531] - state: ‘finished’
[11:02:37.531] - run: TRUE
[11:02:37.531] - result: ‘FutureResult’
[11:02:37.532] resolved() for ‘SequentialFuture’ ... done
[11:02:37.532] Future #1
[11:02:37.532]  length: 2 (resolved future 1)
[11:02:37.532] resolved() for ‘SequentialFuture’ ...
[11:02:37.532] - state: ‘finished’
[11:02:37.532] - run: TRUE
[11:02:37.532] - result: ‘FutureResult’
[11:02:37.532] resolved() for ‘SequentialFuture’ ... done
[11:02:37.532] Future #2
[11:02:37.532]  length: 1 (resolved future 2)
[11:02:37.532]  length: 0 (resolved future 3)
[11:02:37.533] resolve() on environment ... DONE
[11:02:37.533] resolve() on environment ...
[11:02:37.533]  recursive: 0
[11:02:37.533]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[11:02:37.534] resolved() for ‘SequentialFuture’ ...
[11:02:37.534] - state: ‘finished’
[11:02:37.534] - run: TRUE
[11:02:37.534] - result: ‘FutureResult’
[11:02:37.534] resolved() for ‘SequentialFuture’ ... done
[11:02:37.534] Future #1
[11:02:37.534]  length: 2 (resolved future 1)
[11:02:37.534] resolved() for ‘SequentialFuture’ ...
[11:02:37.534] - state: ‘finished’
[11:02:37.535] - run: TRUE
[11:02:37.535] - result: ‘FutureResult’
[11:02:37.535] resolved() for ‘SequentialFuture’ ... done
[11:02:37.535] Future #2
[11:02:37.535]  length: 1 (resolved future 2)
[11:02:37.535]  length: 0 (resolved future 3)
[11:02:37.535] resolve() on environment ... DONE
[11:02:37.536] resolve() on environment ...
[11:02:37.536]  recursive: 99
[11:02:37.536]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[11:02:37.536] resolved() for ‘SequentialFuture’ ...
[11:02:37.536] - state: ‘finished’
[11:02:37.536] - run: TRUE
[11:02:37.536] - result: ‘FutureResult’
[11:02:37.536] resolved() for ‘SequentialFuture’ ... done
[11:02:37.537] Future #1
[11:02:37.537] resolved() for ‘SequentialFuture’ ...
[11:02:37.537] - state: ‘finished’
[11:02:37.537] - run: TRUE
[11:02:37.537] - result: ‘FutureResult’
[11:02:37.537] resolved() for ‘SequentialFuture’ ... done
[11:02:37.537] A SequentialFuture was resolved
[11:02:37.537]  length: 2 (resolved future 1)
[11:02:37.537] resolved() for ‘SequentialFuture’ ...
[11:02:37.537] - state: ‘finished’
[11:02:37.537] - run: TRUE
[11:02:37.538] - result: ‘FutureResult’
[11:02:37.538] resolved() for ‘SequentialFuture’ ... done
[11:02:37.538] Future #2
[11:02:37.538] resolved() for ‘SequentialFuture’ ...
[11:02:37.538] - state: ‘finished’
[11:02:37.539] - run: TRUE
[11:02:37.539] - result: ‘FutureResult’
[11:02:37.539] resolved() for ‘SequentialFuture’ ... done
[11:02:37.539] A SequentialFuture was resolved
[11:02:37.539]  length: 1 (resolved future 2)
[11:02:37.539]  length: 0 (resolved future 3)
[11:02:37.539] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[11:02:37.540] resolve() on list environment ...
[11:02:37.540]  recursive: 0
[11:02:37.541]  length: 2
[11:02:37.541]  elements: ‘a’, ‘b’
[11:02:37.541]  length: 1 (resolved future 1)
[11:02:37.542]  length: 0 (resolved future 2)
[11:02:37.542] resolve() on list environment ... DONE
[11:02:37.542] getGlobalsAndPackages() ...
[11:02:37.542] Searching for globals...
[11:02:37.542] 
[11:02:37.542] Searching for globals ... DONE
[11:02:37.542] - globals: [0] <none>
[11:02:37.542] getGlobalsAndPackages() ... DONE
[11:02:37.542] run() for ‘Future’ ...
[11:02:37.543] - state: ‘created’
[11:02:37.543] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:02:37.543] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:37.543] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:37.543]   - Field: ‘label’
[11:02:37.543]   - Field: ‘local’
[11:02:37.543]   - Field: ‘owner’
[11:02:37.543]   - Field: ‘envir’
[11:02:37.543]   - Field: ‘packages’
[11:02:37.544]   - Field: ‘gc’
[11:02:37.544]   - Field: ‘conditions’
[11:02:37.544]   - Field: ‘expr’
[11:02:37.544]   - Field: ‘uuid’
[11:02:37.544]   - Field: ‘seed’
[11:02:37.544]   - Field: ‘version’
[11:02:37.544]   - Field: ‘result’
[11:02:37.544]   - Field: ‘asynchronous’
[11:02:37.544]   - Field: ‘calls’
[11:02:37.544]   - Field: ‘globals’
[11:02:37.544]   - Field: ‘stdout’
[11:02:37.544]   - Field: ‘earlySignal’
[11:02:37.544]   - Field: ‘lazy’
[11:02:37.545]   - Field: ‘state’
[11:02:37.545] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:37.545] - Launch lazy future ...
[11:02:37.545] Packages needed by the future expression (n = 0): <none>
[11:02:37.545] Packages needed by future strategies (n = 0): <none>
[11:02:37.545] {
[11:02:37.545]     {
[11:02:37.545]         {
[11:02:37.545]             ...future.startTime <- base::Sys.time()
[11:02:37.545]             {
[11:02:37.545]                 {
[11:02:37.545]                   {
[11:02:37.545]                     base::local({
[11:02:37.545]                       has_future <- base::requireNamespace("future", 
[11:02:37.545]                         quietly = TRUE)
[11:02:37.545]                       if (has_future) {
[11:02:37.545]                         ns <- base::getNamespace("future")
[11:02:37.545]                         version <- ns[[".package"]][["version"]]
[11:02:37.545]                         if (is.null(version)) 
[11:02:37.545]                           version <- utils::packageVersion("future")
[11:02:37.545]                       }
[11:02:37.545]                       else {
[11:02:37.545]                         version <- NULL
[11:02:37.545]                       }
[11:02:37.545]                       if (!has_future || version < "1.8.0") {
[11:02:37.545]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:37.545]                           "", base::R.version$version.string), 
[11:02:37.545]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:37.545]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:37.545]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:37.545]                             "release", "version")], collapse = " "), 
[11:02:37.545]                           hostname = base::Sys.info()[["nodename"]])
[11:02:37.545]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:37.545]                           info)
[11:02:37.545]                         info <- base::paste(info, collapse = "; ")
[11:02:37.545]                         if (!has_future) {
[11:02:37.545]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:37.545]                             info)
[11:02:37.545]                         }
[11:02:37.545]                         else {
[11:02:37.545]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:37.545]                             info, version)
[11:02:37.545]                         }
[11:02:37.545]                         base::stop(msg)
[11:02:37.545]                       }
[11:02:37.545]                     })
[11:02:37.545]                   }
[11:02:37.545]                   ...future.strategy.old <- future::plan("list")
[11:02:37.545]                   options(future.plan = NULL)
[11:02:37.545]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:37.545]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:37.545]                 }
[11:02:37.545]                 ...future.workdir <- getwd()
[11:02:37.545]             }
[11:02:37.545]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:37.545]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:37.545]         }
[11:02:37.545]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:37.545]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:37.545]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:37.545]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:37.545]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:37.545]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:37.545]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:37.545]             base::names(...future.oldOptions))
[11:02:37.545]     }
[11:02:37.545]     if (FALSE) {
[11:02:37.545]     }
[11:02:37.545]     else {
[11:02:37.545]         if (TRUE) {
[11:02:37.545]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:37.545]                 open = "w")
[11:02:37.545]         }
[11:02:37.545]         else {
[11:02:37.545]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:37.545]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:37.545]         }
[11:02:37.545]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:37.545]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:37.545]             base::sink(type = "output", split = FALSE)
[11:02:37.545]             base::close(...future.stdout)
[11:02:37.545]         }, add = TRUE)
[11:02:37.545]     }
[11:02:37.545]     ...future.frame <- base::sys.nframe()
[11:02:37.545]     ...future.conditions <- base::list()
[11:02:37.545]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:37.545]     if (FALSE) {
[11:02:37.545]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:37.545]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:37.545]     }
[11:02:37.545]     ...future.result <- base::tryCatch({
[11:02:37.545]         base::withCallingHandlers({
[11:02:37.545]             ...future.value <- base::withVisible(base::local(1))
[11:02:37.545]             future::FutureResult(value = ...future.value$value, 
[11:02:37.545]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:37.545]                   ...future.rng), globalenv = if (FALSE) 
[11:02:37.545]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:37.545]                     ...future.globalenv.names))
[11:02:37.545]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:37.545]         }, condition = base::local({
[11:02:37.545]             c <- base::c
[11:02:37.545]             inherits <- base::inherits
[11:02:37.545]             invokeRestart <- base::invokeRestart
[11:02:37.545]             length <- base::length
[11:02:37.545]             list <- base::list
[11:02:37.545]             seq.int <- base::seq.int
[11:02:37.545]             signalCondition <- base::signalCondition
[11:02:37.545]             sys.calls <- base::sys.calls
[11:02:37.545]             `[[` <- base::`[[`
[11:02:37.545]             `+` <- base::`+`
[11:02:37.545]             `<<-` <- base::`<<-`
[11:02:37.545]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:37.545]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:37.545]                   3L)]
[11:02:37.545]             }
[11:02:37.545]             function(cond) {
[11:02:37.545]                 is_error <- inherits(cond, "error")
[11:02:37.545]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:37.545]                   NULL)
[11:02:37.545]                 if (is_error) {
[11:02:37.545]                   sessionInformation <- function() {
[11:02:37.545]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:37.545]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:37.545]                       search = base::search(), system = base::Sys.info())
[11:02:37.545]                   }
[11:02:37.545]                   ...future.conditions[[length(...future.conditions) + 
[11:02:37.545]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:37.545]                     cond$call), session = sessionInformation(), 
[11:02:37.545]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:37.545]                   signalCondition(cond)
[11:02:37.545]                 }
[11:02:37.545]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:37.545]                 "immediateCondition"))) {
[11:02:37.545]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:37.545]                   ...future.conditions[[length(...future.conditions) + 
[11:02:37.545]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:37.545]                   if (TRUE && !signal) {
[11:02:37.545]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:37.545]                     {
[11:02:37.545]                       inherits <- base::inherits
[11:02:37.545]                       invokeRestart <- base::invokeRestart
[11:02:37.545]                       is.null <- base::is.null
[11:02:37.545]                       muffled <- FALSE
[11:02:37.545]                       if (inherits(cond, "message")) {
[11:02:37.545]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:37.545]                         if (muffled) 
[11:02:37.545]                           invokeRestart("muffleMessage")
[11:02:37.545]                       }
[11:02:37.545]                       else if (inherits(cond, "warning")) {
[11:02:37.545]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:37.545]                         if (muffled) 
[11:02:37.545]                           invokeRestart("muffleWarning")
[11:02:37.545]                       }
[11:02:37.545]                       else if (inherits(cond, "condition")) {
[11:02:37.545]                         if (!is.null(pattern)) {
[11:02:37.545]                           computeRestarts <- base::computeRestarts
[11:02:37.545]                           grepl <- base::grepl
[11:02:37.545]                           restarts <- computeRestarts(cond)
[11:02:37.545]                           for (restart in restarts) {
[11:02:37.545]                             name <- restart$name
[11:02:37.545]                             if (is.null(name)) 
[11:02:37.545]                               next
[11:02:37.545]                             if (!grepl(pattern, name)) 
[11:02:37.545]                               next
[11:02:37.545]                             invokeRestart(restart)
[11:02:37.545]                             muffled <- TRUE
[11:02:37.545]                             break
[11:02:37.545]                           }
[11:02:37.545]                         }
[11:02:37.545]                       }
[11:02:37.545]                       invisible(muffled)
[11:02:37.545]                     }
[11:02:37.545]                     muffleCondition(cond, pattern = "^muffle")
[11:02:37.545]                   }
[11:02:37.545]                 }
[11:02:37.545]                 else {
[11:02:37.545]                   if (TRUE) {
[11:02:37.545]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:37.545]                     {
[11:02:37.545]                       inherits <- base::inherits
[11:02:37.545]                       invokeRestart <- base::invokeRestart
[11:02:37.545]                       is.null <- base::is.null
[11:02:37.545]                       muffled <- FALSE
[11:02:37.545]                       if (inherits(cond, "message")) {
[11:02:37.545]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:37.545]                         if (muffled) 
[11:02:37.545]                           invokeRestart("muffleMessage")
[11:02:37.545]                       }
[11:02:37.545]                       else if (inherits(cond, "warning")) {
[11:02:37.545]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:37.545]                         if (muffled) 
[11:02:37.545]                           invokeRestart("muffleWarning")
[11:02:37.545]                       }
[11:02:37.545]                       else if (inherits(cond, "condition")) {
[11:02:37.545]                         if (!is.null(pattern)) {
[11:02:37.545]                           computeRestarts <- base::computeRestarts
[11:02:37.545]                           grepl <- base::grepl
[11:02:37.545]                           restarts <- computeRestarts(cond)
[11:02:37.545]                           for (restart in restarts) {
[11:02:37.545]                             name <- restart$name
[11:02:37.545]                             if (is.null(name)) 
[11:02:37.545]                               next
[11:02:37.545]                             if (!grepl(pattern, name)) 
[11:02:37.545]                               next
[11:02:37.545]                             invokeRestart(restart)
[11:02:37.545]                             muffled <- TRUE
[11:02:37.545]                             break
[11:02:37.545]                           }
[11:02:37.545]                         }
[11:02:37.545]                       }
[11:02:37.545]                       invisible(muffled)
[11:02:37.545]                     }
[11:02:37.545]                     muffleCondition(cond, pattern = "^muffle")
[11:02:37.545]                   }
[11:02:37.545]                 }
[11:02:37.545]             }
[11:02:37.545]         }))
[11:02:37.545]     }, error = function(ex) {
[11:02:37.545]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:37.545]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:37.545]                 ...future.rng), started = ...future.startTime, 
[11:02:37.545]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:37.545]             version = "1.8"), class = "FutureResult")
[11:02:37.545]     }, finally = {
[11:02:37.545]         if (!identical(...future.workdir, getwd())) 
[11:02:37.545]             setwd(...future.workdir)
[11:02:37.545]         {
[11:02:37.545]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:37.545]                 ...future.oldOptions$nwarnings <- NULL
[11:02:37.545]             }
[11:02:37.545]             base::options(...future.oldOptions)
[11:02:37.545]             if (.Platform$OS.type == "windows") {
[11:02:37.545]                 old_names <- names(...future.oldEnvVars)
[11:02:37.545]                 envs <- base::Sys.getenv()
[11:02:37.545]                 names <- names(envs)
[11:02:37.545]                 common <- intersect(names, old_names)
[11:02:37.545]                 added <- setdiff(names, old_names)
[11:02:37.545]                 removed <- setdiff(old_names, names)
[11:02:37.545]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:37.545]                   envs[common]]
[11:02:37.545]                 NAMES <- toupper(changed)
[11:02:37.545]                 args <- list()
[11:02:37.545]                 for (kk in seq_along(NAMES)) {
[11:02:37.545]                   name <- changed[[kk]]
[11:02:37.545]                   NAME <- NAMES[[kk]]
[11:02:37.545]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.545]                     next
[11:02:37.545]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:37.545]                 }
[11:02:37.545]                 NAMES <- toupper(added)
[11:02:37.545]                 for (kk in seq_along(NAMES)) {
[11:02:37.545]                   name <- added[[kk]]
[11:02:37.545]                   NAME <- NAMES[[kk]]
[11:02:37.545]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.545]                     next
[11:02:37.545]                   args[[name]] <- ""
[11:02:37.545]                 }
[11:02:37.545]                 NAMES <- toupper(removed)
[11:02:37.545]                 for (kk in seq_along(NAMES)) {
[11:02:37.545]                   name <- removed[[kk]]
[11:02:37.545]                   NAME <- NAMES[[kk]]
[11:02:37.545]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.545]                     next
[11:02:37.545]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:37.545]                 }
[11:02:37.545]                 if (length(args) > 0) 
[11:02:37.545]                   base::do.call(base::Sys.setenv, args = args)
[11:02:37.545]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:37.545]             }
[11:02:37.545]             else {
[11:02:37.545]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:37.545]             }
[11:02:37.545]             {
[11:02:37.545]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:37.545]                   0L) {
[11:02:37.545]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:37.545]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:37.545]                   base::options(opts)
[11:02:37.545]                 }
[11:02:37.545]                 {
[11:02:37.545]                   {
[11:02:37.545]                     NULL
[11:02:37.545]                     RNGkind("Mersenne-Twister")
[11:02:37.545]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:37.545]                       inherits = FALSE)
[11:02:37.545]                   }
[11:02:37.545]                   options(future.plan = NULL)
[11:02:37.545]                   if (is.na(NA_character_)) 
[11:02:37.545]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:37.545]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:37.545]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:37.545]                     .init = FALSE)
[11:02:37.545]                 }
[11:02:37.545]             }
[11:02:37.545]         }
[11:02:37.545]     })
[11:02:37.545]     if (TRUE) {
[11:02:37.545]         base::sink(type = "output", split = FALSE)
[11:02:37.545]         if (TRUE) {
[11:02:37.545]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:37.545]         }
[11:02:37.545]         else {
[11:02:37.545]             ...future.result["stdout"] <- base::list(NULL)
[11:02:37.545]         }
[11:02:37.545]         base::close(...future.stdout)
[11:02:37.545]         ...future.stdout <- NULL
[11:02:37.545]     }
[11:02:37.545]     ...future.result$conditions <- ...future.conditions
[11:02:37.545]     ...future.result$finished <- base::Sys.time()
[11:02:37.545]     ...future.result
[11:02:37.545] }
[11:02:37.547] plan(): Setting new future strategy stack:
[11:02:37.547] List of future strategies:
[11:02:37.547] 1. sequential:
[11:02:37.547]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:37.547]    - tweaked: FALSE
[11:02:37.547]    - call: NULL
[11:02:37.548] plan(): nbrOfWorkers() = 1
[11:02:37.548] plan(): Setting new future strategy stack:
[11:02:37.548] List of future strategies:
[11:02:37.548] 1. sequential:
[11:02:37.548]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:37.548]    - tweaked: FALSE
[11:02:37.548]    - call: plan(strategy)
[11:02:37.549] plan(): nbrOfWorkers() = 1
[11:02:37.549] SequentialFuture started (and completed)
[11:02:37.549] - Launch lazy future ... done
[11:02:37.549] run() for ‘SequentialFuture’ ... done
[11:02:37.549] getGlobalsAndPackages() ...
[11:02:37.549] Searching for globals...
[11:02:37.549] 
[11:02:37.550] Searching for globals ... DONE
[11:02:37.550] - globals: [0] <none>
[11:02:37.550] getGlobalsAndPackages() ... DONE
[11:02:37.550] run() for ‘Future’ ...
[11:02:37.550] - state: ‘created’
[11:02:37.550] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:02:37.550] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:37.550] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:37.551]   - Field: ‘label’
[11:02:37.551]   - Field: ‘local’
[11:02:37.551]   - Field: ‘owner’
[11:02:37.551]   - Field: ‘envir’
[11:02:37.551]   - Field: ‘packages’
[11:02:37.551]   - Field: ‘gc’
[11:02:37.551]   - Field: ‘conditions’
[11:02:37.551]   - Field: ‘expr’
[11:02:37.551]   - Field: ‘uuid’
[11:02:37.551]   - Field: ‘seed’
[11:02:37.551]   - Field: ‘version’
[11:02:37.551]   - Field: ‘result’
[11:02:37.551]   - Field: ‘asynchronous’
[11:02:37.552]   - Field: ‘calls’
[11:02:37.552]   - Field: ‘globals’
[11:02:37.552]   - Field: ‘stdout’
[11:02:37.552]   - Field: ‘earlySignal’
[11:02:37.552]   - Field: ‘lazy’
[11:02:37.552]   - Field: ‘state’
[11:02:37.552] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:37.552] - Launch lazy future ...
[11:02:37.552] Packages needed by the future expression (n = 0): <none>
[11:02:37.552] Packages needed by future strategies (n = 0): <none>
[11:02:37.553] {
[11:02:37.553]     {
[11:02:37.553]         {
[11:02:37.553]             ...future.startTime <- base::Sys.time()
[11:02:37.553]             {
[11:02:37.553]                 {
[11:02:37.553]                   {
[11:02:37.553]                     base::local({
[11:02:37.553]                       has_future <- base::requireNamespace("future", 
[11:02:37.553]                         quietly = TRUE)
[11:02:37.553]                       if (has_future) {
[11:02:37.553]                         ns <- base::getNamespace("future")
[11:02:37.553]                         version <- ns[[".package"]][["version"]]
[11:02:37.553]                         if (is.null(version)) 
[11:02:37.553]                           version <- utils::packageVersion("future")
[11:02:37.553]                       }
[11:02:37.553]                       else {
[11:02:37.553]                         version <- NULL
[11:02:37.553]                       }
[11:02:37.553]                       if (!has_future || version < "1.8.0") {
[11:02:37.553]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:37.553]                           "", base::R.version$version.string), 
[11:02:37.553]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:37.553]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:37.553]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:37.553]                             "release", "version")], collapse = " "), 
[11:02:37.553]                           hostname = base::Sys.info()[["nodename"]])
[11:02:37.553]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:37.553]                           info)
[11:02:37.553]                         info <- base::paste(info, collapse = "; ")
[11:02:37.553]                         if (!has_future) {
[11:02:37.553]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:37.553]                             info)
[11:02:37.553]                         }
[11:02:37.553]                         else {
[11:02:37.553]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:37.553]                             info, version)
[11:02:37.553]                         }
[11:02:37.553]                         base::stop(msg)
[11:02:37.553]                       }
[11:02:37.553]                     })
[11:02:37.553]                   }
[11:02:37.553]                   ...future.strategy.old <- future::plan("list")
[11:02:37.553]                   options(future.plan = NULL)
[11:02:37.553]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:37.553]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:37.553]                 }
[11:02:37.553]                 ...future.workdir <- getwd()
[11:02:37.553]             }
[11:02:37.553]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:37.553]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:37.553]         }
[11:02:37.553]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:37.553]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:37.553]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:37.553]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:37.553]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:37.553]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:37.553]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:37.553]             base::names(...future.oldOptions))
[11:02:37.553]     }
[11:02:37.553]     if (FALSE) {
[11:02:37.553]     }
[11:02:37.553]     else {
[11:02:37.553]         if (TRUE) {
[11:02:37.553]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:37.553]                 open = "w")
[11:02:37.553]         }
[11:02:37.553]         else {
[11:02:37.553]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:37.553]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:37.553]         }
[11:02:37.553]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:37.553]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:37.553]             base::sink(type = "output", split = FALSE)
[11:02:37.553]             base::close(...future.stdout)
[11:02:37.553]         }, add = TRUE)
[11:02:37.553]     }
[11:02:37.553]     ...future.frame <- base::sys.nframe()
[11:02:37.553]     ...future.conditions <- base::list()
[11:02:37.553]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:37.553]     if (FALSE) {
[11:02:37.553]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:37.553]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:37.553]     }
[11:02:37.553]     ...future.result <- base::tryCatch({
[11:02:37.553]         base::withCallingHandlers({
[11:02:37.553]             ...future.value <- base::withVisible(base::local(2))
[11:02:37.553]             future::FutureResult(value = ...future.value$value, 
[11:02:37.553]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:37.553]                   ...future.rng), globalenv = if (FALSE) 
[11:02:37.553]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:37.553]                     ...future.globalenv.names))
[11:02:37.553]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:37.553]         }, condition = base::local({
[11:02:37.553]             c <- base::c
[11:02:37.553]             inherits <- base::inherits
[11:02:37.553]             invokeRestart <- base::invokeRestart
[11:02:37.553]             length <- base::length
[11:02:37.553]             list <- base::list
[11:02:37.553]             seq.int <- base::seq.int
[11:02:37.553]             signalCondition <- base::signalCondition
[11:02:37.553]             sys.calls <- base::sys.calls
[11:02:37.553]             `[[` <- base::`[[`
[11:02:37.553]             `+` <- base::`+`
[11:02:37.553]             `<<-` <- base::`<<-`
[11:02:37.553]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:37.553]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:37.553]                   3L)]
[11:02:37.553]             }
[11:02:37.553]             function(cond) {
[11:02:37.553]                 is_error <- inherits(cond, "error")
[11:02:37.553]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:37.553]                   NULL)
[11:02:37.553]                 if (is_error) {
[11:02:37.553]                   sessionInformation <- function() {
[11:02:37.553]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:37.553]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:37.553]                       search = base::search(), system = base::Sys.info())
[11:02:37.553]                   }
[11:02:37.553]                   ...future.conditions[[length(...future.conditions) + 
[11:02:37.553]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:37.553]                     cond$call), session = sessionInformation(), 
[11:02:37.553]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:37.553]                   signalCondition(cond)
[11:02:37.553]                 }
[11:02:37.553]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:37.553]                 "immediateCondition"))) {
[11:02:37.553]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:37.553]                   ...future.conditions[[length(...future.conditions) + 
[11:02:37.553]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:37.553]                   if (TRUE && !signal) {
[11:02:37.553]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:37.553]                     {
[11:02:37.553]                       inherits <- base::inherits
[11:02:37.553]                       invokeRestart <- base::invokeRestart
[11:02:37.553]                       is.null <- base::is.null
[11:02:37.553]                       muffled <- FALSE
[11:02:37.553]                       if (inherits(cond, "message")) {
[11:02:37.553]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:37.553]                         if (muffled) 
[11:02:37.553]                           invokeRestart("muffleMessage")
[11:02:37.553]                       }
[11:02:37.553]                       else if (inherits(cond, "warning")) {
[11:02:37.553]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:37.553]                         if (muffled) 
[11:02:37.553]                           invokeRestart("muffleWarning")
[11:02:37.553]                       }
[11:02:37.553]                       else if (inherits(cond, "condition")) {
[11:02:37.553]                         if (!is.null(pattern)) {
[11:02:37.553]                           computeRestarts <- base::computeRestarts
[11:02:37.553]                           grepl <- base::grepl
[11:02:37.553]                           restarts <- computeRestarts(cond)
[11:02:37.553]                           for (restart in restarts) {
[11:02:37.553]                             name <- restart$name
[11:02:37.553]                             if (is.null(name)) 
[11:02:37.553]                               next
[11:02:37.553]                             if (!grepl(pattern, name)) 
[11:02:37.553]                               next
[11:02:37.553]                             invokeRestart(restart)
[11:02:37.553]                             muffled <- TRUE
[11:02:37.553]                             break
[11:02:37.553]                           }
[11:02:37.553]                         }
[11:02:37.553]                       }
[11:02:37.553]                       invisible(muffled)
[11:02:37.553]                     }
[11:02:37.553]                     muffleCondition(cond, pattern = "^muffle")
[11:02:37.553]                   }
[11:02:37.553]                 }
[11:02:37.553]                 else {
[11:02:37.553]                   if (TRUE) {
[11:02:37.553]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:37.553]                     {
[11:02:37.553]                       inherits <- base::inherits
[11:02:37.553]                       invokeRestart <- base::invokeRestart
[11:02:37.553]                       is.null <- base::is.null
[11:02:37.553]                       muffled <- FALSE
[11:02:37.553]                       if (inherits(cond, "message")) {
[11:02:37.553]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:37.553]                         if (muffled) 
[11:02:37.553]                           invokeRestart("muffleMessage")
[11:02:37.553]                       }
[11:02:37.553]                       else if (inherits(cond, "warning")) {
[11:02:37.553]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:37.553]                         if (muffled) 
[11:02:37.553]                           invokeRestart("muffleWarning")
[11:02:37.553]                       }
[11:02:37.553]                       else if (inherits(cond, "condition")) {
[11:02:37.553]                         if (!is.null(pattern)) {
[11:02:37.553]                           computeRestarts <- base::computeRestarts
[11:02:37.553]                           grepl <- base::grepl
[11:02:37.553]                           restarts <- computeRestarts(cond)
[11:02:37.553]                           for (restart in restarts) {
[11:02:37.553]                             name <- restart$name
[11:02:37.553]                             if (is.null(name)) 
[11:02:37.553]                               next
[11:02:37.553]                             if (!grepl(pattern, name)) 
[11:02:37.553]                               next
[11:02:37.553]                             invokeRestart(restart)
[11:02:37.553]                             muffled <- TRUE
[11:02:37.553]                             break
[11:02:37.553]                           }
[11:02:37.553]                         }
[11:02:37.553]                       }
[11:02:37.553]                       invisible(muffled)
[11:02:37.553]                     }
[11:02:37.553]                     muffleCondition(cond, pattern = "^muffle")
[11:02:37.553]                   }
[11:02:37.553]                 }
[11:02:37.553]             }
[11:02:37.553]         }))
[11:02:37.553]     }, error = function(ex) {
[11:02:37.553]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:37.553]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:37.553]                 ...future.rng), started = ...future.startTime, 
[11:02:37.553]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:37.553]             version = "1.8"), class = "FutureResult")
[11:02:37.553]     }, finally = {
[11:02:37.553]         if (!identical(...future.workdir, getwd())) 
[11:02:37.553]             setwd(...future.workdir)
[11:02:37.553]         {
[11:02:37.553]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:37.553]                 ...future.oldOptions$nwarnings <- NULL
[11:02:37.553]             }
[11:02:37.553]             base::options(...future.oldOptions)
[11:02:37.553]             if (.Platform$OS.type == "windows") {
[11:02:37.553]                 old_names <- names(...future.oldEnvVars)
[11:02:37.553]                 envs <- base::Sys.getenv()
[11:02:37.553]                 names <- names(envs)
[11:02:37.553]                 common <- intersect(names, old_names)
[11:02:37.553]                 added <- setdiff(names, old_names)
[11:02:37.553]                 removed <- setdiff(old_names, names)
[11:02:37.553]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:37.553]                   envs[common]]
[11:02:37.553]                 NAMES <- toupper(changed)
[11:02:37.553]                 args <- list()
[11:02:37.553]                 for (kk in seq_along(NAMES)) {
[11:02:37.553]                   name <- changed[[kk]]
[11:02:37.553]                   NAME <- NAMES[[kk]]
[11:02:37.553]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.553]                     next
[11:02:37.553]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:37.553]                 }
[11:02:37.553]                 NAMES <- toupper(added)
[11:02:37.553]                 for (kk in seq_along(NAMES)) {
[11:02:37.553]                   name <- added[[kk]]
[11:02:37.553]                   NAME <- NAMES[[kk]]
[11:02:37.553]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.553]                     next
[11:02:37.553]                   args[[name]] <- ""
[11:02:37.553]                 }
[11:02:37.553]                 NAMES <- toupper(removed)
[11:02:37.553]                 for (kk in seq_along(NAMES)) {
[11:02:37.553]                   name <- removed[[kk]]
[11:02:37.553]                   NAME <- NAMES[[kk]]
[11:02:37.553]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.553]                     next
[11:02:37.553]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:37.553]                 }
[11:02:37.553]                 if (length(args) > 0) 
[11:02:37.553]                   base::do.call(base::Sys.setenv, args = args)
[11:02:37.553]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:37.553]             }
[11:02:37.553]             else {
[11:02:37.553]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:37.553]             }
[11:02:37.553]             {
[11:02:37.553]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:37.553]                   0L) {
[11:02:37.553]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:37.553]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:37.553]                   base::options(opts)
[11:02:37.553]                 }
[11:02:37.553]                 {
[11:02:37.553]                   {
[11:02:37.553]                     NULL
[11:02:37.553]                     RNGkind("Mersenne-Twister")
[11:02:37.553]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:37.553]                       inherits = FALSE)
[11:02:37.553]                   }
[11:02:37.553]                   options(future.plan = NULL)
[11:02:37.553]                   if (is.na(NA_character_)) 
[11:02:37.553]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:37.553]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:37.553]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:37.553]                     .init = FALSE)
[11:02:37.553]                 }
[11:02:37.553]             }
[11:02:37.553]         }
[11:02:37.553]     })
[11:02:37.553]     if (TRUE) {
[11:02:37.553]         base::sink(type = "output", split = FALSE)
[11:02:37.553]         if (TRUE) {
[11:02:37.553]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:37.553]         }
[11:02:37.553]         else {
[11:02:37.553]             ...future.result["stdout"] <- base::list(NULL)
[11:02:37.553]         }
[11:02:37.553]         base::close(...future.stdout)
[11:02:37.553]         ...future.stdout <- NULL
[11:02:37.553]     }
[11:02:37.553]     ...future.result$conditions <- ...future.conditions
[11:02:37.553]     ...future.result$finished <- base::Sys.time()
[11:02:37.553]     ...future.result
[11:02:37.553] }
[11:02:37.554] plan(): Setting new future strategy stack:
[11:02:37.555] List of future strategies:
[11:02:37.555] 1. sequential:
[11:02:37.555]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:37.555]    - tweaked: FALSE
[11:02:37.555]    - call: NULL
[11:02:37.555] plan(): nbrOfWorkers() = 1
[11:02:37.556] plan(): Setting new future strategy stack:
[11:02:37.556] List of future strategies:
[11:02:37.556] 1. sequential:
[11:02:37.556]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:37.556]    - tweaked: FALSE
[11:02:37.556]    - call: plan(strategy)
[11:02:37.556] plan(): nbrOfWorkers() = 1
[11:02:37.556] SequentialFuture started (and completed)
[11:02:37.556] - Launch lazy future ... done
[11:02:37.556] run() for ‘SequentialFuture’ ... done
[11:02:37.557] resolve() on list environment ...
[11:02:37.557]  recursive: 0
[11:02:37.558]  length: 3
[11:02:37.558]  elements: ‘a’, ‘b’, ‘c’
[11:02:37.558] resolved() for ‘SequentialFuture’ ...
[11:02:37.558] - state: ‘finished’
[11:02:37.558] - run: TRUE
[11:02:37.558] - result: ‘FutureResult’
[11:02:37.558] resolved() for ‘SequentialFuture’ ... done
[11:02:37.558] Future #1
[11:02:37.558]  length: 2 (resolved future 1)
[11:02:37.558] resolved() for ‘SequentialFuture’ ...
[11:02:37.559] - state: ‘finished’
[11:02:37.559] - run: TRUE
[11:02:37.559] - result: ‘FutureResult’
[11:02:37.559] resolved() for ‘SequentialFuture’ ... done
[11:02:37.559] Future #2
[11:02:37.559]  length: 1 (resolved future 2)
[11:02:37.559]  length: 0 (resolved future 3)
[11:02:37.559] resolve() on list environment ... DONE
[11:02:37.560] getGlobalsAndPackages() ...
[11:02:37.560] Searching for globals...
[11:02:37.560] - globals found: [1] ‘{’
[11:02:37.560] Searching for globals ... DONE
[11:02:37.561] Resolving globals: FALSE
[11:02:37.561] 
[11:02:37.561] 
[11:02:37.561] getGlobalsAndPackages() ... DONE
[11:02:37.561] run() for ‘Future’ ...
[11:02:37.561] - state: ‘created’
[11:02:37.561] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:02:37.562] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:37.562] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:37.562]   - Field: ‘label’
[11:02:37.562]   - Field: ‘local’
[11:02:37.563]   - Field: ‘owner’
[11:02:37.563]   - Field: ‘envir’
[11:02:37.563]   - Field: ‘packages’
[11:02:37.563]   - Field: ‘gc’
[11:02:37.563]   - Field: ‘conditions’
[11:02:37.563]   - Field: ‘expr’
[11:02:37.564]   - Field: ‘uuid’
[11:02:37.564]   - Field: ‘seed’
[11:02:37.564]   - Field: ‘version’
[11:02:37.564]   - Field: ‘result’
[11:02:37.564]   - Field: ‘asynchronous’
[11:02:37.564]   - Field: ‘calls’
[11:02:37.564]   - Field: ‘globals’
[11:02:37.564]   - Field: ‘stdout’
[11:02:37.564]   - Field: ‘earlySignal’
[11:02:37.564]   - Field: ‘lazy’
[11:02:37.564]   - Field: ‘state’
[11:02:37.564] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:37.564] - Launch lazy future ...
[11:02:37.565] Packages needed by the future expression (n = 0): <none>
[11:02:37.565] Packages needed by future strategies (n = 0): <none>
[11:02:37.565] {
[11:02:37.565]     {
[11:02:37.565]         {
[11:02:37.565]             ...future.startTime <- base::Sys.time()
[11:02:37.565]             {
[11:02:37.565]                 {
[11:02:37.565]                   {
[11:02:37.565]                     base::local({
[11:02:37.565]                       has_future <- base::requireNamespace("future", 
[11:02:37.565]                         quietly = TRUE)
[11:02:37.565]                       if (has_future) {
[11:02:37.565]                         ns <- base::getNamespace("future")
[11:02:37.565]                         version <- ns[[".package"]][["version"]]
[11:02:37.565]                         if (is.null(version)) 
[11:02:37.565]                           version <- utils::packageVersion("future")
[11:02:37.565]                       }
[11:02:37.565]                       else {
[11:02:37.565]                         version <- NULL
[11:02:37.565]                       }
[11:02:37.565]                       if (!has_future || version < "1.8.0") {
[11:02:37.565]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:37.565]                           "", base::R.version$version.string), 
[11:02:37.565]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:37.565]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:37.565]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:37.565]                             "release", "version")], collapse = " "), 
[11:02:37.565]                           hostname = base::Sys.info()[["nodename"]])
[11:02:37.565]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:37.565]                           info)
[11:02:37.565]                         info <- base::paste(info, collapse = "; ")
[11:02:37.565]                         if (!has_future) {
[11:02:37.565]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:37.565]                             info)
[11:02:37.565]                         }
[11:02:37.565]                         else {
[11:02:37.565]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:37.565]                             info, version)
[11:02:37.565]                         }
[11:02:37.565]                         base::stop(msg)
[11:02:37.565]                       }
[11:02:37.565]                     })
[11:02:37.565]                   }
[11:02:37.565]                   ...future.strategy.old <- future::plan("list")
[11:02:37.565]                   options(future.plan = NULL)
[11:02:37.565]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:37.565]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:37.565]                 }
[11:02:37.565]                 ...future.workdir <- getwd()
[11:02:37.565]             }
[11:02:37.565]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:37.565]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:37.565]         }
[11:02:37.565]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:37.565]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:37.565]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:37.565]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:37.565]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:37.565]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:37.565]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:37.565]             base::names(...future.oldOptions))
[11:02:37.565]     }
[11:02:37.565]     if (FALSE) {
[11:02:37.565]     }
[11:02:37.565]     else {
[11:02:37.565]         if (TRUE) {
[11:02:37.565]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:37.565]                 open = "w")
[11:02:37.565]         }
[11:02:37.565]         else {
[11:02:37.565]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:37.565]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:37.565]         }
[11:02:37.565]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:37.565]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:37.565]             base::sink(type = "output", split = FALSE)
[11:02:37.565]             base::close(...future.stdout)
[11:02:37.565]         }, add = TRUE)
[11:02:37.565]     }
[11:02:37.565]     ...future.frame <- base::sys.nframe()
[11:02:37.565]     ...future.conditions <- base::list()
[11:02:37.565]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:37.565]     if (FALSE) {
[11:02:37.565]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:37.565]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:37.565]     }
[11:02:37.565]     ...future.result <- base::tryCatch({
[11:02:37.565]         base::withCallingHandlers({
[11:02:37.565]             ...future.value <- base::withVisible(base::local({
[11:02:37.565]                 1
[11:02:37.565]             }))
[11:02:37.565]             future::FutureResult(value = ...future.value$value, 
[11:02:37.565]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:37.565]                   ...future.rng), globalenv = if (FALSE) 
[11:02:37.565]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:37.565]                     ...future.globalenv.names))
[11:02:37.565]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:37.565]         }, condition = base::local({
[11:02:37.565]             c <- base::c
[11:02:37.565]             inherits <- base::inherits
[11:02:37.565]             invokeRestart <- base::invokeRestart
[11:02:37.565]             length <- base::length
[11:02:37.565]             list <- base::list
[11:02:37.565]             seq.int <- base::seq.int
[11:02:37.565]             signalCondition <- base::signalCondition
[11:02:37.565]             sys.calls <- base::sys.calls
[11:02:37.565]             `[[` <- base::`[[`
[11:02:37.565]             `+` <- base::`+`
[11:02:37.565]             `<<-` <- base::`<<-`
[11:02:37.565]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:37.565]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:37.565]                   3L)]
[11:02:37.565]             }
[11:02:37.565]             function(cond) {
[11:02:37.565]                 is_error <- inherits(cond, "error")
[11:02:37.565]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:37.565]                   NULL)
[11:02:37.565]                 if (is_error) {
[11:02:37.565]                   sessionInformation <- function() {
[11:02:37.565]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:37.565]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:37.565]                       search = base::search(), system = base::Sys.info())
[11:02:37.565]                   }
[11:02:37.565]                   ...future.conditions[[length(...future.conditions) + 
[11:02:37.565]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:37.565]                     cond$call), session = sessionInformation(), 
[11:02:37.565]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:37.565]                   signalCondition(cond)
[11:02:37.565]                 }
[11:02:37.565]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:37.565]                 "immediateCondition"))) {
[11:02:37.565]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:37.565]                   ...future.conditions[[length(...future.conditions) + 
[11:02:37.565]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:37.565]                   if (TRUE && !signal) {
[11:02:37.565]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:37.565]                     {
[11:02:37.565]                       inherits <- base::inherits
[11:02:37.565]                       invokeRestart <- base::invokeRestart
[11:02:37.565]                       is.null <- base::is.null
[11:02:37.565]                       muffled <- FALSE
[11:02:37.565]                       if (inherits(cond, "message")) {
[11:02:37.565]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:37.565]                         if (muffled) 
[11:02:37.565]                           invokeRestart("muffleMessage")
[11:02:37.565]                       }
[11:02:37.565]                       else if (inherits(cond, "warning")) {
[11:02:37.565]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:37.565]                         if (muffled) 
[11:02:37.565]                           invokeRestart("muffleWarning")
[11:02:37.565]                       }
[11:02:37.565]                       else if (inherits(cond, "condition")) {
[11:02:37.565]                         if (!is.null(pattern)) {
[11:02:37.565]                           computeRestarts <- base::computeRestarts
[11:02:37.565]                           grepl <- base::grepl
[11:02:37.565]                           restarts <- computeRestarts(cond)
[11:02:37.565]                           for (restart in restarts) {
[11:02:37.565]                             name <- restart$name
[11:02:37.565]                             if (is.null(name)) 
[11:02:37.565]                               next
[11:02:37.565]                             if (!grepl(pattern, name)) 
[11:02:37.565]                               next
[11:02:37.565]                             invokeRestart(restart)
[11:02:37.565]                             muffled <- TRUE
[11:02:37.565]                             break
[11:02:37.565]                           }
[11:02:37.565]                         }
[11:02:37.565]                       }
[11:02:37.565]                       invisible(muffled)
[11:02:37.565]                     }
[11:02:37.565]                     muffleCondition(cond, pattern = "^muffle")
[11:02:37.565]                   }
[11:02:37.565]                 }
[11:02:37.565]                 else {
[11:02:37.565]                   if (TRUE) {
[11:02:37.565]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:37.565]                     {
[11:02:37.565]                       inherits <- base::inherits
[11:02:37.565]                       invokeRestart <- base::invokeRestart
[11:02:37.565]                       is.null <- base::is.null
[11:02:37.565]                       muffled <- FALSE
[11:02:37.565]                       if (inherits(cond, "message")) {
[11:02:37.565]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:37.565]                         if (muffled) 
[11:02:37.565]                           invokeRestart("muffleMessage")
[11:02:37.565]                       }
[11:02:37.565]                       else if (inherits(cond, "warning")) {
[11:02:37.565]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:37.565]                         if (muffled) 
[11:02:37.565]                           invokeRestart("muffleWarning")
[11:02:37.565]                       }
[11:02:37.565]                       else if (inherits(cond, "condition")) {
[11:02:37.565]                         if (!is.null(pattern)) {
[11:02:37.565]                           computeRestarts <- base::computeRestarts
[11:02:37.565]                           grepl <- base::grepl
[11:02:37.565]                           restarts <- computeRestarts(cond)
[11:02:37.565]                           for (restart in restarts) {
[11:02:37.565]                             name <- restart$name
[11:02:37.565]                             if (is.null(name)) 
[11:02:37.565]                               next
[11:02:37.565]                             if (!grepl(pattern, name)) 
[11:02:37.565]                               next
[11:02:37.565]                             invokeRestart(restart)
[11:02:37.565]                             muffled <- TRUE
[11:02:37.565]                             break
[11:02:37.565]                           }
[11:02:37.565]                         }
[11:02:37.565]                       }
[11:02:37.565]                       invisible(muffled)
[11:02:37.565]                     }
[11:02:37.565]                     muffleCondition(cond, pattern = "^muffle")
[11:02:37.565]                   }
[11:02:37.565]                 }
[11:02:37.565]             }
[11:02:37.565]         }))
[11:02:37.565]     }, error = function(ex) {
[11:02:37.565]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:37.565]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:37.565]                 ...future.rng), started = ...future.startTime, 
[11:02:37.565]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:37.565]             version = "1.8"), class = "FutureResult")
[11:02:37.565]     }, finally = {
[11:02:37.565]         if (!identical(...future.workdir, getwd())) 
[11:02:37.565]             setwd(...future.workdir)
[11:02:37.565]         {
[11:02:37.565]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:37.565]                 ...future.oldOptions$nwarnings <- NULL
[11:02:37.565]             }
[11:02:37.565]             base::options(...future.oldOptions)
[11:02:37.565]             if (.Platform$OS.type == "windows") {
[11:02:37.565]                 old_names <- names(...future.oldEnvVars)
[11:02:37.565]                 envs <- base::Sys.getenv()
[11:02:37.565]                 names <- names(envs)
[11:02:37.565]                 common <- intersect(names, old_names)
[11:02:37.565]                 added <- setdiff(names, old_names)
[11:02:37.565]                 removed <- setdiff(old_names, names)
[11:02:37.565]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:37.565]                   envs[common]]
[11:02:37.565]                 NAMES <- toupper(changed)
[11:02:37.565]                 args <- list()
[11:02:37.565]                 for (kk in seq_along(NAMES)) {
[11:02:37.565]                   name <- changed[[kk]]
[11:02:37.565]                   NAME <- NAMES[[kk]]
[11:02:37.565]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.565]                     next
[11:02:37.565]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:37.565]                 }
[11:02:37.565]                 NAMES <- toupper(added)
[11:02:37.565]                 for (kk in seq_along(NAMES)) {
[11:02:37.565]                   name <- added[[kk]]
[11:02:37.565]                   NAME <- NAMES[[kk]]
[11:02:37.565]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.565]                     next
[11:02:37.565]                   args[[name]] <- ""
[11:02:37.565]                 }
[11:02:37.565]                 NAMES <- toupper(removed)
[11:02:37.565]                 for (kk in seq_along(NAMES)) {
[11:02:37.565]                   name <- removed[[kk]]
[11:02:37.565]                   NAME <- NAMES[[kk]]
[11:02:37.565]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.565]                     next
[11:02:37.565]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:37.565]                 }
[11:02:37.565]                 if (length(args) > 0) 
[11:02:37.565]                   base::do.call(base::Sys.setenv, args = args)
[11:02:37.565]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:37.565]             }
[11:02:37.565]             else {
[11:02:37.565]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:37.565]             }
[11:02:37.565]             {
[11:02:37.565]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:37.565]                   0L) {
[11:02:37.565]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:37.565]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:37.565]                   base::options(opts)
[11:02:37.565]                 }
[11:02:37.565]                 {
[11:02:37.565]                   {
[11:02:37.565]                     NULL
[11:02:37.565]                     RNGkind("Mersenne-Twister")
[11:02:37.565]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:37.565]                       inherits = FALSE)
[11:02:37.565]                   }
[11:02:37.565]                   options(future.plan = NULL)
[11:02:37.565]                   if (is.na(NA_character_)) 
[11:02:37.565]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:37.565]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:37.565]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:37.565]                     .init = FALSE)
[11:02:37.565]                 }
[11:02:37.565]             }
[11:02:37.565]         }
[11:02:37.565]     })
[11:02:37.565]     if (TRUE) {
[11:02:37.565]         base::sink(type = "output", split = FALSE)
[11:02:37.565]         if (TRUE) {
[11:02:37.565]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:37.565]         }
[11:02:37.565]         else {
[11:02:37.565]             ...future.result["stdout"] <- base::list(NULL)
[11:02:37.565]         }
[11:02:37.565]         base::close(...future.stdout)
[11:02:37.565]         ...future.stdout <- NULL
[11:02:37.565]     }
[11:02:37.565]     ...future.result$conditions <- ...future.conditions
[11:02:37.565]     ...future.result$finished <- base::Sys.time()
[11:02:37.565]     ...future.result
[11:02:37.565] }
[11:02:37.567] plan(): Setting new future strategy stack:
[11:02:37.567] List of future strategies:
[11:02:37.567] 1. sequential:
[11:02:37.567]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:37.567]    - tweaked: FALSE
[11:02:37.567]    - call: NULL
[11:02:37.567] plan(): nbrOfWorkers() = 1
[11:02:37.568] plan(): Setting new future strategy stack:
[11:02:37.568] List of future strategies:
[11:02:37.568] 1. sequential:
[11:02:37.568]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:37.568]    - tweaked: FALSE
[11:02:37.568]    - call: plan(strategy)
[11:02:37.569] plan(): nbrOfWorkers() = 1
[11:02:37.569] SequentialFuture started (and completed)
[11:02:37.569] - Launch lazy future ... done
[11:02:37.569] run() for ‘SequentialFuture’ ... done
[11:02:37.569] getGlobalsAndPackages() ...
[11:02:37.569] Searching for globals...
[11:02:37.570] - globals found: [1] ‘{’
[11:02:37.570] Searching for globals ... DONE
[11:02:37.570] Resolving globals: FALSE
[11:02:37.570] 
[11:02:37.570] 
[11:02:37.570] getGlobalsAndPackages() ... DONE
[11:02:37.571] run() for ‘Future’ ...
[11:02:37.571] - state: ‘created’
[11:02:37.571] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:02:37.571] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:37.571] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:37.571]   - Field: ‘label’
[11:02:37.571]   - Field: ‘local’
[11:02:37.571]   - Field: ‘owner’
[11:02:37.571]   - Field: ‘envir’
[11:02:37.571]   - Field: ‘packages’
[11:02:37.572]   - Field: ‘gc’
[11:02:37.572]   - Field: ‘conditions’
[11:02:37.572]   - Field: ‘expr’
[11:02:37.572]   - Field: ‘uuid’
[11:02:37.572]   - Field: ‘seed’
[11:02:37.572]   - Field: ‘version’
[11:02:37.572]   - Field: ‘result’
[11:02:37.572]   - Field: ‘asynchronous’
[11:02:37.572]   - Field: ‘calls’
[11:02:37.572]   - Field: ‘globals’
[11:02:37.572]   - Field: ‘stdout’
[11:02:37.572]   - Field: ‘earlySignal’
[11:02:37.572]   - Field: ‘lazy’
[11:02:37.573]   - Field: ‘state’
[11:02:37.573] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:37.573] - Launch lazy future ...
[11:02:37.573] Packages needed by the future expression (n = 0): <none>
[11:02:37.573] Packages needed by future strategies (n = 0): <none>
[11:02:37.573] {
[11:02:37.573]     {
[11:02:37.573]         {
[11:02:37.573]             ...future.startTime <- base::Sys.time()
[11:02:37.573]             {
[11:02:37.573]                 {
[11:02:37.573]                   {
[11:02:37.573]                     base::local({
[11:02:37.573]                       has_future <- base::requireNamespace("future", 
[11:02:37.573]                         quietly = TRUE)
[11:02:37.573]                       if (has_future) {
[11:02:37.573]                         ns <- base::getNamespace("future")
[11:02:37.573]                         version <- ns[[".package"]][["version"]]
[11:02:37.573]                         if (is.null(version)) 
[11:02:37.573]                           version <- utils::packageVersion("future")
[11:02:37.573]                       }
[11:02:37.573]                       else {
[11:02:37.573]                         version <- NULL
[11:02:37.573]                       }
[11:02:37.573]                       if (!has_future || version < "1.8.0") {
[11:02:37.573]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:37.573]                           "", base::R.version$version.string), 
[11:02:37.573]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:37.573]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:37.573]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:37.573]                             "release", "version")], collapse = " "), 
[11:02:37.573]                           hostname = base::Sys.info()[["nodename"]])
[11:02:37.573]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:37.573]                           info)
[11:02:37.573]                         info <- base::paste(info, collapse = "; ")
[11:02:37.573]                         if (!has_future) {
[11:02:37.573]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:37.573]                             info)
[11:02:37.573]                         }
[11:02:37.573]                         else {
[11:02:37.573]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:37.573]                             info, version)
[11:02:37.573]                         }
[11:02:37.573]                         base::stop(msg)
[11:02:37.573]                       }
[11:02:37.573]                     })
[11:02:37.573]                   }
[11:02:37.573]                   ...future.strategy.old <- future::plan("list")
[11:02:37.573]                   options(future.plan = NULL)
[11:02:37.573]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:37.573]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:37.573]                 }
[11:02:37.573]                 ...future.workdir <- getwd()
[11:02:37.573]             }
[11:02:37.573]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:37.573]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:37.573]         }
[11:02:37.573]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:37.573]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:37.573]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:37.573]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:37.573]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:37.573]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:37.573]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:37.573]             base::names(...future.oldOptions))
[11:02:37.573]     }
[11:02:37.573]     if (FALSE) {
[11:02:37.573]     }
[11:02:37.573]     else {
[11:02:37.573]         if (TRUE) {
[11:02:37.573]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:37.573]                 open = "w")
[11:02:37.573]         }
[11:02:37.573]         else {
[11:02:37.573]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:37.573]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:37.573]         }
[11:02:37.573]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:37.573]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:37.573]             base::sink(type = "output", split = FALSE)
[11:02:37.573]             base::close(...future.stdout)
[11:02:37.573]         }, add = TRUE)
[11:02:37.573]     }
[11:02:37.573]     ...future.frame <- base::sys.nframe()
[11:02:37.573]     ...future.conditions <- base::list()
[11:02:37.573]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:37.573]     if (FALSE) {
[11:02:37.573]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:37.573]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:37.573]     }
[11:02:37.573]     ...future.result <- base::tryCatch({
[11:02:37.573]         base::withCallingHandlers({
[11:02:37.573]             ...future.value <- base::withVisible(base::local({
[11:02:37.573]                 2
[11:02:37.573]             }))
[11:02:37.573]             future::FutureResult(value = ...future.value$value, 
[11:02:37.573]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:37.573]                   ...future.rng), globalenv = if (FALSE) 
[11:02:37.573]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:37.573]                     ...future.globalenv.names))
[11:02:37.573]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:37.573]         }, condition = base::local({
[11:02:37.573]             c <- base::c
[11:02:37.573]             inherits <- base::inherits
[11:02:37.573]             invokeRestart <- base::invokeRestart
[11:02:37.573]             length <- base::length
[11:02:37.573]             list <- base::list
[11:02:37.573]             seq.int <- base::seq.int
[11:02:37.573]             signalCondition <- base::signalCondition
[11:02:37.573]             sys.calls <- base::sys.calls
[11:02:37.573]             `[[` <- base::`[[`
[11:02:37.573]             `+` <- base::`+`
[11:02:37.573]             `<<-` <- base::`<<-`
[11:02:37.573]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:37.573]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:37.573]                   3L)]
[11:02:37.573]             }
[11:02:37.573]             function(cond) {
[11:02:37.573]                 is_error <- inherits(cond, "error")
[11:02:37.573]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:37.573]                   NULL)
[11:02:37.573]                 if (is_error) {
[11:02:37.573]                   sessionInformation <- function() {
[11:02:37.573]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:37.573]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:37.573]                       search = base::search(), system = base::Sys.info())
[11:02:37.573]                   }
[11:02:37.573]                   ...future.conditions[[length(...future.conditions) + 
[11:02:37.573]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:37.573]                     cond$call), session = sessionInformation(), 
[11:02:37.573]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:37.573]                   signalCondition(cond)
[11:02:37.573]                 }
[11:02:37.573]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:37.573]                 "immediateCondition"))) {
[11:02:37.573]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:37.573]                   ...future.conditions[[length(...future.conditions) + 
[11:02:37.573]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:37.573]                   if (TRUE && !signal) {
[11:02:37.573]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:37.573]                     {
[11:02:37.573]                       inherits <- base::inherits
[11:02:37.573]                       invokeRestart <- base::invokeRestart
[11:02:37.573]                       is.null <- base::is.null
[11:02:37.573]                       muffled <- FALSE
[11:02:37.573]                       if (inherits(cond, "message")) {
[11:02:37.573]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:37.573]                         if (muffled) 
[11:02:37.573]                           invokeRestart("muffleMessage")
[11:02:37.573]                       }
[11:02:37.573]                       else if (inherits(cond, "warning")) {
[11:02:37.573]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:37.573]                         if (muffled) 
[11:02:37.573]                           invokeRestart("muffleWarning")
[11:02:37.573]                       }
[11:02:37.573]                       else if (inherits(cond, "condition")) {
[11:02:37.573]                         if (!is.null(pattern)) {
[11:02:37.573]                           computeRestarts <- base::computeRestarts
[11:02:37.573]                           grepl <- base::grepl
[11:02:37.573]                           restarts <- computeRestarts(cond)
[11:02:37.573]                           for (restart in restarts) {
[11:02:37.573]                             name <- restart$name
[11:02:37.573]                             if (is.null(name)) 
[11:02:37.573]                               next
[11:02:37.573]                             if (!grepl(pattern, name)) 
[11:02:37.573]                               next
[11:02:37.573]                             invokeRestart(restart)
[11:02:37.573]                             muffled <- TRUE
[11:02:37.573]                             break
[11:02:37.573]                           }
[11:02:37.573]                         }
[11:02:37.573]                       }
[11:02:37.573]                       invisible(muffled)
[11:02:37.573]                     }
[11:02:37.573]                     muffleCondition(cond, pattern = "^muffle")
[11:02:37.573]                   }
[11:02:37.573]                 }
[11:02:37.573]                 else {
[11:02:37.573]                   if (TRUE) {
[11:02:37.573]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:37.573]                     {
[11:02:37.573]                       inherits <- base::inherits
[11:02:37.573]                       invokeRestart <- base::invokeRestart
[11:02:37.573]                       is.null <- base::is.null
[11:02:37.573]                       muffled <- FALSE
[11:02:37.573]                       if (inherits(cond, "message")) {
[11:02:37.573]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:37.573]                         if (muffled) 
[11:02:37.573]                           invokeRestart("muffleMessage")
[11:02:37.573]                       }
[11:02:37.573]                       else if (inherits(cond, "warning")) {
[11:02:37.573]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:37.573]                         if (muffled) 
[11:02:37.573]                           invokeRestart("muffleWarning")
[11:02:37.573]                       }
[11:02:37.573]                       else if (inherits(cond, "condition")) {
[11:02:37.573]                         if (!is.null(pattern)) {
[11:02:37.573]                           computeRestarts <- base::computeRestarts
[11:02:37.573]                           grepl <- base::grepl
[11:02:37.573]                           restarts <- computeRestarts(cond)
[11:02:37.573]                           for (restart in restarts) {
[11:02:37.573]                             name <- restart$name
[11:02:37.573]                             if (is.null(name)) 
[11:02:37.573]                               next
[11:02:37.573]                             if (!grepl(pattern, name)) 
[11:02:37.573]                               next
[11:02:37.573]                             invokeRestart(restart)
[11:02:37.573]                             muffled <- TRUE
[11:02:37.573]                             break
[11:02:37.573]                           }
[11:02:37.573]                         }
[11:02:37.573]                       }
[11:02:37.573]                       invisible(muffled)
[11:02:37.573]                     }
[11:02:37.573]                     muffleCondition(cond, pattern = "^muffle")
[11:02:37.573]                   }
[11:02:37.573]                 }
[11:02:37.573]             }
[11:02:37.573]         }))
[11:02:37.573]     }, error = function(ex) {
[11:02:37.573]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:37.573]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:37.573]                 ...future.rng), started = ...future.startTime, 
[11:02:37.573]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:37.573]             version = "1.8"), class = "FutureResult")
[11:02:37.573]     }, finally = {
[11:02:37.573]         if (!identical(...future.workdir, getwd())) 
[11:02:37.573]             setwd(...future.workdir)
[11:02:37.573]         {
[11:02:37.573]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:37.573]                 ...future.oldOptions$nwarnings <- NULL
[11:02:37.573]             }
[11:02:37.573]             base::options(...future.oldOptions)
[11:02:37.573]             if (.Platform$OS.type == "windows") {
[11:02:37.573]                 old_names <- names(...future.oldEnvVars)
[11:02:37.573]                 envs <- base::Sys.getenv()
[11:02:37.573]                 names <- names(envs)
[11:02:37.573]                 common <- intersect(names, old_names)
[11:02:37.573]                 added <- setdiff(names, old_names)
[11:02:37.573]                 removed <- setdiff(old_names, names)
[11:02:37.573]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:37.573]                   envs[common]]
[11:02:37.573]                 NAMES <- toupper(changed)
[11:02:37.573]                 args <- list()
[11:02:37.573]                 for (kk in seq_along(NAMES)) {
[11:02:37.573]                   name <- changed[[kk]]
[11:02:37.573]                   NAME <- NAMES[[kk]]
[11:02:37.573]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.573]                     next
[11:02:37.573]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:37.573]                 }
[11:02:37.573]                 NAMES <- toupper(added)
[11:02:37.573]                 for (kk in seq_along(NAMES)) {
[11:02:37.573]                   name <- added[[kk]]
[11:02:37.573]                   NAME <- NAMES[[kk]]
[11:02:37.573]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.573]                     next
[11:02:37.573]                   args[[name]] <- ""
[11:02:37.573]                 }
[11:02:37.573]                 NAMES <- toupper(removed)
[11:02:37.573]                 for (kk in seq_along(NAMES)) {
[11:02:37.573]                   name <- removed[[kk]]
[11:02:37.573]                   NAME <- NAMES[[kk]]
[11:02:37.573]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.573]                     next
[11:02:37.573]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:37.573]                 }
[11:02:37.573]                 if (length(args) > 0) 
[11:02:37.573]                   base::do.call(base::Sys.setenv, args = args)
[11:02:37.573]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:37.573]             }
[11:02:37.573]             else {
[11:02:37.573]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:37.573]             }
[11:02:37.573]             {
[11:02:37.573]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:37.573]                   0L) {
[11:02:37.573]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:37.573]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:37.573]                   base::options(opts)
[11:02:37.573]                 }
[11:02:37.573]                 {
[11:02:37.573]                   {
[11:02:37.573]                     NULL
[11:02:37.573]                     RNGkind("Mersenne-Twister")
[11:02:37.573]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:37.573]                       inherits = FALSE)
[11:02:37.573]                   }
[11:02:37.573]                   options(future.plan = NULL)
[11:02:37.573]                   if (is.na(NA_character_)) 
[11:02:37.573]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:37.573]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:37.573]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:37.573]                     .init = FALSE)
[11:02:37.573]                 }
[11:02:37.573]             }
[11:02:37.573]         }
[11:02:37.573]     })
[11:02:37.573]     if (TRUE) {
[11:02:37.573]         base::sink(type = "output", split = FALSE)
[11:02:37.573]         if (TRUE) {
[11:02:37.573]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:37.573]         }
[11:02:37.573]         else {
[11:02:37.573]             ...future.result["stdout"] <- base::list(NULL)
[11:02:37.573]         }
[11:02:37.573]         base::close(...future.stdout)
[11:02:37.573]         ...future.stdout <- NULL
[11:02:37.573]     }
[11:02:37.573]     ...future.result$conditions <- ...future.conditions
[11:02:37.573]     ...future.result$finished <- base::Sys.time()
[11:02:37.573]     ...future.result
[11:02:37.573] }
[11:02:37.575] plan(): Setting new future strategy stack:
[11:02:37.575] List of future strategies:
[11:02:37.575] 1. sequential:
[11:02:37.575]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:37.575]    - tweaked: FALSE
[11:02:37.575]    - call: NULL
[11:02:37.576] plan(): nbrOfWorkers() = 1
[11:02:37.576] plan(): Setting new future strategy stack:
[11:02:37.576] List of future strategies:
[11:02:37.576] 1. sequential:
[11:02:37.576]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:37.576]    - tweaked: FALSE
[11:02:37.576]    - call: plan(strategy)
[11:02:37.577] plan(): nbrOfWorkers() = 1
[11:02:37.577] SequentialFuture started (and completed)
[11:02:37.577] - Launch lazy future ... done
[11:02:37.577] run() for ‘SequentialFuture’ ... done
[11:02:37.577] resolve() on list environment ...
[11:02:37.578]  recursive: 0
[11:02:37.578]  length: 3
[11:02:37.578]  elements: ‘a’, ‘b’, ‘c’
[11:02:37.578] resolved() for ‘SequentialFuture’ ...
[11:02:37.578] - state: ‘finished’
[11:02:37.578] - run: TRUE
[11:02:37.578] - result: ‘FutureResult’
[11:02:37.579] resolved() for ‘SequentialFuture’ ... done
[11:02:37.579] Future #1
[11:02:37.579]  length: 2 (resolved future 1)
[11:02:37.579] resolved() for ‘SequentialFuture’ ...
[11:02:37.579] - state: ‘finished’
[11:02:37.579] - run: TRUE
[11:02:37.579] - result: ‘FutureResult’
[11:02:37.579] resolved() for ‘SequentialFuture’ ... done
[11:02:37.579] Future #2
[11:02:37.579]  length: 1 (resolved future 2)
[11:02:37.579]  length: 0 (resolved future 3)
[11:02:37.579] resolve() on list environment ... DONE
[11:02:37.580] getGlobalsAndPackages() ...
[11:02:37.580] Searching for globals...
[11:02:37.580] - globals found: [1] ‘{’
[11:02:37.581] Searching for globals ... DONE
[11:02:37.581] Resolving globals: FALSE
[11:02:37.581] 
[11:02:37.581] 
[11:02:37.581] getGlobalsAndPackages() ... DONE
[11:02:37.581] run() for ‘Future’ ...
[11:02:37.581] - state: ‘created’
[11:02:37.581] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:02:37.582] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:37.582] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:37.582]   - Field: ‘label’
[11:02:37.582]   - Field: ‘local’
[11:02:37.582]   - Field: ‘owner’
[11:02:37.582]   - Field: ‘envir’
[11:02:37.582]   - Field: ‘packages’
[11:02:37.582]   - Field: ‘gc’
[11:02:37.582]   - Field: ‘conditions’
[11:02:37.582]   - Field: ‘expr’
[11:02:37.582]   - Field: ‘uuid’
[11:02:37.583]   - Field: ‘seed’
[11:02:37.583]   - Field: ‘version’
[11:02:37.583]   - Field: ‘result’
[11:02:37.583]   - Field: ‘asynchronous’
[11:02:37.583]   - Field: ‘calls’
[11:02:37.583]   - Field: ‘globals’
[11:02:37.583]   - Field: ‘stdout’
[11:02:37.583]   - Field: ‘earlySignal’
[11:02:37.583]   - Field: ‘lazy’
[11:02:37.583]   - Field: ‘state’
[11:02:37.583] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:37.583] - Launch lazy future ...
[11:02:37.584] Packages needed by the future expression (n = 0): <none>
[11:02:37.584] Packages needed by future strategies (n = 0): <none>
[11:02:37.584] {
[11:02:37.584]     {
[11:02:37.584]         {
[11:02:37.584]             ...future.startTime <- base::Sys.time()
[11:02:37.584]             {
[11:02:37.584]                 {
[11:02:37.584]                   {
[11:02:37.584]                     base::local({
[11:02:37.584]                       has_future <- base::requireNamespace("future", 
[11:02:37.584]                         quietly = TRUE)
[11:02:37.584]                       if (has_future) {
[11:02:37.584]                         ns <- base::getNamespace("future")
[11:02:37.584]                         version <- ns[[".package"]][["version"]]
[11:02:37.584]                         if (is.null(version)) 
[11:02:37.584]                           version <- utils::packageVersion("future")
[11:02:37.584]                       }
[11:02:37.584]                       else {
[11:02:37.584]                         version <- NULL
[11:02:37.584]                       }
[11:02:37.584]                       if (!has_future || version < "1.8.0") {
[11:02:37.584]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:37.584]                           "", base::R.version$version.string), 
[11:02:37.584]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:37.584]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:37.584]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:37.584]                             "release", "version")], collapse = " "), 
[11:02:37.584]                           hostname = base::Sys.info()[["nodename"]])
[11:02:37.584]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:37.584]                           info)
[11:02:37.584]                         info <- base::paste(info, collapse = "; ")
[11:02:37.584]                         if (!has_future) {
[11:02:37.584]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:37.584]                             info)
[11:02:37.584]                         }
[11:02:37.584]                         else {
[11:02:37.584]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:37.584]                             info, version)
[11:02:37.584]                         }
[11:02:37.584]                         base::stop(msg)
[11:02:37.584]                       }
[11:02:37.584]                     })
[11:02:37.584]                   }
[11:02:37.584]                   ...future.strategy.old <- future::plan("list")
[11:02:37.584]                   options(future.plan = NULL)
[11:02:37.584]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:37.584]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:37.584]                 }
[11:02:37.584]                 ...future.workdir <- getwd()
[11:02:37.584]             }
[11:02:37.584]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:37.584]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:37.584]         }
[11:02:37.584]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:37.584]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:37.584]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:37.584]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:37.584]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:37.584]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:37.584]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:37.584]             base::names(...future.oldOptions))
[11:02:37.584]     }
[11:02:37.584]     if (FALSE) {
[11:02:37.584]     }
[11:02:37.584]     else {
[11:02:37.584]         if (TRUE) {
[11:02:37.584]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:37.584]                 open = "w")
[11:02:37.584]         }
[11:02:37.584]         else {
[11:02:37.584]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:37.584]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:37.584]         }
[11:02:37.584]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:37.584]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:37.584]             base::sink(type = "output", split = FALSE)
[11:02:37.584]             base::close(...future.stdout)
[11:02:37.584]         }, add = TRUE)
[11:02:37.584]     }
[11:02:37.584]     ...future.frame <- base::sys.nframe()
[11:02:37.584]     ...future.conditions <- base::list()
[11:02:37.584]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:37.584]     if (FALSE) {
[11:02:37.584]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:37.584]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:37.584]     }
[11:02:37.584]     ...future.result <- base::tryCatch({
[11:02:37.584]         base::withCallingHandlers({
[11:02:37.584]             ...future.value <- base::withVisible(base::local({
[11:02:37.584]                 1
[11:02:37.584]             }))
[11:02:37.584]             future::FutureResult(value = ...future.value$value, 
[11:02:37.584]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:37.584]                   ...future.rng), globalenv = if (FALSE) 
[11:02:37.584]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:37.584]                     ...future.globalenv.names))
[11:02:37.584]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:37.584]         }, condition = base::local({
[11:02:37.584]             c <- base::c
[11:02:37.584]             inherits <- base::inherits
[11:02:37.584]             invokeRestart <- base::invokeRestart
[11:02:37.584]             length <- base::length
[11:02:37.584]             list <- base::list
[11:02:37.584]             seq.int <- base::seq.int
[11:02:37.584]             signalCondition <- base::signalCondition
[11:02:37.584]             sys.calls <- base::sys.calls
[11:02:37.584]             `[[` <- base::`[[`
[11:02:37.584]             `+` <- base::`+`
[11:02:37.584]             `<<-` <- base::`<<-`
[11:02:37.584]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:37.584]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:37.584]                   3L)]
[11:02:37.584]             }
[11:02:37.584]             function(cond) {
[11:02:37.584]                 is_error <- inherits(cond, "error")
[11:02:37.584]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:37.584]                   NULL)
[11:02:37.584]                 if (is_error) {
[11:02:37.584]                   sessionInformation <- function() {
[11:02:37.584]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:37.584]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:37.584]                       search = base::search(), system = base::Sys.info())
[11:02:37.584]                   }
[11:02:37.584]                   ...future.conditions[[length(...future.conditions) + 
[11:02:37.584]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:37.584]                     cond$call), session = sessionInformation(), 
[11:02:37.584]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:37.584]                   signalCondition(cond)
[11:02:37.584]                 }
[11:02:37.584]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:37.584]                 "immediateCondition"))) {
[11:02:37.584]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:37.584]                   ...future.conditions[[length(...future.conditions) + 
[11:02:37.584]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:37.584]                   if (TRUE && !signal) {
[11:02:37.584]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:37.584]                     {
[11:02:37.584]                       inherits <- base::inherits
[11:02:37.584]                       invokeRestart <- base::invokeRestart
[11:02:37.584]                       is.null <- base::is.null
[11:02:37.584]                       muffled <- FALSE
[11:02:37.584]                       if (inherits(cond, "message")) {
[11:02:37.584]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:37.584]                         if (muffled) 
[11:02:37.584]                           invokeRestart("muffleMessage")
[11:02:37.584]                       }
[11:02:37.584]                       else if (inherits(cond, "warning")) {
[11:02:37.584]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:37.584]                         if (muffled) 
[11:02:37.584]                           invokeRestart("muffleWarning")
[11:02:37.584]                       }
[11:02:37.584]                       else if (inherits(cond, "condition")) {
[11:02:37.584]                         if (!is.null(pattern)) {
[11:02:37.584]                           computeRestarts <- base::computeRestarts
[11:02:37.584]                           grepl <- base::grepl
[11:02:37.584]                           restarts <- computeRestarts(cond)
[11:02:37.584]                           for (restart in restarts) {
[11:02:37.584]                             name <- restart$name
[11:02:37.584]                             if (is.null(name)) 
[11:02:37.584]                               next
[11:02:37.584]                             if (!grepl(pattern, name)) 
[11:02:37.584]                               next
[11:02:37.584]                             invokeRestart(restart)
[11:02:37.584]                             muffled <- TRUE
[11:02:37.584]                             break
[11:02:37.584]                           }
[11:02:37.584]                         }
[11:02:37.584]                       }
[11:02:37.584]                       invisible(muffled)
[11:02:37.584]                     }
[11:02:37.584]                     muffleCondition(cond, pattern = "^muffle")
[11:02:37.584]                   }
[11:02:37.584]                 }
[11:02:37.584]                 else {
[11:02:37.584]                   if (TRUE) {
[11:02:37.584]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:37.584]                     {
[11:02:37.584]                       inherits <- base::inherits
[11:02:37.584]                       invokeRestart <- base::invokeRestart
[11:02:37.584]                       is.null <- base::is.null
[11:02:37.584]                       muffled <- FALSE
[11:02:37.584]                       if (inherits(cond, "message")) {
[11:02:37.584]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:37.584]                         if (muffled) 
[11:02:37.584]                           invokeRestart("muffleMessage")
[11:02:37.584]                       }
[11:02:37.584]                       else if (inherits(cond, "warning")) {
[11:02:37.584]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:37.584]                         if (muffled) 
[11:02:37.584]                           invokeRestart("muffleWarning")
[11:02:37.584]                       }
[11:02:37.584]                       else if (inherits(cond, "condition")) {
[11:02:37.584]                         if (!is.null(pattern)) {
[11:02:37.584]                           computeRestarts <- base::computeRestarts
[11:02:37.584]                           grepl <- base::grepl
[11:02:37.584]                           restarts <- computeRestarts(cond)
[11:02:37.584]                           for (restart in restarts) {
[11:02:37.584]                             name <- restart$name
[11:02:37.584]                             if (is.null(name)) 
[11:02:37.584]                               next
[11:02:37.584]                             if (!grepl(pattern, name)) 
[11:02:37.584]                               next
[11:02:37.584]                             invokeRestart(restart)
[11:02:37.584]                             muffled <- TRUE
[11:02:37.584]                             break
[11:02:37.584]                           }
[11:02:37.584]                         }
[11:02:37.584]                       }
[11:02:37.584]                       invisible(muffled)
[11:02:37.584]                     }
[11:02:37.584]                     muffleCondition(cond, pattern = "^muffle")
[11:02:37.584]                   }
[11:02:37.584]                 }
[11:02:37.584]             }
[11:02:37.584]         }))
[11:02:37.584]     }, error = function(ex) {
[11:02:37.584]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:37.584]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:37.584]                 ...future.rng), started = ...future.startTime, 
[11:02:37.584]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:37.584]             version = "1.8"), class = "FutureResult")
[11:02:37.584]     }, finally = {
[11:02:37.584]         if (!identical(...future.workdir, getwd())) 
[11:02:37.584]             setwd(...future.workdir)
[11:02:37.584]         {
[11:02:37.584]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:37.584]                 ...future.oldOptions$nwarnings <- NULL
[11:02:37.584]             }
[11:02:37.584]             base::options(...future.oldOptions)
[11:02:37.584]             if (.Platform$OS.type == "windows") {
[11:02:37.584]                 old_names <- names(...future.oldEnvVars)
[11:02:37.584]                 envs <- base::Sys.getenv()
[11:02:37.584]                 names <- names(envs)
[11:02:37.584]                 common <- intersect(names, old_names)
[11:02:37.584]                 added <- setdiff(names, old_names)
[11:02:37.584]                 removed <- setdiff(old_names, names)
[11:02:37.584]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:37.584]                   envs[common]]
[11:02:37.584]                 NAMES <- toupper(changed)
[11:02:37.584]                 args <- list()
[11:02:37.584]                 for (kk in seq_along(NAMES)) {
[11:02:37.584]                   name <- changed[[kk]]
[11:02:37.584]                   NAME <- NAMES[[kk]]
[11:02:37.584]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.584]                     next
[11:02:37.584]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:37.584]                 }
[11:02:37.584]                 NAMES <- toupper(added)
[11:02:37.584]                 for (kk in seq_along(NAMES)) {
[11:02:37.584]                   name <- added[[kk]]
[11:02:37.584]                   NAME <- NAMES[[kk]]
[11:02:37.584]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.584]                     next
[11:02:37.584]                   args[[name]] <- ""
[11:02:37.584]                 }
[11:02:37.584]                 NAMES <- toupper(removed)
[11:02:37.584]                 for (kk in seq_along(NAMES)) {
[11:02:37.584]                   name <- removed[[kk]]
[11:02:37.584]                   NAME <- NAMES[[kk]]
[11:02:37.584]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.584]                     next
[11:02:37.584]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:37.584]                 }
[11:02:37.584]                 if (length(args) > 0) 
[11:02:37.584]                   base::do.call(base::Sys.setenv, args = args)
[11:02:37.584]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:37.584]             }
[11:02:37.584]             else {
[11:02:37.584]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:37.584]             }
[11:02:37.584]             {
[11:02:37.584]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:37.584]                   0L) {
[11:02:37.584]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:37.584]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:37.584]                   base::options(opts)
[11:02:37.584]                 }
[11:02:37.584]                 {
[11:02:37.584]                   {
[11:02:37.584]                     NULL
[11:02:37.584]                     RNGkind("Mersenne-Twister")
[11:02:37.584]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:37.584]                       inherits = FALSE)
[11:02:37.584]                   }
[11:02:37.584]                   options(future.plan = NULL)
[11:02:37.584]                   if (is.na(NA_character_)) 
[11:02:37.584]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:37.584]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:37.584]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:37.584]                     .init = FALSE)
[11:02:37.584]                 }
[11:02:37.584]             }
[11:02:37.584]         }
[11:02:37.584]     })
[11:02:37.584]     if (TRUE) {
[11:02:37.584]         base::sink(type = "output", split = FALSE)
[11:02:37.584]         if (TRUE) {
[11:02:37.584]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:37.584]         }
[11:02:37.584]         else {
[11:02:37.584]             ...future.result["stdout"] <- base::list(NULL)
[11:02:37.584]         }
[11:02:37.584]         base::close(...future.stdout)
[11:02:37.584]         ...future.stdout <- NULL
[11:02:37.584]     }
[11:02:37.584]     ...future.result$conditions <- ...future.conditions
[11:02:37.584]     ...future.result$finished <- base::Sys.time()
[11:02:37.584]     ...future.result
[11:02:37.584] }
[11:02:37.586] plan(): Setting new future strategy stack:
[11:02:37.586] List of future strategies:
[11:02:37.586] 1. sequential:
[11:02:37.586]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:37.586]    - tweaked: FALSE
[11:02:37.586]    - call: NULL
[11:02:37.586] plan(): nbrOfWorkers() = 1
[11:02:37.588] plan(): Setting new future strategy stack:
[11:02:37.588] List of future strategies:
[11:02:37.588] 1. sequential:
[11:02:37.588]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:37.588]    - tweaked: FALSE
[11:02:37.588]    - call: plan(strategy)
[11:02:37.589] plan(): nbrOfWorkers() = 1
[11:02:37.589] SequentialFuture started (and completed)
[11:02:37.589] - Launch lazy future ... done
[11:02:37.589] run() for ‘SequentialFuture’ ... done
[11:02:37.589] getGlobalsAndPackages() ...
[11:02:37.589] Searching for globals...
[11:02:37.590] - globals found: [2] ‘{’, ‘Sys.sleep’
[11:02:37.590] Searching for globals ... DONE
[11:02:37.590] Resolving globals: FALSE
[11:02:37.591] 
[11:02:37.591] 
[11:02:37.591] getGlobalsAndPackages() ... DONE
[11:02:37.591] run() for ‘Future’ ...
[11:02:37.591] - state: ‘created’
[11:02:37.591] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:02:37.591] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:37.592] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:37.592]   - Field: ‘label’
[11:02:37.592]   - Field: ‘local’
[11:02:37.592]   - Field: ‘owner’
[11:02:37.592]   - Field: ‘envir’
[11:02:37.592]   - Field: ‘packages’
[11:02:37.592]   - Field: ‘gc’
[11:02:37.592]   - Field: ‘conditions’
[11:02:37.592]   - Field: ‘expr’
[11:02:37.592]   - Field: ‘uuid’
[11:02:37.592]   - Field: ‘seed’
[11:02:37.592]   - Field: ‘version’
[11:02:37.593]   - Field: ‘result’
[11:02:37.593]   - Field: ‘asynchronous’
[11:02:37.593]   - Field: ‘calls’
[11:02:37.593]   - Field: ‘globals’
[11:02:37.593]   - Field: ‘stdout’
[11:02:37.593]   - Field: ‘earlySignal’
[11:02:37.593]   - Field: ‘lazy’
[11:02:37.593]   - Field: ‘state’
[11:02:37.593] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:37.593] - Launch lazy future ...
[11:02:37.593] Packages needed by the future expression (n = 0): <none>
[11:02:37.593] Packages needed by future strategies (n = 0): <none>
[11:02:37.594] {
[11:02:37.594]     {
[11:02:37.594]         {
[11:02:37.594]             ...future.startTime <- base::Sys.time()
[11:02:37.594]             {
[11:02:37.594]                 {
[11:02:37.594]                   {
[11:02:37.594]                     base::local({
[11:02:37.594]                       has_future <- base::requireNamespace("future", 
[11:02:37.594]                         quietly = TRUE)
[11:02:37.594]                       if (has_future) {
[11:02:37.594]                         ns <- base::getNamespace("future")
[11:02:37.594]                         version <- ns[[".package"]][["version"]]
[11:02:37.594]                         if (is.null(version)) 
[11:02:37.594]                           version <- utils::packageVersion("future")
[11:02:37.594]                       }
[11:02:37.594]                       else {
[11:02:37.594]                         version <- NULL
[11:02:37.594]                       }
[11:02:37.594]                       if (!has_future || version < "1.8.0") {
[11:02:37.594]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:37.594]                           "", base::R.version$version.string), 
[11:02:37.594]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:37.594]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:37.594]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:37.594]                             "release", "version")], collapse = " "), 
[11:02:37.594]                           hostname = base::Sys.info()[["nodename"]])
[11:02:37.594]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:37.594]                           info)
[11:02:37.594]                         info <- base::paste(info, collapse = "; ")
[11:02:37.594]                         if (!has_future) {
[11:02:37.594]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:37.594]                             info)
[11:02:37.594]                         }
[11:02:37.594]                         else {
[11:02:37.594]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:37.594]                             info, version)
[11:02:37.594]                         }
[11:02:37.594]                         base::stop(msg)
[11:02:37.594]                       }
[11:02:37.594]                     })
[11:02:37.594]                   }
[11:02:37.594]                   ...future.strategy.old <- future::plan("list")
[11:02:37.594]                   options(future.plan = NULL)
[11:02:37.594]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:37.594]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:37.594]                 }
[11:02:37.594]                 ...future.workdir <- getwd()
[11:02:37.594]             }
[11:02:37.594]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:37.594]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:37.594]         }
[11:02:37.594]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:37.594]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:37.594]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:37.594]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:37.594]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:37.594]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:37.594]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:37.594]             base::names(...future.oldOptions))
[11:02:37.594]     }
[11:02:37.594]     if (FALSE) {
[11:02:37.594]     }
[11:02:37.594]     else {
[11:02:37.594]         if (TRUE) {
[11:02:37.594]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:37.594]                 open = "w")
[11:02:37.594]         }
[11:02:37.594]         else {
[11:02:37.594]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:37.594]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:37.594]         }
[11:02:37.594]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:37.594]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:37.594]             base::sink(type = "output", split = FALSE)
[11:02:37.594]             base::close(...future.stdout)
[11:02:37.594]         }, add = TRUE)
[11:02:37.594]     }
[11:02:37.594]     ...future.frame <- base::sys.nframe()
[11:02:37.594]     ...future.conditions <- base::list()
[11:02:37.594]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:37.594]     if (FALSE) {
[11:02:37.594]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:37.594]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:37.594]     }
[11:02:37.594]     ...future.result <- base::tryCatch({
[11:02:37.594]         base::withCallingHandlers({
[11:02:37.594]             ...future.value <- base::withVisible(base::local({
[11:02:37.594]                 Sys.sleep(0.5)
[11:02:37.594]                 2
[11:02:37.594]             }))
[11:02:37.594]             future::FutureResult(value = ...future.value$value, 
[11:02:37.594]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:37.594]                   ...future.rng), globalenv = if (FALSE) 
[11:02:37.594]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:37.594]                     ...future.globalenv.names))
[11:02:37.594]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:37.594]         }, condition = base::local({
[11:02:37.594]             c <- base::c
[11:02:37.594]             inherits <- base::inherits
[11:02:37.594]             invokeRestart <- base::invokeRestart
[11:02:37.594]             length <- base::length
[11:02:37.594]             list <- base::list
[11:02:37.594]             seq.int <- base::seq.int
[11:02:37.594]             signalCondition <- base::signalCondition
[11:02:37.594]             sys.calls <- base::sys.calls
[11:02:37.594]             `[[` <- base::`[[`
[11:02:37.594]             `+` <- base::`+`
[11:02:37.594]             `<<-` <- base::`<<-`
[11:02:37.594]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:37.594]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:37.594]                   3L)]
[11:02:37.594]             }
[11:02:37.594]             function(cond) {
[11:02:37.594]                 is_error <- inherits(cond, "error")
[11:02:37.594]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:37.594]                   NULL)
[11:02:37.594]                 if (is_error) {
[11:02:37.594]                   sessionInformation <- function() {
[11:02:37.594]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:37.594]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:37.594]                       search = base::search(), system = base::Sys.info())
[11:02:37.594]                   }
[11:02:37.594]                   ...future.conditions[[length(...future.conditions) + 
[11:02:37.594]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:37.594]                     cond$call), session = sessionInformation(), 
[11:02:37.594]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:37.594]                   signalCondition(cond)
[11:02:37.594]                 }
[11:02:37.594]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:37.594]                 "immediateCondition"))) {
[11:02:37.594]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:37.594]                   ...future.conditions[[length(...future.conditions) + 
[11:02:37.594]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:37.594]                   if (TRUE && !signal) {
[11:02:37.594]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:37.594]                     {
[11:02:37.594]                       inherits <- base::inherits
[11:02:37.594]                       invokeRestart <- base::invokeRestart
[11:02:37.594]                       is.null <- base::is.null
[11:02:37.594]                       muffled <- FALSE
[11:02:37.594]                       if (inherits(cond, "message")) {
[11:02:37.594]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:37.594]                         if (muffled) 
[11:02:37.594]                           invokeRestart("muffleMessage")
[11:02:37.594]                       }
[11:02:37.594]                       else if (inherits(cond, "warning")) {
[11:02:37.594]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:37.594]                         if (muffled) 
[11:02:37.594]                           invokeRestart("muffleWarning")
[11:02:37.594]                       }
[11:02:37.594]                       else if (inherits(cond, "condition")) {
[11:02:37.594]                         if (!is.null(pattern)) {
[11:02:37.594]                           computeRestarts <- base::computeRestarts
[11:02:37.594]                           grepl <- base::grepl
[11:02:37.594]                           restarts <- computeRestarts(cond)
[11:02:37.594]                           for (restart in restarts) {
[11:02:37.594]                             name <- restart$name
[11:02:37.594]                             if (is.null(name)) 
[11:02:37.594]                               next
[11:02:37.594]                             if (!grepl(pattern, name)) 
[11:02:37.594]                               next
[11:02:37.594]                             invokeRestart(restart)
[11:02:37.594]                             muffled <- TRUE
[11:02:37.594]                             break
[11:02:37.594]                           }
[11:02:37.594]                         }
[11:02:37.594]                       }
[11:02:37.594]                       invisible(muffled)
[11:02:37.594]                     }
[11:02:37.594]                     muffleCondition(cond, pattern = "^muffle")
[11:02:37.594]                   }
[11:02:37.594]                 }
[11:02:37.594]                 else {
[11:02:37.594]                   if (TRUE) {
[11:02:37.594]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:37.594]                     {
[11:02:37.594]                       inherits <- base::inherits
[11:02:37.594]                       invokeRestart <- base::invokeRestart
[11:02:37.594]                       is.null <- base::is.null
[11:02:37.594]                       muffled <- FALSE
[11:02:37.594]                       if (inherits(cond, "message")) {
[11:02:37.594]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:37.594]                         if (muffled) 
[11:02:37.594]                           invokeRestart("muffleMessage")
[11:02:37.594]                       }
[11:02:37.594]                       else if (inherits(cond, "warning")) {
[11:02:37.594]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:37.594]                         if (muffled) 
[11:02:37.594]                           invokeRestart("muffleWarning")
[11:02:37.594]                       }
[11:02:37.594]                       else if (inherits(cond, "condition")) {
[11:02:37.594]                         if (!is.null(pattern)) {
[11:02:37.594]                           computeRestarts <- base::computeRestarts
[11:02:37.594]                           grepl <- base::grepl
[11:02:37.594]                           restarts <- computeRestarts(cond)
[11:02:37.594]                           for (restart in restarts) {
[11:02:37.594]                             name <- restart$name
[11:02:37.594]                             if (is.null(name)) 
[11:02:37.594]                               next
[11:02:37.594]                             if (!grepl(pattern, name)) 
[11:02:37.594]                               next
[11:02:37.594]                             invokeRestart(restart)
[11:02:37.594]                             muffled <- TRUE
[11:02:37.594]                             break
[11:02:37.594]                           }
[11:02:37.594]                         }
[11:02:37.594]                       }
[11:02:37.594]                       invisible(muffled)
[11:02:37.594]                     }
[11:02:37.594]                     muffleCondition(cond, pattern = "^muffle")
[11:02:37.594]                   }
[11:02:37.594]                 }
[11:02:37.594]             }
[11:02:37.594]         }))
[11:02:37.594]     }, error = function(ex) {
[11:02:37.594]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:37.594]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:37.594]                 ...future.rng), started = ...future.startTime, 
[11:02:37.594]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:37.594]             version = "1.8"), class = "FutureResult")
[11:02:37.594]     }, finally = {
[11:02:37.594]         if (!identical(...future.workdir, getwd())) 
[11:02:37.594]             setwd(...future.workdir)
[11:02:37.594]         {
[11:02:37.594]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:37.594]                 ...future.oldOptions$nwarnings <- NULL
[11:02:37.594]             }
[11:02:37.594]             base::options(...future.oldOptions)
[11:02:37.594]             if (.Platform$OS.type == "windows") {
[11:02:37.594]                 old_names <- names(...future.oldEnvVars)
[11:02:37.594]                 envs <- base::Sys.getenv()
[11:02:37.594]                 names <- names(envs)
[11:02:37.594]                 common <- intersect(names, old_names)
[11:02:37.594]                 added <- setdiff(names, old_names)
[11:02:37.594]                 removed <- setdiff(old_names, names)
[11:02:37.594]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:37.594]                   envs[common]]
[11:02:37.594]                 NAMES <- toupper(changed)
[11:02:37.594]                 args <- list()
[11:02:37.594]                 for (kk in seq_along(NAMES)) {
[11:02:37.594]                   name <- changed[[kk]]
[11:02:37.594]                   NAME <- NAMES[[kk]]
[11:02:37.594]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.594]                     next
[11:02:37.594]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:37.594]                 }
[11:02:37.594]                 NAMES <- toupper(added)
[11:02:37.594]                 for (kk in seq_along(NAMES)) {
[11:02:37.594]                   name <- added[[kk]]
[11:02:37.594]                   NAME <- NAMES[[kk]]
[11:02:37.594]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.594]                     next
[11:02:37.594]                   args[[name]] <- ""
[11:02:37.594]                 }
[11:02:37.594]                 NAMES <- toupper(removed)
[11:02:37.594]                 for (kk in seq_along(NAMES)) {
[11:02:37.594]                   name <- removed[[kk]]
[11:02:37.594]                   NAME <- NAMES[[kk]]
[11:02:37.594]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:37.594]                     next
[11:02:37.594]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:37.594]                 }
[11:02:37.594]                 if (length(args) > 0) 
[11:02:37.594]                   base::do.call(base::Sys.setenv, args = args)
[11:02:37.594]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:37.594]             }
[11:02:37.594]             else {
[11:02:37.594]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:37.594]             }
[11:02:37.594]             {
[11:02:37.594]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:37.594]                   0L) {
[11:02:37.594]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:37.594]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:37.594]                   base::options(opts)
[11:02:37.594]                 }
[11:02:37.594]                 {
[11:02:37.594]                   {
[11:02:37.594]                     NULL
[11:02:37.594]                     RNGkind("Mersenne-Twister")
[11:02:37.594]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:37.594]                       inherits = FALSE)
[11:02:37.594]                   }
[11:02:37.594]                   options(future.plan = NULL)
[11:02:37.594]                   if (is.na(NA_character_)) 
[11:02:37.594]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:37.594]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:37.594]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:37.594]                     .init = FALSE)
[11:02:37.594]                 }
[11:02:37.594]             }
[11:02:37.594]         }
[11:02:37.594]     })
[11:02:37.594]     if (TRUE) {
[11:02:37.594]         base::sink(type = "output", split = FALSE)
[11:02:37.594]         if (TRUE) {
[11:02:37.594]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:37.594]         }
[11:02:37.594]         else {
[11:02:37.594]             ...future.result["stdout"] <- base::list(NULL)
[11:02:37.594]         }
[11:02:37.594]         base::close(...future.stdout)
[11:02:37.594]         ...future.stdout <- NULL
[11:02:37.594]     }
[11:02:37.594]     ...future.result$conditions <- ...future.conditions
[11:02:37.594]     ...future.result$finished <- base::Sys.time()
[11:02:37.594]     ...future.result
[11:02:37.594] }
[11:02:37.596] plan(): Setting new future strategy stack:
[11:02:37.596] List of future strategies:
[11:02:37.596] 1. sequential:
[11:02:37.596]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:37.596]    - tweaked: FALSE
[11:02:37.596]    - call: NULL
[11:02:37.596] plan(): nbrOfWorkers() = 1
[11:02:38.098] plan(): Setting new future strategy stack:
[11:02:38.098] List of future strategies:
[11:02:38.098] 1. sequential:
[11:02:38.098]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:38.098]    - tweaked: FALSE
[11:02:38.098]    - call: plan(strategy)
[11:02:38.099] plan(): nbrOfWorkers() = 1
[11:02:38.099] SequentialFuture started (and completed)
[11:02:38.099] - Launch lazy future ... done
[11:02:38.099] run() for ‘SequentialFuture’ ... done
[11:02:38.100] getGlobalsAndPackages() ...
[11:02:38.100] Searching for globals...
[11:02:38.100] - globals found: [1] ‘{’
[11:02:38.100] Searching for globals ... DONE
[11:02:38.101] Resolving globals: FALSE
[11:02:38.101] 
[11:02:38.101] 
[11:02:38.101] getGlobalsAndPackages() ... DONE
[11:02:38.101] run() for ‘Future’ ...
[11:02:38.101] - state: ‘created’
[11:02:38.101] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:02:38.102] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:38.102] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:38.102]   - Field: ‘label’
[11:02:38.102]   - Field: ‘local’
[11:02:38.102]   - Field: ‘owner’
[11:02:38.102]   - Field: ‘envir’
[11:02:38.102]   - Field: ‘packages’
[11:02:38.102]   - Field: ‘gc’
[11:02:38.102]   - Field: ‘conditions’
[11:02:38.103]   - Field: ‘expr’
[11:02:38.103]   - Field: ‘uuid’
[11:02:38.103]   - Field: ‘seed’
[11:02:38.103]   - Field: ‘version’
[11:02:38.103]   - Field: ‘result’
[11:02:38.103]   - Field: ‘asynchronous’
[11:02:38.103]   - Field: ‘calls’
[11:02:38.103]   - Field: ‘globals’
[11:02:38.103]   - Field: ‘stdout’
[11:02:38.103]   - Field: ‘earlySignal’
[11:02:38.103]   - Field: ‘lazy’
[11:02:38.103]   - Field: ‘state’
[11:02:38.104] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:38.104] - Launch lazy future ...
[11:02:38.104] Packages needed by the future expression (n = 0): <none>
[11:02:38.104] Packages needed by future strategies (n = 0): <none>
[11:02:38.104] {
[11:02:38.104]     {
[11:02:38.104]         {
[11:02:38.104]             ...future.startTime <- base::Sys.time()
[11:02:38.104]             {
[11:02:38.104]                 {
[11:02:38.104]                   {
[11:02:38.104]                     base::local({
[11:02:38.104]                       has_future <- base::requireNamespace("future", 
[11:02:38.104]                         quietly = TRUE)
[11:02:38.104]                       if (has_future) {
[11:02:38.104]                         ns <- base::getNamespace("future")
[11:02:38.104]                         version <- ns[[".package"]][["version"]]
[11:02:38.104]                         if (is.null(version)) 
[11:02:38.104]                           version <- utils::packageVersion("future")
[11:02:38.104]                       }
[11:02:38.104]                       else {
[11:02:38.104]                         version <- NULL
[11:02:38.104]                       }
[11:02:38.104]                       if (!has_future || version < "1.8.0") {
[11:02:38.104]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:38.104]                           "", base::R.version$version.string), 
[11:02:38.104]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:38.104]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:38.104]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:38.104]                             "release", "version")], collapse = " "), 
[11:02:38.104]                           hostname = base::Sys.info()[["nodename"]])
[11:02:38.104]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:38.104]                           info)
[11:02:38.104]                         info <- base::paste(info, collapse = "; ")
[11:02:38.104]                         if (!has_future) {
[11:02:38.104]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:38.104]                             info)
[11:02:38.104]                         }
[11:02:38.104]                         else {
[11:02:38.104]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:38.104]                             info, version)
[11:02:38.104]                         }
[11:02:38.104]                         base::stop(msg)
[11:02:38.104]                       }
[11:02:38.104]                     })
[11:02:38.104]                   }
[11:02:38.104]                   ...future.strategy.old <- future::plan("list")
[11:02:38.104]                   options(future.plan = NULL)
[11:02:38.104]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:38.104]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:38.104]                 }
[11:02:38.104]                 ...future.workdir <- getwd()
[11:02:38.104]             }
[11:02:38.104]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:38.104]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:38.104]         }
[11:02:38.104]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:38.104]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:38.104]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:38.104]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:38.104]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:38.104]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:38.104]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:38.104]             base::names(...future.oldOptions))
[11:02:38.104]     }
[11:02:38.104]     if (FALSE) {
[11:02:38.104]     }
[11:02:38.104]     else {
[11:02:38.104]         if (TRUE) {
[11:02:38.104]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:38.104]                 open = "w")
[11:02:38.104]         }
[11:02:38.104]         else {
[11:02:38.104]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:38.104]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:38.104]         }
[11:02:38.104]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:38.104]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:38.104]             base::sink(type = "output", split = FALSE)
[11:02:38.104]             base::close(...future.stdout)
[11:02:38.104]         }, add = TRUE)
[11:02:38.104]     }
[11:02:38.104]     ...future.frame <- base::sys.nframe()
[11:02:38.104]     ...future.conditions <- base::list()
[11:02:38.104]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:38.104]     if (FALSE) {
[11:02:38.104]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:38.104]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:38.104]     }
[11:02:38.104]     ...future.result <- base::tryCatch({
[11:02:38.104]         base::withCallingHandlers({
[11:02:38.104]             ...future.value <- base::withVisible(base::local({
[11:02:38.104]                 3
[11:02:38.104]             }))
[11:02:38.104]             future::FutureResult(value = ...future.value$value, 
[11:02:38.104]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:38.104]                   ...future.rng), globalenv = if (FALSE) 
[11:02:38.104]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:38.104]                     ...future.globalenv.names))
[11:02:38.104]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:38.104]         }, condition = base::local({
[11:02:38.104]             c <- base::c
[11:02:38.104]             inherits <- base::inherits
[11:02:38.104]             invokeRestart <- base::invokeRestart
[11:02:38.104]             length <- base::length
[11:02:38.104]             list <- base::list
[11:02:38.104]             seq.int <- base::seq.int
[11:02:38.104]             signalCondition <- base::signalCondition
[11:02:38.104]             sys.calls <- base::sys.calls
[11:02:38.104]             `[[` <- base::`[[`
[11:02:38.104]             `+` <- base::`+`
[11:02:38.104]             `<<-` <- base::`<<-`
[11:02:38.104]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:38.104]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:38.104]                   3L)]
[11:02:38.104]             }
[11:02:38.104]             function(cond) {
[11:02:38.104]                 is_error <- inherits(cond, "error")
[11:02:38.104]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:38.104]                   NULL)
[11:02:38.104]                 if (is_error) {
[11:02:38.104]                   sessionInformation <- function() {
[11:02:38.104]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:38.104]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:38.104]                       search = base::search(), system = base::Sys.info())
[11:02:38.104]                   }
[11:02:38.104]                   ...future.conditions[[length(...future.conditions) + 
[11:02:38.104]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:38.104]                     cond$call), session = sessionInformation(), 
[11:02:38.104]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:38.104]                   signalCondition(cond)
[11:02:38.104]                 }
[11:02:38.104]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:38.104]                 "immediateCondition"))) {
[11:02:38.104]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:38.104]                   ...future.conditions[[length(...future.conditions) + 
[11:02:38.104]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:38.104]                   if (TRUE && !signal) {
[11:02:38.104]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:38.104]                     {
[11:02:38.104]                       inherits <- base::inherits
[11:02:38.104]                       invokeRestart <- base::invokeRestart
[11:02:38.104]                       is.null <- base::is.null
[11:02:38.104]                       muffled <- FALSE
[11:02:38.104]                       if (inherits(cond, "message")) {
[11:02:38.104]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:38.104]                         if (muffled) 
[11:02:38.104]                           invokeRestart("muffleMessage")
[11:02:38.104]                       }
[11:02:38.104]                       else if (inherits(cond, "warning")) {
[11:02:38.104]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:38.104]                         if (muffled) 
[11:02:38.104]                           invokeRestart("muffleWarning")
[11:02:38.104]                       }
[11:02:38.104]                       else if (inherits(cond, "condition")) {
[11:02:38.104]                         if (!is.null(pattern)) {
[11:02:38.104]                           computeRestarts <- base::computeRestarts
[11:02:38.104]                           grepl <- base::grepl
[11:02:38.104]                           restarts <- computeRestarts(cond)
[11:02:38.104]                           for (restart in restarts) {
[11:02:38.104]                             name <- restart$name
[11:02:38.104]                             if (is.null(name)) 
[11:02:38.104]                               next
[11:02:38.104]                             if (!grepl(pattern, name)) 
[11:02:38.104]                               next
[11:02:38.104]                             invokeRestart(restart)
[11:02:38.104]                             muffled <- TRUE
[11:02:38.104]                             break
[11:02:38.104]                           }
[11:02:38.104]                         }
[11:02:38.104]                       }
[11:02:38.104]                       invisible(muffled)
[11:02:38.104]                     }
[11:02:38.104]                     muffleCondition(cond, pattern = "^muffle")
[11:02:38.104]                   }
[11:02:38.104]                 }
[11:02:38.104]                 else {
[11:02:38.104]                   if (TRUE) {
[11:02:38.104]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:38.104]                     {
[11:02:38.104]                       inherits <- base::inherits
[11:02:38.104]                       invokeRestart <- base::invokeRestart
[11:02:38.104]                       is.null <- base::is.null
[11:02:38.104]                       muffled <- FALSE
[11:02:38.104]                       if (inherits(cond, "message")) {
[11:02:38.104]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:38.104]                         if (muffled) 
[11:02:38.104]                           invokeRestart("muffleMessage")
[11:02:38.104]                       }
[11:02:38.104]                       else if (inherits(cond, "warning")) {
[11:02:38.104]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:38.104]                         if (muffled) 
[11:02:38.104]                           invokeRestart("muffleWarning")
[11:02:38.104]                       }
[11:02:38.104]                       else if (inherits(cond, "condition")) {
[11:02:38.104]                         if (!is.null(pattern)) {
[11:02:38.104]                           computeRestarts <- base::computeRestarts
[11:02:38.104]                           grepl <- base::grepl
[11:02:38.104]                           restarts <- computeRestarts(cond)
[11:02:38.104]                           for (restart in restarts) {
[11:02:38.104]                             name <- restart$name
[11:02:38.104]                             if (is.null(name)) 
[11:02:38.104]                               next
[11:02:38.104]                             if (!grepl(pattern, name)) 
[11:02:38.104]                               next
[11:02:38.104]                             invokeRestart(restart)
[11:02:38.104]                             muffled <- TRUE
[11:02:38.104]                             break
[11:02:38.104]                           }
[11:02:38.104]                         }
[11:02:38.104]                       }
[11:02:38.104]                       invisible(muffled)
[11:02:38.104]                     }
[11:02:38.104]                     muffleCondition(cond, pattern = "^muffle")
[11:02:38.104]                   }
[11:02:38.104]                 }
[11:02:38.104]             }
[11:02:38.104]         }))
[11:02:38.104]     }, error = function(ex) {
[11:02:38.104]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:38.104]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:38.104]                 ...future.rng), started = ...future.startTime, 
[11:02:38.104]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:38.104]             version = "1.8"), class = "FutureResult")
[11:02:38.104]     }, finally = {
[11:02:38.104]         if (!identical(...future.workdir, getwd())) 
[11:02:38.104]             setwd(...future.workdir)
[11:02:38.104]         {
[11:02:38.104]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:38.104]                 ...future.oldOptions$nwarnings <- NULL
[11:02:38.104]             }
[11:02:38.104]             base::options(...future.oldOptions)
[11:02:38.104]             if (.Platform$OS.type == "windows") {
[11:02:38.104]                 old_names <- names(...future.oldEnvVars)
[11:02:38.104]                 envs <- base::Sys.getenv()
[11:02:38.104]                 names <- names(envs)
[11:02:38.104]                 common <- intersect(names, old_names)
[11:02:38.104]                 added <- setdiff(names, old_names)
[11:02:38.104]                 removed <- setdiff(old_names, names)
[11:02:38.104]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:38.104]                   envs[common]]
[11:02:38.104]                 NAMES <- toupper(changed)
[11:02:38.104]                 args <- list()
[11:02:38.104]                 for (kk in seq_along(NAMES)) {
[11:02:38.104]                   name <- changed[[kk]]
[11:02:38.104]                   NAME <- NAMES[[kk]]
[11:02:38.104]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:38.104]                     next
[11:02:38.104]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:38.104]                 }
[11:02:38.104]                 NAMES <- toupper(added)
[11:02:38.104]                 for (kk in seq_along(NAMES)) {
[11:02:38.104]                   name <- added[[kk]]
[11:02:38.104]                   NAME <- NAMES[[kk]]
[11:02:38.104]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:38.104]                     next
[11:02:38.104]                   args[[name]] <- ""
[11:02:38.104]                 }
[11:02:38.104]                 NAMES <- toupper(removed)
[11:02:38.104]                 for (kk in seq_along(NAMES)) {
[11:02:38.104]                   name <- removed[[kk]]
[11:02:38.104]                   NAME <- NAMES[[kk]]
[11:02:38.104]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:38.104]                     next
[11:02:38.104]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:38.104]                 }
[11:02:38.104]                 if (length(args) > 0) 
[11:02:38.104]                   base::do.call(base::Sys.setenv, args = args)
[11:02:38.104]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:38.104]             }
[11:02:38.104]             else {
[11:02:38.104]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:38.104]             }
[11:02:38.104]             {
[11:02:38.104]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:38.104]                   0L) {
[11:02:38.104]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:38.104]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:38.104]                   base::options(opts)
[11:02:38.104]                 }
[11:02:38.104]                 {
[11:02:38.104]                   {
[11:02:38.104]                     NULL
[11:02:38.104]                     RNGkind("Mersenne-Twister")
[11:02:38.104]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:38.104]                       inherits = FALSE)
[11:02:38.104]                   }
[11:02:38.104]                   options(future.plan = NULL)
[11:02:38.104]                   if (is.na(NA_character_)) 
[11:02:38.104]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:38.104]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:38.104]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:38.104]                     .init = FALSE)
[11:02:38.104]                 }
[11:02:38.104]             }
[11:02:38.104]         }
[11:02:38.104]     })
[11:02:38.104]     if (TRUE) {
[11:02:38.104]         base::sink(type = "output", split = FALSE)
[11:02:38.104]         if (TRUE) {
[11:02:38.104]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:38.104]         }
[11:02:38.104]         else {
[11:02:38.104]             ...future.result["stdout"] <- base::list(NULL)
[11:02:38.104]         }
[11:02:38.104]         base::close(...future.stdout)
[11:02:38.104]         ...future.stdout <- NULL
[11:02:38.104]     }
[11:02:38.104]     ...future.result$conditions <- ...future.conditions
[11:02:38.104]     ...future.result$finished <- base::Sys.time()
[11:02:38.104]     ...future.result
[11:02:38.104] }
[11:02:38.106] plan(): Setting new future strategy stack:
[11:02:38.106] List of future strategies:
[11:02:38.106] 1. sequential:
[11:02:38.106]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:38.106]    - tweaked: FALSE
[11:02:38.106]    - call: NULL
[11:02:38.107] plan(): nbrOfWorkers() = 1
[11:02:38.107] plan(): Setting new future strategy stack:
[11:02:38.108] List of future strategies:
[11:02:38.108] 1. sequential:
[11:02:38.108]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:38.108]    - tweaked: FALSE
[11:02:38.108]    - call: plan(strategy)
[11:02:38.108] plan(): nbrOfWorkers() = 1
[11:02:38.108] SequentialFuture started (and completed)
[11:02:38.108] - Launch lazy future ... done
[11:02:38.108] run() for ‘SequentialFuture’ ... done
[11:02:38.109] resolve() on list environment ...
[11:02:38.109]  recursive: 0
[11:02:38.110]  length: 4
[11:02:38.110]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[11:02:38.110] resolved() for ‘SequentialFuture’ ...
[11:02:38.110] - state: ‘finished’
[11:02:38.110] - run: TRUE
[11:02:38.110] - result: ‘FutureResult’
[11:02:38.110] resolved() for ‘SequentialFuture’ ... done
[11:02:38.110] Future #1
[11:02:38.110]  length: 3 (resolved future 1)
[11:02:38.111] resolved() for ‘SequentialFuture’ ...
[11:02:38.111] - state: ‘finished’
[11:02:38.111] - run: TRUE
[11:02:38.111] - result: ‘FutureResult’
[11:02:38.111] resolved() for ‘SequentialFuture’ ... done
[11:02:38.111] Future #2
[11:02:38.111]  length: 2 (resolved future 2)
[11:02:38.111] resolved() for ‘SequentialFuture’ ...
[11:02:38.111] - state: ‘finished’
[11:02:38.111] - run: TRUE
[11:02:38.111] - result: ‘FutureResult’
[11:02:38.112] resolved() for ‘SequentialFuture’ ... done
[11:02:38.112] Future #3
[11:02:38.112]  length: 1 (resolved future 3)
[11:02:38.112]  length: 0 (resolved future 4)
[11:02:38.112] resolve() on list environment ... DONE
[11:02:38.112] resolved() for ‘SequentialFuture’ ...
[11:02:38.112] - state: ‘finished’
[11:02:38.112] - run: TRUE
[11:02:38.112] - result: ‘FutureResult’
[11:02:38.113] resolved() for ‘SequentialFuture’ ... done
[11:02:38.113] resolve() on list environment ...
[11:02:38.113]  recursive: 0
[11:02:38.115]  length: 4
[11:02:38.115]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[11:02:38.115] resolved() for ‘SequentialFuture’ ...
[11:02:38.115] - state: ‘finished’
[11:02:38.115] - run: TRUE
[11:02:38.116] - result: ‘FutureResult’
[11:02:38.116] resolved() for ‘SequentialFuture’ ... done
[11:02:38.116] Future #1
[11:02:38.116]  length: 3 (resolved future 1)
[11:02:38.116] resolved() for ‘SequentialFuture’ ...
[11:02:38.116] - state: ‘finished’
[11:02:38.116] - run: TRUE
[11:02:38.116] - result: ‘FutureResult’
[11:02:38.116] resolved() for ‘SequentialFuture’ ... done
[11:02:38.116] Future #2
[11:02:38.116]  length: 2 (resolved future 2)
[11:02:38.117] resolved() for ‘SequentialFuture’ ...
[11:02:38.117] - state: ‘finished’
[11:02:38.117] - run: TRUE
[11:02:38.117] - result: ‘FutureResult’
[11:02:38.117] resolved() for ‘SequentialFuture’ ... done
[11:02:38.117] Future #3
[11:02:38.117]  length: 1 (resolved future 3)
[11:02:38.117]  length: 0 (resolved future 4)
[11:02:38.117] resolve() on list environment ... DONE
[11:02:38.118] resolve() on list environment ...
[11:02:38.118]  recursive: 0
[11:02:38.118]  length: 4
[11:02:38.119]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[11:02:38.119] resolved() for ‘SequentialFuture’ ...
[11:02:38.119] - state: ‘finished’
[11:02:38.119] - run: TRUE
[11:02:38.119] - result: ‘FutureResult’
[11:02:38.119] resolved() for ‘SequentialFuture’ ... done
[11:02:38.119] Future #1
[11:02:38.119]  length: 3 (resolved future 1)
[11:02:38.119] resolved() for ‘SequentialFuture’ ...
[11:02:38.119] - state: ‘finished’
[11:02:38.119] - run: TRUE
[11:02:38.120] - result: ‘FutureResult’
[11:02:38.120] resolved() for ‘SequentialFuture’ ... done
[11:02:38.120] Future #2
[11:02:38.120]  length: 2 (resolved future 2)
[11:02:38.120] resolved() for ‘SequentialFuture’ ...
[11:02:38.120] - state: ‘finished’
[11:02:38.120] - run: TRUE
[11:02:38.120] - result: ‘FutureResult’
[11:02:38.120] resolved() for ‘SequentialFuture’ ... done
[11:02:38.120] Future #3
[11:02:38.120]  length: 1 (resolved future 3)
[11:02:38.121]  length: 0 (resolved future 4)
[11:02:38.121] resolve() on list environment ... DONE
[11:02:38.121] resolve() on list environment ...
[11:02:38.121]  recursive: 0
[11:02:38.122]  length: 4
[11:02:38.122]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[11:02:38.122] resolved() for ‘SequentialFuture’ ...
[11:02:38.122] - state: ‘finished’
[11:02:38.122] - run: TRUE
[11:02:38.122] - result: ‘FutureResult’
[11:02:38.122] resolved() for ‘SequentialFuture’ ... done
[11:02:38.122] Future #1
[11:02:38.122]  length: 3 (resolved future 1)
[11:02:38.123] resolved() for ‘SequentialFuture’ ...
[11:02:38.123] - state: ‘finished’
[11:02:38.123] - run: TRUE
[11:02:38.123] - result: ‘FutureResult’
[11:02:38.123] resolved() for ‘SequentialFuture’ ... done
[11:02:38.123] Future #2
[11:02:38.123]  length: 2 (resolved future 2)
[11:02:38.123] resolved() for ‘SequentialFuture’ ...
[11:02:38.123] - state: ‘finished’
[11:02:38.123] - run: TRUE
[11:02:38.123] - result: ‘FutureResult’
[11:02:38.123] resolved() for ‘SequentialFuture’ ... done
[11:02:38.124] Future #3
[11:02:38.124]  length: 1 (resolved future 3)
[11:02:38.124]  length: 0 (resolved future 4)
[11:02:38.124] resolve() on list environment ... DONE
[11:02:38.124] resolve() on list environment ...
[11:02:38.124]  recursive: 0
[11:02:38.125]  length: 4
[11:02:38.125]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[11:02:38.125] resolved() for ‘SequentialFuture’ ...
[11:02:38.125] - state: ‘finished’
[11:02:38.125] - run: TRUE
[11:02:38.125] - result: ‘FutureResult’
[11:02:38.125] resolved() for ‘SequentialFuture’ ... done
[11:02:38.125] Future #1
[11:02:38.126]  length: 3 (resolved future 1)
[11:02:38.126] resolved() for ‘SequentialFuture’ ...
[11:02:38.126] - state: ‘finished’
[11:02:38.126] - run: TRUE
[11:02:38.126] - result: ‘FutureResult’
[11:02:38.126] resolved() for ‘SequentialFuture’ ... done
[11:02:38.126] Future #2
[11:02:38.126]  length: 2 (resolved future 2)
[11:02:38.126] resolved() for ‘SequentialFuture’ ...
[11:02:38.126] - state: ‘finished’
[11:02:38.127] - run: TRUE
[11:02:38.127] - result: ‘FutureResult’
[11:02:38.127] resolved() for ‘SequentialFuture’ ... done
[11:02:38.127] Future #3
[11:02:38.127]  length: 1 (resolved future 3)
[11:02:38.127]  length: 0 (resolved future 4)
[11:02:38.127] resolve() on list environment ... DONE
[11:02:38.128] resolve() on list environment ...
[11:02:38.128]  recursive: 99
[11:02:38.128]  length: 4
[11:02:38.128]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[11:02:38.128] resolved() for ‘SequentialFuture’ ...
[11:02:38.128] - state: ‘finished’
[11:02:38.129] - run: TRUE
[11:02:38.129] - result: ‘FutureResult’
[11:02:38.129] resolved() for ‘SequentialFuture’ ... done
[11:02:38.129] Future #1
[11:02:38.129] resolved() for ‘SequentialFuture’ ...
[11:02:38.129] - state: ‘finished’
[11:02:38.129] - run: TRUE
[11:02:38.129] - result: ‘FutureResult’
[11:02:38.129] resolved() for ‘SequentialFuture’ ... done
[11:02:38.129] A SequentialFuture was resolved
[11:02:38.129]  length: 3 (resolved future 1)
[11:02:38.130] resolved() for ‘SequentialFuture’ ...
[11:02:38.130] - state: ‘finished’
[11:02:38.130] - run: TRUE
[11:02:38.130] - result: ‘FutureResult’
[11:02:38.130] resolved() for ‘SequentialFuture’ ... done
[11:02:38.130] Future #2
[11:02:38.130] resolved() for ‘SequentialFuture’ ...
[11:02:38.130] - state: ‘finished’
[11:02:38.130] - run: TRUE
[11:02:38.130] - result: ‘FutureResult’
[11:02:38.130] resolved() for ‘SequentialFuture’ ... done
[11:02:38.131] A SequentialFuture was resolved
[11:02:38.131]  length: 2 (resolved future 2)
[11:02:38.131] resolved() for ‘SequentialFuture’ ...
[11:02:38.131] - state: ‘finished’
[11:02:38.131] - run: TRUE
[11:02:38.131] - result: ‘FutureResult’
[11:02:38.131] resolved() for ‘SequentialFuture’ ... done
[11:02:38.131] Future #3
[11:02:38.131] resolved() for ‘SequentialFuture’ ...
[11:02:38.131] - state: ‘finished’
[11:02:38.131] - run: TRUE
[11:02:38.131] - result: ‘FutureResult’
[11:02:38.132] resolved() for ‘SequentialFuture’ ... done
[11:02:38.132] A SequentialFuture was resolved
[11:02:38.132]  length: 1 (resolved future 3)
[11:02:38.132]  length: 0 (resolved future 4)
[11:02:38.132] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('sequential') ...
- plan('multicore') ...
[11:02:38.154] plan(): Setting new future strategy stack:
[11:02:38.155] List of future strategies:
[11:02:38.155] 1. multicore:
[11:02:38.155]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:38.155]    - tweaked: FALSE
[11:02:38.155]    - call: plan(strategy)
[11:02:38.156] plan(): nbrOfWorkers() = 2
*** resolve() for lists ...
[11:02:38.157] resolve() on list ...
[11:02:38.157]  recursive: 0
[11:02:38.157]  length: 2
[11:02:38.157]  elements: ‘a’, ‘b’
[11:02:38.157]  length: 1 (resolved future 1)
[11:02:38.157]  length: 0 (resolved future 2)
[11:02:38.157] resolve() on list ... DONE
[11:02:38.157] getGlobalsAndPackages() ...
[11:02:38.157] Searching for globals...
[11:02:38.158] 
[11:02:38.158] Searching for globals ... DONE
[11:02:38.158] - globals: [0] <none>
[11:02:38.158] getGlobalsAndPackages() ... DONE
[11:02:38.158] run() for ‘Future’ ...
[11:02:38.158] - state: ‘created’
[11:02:38.158] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:02:38.160] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:38.160] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:02:38.160]   - Field: ‘label’
[11:02:38.160]   - Field: ‘local’
[11:02:38.160]   - Field: ‘owner’
[11:02:38.160]   - Field: ‘envir’
[11:02:38.161]   - Field: ‘workers’
[11:02:38.161]   - Field: ‘packages’
[11:02:38.161]   - Field: ‘gc’
[11:02:38.161]   - Field: ‘job’
[11:02:38.161]   - Field: ‘conditions’
[11:02:38.161]   - Field: ‘expr’
[11:02:38.161]   - Field: ‘uuid’
[11:02:38.161]   - Field: ‘seed’
[11:02:38.161]   - Field: ‘version’
[11:02:38.161]   - Field: ‘result’
[11:02:38.161]   - Field: ‘asynchronous’
[11:02:38.161]   - Field: ‘calls’
[11:02:38.161]   - Field: ‘globals’
[11:02:38.162]   - Field: ‘stdout’
[11:02:38.162]   - Field: ‘earlySignal’
[11:02:38.162]   - Field: ‘lazy’
[11:02:38.162]   - Field: ‘state’
[11:02:38.162] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:02:38.162] - Launch lazy future ...
[11:02:38.163] Packages needed by the future expression (n = 0): <none>
[11:02:38.163] Packages needed by future strategies (n = 0): <none>
[11:02:38.163] {
[11:02:38.163]     {
[11:02:38.163]         {
[11:02:38.163]             ...future.startTime <- base::Sys.time()
[11:02:38.163]             {
[11:02:38.163]                 {
[11:02:38.163]                   {
[11:02:38.163]                     {
[11:02:38.163]                       base::local({
[11:02:38.163]                         has_future <- base::requireNamespace("future", 
[11:02:38.163]                           quietly = TRUE)
[11:02:38.163]                         if (has_future) {
[11:02:38.163]                           ns <- base::getNamespace("future")
[11:02:38.163]                           version <- ns[[".package"]][["version"]]
[11:02:38.163]                           if (is.null(version)) 
[11:02:38.163]                             version <- utils::packageVersion("future")
[11:02:38.163]                         }
[11:02:38.163]                         else {
[11:02:38.163]                           version <- NULL
[11:02:38.163]                         }
[11:02:38.163]                         if (!has_future || version < "1.8.0") {
[11:02:38.163]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:38.163]                             "", base::R.version$version.string), 
[11:02:38.163]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:38.163]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:38.163]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:38.163]                               "release", "version")], collapse = " "), 
[11:02:38.163]                             hostname = base::Sys.info()[["nodename"]])
[11:02:38.163]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:38.163]                             info)
[11:02:38.163]                           info <- base::paste(info, collapse = "; ")
[11:02:38.163]                           if (!has_future) {
[11:02:38.163]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:38.163]                               info)
[11:02:38.163]                           }
[11:02:38.163]                           else {
[11:02:38.163]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:38.163]                               info, version)
[11:02:38.163]                           }
[11:02:38.163]                           base::stop(msg)
[11:02:38.163]                         }
[11:02:38.163]                       })
[11:02:38.163]                     }
[11:02:38.163]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:38.163]                     base::options(mc.cores = 1L)
[11:02:38.163]                   }
[11:02:38.163]                   ...future.strategy.old <- future::plan("list")
[11:02:38.163]                   options(future.plan = NULL)
[11:02:38.163]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:38.163]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:38.163]                 }
[11:02:38.163]                 ...future.workdir <- getwd()
[11:02:38.163]             }
[11:02:38.163]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:38.163]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:38.163]         }
[11:02:38.163]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:38.163]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:38.163]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:38.163]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:38.163]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:38.163]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:38.163]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:38.163]             base::names(...future.oldOptions))
[11:02:38.163]     }
[11:02:38.163]     if (FALSE) {
[11:02:38.163]     }
[11:02:38.163]     else {
[11:02:38.163]         if (TRUE) {
[11:02:38.163]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:38.163]                 open = "w")
[11:02:38.163]         }
[11:02:38.163]         else {
[11:02:38.163]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:38.163]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:38.163]         }
[11:02:38.163]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:38.163]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:38.163]             base::sink(type = "output", split = FALSE)
[11:02:38.163]             base::close(...future.stdout)
[11:02:38.163]         }, add = TRUE)
[11:02:38.163]     }
[11:02:38.163]     ...future.frame <- base::sys.nframe()
[11:02:38.163]     ...future.conditions <- base::list()
[11:02:38.163]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:38.163]     if (FALSE) {
[11:02:38.163]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:38.163]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:38.163]     }
[11:02:38.163]     ...future.result <- base::tryCatch({
[11:02:38.163]         base::withCallingHandlers({
[11:02:38.163]             ...future.value <- base::withVisible(base::local({
[11:02:38.163]                 withCallingHandlers({
[11:02:38.163]                   1
[11:02:38.163]                 }, immediateCondition = function(cond) {
[11:02:38.163]                   save_rds <- function (object, pathname, ...) 
[11:02:38.163]                   {
[11:02:38.163]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:02:38.163]                     if (file_test("-f", pathname_tmp)) {
[11:02:38.163]                       fi_tmp <- file.info(pathname_tmp)
[11:02:38.163]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:02:38.163]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:38.163]                         fi_tmp[["mtime"]])
[11:02:38.163]                     }
[11:02:38.163]                     tryCatch({
[11:02:38.163]                       saveRDS(object, file = pathname_tmp, ...)
[11:02:38.163]                     }, error = function(ex) {
[11:02:38.163]                       msg <- conditionMessage(ex)
[11:02:38.163]                       fi_tmp <- file.info(pathname_tmp)
[11:02:38.163]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:02:38.163]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:38.163]                         fi_tmp[["mtime"]], msg)
[11:02:38.163]                       ex$message <- msg
[11:02:38.163]                       stop(ex)
[11:02:38.163]                     })
[11:02:38.163]                     stopifnot(file_test("-f", pathname_tmp))
[11:02:38.163]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:02:38.163]                     if (!res || file_test("-f", pathname_tmp)) {
[11:02:38.163]                       fi_tmp <- file.info(pathname_tmp)
[11:02:38.163]                       fi <- file.info(pathname)
[11:02:38.163]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:02:38.163]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:38.163]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:02:38.163]                         fi[["size"]], fi[["mtime"]])
[11:02:38.163]                       stop(msg)
[11:02:38.163]                     }
[11:02:38.163]                     invisible(pathname)
[11:02:38.163]                   }
[11:02:38.163]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:02:38.163]                     rootPath = tempdir()) 
[11:02:38.163]                   {
[11:02:38.163]                     obj <- list(time = Sys.time(), condition = cond)
[11:02:38.163]                     file <- tempfile(pattern = class(cond)[1], 
[11:02:38.163]                       tmpdir = path, fileext = ".rds")
[11:02:38.163]                     save_rds(obj, file)
[11:02:38.163]                   }
[11:02:38.163]                   saveImmediateCondition(cond, path = "/tmp/RtmpPVwpFC/.future/immediateConditions")
[11:02:38.163]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:38.163]                   {
[11:02:38.163]                     inherits <- base::inherits
[11:02:38.163]                     invokeRestart <- base::invokeRestart
[11:02:38.163]                     is.null <- base::is.null
[11:02:38.163]                     muffled <- FALSE
[11:02:38.163]                     if (inherits(cond, "message")) {
[11:02:38.163]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:38.163]                       if (muffled) 
[11:02:38.163]                         invokeRestart("muffleMessage")
[11:02:38.163]                     }
[11:02:38.163]                     else if (inherits(cond, "warning")) {
[11:02:38.163]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:38.163]                       if (muffled) 
[11:02:38.163]                         invokeRestart("muffleWarning")
[11:02:38.163]                     }
[11:02:38.163]                     else if (inherits(cond, "condition")) {
[11:02:38.163]                       if (!is.null(pattern)) {
[11:02:38.163]                         computeRestarts <- base::computeRestarts
[11:02:38.163]                         grepl <- base::grepl
[11:02:38.163]                         restarts <- computeRestarts(cond)
[11:02:38.163]                         for (restart in restarts) {
[11:02:38.163]                           name <- restart$name
[11:02:38.163]                           if (is.null(name)) 
[11:02:38.163]                             next
[11:02:38.163]                           if (!grepl(pattern, name)) 
[11:02:38.163]                             next
[11:02:38.163]                           invokeRestart(restart)
[11:02:38.163]                           muffled <- TRUE
[11:02:38.163]                           break
[11:02:38.163]                         }
[11:02:38.163]                       }
[11:02:38.163]                     }
[11:02:38.163]                     invisible(muffled)
[11:02:38.163]                   }
[11:02:38.163]                   muffleCondition(cond)
[11:02:38.163]                 })
[11:02:38.163]             }))
[11:02:38.163]             future::FutureResult(value = ...future.value$value, 
[11:02:38.163]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:38.163]                   ...future.rng), globalenv = if (FALSE) 
[11:02:38.163]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:38.163]                     ...future.globalenv.names))
[11:02:38.163]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:38.163]         }, condition = base::local({
[11:02:38.163]             c <- base::c
[11:02:38.163]             inherits <- base::inherits
[11:02:38.163]             invokeRestart <- base::invokeRestart
[11:02:38.163]             length <- base::length
[11:02:38.163]             list <- base::list
[11:02:38.163]             seq.int <- base::seq.int
[11:02:38.163]             signalCondition <- base::signalCondition
[11:02:38.163]             sys.calls <- base::sys.calls
[11:02:38.163]             `[[` <- base::`[[`
[11:02:38.163]             `+` <- base::`+`
[11:02:38.163]             `<<-` <- base::`<<-`
[11:02:38.163]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:38.163]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:38.163]                   3L)]
[11:02:38.163]             }
[11:02:38.163]             function(cond) {
[11:02:38.163]                 is_error <- inherits(cond, "error")
[11:02:38.163]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:38.163]                   NULL)
[11:02:38.163]                 if (is_error) {
[11:02:38.163]                   sessionInformation <- function() {
[11:02:38.163]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:38.163]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:38.163]                       search = base::search(), system = base::Sys.info())
[11:02:38.163]                   }
[11:02:38.163]                   ...future.conditions[[length(...future.conditions) + 
[11:02:38.163]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:38.163]                     cond$call), session = sessionInformation(), 
[11:02:38.163]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:38.163]                   signalCondition(cond)
[11:02:38.163]                 }
[11:02:38.163]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:38.163]                 "immediateCondition"))) {
[11:02:38.163]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:38.163]                   ...future.conditions[[length(...future.conditions) + 
[11:02:38.163]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:38.163]                   if (TRUE && !signal) {
[11:02:38.163]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:38.163]                     {
[11:02:38.163]                       inherits <- base::inherits
[11:02:38.163]                       invokeRestart <- base::invokeRestart
[11:02:38.163]                       is.null <- base::is.null
[11:02:38.163]                       muffled <- FALSE
[11:02:38.163]                       if (inherits(cond, "message")) {
[11:02:38.163]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:38.163]                         if (muffled) 
[11:02:38.163]                           invokeRestart("muffleMessage")
[11:02:38.163]                       }
[11:02:38.163]                       else if (inherits(cond, "warning")) {
[11:02:38.163]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:38.163]                         if (muffled) 
[11:02:38.163]                           invokeRestart("muffleWarning")
[11:02:38.163]                       }
[11:02:38.163]                       else if (inherits(cond, "condition")) {
[11:02:38.163]                         if (!is.null(pattern)) {
[11:02:38.163]                           computeRestarts <- base::computeRestarts
[11:02:38.163]                           grepl <- base::grepl
[11:02:38.163]                           restarts <- computeRestarts(cond)
[11:02:38.163]                           for (restart in restarts) {
[11:02:38.163]                             name <- restart$name
[11:02:38.163]                             if (is.null(name)) 
[11:02:38.163]                               next
[11:02:38.163]                             if (!grepl(pattern, name)) 
[11:02:38.163]                               next
[11:02:38.163]                             invokeRestart(restart)
[11:02:38.163]                             muffled <- TRUE
[11:02:38.163]                             break
[11:02:38.163]                           }
[11:02:38.163]                         }
[11:02:38.163]                       }
[11:02:38.163]                       invisible(muffled)
[11:02:38.163]                     }
[11:02:38.163]                     muffleCondition(cond, pattern = "^muffle")
[11:02:38.163]                   }
[11:02:38.163]                 }
[11:02:38.163]                 else {
[11:02:38.163]                   if (TRUE) {
[11:02:38.163]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:38.163]                     {
[11:02:38.163]                       inherits <- base::inherits
[11:02:38.163]                       invokeRestart <- base::invokeRestart
[11:02:38.163]                       is.null <- base::is.null
[11:02:38.163]                       muffled <- FALSE
[11:02:38.163]                       if (inherits(cond, "message")) {
[11:02:38.163]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:38.163]                         if (muffled) 
[11:02:38.163]                           invokeRestart("muffleMessage")
[11:02:38.163]                       }
[11:02:38.163]                       else if (inherits(cond, "warning")) {
[11:02:38.163]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:38.163]                         if (muffled) 
[11:02:38.163]                           invokeRestart("muffleWarning")
[11:02:38.163]                       }
[11:02:38.163]                       else if (inherits(cond, "condition")) {
[11:02:38.163]                         if (!is.null(pattern)) {
[11:02:38.163]                           computeRestarts <- base::computeRestarts
[11:02:38.163]                           grepl <- base::grepl
[11:02:38.163]                           restarts <- computeRestarts(cond)
[11:02:38.163]                           for (restart in restarts) {
[11:02:38.163]                             name <- restart$name
[11:02:38.163]                             if (is.null(name)) 
[11:02:38.163]                               next
[11:02:38.163]                             if (!grepl(pattern, name)) 
[11:02:38.163]                               next
[11:02:38.163]                             invokeRestart(restart)
[11:02:38.163]                             muffled <- TRUE
[11:02:38.163]                             break
[11:02:38.163]                           }
[11:02:38.163]                         }
[11:02:38.163]                       }
[11:02:38.163]                       invisible(muffled)
[11:02:38.163]                     }
[11:02:38.163]                     muffleCondition(cond, pattern = "^muffle")
[11:02:38.163]                   }
[11:02:38.163]                 }
[11:02:38.163]             }
[11:02:38.163]         }))
[11:02:38.163]     }, error = function(ex) {
[11:02:38.163]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:38.163]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:38.163]                 ...future.rng), started = ...future.startTime, 
[11:02:38.163]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:38.163]             version = "1.8"), class = "FutureResult")
[11:02:38.163]     }, finally = {
[11:02:38.163]         if (!identical(...future.workdir, getwd())) 
[11:02:38.163]             setwd(...future.workdir)
[11:02:38.163]         {
[11:02:38.163]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:38.163]                 ...future.oldOptions$nwarnings <- NULL
[11:02:38.163]             }
[11:02:38.163]             base::options(...future.oldOptions)
[11:02:38.163]             if (.Platform$OS.type == "windows") {
[11:02:38.163]                 old_names <- names(...future.oldEnvVars)
[11:02:38.163]                 envs <- base::Sys.getenv()
[11:02:38.163]                 names <- names(envs)
[11:02:38.163]                 common <- intersect(names, old_names)
[11:02:38.163]                 added <- setdiff(names, old_names)
[11:02:38.163]                 removed <- setdiff(old_names, names)
[11:02:38.163]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:38.163]                   envs[common]]
[11:02:38.163]                 NAMES <- toupper(changed)
[11:02:38.163]                 args <- list()
[11:02:38.163]                 for (kk in seq_along(NAMES)) {
[11:02:38.163]                   name <- changed[[kk]]
[11:02:38.163]                   NAME <- NAMES[[kk]]
[11:02:38.163]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:38.163]                     next
[11:02:38.163]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:38.163]                 }
[11:02:38.163]                 NAMES <- toupper(added)
[11:02:38.163]                 for (kk in seq_along(NAMES)) {
[11:02:38.163]                   name <- added[[kk]]
[11:02:38.163]                   NAME <- NAMES[[kk]]
[11:02:38.163]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:38.163]                     next
[11:02:38.163]                   args[[name]] <- ""
[11:02:38.163]                 }
[11:02:38.163]                 NAMES <- toupper(removed)
[11:02:38.163]                 for (kk in seq_along(NAMES)) {
[11:02:38.163]                   name <- removed[[kk]]
[11:02:38.163]                   NAME <- NAMES[[kk]]
[11:02:38.163]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:38.163]                     next
[11:02:38.163]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:38.163]                 }
[11:02:38.163]                 if (length(args) > 0) 
[11:02:38.163]                   base::do.call(base::Sys.setenv, args = args)
[11:02:38.163]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:38.163]             }
[11:02:38.163]             else {
[11:02:38.163]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:38.163]             }
[11:02:38.163]             {
[11:02:38.163]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:38.163]                   0L) {
[11:02:38.163]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:38.163]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:38.163]                   base::options(opts)
[11:02:38.163]                 }
[11:02:38.163]                 {
[11:02:38.163]                   {
[11:02:38.163]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:38.163]                     NULL
[11:02:38.163]                   }
[11:02:38.163]                   options(future.plan = NULL)
[11:02:38.163]                   if (is.na(NA_character_)) 
[11:02:38.163]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:38.163]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:38.163]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:38.163]                     .init = FALSE)
[11:02:38.163]                 }
[11:02:38.163]             }
[11:02:38.163]         }
[11:02:38.163]     })
[11:02:38.163]     if (TRUE) {
[11:02:38.163]         base::sink(type = "output", split = FALSE)
[11:02:38.163]         if (TRUE) {
[11:02:38.163]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:38.163]         }
[11:02:38.163]         else {
[11:02:38.163]             ...future.result["stdout"] <- base::list(NULL)
[11:02:38.163]         }
[11:02:38.163]         base::close(...future.stdout)
[11:02:38.163]         ...future.stdout <- NULL
[11:02:38.163]     }
[11:02:38.163]     ...future.result$conditions <- ...future.conditions
[11:02:38.163]     ...future.result$finished <- base::Sys.time()
[11:02:38.163]     ...future.result
[11:02:38.163] }
[11:02:38.166] requestCore(): workers = 2
[11:02:38.168] MulticoreFuture started
[11:02:38.169] - Launch lazy future ... done
[11:02:38.169] plan(): Setting new future strategy stack:
[11:02:38.169] run() for ‘MulticoreFuture’ ... done
[11:02:38.170] getGlobalsAndPackages() ...
[11:02:38.170] Searching for globals...
[11:02:38.169] List of future strategies:
[11:02:38.169] 1. sequential:
[11:02:38.169]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:38.169]    - tweaked: FALSE
[11:02:38.169]    - call: NULL
[11:02:38.170] plan(): nbrOfWorkers() = 1
[11:02:38.171] 
[11:02:38.171] Searching for globals ... DONE
[11:02:38.171] - globals: [0] <none>
[11:02:38.171] getGlobalsAndPackages() ... DONE
[11:02:38.172] run() for ‘Future’ ...
[11:02:38.172] - state: ‘created’
[11:02:38.172] plan(): Setting new future strategy stack:
[11:02:38.172] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:02:38.173] List of future strategies:
[11:02:38.173] 1. multicore:
[11:02:38.173]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:38.173]    - tweaked: FALSE
[11:02:38.173]    - call: plan(strategy)
[11:02:38.175] plan(): nbrOfWorkers() = 2
[11:02:38.176] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:38.176] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:02:38.176]   - Field: ‘label’
[11:02:38.176]   - Field: ‘local’
[11:02:38.177]   - Field: ‘owner’
[11:02:38.177]   - Field: ‘envir’
[11:02:38.177]   - Field: ‘workers’
[11:02:38.177]   - Field: ‘packages’
[11:02:38.177]   - Field: ‘gc’
[11:02:38.177]   - Field: ‘job’
[11:02:38.178]   - Field: ‘conditions’
[11:02:38.178]   - Field: ‘expr’
[11:02:38.178]   - Field: ‘uuid’
[11:02:38.178]   - Field: ‘seed’
[11:02:38.178]   - Field: ‘version’
[11:02:38.179]   - Field: ‘result’
[11:02:38.179]   - Field: ‘asynchronous’
[11:02:38.179]   - Field: ‘calls’
[11:02:38.179]   - Field: ‘globals’
[11:02:38.179]   - Field: ‘stdout’
[11:02:38.179]   - Field: ‘earlySignal’
[11:02:38.180]   - Field: ‘lazy’
[11:02:38.180]   - Field: ‘state’
[11:02:38.180] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:02:38.180] - Launch lazy future ...
[11:02:38.181] Packages needed by the future expression (n = 0): <none>
[11:02:38.181] Packages needed by future strategies (n = 0): <none>
[11:02:38.182] {
[11:02:38.182]     {
[11:02:38.182]         {
[11:02:38.182]             ...future.startTime <- base::Sys.time()
[11:02:38.182]             {
[11:02:38.182]                 {
[11:02:38.182]                   {
[11:02:38.182]                     {
[11:02:38.182]                       base::local({
[11:02:38.182]                         has_future <- base::requireNamespace("future", 
[11:02:38.182]                           quietly = TRUE)
[11:02:38.182]                         if (has_future) {
[11:02:38.182]                           ns <- base::getNamespace("future")
[11:02:38.182]                           version <- ns[[".package"]][["version"]]
[11:02:38.182]                           if (is.null(version)) 
[11:02:38.182]                             version <- utils::packageVersion("future")
[11:02:38.182]                         }
[11:02:38.182]                         else {
[11:02:38.182]                           version <- NULL
[11:02:38.182]                         }
[11:02:38.182]                         if (!has_future || version < "1.8.0") {
[11:02:38.182]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:38.182]                             "", base::R.version$version.string), 
[11:02:38.182]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:38.182]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:38.182]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:38.182]                               "release", "version")], collapse = " "), 
[11:02:38.182]                             hostname = base::Sys.info()[["nodename"]])
[11:02:38.182]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:38.182]                             info)
[11:02:38.182]                           info <- base::paste(info, collapse = "; ")
[11:02:38.182]                           if (!has_future) {
[11:02:38.182]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:38.182]                               info)
[11:02:38.182]                           }
[11:02:38.182]                           else {
[11:02:38.182]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:38.182]                               info, version)
[11:02:38.182]                           }
[11:02:38.182]                           base::stop(msg)
[11:02:38.182]                         }
[11:02:38.182]                       })
[11:02:38.182]                     }
[11:02:38.182]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:38.182]                     base::options(mc.cores = 1L)
[11:02:38.182]                   }
[11:02:38.182]                   ...future.strategy.old <- future::plan("list")
[11:02:38.182]                   options(future.plan = NULL)
[11:02:38.182]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:38.182]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:38.182]                 }
[11:02:38.182]                 ...future.workdir <- getwd()
[11:02:38.182]             }
[11:02:38.182]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:38.182]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:38.182]         }
[11:02:38.182]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:38.182]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:38.182]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:38.182]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:38.182]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:38.182]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:38.182]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:38.182]             base::names(...future.oldOptions))
[11:02:38.182]     }
[11:02:38.182]     if (FALSE) {
[11:02:38.182]     }
[11:02:38.182]     else {
[11:02:38.182]         if (TRUE) {
[11:02:38.182]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:38.182]                 open = "w")
[11:02:38.182]         }
[11:02:38.182]         else {
[11:02:38.182]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:38.182]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:38.182]         }
[11:02:38.182]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:38.182]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:38.182]             base::sink(type = "output", split = FALSE)
[11:02:38.182]             base::close(...future.stdout)
[11:02:38.182]         }, add = TRUE)
[11:02:38.182]     }
[11:02:38.182]     ...future.frame <- base::sys.nframe()
[11:02:38.182]     ...future.conditions <- base::list()
[11:02:38.182]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:38.182]     if (FALSE) {
[11:02:38.182]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:38.182]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:38.182]     }
[11:02:38.182]     ...future.result <- base::tryCatch({
[11:02:38.182]         base::withCallingHandlers({
[11:02:38.182]             ...future.value <- base::withVisible(base::local({
[11:02:38.182]                 withCallingHandlers({
[11:02:38.182]                   2
[11:02:38.182]                 }, immediateCondition = function(cond) {
[11:02:38.182]                   save_rds <- function (object, pathname, ...) 
[11:02:38.182]                   {
[11:02:38.182]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:02:38.182]                     if (file_test("-f", pathname_tmp)) {
[11:02:38.182]                       fi_tmp <- file.info(pathname_tmp)
[11:02:38.182]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:02:38.182]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:38.182]                         fi_tmp[["mtime"]])
[11:02:38.182]                     }
[11:02:38.182]                     tryCatch({
[11:02:38.182]                       saveRDS(object, file = pathname_tmp, ...)
[11:02:38.182]                     }, error = function(ex) {
[11:02:38.182]                       msg <- conditionMessage(ex)
[11:02:38.182]                       fi_tmp <- file.info(pathname_tmp)
[11:02:38.182]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:02:38.182]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:38.182]                         fi_tmp[["mtime"]], msg)
[11:02:38.182]                       ex$message <- msg
[11:02:38.182]                       stop(ex)
[11:02:38.182]                     })
[11:02:38.182]                     stopifnot(file_test("-f", pathname_tmp))
[11:02:38.182]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:02:38.182]                     if (!res || file_test("-f", pathname_tmp)) {
[11:02:38.182]                       fi_tmp <- file.info(pathname_tmp)
[11:02:38.182]                       fi <- file.info(pathname)
[11:02:38.182]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:02:38.182]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:38.182]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:02:38.182]                         fi[["size"]], fi[["mtime"]])
[11:02:38.182]                       stop(msg)
[11:02:38.182]                     }
[11:02:38.182]                     invisible(pathname)
[11:02:38.182]                   }
[11:02:38.182]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:02:38.182]                     rootPath = tempdir()) 
[11:02:38.182]                   {
[11:02:38.182]                     obj <- list(time = Sys.time(), condition = cond)
[11:02:38.182]                     file <- tempfile(pattern = class(cond)[1], 
[11:02:38.182]                       tmpdir = path, fileext = ".rds")
[11:02:38.182]                     save_rds(obj, file)
[11:02:38.182]                   }
[11:02:38.182]                   saveImmediateCondition(cond, path = "/tmp/RtmpPVwpFC/.future/immediateConditions")
[11:02:38.182]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:38.182]                   {
[11:02:38.182]                     inherits <- base::inherits
[11:02:38.182]                     invokeRestart <- base::invokeRestart
[11:02:38.182]                     is.null <- base::is.null
[11:02:38.182]                     muffled <- FALSE
[11:02:38.182]                     if (inherits(cond, "message")) {
[11:02:38.182]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:38.182]                       if (muffled) 
[11:02:38.182]                         invokeRestart("muffleMessage")
[11:02:38.182]                     }
[11:02:38.182]                     else if (inherits(cond, "warning")) {
[11:02:38.182]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:38.182]                       if (muffled) 
[11:02:38.182]                         invokeRestart("muffleWarning")
[11:02:38.182]                     }
[11:02:38.182]                     else if (inherits(cond, "condition")) {
[11:02:38.182]                       if (!is.null(pattern)) {
[11:02:38.182]                         computeRestarts <- base::computeRestarts
[11:02:38.182]                         grepl <- base::grepl
[11:02:38.182]                         restarts <- computeRestarts(cond)
[11:02:38.182]                         for (restart in restarts) {
[11:02:38.182]                           name <- restart$name
[11:02:38.182]                           if (is.null(name)) 
[11:02:38.182]                             next
[11:02:38.182]                           if (!grepl(pattern, name)) 
[11:02:38.182]                             next
[11:02:38.182]                           invokeRestart(restart)
[11:02:38.182]                           muffled <- TRUE
[11:02:38.182]                           break
[11:02:38.182]                         }
[11:02:38.182]                       }
[11:02:38.182]                     }
[11:02:38.182]                     invisible(muffled)
[11:02:38.182]                   }
[11:02:38.182]                   muffleCondition(cond)
[11:02:38.182]                 })
[11:02:38.182]             }))
[11:02:38.182]             future::FutureResult(value = ...future.value$value, 
[11:02:38.182]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:38.182]                   ...future.rng), globalenv = if (FALSE) 
[11:02:38.182]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:38.182]                     ...future.globalenv.names))
[11:02:38.182]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:38.182]         }, condition = base::local({
[11:02:38.182]             c <- base::c
[11:02:38.182]             inherits <- base::inherits
[11:02:38.182]             invokeRestart <- base::invokeRestart
[11:02:38.182]             length <- base::length
[11:02:38.182]             list <- base::list
[11:02:38.182]             seq.int <- base::seq.int
[11:02:38.182]             signalCondition <- base::signalCondition
[11:02:38.182]             sys.calls <- base::sys.calls
[11:02:38.182]             `[[` <- base::`[[`
[11:02:38.182]             `+` <- base::`+`
[11:02:38.182]             `<<-` <- base::`<<-`
[11:02:38.182]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:38.182]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:38.182]                   3L)]
[11:02:38.182]             }
[11:02:38.182]             function(cond) {
[11:02:38.182]                 is_error <- inherits(cond, "error")
[11:02:38.182]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:38.182]                   NULL)
[11:02:38.182]                 if (is_error) {
[11:02:38.182]                   sessionInformation <- function() {
[11:02:38.182]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:38.182]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:38.182]                       search = base::search(), system = base::Sys.info())
[11:02:38.182]                   }
[11:02:38.182]                   ...future.conditions[[length(...future.conditions) + 
[11:02:38.182]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:38.182]                     cond$call), session = sessionInformation(), 
[11:02:38.182]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:38.182]                   signalCondition(cond)
[11:02:38.182]                 }
[11:02:38.182]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:38.182]                 "immediateCondition"))) {
[11:02:38.182]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:38.182]                   ...future.conditions[[length(...future.conditions) + 
[11:02:38.182]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:38.182]                   if (TRUE && !signal) {
[11:02:38.182]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:38.182]                     {
[11:02:38.182]                       inherits <- base::inherits
[11:02:38.182]                       invokeRestart <- base::invokeRestart
[11:02:38.182]                       is.null <- base::is.null
[11:02:38.182]                       muffled <- FALSE
[11:02:38.182]                       if (inherits(cond, "message")) {
[11:02:38.182]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:38.182]                         if (muffled) 
[11:02:38.182]                           invokeRestart("muffleMessage")
[11:02:38.182]                       }
[11:02:38.182]                       else if (inherits(cond, "warning")) {
[11:02:38.182]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:38.182]                         if (muffled) 
[11:02:38.182]                           invokeRestart("muffleWarning")
[11:02:38.182]                       }
[11:02:38.182]                       else if (inherits(cond, "condition")) {
[11:02:38.182]                         if (!is.null(pattern)) {
[11:02:38.182]                           computeRestarts <- base::computeRestarts
[11:02:38.182]                           grepl <- base::grepl
[11:02:38.182]                           restarts <- computeRestarts(cond)
[11:02:38.182]                           for (restart in restarts) {
[11:02:38.182]                             name <- restart$name
[11:02:38.182]                             if (is.null(name)) 
[11:02:38.182]                               next
[11:02:38.182]                             if (!grepl(pattern, name)) 
[11:02:38.182]                               next
[11:02:38.182]                             invokeRestart(restart)
[11:02:38.182]                             muffled <- TRUE
[11:02:38.182]                             break
[11:02:38.182]                           }
[11:02:38.182]                         }
[11:02:38.182]                       }
[11:02:38.182]                       invisible(muffled)
[11:02:38.182]                     }
[11:02:38.182]                     muffleCondition(cond, pattern = "^muffle")
[11:02:38.182]                   }
[11:02:38.182]                 }
[11:02:38.182]                 else {
[11:02:38.182]                   if (TRUE) {
[11:02:38.182]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:38.182]                     {
[11:02:38.182]                       inherits <- base::inherits
[11:02:38.182]                       invokeRestart <- base::invokeRestart
[11:02:38.182]                       is.null <- base::is.null
[11:02:38.182]                       muffled <- FALSE
[11:02:38.182]                       if (inherits(cond, "message")) {
[11:02:38.182]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:38.182]                         if (muffled) 
[11:02:38.182]                           invokeRestart("muffleMessage")
[11:02:38.182]                       }
[11:02:38.182]                       else if (inherits(cond, "warning")) {
[11:02:38.182]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:38.182]                         if (muffled) 
[11:02:38.182]                           invokeRestart("muffleWarning")
[11:02:38.182]                       }
[11:02:38.182]                       else if (inherits(cond, "condition")) {
[11:02:38.182]                         if (!is.null(pattern)) {
[11:02:38.182]                           computeRestarts <- base::computeRestarts
[11:02:38.182]                           grepl <- base::grepl
[11:02:38.182]                           restarts <- computeRestarts(cond)
[11:02:38.182]                           for (restart in restarts) {
[11:02:38.182]                             name <- restart$name
[11:02:38.182]                             if (is.null(name)) 
[11:02:38.182]                               next
[11:02:38.182]                             if (!grepl(pattern, name)) 
[11:02:38.182]                               next
[11:02:38.182]                             invokeRestart(restart)
[11:02:38.182]                             muffled <- TRUE
[11:02:38.182]                             break
[11:02:38.182]                           }
[11:02:38.182]                         }
[11:02:38.182]                       }
[11:02:38.182]                       invisible(muffled)
[11:02:38.182]                     }
[11:02:38.182]                     muffleCondition(cond, pattern = "^muffle")
[11:02:38.182]                   }
[11:02:38.182]                 }
[11:02:38.182]             }
[11:02:38.182]         }))
[11:02:38.182]     }, error = function(ex) {
[11:02:38.182]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:38.182]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:38.182]                 ...future.rng), started = ...future.startTime, 
[11:02:38.182]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:38.182]             version = "1.8"), class = "FutureResult")
[11:02:38.182]     }, finally = {
[11:02:38.182]         if (!identical(...future.workdir, getwd())) 
[11:02:38.182]             setwd(...future.workdir)
[11:02:38.182]         {
[11:02:38.182]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:38.182]                 ...future.oldOptions$nwarnings <- NULL
[11:02:38.182]             }
[11:02:38.182]             base::options(...future.oldOptions)
[11:02:38.182]             if (.Platform$OS.type == "windows") {
[11:02:38.182]                 old_names <- names(...future.oldEnvVars)
[11:02:38.182]                 envs <- base::Sys.getenv()
[11:02:38.182]                 names <- names(envs)
[11:02:38.182]                 common <- intersect(names, old_names)
[11:02:38.182]                 added <- setdiff(names, old_names)
[11:02:38.182]                 removed <- setdiff(old_names, names)
[11:02:38.182]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:38.182]                   envs[common]]
[11:02:38.182]                 NAMES <- toupper(changed)
[11:02:38.182]                 args <- list()
[11:02:38.182]                 for (kk in seq_along(NAMES)) {
[11:02:38.182]                   name <- changed[[kk]]
[11:02:38.182]                   NAME <- NAMES[[kk]]
[11:02:38.182]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:38.182]                     next
[11:02:38.182]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:38.182]                 }
[11:02:38.182]                 NAMES <- toupper(added)
[11:02:38.182]                 for (kk in seq_along(NAMES)) {
[11:02:38.182]                   name <- added[[kk]]
[11:02:38.182]                   NAME <- NAMES[[kk]]
[11:02:38.182]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:38.182]                     next
[11:02:38.182]                   args[[name]] <- ""
[11:02:38.182]                 }
[11:02:38.182]                 NAMES <- toupper(removed)
[11:02:38.182]                 for (kk in seq_along(NAMES)) {
[11:02:38.182]                   name <- removed[[kk]]
[11:02:38.182]                   NAME <- NAMES[[kk]]
[11:02:38.182]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:38.182]                     next
[11:02:38.182]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:38.182]                 }
[11:02:38.182]                 if (length(args) > 0) 
[11:02:38.182]                   base::do.call(base::Sys.setenv, args = args)
[11:02:38.182]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:38.182]             }
[11:02:38.182]             else {
[11:02:38.182]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:38.182]             }
[11:02:38.182]             {
[11:02:38.182]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:38.182]                   0L) {
[11:02:38.182]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:38.182]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:38.182]                   base::options(opts)
[11:02:38.182]                 }
[11:02:38.182]                 {
[11:02:38.182]                   {
[11:02:38.182]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:38.182]                     NULL
[11:02:38.182]                   }
[11:02:38.182]                   options(future.plan = NULL)
[11:02:38.182]                   if (is.na(NA_character_)) 
[11:02:38.182]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:38.182]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:38.182]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:38.182]                     .init = FALSE)
[11:02:38.182]                 }
[11:02:38.182]             }
[11:02:38.182]         }
[11:02:38.182]     })
[11:02:38.182]     if (TRUE) {
[11:02:38.182]         base::sink(type = "output", split = FALSE)
[11:02:38.182]         if (TRUE) {
[11:02:38.182]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:38.182]         }
[11:02:38.182]         else {
[11:02:38.182]             ...future.result["stdout"] <- base::list(NULL)
[11:02:38.182]         }
[11:02:38.182]         base::close(...future.stdout)
[11:02:38.182]         ...future.stdout <- NULL
[11:02:38.182]     }
[11:02:38.182]     ...future.result$conditions <- ...future.conditions
[11:02:38.182]     ...future.result$finished <- base::Sys.time()
[11:02:38.182]     ...future.result
[11:02:38.182] }
[11:02:38.186] requestCore(): workers = 2
[11:02:38.193] MulticoreFuture started
[11:02:38.193] - Launch lazy future ... done
[11:02:38.194] run() for ‘MulticoreFuture’ ... done
[11:02:38.194] plan(): Setting new future strategy stack:
[11:02:38.194] resolve() on list ...
[11:02:38.194]  recursive: 0
[11:02:38.194]  length: 3
[11:02:38.195]  elements: ‘a’, ‘b’, ‘’
[11:02:38.194] List of future strategies:
[11:02:38.194] 1. sequential:
[11:02:38.194]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:38.194]    - tweaked: FALSE
[11:02:38.194]    - call: NULL
[11:02:38.195] plan(): nbrOfWorkers() = 1
[11:02:38.197] Future #1
[11:02:38.197] plan(): Setting new future strategy stack:
[11:02:38.197]  length: 2 (resolved future 1)
[11:02:38.197] List of future strategies:
[11:02:38.197] 1. multicore:
[11:02:38.197]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:38.197]    - tweaked: FALSE
[11:02:38.197]    - call: plan(strategy)
[11:02:38.200] plan(): nbrOfWorkers() = 2
[11:02:38.201] Future #2
[11:02:38.201]  length: 1 (resolved future 2)
[11:02:38.201]  length: 0 (resolved future 3)
[11:02:38.201] resolve() on list ... DONE
[11:02:38.202] getGlobalsAndPackages() ...
[11:02:38.202] Searching for globals...
[11:02:38.203] 
[11:02:38.203] Searching for globals ... DONE
[11:02:38.204] - globals: [0] <none>
[11:02:38.204] getGlobalsAndPackages() ... DONE
[11:02:38.204] getGlobalsAndPackages() ...
[11:02:38.204] Searching for globals...
[11:02:38.205] 
[11:02:38.205] Searching for globals ... DONE
[11:02:38.205] - globals: [0] <none>
[11:02:38.205] getGlobalsAndPackages() ... DONE
[11:02:38.206] run() for ‘Future’ ...
[11:02:38.206] - state: ‘created’
[11:02:38.206] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:02:38.209] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:38.209] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:02:38.210]   - Field: ‘label’
[11:02:38.210]   - Field: ‘local’
[11:02:38.210]   - Field: ‘owner’
[11:02:38.210]   - Field: ‘envir’
[11:02:38.210]   - Field: ‘workers’
[11:02:38.210]   - Field: ‘packages’
[11:02:38.211]   - Field: ‘gc’
[11:02:38.211]   - Field: ‘job’
[11:02:38.211]   - Field: ‘conditions’
[11:02:38.211]   - Field: ‘expr’
[11:02:38.211]   - Field: ‘uuid’
[11:02:38.211]   - Field: ‘seed’
[11:02:38.212]   - Field: ‘version’
[11:02:38.212]   - Field: ‘result’
[11:02:38.212]   - Field: ‘asynchronous’
[11:02:38.212]   - Field: ‘calls’
[11:02:38.212]   - Field: ‘globals’
[11:02:38.212]   - Field: ‘stdout’
[11:02:38.213]   - Field: ‘earlySignal’
[11:02:38.213]   - Field: ‘lazy’
[11:02:38.213]   - Field: ‘state’
[11:02:38.213] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:02:38.219] - Launch lazy future ...
[11:02:38.220] Packages needed by the future expression (n = 0): <none>
[11:02:38.220] Packages needed by future strategies (n = 0): <none>
[11:02:38.222] {
[11:02:38.222]     {
[11:02:38.222]         {
[11:02:38.222]             ...future.startTime <- base::Sys.time()
[11:02:38.222]             {
[11:02:38.222]                 {
[11:02:38.222]                   {
[11:02:38.222]                     {
[11:02:38.222]                       base::local({
[11:02:38.222]                         has_future <- base::requireNamespace("future", 
[11:02:38.222]                           quietly = TRUE)
[11:02:38.222]                         if (has_future) {
[11:02:38.222]                           ns <- base::getNamespace("future")
[11:02:38.222]                           version <- ns[[".package"]][["version"]]
[11:02:38.222]                           if (is.null(version)) 
[11:02:38.222]                             version <- utils::packageVersion("future")
[11:02:38.222]                         }
[11:02:38.222]                         else {
[11:02:38.222]                           version <- NULL
[11:02:38.222]                         }
[11:02:38.222]                         if (!has_future || version < "1.8.0") {
[11:02:38.222]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:38.222]                             "", base::R.version$version.string), 
[11:02:38.222]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:38.222]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:38.222]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:38.222]                               "release", "version")], collapse = " "), 
[11:02:38.222]                             hostname = base::Sys.info()[["nodename"]])
[11:02:38.222]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:38.222]                             info)
[11:02:38.222]                           info <- base::paste(info, collapse = "; ")
[11:02:38.222]                           if (!has_future) {
[11:02:38.222]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:38.222]                               info)
[11:02:38.222]                           }
[11:02:38.222]                           else {
[11:02:38.222]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:38.222]                               info, version)
[11:02:38.222]                           }
[11:02:38.222]                           base::stop(msg)
[11:02:38.222]                         }
[11:02:38.222]                       })
[11:02:38.222]                     }
[11:02:38.222]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:38.222]                     base::options(mc.cores = 1L)
[11:02:38.222]                   }
[11:02:38.222]                   ...future.strategy.old <- future::plan("list")
[11:02:38.222]                   options(future.plan = NULL)
[11:02:38.222]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:38.222]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:38.222]                 }
[11:02:38.222]                 ...future.workdir <- getwd()
[11:02:38.222]             }
[11:02:38.222]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:38.222]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:38.222]         }
[11:02:38.222]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:38.222]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:38.222]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:38.222]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:38.222]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:38.222]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:38.222]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:38.222]             base::names(...future.oldOptions))
[11:02:38.222]     }
[11:02:38.222]     if (FALSE) {
[11:02:38.222]     }
[11:02:38.222]     else {
[11:02:38.222]         if (TRUE) {
[11:02:38.222]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:38.222]                 open = "w")
[11:02:38.222]         }
[11:02:38.222]         else {
[11:02:38.222]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:38.222]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:38.222]         }
[11:02:38.222]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:38.222]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:38.222]             base::sink(type = "output", split = FALSE)
[11:02:38.222]             base::close(...future.stdout)
[11:02:38.222]         }, add = TRUE)
[11:02:38.222]     }
[11:02:38.222]     ...future.frame <- base::sys.nframe()
[11:02:38.222]     ...future.conditions <- base::list()
[11:02:38.222]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:38.222]     if (FALSE) {
[11:02:38.222]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:38.222]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:38.222]     }
[11:02:38.222]     ...future.result <- base::tryCatch({
[11:02:38.222]         base::withCallingHandlers({
[11:02:38.222]             ...future.value <- base::withVisible(base::local({
[11:02:38.222]                 withCallingHandlers({
[11:02:38.222]                   2
[11:02:38.222]                 }, immediateCondition = function(cond) {
[11:02:38.222]                   save_rds <- function (object, pathname, ...) 
[11:02:38.222]                   {
[11:02:38.222]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:02:38.222]                     if (file_test("-f", pathname_tmp)) {
[11:02:38.222]                       fi_tmp <- file.info(pathname_tmp)
[11:02:38.222]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:02:38.222]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:38.222]                         fi_tmp[["mtime"]])
[11:02:38.222]                     }
[11:02:38.222]                     tryCatch({
[11:02:38.222]                       saveRDS(object, file = pathname_tmp, ...)
[11:02:38.222]                     }, error = function(ex) {
[11:02:38.222]                       msg <- conditionMessage(ex)
[11:02:38.222]                       fi_tmp <- file.info(pathname_tmp)
[11:02:38.222]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:02:38.222]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:38.222]                         fi_tmp[["mtime"]], msg)
[11:02:38.222]                       ex$message <- msg
[11:02:38.222]                       stop(ex)
[11:02:38.222]                     })
[11:02:38.222]                     stopifnot(file_test("-f", pathname_tmp))
[11:02:38.222]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:02:38.222]                     if (!res || file_test("-f", pathname_tmp)) {
[11:02:38.222]                       fi_tmp <- file.info(pathname_tmp)
[11:02:38.222]                       fi <- file.info(pathname)
[11:02:38.222]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:02:38.222]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:38.222]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:02:38.222]                         fi[["size"]], fi[["mtime"]])
[11:02:38.222]                       stop(msg)
[11:02:38.222]                     }
[11:02:38.222]                     invisible(pathname)
[11:02:38.222]                   }
[11:02:38.222]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:02:38.222]                     rootPath = tempdir()) 
[11:02:38.222]                   {
[11:02:38.222]                     obj <- list(time = Sys.time(), condition = cond)
[11:02:38.222]                     file <- tempfile(pattern = class(cond)[1], 
[11:02:38.222]                       tmpdir = path, fileext = ".rds")
[11:02:38.222]                     save_rds(obj, file)
[11:02:38.222]                   }
[11:02:38.222]                   saveImmediateCondition(cond, path = "/tmp/RtmpPVwpFC/.future/immediateConditions")
[11:02:38.222]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:38.222]                   {
[11:02:38.222]                     inherits <- base::inherits
[11:02:38.222]                     invokeRestart <- base::invokeRestart
[11:02:38.222]                     is.null <- base::is.null
[11:02:38.222]                     muffled <- FALSE
[11:02:38.222]                     if (inherits(cond, "message")) {
[11:02:38.222]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:38.222]                       if (muffled) 
[11:02:38.222]                         invokeRestart("muffleMessage")
[11:02:38.222]                     }
[11:02:38.222]                     else if (inherits(cond, "warning")) {
[11:02:38.222]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:38.222]                       if (muffled) 
[11:02:38.222]                         invokeRestart("muffleWarning")
[11:02:38.222]                     }
[11:02:38.222]                     else if (inherits(cond, "condition")) {
[11:02:38.222]                       if (!is.null(pattern)) {
[11:02:38.222]                         computeRestarts <- base::computeRestarts
[11:02:38.222]                         grepl <- base::grepl
[11:02:38.222]                         restarts <- computeRestarts(cond)
[11:02:38.222]                         for (restart in restarts) {
[11:02:38.222]                           name <- restart$name
[11:02:38.222]                           if (is.null(name)) 
[11:02:38.222]                             next
[11:02:38.222]                           if (!grepl(pattern, name)) 
[11:02:38.222]                             next
[11:02:38.222]                           invokeRestart(restart)
[11:02:38.222]                           muffled <- TRUE
[11:02:38.222]                           break
[11:02:38.222]                         }
[11:02:38.222]                       }
[11:02:38.222]                     }
[11:02:38.222]                     invisible(muffled)
[11:02:38.222]                   }
[11:02:38.222]                   muffleCondition(cond)
[11:02:38.222]                 })
[11:02:38.222]             }))
[11:02:38.222]             future::FutureResult(value = ...future.value$value, 
[11:02:38.222]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:38.222]                   ...future.rng), globalenv = if (FALSE) 
[11:02:38.222]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:38.222]                     ...future.globalenv.names))
[11:02:38.222]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:38.222]         }, condition = base::local({
[11:02:38.222]             c <- base::c
[11:02:38.222]             inherits <- base::inherits
[11:02:38.222]             invokeRestart <- base::invokeRestart
[11:02:38.222]             length <- base::length
[11:02:38.222]             list <- base::list
[11:02:38.222]             seq.int <- base::seq.int
[11:02:38.222]             signalCondition <- base::signalCondition
[11:02:38.222]             sys.calls <- base::sys.calls
[11:02:38.222]             `[[` <- base::`[[`
[11:02:38.222]             `+` <- base::`+`
[11:02:38.222]             `<<-` <- base::`<<-`
[11:02:38.222]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:38.222]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:38.222]                   3L)]
[11:02:38.222]             }
[11:02:38.222]             function(cond) {
[11:02:38.222]                 is_error <- inherits(cond, "error")
[11:02:38.222]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:38.222]                   NULL)
[11:02:38.222]                 if (is_error) {
[11:02:38.222]                   sessionInformation <- function() {
[11:02:38.222]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:38.222]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:38.222]                       search = base::search(), system = base::Sys.info())
[11:02:38.222]                   }
[11:02:38.222]                   ...future.conditions[[length(...future.conditions) + 
[11:02:38.222]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:38.222]                     cond$call), session = sessionInformation(), 
[11:02:38.222]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:38.222]                   signalCondition(cond)
[11:02:38.222]                 }
[11:02:38.222]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:38.222]                 "immediateCondition"))) {
[11:02:38.222]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:38.222]                   ...future.conditions[[length(...future.conditions) + 
[11:02:38.222]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:38.222]                   if (TRUE && !signal) {
[11:02:38.222]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:38.222]                     {
[11:02:38.222]                       inherits <- base::inherits
[11:02:38.222]                       invokeRestart <- base::invokeRestart
[11:02:38.222]                       is.null <- base::is.null
[11:02:38.222]                       muffled <- FALSE
[11:02:38.222]                       if (inherits(cond, "message")) {
[11:02:38.222]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:38.222]                         if (muffled) 
[11:02:38.222]                           invokeRestart("muffleMessage")
[11:02:38.222]                       }
[11:02:38.222]                       else if (inherits(cond, "warning")) {
[11:02:38.222]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:38.222]                         if (muffled) 
[11:02:38.222]                           invokeRestart("muffleWarning")
[11:02:38.222]                       }
[11:02:38.222]                       else if (inherits(cond, "condition")) {
[11:02:38.222]                         if (!is.null(pattern)) {
[11:02:38.222]                           computeRestarts <- base::computeRestarts
[11:02:38.222]                           grepl <- base::grepl
[11:02:38.222]                           restarts <- computeRestarts(cond)
[11:02:38.222]                           for (restart in restarts) {
[11:02:38.222]                             name <- restart$name
[11:02:38.222]                             if (is.null(name)) 
[11:02:38.222]                               next
[11:02:38.222]                             if (!grepl(pattern, name)) 
[11:02:38.222]                               next
[11:02:38.222]                             invokeRestart(restart)
[11:02:38.222]                             muffled <- TRUE
[11:02:38.222]                             break
[11:02:38.222]                           }
[11:02:38.222]                         }
[11:02:38.222]                       }
[11:02:38.222]                       invisible(muffled)
[11:02:38.222]                     }
[11:02:38.222]                     muffleCondition(cond, pattern = "^muffle")
[11:02:38.222]                   }
[11:02:38.222]                 }
[11:02:38.222]                 else {
[11:02:38.222]                   if (TRUE) {
[11:02:38.222]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:38.222]                     {
[11:02:38.222]                       inherits <- base::inherits
[11:02:38.222]                       invokeRestart <- base::invokeRestart
[11:02:38.222]                       is.null <- base::is.null
[11:02:38.222]                       muffled <- FALSE
[11:02:38.222]                       if (inherits(cond, "message")) {
[11:02:38.222]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:38.222]                         if (muffled) 
[11:02:38.222]                           invokeRestart("muffleMessage")
[11:02:38.222]                       }
[11:02:38.222]                       else if (inherits(cond, "warning")) {
[11:02:38.222]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:38.222]                         if (muffled) 
[11:02:38.222]                           invokeRestart("muffleWarning")
[11:02:38.222]                       }
[11:02:38.222]                       else if (inherits(cond, "condition")) {
[11:02:38.222]                         if (!is.null(pattern)) {
[11:02:38.222]                           computeRestarts <- base::computeRestarts
[11:02:38.222]                           grepl <- base::grepl
[11:02:38.222]                           restarts <- computeRestarts(cond)
[11:02:38.222]                           for (restart in restarts) {
[11:02:38.222]                             name <- restart$name
[11:02:38.222]                             if (is.null(name)) 
[11:02:38.222]                               next
[11:02:38.222]                             if (!grepl(pattern, name)) 
[11:02:38.222]                               next
[11:02:38.222]                             invokeRestart(restart)
[11:02:38.222]                             muffled <- TRUE
[11:02:38.222]                             break
[11:02:38.222]                           }
[11:02:38.222]                         }
[11:02:38.222]                       }
[11:02:38.222]                       invisible(muffled)
[11:02:38.222]                     }
[11:02:38.222]                     muffleCondition(cond, pattern = "^muffle")
[11:02:38.222]                   }
[11:02:38.222]                 }
[11:02:38.222]             }
[11:02:38.222]         }))
[11:02:38.222]     }, error = function(ex) {
[11:02:38.222]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:38.222]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:38.222]                 ...future.rng), started = ...future.startTime, 
[11:02:38.222]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:38.222]             version = "1.8"), class = "FutureResult")
[11:02:38.222]     }, finally = {
[11:02:38.222]         if (!identical(...future.workdir, getwd())) 
[11:02:38.222]             setwd(...future.workdir)
[11:02:38.222]         {
[11:02:38.222]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:38.222]                 ...future.oldOptions$nwarnings <- NULL
[11:02:38.222]             }
[11:02:38.222]             base::options(...future.oldOptions)
[11:02:38.222]             if (.Platform$OS.type == "windows") {
[11:02:38.222]                 old_names <- names(...future.oldEnvVars)
[11:02:38.222]                 envs <- base::Sys.getenv()
[11:02:38.222]                 names <- names(envs)
[11:02:38.222]                 common <- intersect(names, old_names)
[11:02:38.222]                 added <- setdiff(names, old_names)
[11:02:38.222]                 removed <- setdiff(old_names, names)
[11:02:38.222]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:38.222]                   envs[common]]
[11:02:38.222]                 NAMES <- toupper(changed)
[11:02:38.222]                 args <- list()
[11:02:38.222]                 for (kk in seq_along(NAMES)) {
[11:02:38.222]                   name <- changed[[kk]]
[11:02:38.222]                   NAME <- NAMES[[kk]]
[11:02:38.222]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:38.222]                     next
[11:02:38.222]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:38.222]                 }
[11:02:38.222]                 NAMES <- toupper(added)
[11:02:38.222]                 for (kk in seq_along(NAMES)) {
[11:02:38.222]                   name <- added[[kk]]
[11:02:38.222]                   NAME <- NAMES[[kk]]
[11:02:38.222]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:38.222]                     next
[11:02:38.222]                   args[[name]] <- ""
[11:02:38.222]                 }
[11:02:38.222]                 NAMES <- toupper(removed)
[11:02:38.222]                 for (kk in seq_along(NAMES)) {
[11:02:38.222]                   name <- removed[[kk]]
[11:02:38.222]                   NAME <- NAMES[[kk]]
[11:02:38.222]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:38.222]                     next
[11:02:38.222]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:38.222]                 }
[11:02:38.222]                 if (length(args) > 0) 
[11:02:38.222]                   base::do.call(base::Sys.setenv, args = args)
[11:02:38.222]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:38.222]             }
[11:02:38.222]             else {
[11:02:38.222]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:38.222]             }
[11:02:38.222]             {
[11:02:38.222]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:38.222]                   0L) {
[11:02:38.222]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:38.222]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:38.222]                   base::options(opts)
[11:02:38.222]                 }
[11:02:38.222]                 {
[11:02:38.222]                   {
[11:02:38.222]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:38.222]                     NULL
[11:02:38.222]                   }
[11:02:38.222]                   options(future.plan = NULL)
[11:02:38.222]                   if (is.na(NA_character_)) 
[11:02:38.222]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:38.222]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:38.222]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:38.222]                     .init = FALSE)
[11:02:38.222]                 }
[11:02:38.222]             }
[11:02:38.222]         }
[11:02:38.222]     })
[11:02:38.222]     if (TRUE) {
[11:02:38.222]         base::sink(type = "output", split = FALSE)
[11:02:38.222]         if (TRUE) {
[11:02:38.222]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:38.222]         }
[11:02:38.222]         else {
[11:02:38.222]             ...future.result["stdout"] <- base::list(NULL)
[11:02:38.222]         }
[11:02:38.222]         base::close(...future.stdout)
[11:02:38.222]         ...future.stdout <- NULL
[11:02:38.222]     }
[11:02:38.222]     ...future.result$conditions <- ...future.conditions
[11:02:38.222]     ...future.result$finished <- base::Sys.time()
[11:02:38.222]     ...future.result
[11:02:38.222] }
[11:02:38.224] requestCore(): workers = 2
[11:02:38.225] Poll #1 (0): usedCores() = 2, workers = 2
[11:02:38.236] result() for MulticoreFuture ...
[11:02:38.238] result() for MulticoreFuture ...
[11:02:38.238] result() for MulticoreFuture ... done
[11:02:38.238] result() for MulticoreFuture ... done
[11:02:38.238] result() for MulticoreFuture ...
[11:02:38.238] result() for MulticoreFuture ... done
[11:02:38.241] MulticoreFuture started
[11:02:38.242] - Launch lazy future ... done
[11:02:38.242] run() for ‘MulticoreFuture’ ... done
[11:02:38.242] plan(): Setting new future strategy stack:
[11:02:38.243] resolve() on list ...
[11:02:38.243]  recursive: 0
[11:02:38.243]  length: 3
[11:02:38.243]  elements: ‘a’, ‘b’, ‘’
[11:02:38.244] run() for ‘Future’ ...
[11:02:38.243] List of future strategies:
[11:02:38.243] 1. sequential:
[11:02:38.243]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:38.243]    - tweaked: FALSE
[11:02:38.243]    - call: NULL
[11:02:38.244] - state: ‘created’
[11:02:38.244] plan(): nbrOfWorkers() = 1
[11:02:38.245] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:02:38.248] plan(): Setting new future strategy stack:
[11:02:38.248] List of future strategies:
[11:02:38.248] 1. multicore:
[11:02:38.248]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:38.248]    - tweaked: FALSE
[11:02:38.248]    - call: plan(strategy)
[11:02:38.250] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:38.250] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:02:38.250]   - Field: ‘label’
[11:02:38.251]   - Field: ‘local’
[11:02:38.251]   - Field: ‘owner’
[11:02:38.251]   - Field: ‘envir’
[11:02:38.251]   - Field: ‘workers’
[11:02:38.252]   - Field: ‘packages’
[11:02:38.252] plan(): nbrOfWorkers() = 2
[11:02:38.252]   - Field: ‘gc’
[11:02:38.252]   - Field: ‘job’
[11:02:38.252]   - Field: ‘conditions’
[11:02:38.252]   - Field: ‘expr’
[11:02:38.253]   - Field: ‘uuid’
[11:02:38.253]   - Field: ‘seed’
[11:02:38.253]   - Field: ‘version’
[11:02:38.253]   - Field: ‘result’
[11:02:38.253]   - Field: ‘asynchronous’
[11:02:38.253]   - Field: ‘calls’
[11:02:38.254]   - Field: ‘globals’
[11:02:38.254]   - Field: ‘stdout’
[11:02:38.254]   - Field: ‘earlySignal’
[11:02:38.254]   - Field: ‘lazy’
[11:02:38.254]   - Field: ‘state’
[11:02:38.254] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:02:38.255] - Launch lazy future ...
[11:02:38.255] Packages needed by the future expression (n = 0): <none>
[11:02:38.255] Packages needed by future strategies (n = 0): <none>
[11:02:38.256] {
[11:02:38.256]     {
[11:02:38.256]         {
[11:02:38.256]             ...future.startTime <- base::Sys.time()
[11:02:38.256]             {
[11:02:38.256]                 {
[11:02:38.256]                   {
[11:02:38.256]                     {
[11:02:38.256]                       base::local({
[11:02:38.256]                         has_future <- base::requireNamespace("future", 
[11:02:38.256]                           quietly = TRUE)
[11:02:38.256]                         if (has_future) {
[11:02:38.256]                           ns <- base::getNamespace("future")
[11:02:38.256]                           version <- ns[[".package"]][["version"]]
[11:02:38.256]                           if (is.null(version)) 
[11:02:38.256]                             version <- utils::packageVersion("future")
[11:02:38.256]                         }
[11:02:38.256]                         else {
[11:02:38.256]                           version <- NULL
[11:02:38.256]                         }
[11:02:38.256]                         if (!has_future || version < "1.8.0") {
[11:02:38.256]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:38.256]                             "", base::R.version$version.string), 
[11:02:38.256]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:38.256]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:38.256]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:38.256]                               "release", "version")], collapse = " "), 
[11:02:38.256]                             hostname = base::Sys.info()[["nodename"]])
[11:02:38.256]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:38.256]                             info)
[11:02:38.256]                           info <- base::paste(info, collapse = "; ")
[11:02:38.256]                           if (!has_future) {
[11:02:38.256]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:38.256]                               info)
[11:02:38.256]                           }
[11:02:38.256]                           else {
[11:02:38.256]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:38.256]                               info, version)
[11:02:38.256]                           }
[11:02:38.256]                           base::stop(msg)
[11:02:38.256]                         }
[11:02:38.256]                       })
[11:02:38.256]                     }
[11:02:38.256]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:38.256]                     base::options(mc.cores = 1L)
[11:02:38.256]                   }
[11:02:38.256]                   ...future.strategy.old <- future::plan("list")
[11:02:38.256]                   options(future.plan = NULL)
[11:02:38.256]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:38.256]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:38.256]                 }
[11:02:38.256]                 ...future.workdir <- getwd()
[11:02:38.256]             }
[11:02:38.256]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:38.256]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:38.256]         }
[11:02:38.256]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:38.256]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:38.256]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:38.256]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:38.256]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:38.256]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:38.256]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:38.256]             base::names(...future.oldOptions))
[11:02:38.256]     }
[11:02:38.256]     if (FALSE) {
[11:02:38.256]     }
[11:02:38.256]     else {
[11:02:38.256]         if (TRUE) {
[11:02:38.256]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:38.256]                 open = "w")
[11:02:38.256]         }
[11:02:38.256]         else {
[11:02:38.256]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:38.256]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:38.256]         }
[11:02:38.256]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:38.256]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:38.256]             base::sink(type = "output", split = FALSE)
[11:02:38.256]             base::close(...future.stdout)
[11:02:38.256]         }, add = TRUE)
[11:02:38.256]     }
[11:02:38.256]     ...future.frame <- base::sys.nframe()
[11:02:38.256]     ...future.conditions <- base::list()
[11:02:38.256]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:38.256]     if (FALSE) {
[11:02:38.256]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:38.256]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:38.256]     }
[11:02:38.256]     ...future.result <- base::tryCatch({
[11:02:38.256]         base::withCallingHandlers({
[11:02:38.256]             ...future.value <- base::withVisible(base::local({
[11:02:38.256]                 withCallingHandlers({
[11:02:38.256]                   1
[11:02:38.256]                 }, immediateCondition = function(cond) {
[11:02:38.256]                   save_rds <- function (object, pathname, ...) 
[11:02:38.256]                   {
[11:02:38.256]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:02:38.256]                     if (file_test("-f", pathname_tmp)) {
[11:02:38.256]                       fi_tmp <- file.info(pathname_tmp)
[11:02:38.256]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:02:38.256]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:38.256]                         fi_tmp[["mtime"]])
[11:02:38.256]                     }
[11:02:38.256]                     tryCatch({
[11:02:38.256]                       saveRDS(object, file = pathname_tmp, ...)
[11:02:38.256]                     }, error = function(ex) {
[11:02:38.256]                       msg <- conditionMessage(ex)
[11:02:38.256]                       fi_tmp <- file.info(pathname_tmp)
[11:02:38.256]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:02:38.256]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:38.256]                         fi_tmp[["mtime"]], msg)
[11:02:38.256]                       ex$message <- msg
[11:02:38.256]                       stop(ex)
[11:02:38.256]                     })
[11:02:38.256]                     stopifnot(file_test("-f", pathname_tmp))
[11:02:38.256]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:02:38.256]                     if (!res || file_test("-f", pathname_tmp)) {
[11:02:38.256]                       fi_tmp <- file.info(pathname_tmp)
[11:02:38.256]                       fi <- file.info(pathname)
[11:02:38.256]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:02:38.256]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:38.256]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:02:38.256]                         fi[["size"]], fi[["mtime"]])
[11:02:38.256]                       stop(msg)
[11:02:38.256]                     }
[11:02:38.256]                     invisible(pathname)
[11:02:38.256]                   }
[11:02:38.256]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:02:38.256]                     rootPath = tempdir()) 
[11:02:38.256]                   {
[11:02:38.256]                     obj <- list(time = Sys.time(), condition = cond)
[11:02:38.256]                     file <- tempfile(pattern = class(cond)[1], 
[11:02:38.256]                       tmpdir = path, fileext = ".rds")
[11:02:38.256]                     save_rds(obj, file)
[11:02:38.256]                   }
[11:02:38.256]                   saveImmediateCondition(cond, path = "/tmp/RtmpPVwpFC/.future/immediateConditions")
[11:02:38.256]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:38.256]                   {
[11:02:38.256]                     inherits <- base::inherits
[11:02:38.256]                     invokeRestart <- base::invokeRestart
[11:02:38.256]                     is.null <- base::is.null
[11:02:38.256]                     muffled <- FALSE
[11:02:38.256]                     if (inherits(cond, "message")) {
[11:02:38.256]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:38.256]                       if (muffled) 
[11:02:38.256]                         invokeRestart("muffleMessage")
[11:02:38.256]                     }
[11:02:38.256]                     else if (inherits(cond, "warning")) {
[11:02:38.256]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:38.256]                       if (muffled) 
[11:02:38.256]                         invokeRestart("muffleWarning")
[11:02:38.256]                     }
[11:02:38.256]                     else if (inherits(cond, "condition")) {
[11:02:38.256]                       if (!is.null(pattern)) {
[11:02:38.256]                         computeRestarts <- base::computeRestarts
[11:02:38.256]                         grepl <- base::grepl
[11:02:38.256]                         restarts <- computeRestarts(cond)
[11:02:38.256]                         for (restart in restarts) {
[11:02:38.256]                           name <- restart$name
[11:02:38.256]                           if (is.null(name)) 
[11:02:38.256]                             next
[11:02:38.256]                           if (!grepl(pattern, name)) 
[11:02:38.256]                             next
[11:02:38.256]                           invokeRestart(restart)
[11:02:38.256]                           muffled <- TRUE
[11:02:38.256]                           break
[11:02:38.256]                         }
[11:02:38.256]                       }
[11:02:38.256]                     }
[11:02:38.256]                     invisible(muffled)
[11:02:38.256]                   }
[11:02:38.256]                   muffleCondition(cond)
[11:02:38.256]                 })
[11:02:38.256]             }))
[11:02:38.256]             future::FutureResult(value = ...future.value$value, 
[11:02:38.256]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:38.256]                   ...future.rng), globalenv = if (FALSE) 
[11:02:38.256]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:38.256]                     ...future.globalenv.names))
[11:02:38.256]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:38.256]         }, condition = base::local({
[11:02:38.256]             c <- base::c
[11:02:38.256]             inherits <- base::inherits
[11:02:38.256]             invokeRestart <- base::invokeRestart
[11:02:38.256]             length <- base::length
[11:02:38.256]             list <- base::list
[11:02:38.256]             seq.int <- base::seq.int
[11:02:38.256]             signalCondition <- base::signalCondition
[11:02:38.256]             sys.calls <- base::sys.calls
[11:02:38.256]             `[[` <- base::`[[`
[11:02:38.256]             `+` <- base::`+`
[11:02:38.256]             `<<-` <- base::`<<-`
[11:02:38.256]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:38.256]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:38.256]                   3L)]
[11:02:38.256]             }
[11:02:38.256]             function(cond) {
[11:02:38.256]                 is_error <- inherits(cond, "error")
[11:02:38.256]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:38.256]                   NULL)
[11:02:38.256]                 if (is_error) {
[11:02:38.256]                   sessionInformation <- function() {
[11:02:38.256]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:38.256]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:38.256]                       search = base::search(), system = base::Sys.info())
[11:02:38.256]                   }
[11:02:38.256]                   ...future.conditions[[length(...future.conditions) + 
[11:02:38.256]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:38.256]                     cond$call), session = sessionInformation(), 
[11:02:38.256]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:38.256]                   signalCondition(cond)
[11:02:38.256]                 }
[11:02:38.256]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:38.256]                 "immediateCondition"))) {
[11:02:38.256]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:38.256]                   ...future.conditions[[length(...future.conditions) + 
[11:02:38.256]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:38.256]                   if (TRUE && !signal) {
[11:02:38.256]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:38.256]                     {
[11:02:38.256]                       inherits <- base::inherits
[11:02:38.256]                       invokeRestart <- base::invokeRestart
[11:02:38.256]                       is.null <- base::is.null
[11:02:38.256]                       muffled <- FALSE
[11:02:38.256]                       if (inherits(cond, "message")) {
[11:02:38.256]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:38.256]                         if (muffled) 
[11:02:38.256]                           invokeRestart("muffleMessage")
[11:02:38.256]                       }
[11:02:38.256]                       else if (inherits(cond, "warning")) {
[11:02:38.256]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:38.256]                         if (muffled) 
[11:02:38.256]                           invokeRestart("muffleWarning")
[11:02:38.256]                       }
[11:02:38.256]                       else if (inherits(cond, "condition")) {
[11:02:38.256]                         if (!is.null(pattern)) {
[11:02:38.256]                           computeRestarts <- base::computeRestarts
[11:02:38.256]                           grepl <- base::grepl
[11:02:38.256]                           restarts <- computeRestarts(cond)
[11:02:38.256]                           for (restart in restarts) {
[11:02:38.256]                             name <- restart$name
[11:02:38.256]                             if (is.null(name)) 
[11:02:38.256]                               next
[11:02:38.256]                             if (!grepl(pattern, name)) 
[11:02:38.256]                               next
[11:02:38.256]                             invokeRestart(restart)
[11:02:38.256]                             muffled <- TRUE
[11:02:38.256]                             break
[11:02:38.256]                           }
[11:02:38.256]                         }
[11:02:38.256]                       }
[11:02:38.256]                       invisible(muffled)
[11:02:38.256]                     }
[11:02:38.256]                     muffleCondition(cond, pattern = "^muffle")
[11:02:38.256]                   }
[11:02:38.256]                 }
[11:02:38.256]                 else {
[11:02:38.256]                   if (TRUE) {
[11:02:38.256]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:38.256]                     {
[11:02:38.256]                       inherits <- base::inherits
[11:02:38.256]                       invokeRestart <- base::invokeRestart
[11:02:38.256]                       is.null <- base::is.null
[11:02:38.256]                       muffled <- FALSE
[11:02:38.256]                       if (inherits(cond, "message")) {
[11:02:38.256]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:38.256]                         if (muffled) 
[11:02:38.256]                           invokeRestart("muffleMessage")
[11:02:38.256]                       }
[11:02:38.256]                       else if (inherits(cond, "warning")) {
[11:02:38.256]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:38.256]                         if (muffled) 
[11:02:38.256]                           invokeRestart("muffleWarning")
[11:02:38.256]                       }
[11:02:38.256]                       else if (inherits(cond, "condition")) {
[11:02:38.256]                         if (!is.null(pattern)) {
[11:02:38.256]                           computeRestarts <- base::computeRestarts
[11:02:38.256]                           grepl <- base::grepl
[11:02:38.256]                           restarts <- computeRestarts(cond)
[11:02:38.256]                           for (restart in restarts) {
[11:02:38.256]                             name <- restart$name
[11:02:38.256]                             if (is.null(name)) 
[11:02:38.256]                               next
[11:02:38.256]                             if (!grepl(pattern, name)) 
[11:02:38.256]                               next
[11:02:38.256]                             invokeRestart(restart)
[11:02:38.256]                             muffled <- TRUE
[11:02:38.256]                             break
[11:02:38.256]                           }
[11:02:38.256]                         }
[11:02:38.256]                       }
[11:02:38.256]                       invisible(muffled)
[11:02:38.256]                     }
[11:02:38.256]                     muffleCondition(cond, pattern = "^muffle")
[11:02:38.256]                   }
[11:02:38.256]                 }
[11:02:38.256]             }
[11:02:38.256]         }))
[11:02:38.256]     }, error = function(ex) {
[11:02:38.256]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:38.256]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:38.256]                 ...future.rng), started = ...future.startTime, 
[11:02:38.256]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:38.256]             version = "1.8"), class = "FutureResult")
[11:02:38.256]     }, finally = {
[11:02:38.256]         if (!identical(...future.workdir, getwd())) 
[11:02:38.256]             setwd(...future.workdir)
[11:02:38.256]         {
[11:02:38.256]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:38.256]                 ...future.oldOptions$nwarnings <- NULL
[11:02:38.256]             }
[11:02:38.256]             base::options(...future.oldOptions)
[11:02:38.256]             if (.Platform$OS.type == "windows") {
[11:02:38.256]                 old_names <- names(...future.oldEnvVars)
[11:02:38.256]                 envs <- base::Sys.getenv()
[11:02:38.256]                 names <- names(envs)
[11:02:38.256]                 common <- intersect(names, old_names)
[11:02:38.256]                 added <- setdiff(names, old_names)
[11:02:38.256]                 removed <- setdiff(old_names, names)
[11:02:38.256]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:38.256]                   envs[common]]
[11:02:38.256]                 NAMES <- toupper(changed)
[11:02:38.256]                 args <- list()
[11:02:38.256]                 for (kk in seq_along(NAMES)) {
[11:02:38.256]                   name <- changed[[kk]]
[11:02:38.256]                   NAME <- NAMES[[kk]]
[11:02:38.256]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:38.256]                     next
[11:02:38.256]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:38.256]                 }
[11:02:38.256]                 NAMES <- toupper(added)
[11:02:38.256]                 for (kk in seq_along(NAMES)) {
[11:02:38.256]                   name <- added[[kk]]
[11:02:38.256]                   NAME <- NAMES[[kk]]
[11:02:38.256]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:38.256]                     next
[11:02:38.256]                   args[[name]] <- ""
[11:02:38.256]                 }
[11:02:38.256]                 NAMES <- toupper(removed)
[11:02:38.256]                 for (kk in seq_along(NAMES)) {
[11:02:38.256]                   name <- removed[[kk]]
[11:02:38.256]                   NAME <- NAMES[[kk]]
[11:02:38.256]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:38.256]                     next
[11:02:38.256]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:38.256]                 }
[11:02:38.256]                 if (length(args) > 0) 
[11:02:38.256]                   base::do.call(base::Sys.setenv, args = args)
[11:02:38.256]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:38.256]             }
[11:02:38.256]             else {
[11:02:38.256]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:38.256]             }
[11:02:38.256]             {
[11:02:38.256]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:38.256]                   0L) {
[11:02:38.256]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:38.256]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:38.256]                   base::options(opts)
[11:02:38.256]                 }
[11:02:38.256]                 {
[11:02:38.256]                   {
[11:02:38.256]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:38.256]                     NULL
[11:02:38.256]                   }
[11:02:38.256]                   options(future.plan = NULL)
[11:02:38.256]                   if (is.na(NA_character_)) 
[11:02:38.256]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:38.256]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:38.256]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:38.256]                     .init = FALSE)
[11:02:38.256]                 }
[11:02:38.256]             }
[11:02:38.256]         }
[11:02:38.256]     })
[11:02:38.256]     if (TRUE) {
[11:02:38.256]         base::sink(type = "output", split = FALSE)
[11:02:38.256]         if (TRUE) {
[11:02:38.256]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:38.256]         }
[11:02:38.256]         else {
[11:02:38.256]             ...future.result["stdout"] <- base::list(NULL)
[11:02:38.256]         }
[11:02:38.256]         base::close(...future.stdout)
[11:02:38.256]         ...future.stdout <- NULL
[11:02:38.256]     }
[11:02:38.256]     ...future.result$conditions <- ...future.conditions
[11:02:38.256]     ...future.result$finished <- base::Sys.time()
[11:02:38.256]     ...future.result
[11:02:38.256] }
[11:02:38.259] requestCore(): workers = 2
[11:02:38.259] Poll #1 (0): usedCores() = 2, workers = 2
[11:02:38.283] result() for MulticoreFuture ...
[11:02:38.283] result() for MulticoreFuture ...
[11:02:38.284] result() for MulticoreFuture ... done
[11:02:38.284] result() for MulticoreFuture ... done
[11:02:38.284] result() for MulticoreFuture ...
[11:02:38.284] result() for MulticoreFuture ... done
[11:02:38.286] MulticoreFuture started
[11:02:38.287] - Launch lazy future ... done
[11:02:38.287] run() for ‘MulticoreFuture’ ... done
[11:02:38.287] plan(): Setting new future strategy stack:
[11:02:38.288] List of future strategies:
[11:02:38.288] 1. sequential:
[11:02:38.288]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:38.288]    - tweaked: FALSE
[11:02:38.288]    - call: NULL
[11:02:38.289] plan(): nbrOfWorkers() = 1
[11:02:38.291] plan(): Setting new future strategy stack:
[11:02:38.291] List of future strategies:
[11:02:38.291] 1. multicore:
[11:02:38.291]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:38.291]    - tweaked: FALSE
[11:02:38.291]    - call: plan(strategy)
[11:02:38.294] plan(): nbrOfWorkers() = 2
[11:02:38.295] Future #1
[11:02:38.295]  length: 2 (resolved future 1)
[11:02:38.295] Future #2
[11:02:38.295]  length: 1 (resolved future 2)
[11:02:38.295]  length: 0 (resolved future 3)
[11:02:38.296] resolve() on list ... DONE
[11:02:38.296] getGlobalsAndPackages() ...
[11:02:38.296] Searching for globals...
[11:02:38.297] 
[11:02:38.297] Searching for globals ... DONE
[11:02:38.297] - globals: [0] <none>
[11:02:38.297] getGlobalsAndPackages() ... DONE
[11:02:38.298] getGlobalsAndPackages() ...
[11:02:38.298] Searching for globals...
[11:02:38.298] 
[11:02:38.299] Searching for globals ... DONE
[11:02:38.299] - globals: [0] <none>
[11:02:38.299] getGlobalsAndPackages() ... DONE
[11:02:38.299] resolve() on list ...
[11:02:38.299]  recursive: 0
[11:02:38.299]  length: 3
[11:02:38.300]  elements: ‘a’, ‘b’, ‘’
[11:02:38.300] run() for ‘Future’ ...
[11:02:38.300] - state: ‘created’
[11:02:38.300] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:02:38.308] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:38.309] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:02:38.309]   - Field: ‘label’
[11:02:38.309]   - Field: ‘local’
[11:02:38.309]   - Field: ‘owner’
[11:02:38.310]   - Field: ‘envir’
[11:02:38.310]   - Field: ‘workers’
[11:02:38.310]   - Field: ‘packages’
[11:02:38.310]   - Field: ‘gc’
[11:02:38.310]   - Field: ‘job’
[11:02:38.311]   - Field: ‘conditions’
[11:02:38.311]   - Field: ‘expr’
[11:02:38.311]   - Field: ‘uuid’
[11:02:38.311]   - Field: ‘seed’
[11:02:38.311]   - Field: ‘version’
[11:02:38.311]   - Field: ‘result’
[11:02:38.311]   - Field: ‘asynchronous’
[11:02:38.312]   - Field: ‘calls’
[11:02:38.312]   - Field: ‘globals’
[11:02:38.312]   - Field: ‘stdout’
[11:02:38.312]   - Field: ‘earlySignal’
[11:02:38.312]   - Field: ‘lazy’
[11:02:38.313]   - Field: ‘state’
[11:02:38.313] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:02:38.313] - Launch lazy future ...
[11:02:38.313] Packages needed by the future expression (n = 0): <none>
[11:02:38.313] Packages needed by future strategies (n = 0): <none>
[11:02:38.314] {
[11:02:38.314]     {
[11:02:38.314]         {
[11:02:38.314]             ...future.startTime <- base::Sys.time()
[11:02:38.314]             {
[11:02:38.314]                 {
[11:02:38.314]                   {
[11:02:38.314]                     {
[11:02:38.314]                       base::local({
[11:02:38.314]                         has_future <- base::requireNamespace("future", 
[11:02:38.314]                           quietly = TRUE)
[11:02:38.314]                         if (has_future) {
[11:02:38.314]                           ns <- base::getNamespace("future")
[11:02:38.314]                           version <- ns[[".package"]][["version"]]
[11:02:38.314]                           if (is.null(version)) 
[11:02:38.314]                             version <- utils::packageVersion("future")
[11:02:38.314]                         }
[11:02:38.314]                         else {
[11:02:38.314]                           version <- NULL
[11:02:38.314]                         }
[11:02:38.314]                         if (!has_future || version < "1.8.0") {
[11:02:38.314]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:38.314]                             "", base::R.version$version.string), 
[11:02:38.314]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:38.314]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:38.314]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:38.314]                               "release", "version")], collapse = " "), 
[11:02:38.314]                             hostname = base::Sys.info()[["nodename"]])
[11:02:38.314]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:38.314]                             info)
[11:02:38.314]                           info <- base::paste(info, collapse = "; ")
[11:02:38.314]                           if (!has_future) {
[11:02:38.314]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:38.314]                               info)
[11:02:38.314]                           }
[11:02:38.314]                           else {
[11:02:38.314]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:38.314]                               info, version)
[11:02:38.314]                           }
[11:02:38.314]                           base::stop(msg)
[11:02:38.314]                         }
[11:02:38.314]                       })
[11:02:38.314]                     }
[11:02:38.314]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:38.314]                     base::options(mc.cores = 1L)
[11:02:38.314]                   }
[11:02:38.314]                   ...future.strategy.old <- future::plan("list")
[11:02:38.314]                   options(future.plan = NULL)
[11:02:38.314]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:38.314]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:38.314]                 }
[11:02:38.314]                 ...future.workdir <- getwd()
[11:02:38.314]             }
[11:02:38.314]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:38.314]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:38.314]         }
[11:02:38.314]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:38.314]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:38.314]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:38.314]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:38.314]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:38.314]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:38.314]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:38.314]             base::names(...future.oldOptions))
[11:02:38.314]     }
[11:02:38.314]     if (FALSE) {
[11:02:38.314]     }
[11:02:38.314]     else {
[11:02:38.314]         if (TRUE) {
[11:02:38.314]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:38.314]                 open = "w")
[11:02:38.314]         }
[11:02:38.314]         else {
[11:02:38.314]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:38.314]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:38.314]         }
[11:02:38.314]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:38.314]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:38.314]             base::sink(type = "output", split = FALSE)
[11:02:38.314]             base::close(...future.stdout)
[11:02:38.314]         }, add = TRUE)
[11:02:38.314]     }
[11:02:38.314]     ...future.frame <- base::sys.nframe()
[11:02:38.314]     ...future.conditions <- base::list()
[11:02:38.314]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:38.314]     if (FALSE) {
[11:02:38.314]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:38.314]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:38.314]     }
[11:02:38.314]     ...future.result <- base::tryCatch({
[11:02:38.314]         base::withCallingHandlers({
[11:02:38.314]             ...future.value <- base::withVisible(base::local({
[11:02:38.314]                 withCallingHandlers({
[11:02:38.314]                   1
[11:02:38.314]                 }, immediateCondition = function(cond) {
[11:02:38.314]                   save_rds <- function (object, pathname, ...) 
[11:02:38.314]                   {
[11:02:38.314]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:02:38.314]                     if (file_test("-f", pathname_tmp)) {
[11:02:38.314]                       fi_tmp <- file.info(pathname_tmp)
[11:02:38.314]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:02:38.314]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:38.314]                         fi_tmp[["mtime"]])
[11:02:38.314]                     }
[11:02:38.314]                     tryCatch({
[11:02:38.314]                       saveRDS(object, file = pathname_tmp, ...)
[11:02:38.314]                     }, error = function(ex) {
[11:02:38.314]                       msg <- conditionMessage(ex)
[11:02:38.314]                       fi_tmp <- file.info(pathname_tmp)
[11:02:38.314]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:02:38.314]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:38.314]                         fi_tmp[["mtime"]], msg)
[11:02:38.314]                       ex$message <- msg
[11:02:38.314]                       stop(ex)
[11:02:38.314]                     })
[11:02:38.314]                     stopifnot(file_test("-f", pathname_tmp))
[11:02:38.314]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:02:38.314]                     if (!res || file_test("-f", pathname_tmp)) {
[11:02:38.314]                       fi_tmp <- file.info(pathname_tmp)
[11:02:38.314]                       fi <- file.info(pathname)
[11:02:38.314]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:02:38.314]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:38.314]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:02:38.314]                         fi[["size"]], fi[["mtime"]])
[11:02:38.314]                       stop(msg)
[11:02:38.314]                     }
[11:02:38.314]                     invisible(pathname)
[11:02:38.314]                   }
[11:02:38.314]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:02:38.314]                     rootPath = tempdir()) 
[11:02:38.314]                   {
[11:02:38.314]                     obj <- list(time = Sys.time(), condition = cond)
[11:02:38.314]                     file <- tempfile(pattern = class(cond)[1], 
[11:02:38.314]                       tmpdir = path, fileext = ".rds")
[11:02:38.314]                     save_rds(obj, file)
[11:02:38.314]                   }
[11:02:38.314]                   saveImmediateCondition(cond, path = "/tmp/RtmpPVwpFC/.future/immediateConditions")
[11:02:38.314]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:38.314]                   {
[11:02:38.314]                     inherits <- base::inherits
[11:02:38.314]                     invokeRestart <- base::invokeRestart
[11:02:38.314]                     is.null <- base::is.null
[11:02:38.314]                     muffled <- FALSE
[11:02:38.314]                     if (inherits(cond, "message")) {
[11:02:38.314]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:38.314]                       if (muffled) 
[11:02:38.314]                         invokeRestart("muffleMessage")
[11:02:38.314]                     }
[11:02:38.314]                     else if (inherits(cond, "warning")) {
[11:02:38.314]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:38.314]                       if (muffled) 
[11:02:38.314]                         invokeRestart("muffleWarning")
[11:02:38.314]                     }
[11:02:38.314]                     else if (inherits(cond, "condition")) {
[11:02:38.314]                       if (!is.null(pattern)) {
[11:02:38.314]                         computeRestarts <- base::computeRestarts
[11:02:38.314]                         grepl <- base::grepl
[11:02:38.314]                         restarts <- computeRestarts(cond)
[11:02:38.314]                         for (restart in restarts) {
[11:02:38.314]                           name <- restart$name
[11:02:38.314]                           if (is.null(name)) 
[11:02:38.314]                             next
[11:02:38.314]                           if (!grepl(pattern, name)) 
[11:02:38.314]                             next
[11:02:38.314]                           invokeRestart(restart)
[11:02:38.314]                           muffled <- TRUE
[11:02:38.314]                           break
[11:02:38.314]                         }
[11:02:38.314]                       }
[11:02:38.314]                     }
[11:02:38.314]                     invisible(muffled)
[11:02:38.314]                   }
[11:02:38.314]                   muffleCondition(cond)
[11:02:38.314]                 })
[11:02:38.314]             }))
[11:02:38.314]             future::FutureResult(value = ...future.value$value, 
[11:02:38.314]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:38.314]                   ...future.rng), globalenv = if (FALSE) 
[11:02:38.314]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:38.314]                     ...future.globalenv.names))
[11:02:38.314]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:38.314]         }, condition = base::local({
[11:02:38.314]             c <- base::c
[11:02:38.314]             inherits <- base::inherits
[11:02:38.314]             invokeRestart <- base::invokeRestart
[11:02:38.314]             length <- base::length
[11:02:38.314]             list <- base::list
[11:02:38.314]             seq.int <- base::seq.int
[11:02:38.314]             signalCondition <- base::signalCondition
[11:02:38.314]             sys.calls <- base::sys.calls
[11:02:38.314]             `[[` <- base::`[[`
[11:02:38.314]             `+` <- base::`+`
[11:02:38.314]             `<<-` <- base::`<<-`
[11:02:38.314]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:38.314]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:38.314]                   3L)]
[11:02:38.314]             }
[11:02:38.314]             function(cond) {
[11:02:38.314]                 is_error <- inherits(cond, "error")
[11:02:38.314]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:38.314]                   NULL)
[11:02:38.314]                 if (is_error) {
[11:02:38.314]                   sessionInformation <- function() {
[11:02:38.314]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:38.314]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:38.314]                       search = base::search(), system = base::Sys.info())
[11:02:38.314]                   }
[11:02:38.314]                   ...future.conditions[[length(...future.conditions) + 
[11:02:38.314]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:38.314]                     cond$call), session = sessionInformation(), 
[11:02:38.314]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:38.314]                   signalCondition(cond)
[11:02:38.314]                 }
[11:02:38.314]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:38.314]                 "immediateCondition"))) {
[11:02:38.314]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:38.314]                   ...future.conditions[[length(...future.conditions) + 
[11:02:38.314]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:38.314]                   if (TRUE && !signal) {
[11:02:38.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:38.314]                     {
[11:02:38.314]                       inherits <- base::inherits
[11:02:38.314]                       invokeRestart <- base::invokeRestart
[11:02:38.314]                       is.null <- base::is.null
[11:02:38.314]                       muffled <- FALSE
[11:02:38.314]                       if (inherits(cond, "message")) {
[11:02:38.314]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:38.314]                         if (muffled) 
[11:02:38.314]                           invokeRestart("muffleMessage")
[11:02:38.314]                       }
[11:02:38.314]                       else if (inherits(cond, "warning")) {
[11:02:38.314]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:38.314]                         if (muffled) 
[11:02:38.314]                           invokeRestart("muffleWarning")
[11:02:38.314]                       }
[11:02:38.314]                       else if (inherits(cond, "condition")) {
[11:02:38.314]                         if (!is.null(pattern)) {
[11:02:38.314]                           computeRestarts <- base::computeRestarts
[11:02:38.314]                           grepl <- base::grepl
[11:02:38.314]                           restarts <- computeRestarts(cond)
[11:02:38.314]                           for (restart in restarts) {
[11:02:38.314]                             name <- restart$name
[11:02:38.314]                             if (is.null(name)) 
[11:02:38.314]                               next
[11:02:38.314]                             if (!grepl(pattern, name)) 
[11:02:38.314]                               next
[11:02:38.314]                             invokeRestart(restart)
[11:02:38.314]                             muffled <- TRUE
[11:02:38.314]                             break
[11:02:38.314]                           }
[11:02:38.314]                         }
[11:02:38.314]                       }
[11:02:38.314]                       invisible(muffled)
[11:02:38.314]                     }
[11:02:38.314]                     muffleCondition(cond, pattern = "^muffle")
[11:02:38.314]                   }
[11:02:38.314]                 }
[11:02:38.314]                 else {
[11:02:38.314]                   if (TRUE) {
[11:02:38.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:38.314]                     {
[11:02:38.314]                       inherits <- base::inherits
[11:02:38.314]                       invokeRestart <- base::invokeRestart
[11:02:38.314]                       is.null <- base::is.null
[11:02:38.314]                       muffled <- FALSE
[11:02:38.314]                       if (inherits(cond, "message")) {
[11:02:38.314]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:38.314]                         if (muffled) 
[11:02:38.314]                           invokeRestart("muffleMessage")
[11:02:38.314]                       }
[11:02:38.314]                       else if (inherits(cond, "warning")) {
[11:02:38.314]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:38.314]                         if (muffled) 
[11:02:38.314]                           invokeRestart("muffleWarning")
[11:02:38.314]                       }
[11:02:38.314]                       else if (inherits(cond, "condition")) {
[11:02:38.314]                         if (!is.null(pattern)) {
[11:02:38.314]                           computeRestarts <- base::computeRestarts
[11:02:38.314]                           grepl <- base::grepl
[11:02:38.314]                           restarts <- computeRestarts(cond)
[11:02:38.314]                           for (restart in restarts) {
[11:02:38.314]                             name <- restart$name
[11:02:38.314]                             if (is.null(name)) 
[11:02:38.314]                               next
[11:02:38.314]                             if (!grepl(pattern, name)) 
[11:02:38.314]                               next
[11:02:38.314]                             invokeRestart(restart)
[11:02:38.314]                             muffled <- TRUE
[11:02:38.314]                             break
[11:02:38.314]                           }
[11:02:38.314]                         }
[11:02:38.314]                       }
[11:02:38.314]                       invisible(muffled)
[11:02:38.314]                     }
[11:02:38.314]                     muffleCondition(cond, pattern = "^muffle")
[11:02:38.314]                   }
[11:02:38.314]                 }
[11:02:38.314]             }
[11:02:38.314]         }))
[11:02:38.314]     }, error = function(ex) {
[11:02:38.314]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:38.314]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:38.314]                 ...future.rng), started = ...future.startTime, 
[11:02:38.314]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:38.314]             version = "1.8"), class = "FutureResult")
[11:02:38.314]     }, finally = {
[11:02:38.314]         if (!identical(...future.workdir, getwd())) 
[11:02:38.314]             setwd(...future.workdir)
[11:02:38.314]         {
[11:02:38.314]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:38.314]                 ...future.oldOptions$nwarnings <- NULL
[11:02:38.314]             }
[11:02:38.314]             base::options(...future.oldOptions)
[11:02:38.314]             if (.Platform$OS.type == "windows") {
[11:02:38.314]                 old_names <- names(...future.oldEnvVars)
[11:02:38.314]                 envs <- base::Sys.getenv()
[11:02:38.314]                 names <- names(envs)
[11:02:38.314]                 common <- intersect(names, old_names)
[11:02:38.314]                 added <- setdiff(names, old_names)
[11:02:38.314]                 removed <- setdiff(old_names, names)
[11:02:38.314]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:38.314]                   envs[common]]
[11:02:38.314]                 NAMES <- toupper(changed)
[11:02:38.314]                 args <- list()
[11:02:38.314]                 for (kk in seq_along(NAMES)) {
[11:02:38.314]                   name <- changed[[kk]]
[11:02:38.314]                   NAME <- NAMES[[kk]]
[11:02:38.314]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:38.314]                     next
[11:02:38.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:38.314]                 }
[11:02:38.314]                 NAMES <- toupper(added)
[11:02:38.314]                 for (kk in seq_along(NAMES)) {
[11:02:38.314]                   name <- added[[kk]]
[11:02:38.314]                   NAME <- NAMES[[kk]]
[11:02:38.314]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:38.314]                     next
[11:02:38.314]                   args[[name]] <- ""
[11:02:38.314]                 }
[11:02:38.314]                 NAMES <- toupper(removed)
[11:02:38.314]                 for (kk in seq_along(NAMES)) {
[11:02:38.314]                   name <- removed[[kk]]
[11:02:38.314]                   NAME <- NAMES[[kk]]
[11:02:38.314]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:38.314]                     next
[11:02:38.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:38.314]                 }
[11:02:38.314]                 if (length(args) > 0) 
[11:02:38.314]                   base::do.call(base::Sys.setenv, args = args)
[11:02:38.314]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:38.314]             }
[11:02:38.314]             else {
[11:02:38.314]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:38.314]             }
[11:02:38.314]             {
[11:02:38.314]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:38.314]                   0L) {
[11:02:38.314]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:38.314]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:38.314]                   base::options(opts)
[11:02:38.314]                 }
[11:02:38.314]                 {
[11:02:38.314]                   {
[11:02:38.314]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:38.314]                     NULL
[11:02:38.314]                   }
[11:02:38.314]                   options(future.plan = NULL)
[11:02:38.314]                   if (is.na(NA_character_)) 
[11:02:38.314]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:38.314]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:38.314]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:38.314]                     .init = FALSE)
[11:02:38.314]                 }
[11:02:38.314]             }
[11:02:38.314]         }
[11:02:38.314]     })
[11:02:38.314]     if (TRUE) {
[11:02:38.314]         base::sink(type = "output", split = FALSE)
[11:02:38.314]         if (TRUE) {
[11:02:38.314]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:38.314]         }
[11:02:38.314]         else {
[11:02:38.314]             ...future.result["stdout"] <- base::list(NULL)
[11:02:38.314]         }
[11:02:38.314]         base::close(...future.stdout)
[11:02:38.314]         ...future.stdout <- NULL
[11:02:38.314]     }
[11:02:38.314]     ...future.result$conditions <- ...future.conditions
[11:02:38.314]     ...future.result$finished <- base::Sys.time()
[11:02:38.314]     ...future.result
[11:02:38.314] }
[11:02:38.317] requestCore(): workers = 2
[11:02:38.317] Poll #1 (0): usedCores() = 2, workers = 2
[11:02:38.328] result() for MulticoreFuture ...
[11:02:38.329] result() for MulticoreFuture ...
[11:02:38.329] result() for MulticoreFuture ... done
[11:02:38.329] result() for MulticoreFuture ... done
[11:02:38.329] result() for MulticoreFuture ...
[11:02:38.329] result() for MulticoreFuture ... done
[11:02:38.332] MulticoreFuture started
[11:02:38.333] - Launch lazy future ... done
[11:02:38.333] run() for ‘MulticoreFuture’ ... done
[11:02:38.333] plan(): Setting new future strategy stack:
[11:02:38.333] List of future strategies:
[11:02:38.333] 1. sequential:
[11:02:38.333]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:38.333]    - tweaked: FALSE
[11:02:38.333]    - call: NULL
[11:02:38.335] plan(): nbrOfWorkers() = 1
[11:02:38.337] plan(): Setting new future strategy stack:
[11:02:38.337] List of future strategies:
[11:02:38.337] 1. multicore:
[11:02:38.337]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:38.337]    - tweaked: FALSE
[11:02:38.337]    - call: plan(strategy)
[11:02:38.340] plan(): nbrOfWorkers() = 2
[11:02:38.341] Future #1
[11:02:38.341]  length: 2 (resolved future 1)
[11:02:38.341] run() for ‘Future’ ...
[11:02:38.341] - state: ‘created’
[11:02:38.342] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:02:38.344] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:38.344] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:02:38.345]   - Field: ‘label’
[11:02:38.345]   - Field: ‘local’
[11:02:38.345]   - Field: ‘owner’
[11:02:38.345]   - Field: ‘envir’
[11:02:38.345]   - Field: ‘workers’
[11:02:38.345]   - Field: ‘packages’
[11:02:38.345]   - Field: ‘gc’
[11:02:38.346]   - Field: ‘job’
[11:02:38.346]   - Field: ‘conditions’
[11:02:38.346]   - Field: ‘expr’
[11:02:38.346]   - Field: ‘uuid’
[11:02:38.346]   - Field: ‘seed’
[11:02:38.346]   - Field: ‘version’
[11:02:38.346]   - Field: ‘result’
[11:02:38.347]   - Field: ‘asynchronous’
[11:02:38.347]   - Field: ‘calls’
[11:02:38.347]   - Field: ‘globals’
[11:02:38.347]   - Field: ‘stdout’
[11:02:38.347]   - Field: ‘earlySignal’
[11:02:38.347]   - Field: ‘lazy’
[11:02:38.347]   - Field: ‘state’
[11:02:38.348] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:02:38.348] - Launch lazy future ...
[11:02:38.348] Packages needed by the future expression (n = 0): <none>
[11:02:38.348] Packages needed by future strategies (n = 0): <none>
[11:02:38.349] {
[11:02:38.349]     {
[11:02:38.349]         {
[11:02:38.349]             ...future.startTime <- base::Sys.time()
[11:02:38.349]             {
[11:02:38.349]                 {
[11:02:38.349]                   {
[11:02:38.349]                     {
[11:02:38.349]                       base::local({
[11:02:38.349]                         has_future <- base::requireNamespace("future", 
[11:02:38.349]                           quietly = TRUE)
[11:02:38.349]                         if (has_future) {
[11:02:38.349]                           ns <- base::getNamespace("future")
[11:02:38.349]                           version <- ns[[".package"]][["version"]]
[11:02:38.349]                           if (is.null(version)) 
[11:02:38.349]                             version <- utils::packageVersion("future")
[11:02:38.349]                         }
[11:02:38.349]                         else {
[11:02:38.349]                           version <- NULL
[11:02:38.349]                         }
[11:02:38.349]                         if (!has_future || version < "1.8.0") {
[11:02:38.349]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:38.349]                             "", base::R.version$version.string), 
[11:02:38.349]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:38.349]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:38.349]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:38.349]                               "release", "version")], collapse = " "), 
[11:02:38.349]                             hostname = base::Sys.info()[["nodename"]])
[11:02:38.349]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:38.349]                             info)
[11:02:38.349]                           info <- base::paste(info, collapse = "; ")
[11:02:38.349]                           if (!has_future) {
[11:02:38.349]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:38.349]                               info)
[11:02:38.349]                           }
[11:02:38.349]                           else {
[11:02:38.349]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:38.349]                               info, version)
[11:02:38.349]                           }
[11:02:38.349]                           base::stop(msg)
[11:02:38.349]                         }
[11:02:38.349]                       })
[11:02:38.349]                     }
[11:02:38.349]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:38.349]                     base::options(mc.cores = 1L)
[11:02:38.349]                   }
[11:02:38.349]                   ...future.strategy.old <- future::plan("list")
[11:02:38.349]                   options(future.plan = NULL)
[11:02:38.349]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:38.349]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:38.349]                 }
[11:02:38.349]                 ...future.workdir <- getwd()
[11:02:38.349]             }
[11:02:38.349]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:38.349]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:38.349]         }
[11:02:38.349]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:38.349]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:38.349]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:38.349]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:38.349]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:38.349]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:38.349]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:38.349]             base::names(...future.oldOptions))
[11:02:38.349]     }
[11:02:38.349]     if (FALSE) {
[11:02:38.349]     }
[11:02:38.349]     else {
[11:02:38.349]         if (TRUE) {
[11:02:38.349]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:38.349]                 open = "w")
[11:02:38.349]         }
[11:02:38.349]         else {
[11:02:38.349]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:38.349]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:38.349]         }
[11:02:38.349]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:38.349]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:38.349]             base::sink(type = "output", split = FALSE)
[11:02:38.349]             base::close(...future.stdout)
[11:02:38.349]         }, add = TRUE)
[11:02:38.349]     }
[11:02:38.349]     ...future.frame <- base::sys.nframe()
[11:02:38.349]     ...future.conditions <- base::list()
[11:02:38.349]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:38.349]     if (FALSE) {
[11:02:38.349]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:38.349]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:38.349]     }
[11:02:38.349]     ...future.result <- base::tryCatch({
[11:02:38.349]         base::withCallingHandlers({
[11:02:38.349]             ...future.value <- base::withVisible(base::local({
[11:02:38.349]                 withCallingHandlers({
[11:02:38.349]                   2
[11:02:38.349]                 }, immediateCondition = function(cond) {
[11:02:38.349]                   save_rds <- function (object, pathname, ...) 
[11:02:38.349]                   {
[11:02:38.349]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:02:38.349]                     if (file_test("-f", pathname_tmp)) {
[11:02:38.349]                       fi_tmp <- file.info(pathname_tmp)
[11:02:38.349]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:02:38.349]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:38.349]                         fi_tmp[["mtime"]])
[11:02:38.349]                     }
[11:02:38.349]                     tryCatch({
[11:02:38.349]                       saveRDS(object, file = pathname_tmp, ...)
[11:02:38.349]                     }, error = function(ex) {
[11:02:38.349]                       msg <- conditionMessage(ex)
[11:02:38.349]                       fi_tmp <- file.info(pathname_tmp)
[11:02:38.349]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:02:38.349]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:38.349]                         fi_tmp[["mtime"]], msg)
[11:02:38.349]                       ex$message <- msg
[11:02:38.349]                       stop(ex)
[11:02:38.349]                     })
[11:02:38.349]                     stopifnot(file_test("-f", pathname_tmp))
[11:02:38.349]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:02:38.349]                     if (!res || file_test("-f", pathname_tmp)) {
[11:02:38.349]                       fi_tmp <- file.info(pathname_tmp)
[11:02:38.349]                       fi <- file.info(pathname)
[11:02:38.349]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:02:38.349]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:38.349]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:02:38.349]                         fi[["size"]], fi[["mtime"]])
[11:02:38.349]                       stop(msg)
[11:02:38.349]                     }
[11:02:38.349]                     invisible(pathname)
[11:02:38.349]                   }
[11:02:38.349]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:02:38.349]                     rootPath = tempdir()) 
[11:02:38.349]                   {
[11:02:38.349]                     obj <- list(time = Sys.time(), condition = cond)
[11:02:38.349]                     file <- tempfile(pattern = class(cond)[1], 
[11:02:38.349]                       tmpdir = path, fileext = ".rds")
[11:02:38.349]                     save_rds(obj, file)
[11:02:38.349]                   }
[11:02:38.349]                   saveImmediateCondition(cond, path = "/tmp/RtmpPVwpFC/.future/immediateConditions")
[11:02:38.349]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:38.349]                   {
[11:02:38.349]                     inherits <- base::inherits
[11:02:38.349]                     invokeRestart <- base::invokeRestart
[11:02:38.349]                     is.null <- base::is.null
[11:02:38.349]                     muffled <- FALSE
[11:02:38.349]                     if (inherits(cond, "message")) {
[11:02:38.349]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:38.349]                       if (muffled) 
[11:02:38.349]                         invokeRestart("muffleMessage")
[11:02:38.349]                     }
[11:02:38.349]                     else if (inherits(cond, "warning")) {
[11:02:38.349]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:38.349]                       if (muffled) 
[11:02:38.349]                         invokeRestart("muffleWarning")
[11:02:38.349]                     }
[11:02:38.349]                     else if (inherits(cond, "condition")) {
[11:02:38.349]                       if (!is.null(pattern)) {
[11:02:38.349]                         computeRestarts <- base::computeRestarts
[11:02:38.349]                         grepl <- base::grepl
[11:02:38.349]                         restarts <- computeRestarts(cond)
[11:02:38.349]                         for (restart in restarts) {
[11:02:38.349]                           name <- restart$name
[11:02:38.349]                           if (is.null(name)) 
[11:02:38.349]                             next
[11:02:38.349]                           if (!grepl(pattern, name)) 
[11:02:38.349]                             next
[11:02:38.349]                           invokeRestart(restart)
[11:02:38.349]                           muffled <- TRUE
[11:02:38.349]                           break
[11:02:38.349]                         }
[11:02:38.349]                       }
[11:02:38.349]                     }
[11:02:38.349]                     invisible(muffled)
[11:02:38.349]                   }
[11:02:38.349]                   muffleCondition(cond)
[11:02:38.349]                 })
[11:02:38.349]             }))
[11:02:38.349]             future::FutureResult(value = ...future.value$value, 
[11:02:38.349]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:38.349]                   ...future.rng), globalenv = if (FALSE) 
[11:02:38.349]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:38.349]                     ...future.globalenv.names))
[11:02:38.349]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:38.349]         }, condition = base::local({
[11:02:38.349]             c <- base::c
[11:02:38.349]             inherits <- base::inherits
[11:02:38.349]             invokeRestart <- base::invokeRestart
[11:02:38.349]             length <- base::length
[11:02:38.349]             list <- base::list
[11:02:38.349]             seq.int <- base::seq.int
[11:02:38.349]             signalCondition <- base::signalCondition
[11:02:38.349]             sys.calls <- base::sys.calls
[11:02:38.349]             `[[` <- base::`[[`
[11:02:38.349]             `+` <- base::`+`
[11:02:38.349]             `<<-` <- base::`<<-`
[11:02:38.349]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:38.349]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:38.349]                   3L)]
[11:02:38.349]             }
[11:02:38.349]             function(cond) {
[11:02:38.349]                 is_error <- inherits(cond, "error")
[11:02:38.349]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:38.349]                   NULL)
[11:02:38.349]                 if (is_error) {
[11:02:38.349]                   sessionInformation <- function() {
[11:02:38.349]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:38.349]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:38.349]                       search = base::search(), system = base::Sys.info())
[11:02:38.349]                   }
[11:02:38.349]                   ...future.conditions[[length(...future.conditions) + 
[11:02:38.349]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:38.349]                     cond$call), session = sessionInformation(), 
[11:02:38.349]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:38.349]                   signalCondition(cond)
[11:02:38.349]                 }
[11:02:38.349]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:38.349]                 "immediateCondition"))) {
[11:02:38.349]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:38.349]                   ...future.conditions[[length(...future.conditions) + 
[11:02:38.349]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:38.349]                   if (TRUE && !signal) {
[11:02:38.349]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:38.349]                     {
[11:02:38.349]                       inherits <- base::inherits
[11:02:38.349]                       invokeRestart <- base::invokeRestart
[11:02:38.349]                       is.null <- base::is.null
[11:02:38.349]                       muffled <- FALSE
[11:02:38.349]                       if (inherits(cond, "message")) {
[11:02:38.349]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:38.349]                         if (muffled) 
[11:02:38.349]                           invokeRestart("muffleMessage")
[11:02:38.349]                       }
[11:02:38.349]                       else if (inherits(cond, "warning")) {
[11:02:38.349]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:38.349]                         if (muffled) 
[11:02:38.349]                           invokeRestart("muffleWarning")
[11:02:38.349]                       }
[11:02:38.349]                       else if (inherits(cond, "condition")) {
[11:02:38.349]                         if (!is.null(pattern)) {
[11:02:38.349]                           computeRestarts <- base::computeRestarts
[11:02:38.349]                           grepl <- base::grepl
[11:02:38.349]                           restarts <- computeRestarts(cond)
[11:02:38.349]                           for (restart in restarts) {
[11:02:38.349]                             name <- restart$name
[11:02:38.349]                             if (is.null(name)) 
[11:02:38.349]                               next
[11:02:38.349]                             if (!grepl(pattern, name)) 
[11:02:38.349]                               next
[11:02:38.349]                             invokeRestart(restart)
[11:02:38.349]                             muffled <- TRUE
[11:02:38.349]                             break
[11:02:38.349]                           }
[11:02:38.349]                         }
[11:02:38.349]                       }
[11:02:38.349]                       invisible(muffled)
[11:02:38.349]                     }
[11:02:38.349]                     muffleCondition(cond, pattern = "^muffle")
[11:02:38.349]                   }
[11:02:38.349]                 }
[11:02:38.349]                 else {
[11:02:38.349]                   if (TRUE) {
[11:02:38.349]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:38.349]                     {
[11:02:38.349]                       inherits <- base::inherits
[11:02:38.349]                       invokeRestart <- base::invokeRestart
[11:02:38.349]                       is.null <- base::is.null
[11:02:38.349]                       muffled <- FALSE
[11:02:38.349]                       if (inherits(cond, "message")) {
[11:02:38.349]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:38.349]                         if (muffled) 
[11:02:38.349]                           invokeRestart("muffleMessage")
[11:02:38.349]                       }
[11:02:38.349]                       else if (inherits(cond, "warning")) {
[11:02:38.349]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:38.349]                         if (muffled) 
[11:02:38.349]                           invokeRestart("muffleWarning")
[11:02:38.349]                       }
[11:02:38.349]                       else if (inherits(cond, "condition")) {
[11:02:38.349]                         if (!is.null(pattern)) {
[11:02:38.349]                           computeRestarts <- base::computeRestarts
[11:02:38.349]                           grepl <- base::grepl
[11:02:38.349]                           restarts <- computeRestarts(cond)
[11:02:38.349]                           for (restart in restarts) {
[11:02:38.349]                             name <- restart$name
[11:02:38.349]                             if (is.null(name)) 
[11:02:38.349]                               next
[11:02:38.349]                             if (!grepl(pattern, name)) 
[11:02:38.349]                               next
[11:02:38.349]                             invokeRestart(restart)
[11:02:38.349]                             muffled <- TRUE
[11:02:38.349]                             break
[11:02:38.349]                           }
[11:02:38.349]                         }
[11:02:38.349]                       }
[11:02:38.349]                       invisible(muffled)
[11:02:38.349]                     }
[11:02:38.349]                     muffleCondition(cond, pattern = "^muffle")
[11:02:38.349]                   }
[11:02:38.349]                 }
[11:02:38.349]             }
[11:02:38.349]         }))
[11:02:38.349]     }, error = function(ex) {
[11:02:38.349]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:38.349]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:38.349]                 ...future.rng), started = ...future.startTime, 
[11:02:38.349]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:38.349]             version = "1.8"), class = "FutureResult")
[11:02:38.349]     }, finally = {
[11:02:38.349]         if (!identical(...future.workdir, getwd())) 
[11:02:38.349]             setwd(...future.workdir)
[11:02:38.349]         {
[11:02:38.349]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:38.349]                 ...future.oldOptions$nwarnings <- NULL
[11:02:38.349]             }
[11:02:38.349]             base::options(...future.oldOptions)
[11:02:38.349]             if (.Platform$OS.type == "windows") {
[11:02:38.349]                 old_names <- names(...future.oldEnvVars)
[11:02:38.349]                 envs <- base::Sys.getenv()
[11:02:38.349]                 names <- names(envs)
[11:02:38.349]                 common <- intersect(names, old_names)
[11:02:38.349]                 added <- setdiff(names, old_names)
[11:02:38.349]                 removed <- setdiff(old_names, names)
[11:02:38.349]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:38.349]                   envs[common]]
[11:02:38.349]                 NAMES <- toupper(changed)
[11:02:38.349]                 args <- list()
[11:02:38.349]                 for (kk in seq_along(NAMES)) {
[11:02:38.349]                   name <- changed[[kk]]
[11:02:38.349]                   NAME <- NAMES[[kk]]
[11:02:38.349]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:38.349]                     next
[11:02:38.349]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:38.349]                 }
[11:02:38.349]                 NAMES <- toupper(added)
[11:02:38.349]                 for (kk in seq_along(NAMES)) {
[11:02:38.349]                   name <- added[[kk]]
[11:02:38.349]                   NAME <- NAMES[[kk]]
[11:02:38.349]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:38.349]                     next
[11:02:38.349]                   args[[name]] <- ""
[11:02:38.349]                 }
[11:02:38.349]                 NAMES <- toupper(removed)
[11:02:38.349]                 for (kk in seq_along(NAMES)) {
[11:02:38.349]                   name <- removed[[kk]]
[11:02:38.349]                   NAME <- NAMES[[kk]]
[11:02:38.349]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:38.349]                     next
[11:02:38.349]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:38.349]                 }
[11:02:38.349]                 if (length(args) > 0) 
[11:02:38.349]                   base::do.call(base::Sys.setenv, args = args)
[11:02:38.349]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:38.349]             }
[11:02:38.349]             else {
[11:02:38.349]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:38.349]             }
[11:02:38.349]             {
[11:02:38.349]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:38.349]                   0L) {
[11:02:38.349]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:38.349]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:38.349]                   base::options(opts)
[11:02:38.349]                 }
[11:02:38.349]                 {
[11:02:38.349]                   {
[11:02:38.349]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:38.349]                     NULL
[11:02:38.349]                   }
[11:02:38.349]                   options(future.plan = NULL)
[11:02:38.349]                   if (is.na(NA_character_)) 
[11:02:38.349]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:38.349]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:38.349]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:38.349]                     .init = FALSE)
[11:02:38.349]                 }
[11:02:38.349]             }
[11:02:38.349]         }
[11:02:38.349]     })
[11:02:38.349]     if (TRUE) {
[11:02:38.349]         base::sink(type = "output", split = FALSE)
[11:02:38.349]         if (TRUE) {
[11:02:38.349]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:38.349]         }
[11:02:38.349]         else {
[11:02:38.349]             ...future.result["stdout"] <- base::list(NULL)
[11:02:38.349]         }
[11:02:38.349]         base::close(...future.stdout)
[11:02:38.349]         ...future.stdout <- NULL
[11:02:38.349]     }
[11:02:38.349]     ...future.result$conditions <- ...future.conditions
[11:02:38.349]     ...future.result$finished <- base::Sys.time()
[11:02:38.349]     ...future.result
[11:02:38.349] }
[11:02:38.352] requestCore(): workers = 2
[11:02:38.353] Poll #1 (0): usedCores() = 2, workers = 2
[11:02:38.363] result() for MulticoreFuture ...
[11:02:38.364] result() for MulticoreFuture ...
[11:02:38.365] result() for MulticoreFuture ... done
[11:02:38.365] result() for MulticoreFuture ... done
[11:02:38.365] result() for MulticoreFuture ...
[11:02:38.365] result() for MulticoreFuture ... done
[11:02:38.368] MulticoreFuture started
[11:02:38.368] - Launch lazy future ... done
[11:02:38.368] run() for ‘MulticoreFuture’ ... done
[11:02:38.369] plan(): Setting new future strategy stack:
[11:02:38.369] List of future strategies:
[11:02:38.369] 1. sequential:
[11:02:38.369]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:38.369]    - tweaked: FALSE
[11:02:38.369]    - call: NULL
[11:02:38.370] plan(): nbrOfWorkers() = 1
[11:02:38.372] plan(): Setting new future strategy stack:
[11:02:38.372] List of future strategies:
[11:02:38.372] 1. multicore:
[11:02:38.372]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:38.372]    - tweaked: FALSE
[11:02:38.372]    - call: plan(strategy)
[11:02:38.375] plan(): nbrOfWorkers() = 2
[11:02:38.376] Future #2
[11:02:38.376]  length: 1 (resolved future 2)
[11:02:38.376]  length: 0 (resolved future 3)
[11:02:38.376] resolve() on list ... DONE
[11:02:38.377] getGlobalsAndPackages() ...
[11:02:38.377] Searching for globals...
[11:02:38.378] 
[11:02:38.378] Searching for globals ... DONE
[11:02:38.378] - globals: [0] <none>
[11:02:38.378] getGlobalsAndPackages() ... DONE
[11:02:38.379] run() for ‘Future’ ...
[11:02:38.379] - state: ‘created’
[11:02:38.379] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:02:38.382] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:38.382] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:02:38.382]   - Field: ‘label’
[11:02:38.382]   - Field: ‘local’
[11:02:38.382]   - Field: ‘owner’
[11:02:38.382]   - Field: ‘envir’
[11:02:38.383]   - Field: ‘workers’
[11:02:38.383]   - Field: ‘packages’
[11:02:38.383]   - Field: ‘gc’
[11:02:38.383]   - Field: ‘job’
[11:02:38.383]   - Field: ‘conditions’
[11:02:38.383]   - Field: ‘expr’
[11:02:38.383]   - Field: ‘uuid’
[11:02:38.384]   - Field: ‘seed’
[11:02:38.384]   - Field: ‘version’
[11:02:38.384]   - Field: ‘result’
[11:02:38.384]   - Field: ‘asynchronous’
[11:02:38.384]   - Field: ‘calls’
[11:02:38.384]   - Field: ‘globals’
[11:02:38.384]   - Field: ‘stdout’
[11:02:38.385]   - Field: ‘earlySignal’
[11:02:38.385]   - Field: ‘lazy’
[11:02:38.385]   - Field: ‘state’
[11:02:38.385] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:02:38.385] - Launch lazy future ...
[11:02:38.386] Packages needed by the future expression (n = 0): <none>
[11:02:38.386] Packages needed by future strategies (n = 0): <none>
[11:02:38.386] {
[11:02:38.386]     {
[11:02:38.386]         {
[11:02:38.386]             ...future.startTime <- base::Sys.time()
[11:02:38.386]             {
[11:02:38.386]                 {
[11:02:38.386]                   {
[11:02:38.386]                     {
[11:02:38.386]                       base::local({
[11:02:38.386]                         has_future <- base::requireNamespace("future", 
[11:02:38.386]                           quietly = TRUE)
[11:02:38.386]                         if (has_future) {
[11:02:38.386]                           ns <- base::getNamespace("future")
[11:02:38.386]                           version <- ns[[".package"]][["version"]]
[11:02:38.386]                           if (is.null(version)) 
[11:02:38.386]                             version <- utils::packageVersion("future")
[11:02:38.386]                         }
[11:02:38.386]                         else {
[11:02:38.386]                           version <- NULL
[11:02:38.386]                         }
[11:02:38.386]                         if (!has_future || version < "1.8.0") {
[11:02:38.386]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:38.386]                             "", base::R.version$version.string), 
[11:02:38.386]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:38.386]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:38.386]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:38.386]                               "release", "version")], collapse = " "), 
[11:02:38.386]                             hostname = base::Sys.info()[["nodename"]])
[11:02:38.386]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:38.386]                             info)
[11:02:38.386]                           info <- base::paste(info, collapse = "; ")
[11:02:38.386]                           if (!has_future) {
[11:02:38.386]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:38.386]                               info)
[11:02:38.386]                           }
[11:02:38.386]                           else {
[11:02:38.386]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:38.386]                               info, version)
[11:02:38.386]                           }
[11:02:38.386]                           base::stop(msg)
[11:02:38.386]                         }
[11:02:38.386]                       })
[11:02:38.386]                     }
[11:02:38.386]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:38.386]                     base::options(mc.cores = 1L)
[11:02:38.386]                   }
[11:02:38.386]                   ...future.strategy.old <- future::plan("list")
[11:02:38.386]                   options(future.plan = NULL)
[11:02:38.386]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:38.386]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:38.386]                 }
[11:02:38.386]                 ...future.workdir <- getwd()
[11:02:38.386]             }
[11:02:38.386]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:38.386]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:38.386]         }
[11:02:38.386]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:38.386]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:38.386]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:38.386]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:38.386]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:38.386]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:38.386]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:38.386]             base::names(...future.oldOptions))
[11:02:38.386]     }
[11:02:38.386]     if (FALSE) {
[11:02:38.386]     }
[11:02:38.386]     else {
[11:02:38.386]         if (TRUE) {
[11:02:38.386]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:38.386]                 open = "w")
[11:02:38.386]         }
[11:02:38.386]         else {
[11:02:38.386]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:38.386]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:38.386]         }
[11:02:38.386]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:38.386]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:38.386]             base::sink(type = "output", split = FALSE)
[11:02:38.386]             base::close(...future.stdout)
[11:02:38.386]         }, add = TRUE)
[11:02:38.386]     }
[11:02:38.386]     ...future.frame <- base::sys.nframe()
[11:02:38.386]     ...future.conditions <- base::list()
[11:02:38.386]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:38.386]     if (FALSE) {
[11:02:38.386]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:38.386]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:38.386]     }
[11:02:38.386]     ...future.result <- base::tryCatch({
[11:02:38.386]         base::withCallingHandlers({
[11:02:38.386]             ...future.value <- base::withVisible(base::local({
[11:02:38.386]                 withCallingHandlers({
[11:02:38.386]                   1
[11:02:38.386]                 }, immediateCondition = function(cond) {
[11:02:38.386]                   save_rds <- function (object, pathname, ...) 
[11:02:38.386]                   {
[11:02:38.386]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:02:38.386]                     if (file_test("-f", pathname_tmp)) {
[11:02:38.386]                       fi_tmp <- file.info(pathname_tmp)
[11:02:38.386]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:02:38.386]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:38.386]                         fi_tmp[["mtime"]])
[11:02:38.386]                     }
[11:02:38.386]                     tryCatch({
[11:02:38.386]                       saveRDS(object, file = pathname_tmp, ...)
[11:02:38.386]                     }, error = function(ex) {
[11:02:38.386]                       msg <- conditionMessage(ex)
[11:02:38.386]                       fi_tmp <- file.info(pathname_tmp)
[11:02:38.386]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:02:38.386]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:38.386]                         fi_tmp[["mtime"]], msg)
[11:02:38.386]                       ex$message <- msg
[11:02:38.386]                       stop(ex)
[11:02:38.386]                     })
[11:02:38.386]                     stopifnot(file_test("-f", pathname_tmp))
[11:02:38.386]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:02:38.386]                     if (!res || file_test("-f", pathname_tmp)) {
[11:02:38.386]                       fi_tmp <- file.info(pathname_tmp)
[11:02:38.386]                       fi <- file.info(pathname)
[11:02:38.386]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:02:38.386]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:38.386]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:02:38.386]                         fi[["size"]], fi[["mtime"]])
[11:02:38.386]                       stop(msg)
[11:02:38.386]                     }
[11:02:38.386]                     invisible(pathname)
[11:02:38.386]                   }
[11:02:38.386]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:02:38.386]                     rootPath = tempdir()) 
[11:02:38.386]                   {
[11:02:38.386]                     obj <- list(time = Sys.time(), condition = cond)
[11:02:38.386]                     file <- tempfile(pattern = class(cond)[1], 
[11:02:38.386]                       tmpdir = path, fileext = ".rds")
[11:02:38.386]                     save_rds(obj, file)
[11:02:38.386]                   }
[11:02:38.386]                   saveImmediateCondition(cond, path = "/tmp/RtmpPVwpFC/.future/immediateConditions")
[11:02:38.386]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:38.386]                   {
[11:02:38.386]                     inherits <- base::inherits
[11:02:38.386]                     invokeRestart <- base::invokeRestart
[11:02:38.386]                     is.null <- base::is.null
[11:02:38.386]                     muffled <- FALSE
[11:02:38.386]                     if (inherits(cond, "message")) {
[11:02:38.386]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:38.386]                       if (muffled) 
[11:02:38.386]                         invokeRestart("muffleMessage")
[11:02:38.386]                     }
[11:02:38.386]                     else if (inherits(cond, "warning")) {
[11:02:38.386]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:38.386]                       if (muffled) 
[11:02:38.386]                         invokeRestart("muffleWarning")
[11:02:38.386]                     }
[11:02:38.386]                     else if (inherits(cond, "condition")) {
[11:02:38.386]                       if (!is.null(pattern)) {
[11:02:38.386]                         computeRestarts <- base::computeRestarts
[11:02:38.386]                         grepl <- base::grepl
[11:02:38.386]                         restarts <- computeRestarts(cond)
[11:02:38.386]                         for (restart in restarts) {
[11:02:38.386]                           name <- restart$name
[11:02:38.386]                           if (is.null(name)) 
[11:02:38.386]                             next
[11:02:38.386]                           if (!grepl(pattern, name)) 
[11:02:38.386]                             next
[11:02:38.386]                           invokeRestart(restart)
[11:02:38.386]                           muffled <- TRUE
[11:02:38.386]                           break
[11:02:38.386]                         }
[11:02:38.386]                       }
[11:02:38.386]                     }
[11:02:38.386]                     invisible(muffled)
[11:02:38.386]                   }
[11:02:38.386]                   muffleCondition(cond)
[11:02:38.386]                 })
[11:02:38.386]             }))
[11:02:38.386]             future::FutureResult(value = ...future.value$value, 
[11:02:38.386]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:38.386]                   ...future.rng), globalenv = if (FALSE) 
[11:02:38.386]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:38.386]                     ...future.globalenv.names))
[11:02:38.386]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:38.386]         }, condition = base::local({
[11:02:38.386]             c <- base::c
[11:02:38.386]             inherits <- base::inherits
[11:02:38.386]             invokeRestart <- base::invokeRestart
[11:02:38.386]             length <- base::length
[11:02:38.386]             list <- base::list
[11:02:38.386]             seq.int <- base::seq.int
[11:02:38.386]             signalCondition <- base::signalCondition
[11:02:38.386]             sys.calls <- base::sys.calls
[11:02:38.386]             `[[` <- base::`[[`
[11:02:38.386]             `+` <- base::`+`
[11:02:38.386]             `<<-` <- base::`<<-`
[11:02:38.386]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:38.386]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:38.386]                   3L)]
[11:02:38.386]             }
[11:02:38.386]             function(cond) {
[11:02:38.386]                 is_error <- inherits(cond, "error")
[11:02:38.386]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:38.386]                   NULL)
[11:02:38.386]                 if (is_error) {
[11:02:38.386]                   sessionInformation <- function() {
[11:02:38.386]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:38.386]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:38.386]                       search = base::search(), system = base::Sys.info())
[11:02:38.386]                   }
[11:02:38.386]                   ...future.conditions[[length(...future.conditions) + 
[11:02:38.386]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:38.386]                     cond$call), session = sessionInformation(), 
[11:02:38.386]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:38.386]                   signalCondition(cond)
[11:02:38.386]                 }
[11:02:38.386]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:38.386]                 "immediateCondition"))) {
[11:02:38.386]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:38.386]                   ...future.conditions[[length(...future.conditions) + 
[11:02:38.386]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:38.386]                   if (TRUE && !signal) {
[11:02:38.386]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:38.386]                     {
[11:02:38.386]                       inherits <- base::inherits
[11:02:38.386]                       invokeRestart <- base::invokeRestart
[11:02:38.386]                       is.null <- base::is.null
[11:02:38.386]                       muffled <- FALSE
[11:02:38.386]                       if (inherits(cond, "message")) {
[11:02:38.386]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:38.386]                         if (muffled) 
[11:02:38.386]                           invokeRestart("muffleMessage")
[11:02:38.386]                       }
[11:02:38.386]                       else if (inherits(cond, "warning")) {
[11:02:38.386]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:38.386]                         if (muffled) 
[11:02:38.386]                           invokeRestart("muffleWarning")
[11:02:38.386]                       }
[11:02:38.386]                       else if (inherits(cond, "condition")) {
[11:02:38.386]                         if (!is.null(pattern)) {
[11:02:38.386]                           computeRestarts <- base::computeRestarts
[11:02:38.386]                           grepl <- base::grepl
[11:02:38.386]                           restarts <- computeRestarts(cond)
[11:02:38.386]                           for (restart in restarts) {
[11:02:38.386]                             name <- restart$name
[11:02:38.386]                             if (is.null(name)) 
[11:02:38.386]                               next
[11:02:38.386]                             if (!grepl(pattern, name)) 
[11:02:38.386]                               next
[11:02:38.386]                             invokeRestart(restart)
[11:02:38.386]                             muffled <- TRUE
[11:02:38.386]                             break
[11:02:38.386]                           }
[11:02:38.386]                         }
[11:02:38.386]                       }
[11:02:38.386]                       invisible(muffled)
[11:02:38.386]                     }
[11:02:38.386]                     muffleCondition(cond, pattern = "^muffle")
[11:02:38.386]                   }
[11:02:38.386]                 }
[11:02:38.386]                 else {
[11:02:38.386]                   if (TRUE) {
[11:02:38.386]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:38.386]                     {
[11:02:38.386]                       inherits <- base::inherits
[11:02:38.386]                       invokeRestart <- base::invokeRestart
[11:02:38.386]                       is.null <- base::is.null
[11:02:38.386]                       muffled <- FALSE
[11:02:38.386]                       if (inherits(cond, "message")) {
[11:02:38.386]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:38.386]                         if (muffled) 
[11:02:38.386]                           invokeRestart("muffleMessage")
[11:02:38.386]                       }
[11:02:38.386]                       else if (inherits(cond, "warning")) {
[11:02:38.386]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:38.386]                         if (muffled) 
[11:02:38.386]                           invokeRestart("muffleWarning")
[11:02:38.386]                       }
[11:02:38.386]                       else if (inherits(cond, "condition")) {
[11:02:38.386]                         if (!is.null(pattern)) {
[11:02:38.386]                           computeRestarts <- base::computeRestarts
[11:02:38.386]                           grepl <- base::grepl
[11:02:38.386]                           restarts <- computeRestarts(cond)
[11:02:38.386]                           for (restart in restarts) {
[11:02:38.386]                             name <- restart$name
[11:02:38.386]                             if (is.null(name)) 
[11:02:38.386]                               next
[11:02:38.386]                             if (!grepl(pattern, name)) 
[11:02:38.386]                               next
[11:02:38.386]                             invokeRestart(restart)
[11:02:38.386]                             muffled <- TRUE
[11:02:38.386]                             break
[11:02:38.386]                           }
[11:02:38.386]                         }
[11:02:38.386]                       }
[11:02:38.386]                       invisible(muffled)
[11:02:38.386]                     }
[11:02:38.386]                     muffleCondition(cond, pattern = "^muffle")
[11:02:38.386]                   }
[11:02:38.386]                 }
[11:02:38.386]             }
[11:02:38.386]         }))
[11:02:38.386]     }, error = function(ex) {
[11:02:38.386]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:38.386]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:38.386]                 ...future.rng), started = ...future.startTime, 
[11:02:38.386]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:38.386]             version = "1.8"), class = "FutureResult")
[11:02:38.386]     }, finally = {
[11:02:38.386]         if (!identical(...future.workdir, getwd())) 
[11:02:38.386]             setwd(...future.workdir)
[11:02:38.386]         {
[11:02:38.386]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:38.386]                 ...future.oldOptions$nwarnings <- NULL
[11:02:38.386]             }
[11:02:38.386]             base::options(...future.oldOptions)
[11:02:38.386]             if (.Platform$OS.type == "windows") {
[11:02:38.386]                 old_names <- names(...future.oldEnvVars)
[11:02:38.386]                 envs <- base::Sys.getenv()
[11:02:38.386]                 names <- names(envs)
[11:02:38.386]                 common <- intersect(names, old_names)
[11:02:38.386]                 added <- setdiff(names, old_names)
[11:02:38.386]                 removed <- setdiff(old_names, names)
[11:02:38.386]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:38.386]                   envs[common]]
[11:02:38.386]                 NAMES <- toupper(changed)
[11:02:38.386]                 args <- list()
[11:02:38.386]                 for (kk in seq_along(NAMES)) {
[11:02:38.386]                   name <- changed[[kk]]
[11:02:38.386]                   NAME <- NAMES[[kk]]
[11:02:38.386]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:38.386]                     next
[11:02:38.386]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:38.386]                 }
[11:02:38.386]                 NAMES <- toupper(added)
[11:02:38.386]                 for (kk in seq_along(NAMES)) {
[11:02:38.386]                   name <- added[[kk]]
[11:02:38.386]                   NAME <- NAMES[[kk]]
[11:02:38.386]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:38.386]                     next
[11:02:38.386]                   args[[name]] <- ""
[11:02:38.386]                 }
[11:02:38.386]                 NAMES <- toupper(removed)
[11:02:38.386]                 for (kk in seq_along(NAMES)) {
[11:02:38.386]                   name <- removed[[kk]]
[11:02:38.386]                   NAME <- NAMES[[kk]]
[11:02:38.386]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:38.386]                     next
[11:02:38.386]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:38.386]                 }
[11:02:38.386]                 if (length(args) > 0) 
[11:02:38.386]                   base::do.call(base::Sys.setenv, args = args)
[11:02:38.386]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:38.386]             }
[11:02:38.386]             else {
[11:02:38.386]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:38.386]             }
[11:02:38.386]             {
[11:02:38.386]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:38.386]                   0L) {
[11:02:38.386]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:38.386]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:38.386]                   base::options(opts)
[11:02:38.386]                 }
[11:02:38.386]                 {
[11:02:38.386]                   {
[11:02:38.386]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:38.386]                     NULL
[11:02:38.386]                   }
[11:02:38.386]                   options(future.plan = NULL)
[11:02:38.386]                   if (is.na(NA_character_)) 
[11:02:38.386]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:38.386]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:38.386]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:38.386]                     .init = FALSE)
[11:02:38.386]                 }
[11:02:38.386]             }
[11:02:38.386]         }
[11:02:38.386]     })
[11:02:38.386]     if (TRUE) {
[11:02:38.386]         base::sink(type = "output", split = FALSE)
[11:02:38.386]         if (TRUE) {
[11:02:38.386]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:38.386]         }
[11:02:38.386]         else {
[11:02:38.386]             ...future.result["stdout"] <- base::list(NULL)
[11:02:38.386]         }
[11:02:38.386]         base::close(...future.stdout)
[11:02:38.386]         ...future.stdout <- NULL
[11:02:38.386]     }
[11:02:38.386]     ...future.result$conditions <- ...future.conditions
[11:02:38.386]     ...future.result$finished <- base::Sys.time()
[11:02:38.386]     ...future.result
[11:02:38.386] }
[11:02:38.390] requestCore(): workers = 2
[11:02:38.390] Poll #1 (0): usedCores() = 2, workers = 2
[11:02:38.401] result() for MulticoreFuture ...
[11:02:38.402] result() for MulticoreFuture ...
[11:02:38.402] result() for MulticoreFuture ... done
[11:02:38.402] result() for MulticoreFuture ... done
[11:02:38.402] result() for MulticoreFuture ...
[11:02:38.402] result() for MulticoreFuture ... done
[11:02:38.404] MulticoreFuture started
[11:02:38.405] - Launch lazy future ... done
[11:02:38.405] run() for ‘MulticoreFuture’ ... done
[11:02:38.405] getGlobalsAndPackages() ...
[11:02:38.405] plan(): Setting new future strategy stack:
[11:02:38.405] Searching for globals...
[11:02:38.406] List of future strategies:
[11:02:38.406] 1. sequential:
[11:02:38.406]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:38.406]    - tweaked: FALSE
[11:02:38.406]    - call: NULL
[11:02:38.407] plan(): nbrOfWorkers() = 1
[11:02:38.408] - globals found: [2] ‘{’, ‘Sys.sleep’
[11:02:38.409] Searching for globals ... DONE
[11:02:38.409] Resolving globals: FALSE
[11:02:38.410] 
[11:02:38.410] plan(): Setting new future strategy stack:
[11:02:38.410] 
[11:02:38.410] getGlobalsAndPackages() ... DONE
[11:02:38.410] List of future strategies:
[11:02:38.410] 1. multicore:
[11:02:38.410]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:38.410]    - tweaked: FALSE
[11:02:38.410]    - call: plan(strategy)
[11:02:38.411] run() for ‘Future’ ...
[11:02:38.411] - state: ‘created’
[11:02:38.411] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:02:38.413] plan(): nbrOfWorkers() = 2
[11:02:38.422] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:38.423] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:02:38.423]   - Field: ‘label’
[11:02:38.424]   - Field: ‘local’
[11:02:38.424]   - Field: ‘owner’
[11:02:38.424]   - Field: ‘envir’
[11:02:38.425]   - Field: ‘workers’
[11:02:38.425]   - Field: ‘packages’
[11:02:38.425]   - Field: ‘gc’
[11:02:38.426]   - Field: ‘job’
[11:02:38.426]   - Field: ‘conditions’
[11:02:38.426]   - Field: ‘expr’
[11:02:38.426]   - Field: ‘uuid’
[11:02:38.426]   - Field: ‘seed’
[11:02:38.427]   - Field: ‘version’
[11:02:38.427]   - Field: ‘result’
[11:02:38.427]   - Field: ‘asynchronous’
[11:02:38.427]   - Field: ‘calls’
[11:02:38.428]   - Field: ‘globals’
[11:02:38.428]   - Field: ‘stdout’
[11:02:38.428]   - Field: ‘earlySignal’
[11:02:38.428]   - Field: ‘lazy’
[11:02:38.428]   - Field: ‘state’
[11:02:38.429] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:02:38.429] - Launch lazy future ...
[11:02:38.429] Packages needed by the future expression (n = 0): <none>
[11:02:38.430] Packages needed by future strategies (n = 0): <none>
[11:02:38.431] {
[11:02:38.431]     {
[11:02:38.431]         {
[11:02:38.431]             ...future.startTime <- base::Sys.time()
[11:02:38.431]             {
[11:02:38.431]                 {
[11:02:38.431]                   {
[11:02:38.431]                     {
[11:02:38.431]                       base::local({
[11:02:38.431]                         has_future <- base::requireNamespace("future", 
[11:02:38.431]                           quietly = TRUE)
[11:02:38.431]                         if (has_future) {
[11:02:38.431]                           ns <- base::getNamespace("future")
[11:02:38.431]                           version <- ns[[".package"]][["version"]]
[11:02:38.431]                           if (is.null(version)) 
[11:02:38.431]                             version <- utils::packageVersion("future")
[11:02:38.431]                         }
[11:02:38.431]                         else {
[11:02:38.431]                           version <- NULL
[11:02:38.431]                         }
[11:02:38.431]                         if (!has_future || version < "1.8.0") {
[11:02:38.431]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:38.431]                             "", base::R.version$version.string), 
[11:02:38.431]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:38.431]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:38.431]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:38.431]                               "release", "version")], collapse = " "), 
[11:02:38.431]                             hostname = base::Sys.info()[["nodename"]])
[11:02:38.431]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:38.431]                             info)
[11:02:38.431]                           info <- base::paste(info, collapse = "; ")
[11:02:38.431]                           if (!has_future) {
[11:02:38.431]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:38.431]                               info)
[11:02:38.431]                           }
[11:02:38.431]                           else {
[11:02:38.431]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:38.431]                               info, version)
[11:02:38.431]                           }
[11:02:38.431]                           base::stop(msg)
[11:02:38.431]                         }
[11:02:38.431]                       })
[11:02:38.431]                     }
[11:02:38.431]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:38.431]                     base::options(mc.cores = 1L)
[11:02:38.431]                   }
[11:02:38.431]                   ...future.strategy.old <- future::plan("list")
[11:02:38.431]                   options(future.plan = NULL)
[11:02:38.431]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:38.431]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:38.431]                 }
[11:02:38.431]                 ...future.workdir <- getwd()
[11:02:38.431]             }
[11:02:38.431]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:38.431]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:38.431]         }
[11:02:38.431]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:38.431]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:38.431]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:38.431]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:38.431]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:38.431]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:38.431]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:38.431]             base::names(...future.oldOptions))
[11:02:38.431]     }
[11:02:38.431]     if (FALSE) {
[11:02:38.431]     }
[11:02:38.431]     else {
[11:02:38.431]         if (TRUE) {
[11:02:38.431]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:38.431]                 open = "w")
[11:02:38.431]         }
[11:02:38.431]         else {
[11:02:38.431]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:38.431]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:38.431]         }
[11:02:38.431]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:38.431]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:38.431]             base::sink(type = "output", split = FALSE)
[11:02:38.431]             base::close(...future.stdout)
[11:02:38.431]         }, add = TRUE)
[11:02:38.431]     }
[11:02:38.431]     ...future.frame <- base::sys.nframe()
[11:02:38.431]     ...future.conditions <- base::list()
[11:02:38.431]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:38.431]     if (FALSE) {
[11:02:38.431]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:38.431]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:38.431]     }
[11:02:38.431]     ...future.result <- base::tryCatch({
[11:02:38.431]         base::withCallingHandlers({
[11:02:38.431]             ...future.value <- base::withVisible(base::local({
[11:02:38.431]                 withCallingHandlers({
[11:02:38.431]                   {
[11:02:38.431]                     Sys.sleep(0.5)
[11:02:38.431]                     2
[11:02:38.431]                   }
[11:02:38.431]                 }, immediateCondition = function(cond) {
[11:02:38.431]                   save_rds <- function (object, pathname, ...) 
[11:02:38.431]                   {
[11:02:38.431]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:02:38.431]                     if (file_test("-f", pathname_tmp)) {
[11:02:38.431]                       fi_tmp <- file.info(pathname_tmp)
[11:02:38.431]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:02:38.431]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:38.431]                         fi_tmp[["mtime"]])
[11:02:38.431]                     }
[11:02:38.431]                     tryCatch({
[11:02:38.431]                       saveRDS(object, file = pathname_tmp, ...)
[11:02:38.431]                     }, error = function(ex) {
[11:02:38.431]                       msg <- conditionMessage(ex)
[11:02:38.431]                       fi_tmp <- file.info(pathname_tmp)
[11:02:38.431]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:02:38.431]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:38.431]                         fi_tmp[["mtime"]], msg)
[11:02:38.431]                       ex$message <- msg
[11:02:38.431]                       stop(ex)
[11:02:38.431]                     })
[11:02:38.431]                     stopifnot(file_test("-f", pathname_tmp))
[11:02:38.431]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:02:38.431]                     if (!res || file_test("-f", pathname_tmp)) {
[11:02:38.431]                       fi_tmp <- file.info(pathname_tmp)
[11:02:38.431]                       fi <- file.info(pathname)
[11:02:38.431]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:02:38.431]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:38.431]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:02:38.431]                         fi[["size"]], fi[["mtime"]])
[11:02:38.431]                       stop(msg)
[11:02:38.431]                     }
[11:02:38.431]                     invisible(pathname)
[11:02:38.431]                   }
[11:02:38.431]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:02:38.431]                     rootPath = tempdir()) 
[11:02:38.431]                   {
[11:02:38.431]                     obj <- list(time = Sys.time(), condition = cond)
[11:02:38.431]                     file <- tempfile(pattern = class(cond)[1], 
[11:02:38.431]                       tmpdir = path, fileext = ".rds")
[11:02:38.431]                     save_rds(obj, file)
[11:02:38.431]                   }
[11:02:38.431]                   saveImmediateCondition(cond, path = "/tmp/RtmpPVwpFC/.future/immediateConditions")
[11:02:38.431]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:38.431]                   {
[11:02:38.431]                     inherits <- base::inherits
[11:02:38.431]                     invokeRestart <- base::invokeRestart
[11:02:38.431]                     is.null <- base::is.null
[11:02:38.431]                     muffled <- FALSE
[11:02:38.431]                     if (inherits(cond, "message")) {
[11:02:38.431]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:38.431]                       if (muffled) 
[11:02:38.431]                         invokeRestart("muffleMessage")
[11:02:38.431]                     }
[11:02:38.431]                     else if (inherits(cond, "warning")) {
[11:02:38.431]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:38.431]                       if (muffled) 
[11:02:38.431]                         invokeRestart("muffleWarning")
[11:02:38.431]                     }
[11:02:38.431]                     else if (inherits(cond, "condition")) {
[11:02:38.431]                       if (!is.null(pattern)) {
[11:02:38.431]                         computeRestarts <- base::computeRestarts
[11:02:38.431]                         grepl <- base::grepl
[11:02:38.431]                         restarts <- computeRestarts(cond)
[11:02:38.431]                         for (restart in restarts) {
[11:02:38.431]                           name <- restart$name
[11:02:38.431]                           if (is.null(name)) 
[11:02:38.431]                             next
[11:02:38.431]                           if (!grepl(pattern, name)) 
[11:02:38.431]                             next
[11:02:38.431]                           invokeRestart(restart)
[11:02:38.431]                           muffled <- TRUE
[11:02:38.431]                           break
[11:02:38.431]                         }
[11:02:38.431]                       }
[11:02:38.431]                     }
[11:02:38.431]                     invisible(muffled)
[11:02:38.431]                   }
[11:02:38.431]                   muffleCondition(cond)
[11:02:38.431]                 })
[11:02:38.431]             }))
[11:02:38.431]             future::FutureResult(value = ...future.value$value, 
[11:02:38.431]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:38.431]                   ...future.rng), globalenv = if (FALSE) 
[11:02:38.431]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:38.431]                     ...future.globalenv.names))
[11:02:38.431]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:38.431]         }, condition = base::local({
[11:02:38.431]             c <- base::c
[11:02:38.431]             inherits <- base::inherits
[11:02:38.431]             invokeRestart <- base::invokeRestart
[11:02:38.431]             length <- base::length
[11:02:38.431]             list <- base::list
[11:02:38.431]             seq.int <- base::seq.int
[11:02:38.431]             signalCondition <- base::signalCondition
[11:02:38.431]             sys.calls <- base::sys.calls
[11:02:38.431]             `[[` <- base::`[[`
[11:02:38.431]             `+` <- base::`+`
[11:02:38.431]             `<<-` <- base::`<<-`
[11:02:38.431]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:38.431]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:38.431]                   3L)]
[11:02:38.431]             }
[11:02:38.431]             function(cond) {
[11:02:38.431]                 is_error <- inherits(cond, "error")
[11:02:38.431]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:38.431]                   NULL)
[11:02:38.431]                 if (is_error) {
[11:02:38.431]                   sessionInformation <- function() {
[11:02:38.431]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:38.431]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:38.431]                       search = base::search(), system = base::Sys.info())
[11:02:38.431]                   }
[11:02:38.431]                   ...future.conditions[[length(...future.conditions) + 
[11:02:38.431]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:38.431]                     cond$call), session = sessionInformation(), 
[11:02:38.431]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:38.431]                   signalCondition(cond)
[11:02:38.431]                 }
[11:02:38.431]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:38.431]                 "immediateCondition"))) {
[11:02:38.431]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:38.431]                   ...future.conditions[[length(...future.conditions) + 
[11:02:38.431]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:38.431]                   if (TRUE && !signal) {
[11:02:38.431]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:38.431]                     {
[11:02:38.431]                       inherits <- base::inherits
[11:02:38.431]                       invokeRestart <- base::invokeRestart
[11:02:38.431]                       is.null <- base::is.null
[11:02:38.431]                       muffled <- FALSE
[11:02:38.431]                       if (inherits(cond, "message")) {
[11:02:38.431]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:38.431]                         if (muffled) 
[11:02:38.431]                           invokeRestart("muffleMessage")
[11:02:38.431]                       }
[11:02:38.431]                       else if (inherits(cond, "warning")) {
[11:02:38.431]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:38.431]                         if (muffled) 
[11:02:38.431]                           invokeRestart("muffleWarning")
[11:02:38.431]                       }
[11:02:38.431]                       else if (inherits(cond, "condition")) {
[11:02:38.431]                         if (!is.null(pattern)) {
[11:02:38.431]                           computeRestarts <- base::computeRestarts
[11:02:38.431]                           grepl <- base::grepl
[11:02:38.431]                           restarts <- computeRestarts(cond)
[11:02:38.431]                           for (restart in restarts) {
[11:02:38.431]                             name <- restart$name
[11:02:38.431]                             if (is.null(name)) 
[11:02:38.431]                               next
[11:02:38.431]                             if (!grepl(pattern, name)) 
[11:02:38.431]                               next
[11:02:38.431]                             invokeRestart(restart)
[11:02:38.431]                             muffled <- TRUE
[11:02:38.431]                             break
[11:02:38.431]                           }
[11:02:38.431]                         }
[11:02:38.431]                       }
[11:02:38.431]                       invisible(muffled)
[11:02:38.431]                     }
[11:02:38.431]                     muffleCondition(cond, pattern = "^muffle")
[11:02:38.431]                   }
[11:02:38.431]                 }
[11:02:38.431]                 else {
[11:02:38.431]                   if (TRUE) {
[11:02:38.431]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:38.431]                     {
[11:02:38.431]                       inherits <- base::inherits
[11:02:38.431]                       invokeRestart <- base::invokeRestart
[11:02:38.431]                       is.null <- base::is.null
[11:02:38.431]                       muffled <- FALSE
[11:02:38.431]                       if (inherits(cond, "message")) {
[11:02:38.431]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:38.431]                         if (muffled) 
[11:02:38.431]                           invokeRestart("muffleMessage")
[11:02:38.431]                       }
[11:02:38.431]                       else if (inherits(cond, "warning")) {
[11:02:38.431]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:38.431]                         if (muffled) 
[11:02:38.431]                           invokeRestart("muffleWarning")
[11:02:38.431]                       }
[11:02:38.431]                       else if (inherits(cond, "condition")) {
[11:02:38.431]                         if (!is.null(pattern)) {
[11:02:38.431]                           computeRestarts <- base::computeRestarts
[11:02:38.431]                           grepl <- base::grepl
[11:02:38.431]                           restarts <- computeRestarts(cond)
[11:02:38.431]                           for (restart in restarts) {
[11:02:38.431]                             name <- restart$name
[11:02:38.431]                             if (is.null(name)) 
[11:02:38.431]                               next
[11:02:38.431]                             if (!grepl(pattern, name)) 
[11:02:38.431]                               next
[11:02:38.431]                             invokeRestart(restart)
[11:02:38.431]                             muffled <- TRUE
[11:02:38.431]                             break
[11:02:38.431]                           }
[11:02:38.431]                         }
[11:02:38.431]                       }
[11:02:38.431]                       invisible(muffled)
[11:02:38.431]                     }
[11:02:38.431]                     muffleCondition(cond, pattern = "^muffle")
[11:02:38.431]                   }
[11:02:38.431]                 }
[11:02:38.431]             }
[11:02:38.431]         }))
[11:02:38.431]     }, error = function(ex) {
[11:02:38.431]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:38.431]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:38.431]                 ...future.rng), started = ...future.startTime, 
[11:02:38.431]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:38.431]             version = "1.8"), class = "FutureResult")
[11:02:38.431]     }, finally = {
[11:02:38.431]         if (!identical(...future.workdir, getwd())) 
[11:02:38.431]             setwd(...future.workdir)
[11:02:38.431]         {
[11:02:38.431]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:38.431]                 ...future.oldOptions$nwarnings <- NULL
[11:02:38.431]             }
[11:02:38.431]             base::options(...future.oldOptions)
[11:02:38.431]             if (.Platform$OS.type == "windows") {
[11:02:38.431]                 old_names <- names(...future.oldEnvVars)
[11:02:38.431]                 envs <- base::Sys.getenv()
[11:02:38.431]                 names <- names(envs)
[11:02:38.431]                 common <- intersect(names, old_names)
[11:02:38.431]                 added <- setdiff(names, old_names)
[11:02:38.431]                 removed <- setdiff(old_names, names)
[11:02:38.431]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:38.431]                   envs[common]]
[11:02:38.431]                 NAMES <- toupper(changed)
[11:02:38.431]                 args <- list()
[11:02:38.431]                 for (kk in seq_along(NAMES)) {
[11:02:38.431]                   name <- changed[[kk]]
[11:02:38.431]                   NAME <- NAMES[[kk]]
[11:02:38.431]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:38.431]                     next
[11:02:38.431]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:38.431]                 }
[11:02:38.431]                 NAMES <- toupper(added)
[11:02:38.431]                 for (kk in seq_along(NAMES)) {
[11:02:38.431]                   name <- added[[kk]]
[11:02:38.431]                   NAME <- NAMES[[kk]]
[11:02:38.431]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:38.431]                     next
[11:02:38.431]                   args[[name]] <- ""
[11:02:38.431]                 }
[11:02:38.431]                 NAMES <- toupper(removed)
[11:02:38.431]                 for (kk in seq_along(NAMES)) {
[11:02:38.431]                   name <- removed[[kk]]
[11:02:38.431]                   NAME <- NAMES[[kk]]
[11:02:38.431]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:38.431]                     next
[11:02:38.431]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:38.431]                 }
[11:02:38.431]                 if (length(args) > 0) 
[11:02:38.431]                   base::do.call(base::Sys.setenv, args = args)
[11:02:38.431]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:38.431]             }
[11:02:38.431]             else {
[11:02:38.431]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:38.431]             }
[11:02:38.431]             {
[11:02:38.431]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:38.431]                   0L) {
[11:02:38.431]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:38.431]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:38.431]                   base::options(opts)
[11:02:38.431]                 }
[11:02:38.431]                 {
[11:02:38.431]                   {
[11:02:38.431]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:38.431]                     NULL
[11:02:38.431]                   }
[11:02:38.431]                   options(future.plan = NULL)
[11:02:38.431]                   if (is.na(NA_character_)) 
[11:02:38.431]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:38.431]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:38.431]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:38.431]                     .init = FALSE)
[11:02:38.431]                 }
[11:02:38.431]             }
[11:02:38.431]         }
[11:02:38.431]     })
[11:02:38.431]     if (TRUE) {
[11:02:38.431]         base::sink(type = "output", split = FALSE)
[11:02:38.431]         if (TRUE) {
[11:02:38.431]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:38.431]         }
[11:02:38.431]         else {
[11:02:38.431]             ...future.result["stdout"] <- base::list(NULL)
[11:02:38.431]         }
[11:02:38.431]         base::close(...future.stdout)
[11:02:38.431]         ...future.stdout <- NULL
[11:02:38.431]     }
[11:02:38.431]     ...future.result$conditions <- ...future.conditions
[11:02:38.431]     ...future.result$finished <- base::Sys.time()
[11:02:38.431]     ...future.result
[11:02:38.431] }
[11:02:38.433] requestCore(): workers = 2
[11:02:38.434] Poll #1 (0): usedCores() = 2, workers = 2
[11:02:38.444] result() for MulticoreFuture ...
[11:02:38.445] result() for MulticoreFuture ...
[11:02:38.445] result() for MulticoreFuture ... done
[11:02:38.445] result() for MulticoreFuture ... done
[11:02:38.446] result() for MulticoreFuture ...
[11:02:38.446] result() for MulticoreFuture ... done
[11:02:38.448] MulticoreFuture started
[11:02:38.448] - Launch lazy future ... done
[11:02:38.449] run() for ‘MulticoreFuture’ ... done
[11:02:38.449] plan(): Setting new future strategy stack:
[11:02:38.450] resolve() on list ...
[11:02:38.450]  recursive: 0
[11:02:38.450]  length: 1
[11:02:38.450] 
[11:02:38.449] List of future strategies:
[11:02:38.449] 1. sequential:
[11:02:38.449]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:38.449]    - tweaked: FALSE
[11:02:38.449]    - call: NULL
[11:02:38.451] plan(): nbrOfWorkers() = 1
[11:02:38.451] Future #1
[11:02:38.452]  length: 0 (resolved future 1)
[11:02:38.452] resolve() on list ... DONE
[11:02:38.453] resolve() on list ...
[11:02:38.453]  recursive: 0
[11:02:38.453]  length: 1
[11:02:38.453] 
[11:02:38.955] plan(): Setting new future strategy stack:
[11:02:38.955] List of future strategies:
[11:02:38.955] 1. multicore:
[11:02:38.955]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:38.955]    - tweaked: FALSE
[11:02:38.955]    - call: plan(strategy)
[11:02:38.958] plan(): nbrOfWorkers() = 2
[11:02:38.964] Future #1
[11:02:38.964]  length: 0 (resolved future 1)
[11:02:38.965] resolve() on list ... DONE
[11:02:38.965] resolve() on list ...
[11:02:38.965]  recursive: 0
[11:02:38.965]  length: 1
[11:02:38.966] 
[11:02:38.966]  length: 0 (resolved future 1)
[11:02:38.966] resolve() on list ... DONE
[11:02:38.966] resolve() on list ...
[11:02:38.966]  recursive: 0
[11:02:38.967]  length: 4
[11:02:38.967] 
[11:02:38.967] Future #1
[11:02:38.967]  length: 3 (resolved future 1)
[11:02:38.967] Future #2
[11:02:38.968]  length: 2 (resolved future 2)
[11:02:38.968]  length: 1 (resolved future 3)
[11:02:38.968]  length: 0 (resolved future 4)
[11:02:38.968] resolve() on list ... DONE
[11:02:38.968] resolve() on list ...
[11:02:38.969]  recursive: 0
[11:02:38.969]  length: 4
[11:02:38.969] 
[11:02:38.969] Future #1
[11:02:38.969]  length: 3 (resolved future 1)
[11:02:38.970] Future #2
[11:02:38.970]  length: 2 (resolved future 2)
[11:02:38.970]  length: 1 (resolved future 3)
[11:02:38.970]  length: 0 (resolved future 4)
[11:02:38.970] resolve() on list ... DONE
[11:02:38.971] resolve() on list ...
[11:02:38.971]  recursive: 0
[11:02:38.971]  length: 1
[11:02:38.971] 
[11:02:38.971]  length: 0 (resolved future 1)
[11:02:38.971] resolve() on list ... DONE
[11:02:38.971] getGlobalsAndPackages() ...
[11:02:38.972] Searching for globals...
[11:02:38.973] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[11:02:38.974] Searching for globals ... DONE
[11:02:38.974] Resolving globals: FALSE
[11:02:38.974] The total size of the 1 globals is 35 bytes (35 bytes)
[11:02:38.975] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[11:02:38.975] - globals: [1] ‘kk’
[11:02:38.975] 
[11:02:38.975] getGlobalsAndPackages() ... DONE
[11:02:38.976] run() for ‘Future’ ...
[11:02:38.976] - state: ‘created’
[11:02:38.976] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:02:38.979] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:38.979] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:02:38.979]   - Field: ‘label’
[11:02:38.979]   - Field: ‘local’
[11:02:38.979]   - Field: ‘owner’
[11:02:38.979]   - Field: ‘envir’
[11:02:38.979]   - Field: ‘workers’
[11:02:38.979]   - Field: ‘packages’
[11:02:38.980]   - Field: ‘gc’
[11:02:38.980]   - Field: ‘job’
[11:02:38.980]   - Field: ‘conditions’
[11:02:38.980]   - Field: ‘expr’
[11:02:38.980]   - Field: ‘uuid’
[11:02:38.980]   - Field: ‘seed’
[11:02:38.981]   - Field: ‘version’
[11:02:38.981]   - Field: ‘result’
[11:02:38.981]   - Field: ‘asynchronous’
[11:02:38.981]   - Field: ‘calls’
[11:02:38.981]   - Field: ‘globals’
[11:02:38.981]   - Field: ‘stdout’
[11:02:38.981]   - Field: ‘earlySignal’
[11:02:38.982]   - Field: ‘lazy’
[11:02:38.982]   - Field: ‘state’
[11:02:38.982] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:02:38.982] - Launch lazy future ...
[11:02:38.982] Packages needed by the future expression (n = 0): <none>
[11:02:38.982] Packages needed by future strategies (n = 0): <none>
[11:02:38.983] {
[11:02:38.983]     {
[11:02:38.983]         {
[11:02:38.983]             ...future.startTime <- base::Sys.time()
[11:02:38.983]             {
[11:02:38.983]                 {
[11:02:38.983]                   {
[11:02:38.983]                     {
[11:02:38.983]                       base::local({
[11:02:38.983]                         has_future <- base::requireNamespace("future", 
[11:02:38.983]                           quietly = TRUE)
[11:02:38.983]                         if (has_future) {
[11:02:38.983]                           ns <- base::getNamespace("future")
[11:02:38.983]                           version <- ns[[".package"]][["version"]]
[11:02:38.983]                           if (is.null(version)) 
[11:02:38.983]                             version <- utils::packageVersion("future")
[11:02:38.983]                         }
[11:02:38.983]                         else {
[11:02:38.983]                           version <- NULL
[11:02:38.983]                         }
[11:02:38.983]                         if (!has_future || version < "1.8.0") {
[11:02:38.983]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:38.983]                             "", base::R.version$version.string), 
[11:02:38.983]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:38.983]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:38.983]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:38.983]                               "release", "version")], collapse = " "), 
[11:02:38.983]                             hostname = base::Sys.info()[["nodename"]])
[11:02:38.983]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:38.983]                             info)
[11:02:38.983]                           info <- base::paste(info, collapse = "; ")
[11:02:38.983]                           if (!has_future) {
[11:02:38.983]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:38.983]                               info)
[11:02:38.983]                           }
[11:02:38.983]                           else {
[11:02:38.983]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:38.983]                               info, version)
[11:02:38.983]                           }
[11:02:38.983]                           base::stop(msg)
[11:02:38.983]                         }
[11:02:38.983]                       })
[11:02:38.983]                     }
[11:02:38.983]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:38.983]                     base::options(mc.cores = 1L)
[11:02:38.983]                   }
[11:02:38.983]                   ...future.strategy.old <- future::plan("list")
[11:02:38.983]                   options(future.plan = NULL)
[11:02:38.983]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:38.983]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:38.983]                 }
[11:02:38.983]                 ...future.workdir <- getwd()
[11:02:38.983]             }
[11:02:38.983]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:38.983]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:38.983]         }
[11:02:38.983]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:38.983]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:38.983]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:38.983]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:38.983]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:38.983]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:38.983]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:38.983]             base::names(...future.oldOptions))
[11:02:38.983]     }
[11:02:38.983]     if (FALSE) {
[11:02:38.983]     }
[11:02:38.983]     else {
[11:02:38.983]         if (TRUE) {
[11:02:38.983]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:38.983]                 open = "w")
[11:02:38.983]         }
[11:02:38.983]         else {
[11:02:38.983]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:38.983]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:38.983]         }
[11:02:38.983]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:38.983]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:38.983]             base::sink(type = "output", split = FALSE)
[11:02:38.983]             base::close(...future.stdout)
[11:02:38.983]         }, add = TRUE)
[11:02:38.983]     }
[11:02:38.983]     ...future.frame <- base::sys.nframe()
[11:02:38.983]     ...future.conditions <- base::list()
[11:02:38.983]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:38.983]     if (FALSE) {
[11:02:38.983]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:38.983]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:38.983]     }
[11:02:38.983]     ...future.result <- base::tryCatch({
[11:02:38.983]         base::withCallingHandlers({
[11:02:38.983]             ...future.value <- base::withVisible(base::local({
[11:02:38.983]                 withCallingHandlers({
[11:02:38.983]                   {
[11:02:38.983]                     Sys.sleep(0.1)
[11:02:38.983]                     kk
[11:02:38.983]                   }
[11:02:38.983]                 }, immediateCondition = function(cond) {
[11:02:38.983]                   save_rds <- function (object, pathname, ...) 
[11:02:38.983]                   {
[11:02:38.983]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:02:38.983]                     if (file_test("-f", pathname_tmp)) {
[11:02:38.983]                       fi_tmp <- file.info(pathname_tmp)
[11:02:38.983]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:02:38.983]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:38.983]                         fi_tmp[["mtime"]])
[11:02:38.983]                     }
[11:02:38.983]                     tryCatch({
[11:02:38.983]                       saveRDS(object, file = pathname_tmp, ...)
[11:02:38.983]                     }, error = function(ex) {
[11:02:38.983]                       msg <- conditionMessage(ex)
[11:02:38.983]                       fi_tmp <- file.info(pathname_tmp)
[11:02:38.983]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:02:38.983]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:38.983]                         fi_tmp[["mtime"]], msg)
[11:02:38.983]                       ex$message <- msg
[11:02:38.983]                       stop(ex)
[11:02:38.983]                     })
[11:02:38.983]                     stopifnot(file_test("-f", pathname_tmp))
[11:02:38.983]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:02:38.983]                     if (!res || file_test("-f", pathname_tmp)) {
[11:02:38.983]                       fi_tmp <- file.info(pathname_tmp)
[11:02:38.983]                       fi <- file.info(pathname)
[11:02:38.983]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:02:38.983]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:38.983]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:02:38.983]                         fi[["size"]], fi[["mtime"]])
[11:02:38.983]                       stop(msg)
[11:02:38.983]                     }
[11:02:38.983]                     invisible(pathname)
[11:02:38.983]                   }
[11:02:38.983]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:02:38.983]                     rootPath = tempdir()) 
[11:02:38.983]                   {
[11:02:38.983]                     obj <- list(time = Sys.time(), condition = cond)
[11:02:38.983]                     file <- tempfile(pattern = class(cond)[1], 
[11:02:38.983]                       tmpdir = path, fileext = ".rds")
[11:02:38.983]                     save_rds(obj, file)
[11:02:38.983]                   }
[11:02:38.983]                   saveImmediateCondition(cond, path = "/tmp/RtmpPVwpFC/.future/immediateConditions")
[11:02:38.983]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:38.983]                   {
[11:02:38.983]                     inherits <- base::inherits
[11:02:38.983]                     invokeRestart <- base::invokeRestart
[11:02:38.983]                     is.null <- base::is.null
[11:02:38.983]                     muffled <- FALSE
[11:02:38.983]                     if (inherits(cond, "message")) {
[11:02:38.983]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:38.983]                       if (muffled) 
[11:02:38.983]                         invokeRestart("muffleMessage")
[11:02:38.983]                     }
[11:02:38.983]                     else if (inherits(cond, "warning")) {
[11:02:38.983]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:38.983]                       if (muffled) 
[11:02:38.983]                         invokeRestart("muffleWarning")
[11:02:38.983]                     }
[11:02:38.983]                     else if (inherits(cond, "condition")) {
[11:02:38.983]                       if (!is.null(pattern)) {
[11:02:38.983]                         computeRestarts <- base::computeRestarts
[11:02:38.983]                         grepl <- base::grepl
[11:02:38.983]                         restarts <- computeRestarts(cond)
[11:02:38.983]                         for (restart in restarts) {
[11:02:38.983]                           name <- restart$name
[11:02:38.983]                           if (is.null(name)) 
[11:02:38.983]                             next
[11:02:38.983]                           if (!grepl(pattern, name)) 
[11:02:38.983]                             next
[11:02:38.983]                           invokeRestart(restart)
[11:02:38.983]                           muffled <- TRUE
[11:02:38.983]                           break
[11:02:38.983]                         }
[11:02:38.983]                       }
[11:02:38.983]                     }
[11:02:38.983]                     invisible(muffled)
[11:02:38.983]                   }
[11:02:38.983]                   muffleCondition(cond)
[11:02:38.983]                 })
[11:02:38.983]             }))
[11:02:38.983]             future::FutureResult(value = ...future.value$value, 
[11:02:38.983]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:38.983]                   ...future.rng), globalenv = if (FALSE) 
[11:02:38.983]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:38.983]                     ...future.globalenv.names))
[11:02:38.983]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:38.983]         }, condition = base::local({
[11:02:38.983]             c <- base::c
[11:02:38.983]             inherits <- base::inherits
[11:02:38.983]             invokeRestart <- base::invokeRestart
[11:02:38.983]             length <- base::length
[11:02:38.983]             list <- base::list
[11:02:38.983]             seq.int <- base::seq.int
[11:02:38.983]             signalCondition <- base::signalCondition
[11:02:38.983]             sys.calls <- base::sys.calls
[11:02:38.983]             `[[` <- base::`[[`
[11:02:38.983]             `+` <- base::`+`
[11:02:38.983]             `<<-` <- base::`<<-`
[11:02:38.983]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:38.983]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:38.983]                   3L)]
[11:02:38.983]             }
[11:02:38.983]             function(cond) {
[11:02:38.983]                 is_error <- inherits(cond, "error")
[11:02:38.983]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:38.983]                   NULL)
[11:02:38.983]                 if (is_error) {
[11:02:38.983]                   sessionInformation <- function() {
[11:02:38.983]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:38.983]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:38.983]                       search = base::search(), system = base::Sys.info())
[11:02:38.983]                   }
[11:02:38.983]                   ...future.conditions[[length(...future.conditions) + 
[11:02:38.983]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:38.983]                     cond$call), session = sessionInformation(), 
[11:02:38.983]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:38.983]                   signalCondition(cond)
[11:02:38.983]                 }
[11:02:38.983]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:38.983]                 "immediateCondition"))) {
[11:02:38.983]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:38.983]                   ...future.conditions[[length(...future.conditions) + 
[11:02:38.983]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:38.983]                   if (TRUE && !signal) {
[11:02:38.983]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:38.983]                     {
[11:02:38.983]                       inherits <- base::inherits
[11:02:38.983]                       invokeRestart <- base::invokeRestart
[11:02:38.983]                       is.null <- base::is.null
[11:02:38.983]                       muffled <- FALSE
[11:02:38.983]                       if (inherits(cond, "message")) {
[11:02:38.983]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:38.983]                         if (muffled) 
[11:02:38.983]                           invokeRestart("muffleMessage")
[11:02:38.983]                       }
[11:02:38.983]                       else if (inherits(cond, "warning")) {
[11:02:38.983]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:38.983]                         if (muffled) 
[11:02:38.983]                           invokeRestart("muffleWarning")
[11:02:38.983]                       }
[11:02:38.983]                       else if (inherits(cond, "condition")) {
[11:02:38.983]                         if (!is.null(pattern)) {
[11:02:38.983]                           computeRestarts <- base::computeRestarts
[11:02:38.983]                           grepl <- base::grepl
[11:02:38.983]                           restarts <- computeRestarts(cond)
[11:02:38.983]                           for (restart in restarts) {
[11:02:38.983]                             name <- restart$name
[11:02:38.983]                             if (is.null(name)) 
[11:02:38.983]                               next
[11:02:38.983]                             if (!grepl(pattern, name)) 
[11:02:38.983]                               next
[11:02:38.983]                             invokeRestart(restart)
[11:02:38.983]                             muffled <- TRUE
[11:02:38.983]                             break
[11:02:38.983]                           }
[11:02:38.983]                         }
[11:02:38.983]                       }
[11:02:38.983]                       invisible(muffled)
[11:02:38.983]                     }
[11:02:38.983]                     muffleCondition(cond, pattern = "^muffle")
[11:02:38.983]                   }
[11:02:38.983]                 }
[11:02:38.983]                 else {
[11:02:38.983]                   if (TRUE) {
[11:02:38.983]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:38.983]                     {
[11:02:38.983]                       inherits <- base::inherits
[11:02:38.983]                       invokeRestart <- base::invokeRestart
[11:02:38.983]                       is.null <- base::is.null
[11:02:38.983]                       muffled <- FALSE
[11:02:38.983]                       if (inherits(cond, "message")) {
[11:02:38.983]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:38.983]                         if (muffled) 
[11:02:38.983]                           invokeRestart("muffleMessage")
[11:02:38.983]                       }
[11:02:38.983]                       else if (inherits(cond, "warning")) {
[11:02:38.983]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:38.983]                         if (muffled) 
[11:02:38.983]                           invokeRestart("muffleWarning")
[11:02:38.983]                       }
[11:02:38.983]                       else if (inherits(cond, "condition")) {
[11:02:38.983]                         if (!is.null(pattern)) {
[11:02:38.983]                           computeRestarts <- base::computeRestarts
[11:02:38.983]                           grepl <- base::grepl
[11:02:38.983]                           restarts <- computeRestarts(cond)
[11:02:38.983]                           for (restart in restarts) {
[11:02:38.983]                             name <- restart$name
[11:02:38.983]                             if (is.null(name)) 
[11:02:38.983]                               next
[11:02:38.983]                             if (!grepl(pattern, name)) 
[11:02:38.983]                               next
[11:02:38.983]                             invokeRestart(restart)
[11:02:38.983]                             muffled <- TRUE
[11:02:38.983]                             break
[11:02:38.983]                           }
[11:02:38.983]                         }
[11:02:38.983]                       }
[11:02:38.983]                       invisible(muffled)
[11:02:38.983]                     }
[11:02:38.983]                     muffleCondition(cond, pattern = "^muffle")
[11:02:38.983]                   }
[11:02:38.983]                 }
[11:02:38.983]             }
[11:02:38.983]         }))
[11:02:38.983]     }, error = function(ex) {
[11:02:38.983]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:38.983]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:38.983]                 ...future.rng), started = ...future.startTime, 
[11:02:38.983]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:38.983]             version = "1.8"), class = "FutureResult")
[11:02:38.983]     }, finally = {
[11:02:38.983]         if (!identical(...future.workdir, getwd())) 
[11:02:38.983]             setwd(...future.workdir)
[11:02:38.983]         {
[11:02:38.983]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:38.983]                 ...future.oldOptions$nwarnings <- NULL
[11:02:38.983]             }
[11:02:38.983]             base::options(...future.oldOptions)
[11:02:38.983]             if (.Platform$OS.type == "windows") {
[11:02:38.983]                 old_names <- names(...future.oldEnvVars)
[11:02:38.983]                 envs <- base::Sys.getenv()
[11:02:38.983]                 names <- names(envs)
[11:02:38.983]                 common <- intersect(names, old_names)
[11:02:38.983]                 added <- setdiff(names, old_names)
[11:02:38.983]                 removed <- setdiff(old_names, names)
[11:02:38.983]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:38.983]                   envs[common]]
[11:02:38.983]                 NAMES <- toupper(changed)
[11:02:38.983]                 args <- list()
[11:02:38.983]                 for (kk in seq_along(NAMES)) {
[11:02:38.983]                   name <- changed[[kk]]
[11:02:38.983]                   NAME <- NAMES[[kk]]
[11:02:38.983]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:38.983]                     next
[11:02:38.983]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:38.983]                 }
[11:02:38.983]                 NAMES <- toupper(added)
[11:02:38.983]                 for (kk in seq_along(NAMES)) {
[11:02:38.983]                   name <- added[[kk]]
[11:02:38.983]                   NAME <- NAMES[[kk]]
[11:02:38.983]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:38.983]                     next
[11:02:38.983]                   args[[name]] <- ""
[11:02:38.983]                 }
[11:02:38.983]                 NAMES <- toupper(removed)
[11:02:38.983]                 for (kk in seq_along(NAMES)) {
[11:02:38.983]                   name <- removed[[kk]]
[11:02:38.983]                   NAME <- NAMES[[kk]]
[11:02:38.983]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:38.983]                     next
[11:02:38.983]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:38.983]                 }
[11:02:38.983]                 if (length(args) > 0) 
[11:02:38.983]                   base::do.call(base::Sys.setenv, args = args)
[11:02:38.983]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:38.983]             }
[11:02:38.983]             else {
[11:02:38.983]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:38.983]             }
[11:02:38.983]             {
[11:02:38.983]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:38.983]                   0L) {
[11:02:38.983]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:38.983]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:38.983]                   base::options(opts)
[11:02:38.983]                 }
[11:02:38.983]                 {
[11:02:38.983]                   {
[11:02:38.983]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:38.983]                     NULL
[11:02:38.983]                   }
[11:02:38.983]                   options(future.plan = NULL)
[11:02:38.983]                   if (is.na(NA_character_)) 
[11:02:38.983]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:38.983]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:38.983]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:38.983]                     .init = FALSE)
[11:02:38.983]                 }
[11:02:38.983]             }
[11:02:38.983]         }
[11:02:38.983]     })
[11:02:38.983]     if (TRUE) {
[11:02:38.983]         base::sink(type = "output", split = FALSE)
[11:02:38.983]         if (TRUE) {
[11:02:38.983]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:38.983]         }
[11:02:38.983]         else {
[11:02:38.983]             ...future.result["stdout"] <- base::list(NULL)
[11:02:38.983]         }
[11:02:38.983]         base::close(...future.stdout)
[11:02:38.983]         ...future.stdout <- NULL
[11:02:38.983]     }
[11:02:38.983]     ...future.result$conditions <- ...future.conditions
[11:02:38.983]     ...future.result$finished <- base::Sys.time()
[11:02:38.983]     ...future.result
[11:02:38.983] }
[11:02:38.986] assign_globals() ...
[11:02:38.986] List of 1
[11:02:38.986]  $ kk: int 1
[11:02:38.986]  - attr(*, "where")=List of 1
[11:02:38.986]   ..$ kk:<environment: R_EmptyEnv> 
[11:02:38.986]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:02:38.986]  - attr(*, "resolved")= logi FALSE
[11:02:38.986]  - attr(*, "total_size")= num 35
[11:02:38.986]  - attr(*, "already-done")= logi TRUE
[11:02:38.992] - copied ‘kk’ to environment
[11:02:38.992] assign_globals() ... done
[11:02:38.992] requestCore(): workers = 2
[11:02:38.993] Poll #1 (0): usedCores() = 2, workers = 2
[11:02:39.004] result() for MulticoreFuture ...
[11:02:39.005] result() for MulticoreFuture ...
[11:02:39.005] result() for MulticoreFuture ... done
[11:02:39.005] result() for MulticoreFuture ... done
[11:02:39.005] result() for MulticoreFuture ...
[11:02:39.005] result() for MulticoreFuture ... done
[11:02:39.008] MulticoreFuture started
[11:02:39.008] - Launch lazy future ... done
[11:02:39.009] run() for ‘MulticoreFuture’ ... done
[11:02:39.009] plan(): Setting new future strategy stack:
[11:02:39.010] getGlobalsAndPackages() ...
[11:02:39.010] Searching for globals...
[11:02:39.010] List of future strategies:
[11:02:39.010] 1. sequential:
[11:02:39.010]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:39.010]    - tweaked: FALSE
[11:02:39.010]    - call: NULL
[11:02:39.011] plan(): nbrOfWorkers() = 1
[11:02:39.014] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[11:02:39.014] Searching for globals ... DONE
[11:02:39.014] Resolving globals: FALSE
[11:02:39.015] The total size of the 1 globals is 35 bytes (35 bytes)
[11:02:39.016] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[11:02:39.016] - globals: [1] ‘kk’
[11:02:39.016] 
[11:02:39.016] getGlobalsAndPackages() ... DONE
[11:02:39.017] run() for ‘Future’ ...
[11:02:39.017] - state: ‘created’
[11:02:39.017] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:02:39.020] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:39.020] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:02:39.021]   - Field: ‘label’
[11:02:39.021]   - Field: ‘local’
[11:02:39.021]   - Field: ‘owner’
[11:02:39.021]   - Field: ‘envir’
[11:02:39.021]   - Field: ‘workers’
[11:02:39.022]   - Field: ‘packages’
[11:02:39.022]   - Field: ‘gc’
[11:02:39.022]   - Field: ‘job’
[11:02:39.022]   - Field: ‘conditions’
[11:02:39.022]   - Field: ‘expr’
[11:02:39.022]   - Field: ‘uuid’
[11:02:39.023]   - Field: ‘seed’
[11:02:39.023]   - Field: ‘version’
[11:02:39.023]   - Field: ‘result’
[11:02:39.023]   - Field: ‘asynchronous’
[11:02:39.023]   - Field: ‘calls’
[11:02:39.023]   - Field: ‘globals’
[11:02:39.023]   - Field: ‘stdout’
[11:02:39.023]   - Field: ‘earlySignal’
[11:02:39.024]   - Field: ‘lazy’
[11:02:39.024]   - Field: ‘state’
[11:02:39.024] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:02:39.024] - Launch lazy future ...
[11:02:39.024] Packages needed by the future expression (n = 0): <none>
[11:02:39.025] Packages needed by future strategies (n = 0): <none>
[11:02:39.025] {
[11:02:39.025]     {
[11:02:39.025]         {
[11:02:39.025]             ...future.startTime <- base::Sys.time()
[11:02:39.025]             {
[11:02:39.025]                 {
[11:02:39.025]                   {
[11:02:39.025]                     {
[11:02:39.025]                       base::local({
[11:02:39.025]                         has_future <- base::requireNamespace("future", 
[11:02:39.025]                           quietly = TRUE)
[11:02:39.025]                         if (has_future) {
[11:02:39.025]                           ns <- base::getNamespace("future")
[11:02:39.025]                           version <- ns[[".package"]][["version"]]
[11:02:39.025]                           if (is.null(version)) 
[11:02:39.025]                             version <- utils::packageVersion("future")
[11:02:39.025]                         }
[11:02:39.025]                         else {
[11:02:39.025]                           version <- NULL
[11:02:39.025]                         }
[11:02:39.025]                         if (!has_future || version < "1.8.0") {
[11:02:39.025]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:39.025]                             "", base::R.version$version.string), 
[11:02:39.025]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:39.025]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:39.025]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:39.025]                               "release", "version")], collapse = " "), 
[11:02:39.025]                             hostname = base::Sys.info()[["nodename"]])
[11:02:39.025]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:39.025]                             info)
[11:02:39.025]                           info <- base::paste(info, collapse = "; ")
[11:02:39.025]                           if (!has_future) {
[11:02:39.025]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:39.025]                               info)
[11:02:39.025]                           }
[11:02:39.025]                           else {
[11:02:39.025]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:39.025]                               info, version)
[11:02:39.025]                           }
[11:02:39.025]                           base::stop(msg)
[11:02:39.025]                         }
[11:02:39.025]                       })
[11:02:39.025]                     }
[11:02:39.025]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:39.025]                     base::options(mc.cores = 1L)
[11:02:39.025]                   }
[11:02:39.025]                   ...future.strategy.old <- future::plan("list")
[11:02:39.025]                   options(future.plan = NULL)
[11:02:39.025]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:39.025]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:39.025]                 }
[11:02:39.025]                 ...future.workdir <- getwd()
[11:02:39.025]             }
[11:02:39.025]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:39.025]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:39.025]         }
[11:02:39.025]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:39.025]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:39.025]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:39.025]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:39.025]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:39.025]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:39.025]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:39.025]             base::names(...future.oldOptions))
[11:02:39.025]     }
[11:02:39.025]     if (FALSE) {
[11:02:39.025]     }
[11:02:39.025]     else {
[11:02:39.025]         if (TRUE) {
[11:02:39.025]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:39.025]                 open = "w")
[11:02:39.025]         }
[11:02:39.025]         else {
[11:02:39.025]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:39.025]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:39.025]         }
[11:02:39.025]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:39.025]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:39.025]             base::sink(type = "output", split = FALSE)
[11:02:39.025]             base::close(...future.stdout)
[11:02:39.025]         }, add = TRUE)
[11:02:39.025]     }
[11:02:39.025]     ...future.frame <- base::sys.nframe()
[11:02:39.025]     ...future.conditions <- base::list()
[11:02:39.025]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:39.025]     if (FALSE) {
[11:02:39.025]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:39.025]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:39.025]     }
[11:02:39.025]     ...future.result <- base::tryCatch({
[11:02:39.025]         base::withCallingHandlers({
[11:02:39.025]             ...future.value <- base::withVisible(base::local({
[11:02:39.025]                 withCallingHandlers({
[11:02:39.025]                   {
[11:02:39.025]                     Sys.sleep(0.1)
[11:02:39.025]                     kk
[11:02:39.025]                   }
[11:02:39.025]                 }, immediateCondition = function(cond) {
[11:02:39.025]                   save_rds <- function (object, pathname, ...) 
[11:02:39.025]                   {
[11:02:39.025]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:02:39.025]                     if (file_test("-f", pathname_tmp)) {
[11:02:39.025]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.025]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:02:39.025]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.025]                         fi_tmp[["mtime"]])
[11:02:39.025]                     }
[11:02:39.025]                     tryCatch({
[11:02:39.025]                       saveRDS(object, file = pathname_tmp, ...)
[11:02:39.025]                     }, error = function(ex) {
[11:02:39.025]                       msg <- conditionMessage(ex)
[11:02:39.025]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.025]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:02:39.025]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.025]                         fi_tmp[["mtime"]], msg)
[11:02:39.025]                       ex$message <- msg
[11:02:39.025]                       stop(ex)
[11:02:39.025]                     })
[11:02:39.025]                     stopifnot(file_test("-f", pathname_tmp))
[11:02:39.025]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:02:39.025]                     if (!res || file_test("-f", pathname_tmp)) {
[11:02:39.025]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.025]                       fi <- file.info(pathname)
[11:02:39.025]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:02:39.025]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.025]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:02:39.025]                         fi[["size"]], fi[["mtime"]])
[11:02:39.025]                       stop(msg)
[11:02:39.025]                     }
[11:02:39.025]                     invisible(pathname)
[11:02:39.025]                   }
[11:02:39.025]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:02:39.025]                     rootPath = tempdir()) 
[11:02:39.025]                   {
[11:02:39.025]                     obj <- list(time = Sys.time(), condition = cond)
[11:02:39.025]                     file <- tempfile(pattern = class(cond)[1], 
[11:02:39.025]                       tmpdir = path, fileext = ".rds")
[11:02:39.025]                     save_rds(obj, file)
[11:02:39.025]                   }
[11:02:39.025]                   saveImmediateCondition(cond, path = "/tmp/RtmpPVwpFC/.future/immediateConditions")
[11:02:39.025]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.025]                   {
[11:02:39.025]                     inherits <- base::inherits
[11:02:39.025]                     invokeRestart <- base::invokeRestart
[11:02:39.025]                     is.null <- base::is.null
[11:02:39.025]                     muffled <- FALSE
[11:02:39.025]                     if (inherits(cond, "message")) {
[11:02:39.025]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:39.025]                       if (muffled) 
[11:02:39.025]                         invokeRestart("muffleMessage")
[11:02:39.025]                     }
[11:02:39.025]                     else if (inherits(cond, "warning")) {
[11:02:39.025]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:39.025]                       if (muffled) 
[11:02:39.025]                         invokeRestart("muffleWarning")
[11:02:39.025]                     }
[11:02:39.025]                     else if (inherits(cond, "condition")) {
[11:02:39.025]                       if (!is.null(pattern)) {
[11:02:39.025]                         computeRestarts <- base::computeRestarts
[11:02:39.025]                         grepl <- base::grepl
[11:02:39.025]                         restarts <- computeRestarts(cond)
[11:02:39.025]                         for (restart in restarts) {
[11:02:39.025]                           name <- restart$name
[11:02:39.025]                           if (is.null(name)) 
[11:02:39.025]                             next
[11:02:39.025]                           if (!grepl(pattern, name)) 
[11:02:39.025]                             next
[11:02:39.025]                           invokeRestart(restart)
[11:02:39.025]                           muffled <- TRUE
[11:02:39.025]                           break
[11:02:39.025]                         }
[11:02:39.025]                       }
[11:02:39.025]                     }
[11:02:39.025]                     invisible(muffled)
[11:02:39.025]                   }
[11:02:39.025]                   muffleCondition(cond)
[11:02:39.025]                 })
[11:02:39.025]             }))
[11:02:39.025]             future::FutureResult(value = ...future.value$value, 
[11:02:39.025]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:39.025]                   ...future.rng), globalenv = if (FALSE) 
[11:02:39.025]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:39.025]                     ...future.globalenv.names))
[11:02:39.025]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:39.025]         }, condition = base::local({
[11:02:39.025]             c <- base::c
[11:02:39.025]             inherits <- base::inherits
[11:02:39.025]             invokeRestart <- base::invokeRestart
[11:02:39.025]             length <- base::length
[11:02:39.025]             list <- base::list
[11:02:39.025]             seq.int <- base::seq.int
[11:02:39.025]             signalCondition <- base::signalCondition
[11:02:39.025]             sys.calls <- base::sys.calls
[11:02:39.025]             `[[` <- base::`[[`
[11:02:39.025]             `+` <- base::`+`
[11:02:39.025]             `<<-` <- base::`<<-`
[11:02:39.025]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:39.025]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:39.025]                   3L)]
[11:02:39.025]             }
[11:02:39.025]             function(cond) {
[11:02:39.025]                 is_error <- inherits(cond, "error")
[11:02:39.025]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:39.025]                   NULL)
[11:02:39.025]                 if (is_error) {
[11:02:39.025]                   sessionInformation <- function() {
[11:02:39.025]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:39.025]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:39.025]                       search = base::search(), system = base::Sys.info())
[11:02:39.025]                   }
[11:02:39.025]                   ...future.conditions[[length(...future.conditions) + 
[11:02:39.025]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:39.025]                     cond$call), session = sessionInformation(), 
[11:02:39.025]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:39.025]                   signalCondition(cond)
[11:02:39.025]                 }
[11:02:39.025]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:39.025]                 "immediateCondition"))) {
[11:02:39.025]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:39.025]                   ...future.conditions[[length(...future.conditions) + 
[11:02:39.025]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:39.025]                   if (TRUE && !signal) {
[11:02:39.025]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.025]                     {
[11:02:39.025]                       inherits <- base::inherits
[11:02:39.025]                       invokeRestart <- base::invokeRestart
[11:02:39.025]                       is.null <- base::is.null
[11:02:39.025]                       muffled <- FALSE
[11:02:39.025]                       if (inherits(cond, "message")) {
[11:02:39.025]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:39.025]                         if (muffled) 
[11:02:39.025]                           invokeRestart("muffleMessage")
[11:02:39.025]                       }
[11:02:39.025]                       else if (inherits(cond, "warning")) {
[11:02:39.025]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:39.025]                         if (muffled) 
[11:02:39.025]                           invokeRestart("muffleWarning")
[11:02:39.025]                       }
[11:02:39.025]                       else if (inherits(cond, "condition")) {
[11:02:39.025]                         if (!is.null(pattern)) {
[11:02:39.025]                           computeRestarts <- base::computeRestarts
[11:02:39.025]                           grepl <- base::grepl
[11:02:39.025]                           restarts <- computeRestarts(cond)
[11:02:39.025]                           for (restart in restarts) {
[11:02:39.025]                             name <- restart$name
[11:02:39.025]                             if (is.null(name)) 
[11:02:39.025]                               next
[11:02:39.025]                             if (!grepl(pattern, name)) 
[11:02:39.025]                               next
[11:02:39.025]                             invokeRestart(restart)
[11:02:39.025]                             muffled <- TRUE
[11:02:39.025]                             break
[11:02:39.025]                           }
[11:02:39.025]                         }
[11:02:39.025]                       }
[11:02:39.025]                       invisible(muffled)
[11:02:39.025]                     }
[11:02:39.025]                     muffleCondition(cond, pattern = "^muffle")
[11:02:39.025]                   }
[11:02:39.025]                 }
[11:02:39.025]                 else {
[11:02:39.025]                   if (TRUE) {
[11:02:39.025]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.025]                     {
[11:02:39.025]                       inherits <- base::inherits
[11:02:39.025]                       invokeRestart <- base::invokeRestart
[11:02:39.025]                       is.null <- base::is.null
[11:02:39.025]                       muffled <- FALSE
[11:02:39.025]                       if (inherits(cond, "message")) {
[11:02:39.025]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:39.025]                         if (muffled) 
[11:02:39.025]                           invokeRestart("muffleMessage")
[11:02:39.025]                       }
[11:02:39.025]                       else if (inherits(cond, "warning")) {
[11:02:39.025]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:39.025]                         if (muffled) 
[11:02:39.025]                           invokeRestart("muffleWarning")
[11:02:39.025]                       }
[11:02:39.025]                       else if (inherits(cond, "condition")) {
[11:02:39.025]                         if (!is.null(pattern)) {
[11:02:39.025]                           computeRestarts <- base::computeRestarts
[11:02:39.025]                           grepl <- base::grepl
[11:02:39.025]                           restarts <- computeRestarts(cond)
[11:02:39.025]                           for (restart in restarts) {
[11:02:39.025]                             name <- restart$name
[11:02:39.025]                             if (is.null(name)) 
[11:02:39.025]                               next
[11:02:39.025]                             if (!grepl(pattern, name)) 
[11:02:39.025]                               next
[11:02:39.025]                             invokeRestart(restart)
[11:02:39.025]                             muffled <- TRUE
[11:02:39.025]                             break
[11:02:39.025]                           }
[11:02:39.025]                         }
[11:02:39.025]                       }
[11:02:39.025]                       invisible(muffled)
[11:02:39.025]                     }
[11:02:39.025]                     muffleCondition(cond, pattern = "^muffle")
[11:02:39.025]                   }
[11:02:39.025]                 }
[11:02:39.025]             }
[11:02:39.025]         }))
[11:02:39.025]     }, error = function(ex) {
[11:02:39.025]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:39.025]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:39.025]                 ...future.rng), started = ...future.startTime, 
[11:02:39.025]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:39.025]             version = "1.8"), class = "FutureResult")
[11:02:39.025]     }, finally = {
[11:02:39.025]         if (!identical(...future.workdir, getwd())) 
[11:02:39.025]             setwd(...future.workdir)
[11:02:39.025]         {
[11:02:39.025]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:39.025]                 ...future.oldOptions$nwarnings <- NULL
[11:02:39.025]             }
[11:02:39.025]             base::options(...future.oldOptions)
[11:02:39.025]             if (.Platform$OS.type == "windows") {
[11:02:39.025]                 old_names <- names(...future.oldEnvVars)
[11:02:39.025]                 envs <- base::Sys.getenv()
[11:02:39.025]                 names <- names(envs)
[11:02:39.025]                 common <- intersect(names, old_names)
[11:02:39.025]                 added <- setdiff(names, old_names)
[11:02:39.025]                 removed <- setdiff(old_names, names)
[11:02:39.025]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:39.025]                   envs[common]]
[11:02:39.025]                 NAMES <- toupper(changed)
[11:02:39.025]                 args <- list()
[11:02:39.025]                 for (kk in seq_along(NAMES)) {
[11:02:39.025]                   name <- changed[[kk]]
[11:02:39.025]                   NAME <- NAMES[[kk]]
[11:02:39.025]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.025]                     next
[11:02:39.025]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:39.025]                 }
[11:02:39.025]                 NAMES <- toupper(added)
[11:02:39.025]                 for (kk in seq_along(NAMES)) {
[11:02:39.025]                   name <- added[[kk]]
[11:02:39.025]                   NAME <- NAMES[[kk]]
[11:02:39.025]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.025]                     next
[11:02:39.025]                   args[[name]] <- ""
[11:02:39.025]                 }
[11:02:39.025]                 NAMES <- toupper(removed)
[11:02:39.025]                 for (kk in seq_along(NAMES)) {
[11:02:39.025]                   name <- removed[[kk]]
[11:02:39.025]                   NAME <- NAMES[[kk]]
[11:02:39.025]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.025]                     next
[11:02:39.025]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:39.025]                 }
[11:02:39.025]                 if (length(args) > 0) 
[11:02:39.025]                   base::do.call(base::Sys.setenv, args = args)
[11:02:39.025]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:39.025]             }
[11:02:39.025]             else {
[11:02:39.025]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:39.025]             }
[11:02:39.025]             {
[11:02:39.025]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:39.025]                   0L) {
[11:02:39.025]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:39.025]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:39.025]                   base::options(opts)
[11:02:39.025]                 }
[11:02:39.025]                 {
[11:02:39.025]                   {
[11:02:39.025]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:39.025]                     NULL
[11:02:39.025]                   }
[11:02:39.025]                   options(future.plan = NULL)
[11:02:39.025]                   if (is.na(NA_character_)) 
[11:02:39.025]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:39.025]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:39.025]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:39.025]                     .init = FALSE)
[11:02:39.025]                 }
[11:02:39.025]             }
[11:02:39.025]         }
[11:02:39.025]     })
[11:02:39.025]     if (TRUE) {
[11:02:39.025]         base::sink(type = "output", split = FALSE)
[11:02:39.025]         if (TRUE) {
[11:02:39.025]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:39.025]         }
[11:02:39.025]         else {
[11:02:39.025]             ...future.result["stdout"] <- base::list(NULL)
[11:02:39.025]         }
[11:02:39.025]         base::close(...future.stdout)
[11:02:39.025]         ...future.stdout <- NULL
[11:02:39.025]     }
[11:02:39.025]     ...future.result$conditions <- ...future.conditions
[11:02:39.025]     ...future.result$finished <- base::Sys.time()
[11:02:39.025]     ...future.result
[11:02:39.025] }
[11:02:39.029] assign_globals() ...
[11:02:39.029] List of 1
[11:02:39.029]  $ kk: int 2
[11:02:39.029]  - attr(*, "where")=List of 1
[11:02:39.029]   ..$ kk:<environment: R_EmptyEnv> 
[11:02:39.029]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:02:39.029]  - attr(*, "resolved")= logi FALSE
[11:02:39.029]  - attr(*, "total_size")= num 35
[11:02:39.029]  - attr(*, "already-done")= logi TRUE
[11:02:39.033] - copied ‘kk’ to environment
[11:02:39.033] assign_globals() ... done
[11:02:39.033] requestCore(): workers = 2
[11:02:39.033] Poll #1 (0): usedCores() = 2, workers = 2
[11:02:39.044] result() for MulticoreFuture ...
[11:02:39.045] result() for MulticoreFuture ...
[11:02:39.045] result() for MulticoreFuture ... done
[11:02:39.045] result() for MulticoreFuture ... done
[11:02:39.045] result() for MulticoreFuture ...
[11:02:39.045] result() for MulticoreFuture ... done
[11:02:39.048] MulticoreFuture started
[11:02:39.048] - Launch lazy future ... done
[11:02:39.049] run() for ‘MulticoreFuture’ ... done
[11:02:39.049] plan(): Setting new future strategy stack:
[11:02:39.049] getGlobalsAndPackages() ...
[11:02:39.049] Searching for globals...
[11:02:39.049] List of future strategies:
[11:02:39.049] 1. sequential:
[11:02:39.049]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:39.049]    - tweaked: FALSE
[11:02:39.049]    - call: NULL
[11:02:39.050] plan(): nbrOfWorkers() = 1
[11:02:39.051] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[11:02:39.052] Searching for globals ... DONE
[11:02:39.052] Resolving globals: FALSE
[11:02:39.053] The total size of the 1 globals is 35 bytes (35 bytes)
[11:02:39.053] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[11:02:39.053] - globals: [1] ‘kk’
[11:02:39.054] 
[11:02:39.054] getGlobalsAndPackages() ... DONE
[11:02:39.054] run() for ‘Future’ ...
[11:02:39.054] - state: ‘created’
[11:02:39.055] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:02:39.058] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:39.058] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:02:39.058]   - Field: ‘label’
[11:02:39.058]   - Field: ‘local’
[11:02:39.058]   - Field: ‘owner’
[11:02:39.058]   - Field: ‘envir’
[11:02:39.059]   - Field: ‘workers’
[11:02:39.059]   - Field: ‘packages’
[11:02:39.059]   - Field: ‘gc’
[11:02:39.059]   - Field: ‘job’
[11:02:39.059]   - Field: ‘conditions’
[11:02:39.059]   - Field: ‘expr’
[11:02:39.059]   - Field: ‘uuid’
[11:02:39.060]   - Field: ‘seed’
[11:02:39.060]   - Field: ‘version’
[11:02:39.060]   - Field: ‘result’
[11:02:39.060]   - Field: ‘asynchronous’
[11:02:39.060]   - Field: ‘calls’
[11:02:39.060]   - Field: ‘globals’
[11:02:39.060]   - Field: ‘stdout’
[11:02:39.061]   - Field: ‘earlySignal’
[11:02:39.061]   - Field: ‘lazy’
[11:02:39.061]   - Field: ‘state’
[11:02:39.061] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:02:39.061] - Launch lazy future ...
[11:02:39.062] Packages needed by the future expression (n = 0): <none>
[11:02:39.062] Packages needed by future strategies (n = 0): <none>
[11:02:39.062] {
[11:02:39.062]     {
[11:02:39.062]         {
[11:02:39.062]             ...future.startTime <- base::Sys.time()
[11:02:39.062]             {
[11:02:39.062]                 {
[11:02:39.062]                   {
[11:02:39.062]                     {
[11:02:39.062]                       base::local({
[11:02:39.062]                         has_future <- base::requireNamespace("future", 
[11:02:39.062]                           quietly = TRUE)
[11:02:39.062]                         if (has_future) {
[11:02:39.062]                           ns <- base::getNamespace("future")
[11:02:39.062]                           version <- ns[[".package"]][["version"]]
[11:02:39.062]                           if (is.null(version)) 
[11:02:39.062]                             version <- utils::packageVersion("future")
[11:02:39.062]                         }
[11:02:39.062]                         else {
[11:02:39.062]                           version <- NULL
[11:02:39.062]                         }
[11:02:39.062]                         if (!has_future || version < "1.8.0") {
[11:02:39.062]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:39.062]                             "", base::R.version$version.string), 
[11:02:39.062]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:39.062]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:39.062]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:39.062]                               "release", "version")], collapse = " "), 
[11:02:39.062]                             hostname = base::Sys.info()[["nodename"]])
[11:02:39.062]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:39.062]                             info)
[11:02:39.062]                           info <- base::paste(info, collapse = "; ")
[11:02:39.062]                           if (!has_future) {
[11:02:39.062]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:39.062]                               info)
[11:02:39.062]                           }
[11:02:39.062]                           else {
[11:02:39.062]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:39.062]                               info, version)
[11:02:39.062]                           }
[11:02:39.062]                           base::stop(msg)
[11:02:39.062]                         }
[11:02:39.062]                       })
[11:02:39.062]                     }
[11:02:39.062]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:39.062]                     base::options(mc.cores = 1L)
[11:02:39.062]                   }
[11:02:39.062]                   ...future.strategy.old <- future::plan("list")
[11:02:39.062]                   options(future.plan = NULL)
[11:02:39.062]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:39.062]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:39.062]                 }
[11:02:39.062]                 ...future.workdir <- getwd()
[11:02:39.062]             }
[11:02:39.062]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:39.062]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:39.062]         }
[11:02:39.062]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:39.062]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:39.062]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:39.062]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:39.062]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:39.062]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:39.062]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:39.062]             base::names(...future.oldOptions))
[11:02:39.062]     }
[11:02:39.062]     if (FALSE) {
[11:02:39.062]     }
[11:02:39.062]     else {
[11:02:39.062]         if (TRUE) {
[11:02:39.062]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:39.062]                 open = "w")
[11:02:39.062]         }
[11:02:39.062]         else {
[11:02:39.062]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:39.062]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:39.062]         }
[11:02:39.062]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:39.062]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:39.062]             base::sink(type = "output", split = FALSE)
[11:02:39.062]             base::close(...future.stdout)
[11:02:39.062]         }, add = TRUE)
[11:02:39.062]     }
[11:02:39.062]     ...future.frame <- base::sys.nframe()
[11:02:39.062]     ...future.conditions <- base::list()
[11:02:39.062]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:39.062]     if (FALSE) {
[11:02:39.062]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:39.062]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:39.062]     }
[11:02:39.062]     ...future.result <- base::tryCatch({
[11:02:39.062]         base::withCallingHandlers({
[11:02:39.062]             ...future.value <- base::withVisible(base::local({
[11:02:39.062]                 withCallingHandlers({
[11:02:39.062]                   {
[11:02:39.062]                     Sys.sleep(0.1)
[11:02:39.062]                     kk
[11:02:39.062]                   }
[11:02:39.062]                 }, immediateCondition = function(cond) {
[11:02:39.062]                   save_rds <- function (object, pathname, ...) 
[11:02:39.062]                   {
[11:02:39.062]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:02:39.062]                     if (file_test("-f", pathname_tmp)) {
[11:02:39.062]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.062]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:02:39.062]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.062]                         fi_tmp[["mtime"]])
[11:02:39.062]                     }
[11:02:39.062]                     tryCatch({
[11:02:39.062]                       saveRDS(object, file = pathname_tmp, ...)
[11:02:39.062]                     }, error = function(ex) {
[11:02:39.062]                       msg <- conditionMessage(ex)
[11:02:39.062]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.062]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:02:39.062]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.062]                         fi_tmp[["mtime"]], msg)
[11:02:39.062]                       ex$message <- msg
[11:02:39.062]                       stop(ex)
[11:02:39.062]                     })
[11:02:39.062]                     stopifnot(file_test("-f", pathname_tmp))
[11:02:39.062]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:02:39.062]                     if (!res || file_test("-f", pathname_tmp)) {
[11:02:39.062]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.062]                       fi <- file.info(pathname)
[11:02:39.062]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:02:39.062]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.062]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:02:39.062]                         fi[["size"]], fi[["mtime"]])
[11:02:39.062]                       stop(msg)
[11:02:39.062]                     }
[11:02:39.062]                     invisible(pathname)
[11:02:39.062]                   }
[11:02:39.062]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:02:39.062]                     rootPath = tempdir()) 
[11:02:39.062]                   {
[11:02:39.062]                     obj <- list(time = Sys.time(), condition = cond)
[11:02:39.062]                     file <- tempfile(pattern = class(cond)[1], 
[11:02:39.062]                       tmpdir = path, fileext = ".rds")
[11:02:39.062]                     save_rds(obj, file)
[11:02:39.062]                   }
[11:02:39.062]                   saveImmediateCondition(cond, path = "/tmp/RtmpPVwpFC/.future/immediateConditions")
[11:02:39.062]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.062]                   {
[11:02:39.062]                     inherits <- base::inherits
[11:02:39.062]                     invokeRestart <- base::invokeRestart
[11:02:39.062]                     is.null <- base::is.null
[11:02:39.062]                     muffled <- FALSE
[11:02:39.062]                     if (inherits(cond, "message")) {
[11:02:39.062]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:39.062]                       if (muffled) 
[11:02:39.062]                         invokeRestart("muffleMessage")
[11:02:39.062]                     }
[11:02:39.062]                     else if (inherits(cond, "warning")) {
[11:02:39.062]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:39.062]                       if (muffled) 
[11:02:39.062]                         invokeRestart("muffleWarning")
[11:02:39.062]                     }
[11:02:39.062]                     else if (inherits(cond, "condition")) {
[11:02:39.062]                       if (!is.null(pattern)) {
[11:02:39.062]                         computeRestarts <- base::computeRestarts
[11:02:39.062]                         grepl <- base::grepl
[11:02:39.062]                         restarts <- computeRestarts(cond)
[11:02:39.062]                         for (restart in restarts) {
[11:02:39.062]                           name <- restart$name
[11:02:39.062]                           if (is.null(name)) 
[11:02:39.062]                             next
[11:02:39.062]                           if (!grepl(pattern, name)) 
[11:02:39.062]                             next
[11:02:39.062]                           invokeRestart(restart)
[11:02:39.062]                           muffled <- TRUE
[11:02:39.062]                           break
[11:02:39.062]                         }
[11:02:39.062]                       }
[11:02:39.062]                     }
[11:02:39.062]                     invisible(muffled)
[11:02:39.062]                   }
[11:02:39.062]                   muffleCondition(cond)
[11:02:39.062]                 })
[11:02:39.062]             }))
[11:02:39.062]             future::FutureResult(value = ...future.value$value, 
[11:02:39.062]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:39.062]                   ...future.rng), globalenv = if (FALSE) 
[11:02:39.062]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:39.062]                     ...future.globalenv.names))
[11:02:39.062]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:39.062]         }, condition = base::local({
[11:02:39.062]             c <- base::c
[11:02:39.062]             inherits <- base::inherits
[11:02:39.062]             invokeRestart <- base::invokeRestart
[11:02:39.062]             length <- base::length
[11:02:39.062]             list <- base::list
[11:02:39.062]             seq.int <- base::seq.int
[11:02:39.062]             signalCondition <- base::signalCondition
[11:02:39.062]             sys.calls <- base::sys.calls
[11:02:39.062]             `[[` <- base::`[[`
[11:02:39.062]             `+` <- base::`+`
[11:02:39.062]             `<<-` <- base::`<<-`
[11:02:39.062]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:39.062]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:39.062]                   3L)]
[11:02:39.062]             }
[11:02:39.062]             function(cond) {
[11:02:39.062]                 is_error <- inherits(cond, "error")
[11:02:39.062]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:39.062]                   NULL)
[11:02:39.062]                 if (is_error) {
[11:02:39.062]                   sessionInformation <- function() {
[11:02:39.062]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:39.062]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:39.062]                       search = base::search(), system = base::Sys.info())
[11:02:39.062]                   }
[11:02:39.062]                   ...future.conditions[[length(...future.conditions) + 
[11:02:39.062]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:39.062]                     cond$call), session = sessionInformation(), 
[11:02:39.062]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:39.062]                   signalCondition(cond)
[11:02:39.062]                 }
[11:02:39.062]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:39.062]                 "immediateCondition"))) {
[11:02:39.062]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:39.062]                   ...future.conditions[[length(...future.conditions) + 
[11:02:39.062]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:39.062]                   if (TRUE && !signal) {
[11:02:39.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.062]                     {
[11:02:39.062]                       inherits <- base::inherits
[11:02:39.062]                       invokeRestart <- base::invokeRestart
[11:02:39.062]                       is.null <- base::is.null
[11:02:39.062]                       muffled <- FALSE
[11:02:39.062]                       if (inherits(cond, "message")) {
[11:02:39.062]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:39.062]                         if (muffled) 
[11:02:39.062]                           invokeRestart("muffleMessage")
[11:02:39.062]                       }
[11:02:39.062]                       else if (inherits(cond, "warning")) {
[11:02:39.062]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:39.062]                         if (muffled) 
[11:02:39.062]                           invokeRestart("muffleWarning")
[11:02:39.062]                       }
[11:02:39.062]                       else if (inherits(cond, "condition")) {
[11:02:39.062]                         if (!is.null(pattern)) {
[11:02:39.062]                           computeRestarts <- base::computeRestarts
[11:02:39.062]                           grepl <- base::grepl
[11:02:39.062]                           restarts <- computeRestarts(cond)
[11:02:39.062]                           for (restart in restarts) {
[11:02:39.062]                             name <- restart$name
[11:02:39.062]                             if (is.null(name)) 
[11:02:39.062]                               next
[11:02:39.062]                             if (!grepl(pattern, name)) 
[11:02:39.062]                               next
[11:02:39.062]                             invokeRestart(restart)
[11:02:39.062]                             muffled <- TRUE
[11:02:39.062]                             break
[11:02:39.062]                           }
[11:02:39.062]                         }
[11:02:39.062]                       }
[11:02:39.062]                       invisible(muffled)
[11:02:39.062]                     }
[11:02:39.062]                     muffleCondition(cond, pattern = "^muffle")
[11:02:39.062]                   }
[11:02:39.062]                 }
[11:02:39.062]                 else {
[11:02:39.062]                   if (TRUE) {
[11:02:39.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.062]                     {
[11:02:39.062]                       inherits <- base::inherits
[11:02:39.062]                       invokeRestart <- base::invokeRestart
[11:02:39.062]                       is.null <- base::is.null
[11:02:39.062]                       muffled <- FALSE
[11:02:39.062]                       if (inherits(cond, "message")) {
[11:02:39.062]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:39.062]                         if (muffled) 
[11:02:39.062]                           invokeRestart("muffleMessage")
[11:02:39.062]                       }
[11:02:39.062]                       else if (inherits(cond, "warning")) {
[11:02:39.062]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:39.062]                         if (muffled) 
[11:02:39.062]                           invokeRestart("muffleWarning")
[11:02:39.062]                       }
[11:02:39.062]                       else if (inherits(cond, "condition")) {
[11:02:39.062]                         if (!is.null(pattern)) {
[11:02:39.062]                           computeRestarts <- base::computeRestarts
[11:02:39.062]                           grepl <- base::grepl
[11:02:39.062]                           restarts <- computeRestarts(cond)
[11:02:39.062]                           for (restart in restarts) {
[11:02:39.062]                             name <- restart$name
[11:02:39.062]                             if (is.null(name)) 
[11:02:39.062]                               next
[11:02:39.062]                             if (!grepl(pattern, name)) 
[11:02:39.062]                               next
[11:02:39.062]                             invokeRestart(restart)
[11:02:39.062]                             muffled <- TRUE
[11:02:39.062]                             break
[11:02:39.062]                           }
[11:02:39.062]                         }
[11:02:39.062]                       }
[11:02:39.062]                       invisible(muffled)
[11:02:39.062]                     }
[11:02:39.062]                     muffleCondition(cond, pattern = "^muffle")
[11:02:39.062]                   }
[11:02:39.062]                 }
[11:02:39.062]             }
[11:02:39.062]         }))
[11:02:39.062]     }, error = function(ex) {
[11:02:39.062]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:39.062]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:39.062]                 ...future.rng), started = ...future.startTime, 
[11:02:39.062]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:39.062]             version = "1.8"), class = "FutureResult")
[11:02:39.062]     }, finally = {
[11:02:39.062]         if (!identical(...future.workdir, getwd())) 
[11:02:39.062]             setwd(...future.workdir)
[11:02:39.062]         {
[11:02:39.062]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:39.062]                 ...future.oldOptions$nwarnings <- NULL
[11:02:39.062]             }
[11:02:39.062]             base::options(...future.oldOptions)
[11:02:39.062]             if (.Platform$OS.type == "windows") {
[11:02:39.062]                 old_names <- names(...future.oldEnvVars)
[11:02:39.062]                 envs <- base::Sys.getenv()
[11:02:39.062]                 names <- names(envs)
[11:02:39.062]                 common <- intersect(names, old_names)
[11:02:39.062]                 added <- setdiff(names, old_names)
[11:02:39.062]                 removed <- setdiff(old_names, names)
[11:02:39.062]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:39.062]                   envs[common]]
[11:02:39.062]                 NAMES <- toupper(changed)
[11:02:39.062]                 args <- list()
[11:02:39.062]                 for (kk in seq_along(NAMES)) {
[11:02:39.062]                   name <- changed[[kk]]
[11:02:39.062]                   NAME <- NAMES[[kk]]
[11:02:39.062]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.062]                     next
[11:02:39.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:39.062]                 }
[11:02:39.062]                 NAMES <- toupper(added)
[11:02:39.062]                 for (kk in seq_along(NAMES)) {
[11:02:39.062]                   name <- added[[kk]]
[11:02:39.062]                   NAME <- NAMES[[kk]]
[11:02:39.062]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.062]                     next
[11:02:39.062]                   args[[name]] <- ""
[11:02:39.062]                 }
[11:02:39.062]                 NAMES <- toupper(removed)
[11:02:39.062]                 for (kk in seq_along(NAMES)) {
[11:02:39.062]                   name <- removed[[kk]]
[11:02:39.062]                   NAME <- NAMES[[kk]]
[11:02:39.062]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.062]                     next
[11:02:39.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:39.062]                 }
[11:02:39.062]                 if (length(args) > 0) 
[11:02:39.062]                   base::do.call(base::Sys.setenv, args = args)
[11:02:39.062]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:39.062]             }
[11:02:39.062]             else {
[11:02:39.062]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:39.062]             }
[11:02:39.062]             {
[11:02:39.062]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:39.062]                   0L) {
[11:02:39.062]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:39.062]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:39.062]                   base::options(opts)
[11:02:39.062]                 }
[11:02:39.062]                 {
[11:02:39.062]                   {
[11:02:39.062]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:39.062]                     NULL
[11:02:39.062]                   }
[11:02:39.062]                   options(future.plan = NULL)
[11:02:39.062]                   if (is.na(NA_character_)) 
[11:02:39.062]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:39.062]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:39.062]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:39.062]                     .init = FALSE)
[11:02:39.062]                 }
[11:02:39.062]             }
[11:02:39.062]         }
[11:02:39.062]     })
[11:02:39.062]     if (TRUE) {
[11:02:39.062]         base::sink(type = "output", split = FALSE)
[11:02:39.062]         if (TRUE) {
[11:02:39.062]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:39.062]         }
[11:02:39.062]         else {
[11:02:39.062]             ...future.result["stdout"] <- base::list(NULL)
[11:02:39.062]         }
[11:02:39.062]         base::close(...future.stdout)
[11:02:39.062]         ...future.stdout <- NULL
[11:02:39.062]     }
[11:02:39.062]     ...future.result$conditions <- ...future.conditions
[11:02:39.062]     ...future.result$finished <- base::Sys.time()
[11:02:39.062]     ...future.result
[11:02:39.062] }
[11:02:39.066] assign_globals() ...
[11:02:39.066] List of 1
[11:02:39.066]  $ kk: int 3
[11:02:39.066]  - attr(*, "where")=List of 1
[11:02:39.066]   ..$ kk:<environment: R_EmptyEnv> 
[11:02:39.066]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:02:39.066]  - attr(*, "resolved")= logi FALSE
[11:02:39.066]  - attr(*, "total_size")= num 35
[11:02:39.066]  - attr(*, "already-done")= logi TRUE
[11:02:39.073] - copied ‘kk’ to environment
[11:02:39.074] assign_globals() ... done
[11:02:39.074] requestCore(): workers = 2
[11:02:39.074] Poll #1 (0): usedCores() = 2, workers = 2
[11:02:39.106] Poll #2 (0.03 secs): usedCores() = 2, workers = 2
[11:02:39.114] plan(): Setting new future strategy stack:
[11:02:39.115] List of future strategies:
[11:02:39.115] 1. multicore:
[11:02:39.115]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:39.115]    - tweaked: FALSE
[11:02:39.115]    - call: plan(strategy)
[11:02:39.117] plan(): nbrOfWorkers() = 2
[11:02:39.118] result() for MulticoreFuture ...
[11:02:39.119] result() for MulticoreFuture ...
[11:02:39.119] result() for MulticoreFuture ... done
[11:02:39.119] result() for MulticoreFuture ... done
[11:02:39.119] result() for MulticoreFuture ...
[11:02:39.120] result() for MulticoreFuture ... done
[11:02:39.122] MulticoreFuture started
[11:02:39.123] - Launch lazy future ... done
[11:02:39.123] run() for ‘MulticoreFuture’ ... done
[11:02:39.123] plan(): Setting new future strategy stack:
[11:02:39.123] resolve() on list ...
[11:02:39.124]  recursive: 0
[11:02:39.124]  length: 3
[11:02:39.124] 
[11:02:39.123] List of future strategies:
[11:02:39.123] 1. sequential:
[11:02:39.123]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:39.123]    - tweaked: FALSE
[11:02:39.123]    - call: NULL
[11:02:39.124] Future #1
[11:02:39.125]  length: 2 (resolved future 1)
[11:02:39.125] plan(): nbrOfWorkers() = 1
[11:02:39.153] plan(): Setting new future strategy stack:
[11:02:39.153] List of future strategies:
[11:02:39.153] 1. multicore:
[11:02:39.153]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:39.153]    - tweaked: FALSE
[11:02:39.153]    - call: plan(strategy)
[11:02:39.155] plan(): nbrOfWorkers() = 2
[11:02:39.156] Future #2
[11:02:39.156]  length: 1 (resolved future 2)
[11:02:39.227] plan(): Setting new future strategy stack:
[11:02:39.228] List of future strategies:
[11:02:39.228] 1. multicore:
[11:02:39.228]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:39.228]    - tweaked: FALSE
[11:02:39.228]    - call: plan(strategy)
[11:02:39.231] plan(): nbrOfWorkers() = 2
[11:02:39.238] Future #3
[11:02:39.238]  length: 0 (resolved future 3)
[11:02:39.239] resolve() on list ... DONE
[11:02:39.239] getGlobalsAndPackages() ...
[11:02:39.239] Searching for globals...
[11:02:39.241] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[11:02:39.241] Searching for globals ... DONE
[11:02:39.242] Resolving globals: FALSE
[11:02:39.242] The total size of the 1 globals is 35 bytes (35 bytes)
[11:02:39.243] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[11:02:39.243] - globals: [1] ‘kk’
[11:02:39.243] 
[11:02:39.243] getGlobalsAndPackages() ... DONE
[11:02:39.244] getGlobalsAndPackages() ...
[11:02:39.244] Searching for globals...
[11:02:39.246] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[11:02:39.246] Searching for globals ... DONE
[11:02:39.246] Resolving globals: FALSE
[11:02:39.246] The total size of the 1 globals is 35 bytes (35 bytes)
[11:02:39.247] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[11:02:39.247] - globals: [1] ‘kk’
[11:02:39.247] 
[11:02:39.247] getGlobalsAndPackages() ... DONE
[11:02:39.248] getGlobalsAndPackages() ...
[11:02:39.248] Searching for globals...
[11:02:39.249] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[11:02:39.249] Searching for globals ... DONE
[11:02:39.249] Resolving globals: FALSE
[11:02:39.250] The total size of the 1 globals is 35 bytes (35 bytes)
[11:02:39.250] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[11:02:39.251] - globals: [1] ‘kk’
[11:02:39.251] 
[11:02:39.251] getGlobalsAndPackages() ... DONE
[11:02:39.251] resolve() on list ...
[11:02:39.251]  recursive: 0
[11:02:39.251]  length: 3
[11:02:39.252] 
[11:02:39.252] run() for ‘Future’ ...
[11:02:39.252] - state: ‘created’
[11:02:39.252] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:02:39.254] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:39.255] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:02:39.255]   - Field: ‘label’
[11:02:39.255]   - Field: ‘local’
[11:02:39.255]   - Field: ‘owner’
[11:02:39.255]   - Field: ‘envir’
[11:02:39.255]   - Field: ‘workers’
[11:02:39.255]   - Field: ‘packages’
[11:02:39.256]   - Field: ‘gc’
[11:02:39.256]   - Field: ‘job’
[11:02:39.256]   - Field: ‘conditions’
[11:02:39.256]   - Field: ‘expr’
[11:02:39.256]   - Field: ‘uuid’
[11:02:39.256]   - Field: ‘seed’
[11:02:39.256]   - Field: ‘version’
[11:02:39.256]   - Field: ‘result’
[11:02:39.257]   - Field: ‘asynchronous’
[11:02:39.257]   - Field: ‘calls’
[11:02:39.257]   - Field: ‘globals’
[11:02:39.257]   - Field: ‘stdout’
[11:02:39.257]   - Field: ‘earlySignal’
[11:02:39.257]   - Field: ‘lazy’
[11:02:39.257]   - Field: ‘state’
[11:02:39.257] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:02:39.258] - Launch lazy future ...
[11:02:39.258] Packages needed by the future expression (n = 0): <none>
[11:02:39.258] Packages needed by future strategies (n = 0): <none>
[11:02:39.259] {
[11:02:39.259]     {
[11:02:39.259]         {
[11:02:39.259]             ...future.startTime <- base::Sys.time()
[11:02:39.259]             {
[11:02:39.259]                 {
[11:02:39.259]                   {
[11:02:39.259]                     {
[11:02:39.259]                       base::local({
[11:02:39.259]                         has_future <- base::requireNamespace("future", 
[11:02:39.259]                           quietly = TRUE)
[11:02:39.259]                         if (has_future) {
[11:02:39.259]                           ns <- base::getNamespace("future")
[11:02:39.259]                           version <- ns[[".package"]][["version"]]
[11:02:39.259]                           if (is.null(version)) 
[11:02:39.259]                             version <- utils::packageVersion("future")
[11:02:39.259]                         }
[11:02:39.259]                         else {
[11:02:39.259]                           version <- NULL
[11:02:39.259]                         }
[11:02:39.259]                         if (!has_future || version < "1.8.0") {
[11:02:39.259]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:39.259]                             "", base::R.version$version.string), 
[11:02:39.259]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:39.259]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:39.259]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:39.259]                               "release", "version")], collapse = " "), 
[11:02:39.259]                             hostname = base::Sys.info()[["nodename"]])
[11:02:39.259]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:39.259]                             info)
[11:02:39.259]                           info <- base::paste(info, collapse = "; ")
[11:02:39.259]                           if (!has_future) {
[11:02:39.259]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:39.259]                               info)
[11:02:39.259]                           }
[11:02:39.259]                           else {
[11:02:39.259]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:39.259]                               info, version)
[11:02:39.259]                           }
[11:02:39.259]                           base::stop(msg)
[11:02:39.259]                         }
[11:02:39.259]                       })
[11:02:39.259]                     }
[11:02:39.259]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:39.259]                     base::options(mc.cores = 1L)
[11:02:39.259]                   }
[11:02:39.259]                   ...future.strategy.old <- future::plan("list")
[11:02:39.259]                   options(future.plan = NULL)
[11:02:39.259]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:39.259]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:39.259]                 }
[11:02:39.259]                 ...future.workdir <- getwd()
[11:02:39.259]             }
[11:02:39.259]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:39.259]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:39.259]         }
[11:02:39.259]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:39.259]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:39.259]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:39.259]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:39.259]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:39.259]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:39.259]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:39.259]             base::names(...future.oldOptions))
[11:02:39.259]     }
[11:02:39.259]     if (FALSE) {
[11:02:39.259]     }
[11:02:39.259]     else {
[11:02:39.259]         if (TRUE) {
[11:02:39.259]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:39.259]                 open = "w")
[11:02:39.259]         }
[11:02:39.259]         else {
[11:02:39.259]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:39.259]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:39.259]         }
[11:02:39.259]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:39.259]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:39.259]             base::sink(type = "output", split = FALSE)
[11:02:39.259]             base::close(...future.stdout)
[11:02:39.259]         }, add = TRUE)
[11:02:39.259]     }
[11:02:39.259]     ...future.frame <- base::sys.nframe()
[11:02:39.259]     ...future.conditions <- base::list()
[11:02:39.259]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:39.259]     if (FALSE) {
[11:02:39.259]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:39.259]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:39.259]     }
[11:02:39.259]     ...future.result <- base::tryCatch({
[11:02:39.259]         base::withCallingHandlers({
[11:02:39.259]             ...future.value <- base::withVisible(base::local({
[11:02:39.259]                 withCallingHandlers({
[11:02:39.259]                   {
[11:02:39.259]                     Sys.sleep(0.1)
[11:02:39.259]                     kk
[11:02:39.259]                   }
[11:02:39.259]                 }, immediateCondition = function(cond) {
[11:02:39.259]                   save_rds <- function (object, pathname, ...) 
[11:02:39.259]                   {
[11:02:39.259]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:02:39.259]                     if (file_test("-f", pathname_tmp)) {
[11:02:39.259]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.259]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:02:39.259]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.259]                         fi_tmp[["mtime"]])
[11:02:39.259]                     }
[11:02:39.259]                     tryCatch({
[11:02:39.259]                       saveRDS(object, file = pathname_tmp, ...)
[11:02:39.259]                     }, error = function(ex) {
[11:02:39.259]                       msg <- conditionMessage(ex)
[11:02:39.259]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.259]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:02:39.259]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.259]                         fi_tmp[["mtime"]], msg)
[11:02:39.259]                       ex$message <- msg
[11:02:39.259]                       stop(ex)
[11:02:39.259]                     })
[11:02:39.259]                     stopifnot(file_test("-f", pathname_tmp))
[11:02:39.259]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:02:39.259]                     if (!res || file_test("-f", pathname_tmp)) {
[11:02:39.259]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.259]                       fi <- file.info(pathname)
[11:02:39.259]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:02:39.259]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.259]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:02:39.259]                         fi[["size"]], fi[["mtime"]])
[11:02:39.259]                       stop(msg)
[11:02:39.259]                     }
[11:02:39.259]                     invisible(pathname)
[11:02:39.259]                   }
[11:02:39.259]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:02:39.259]                     rootPath = tempdir()) 
[11:02:39.259]                   {
[11:02:39.259]                     obj <- list(time = Sys.time(), condition = cond)
[11:02:39.259]                     file <- tempfile(pattern = class(cond)[1], 
[11:02:39.259]                       tmpdir = path, fileext = ".rds")
[11:02:39.259]                     save_rds(obj, file)
[11:02:39.259]                   }
[11:02:39.259]                   saveImmediateCondition(cond, path = "/tmp/RtmpPVwpFC/.future/immediateConditions")
[11:02:39.259]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.259]                   {
[11:02:39.259]                     inherits <- base::inherits
[11:02:39.259]                     invokeRestart <- base::invokeRestart
[11:02:39.259]                     is.null <- base::is.null
[11:02:39.259]                     muffled <- FALSE
[11:02:39.259]                     if (inherits(cond, "message")) {
[11:02:39.259]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:39.259]                       if (muffled) 
[11:02:39.259]                         invokeRestart("muffleMessage")
[11:02:39.259]                     }
[11:02:39.259]                     else if (inherits(cond, "warning")) {
[11:02:39.259]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:39.259]                       if (muffled) 
[11:02:39.259]                         invokeRestart("muffleWarning")
[11:02:39.259]                     }
[11:02:39.259]                     else if (inherits(cond, "condition")) {
[11:02:39.259]                       if (!is.null(pattern)) {
[11:02:39.259]                         computeRestarts <- base::computeRestarts
[11:02:39.259]                         grepl <- base::grepl
[11:02:39.259]                         restarts <- computeRestarts(cond)
[11:02:39.259]                         for (restart in restarts) {
[11:02:39.259]                           name <- restart$name
[11:02:39.259]                           if (is.null(name)) 
[11:02:39.259]                             next
[11:02:39.259]                           if (!grepl(pattern, name)) 
[11:02:39.259]                             next
[11:02:39.259]                           invokeRestart(restart)
[11:02:39.259]                           muffled <- TRUE
[11:02:39.259]                           break
[11:02:39.259]                         }
[11:02:39.259]                       }
[11:02:39.259]                     }
[11:02:39.259]                     invisible(muffled)
[11:02:39.259]                   }
[11:02:39.259]                   muffleCondition(cond)
[11:02:39.259]                 })
[11:02:39.259]             }))
[11:02:39.259]             future::FutureResult(value = ...future.value$value, 
[11:02:39.259]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:39.259]                   ...future.rng), globalenv = if (FALSE) 
[11:02:39.259]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:39.259]                     ...future.globalenv.names))
[11:02:39.259]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:39.259]         }, condition = base::local({
[11:02:39.259]             c <- base::c
[11:02:39.259]             inherits <- base::inherits
[11:02:39.259]             invokeRestart <- base::invokeRestart
[11:02:39.259]             length <- base::length
[11:02:39.259]             list <- base::list
[11:02:39.259]             seq.int <- base::seq.int
[11:02:39.259]             signalCondition <- base::signalCondition
[11:02:39.259]             sys.calls <- base::sys.calls
[11:02:39.259]             `[[` <- base::`[[`
[11:02:39.259]             `+` <- base::`+`
[11:02:39.259]             `<<-` <- base::`<<-`
[11:02:39.259]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:39.259]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:39.259]                   3L)]
[11:02:39.259]             }
[11:02:39.259]             function(cond) {
[11:02:39.259]                 is_error <- inherits(cond, "error")
[11:02:39.259]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:39.259]                   NULL)
[11:02:39.259]                 if (is_error) {
[11:02:39.259]                   sessionInformation <- function() {
[11:02:39.259]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:39.259]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:39.259]                       search = base::search(), system = base::Sys.info())
[11:02:39.259]                   }
[11:02:39.259]                   ...future.conditions[[length(...future.conditions) + 
[11:02:39.259]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:39.259]                     cond$call), session = sessionInformation(), 
[11:02:39.259]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:39.259]                   signalCondition(cond)
[11:02:39.259]                 }
[11:02:39.259]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:39.259]                 "immediateCondition"))) {
[11:02:39.259]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:39.259]                   ...future.conditions[[length(...future.conditions) + 
[11:02:39.259]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:39.259]                   if (TRUE && !signal) {
[11:02:39.259]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.259]                     {
[11:02:39.259]                       inherits <- base::inherits
[11:02:39.259]                       invokeRestart <- base::invokeRestart
[11:02:39.259]                       is.null <- base::is.null
[11:02:39.259]                       muffled <- FALSE
[11:02:39.259]                       if (inherits(cond, "message")) {
[11:02:39.259]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:39.259]                         if (muffled) 
[11:02:39.259]                           invokeRestart("muffleMessage")
[11:02:39.259]                       }
[11:02:39.259]                       else if (inherits(cond, "warning")) {
[11:02:39.259]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:39.259]                         if (muffled) 
[11:02:39.259]                           invokeRestart("muffleWarning")
[11:02:39.259]                       }
[11:02:39.259]                       else if (inherits(cond, "condition")) {
[11:02:39.259]                         if (!is.null(pattern)) {
[11:02:39.259]                           computeRestarts <- base::computeRestarts
[11:02:39.259]                           grepl <- base::grepl
[11:02:39.259]                           restarts <- computeRestarts(cond)
[11:02:39.259]                           for (restart in restarts) {
[11:02:39.259]                             name <- restart$name
[11:02:39.259]                             if (is.null(name)) 
[11:02:39.259]                               next
[11:02:39.259]                             if (!grepl(pattern, name)) 
[11:02:39.259]                               next
[11:02:39.259]                             invokeRestart(restart)
[11:02:39.259]                             muffled <- TRUE
[11:02:39.259]                             break
[11:02:39.259]                           }
[11:02:39.259]                         }
[11:02:39.259]                       }
[11:02:39.259]                       invisible(muffled)
[11:02:39.259]                     }
[11:02:39.259]                     muffleCondition(cond, pattern = "^muffle")
[11:02:39.259]                   }
[11:02:39.259]                 }
[11:02:39.259]                 else {
[11:02:39.259]                   if (TRUE) {
[11:02:39.259]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.259]                     {
[11:02:39.259]                       inherits <- base::inherits
[11:02:39.259]                       invokeRestart <- base::invokeRestart
[11:02:39.259]                       is.null <- base::is.null
[11:02:39.259]                       muffled <- FALSE
[11:02:39.259]                       if (inherits(cond, "message")) {
[11:02:39.259]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:39.259]                         if (muffled) 
[11:02:39.259]                           invokeRestart("muffleMessage")
[11:02:39.259]                       }
[11:02:39.259]                       else if (inherits(cond, "warning")) {
[11:02:39.259]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:39.259]                         if (muffled) 
[11:02:39.259]                           invokeRestart("muffleWarning")
[11:02:39.259]                       }
[11:02:39.259]                       else if (inherits(cond, "condition")) {
[11:02:39.259]                         if (!is.null(pattern)) {
[11:02:39.259]                           computeRestarts <- base::computeRestarts
[11:02:39.259]                           grepl <- base::grepl
[11:02:39.259]                           restarts <- computeRestarts(cond)
[11:02:39.259]                           for (restart in restarts) {
[11:02:39.259]                             name <- restart$name
[11:02:39.259]                             if (is.null(name)) 
[11:02:39.259]                               next
[11:02:39.259]                             if (!grepl(pattern, name)) 
[11:02:39.259]                               next
[11:02:39.259]                             invokeRestart(restart)
[11:02:39.259]                             muffled <- TRUE
[11:02:39.259]                             break
[11:02:39.259]                           }
[11:02:39.259]                         }
[11:02:39.259]                       }
[11:02:39.259]                       invisible(muffled)
[11:02:39.259]                     }
[11:02:39.259]                     muffleCondition(cond, pattern = "^muffle")
[11:02:39.259]                   }
[11:02:39.259]                 }
[11:02:39.259]             }
[11:02:39.259]         }))
[11:02:39.259]     }, error = function(ex) {
[11:02:39.259]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:39.259]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:39.259]                 ...future.rng), started = ...future.startTime, 
[11:02:39.259]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:39.259]             version = "1.8"), class = "FutureResult")
[11:02:39.259]     }, finally = {
[11:02:39.259]         if (!identical(...future.workdir, getwd())) 
[11:02:39.259]             setwd(...future.workdir)
[11:02:39.259]         {
[11:02:39.259]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:39.259]                 ...future.oldOptions$nwarnings <- NULL
[11:02:39.259]             }
[11:02:39.259]             base::options(...future.oldOptions)
[11:02:39.259]             if (.Platform$OS.type == "windows") {
[11:02:39.259]                 old_names <- names(...future.oldEnvVars)
[11:02:39.259]                 envs <- base::Sys.getenv()
[11:02:39.259]                 names <- names(envs)
[11:02:39.259]                 common <- intersect(names, old_names)
[11:02:39.259]                 added <- setdiff(names, old_names)
[11:02:39.259]                 removed <- setdiff(old_names, names)
[11:02:39.259]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:39.259]                   envs[common]]
[11:02:39.259]                 NAMES <- toupper(changed)
[11:02:39.259]                 args <- list()
[11:02:39.259]                 for (kk in seq_along(NAMES)) {
[11:02:39.259]                   name <- changed[[kk]]
[11:02:39.259]                   NAME <- NAMES[[kk]]
[11:02:39.259]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.259]                     next
[11:02:39.259]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:39.259]                 }
[11:02:39.259]                 NAMES <- toupper(added)
[11:02:39.259]                 for (kk in seq_along(NAMES)) {
[11:02:39.259]                   name <- added[[kk]]
[11:02:39.259]                   NAME <- NAMES[[kk]]
[11:02:39.259]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.259]                     next
[11:02:39.259]                   args[[name]] <- ""
[11:02:39.259]                 }
[11:02:39.259]                 NAMES <- toupper(removed)
[11:02:39.259]                 for (kk in seq_along(NAMES)) {
[11:02:39.259]                   name <- removed[[kk]]
[11:02:39.259]                   NAME <- NAMES[[kk]]
[11:02:39.259]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.259]                     next
[11:02:39.259]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:39.259]                 }
[11:02:39.259]                 if (length(args) > 0) 
[11:02:39.259]                   base::do.call(base::Sys.setenv, args = args)
[11:02:39.259]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:39.259]             }
[11:02:39.259]             else {
[11:02:39.259]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:39.259]             }
[11:02:39.259]             {
[11:02:39.259]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:39.259]                   0L) {
[11:02:39.259]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:39.259]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:39.259]                   base::options(opts)
[11:02:39.259]                 }
[11:02:39.259]                 {
[11:02:39.259]                   {
[11:02:39.259]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:39.259]                     NULL
[11:02:39.259]                   }
[11:02:39.259]                   options(future.plan = NULL)
[11:02:39.259]                   if (is.na(NA_character_)) 
[11:02:39.259]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:39.259]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:39.259]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:39.259]                     .init = FALSE)
[11:02:39.259]                 }
[11:02:39.259]             }
[11:02:39.259]         }
[11:02:39.259]     })
[11:02:39.259]     if (TRUE) {
[11:02:39.259]         base::sink(type = "output", split = FALSE)
[11:02:39.259]         if (TRUE) {
[11:02:39.259]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:39.259]         }
[11:02:39.259]         else {
[11:02:39.259]             ...future.result["stdout"] <- base::list(NULL)
[11:02:39.259]         }
[11:02:39.259]         base::close(...future.stdout)
[11:02:39.259]         ...future.stdout <- NULL
[11:02:39.259]     }
[11:02:39.259]     ...future.result$conditions <- ...future.conditions
[11:02:39.259]     ...future.result$finished <- base::Sys.time()
[11:02:39.259]     ...future.result
[11:02:39.259] }
[11:02:39.262] assign_globals() ...
[11:02:39.262] List of 1
[11:02:39.262]  $ kk: int 1
[11:02:39.262]  - attr(*, "where")=List of 1
[11:02:39.262]   ..$ kk:<environment: R_EmptyEnv> 
[11:02:39.262]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:02:39.262]  - attr(*, "resolved")= logi FALSE
[11:02:39.262]  - attr(*, "total_size")= num 35
[11:02:39.262]  - attr(*, "already-done")= logi TRUE
[11:02:39.266] - copied ‘kk’ to environment
[11:02:39.266] assign_globals() ... done
[11:02:39.266] requestCore(): workers = 2
[11:02:39.267] Poll #1 (0): usedCores() = 2, workers = 2
[11:02:39.277] result() for MulticoreFuture ...
[11:02:39.278] result() for MulticoreFuture ...
[11:02:39.278] result() for MulticoreFuture ... done
[11:02:39.278] result() for MulticoreFuture ... done
[11:02:39.278] result() for MulticoreFuture ...
[11:02:39.279] result() for MulticoreFuture ... done
[11:02:39.281] MulticoreFuture started
[11:02:39.281] - Launch lazy future ... done
[11:02:39.282] run() for ‘MulticoreFuture’ ... done
[11:02:39.282] plan(): Setting new future strategy stack:
[11:02:39.282] List of future strategies:
[11:02:39.282] 1. sequential:
[11:02:39.282]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:39.282]    - tweaked: FALSE
[11:02:39.282]    - call: NULL
[11:02:39.283] plan(): nbrOfWorkers() = 1
[11:02:39.292] run() for ‘Future’ ...
[11:02:39.293] - state: ‘created’
[11:02:39.293] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:02:39.299] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:39.300] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:02:39.300]   - Field: ‘label’
[11:02:39.301]   - Field: ‘local’
[11:02:39.301]   - Field: ‘owner’
[11:02:39.301]   - Field: ‘envir’
[11:02:39.301]   - Field: ‘workers’
[11:02:39.302]   - Field: ‘packages’
[11:02:39.302]   - Field: ‘gc’
[11:02:39.302]   - Field: ‘job’
[11:02:39.302]   - Field: ‘conditions’
[11:02:39.302]   - Field: ‘expr’
[11:02:39.302]   - Field: ‘uuid’
[11:02:39.303]   - Field: ‘seed’
[11:02:39.303]   - Field: ‘version’
[11:02:39.303]   - Field: ‘result’
[11:02:39.303]   - Field: ‘asynchronous’
[11:02:39.303]   - Field: ‘calls’
[11:02:39.304]   - Field: ‘globals’
[11:02:39.304]   - Field: ‘stdout’
[11:02:39.304]   - Field: ‘earlySignal’
[11:02:39.304]   - Field: ‘lazy’
[11:02:39.304]   - Field: ‘state’
[11:02:39.304] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:02:39.305] - Launch lazy future ...
[11:02:39.305] Packages needed by the future expression (n = 0): <none>
[11:02:39.305] Packages needed by future strategies (n = 0): <none>
[11:02:39.306] {
[11:02:39.306]     {
[11:02:39.306]         {
[11:02:39.306]             ...future.startTime <- base::Sys.time()
[11:02:39.306]             {
[11:02:39.306]                 {
[11:02:39.306]                   {
[11:02:39.306]                     {
[11:02:39.306]                       base::local({
[11:02:39.306]                         has_future <- base::requireNamespace("future", 
[11:02:39.306]                           quietly = TRUE)
[11:02:39.306]                         if (has_future) {
[11:02:39.306]                           ns <- base::getNamespace("future")
[11:02:39.306]                           version <- ns[[".package"]][["version"]]
[11:02:39.306]                           if (is.null(version)) 
[11:02:39.306]                             version <- utils::packageVersion("future")
[11:02:39.306]                         }
[11:02:39.306]                         else {
[11:02:39.306]                           version <- NULL
[11:02:39.306]                         }
[11:02:39.306]                         if (!has_future || version < "1.8.0") {
[11:02:39.306]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:39.306]                             "", base::R.version$version.string), 
[11:02:39.306]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:39.306]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:39.306]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:39.306]                               "release", "version")], collapse = " "), 
[11:02:39.306]                             hostname = base::Sys.info()[["nodename"]])
[11:02:39.306]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:39.306]                             info)
[11:02:39.306]                           info <- base::paste(info, collapse = "; ")
[11:02:39.306]                           if (!has_future) {
[11:02:39.306]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:39.306]                               info)
[11:02:39.306]                           }
[11:02:39.306]                           else {
[11:02:39.306]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:39.306]                               info, version)
[11:02:39.306]                           }
[11:02:39.306]                           base::stop(msg)
[11:02:39.306]                         }
[11:02:39.306]                       })
[11:02:39.306]                     }
[11:02:39.306]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:39.306]                     base::options(mc.cores = 1L)
[11:02:39.306]                   }
[11:02:39.306]                   ...future.strategy.old <- future::plan("list")
[11:02:39.306]                   options(future.plan = NULL)
[11:02:39.306]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:39.306]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:39.306]                 }
[11:02:39.306]                 ...future.workdir <- getwd()
[11:02:39.306]             }
[11:02:39.306]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:39.306]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:39.306]         }
[11:02:39.306]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:39.306]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:39.306]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:39.306]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:39.306]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:39.306]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:39.306]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:39.306]             base::names(...future.oldOptions))
[11:02:39.306]     }
[11:02:39.306]     if (FALSE) {
[11:02:39.306]     }
[11:02:39.306]     else {
[11:02:39.306]         if (TRUE) {
[11:02:39.306]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:39.306]                 open = "w")
[11:02:39.306]         }
[11:02:39.306]         else {
[11:02:39.306]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:39.306]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:39.306]         }
[11:02:39.306]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:39.306]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:39.306]             base::sink(type = "output", split = FALSE)
[11:02:39.306]             base::close(...future.stdout)
[11:02:39.306]         }, add = TRUE)
[11:02:39.306]     }
[11:02:39.306]     ...future.frame <- base::sys.nframe()
[11:02:39.306]     ...future.conditions <- base::list()
[11:02:39.306]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:39.306]     if (FALSE) {
[11:02:39.306]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:39.306]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:39.306]     }
[11:02:39.306]     ...future.result <- base::tryCatch({
[11:02:39.306]         base::withCallingHandlers({
[11:02:39.306]             ...future.value <- base::withVisible(base::local({
[11:02:39.306]                 withCallingHandlers({
[11:02:39.306]                   {
[11:02:39.306]                     Sys.sleep(0.1)
[11:02:39.306]                     kk
[11:02:39.306]                   }
[11:02:39.306]                 }, immediateCondition = function(cond) {
[11:02:39.306]                   save_rds <- function (object, pathname, ...) 
[11:02:39.306]                   {
[11:02:39.306]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:02:39.306]                     if (file_test("-f", pathname_tmp)) {
[11:02:39.306]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.306]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:02:39.306]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.306]                         fi_tmp[["mtime"]])
[11:02:39.306]                     }
[11:02:39.306]                     tryCatch({
[11:02:39.306]                       saveRDS(object, file = pathname_tmp, ...)
[11:02:39.306]                     }, error = function(ex) {
[11:02:39.306]                       msg <- conditionMessage(ex)
[11:02:39.306]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.306]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:02:39.306]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.306]                         fi_tmp[["mtime"]], msg)
[11:02:39.306]                       ex$message <- msg
[11:02:39.306]                       stop(ex)
[11:02:39.306]                     })
[11:02:39.306]                     stopifnot(file_test("-f", pathname_tmp))
[11:02:39.306]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:02:39.306]                     if (!res || file_test("-f", pathname_tmp)) {
[11:02:39.306]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.306]                       fi <- file.info(pathname)
[11:02:39.306]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:02:39.306]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.306]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:02:39.306]                         fi[["size"]], fi[["mtime"]])
[11:02:39.306]                       stop(msg)
[11:02:39.306]                     }
[11:02:39.306]                     invisible(pathname)
[11:02:39.306]                   }
[11:02:39.306]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:02:39.306]                     rootPath = tempdir()) 
[11:02:39.306]                   {
[11:02:39.306]                     obj <- list(time = Sys.time(), condition = cond)
[11:02:39.306]                     file <- tempfile(pattern = class(cond)[1], 
[11:02:39.306]                       tmpdir = path, fileext = ".rds")
[11:02:39.306]                     save_rds(obj, file)
[11:02:39.306]                   }
[11:02:39.306]                   saveImmediateCondition(cond, path = "/tmp/RtmpPVwpFC/.future/immediateConditions")
[11:02:39.306]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.306]                   {
[11:02:39.306]                     inherits <- base::inherits
[11:02:39.306]                     invokeRestart <- base::invokeRestart
[11:02:39.306]                     is.null <- base::is.null
[11:02:39.306]                     muffled <- FALSE
[11:02:39.306]                     if (inherits(cond, "message")) {
[11:02:39.306]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:39.306]                       if (muffled) 
[11:02:39.306]                         invokeRestart("muffleMessage")
[11:02:39.306]                     }
[11:02:39.306]                     else if (inherits(cond, "warning")) {
[11:02:39.306]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:39.306]                       if (muffled) 
[11:02:39.306]                         invokeRestart("muffleWarning")
[11:02:39.306]                     }
[11:02:39.306]                     else if (inherits(cond, "condition")) {
[11:02:39.306]                       if (!is.null(pattern)) {
[11:02:39.306]                         computeRestarts <- base::computeRestarts
[11:02:39.306]                         grepl <- base::grepl
[11:02:39.306]                         restarts <- computeRestarts(cond)
[11:02:39.306]                         for (restart in restarts) {
[11:02:39.306]                           name <- restart$name
[11:02:39.306]                           if (is.null(name)) 
[11:02:39.306]                             next
[11:02:39.306]                           if (!grepl(pattern, name)) 
[11:02:39.306]                             next
[11:02:39.306]                           invokeRestart(restart)
[11:02:39.306]                           muffled <- TRUE
[11:02:39.306]                           break
[11:02:39.306]                         }
[11:02:39.306]                       }
[11:02:39.306]                     }
[11:02:39.306]                     invisible(muffled)
[11:02:39.306]                   }
[11:02:39.306]                   muffleCondition(cond)
[11:02:39.306]                 })
[11:02:39.306]             }))
[11:02:39.306]             future::FutureResult(value = ...future.value$value, 
[11:02:39.306]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:39.306]                   ...future.rng), globalenv = if (FALSE) 
[11:02:39.306]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:39.306]                     ...future.globalenv.names))
[11:02:39.306]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:39.306]         }, condition = base::local({
[11:02:39.306]             c <- base::c
[11:02:39.306]             inherits <- base::inherits
[11:02:39.306]             invokeRestart <- base::invokeRestart
[11:02:39.306]             length <- base::length
[11:02:39.306]             list <- base::list
[11:02:39.306]             seq.int <- base::seq.int
[11:02:39.306]             signalCondition <- base::signalCondition
[11:02:39.306]             sys.calls <- base::sys.calls
[11:02:39.306]             `[[` <- base::`[[`
[11:02:39.306]             `+` <- base::`+`
[11:02:39.306]             `<<-` <- base::`<<-`
[11:02:39.306]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:39.306]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:39.306]                   3L)]
[11:02:39.306]             }
[11:02:39.306]             function(cond) {
[11:02:39.306]                 is_error <- inherits(cond, "error")
[11:02:39.306]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:39.306]                   NULL)
[11:02:39.306]                 if (is_error) {
[11:02:39.306]                   sessionInformation <- function() {
[11:02:39.306]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:39.306]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:39.306]                       search = base::search(), system = base::Sys.info())
[11:02:39.306]                   }
[11:02:39.306]                   ...future.conditions[[length(...future.conditions) + 
[11:02:39.306]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:39.306]                     cond$call), session = sessionInformation(), 
[11:02:39.306]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:39.306]                   signalCondition(cond)
[11:02:39.306]                 }
[11:02:39.306]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:39.306]                 "immediateCondition"))) {
[11:02:39.306]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:39.306]                   ...future.conditions[[length(...future.conditions) + 
[11:02:39.306]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:39.306]                   if (TRUE && !signal) {
[11:02:39.306]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.306]                     {
[11:02:39.306]                       inherits <- base::inherits
[11:02:39.306]                       invokeRestart <- base::invokeRestart
[11:02:39.306]                       is.null <- base::is.null
[11:02:39.306]                       muffled <- FALSE
[11:02:39.306]                       if (inherits(cond, "message")) {
[11:02:39.306]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:39.306]                         if (muffled) 
[11:02:39.306]                           invokeRestart("muffleMessage")
[11:02:39.306]                       }
[11:02:39.306]                       else if (inherits(cond, "warning")) {
[11:02:39.306]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:39.306]                         if (muffled) 
[11:02:39.306]                           invokeRestart("muffleWarning")
[11:02:39.306]                       }
[11:02:39.306]                       else if (inherits(cond, "condition")) {
[11:02:39.306]                         if (!is.null(pattern)) {
[11:02:39.306]                           computeRestarts <- base::computeRestarts
[11:02:39.306]                           grepl <- base::grepl
[11:02:39.306]                           restarts <- computeRestarts(cond)
[11:02:39.306]                           for (restart in restarts) {
[11:02:39.306]                             name <- restart$name
[11:02:39.306]                             if (is.null(name)) 
[11:02:39.306]                               next
[11:02:39.306]                             if (!grepl(pattern, name)) 
[11:02:39.306]                               next
[11:02:39.306]                             invokeRestart(restart)
[11:02:39.306]                             muffled <- TRUE
[11:02:39.306]                             break
[11:02:39.306]                           }
[11:02:39.306]                         }
[11:02:39.306]                       }
[11:02:39.306]                       invisible(muffled)
[11:02:39.306]                     }
[11:02:39.306]                     muffleCondition(cond, pattern = "^muffle")
[11:02:39.306]                   }
[11:02:39.306]                 }
[11:02:39.306]                 else {
[11:02:39.306]                   if (TRUE) {
[11:02:39.306]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.306]                     {
[11:02:39.306]                       inherits <- base::inherits
[11:02:39.306]                       invokeRestart <- base::invokeRestart
[11:02:39.306]                       is.null <- base::is.null
[11:02:39.306]                       muffled <- FALSE
[11:02:39.306]                       if (inherits(cond, "message")) {
[11:02:39.306]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:39.306]                         if (muffled) 
[11:02:39.306]                           invokeRestart("muffleMessage")
[11:02:39.306]                       }
[11:02:39.306]                       else if (inherits(cond, "warning")) {
[11:02:39.306]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:39.306]                         if (muffled) 
[11:02:39.306]                           invokeRestart("muffleWarning")
[11:02:39.306]                       }
[11:02:39.306]                       else if (inherits(cond, "condition")) {
[11:02:39.306]                         if (!is.null(pattern)) {
[11:02:39.306]                           computeRestarts <- base::computeRestarts
[11:02:39.306]                           grepl <- base::grepl
[11:02:39.306]                           restarts <- computeRestarts(cond)
[11:02:39.306]                           for (restart in restarts) {
[11:02:39.306]                             name <- restart$name
[11:02:39.306]                             if (is.null(name)) 
[11:02:39.306]                               next
[11:02:39.306]                             if (!grepl(pattern, name)) 
[11:02:39.306]                               next
[11:02:39.306]                             invokeRestart(restart)
[11:02:39.306]                             muffled <- TRUE
[11:02:39.306]                             break
[11:02:39.306]                           }
[11:02:39.306]                         }
[11:02:39.306]                       }
[11:02:39.306]                       invisible(muffled)
[11:02:39.306]                     }
[11:02:39.306]                     muffleCondition(cond, pattern = "^muffle")
[11:02:39.306]                   }
[11:02:39.306]                 }
[11:02:39.306]             }
[11:02:39.306]         }))
[11:02:39.306]     }, error = function(ex) {
[11:02:39.306]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:39.306]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:39.306]                 ...future.rng), started = ...future.startTime, 
[11:02:39.306]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:39.306]             version = "1.8"), class = "FutureResult")
[11:02:39.306]     }, finally = {
[11:02:39.306]         if (!identical(...future.workdir, getwd())) 
[11:02:39.306]             setwd(...future.workdir)
[11:02:39.306]         {
[11:02:39.306]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:39.306]                 ...future.oldOptions$nwarnings <- NULL
[11:02:39.306]             }
[11:02:39.306]             base::options(...future.oldOptions)
[11:02:39.306]             if (.Platform$OS.type == "windows") {
[11:02:39.306]                 old_names <- names(...future.oldEnvVars)
[11:02:39.306]                 envs <- base::Sys.getenv()
[11:02:39.306]                 names <- names(envs)
[11:02:39.306]                 common <- intersect(names, old_names)
[11:02:39.306]                 added <- setdiff(names, old_names)
[11:02:39.306]                 removed <- setdiff(old_names, names)
[11:02:39.306]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:39.306]                   envs[common]]
[11:02:39.306]                 NAMES <- toupper(changed)
[11:02:39.306]                 args <- list()
[11:02:39.306]                 for (kk in seq_along(NAMES)) {
[11:02:39.306]                   name <- changed[[kk]]
[11:02:39.306]                   NAME <- NAMES[[kk]]
[11:02:39.306]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.306]                     next
[11:02:39.306]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:39.306]                 }
[11:02:39.306]                 NAMES <- toupper(added)
[11:02:39.306]                 for (kk in seq_along(NAMES)) {
[11:02:39.306]                   name <- added[[kk]]
[11:02:39.306]                   NAME <- NAMES[[kk]]
[11:02:39.306]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.306]                     next
[11:02:39.306]                   args[[name]] <- ""
[11:02:39.306]                 }
[11:02:39.306]                 NAMES <- toupper(removed)
[11:02:39.306]                 for (kk in seq_along(NAMES)) {
[11:02:39.306]                   name <- removed[[kk]]
[11:02:39.306]                   NAME <- NAMES[[kk]]
[11:02:39.306]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.306]                     next
[11:02:39.306]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:39.306]                 }
[11:02:39.306]                 if (length(args) > 0) 
[11:02:39.306]                   base::do.call(base::Sys.setenv, args = args)
[11:02:39.306]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:39.306]             }
[11:02:39.306]             else {
[11:02:39.306]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:39.306]             }
[11:02:39.306]             {
[11:02:39.306]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:39.306]                   0L) {
[11:02:39.306]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:39.306]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:39.306]                   base::options(opts)
[11:02:39.306]                 }
[11:02:39.306]                 {
[11:02:39.306]                   {
[11:02:39.306]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:39.306]                     NULL
[11:02:39.306]                   }
[11:02:39.306]                   options(future.plan = NULL)
[11:02:39.306]                   if (is.na(NA_character_)) 
[11:02:39.306]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:39.306]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:39.306]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:39.306]                     .init = FALSE)
[11:02:39.306]                 }
[11:02:39.306]             }
[11:02:39.306]         }
[11:02:39.306]     })
[11:02:39.306]     if (TRUE) {
[11:02:39.306]         base::sink(type = "output", split = FALSE)
[11:02:39.306]         if (TRUE) {
[11:02:39.306]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:39.306]         }
[11:02:39.306]         else {
[11:02:39.306]             ...future.result["stdout"] <- base::list(NULL)
[11:02:39.306]         }
[11:02:39.306]         base::close(...future.stdout)
[11:02:39.306]         ...future.stdout <- NULL
[11:02:39.306]     }
[11:02:39.306]     ...future.result$conditions <- ...future.conditions
[11:02:39.306]     ...future.result$finished <- base::Sys.time()
[11:02:39.306]     ...future.result
[11:02:39.306] }
[11:02:39.309] assign_globals() ...
[11:02:39.309] List of 1
[11:02:39.309]  $ kk: int 2
[11:02:39.309]  - attr(*, "where")=List of 1
[11:02:39.309]   ..$ kk:<environment: R_EmptyEnv> 
[11:02:39.309]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:02:39.309]  - attr(*, "resolved")= logi FALSE
[11:02:39.309]  - attr(*, "total_size")= num 35
[11:02:39.309]  - attr(*, "already-done")= logi TRUE
[11:02:39.312] - copied ‘kk’ to environment
[11:02:39.313] assign_globals() ... done
[11:02:39.313] requestCore(): workers = 2
[11:02:39.313] Poll #1 (0): usedCores() = 2, workers = 2
[11:02:39.324] result() for MulticoreFuture ...
[11:02:39.324] result() for MulticoreFuture ...
[11:02:39.325] result() for MulticoreFuture ... done
[11:02:39.325] result() for MulticoreFuture ... done
[11:02:39.325] result() for MulticoreFuture ...
[11:02:39.325] result() for MulticoreFuture ... done
[11:02:39.327] MulticoreFuture started
[11:02:39.327] - Launch lazy future ... done
[11:02:39.328] run() for ‘MulticoreFuture’ ... done
[11:02:39.328] plan(): Setting new future strategy stack:
[11:02:39.329] List of future strategies:
[11:02:39.329] 1. sequential:
[11:02:39.329]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:39.329]    - tweaked: FALSE
[11:02:39.329]    - call: NULL
[11:02:39.330] plan(): nbrOfWorkers() = 1
[11:02:39.339] run() for ‘Future’ ...
[11:02:39.339] - state: ‘created’
[11:02:39.339] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:02:39.342] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:39.343] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:02:39.343]   - Field: ‘label’
[11:02:39.343]   - Field: ‘local’
[11:02:39.343]   - Field: ‘owner’
[11:02:39.343]   - Field: ‘envir’
[11:02:39.343]   - Field: ‘workers’
[11:02:39.343]   - Field: ‘packages’
[11:02:39.344]   - Field: ‘gc’
[11:02:39.344]   - Field: ‘job’
[11:02:39.344]   - Field: ‘conditions’
[11:02:39.344]   - Field: ‘expr’
[11:02:39.344]   - Field: ‘uuid’
[11:02:39.344]   - Field: ‘seed’
[11:02:39.345]   - Field: ‘version’
[11:02:39.345]   - Field: ‘result’
[11:02:39.345]   - Field: ‘asynchronous’
[11:02:39.345]   - Field: ‘calls’
[11:02:39.345]   - Field: ‘globals’
[11:02:39.345]   - Field: ‘stdout’
[11:02:39.345]   - Field: ‘earlySignal’
[11:02:39.346]   - Field: ‘lazy’
[11:02:39.346]   - Field: ‘state’
[11:02:39.346] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:02:39.346] - Launch lazy future ...
[11:02:39.347] Packages needed by the future expression (n = 0): <none>
[11:02:39.347] Packages needed by future strategies (n = 0): <none>
[11:02:39.347] {
[11:02:39.347]     {
[11:02:39.347]         {
[11:02:39.347]             ...future.startTime <- base::Sys.time()
[11:02:39.347]             {
[11:02:39.347]                 {
[11:02:39.347]                   {
[11:02:39.347]                     {
[11:02:39.347]                       base::local({
[11:02:39.347]                         has_future <- base::requireNamespace("future", 
[11:02:39.347]                           quietly = TRUE)
[11:02:39.347]                         if (has_future) {
[11:02:39.347]                           ns <- base::getNamespace("future")
[11:02:39.347]                           version <- ns[[".package"]][["version"]]
[11:02:39.347]                           if (is.null(version)) 
[11:02:39.347]                             version <- utils::packageVersion("future")
[11:02:39.347]                         }
[11:02:39.347]                         else {
[11:02:39.347]                           version <- NULL
[11:02:39.347]                         }
[11:02:39.347]                         if (!has_future || version < "1.8.0") {
[11:02:39.347]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:39.347]                             "", base::R.version$version.string), 
[11:02:39.347]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:39.347]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:39.347]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:39.347]                               "release", "version")], collapse = " "), 
[11:02:39.347]                             hostname = base::Sys.info()[["nodename"]])
[11:02:39.347]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:39.347]                             info)
[11:02:39.347]                           info <- base::paste(info, collapse = "; ")
[11:02:39.347]                           if (!has_future) {
[11:02:39.347]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:39.347]                               info)
[11:02:39.347]                           }
[11:02:39.347]                           else {
[11:02:39.347]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:39.347]                               info, version)
[11:02:39.347]                           }
[11:02:39.347]                           base::stop(msg)
[11:02:39.347]                         }
[11:02:39.347]                       })
[11:02:39.347]                     }
[11:02:39.347]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:39.347]                     base::options(mc.cores = 1L)
[11:02:39.347]                   }
[11:02:39.347]                   ...future.strategy.old <- future::plan("list")
[11:02:39.347]                   options(future.plan = NULL)
[11:02:39.347]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:39.347]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:39.347]                 }
[11:02:39.347]                 ...future.workdir <- getwd()
[11:02:39.347]             }
[11:02:39.347]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:39.347]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:39.347]         }
[11:02:39.347]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:39.347]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:39.347]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:39.347]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:39.347]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:39.347]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:39.347]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:39.347]             base::names(...future.oldOptions))
[11:02:39.347]     }
[11:02:39.347]     if (FALSE) {
[11:02:39.347]     }
[11:02:39.347]     else {
[11:02:39.347]         if (TRUE) {
[11:02:39.347]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:39.347]                 open = "w")
[11:02:39.347]         }
[11:02:39.347]         else {
[11:02:39.347]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:39.347]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:39.347]         }
[11:02:39.347]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:39.347]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:39.347]             base::sink(type = "output", split = FALSE)
[11:02:39.347]             base::close(...future.stdout)
[11:02:39.347]         }, add = TRUE)
[11:02:39.347]     }
[11:02:39.347]     ...future.frame <- base::sys.nframe()
[11:02:39.347]     ...future.conditions <- base::list()
[11:02:39.347]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:39.347]     if (FALSE) {
[11:02:39.347]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:39.347]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:39.347]     }
[11:02:39.347]     ...future.result <- base::tryCatch({
[11:02:39.347]         base::withCallingHandlers({
[11:02:39.347]             ...future.value <- base::withVisible(base::local({
[11:02:39.347]                 withCallingHandlers({
[11:02:39.347]                   {
[11:02:39.347]                     Sys.sleep(0.1)
[11:02:39.347]                     kk
[11:02:39.347]                   }
[11:02:39.347]                 }, immediateCondition = function(cond) {
[11:02:39.347]                   save_rds <- function (object, pathname, ...) 
[11:02:39.347]                   {
[11:02:39.347]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:02:39.347]                     if (file_test("-f", pathname_tmp)) {
[11:02:39.347]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.347]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:02:39.347]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.347]                         fi_tmp[["mtime"]])
[11:02:39.347]                     }
[11:02:39.347]                     tryCatch({
[11:02:39.347]                       saveRDS(object, file = pathname_tmp, ...)
[11:02:39.347]                     }, error = function(ex) {
[11:02:39.347]                       msg <- conditionMessage(ex)
[11:02:39.347]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.347]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:02:39.347]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.347]                         fi_tmp[["mtime"]], msg)
[11:02:39.347]                       ex$message <- msg
[11:02:39.347]                       stop(ex)
[11:02:39.347]                     })
[11:02:39.347]                     stopifnot(file_test("-f", pathname_tmp))
[11:02:39.347]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:02:39.347]                     if (!res || file_test("-f", pathname_tmp)) {
[11:02:39.347]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.347]                       fi <- file.info(pathname)
[11:02:39.347]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:02:39.347]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.347]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:02:39.347]                         fi[["size"]], fi[["mtime"]])
[11:02:39.347]                       stop(msg)
[11:02:39.347]                     }
[11:02:39.347]                     invisible(pathname)
[11:02:39.347]                   }
[11:02:39.347]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:02:39.347]                     rootPath = tempdir()) 
[11:02:39.347]                   {
[11:02:39.347]                     obj <- list(time = Sys.time(), condition = cond)
[11:02:39.347]                     file <- tempfile(pattern = class(cond)[1], 
[11:02:39.347]                       tmpdir = path, fileext = ".rds")
[11:02:39.347]                     save_rds(obj, file)
[11:02:39.347]                   }
[11:02:39.347]                   saveImmediateCondition(cond, path = "/tmp/RtmpPVwpFC/.future/immediateConditions")
[11:02:39.347]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.347]                   {
[11:02:39.347]                     inherits <- base::inherits
[11:02:39.347]                     invokeRestart <- base::invokeRestart
[11:02:39.347]                     is.null <- base::is.null
[11:02:39.347]                     muffled <- FALSE
[11:02:39.347]                     if (inherits(cond, "message")) {
[11:02:39.347]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:39.347]                       if (muffled) 
[11:02:39.347]                         invokeRestart("muffleMessage")
[11:02:39.347]                     }
[11:02:39.347]                     else if (inherits(cond, "warning")) {
[11:02:39.347]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:39.347]                       if (muffled) 
[11:02:39.347]                         invokeRestart("muffleWarning")
[11:02:39.347]                     }
[11:02:39.347]                     else if (inherits(cond, "condition")) {
[11:02:39.347]                       if (!is.null(pattern)) {
[11:02:39.347]                         computeRestarts <- base::computeRestarts
[11:02:39.347]                         grepl <- base::grepl
[11:02:39.347]                         restarts <- computeRestarts(cond)
[11:02:39.347]                         for (restart in restarts) {
[11:02:39.347]                           name <- restart$name
[11:02:39.347]                           if (is.null(name)) 
[11:02:39.347]                             next
[11:02:39.347]                           if (!grepl(pattern, name)) 
[11:02:39.347]                             next
[11:02:39.347]                           invokeRestart(restart)
[11:02:39.347]                           muffled <- TRUE
[11:02:39.347]                           break
[11:02:39.347]                         }
[11:02:39.347]                       }
[11:02:39.347]                     }
[11:02:39.347]                     invisible(muffled)
[11:02:39.347]                   }
[11:02:39.347]                   muffleCondition(cond)
[11:02:39.347]                 })
[11:02:39.347]             }))
[11:02:39.347]             future::FutureResult(value = ...future.value$value, 
[11:02:39.347]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:39.347]                   ...future.rng), globalenv = if (FALSE) 
[11:02:39.347]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:39.347]                     ...future.globalenv.names))
[11:02:39.347]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:39.347]         }, condition = base::local({
[11:02:39.347]             c <- base::c
[11:02:39.347]             inherits <- base::inherits
[11:02:39.347]             invokeRestart <- base::invokeRestart
[11:02:39.347]             length <- base::length
[11:02:39.347]             list <- base::list
[11:02:39.347]             seq.int <- base::seq.int
[11:02:39.347]             signalCondition <- base::signalCondition
[11:02:39.347]             sys.calls <- base::sys.calls
[11:02:39.347]             `[[` <- base::`[[`
[11:02:39.347]             `+` <- base::`+`
[11:02:39.347]             `<<-` <- base::`<<-`
[11:02:39.347]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:39.347]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:39.347]                   3L)]
[11:02:39.347]             }
[11:02:39.347]             function(cond) {
[11:02:39.347]                 is_error <- inherits(cond, "error")
[11:02:39.347]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:39.347]                   NULL)
[11:02:39.347]                 if (is_error) {
[11:02:39.347]                   sessionInformation <- function() {
[11:02:39.347]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:39.347]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:39.347]                       search = base::search(), system = base::Sys.info())
[11:02:39.347]                   }
[11:02:39.347]                   ...future.conditions[[length(...future.conditions) + 
[11:02:39.347]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:39.347]                     cond$call), session = sessionInformation(), 
[11:02:39.347]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:39.347]                   signalCondition(cond)
[11:02:39.347]                 }
[11:02:39.347]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:39.347]                 "immediateCondition"))) {
[11:02:39.347]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:39.347]                   ...future.conditions[[length(...future.conditions) + 
[11:02:39.347]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:39.347]                   if (TRUE && !signal) {
[11:02:39.347]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.347]                     {
[11:02:39.347]                       inherits <- base::inherits
[11:02:39.347]                       invokeRestart <- base::invokeRestart
[11:02:39.347]                       is.null <- base::is.null
[11:02:39.347]                       muffled <- FALSE
[11:02:39.347]                       if (inherits(cond, "message")) {
[11:02:39.347]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:39.347]                         if (muffled) 
[11:02:39.347]                           invokeRestart("muffleMessage")
[11:02:39.347]                       }
[11:02:39.347]                       else if (inherits(cond, "warning")) {
[11:02:39.347]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:39.347]                         if (muffled) 
[11:02:39.347]                           invokeRestart("muffleWarning")
[11:02:39.347]                       }
[11:02:39.347]                       else if (inherits(cond, "condition")) {
[11:02:39.347]                         if (!is.null(pattern)) {
[11:02:39.347]                           computeRestarts <- base::computeRestarts
[11:02:39.347]                           grepl <- base::grepl
[11:02:39.347]                           restarts <- computeRestarts(cond)
[11:02:39.347]                           for (restart in restarts) {
[11:02:39.347]                             name <- restart$name
[11:02:39.347]                             if (is.null(name)) 
[11:02:39.347]                               next
[11:02:39.347]                             if (!grepl(pattern, name)) 
[11:02:39.347]                               next
[11:02:39.347]                             invokeRestart(restart)
[11:02:39.347]                             muffled <- TRUE
[11:02:39.347]                             break
[11:02:39.347]                           }
[11:02:39.347]                         }
[11:02:39.347]                       }
[11:02:39.347]                       invisible(muffled)
[11:02:39.347]                     }
[11:02:39.347]                     muffleCondition(cond, pattern = "^muffle")
[11:02:39.347]                   }
[11:02:39.347]                 }
[11:02:39.347]                 else {
[11:02:39.347]                   if (TRUE) {
[11:02:39.347]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.347]                     {
[11:02:39.347]                       inherits <- base::inherits
[11:02:39.347]                       invokeRestart <- base::invokeRestart
[11:02:39.347]                       is.null <- base::is.null
[11:02:39.347]                       muffled <- FALSE
[11:02:39.347]                       if (inherits(cond, "message")) {
[11:02:39.347]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:39.347]                         if (muffled) 
[11:02:39.347]                           invokeRestart("muffleMessage")
[11:02:39.347]                       }
[11:02:39.347]                       else if (inherits(cond, "warning")) {
[11:02:39.347]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:39.347]                         if (muffled) 
[11:02:39.347]                           invokeRestart("muffleWarning")
[11:02:39.347]                       }
[11:02:39.347]                       else if (inherits(cond, "condition")) {
[11:02:39.347]                         if (!is.null(pattern)) {
[11:02:39.347]                           computeRestarts <- base::computeRestarts
[11:02:39.347]                           grepl <- base::grepl
[11:02:39.347]                           restarts <- computeRestarts(cond)
[11:02:39.347]                           for (restart in restarts) {
[11:02:39.347]                             name <- restart$name
[11:02:39.347]                             if (is.null(name)) 
[11:02:39.347]                               next
[11:02:39.347]                             if (!grepl(pattern, name)) 
[11:02:39.347]                               next
[11:02:39.347]                             invokeRestart(restart)
[11:02:39.347]                             muffled <- TRUE
[11:02:39.347]                             break
[11:02:39.347]                           }
[11:02:39.347]                         }
[11:02:39.347]                       }
[11:02:39.347]                       invisible(muffled)
[11:02:39.347]                     }
[11:02:39.347]                     muffleCondition(cond, pattern = "^muffle")
[11:02:39.347]                   }
[11:02:39.347]                 }
[11:02:39.347]             }
[11:02:39.347]         }))
[11:02:39.347]     }, error = function(ex) {
[11:02:39.347]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:39.347]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:39.347]                 ...future.rng), started = ...future.startTime, 
[11:02:39.347]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:39.347]             version = "1.8"), class = "FutureResult")
[11:02:39.347]     }, finally = {
[11:02:39.347]         if (!identical(...future.workdir, getwd())) 
[11:02:39.347]             setwd(...future.workdir)
[11:02:39.347]         {
[11:02:39.347]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:39.347]                 ...future.oldOptions$nwarnings <- NULL
[11:02:39.347]             }
[11:02:39.347]             base::options(...future.oldOptions)
[11:02:39.347]             if (.Platform$OS.type == "windows") {
[11:02:39.347]                 old_names <- names(...future.oldEnvVars)
[11:02:39.347]                 envs <- base::Sys.getenv()
[11:02:39.347]                 names <- names(envs)
[11:02:39.347]                 common <- intersect(names, old_names)
[11:02:39.347]                 added <- setdiff(names, old_names)
[11:02:39.347]                 removed <- setdiff(old_names, names)
[11:02:39.347]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:39.347]                   envs[common]]
[11:02:39.347]                 NAMES <- toupper(changed)
[11:02:39.347]                 args <- list()
[11:02:39.347]                 for (kk in seq_along(NAMES)) {
[11:02:39.347]                   name <- changed[[kk]]
[11:02:39.347]                   NAME <- NAMES[[kk]]
[11:02:39.347]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.347]                     next
[11:02:39.347]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:39.347]                 }
[11:02:39.347]                 NAMES <- toupper(added)
[11:02:39.347]                 for (kk in seq_along(NAMES)) {
[11:02:39.347]                   name <- added[[kk]]
[11:02:39.347]                   NAME <- NAMES[[kk]]
[11:02:39.347]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.347]                     next
[11:02:39.347]                   args[[name]] <- ""
[11:02:39.347]                 }
[11:02:39.347]                 NAMES <- toupper(removed)
[11:02:39.347]                 for (kk in seq_along(NAMES)) {
[11:02:39.347]                   name <- removed[[kk]]
[11:02:39.347]                   NAME <- NAMES[[kk]]
[11:02:39.347]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.347]                     next
[11:02:39.347]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:39.347]                 }
[11:02:39.347]                 if (length(args) > 0) 
[11:02:39.347]                   base::do.call(base::Sys.setenv, args = args)
[11:02:39.347]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:39.347]             }
[11:02:39.347]             else {
[11:02:39.347]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:39.347]             }
[11:02:39.347]             {
[11:02:39.347]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:39.347]                   0L) {
[11:02:39.347]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:39.347]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:39.347]                   base::options(opts)
[11:02:39.347]                 }
[11:02:39.347]                 {
[11:02:39.347]                   {
[11:02:39.347]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:39.347]                     NULL
[11:02:39.347]                   }
[11:02:39.347]                   options(future.plan = NULL)
[11:02:39.347]                   if (is.na(NA_character_)) 
[11:02:39.347]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:39.347]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:39.347]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:39.347]                     .init = FALSE)
[11:02:39.347]                 }
[11:02:39.347]             }
[11:02:39.347]         }
[11:02:39.347]     })
[11:02:39.347]     if (TRUE) {
[11:02:39.347]         base::sink(type = "output", split = FALSE)
[11:02:39.347]         if (TRUE) {
[11:02:39.347]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:39.347]         }
[11:02:39.347]         else {
[11:02:39.347]             ...future.result["stdout"] <- base::list(NULL)
[11:02:39.347]         }
[11:02:39.347]         base::close(...future.stdout)
[11:02:39.347]         ...future.stdout <- NULL
[11:02:39.347]     }
[11:02:39.347]     ...future.result$conditions <- ...future.conditions
[11:02:39.347]     ...future.result$finished <- base::Sys.time()
[11:02:39.347]     ...future.result
[11:02:39.347] }
[11:02:39.351] assign_globals() ...
[11:02:39.351] List of 1
[11:02:39.351]  $ kk: int 3
[11:02:39.351]  - attr(*, "where")=List of 1
[11:02:39.351]   ..$ kk:<environment: R_EmptyEnv> 
[11:02:39.351]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:02:39.351]  - attr(*, "resolved")= logi FALSE
[11:02:39.351]  - attr(*, "total_size")= num 35
[11:02:39.351]  - attr(*, "already-done")= logi TRUE
[11:02:39.355] - copied ‘kk’ to environment
[11:02:39.355] assign_globals() ... done
[11:02:39.355] requestCore(): workers = 2
[11:02:39.355] Poll #1 (0): usedCores() = 2, workers = 2
[11:02:39.387] Poll #2 (0.03 secs): usedCores() = 2, workers = 2
[11:02:39.390] plan(): Setting new future strategy stack:
[11:02:39.391] List of future strategies:
[11:02:39.391] 1. multicore:
[11:02:39.391]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:39.391]    - tweaked: FALSE
[11:02:39.391]    - call: plan(strategy)
[11:02:39.394] plan(): nbrOfWorkers() = 2
[11:02:39.397] result() for MulticoreFuture ...
[11:02:39.398] result() for MulticoreFuture ...
[11:02:39.399] result() for MulticoreFuture ... done
[11:02:39.399] result() for MulticoreFuture ... done
[11:02:39.399] result() for MulticoreFuture ...
[11:02:39.399] result() for MulticoreFuture ... done
[11:02:39.401] MulticoreFuture started
[11:02:39.402] - Launch lazy future ... done
[11:02:39.402] run() for ‘MulticoreFuture’ ... done
[11:02:39.402] plan(): Setting new future strategy stack:
[11:02:39.403] List of future strategies:
[11:02:39.403] 1. sequential:
[11:02:39.403]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:39.403]    - tweaked: FALSE
[11:02:39.403]    - call: NULL
[11:02:39.404] plan(): nbrOfWorkers() = 1
[11:02:39.423] Future #1
[11:02:39.423]  length: 2 (resolved future 1)
[11:02:39.432] plan(): Setting new future strategy stack:
[11:02:39.432] List of future strategies:
[11:02:39.432] 1. multicore:
[11:02:39.432]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:39.432]    - tweaked: FALSE
[11:02:39.432]    - call: plan(strategy)
[11:02:39.435] plan(): nbrOfWorkers() = 2
[11:02:39.454] Future #2
[11:02:39.455]  length: 1 (resolved future 2)
[11:02:39.506] plan(): Setting new future strategy stack:
[11:02:39.506] List of future strategies:
[11:02:39.506] 1. multicore:
[11:02:39.506]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:39.506]    - tweaked: FALSE
[11:02:39.506]    - call: plan(strategy)
[11:02:39.509] plan(): nbrOfWorkers() = 2
[11:02:39.516] Future #3
[11:02:39.516]  length: 0 (resolved future 3)
[11:02:39.517] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[11:02:39.518] resolve() on environment ...
[11:02:39.518]  recursive: 0
[11:02:39.519]  elements: [2] ‘a’, ‘b’
[11:02:39.519]  length: 1 (resolved future 1)
[11:02:39.519]  length: 0 (resolved future 2)
[11:02:39.519] resolve() on environment ... DONE
[11:02:39.520] getGlobalsAndPackages() ...
[11:02:39.520] Searching for globals...
[11:02:39.521] 
[11:02:39.521] Searching for globals ... DONE
[11:02:39.521] - globals: [0] <none>
[11:02:39.521] getGlobalsAndPackages() ... DONE
[11:02:39.522] run() for ‘Future’ ...
[11:02:39.525] - state: ‘created’
[11:02:39.526] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:02:39.530] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:39.530] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:02:39.531]   - Field: ‘label’
[11:02:39.531]   - Field: ‘local’
[11:02:39.531]   - Field: ‘owner’
[11:02:39.531]   - Field: ‘envir’
[11:02:39.531]   - Field: ‘workers’
[11:02:39.532]   - Field: ‘packages’
[11:02:39.532]   - Field: ‘gc’
[11:02:39.532]   - Field: ‘job’
[11:02:39.532]   - Field: ‘conditions’
[11:02:39.532]   - Field: ‘expr’
[11:02:39.532]   - Field: ‘uuid’
[11:02:39.533]   - Field: ‘seed’
[11:02:39.533]   - Field: ‘version’
[11:02:39.533]   - Field: ‘result’
[11:02:39.533]   - Field: ‘asynchronous’
[11:02:39.533]   - Field: ‘calls’
[11:02:39.533]   - Field: ‘globals’
[11:02:39.534]   - Field: ‘stdout’
[11:02:39.534]   - Field: ‘earlySignal’
[11:02:39.534]   - Field: ‘lazy’
[11:02:39.534]   - Field: ‘state’
[11:02:39.534] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:02:39.534] - Launch lazy future ...
[11:02:39.535] Packages needed by the future expression (n = 0): <none>
[11:02:39.535] Packages needed by future strategies (n = 0): <none>
[11:02:39.536] {
[11:02:39.536]     {
[11:02:39.536]         {
[11:02:39.536]             ...future.startTime <- base::Sys.time()
[11:02:39.536]             {
[11:02:39.536]                 {
[11:02:39.536]                   {
[11:02:39.536]                     {
[11:02:39.536]                       base::local({
[11:02:39.536]                         has_future <- base::requireNamespace("future", 
[11:02:39.536]                           quietly = TRUE)
[11:02:39.536]                         if (has_future) {
[11:02:39.536]                           ns <- base::getNamespace("future")
[11:02:39.536]                           version <- ns[[".package"]][["version"]]
[11:02:39.536]                           if (is.null(version)) 
[11:02:39.536]                             version <- utils::packageVersion("future")
[11:02:39.536]                         }
[11:02:39.536]                         else {
[11:02:39.536]                           version <- NULL
[11:02:39.536]                         }
[11:02:39.536]                         if (!has_future || version < "1.8.0") {
[11:02:39.536]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:39.536]                             "", base::R.version$version.string), 
[11:02:39.536]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:39.536]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:39.536]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:39.536]                               "release", "version")], collapse = " "), 
[11:02:39.536]                             hostname = base::Sys.info()[["nodename"]])
[11:02:39.536]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:39.536]                             info)
[11:02:39.536]                           info <- base::paste(info, collapse = "; ")
[11:02:39.536]                           if (!has_future) {
[11:02:39.536]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:39.536]                               info)
[11:02:39.536]                           }
[11:02:39.536]                           else {
[11:02:39.536]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:39.536]                               info, version)
[11:02:39.536]                           }
[11:02:39.536]                           base::stop(msg)
[11:02:39.536]                         }
[11:02:39.536]                       })
[11:02:39.536]                     }
[11:02:39.536]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:39.536]                     base::options(mc.cores = 1L)
[11:02:39.536]                   }
[11:02:39.536]                   ...future.strategy.old <- future::plan("list")
[11:02:39.536]                   options(future.plan = NULL)
[11:02:39.536]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:39.536]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:39.536]                 }
[11:02:39.536]                 ...future.workdir <- getwd()
[11:02:39.536]             }
[11:02:39.536]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:39.536]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:39.536]         }
[11:02:39.536]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:39.536]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:39.536]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:39.536]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:39.536]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:39.536]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:39.536]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:39.536]             base::names(...future.oldOptions))
[11:02:39.536]     }
[11:02:39.536]     if (FALSE) {
[11:02:39.536]     }
[11:02:39.536]     else {
[11:02:39.536]         if (TRUE) {
[11:02:39.536]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:39.536]                 open = "w")
[11:02:39.536]         }
[11:02:39.536]         else {
[11:02:39.536]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:39.536]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:39.536]         }
[11:02:39.536]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:39.536]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:39.536]             base::sink(type = "output", split = FALSE)
[11:02:39.536]             base::close(...future.stdout)
[11:02:39.536]         }, add = TRUE)
[11:02:39.536]     }
[11:02:39.536]     ...future.frame <- base::sys.nframe()
[11:02:39.536]     ...future.conditions <- base::list()
[11:02:39.536]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:39.536]     if (FALSE) {
[11:02:39.536]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:39.536]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:39.536]     }
[11:02:39.536]     ...future.result <- base::tryCatch({
[11:02:39.536]         base::withCallingHandlers({
[11:02:39.536]             ...future.value <- base::withVisible(base::local({
[11:02:39.536]                 withCallingHandlers({
[11:02:39.536]                   1
[11:02:39.536]                 }, immediateCondition = function(cond) {
[11:02:39.536]                   save_rds <- function (object, pathname, ...) 
[11:02:39.536]                   {
[11:02:39.536]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:02:39.536]                     if (file_test("-f", pathname_tmp)) {
[11:02:39.536]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.536]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:02:39.536]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.536]                         fi_tmp[["mtime"]])
[11:02:39.536]                     }
[11:02:39.536]                     tryCatch({
[11:02:39.536]                       saveRDS(object, file = pathname_tmp, ...)
[11:02:39.536]                     }, error = function(ex) {
[11:02:39.536]                       msg <- conditionMessage(ex)
[11:02:39.536]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.536]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:02:39.536]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.536]                         fi_tmp[["mtime"]], msg)
[11:02:39.536]                       ex$message <- msg
[11:02:39.536]                       stop(ex)
[11:02:39.536]                     })
[11:02:39.536]                     stopifnot(file_test("-f", pathname_tmp))
[11:02:39.536]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:02:39.536]                     if (!res || file_test("-f", pathname_tmp)) {
[11:02:39.536]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.536]                       fi <- file.info(pathname)
[11:02:39.536]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:02:39.536]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.536]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:02:39.536]                         fi[["size"]], fi[["mtime"]])
[11:02:39.536]                       stop(msg)
[11:02:39.536]                     }
[11:02:39.536]                     invisible(pathname)
[11:02:39.536]                   }
[11:02:39.536]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:02:39.536]                     rootPath = tempdir()) 
[11:02:39.536]                   {
[11:02:39.536]                     obj <- list(time = Sys.time(), condition = cond)
[11:02:39.536]                     file <- tempfile(pattern = class(cond)[1], 
[11:02:39.536]                       tmpdir = path, fileext = ".rds")
[11:02:39.536]                     save_rds(obj, file)
[11:02:39.536]                   }
[11:02:39.536]                   saveImmediateCondition(cond, path = "/tmp/RtmpPVwpFC/.future/immediateConditions")
[11:02:39.536]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.536]                   {
[11:02:39.536]                     inherits <- base::inherits
[11:02:39.536]                     invokeRestart <- base::invokeRestart
[11:02:39.536]                     is.null <- base::is.null
[11:02:39.536]                     muffled <- FALSE
[11:02:39.536]                     if (inherits(cond, "message")) {
[11:02:39.536]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:39.536]                       if (muffled) 
[11:02:39.536]                         invokeRestart("muffleMessage")
[11:02:39.536]                     }
[11:02:39.536]                     else if (inherits(cond, "warning")) {
[11:02:39.536]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:39.536]                       if (muffled) 
[11:02:39.536]                         invokeRestart("muffleWarning")
[11:02:39.536]                     }
[11:02:39.536]                     else if (inherits(cond, "condition")) {
[11:02:39.536]                       if (!is.null(pattern)) {
[11:02:39.536]                         computeRestarts <- base::computeRestarts
[11:02:39.536]                         grepl <- base::grepl
[11:02:39.536]                         restarts <- computeRestarts(cond)
[11:02:39.536]                         for (restart in restarts) {
[11:02:39.536]                           name <- restart$name
[11:02:39.536]                           if (is.null(name)) 
[11:02:39.536]                             next
[11:02:39.536]                           if (!grepl(pattern, name)) 
[11:02:39.536]                             next
[11:02:39.536]                           invokeRestart(restart)
[11:02:39.536]                           muffled <- TRUE
[11:02:39.536]                           break
[11:02:39.536]                         }
[11:02:39.536]                       }
[11:02:39.536]                     }
[11:02:39.536]                     invisible(muffled)
[11:02:39.536]                   }
[11:02:39.536]                   muffleCondition(cond)
[11:02:39.536]                 })
[11:02:39.536]             }))
[11:02:39.536]             future::FutureResult(value = ...future.value$value, 
[11:02:39.536]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:39.536]                   ...future.rng), globalenv = if (FALSE) 
[11:02:39.536]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:39.536]                     ...future.globalenv.names))
[11:02:39.536]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:39.536]         }, condition = base::local({
[11:02:39.536]             c <- base::c
[11:02:39.536]             inherits <- base::inherits
[11:02:39.536]             invokeRestart <- base::invokeRestart
[11:02:39.536]             length <- base::length
[11:02:39.536]             list <- base::list
[11:02:39.536]             seq.int <- base::seq.int
[11:02:39.536]             signalCondition <- base::signalCondition
[11:02:39.536]             sys.calls <- base::sys.calls
[11:02:39.536]             `[[` <- base::`[[`
[11:02:39.536]             `+` <- base::`+`
[11:02:39.536]             `<<-` <- base::`<<-`
[11:02:39.536]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:39.536]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:39.536]                   3L)]
[11:02:39.536]             }
[11:02:39.536]             function(cond) {
[11:02:39.536]                 is_error <- inherits(cond, "error")
[11:02:39.536]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:39.536]                   NULL)
[11:02:39.536]                 if (is_error) {
[11:02:39.536]                   sessionInformation <- function() {
[11:02:39.536]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:39.536]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:39.536]                       search = base::search(), system = base::Sys.info())
[11:02:39.536]                   }
[11:02:39.536]                   ...future.conditions[[length(...future.conditions) + 
[11:02:39.536]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:39.536]                     cond$call), session = sessionInformation(), 
[11:02:39.536]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:39.536]                   signalCondition(cond)
[11:02:39.536]                 }
[11:02:39.536]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:39.536]                 "immediateCondition"))) {
[11:02:39.536]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:39.536]                   ...future.conditions[[length(...future.conditions) + 
[11:02:39.536]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:39.536]                   if (TRUE && !signal) {
[11:02:39.536]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.536]                     {
[11:02:39.536]                       inherits <- base::inherits
[11:02:39.536]                       invokeRestart <- base::invokeRestart
[11:02:39.536]                       is.null <- base::is.null
[11:02:39.536]                       muffled <- FALSE
[11:02:39.536]                       if (inherits(cond, "message")) {
[11:02:39.536]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:39.536]                         if (muffled) 
[11:02:39.536]                           invokeRestart("muffleMessage")
[11:02:39.536]                       }
[11:02:39.536]                       else if (inherits(cond, "warning")) {
[11:02:39.536]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:39.536]                         if (muffled) 
[11:02:39.536]                           invokeRestart("muffleWarning")
[11:02:39.536]                       }
[11:02:39.536]                       else if (inherits(cond, "condition")) {
[11:02:39.536]                         if (!is.null(pattern)) {
[11:02:39.536]                           computeRestarts <- base::computeRestarts
[11:02:39.536]                           grepl <- base::grepl
[11:02:39.536]                           restarts <- computeRestarts(cond)
[11:02:39.536]                           for (restart in restarts) {
[11:02:39.536]                             name <- restart$name
[11:02:39.536]                             if (is.null(name)) 
[11:02:39.536]                               next
[11:02:39.536]                             if (!grepl(pattern, name)) 
[11:02:39.536]                               next
[11:02:39.536]                             invokeRestart(restart)
[11:02:39.536]                             muffled <- TRUE
[11:02:39.536]                             break
[11:02:39.536]                           }
[11:02:39.536]                         }
[11:02:39.536]                       }
[11:02:39.536]                       invisible(muffled)
[11:02:39.536]                     }
[11:02:39.536]                     muffleCondition(cond, pattern = "^muffle")
[11:02:39.536]                   }
[11:02:39.536]                 }
[11:02:39.536]                 else {
[11:02:39.536]                   if (TRUE) {
[11:02:39.536]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.536]                     {
[11:02:39.536]                       inherits <- base::inherits
[11:02:39.536]                       invokeRestart <- base::invokeRestart
[11:02:39.536]                       is.null <- base::is.null
[11:02:39.536]                       muffled <- FALSE
[11:02:39.536]                       if (inherits(cond, "message")) {
[11:02:39.536]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:39.536]                         if (muffled) 
[11:02:39.536]                           invokeRestart("muffleMessage")
[11:02:39.536]                       }
[11:02:39.536]                       else if (inherits(cond, "warning")) {
[11:02:39.536]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:39.536]                         if (muffled) 
[11:02:39.536]                           invokeRestart("muffleWarning")
[11:02:39.536]                       }
[11:02:39.536]                       else if (inherits(cond, "condition")) {
[11:02:39.536]                         if (!is.null(pattern)) {
[11:02:39.536]                           computeRestarts <- base::computeRestarts
[11:02:39.536]                           grepl <- base::grepl
[11:02:39.536]                           restarts <- computeRestarts(cond)
[11:02:39.536]                           for (restart in restarts) {
[11:02:39.536]                             name <- restart$name
[11:02:39.536]                             if (is.null(name)) 
[11:02:39.536]                               next
[11:02:39.536]                             if (!grepl(pattern, name)) 
[11:02:39.536]                               next
[11:02:39.536]                             invokeRestart(restart)
[11:02:39.536]                             muffled <- TRUE
[11:02:39.536]                             break
[11:02:39.536]                           }
[11:02:39.536]                         }
[11:02:39.536]                       }
[11:02:39.536]                       invisible(muffled)
[11:02:39.536]                     }
[11:02:39.536]                     muffleCondition(cond, pattern = "^muffle")
[11:02:39.536]                   }
[11:02:39.536]                 }
[11:02:39.536]             }
[11:02:39.536]         }))
[11:02:39.536]     }, error = function(ex) {
[11:02:39.536]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:39.536]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:39.536]                 ...future.rng), started = ...future.startTime, 
[11:02:39.536]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:39.536]             version = "1.8"), class = "FutureResult")
[11:02:39.536]     }, finally = {
[11:02:39.536]         if (!identical(...future.workdir, getwd())) 
[11:02:39.536]             setwd(...future.workdir)
[11:02:39.536]         {
[11:02:39.536]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:39.536]                 ...future.oldOptions$nwarnings <- NULL
[11:02:39.536]             }
[11:02:39.536]             base::options(...future.oldOptions)
[11:02:39.536]             if (.Platform$OS.type == "windows") {
[11:02:39.536]                 old_names <- names(...future.oldEnvVars)
[11:02:39.536]                 envs <- base::Sys.getenv()
[11:02:39.536]                 names <- names(envs)
[11:02:39.536]                 common <- intersect(names, old_names)
[11:02:39.536]                 added <- setdiff(names, old_names)
[11:02:39.536]                 removed <- setdiff(old_names, names)
[11:02:39.536]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:39.536]                   envs[common]]
[11:02:39.536]                 NAMES <- toupper(changed)
[11:02:39.536]                 args <- list()
[11:02:39.536]                 for (kk in seq_along(NAMES)) {
[11:02:39.536]                   name <- changed[[kk]]
[11:02:39.536]                   NAME <- NAMES[[kk]]
[11:02:39.536]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.536]                     next
[11:02:39.536]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:39.536]                 }
[11:02:39.536]                 NAMES <- toupper(added)
[11:02:39.536]                 for (kk in seq_along(NAMES)) {
[11:02:39.536]                   name <- added[[kk]]
[11:02:39.536]                   NAME <- NAMES[[kk]]
[11:02:39.536]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.536]                     next
[11:02:39.536]                   args[[name]] <- ""
[11:02:39.536]                 }
[11:02:39.536]                 NAMES <- toupper(removed)
[11:02:39.536]                 for (kk in seq_along(NAMES)) {
[11:02:39.536]                   name <- removed[[kk]]
[11:02:39.536]                   NAME <- NAMES[[kk]]
[11:02:39.536]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.536]                     next
[11:02:39.536]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:39.536]                 }
[11:02:39.536]                 if (length(args) > 0) 
[11:02:39.536]                   base::do.call(base::Sys.setenv, args = args)
[11:02:39.536]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:39.536]             }
[11:02:39.536]             else {
[11:02:39.536]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:39.536]             }
[11:02:39.536]             {
[11:02:39.536]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:39.536]                   0L) {
[11:02:39.536]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:39.536]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:39.536]                   base::options(opts)
[11:02:39.536]                 }
[11:02:39.536]                 {
[11:02:39.536]                   {
[11:02:39.536]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:39.536]                     NULL
[11:02:39.536]                   }
[11:02:39.536]                   options(future.plan = NULL)
[11:02:39.536]                   if (is.na(NA_character_)) 
[11:02:39.536]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:39.536]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:39.536]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:39.536]                     .init = FALSE)
[11:02:39.536]                 }
[11:02:39.536]             }
[11:02:39.536]         }
[11:02:39.536]     })
[11:02:39.536]     if (TRUE) {
[11:02:39.536]         base::sink(type = "output", split = FALSE)
[11:02:39.536]         if (TRUE) {
[11:02:39.536]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:39.536]         }
[11:02:39.536]         else {
[11:02:39.536]             ...future.result["stdout"] <- base::list(NULL)
[11:02:39.536]         }
[11:02:39.536]         base::close(...future.stdout)
[11:02:39.536]         ...future.stdout <- NULL
[11:02:39.536]     }
[11:02:39.536]     ...future.result$conditions <- ...future.conditions
[11:02:39.536]     ...future.result$finished <- base::Sys.time()
[11:02:39.536]     ...future.result
[11:02:39.536] }
[11:02:39.538] requestCore(): workers = 2
[11:02:39.538] Poll #1 (0): usedCores() = 2, workers = 2
[11:02:39.549] result() for MulticoreFuture ...
[11:02:39.550] result() for MulticoreFuture ...
[11:02:39.550] result() for MulticoreFuture ... done
[11:02:39.550] result() for MulticoreFuture ... done
[11:02:39.551] result() for MulticoreFuture ...
[11:02:39.551] result() for MulticoreFuture ... done
[11:02:39.553] MulticoreFuture started
[11:02:39.554] - Launch lazy future ... done
[11:02:39.554] run() for ‘MulticoreFuture’ ... done
[11:02:39.555] plan(): Setting new future strategy stack:
[11:02:39.555] getGlobalsAndPackages() ...
[11:02:39.555] Searching for globals...
[11:02:39.556] 
[11:02:39.555] List of future strategies:
[11:02:39.555] 1. sequential:
[11:02:39.555]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:39.555]    - tweaked: FALSE
[11:02:39.555]    - call: NULL
[11:02:39.556] Searching for globals ... DONE
[11:02:39.556] - globals: [0] <none>
[11:02:39.556] plan(): nbrOfWorkers() = 1
[11:02:39.556] getGlobalsAndPackages() ... DONE
[11:02:39.557] run() for ‘Future’ ...
[11:02:39.557] - state: ‘created’
[11:02:39.557] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:02:39.559] plan(): Setting new future strategy stack:
[11:02:39.559] List of future strategies:
[11:02:39.559] 1. multicore:
[11:02:39.559]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:39.559]    - tweaked: FALSE
[11:02:39.559]    - call: plan(strategy)
[11:02:39.560] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:39.560] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:02:39.561]   - Field: ‘label’
[11:02:39.561]   - Field: ‘local’
[11:02:39.561]   - Field: ‘owner’
[11:02:39.561]   - Field: ‘envir’
[11:02:39.561]   - Field: ‘workers’
[11:02:39.561]   - Field: ‘packages’
[11:02:39.562]   - Field: ‘gc’
[11:02:39.562]   - Field: ‘job’
[11:02:39.562]   - Field: ‘conditions’
[11:02:39.562]   - Field: ‘expr’
[11:02:39.562] plan(): nbrOfWorkers() = 2
[11:02:39.562]   - Field: ‘uuid’
[11:02:39.562]   - Field: ‘seed’
[11:02:39.563]   - Field: ‘version’
[11:02:39.563]   - Field: ‘result’
[11:02:39.563]   - Field: ‘asynchronous’
[11:02:39.563]   - Field: ‘calls’
[11:02:39.563]   - Field: ‘globals’
[11:02:39.563]   - Field: ‘stdout’
[11:02:39.563]   - Field: ‘earlySignal’
[11:02:39.564]   - Field: ‘lazy’
[11:02:39.564]   - Field: ‘state’
[11:02:39.564] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:02:39.564] - Launch lazy future ...
[11:02:39.564] Packages needed by the future expression (n = 0): <none>
[11:02:39.565] Packages needed by future strategies (n = 0): <none>
[11:02:39.565] {
[11:02:39.565]     {
[11:02:39.565]         {
[11:02:39.565]             ...future.startTime <- base::Sys.time()
[11:02:39.565]             {
[11:02:39.565]                 {
[11:02:39.565]                   {
[11:02:39.565]                     {
[11:02:39.565]                       base::local({
[11:02:39.565]                         has_future <- base::requireNamespace("future", 
[11:02:39.565]                           quietly = TRUE)
[11:02:39.565]                         if (has_future) {
[11:02:39.565]                           ns <- base::getNamespace("future")
[11:02:39.565]                           version <- ns[[".package"]][["version"]]
[11:02:39.565]                           if (is.null(version)) 
[11:02:39.565]                             version <- utils::packageVersion("future")
[11:02:39.565]                         }
[11:02:39.565]                         else {
[11:02:39.565]                           version <- NULL
[11:02:39.565]                         }
[11:02:39.565]                         if (!has_future || version < "1.8.0") {
[11:02:39.565]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:39.565]                             "", base::R.version$version.string), 
[11:02:39.565]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:39.565]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:39.565]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:39.565]                               "release", "version")], collapse = " "), 
[11:02:39.565]                             hostname = base::Sys.info()[["nodename"]])
[11:02:39.565]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:39.565]                             info)
[11:02:39.565]                           info <- base::paste(info, collapse = "; ")
[11:02:39.565]                           if (!has_future) {
[11:02:39.565]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:39.565]                               info)
[11:02:39.565]                           }
[11:02:39.565]                           else {
[11:02:39.565]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:39.565]                               info, version)
[11:02:39.565]                           }
[11:02:39.565]                           base::stop(msg)
[11:02:39.565]                         }
[11:02:39.565]                       })
[11:02:39.565]                     }
[11:02:39.565]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:39.565]                     base::options(mc.cores = 1L)
[11:02:39.565]                   }
[11:02:39.565]                   ...future.strategy.old <- future::plan("list")
[11:02:39.565]                   options(future.plan = NULL)
[11:02:39.565]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:39.565]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:39.565]                 }
[11:02:39.565]                 ...future.workdir <- getwd()
[11:02:39.565]             }
[11:02:39.565]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:39.565]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:39.565]         }
[11:02:39.565]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:39.565]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:39.565]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:39.565]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:39.565]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:39.565]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:39.565]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:39.565]             base::names(...future.oldOptions))
[11:02:39.565]     }
[11:02:39.565]     if (FALSE) {
[11:02:39.565]     }
[11:02:39.565]     else {
[11:02:39.565]         if (TRUE) {
[11:02:39.565]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:39.565]                 open = "w")
[11:02:39.565]         }
[11:02:39.565]         else {
[11:02:39.565]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:39.565]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:39.565]         }
[11:02:39.565]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:39.565]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:39.565]             base::sink(type = "output", split = FALSE)
[11:02:39.565]             base::close(...future.stdout)
[11:02:39.565]         }, add = TRUE)
[11:02:39.565]     }
[11:02:39.565]     ...future.frame <- base::sys.nframe()
[11:02:39.565]     ...future.conditions <- base::list()
[11:02:39.565]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:39.565]     if (FALSE) {
[11:02:39.565]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:39.565]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:39.565]     }
[11:02:39.565]     ...future.result <- base::tryCatch({
[11:02:39.565]         base::withCallingHandlers({
[11:02:39.565]             ...future.value <- base::withVisible(base::local({
[11:02:39.565]                 withCallingHandlers({
[11:02:39.565]                   2
[11:02:39.565]                 }, immediateCondition = function(cond) {
[11:02:39.565]                   save_rds <- function (object, pathname, ...) 
[11:02:39.565]                   {
[11:02:39.565]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:02:39.565]                     if (file_test("-f", pathname_tmp)) {
[11:02:39.565]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.565]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:02:39.565]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.565]                         fi_tmp[["mtime"]])
[11:02:39.565]                     }
[11:02:39.565]                     tryCatch({
[11:02:39.565]                       saveRDS(object, file = pathname_tmp, ...)
[11:02:39.565]                     }, error = function(ex) {
[11:02:39.565]                       msg <- conditionMessage(ex)
[11:02:39.565]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.565]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:02:39.565]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.565]                         fi_tmp[["mtime"]], msg)
[11:02:39.565]                       ex$message <- msg
[11:02:39.565]                       stop(ex)
[11:02:39.565]                     })
[11:02:39.565]                     stopifnot(file_test("-f", pathname_tmp))
[11:02:39.565]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:02:39.565]                     if (!res || file_test("-f", pathname_tmp)) {
[11:02:39.565]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.565]                       fi <- file.info(pathname)
[11:02:39.565]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:02:39.565]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.565]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:02:39.565]                         fi[["size"]], fi[["mtime"]])
[11:02:39.565]                       stop(msg)
[11:02:39.565]                     }
[11:02:39.565]                     invisible(pathname)
[11:02:39.565]                   }
[11:02:39.565]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:02:39.565]                     rootPath = tempdir()) 
[11:02:39.565]                   {
[11:02:39.565]                     obj <- list(time = Sys.time(), condition = cond)
[11:02:39.565]                     file <- tempfile(pattern = class(cond)[1], 
[11:02:39.565]                       tmpdir = path, fileext = ".rds")
[11:02:39.565]                     save_rds(obj, file)
[11:02:39.565]                   }
[11:02:39.565]                   saveImmediateCondition(cond, path = "/tmp/RtmpPVwpFC/.future/immediateConditions")
[11:02:39.565]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.565]                   {
[11:02:39.565]                     inherits <- base::inherits
[11:02:39.565]                     invokeRestart <- base::invokeRestart
[11:02:39.565]                     is.null <- base::is.null
[11:02:39.565]                     muffled <- FALSE
[11:02:39.565]                     if (inherits(cond, "message")) {
[11:02:39.565]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:39.565]                       if (muffled) 
[11:02:39.565]                         invokeRestart("muffleMessage")
[11:02:39.565]                     }
[11:02:39.565]                     else if (inherits(cond, "warning")) {
[11:02:39.565]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:39.565]                       if (muffled) 
[11:02:39.565]                         invokeRestart("muffleWarning")
[11:02:39.565]                     }
[11:02:39.565]                     else if (inherits(cond, "condition")) {
[11:02:39.565]                       if (!is.null(pattern)) {
[11:02:39.565]                         computeRestarts <- base::computeRestarts
[11:02:39.565]                         grepl <- base::grepl
[11:02:39.565]                         restarts <- computeRestarts(cond)
[11:02:39.565]                         for (restart in restarts) {
[11:02:39.565]                           name <- restart$name
[11:02:39.565]                           if (is.null(name)) 
[11:02:39.565]                             next
[11:02:39.565]                           if (!grepl(pattern, name)) 
[11:02:39.565]                             next
[11:02:39.565]                           invokeRestart(restart)
[11:02:39.565]                           muffled <- TRUE
[11:02:39.565]                           break
[11:02:39.565]                         }
[11:02:39.565]                       }
[11:02:39.565]                     }
[11:02:39.565]                     invisible(muffled)
[11:02:39.565]                   }
[11:02:39.565]                   muffleCondition(cond)
[11:02:39.565]                 })
[11:02:39.565]             }))
[11:02:39.565]             future::FutureResult(value = ...future.value$value, 
[11:02:39.565]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:39.565]                   ...future.rng), globalenv = if (FALSE) 
[11:02:39.565]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:39.565]                     ...future.globalenv.names))
[11:02:39.565]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:39.565]         }, condition = base::local({
[11:02:39.565]             c <- base::c
[11:02:39.565]             inherits <- base::inherits
[11:02:39.565]             invokeRestart <- base::invokeRestart
[11:02:39.565]             length <- base::length
[11:02:39.565]             list <- base::list
[11:02:39.565]             seq.int <- base::seq.int
[11:02:39.565]             signalCondition <- base::signalCondition
[11:02:39.565]             sys.calls <- base::sys.calls
[11:02:39.565]             `[[` <- base::`[[`
[11:02:39.565]             `+` <- base::`+`
[11:02:39.565]             `<<-` <- base::`<<-`
[11:02:39.565]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:39.565]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:39.565]                   3L)]
[11:02:39.565]             }
[11:02:39.565]             function(cond) {
[11:02:39.565]                 is_error <- inherits(cond, "error")
[11:02:39.565]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:39.565]                   NULL)
[11:02:39.565]                 if (is_error) {
[11:02:39.565]                   sessionInformation <- function() {
[11:02:39.565]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:39.565]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:39.565]                       search = base::search(), system = base::Sys.info())
[11:02:39.565]                   }
[11:02:39.565]                   ...future.conditions[[length(...future.conditions) + 
[11:02:39.565]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:39.565]                     cond$call), session = sessionInformation(), 
[11:02:39.565]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:39.565]                   signalCondition(cond)
[11:02:39.565]                 }
[11:02:39.565]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:39.565]                 "immediateCondition"))) {
[11:02:39.565]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:39.565]                   ...future.conditions[[length(...future.conditions) + 
[11:02:39.565]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:39.565]                   if (TRUE && !signal) {
[11:02:39.565]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.565]                     {
[11:02:39.565]                       inherits <- base::inherits
[11:02:39.565]                       invokeRestart <- base::invokeRestart
[11:02:39.565]                       is.null <- base::is.null
[11:02:39.565]                       muffled <- FALSE
[11:02:39.565]                       if (inherits(cond, "message")) {
[11:02:39.565]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:39.565]                         if (muffled) 
[11:02:39.565]                           invokeRestart("muffleMessage")
[11:02:39.565]                       }
[11:02:39.565]                       else if (inherits(cond, "warning")) {
[11:02:39.565]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:39.565]                         if (muffled) 
[11:02:39.565]                           invokeRestart("muffleWarning")
[11:02:39.565]                       }
[11:02:39.565]                       else if (inherits(cond, "condition")) {
[11:02:39.565]                         if (!is.null(pattern)) {
[11:02:39.565]                           computeRestarts <- base::computeRestarts
[11:02:39.565]                           grepl <- base::grepl
[11:02:39.565]                           restarts <- computeRestarts(cond)
[11:02:39.565]                           for (restart in restarts) {
[11:02:39.565]                             name <- restart$name
[11:02:39.565]                             if (is.null(name)) 
[11:02:39.565]                               next
[11:02:39.565]                             if (!grepl(pattern, name)) 
[11:02:39.565]                               next
[11:02:39.565]                             invokeRestart(restart)
[11:02:39.565]                             muffled <- TRUE
[11:02:39.565]                             break
[11:02:39.565]                           }
[11:02:39.565]                         }
[11:02:39.565]                       }
[11:02:39.565]                       invisible(muffled)
[11:02:39.565]                     }
[11:02:39.565]                     muffleCondition(cond, pattern = "^muffle")
[11:02:39.565]                   }
[11:02:39.565]                 }
[11:02:39.565]                 else {
[11:02:39.565]                   if (TRUE) {
[11:02:39.565]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.565]                     {
[11:02:39.565]                       inherits <- base::inherits
[11:02:39.565]                       invokeRestart <- base::invokeRestart
[11:02:39.565]                       is.null <- base::is.null
[11:02:39.565]                       muffled <- FALSE
[11:02:39.565]                       if (inherits(cond, "message")) {
[11:02:39.565]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:39.565]                         if (muffled) 
[11:02:39.565]                           invokeRestart("muffleMessage")
[11:02:39.565]                       }
[11:02:39.565]                       else if (inherits(cond, "warning")) {
[11:02:39.565]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:39.565]                         if (muffled) 
[11:02:39.565]                           invokeRestart("muffleWarning")
[11:02:39.565]                       }
[11:02:39.565]                       else if (inherits(cond, "condition")) {
[11:02:39.565]                         if (!is.null(pattern)) {
[11:02:39.565]                           computeRestarts <- base::computeRestarts
[11:02:39.565]                           grepl <- base::grepl
[11:02:39.565]                           restarts <- computeRestarts(cond)
[11:02:39.565]                           for (restart in restarts) {
[11:02:39.565]                             name <- restart$name
[11:02:39.565]                             if (is.null(name)) 
[11:02:39.565]                               next
[11:02:39.565]                             if (!grepl(pattern, name)) 
[11:02:39.565]                               next
[11:02:39.565]                             invokeRestart(restart)
[11:02:39.565]                             muffled <- TRUE
[11:02:39.565]                             break
[11:02:39.565]                           }
[11:02:39.565]                         }
[11:02:39.565]                       }
[11:02:39.565]                       invisible(muffled)
[11:02:39.565]                     }
[11:02:39.565]                     muffleCondition(cond, pattern = "^muffle")
[11:02:39.565]                   }
[11:02:39.565]                 }
[11:02:39.565]             }
[11:02:39.565]         }))
[11:02:39.565]     }, error = function(ex) {
[11:02:39.565]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:39.565]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:39.565]                 ...future.rng), started = ...future.startTime, 
[11:02:39.565]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:39.565]             version = "1.8"), class = "FutureResult")
[11:02:39.565]     }, finally = {
[11:02:39.565]         if (!identical(...future.workdir, getwd())) 
[11:02:39.565]             setwd(...future.workdir)
[11:02:39.565]         {
[11:02:39.565]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:39.565]                 ...future.oldOptions$nwarnings <- NULL
[11:02:39.565]             }
[11:02:39.565]             base::options(...future.oldOptions)
[11:02:39.565]             if (.Platform$OS.type == "windows") {
[11:02:39.565]                 old_names <- names(...future.oldEnvVars)
[11:02:39.565]                 envs <- base::Sys.getenv()
[11:02:39.565]                 names <- names(envs)
[11:02:39.565]                 common <- intersect(names, old_names)
[11:02:39.565]                 added <- setdiff(names, old_names)
[11:02:39.565]                 removed <- setdiff(old_names, names)
[11:02:39.565]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:39.565]                   envs[common]]
[11:02:39.565]                 NAMES <- toupper(changed)
[11:02:39.565]                 args <- list()
[11:02:39.565]                 for (kk in seq_along(NAMES)) {
[11:02:39.565]                   name <- changed[[kk]]
[11:02:39.565]                   NAME <- NAMES[[kk]]
[11:02:39.565]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.565]                     next
[11:02:39.565]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:39.565]                 }
[11:02:39.565]                 NAMES <- toupper(added)
[11:02:39.565]                 for (kk in seq_along(NAMES)) {
[11:02:39.565]                   name <- added[[kk]]
[11:02:39.565]                   NAME <- NAMES[[kk]]
[11:02:39.565]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.565]                     next
[11:02:39.565]                   args[[name]] <- ""
[11:02:39.565]                 }
[11:02:39.565]                 NAMES <- toupper(removed)
[11:02:39.565]                 for (kk in seq_along(NAMES)) {
[11:02:39.565]                   name <- removed[[kk]]
[11:02:39.565]                   NAME <- NAMES[[kk]]
[11:02:39.565]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.565]                     next
[11:02:39.565]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:39.565]                 }
[11:02:39.565]                 if (length(args) > 0) 
[11:02:39.565]                   base::do.call(base::Sys.setenv, args = args)
[11:02:39.565]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:39.565]             }
[11:02:39.565]             else {
[11:02:39.565]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:39.565]             }
[11:02:39.565]             {
[11:02:39.565]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:39.565]                   0L) {
[11:02:39.565]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:39.565]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:39.565]                   base::options(opts)
[11:02:39.565]                 }
[11:02:39.565]                 {
[11:02:39.565]                   {
[11:02:39.565]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:39.565]                     NULL
[11:02:39.565]                   }
[11:02:39.565]                   options(future.plan = NULL)
[11:02:39.565]                   if (is.na(NA_character_)) 
[11:02:39.565]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:39.565]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:39.565]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:39.565]                     .init = FALSE)
[11:02:39.565]                 }
[11:02:39.565]             }
[11:02:39.565]         }
[11:02:39.565]     })
[11:02:39.565]     if (TRUE) {
[11:02:39.565]         base::sink(type = "output", split = FALSE)
[11:02:39.565]         if (TRUE) {
[11:02:39.565]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:39.565]         }
[11:02:39.565]         else {
[11:02:39.565]             ...future.result["stdout"] <- base::list(NULL)
[11:02:39.565]         }
[11:02:39.565]         base::close(...future.stdout)
[11:02:39.565]         ...future.stdout <- NULL
[11:02:39.565]     }
[11:02:39.565]     ...future.result$conditions <- ...future.conditions
[11:02:39.565]     ...future.result$finished <- base::Sys.time()
[11:02:39.565]     ...future.result
[11:02:39.565] }
[11:02:39.569] requestCore(): workers = 2
[11:02:39.569] Poll #1 (0): usedCores() = 2, workers = 2
[11:02:39.580] result() for MulticoreFuture ...
[11:02:39.581] result() for MulticoreFuture ...
[11:02:39.581] result() for MulticoreFuture ... done
[11:02:39.581] result() for MulticoreFuture ... done
[11:02:39.581] result() for MulticoreFuture ...
[11:02:39.581] result() for MulticoreFuture ... done
[11:02:39.583] MulticoreFuture started
[11:02:39.584] - Launch lazy future ... done
[11:02:39.584] run() for ‘MulticoreFuture’ ... done
[11:02:39.585] plan(): Setting new future strategy stack:
[11:02:39.585] List of future strategies:
[11:02:39.585] 1. sequential:
[11:02:39.585]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:39.585]    - tweaked: FALSE
[11:02:39.585]    - call: NULL
[11:02:39.586] resolve() on environment ...
[11:02:39.586]  recursive: 0
[11:02:39.586] plan(): nbrOfWorkers() = 1
[11:02:39.587]  elements: [3] ‘a’, ‘b’, ‘c’
[11:02:39.588] Future #1
[11:02:39.588]  length: 2 (resolved future 1)
[11:02:39.589] plan(): Setting new future strategy stack:
[11:02:39.589] List of future strategies:
[11:02:39.589] 1. multicore:
[11:02:39.589]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:39.589]    - tweaked: FALSE
[11:02:39.589]    - call: plan(strategy)
[11:02:39.592] plan(): nbrOfWorkers() = 2
[11:02:39.593] Future #2
[11:02:39.593]  length: 1 (resolved future 2)
[11:02:39.593]  length: 0 (resolved future 3)
[11:02:39.593] resolve() on environment ... DONE
[11:02:39.594] getGlobalsAndPackages() ...
[11:02:39.595] Searching for globals...
[11:02:39.596] - globals found: [1] ‘{’
[11:02:39.596] Searching for globals ... DONE
[11:02:39.596] Resolving globals: FALSE
[11:02:39.597] 
[11:02:39.597] 
[11:02:39.597] getGlobalsAndPackages() ... DONE
[11:02:39.597] run() for ‘Future’ ...
[11:02:39.598] - state: ‘created’
[11:02:39.598] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:02:39.600] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:39.600] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:02:39.601]   - Field: ‘label’
[11:02:39.601]   - Field: ‘local’
[11:02:39.601]   - Field: ‘owner’
[11:02:39.601]   - Field: ‘envir’
[11:02:39.601]   - Field: ‘workers’
[11:02:39.601]   - Field: ‘packages’
[11:02:39.601]   - Field: ‘gc’
[11:02:39.602]   - Field: ‘job’
[11:02:39.602]   - Field: ‘conditions’
[11:02:39.602]   - Field: ‘expr’
[11:02:39.602]   - Field: ‘uuid’
[11:02:39.602]   - Field: ‘seed’
[11:02:39.602]   - Field: ‘version’
[11:02:39.602]   - Field: ‘result’
[11:02:39.602]   - Field: ‘asynchronous’
[11:02:39.603]   - Field: ‘calls’
[11:02:39.603]   - Field: ‘globals’
[11:02:39.603]   - Field: ‘stdout’
[11:02:39.603]   - Field: ‘earlySignal’
[11:02:39.603]   - Field: ‘lazy’
[11:02:39.603]   - Field: ‘state’
[11:02:39.603] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:02:39.604] - Launch lazy future ...
[11:02:39.604] Packages needed by the future expression (n = 0): <none>
[11:02:39.604] Packages needed by future strategies (n = 0): <none>
[11:02:39.608] {
[11:02:39.608]     {
[11:02:39.608]         {
[11:02:39.608]             ...future.startTime <- base::Sys.time()
[11:02:39.608]             {
[11:02:39.608]                 {
[11:02:39.608]                   {
[11:02:39.608]                     {
[11:02:39.608]                       base::local({
[11:02:39.608]                         has_future <- base::requireNamespace("future", 
[11:02:39.608]                           quietly = TRUE)
[11:02:39.608]                         if (has_future) {
[11:02:39.608]                           ns <- base::getNamespace("future")
[11:02:39.608]                           version <- ns[[".package"]][["version"]]
[11:02:39.608]                           if (is.null(version)) 
[11:02:39.608]                             version <- utils::packageVersion("future")
[11:02:39.608]                         }
[11:02:39.608]                         else {
[11:02:39.608]                           version <- NULL
[11:02:39.608]                         }
[11:02:39.608]                         if (!has_future || version < "1.8.0") {
[11:02:39.608]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:39.608]                             "", base::R.version$version.string), 
[11:02:39.608]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:39.608]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:39.608]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:39.608]                               "release", "version")], collapse = " "), 
[11:02:39.608]                             hostname = base::Sys.info()[["nodename"]])
[11:02:39.608]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:39.608]                             info)
[11:02:39.608]                           info <- base::paste(info, collapse = "; ")
[11:02:39.608]                           if (!has_future) {
[11:02:39.608]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:39.608]                               info)
[11:02:39.608]                           }
[11:02:39.608]                           else {
[11:02:39.608]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:39.608]                               info, version)
[11:02:39.608]                           }
[11:02:39.608]                           base::stop(msg)
[11:02:39.608]                         }
[11:02:39.608]                       })
[11:02:39.608]                     }
[11:02:39.608]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:39.608]                     base::options(mc.cores = 1L)
[11:02:39.608]                   }
[11:02:39.608]                   ...future.strategy.old <- future::plan("list")
[11:02:39.608]                   options(future.plan = NULL)
[11:02:39.608]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:39.608]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:39.608]                 }
[11:02:39.608]                 ...future.workdir <- getwd()
[11:02:39.608]             }
[11:02:39.608]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:39.608]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:39.608]         }
[11:02:39.608]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:39.608]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:39.608]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:39.608]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:39.608]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:39.608]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:39.608]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:39.608]             base::names(...future.oldOptions))
[11:02:39.608]     }
[11:02:39.608]     if (FALSE) {
[11:02:39.608]     }
[11:02:39.608]     else {
[11:02:39.608]         if (TRUE) {
[11:02:39.608]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:39.608]                 open = "w")
[11:02:39.608]         }
[11:02:39.608]         else {
[11:02:39.608]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:39.608]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:39.608]         }
[11:02:39.608]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:39.608]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:39.608]             base::sink(type = "output", split = FALSE)
[11:02:39.608]             base::close(...future.stdout)
[11:02:39.608]         }, add = TRUE)
[11:02:39.608]     }
[11:02:39.608]     ...future.frame <- base::sys.nframe()
[11:02:39.608]     ...future.conditions <- base::list()
[11:02:39.608]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:39.608]     if (FALSE) {
[11:02:39.608]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:39.608]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:39.608]     }
[11:02:39.608]     ...future.result <- base::tryCatch({
[11:02:39.608]         base::withCallingHandlers({
[11:02:39.608]             ...future.value <- base::withVisible(base::local({
[11:02:39.608]                 withCallingHandlers({
[11:02:39.608]                   {
[11:02:39.608]                     1
[11:02:39.608]                   }
[11:02:39.608]                 }, immediateCondition = function(cond) {
[11:02:39.608]                   save_rds <- function (object, pathname, ...) 
[11:02:39.608]                   {
[11:02:39.608]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:02:39.608]                     if (file_test("-f", pathname_tmp)) {
[11:02:39.608]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.608]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:02:39.608]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.608]                         fi_tmp[["mtime"]])
[11:02:39.608]                     }
[11:02:39.608]                     tryCatch({
[11:02:39.608]                       saveRDS(object, file = pathname_tmp, ...)
[11:02:39.608]                     }, error = function(ex) {
[11:02:39.608]                       msg <- conditionMessage(ex)
[11:02:39.608]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.608]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:02:39.608]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.608]                         fi_tmp[["mtime"]], msg)
[11:02:39.608]                       ex$message <- msg
[11:02:39.608]                       stop(ex)
[11:02:39.608]                     })
[11:02:39.608]                     stopifnot(file_test("-f", pathname_tmp))
[11:02:39.608]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:02:39.608]                     if (!res || file_test("-f", pathname_tmp)) {
[11:02:39.608]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.608]                       fi <- file.info(pathname)
[11:02:39.608]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:02:39.608]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.608]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:02:39.608]                         fi[["size"]], fi[["mtime"]])
[11:02:39.608]                       stop(msg)
[11:02:39.608]                     }
[11:02:39.608]                     invisible(pathname)
[11:02:39.608]                   }
[11:02:39.608]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:02:39.608]                     rootPath = tempdir()) 
[11:02:39.608]                   {
[11:02:39.608]                     obj <- list(time = Sys.time(), condition = cond)
[11:02:39.608]                     file <- tempfile(pattern = class(cond)[1], 
[11:02:39.608]                       tmpdir = path, fileext = ".rds")
[11:02:39.608]                     save_rds(obj, file)
[11:02:39.608]                   }
[11:02:39.608]                   saveImmediateCondition(cond, path = "/tmp/RtmpPVwpFC/.future/immediateConditions")
[11:02:39.608]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.608]                   {
[11:02:39.608]                     inherits <- base::inherits
[11:02:39.608]                     invokeRestart <- base::invokeRestart
[11:02:39.608]                     is.null <- base::is.null
[11:02:39.608]                     muffled <- FALSE
[11:02:39.608]                     if (inherits(cond, "message")) {
[11:02:39.608]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:39.608]                       if (muffled) 
[11:02:39.608]                         invokeRestart("muffleMessage")
[11:02:39.608]                     }
[11:02:39.608]                     else if (inherits(cond, "warning")) {
[11:02:39.608]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:39.608]                       if (muffled) 
[11:02:39.608]                         invokeRestart("muffleWarning")
[11:02:39.608]                     }
[11:02:39.608]                     else if (inherits(cond, "condition")) {
[11:02:39.608]                       if (!is.null(pattern)) {
[11:02:39.608]                         computeRestarts <- base::computeRestarts
[11:02:39.608]                         grepl <- base::grepl
[11:02:39.608]                         restarts <- computeRestarts(cond)
[11:02:39.608]                         for (restart in restarts) {
[11:02:39.608]                           name <- restart$name
[11:02:39.608]                           if (is.null(name)) 
[11:02:39.608]                             next
[11:02:39.608]                           if (!grepl(pattern, name)) 
[11:02:39.608]                             next
[11:02:39.608]                           invokeRestart(restart)
[11:02:39.608]                           muffled <- TRUE
[11:02:39.608]                           break
[11:02:39.608]                         }
[11:02:39.608]                       }
[11:02:39.608]                     }
[11:02:39.608]                     invisible(muffled)
[11:02:39.608]                   }
[11:02:39.608]                   muffleCondition(cond)
[11:02:39.608]                 })
[11:02:39.608]             }))
[11:02:39.608]             future::FutureResult(value = ...future.value$value, 
[11:02:39.608]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:39.608]                   ...future.rng), globalenv = if (FALSE) 
[11:02:39.608]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:39.608]                     ...future.globalenv.names))
[11:02:39.608]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:39.608]         }, condition = base::local({
[11:02:39.608]             c <- base::c
[11:02:39.608]             inherits <- base::inherits
[11:02:39.608]             invokeRestart <- base::invokeRestart
[11:02:39.608]             length <- base::length
[11:02:39.608]             list <- base::list
[11:02:39.608]             seq.int <- base::seq.int
[11:02:39.608]             signalCondition <- base::signalCondition
[11:02:39.608]             sys.calls <- base::sys.calls
[11:02:39.608]             `[[` <- base::`[[`
[11:02:39.608]             `+` <- base::`+`
[11:02:39.608]             `<<-` <- base::`<<-`
[11:02:39.608]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:39.608]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:39.608]                   3L)]
[11:02:39.608]             }
[11:02:39.608]             function(cond) {
[11:02:39.608]                 is_error <- inherits(cond, "error")
[11:02:39.608]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:39.608]                   NULL)
[11:02:39.608]                 if (is_error) {
[11:02:39.608]                   sessionInformation <- function() {
[11:02:39.608]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:39.608]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:39.608]                       search = base::search(), system = base::Sys.info())
[11:02:39.608]                   }
[11:02:39.608]                   ...future.conditions[[length(...future.conditions) + 
[11:02:39.608]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:39.608]                     cond$call), session = sessionInformation(), 
[11:02:39.608]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:39.608]                   signalCondition(cond)
[11:02:39.608]                 }
[11:02:39.608]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:39.608]                 "immediateCondition"))) {
[11:02:39.608]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:39.608]                   ...future.conditions[[length(...future.conditions) + 
[11:02:39.608]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:39.608]                   if (TRUE && !signal) {
[11:02:39.608]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.608]                     {
[11:02:39.608]                       inherits <- base::inherits
[11:02:39.608]                       invokeRestart <- base::invokeRestart
[11:02:39.608]                       is.null <- base::is.null
[11:02:39.608]                       muffled <- FALSE
[11:02:39.608]                       if (inherits(cond, "message")) {
[11:02:39.608]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:39.608]                         if (muffled) 
[11:02:39.608]                           invokeRestart("muffleMessage")
[11:02:39.608]                       }
[11:02:39.608]                       else if (inherits(cond, "warning")) {
[11:02:39.608]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:39.608]                         if (muffled) 
[11:02:39.608]                           invokeRestart("muffleWarning")
[11:02:39.608]                       }
[11:02:39.608]                       else if (inherits(cond, "condition")) {
[11:02:39.608]                         if (!is.null(pattern)) {
[11:02:39.608]                           computeRestarts <- base::computeRestarts
[11:02:39.608]                           grepl <- base::grepl
[11:02:39.608]                           restarts <- computeRestarts(cond)
[11:02:39.608]                           for (restart in restarts) {
[11:02:39.608]                             name <- restart$name
[11:02:39.608]                             if (is.null(name)) 
[11:02:39.608]                               next
[11:02:39.608]                             if (!grepl(pattern, name)) 
[11:02:39.608]                               next
[11:02:39.608]                             invokeRestart(restart)
[11:02:39.608]                             muffled <- TRUE
[11:02:39.608]                             break
[11:02:39.608]                           }
[11:02:39.608]                         }
[11:02:39.608]                       }
[11:02:39.608]                       invisible(muffled)
[11:02:39.608]                     }
[11:02:39.608]                     muffleCondition(cond, pattern = "^muffle")
[11:02:39.608]                   }
[11:02:39.608]                 }
[11:02:39.608]                 else {
[11:02:39.608]                   if (TRUE) {
[11:02:39.608]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.608]                     {
[11:02:39.608]                       inherits <- base::inherits
[11:02:39.608]                       invokeRestart <- base::invokeRestart
[11:02:39.608]                       is.null <- base::is.null
[11:02:39.608]                       muffled <- FALSE
[11:02:39.608]                       if (inherits(cond, "message")) {
[11:02:39.608]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:39.608]                         if (muffled) 
[11:02:39.608]                           invokeRestart("muffleMessage")
[11:02:39.608]                       }
[11:02:39.608]                       else if (inherits(cond, "warning")) {
[11:02:39.608]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:39.608]                         if (muffled) 
[11:02:39.608]                           invokeRestart("muffleWarning")
[11:02:39.608]                       }
[11:02:39.608]                       else if (inherits(cond, "condition")) {
[11:02:39.608]                         if (!is.null(pattern)) {
[11:02:39.608]                           computeRestarts <- base::computeRestarts
[11:02:39.608]                           grepl <- base::grepl
[11:02:39.608]                           restarts <- computeRestarts(cond)
[11:02:39.608]                           for (restart in restarts) {
[11:02:39.608]                             name <- restart$name
[11:02:39.608]                             if (is.null(name)) 
[11:02:39.608]                               next
[11:02:39.608]                             if (!grepl(pattern, name)) 
[11:02:39.608]                               next
[11:02:39.608]                             invokeRestart(restart)
[11:02:39.608]                             muffled <- TRUE
[11:02:39.608]                             break
[11:02:39.608]                           }
[11:02:39.608]                         }
[11:02:39.608]                       }
[11:02:39.608]                       invisible(muffled)
[11:02:39.608]                     }
[11:02:39.608]                     muffleCondition(cond, pattern = "^muffle")
[11:02:39.608]                   }
[11:02:39.608]                 }
[11:02:39.608]             }
[11:02:39.608]         }))
[11:02:39.608]     }, error = function(ex) {
[11:02:39.608]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:39.608]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:39.608]                 ...future.rng), started = ...future.startTime, 
[11:02:39.608]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:39.608]             version = "1.8"), class = "FutureResult")
[11:02:39.608]     }, finally = {
[11:02:39.608]         if (!identical(...future.workdir, getwd())) 
[11:02:39.608]             setwd(...future.workdir)
[11:02:39.608]         {
[11:02:39.608]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:39.608]                 ...future.oldOptions$nwarnings <- NULL
[11:02:39.608]             }
[11:02:39.608]             base::options(...future.oldOptions)
[11:02:39.608]             if (.Platform$OS.type == "windows") {
[11:02:39.608]                 old_names <- names(...future.oldEnvVars)
[11:02:39.608]                 envs <- base::Sys.getenv()
[11:02:39.608]                 names <- names(envs)
[11:02:39.608]                 common <- intersect(names, old_names)
[11:02:39.608]                 added <- setdiff(names, old_names)
[11:02:39.608]                 removed <- setdiff(old_names, names)
[11:02:39.608]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:39.608]                   envs[common]]
[11:02:39.608]                 NAMES <- toupper(changed)
[11:02:39.608]                 args <- list()
[11:02:39.608]                 for (kk in seq_along(NAMES)) {
[11:02:39.608]                   name <- changed[[kk]]
[11:02:39.608]                   NAME <- NAMES[[kk]]
[11:02:39.608]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.608]                     next
[11:02:39.608]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:39.608]                 }
[11:02:39.608]                 NAMES <- toupper(added)
[11:02:39.608]                 for (kk in seq_along(NAMES)) {
[11:02:39.608]                   name <- added[[kk]]
[11:02:39.608]                   NAME <- NAMES[[kk]]
[11:02:39.608]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.608]                     next
[11:02:39.608]                   args[[name]] <- ""
[11:02:39.608]                 }
[11:02:39.608]                 NAMES <- toupper(removed)
[11:02:39.608]                 for (kk in seq_along(NAMES)) {
[11:02:39.608]                   name <- removed[[kk]]
[11:02:39.608]                   NAME <- NAMES[[kk]]
[11:02:39.608]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.608]                     next
[11:02:39.608]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:39.608]                 }
[11:02:39.608]                 if (length(args) > 0) 
[11:02:39.608]                   base::do.call(base::Sys.setenv, args = args)
[11:02:39.608]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:39.608]             }
[11:02:39.608]             else {
[11:02:39.608]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:39.608]             }
[11:02:39.608]             {
[11:02:39.608]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:39.608]                   0L) {
[11:02:39.608]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:39.608]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:39.608]                   base::options(opts)
[11:02:39.608]                 }
[11:02:39.608]                 {
[11:02:39.608]                   {
[11:02:39.608]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:39.608]                     NULL
[11:02:39.608]                   }
[11:02:39.608]                   options(future.plan = NULL)
[11:02:39.608]                   if (is.na(NA_character_)) 
[11:02:39.608]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:39.608]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:39.608]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:39.608]                     .init = FALSE)
[11:02:39.608]                 }
[11:02:39.608]             }
[11:02:39.608]         }
[11:02:39.608]     })
[11:02:39.608]     if (TRUE) {
[11:02:39.608]         base::sink(type = "output", split = FALSE)
[11:02:39.608]         if (TRUE) {
[11:02:39.608]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:39.608]         }
[11:02:39.608]         else {
[11:02:39.608]             ...future.result["stdout"] <- base::list(NULL)
[11:02:39.608]         }
[11:02:39.608]         base::close(...future.stdout)
[11:02:39.608]         ...future.stdout <- NULL
[11:02:39.608]     }
[11:02:39.608]     ...future.result$conditions <- ...future.conditions
[11:02:39.608]     ...future.result$finished <- base::Sys.time()
[11:02:39.608]     ...future.result
[11:02:39.608] }
[11:02:39.611] requestCore(): workers = 2
[11:02:39.612] Poll #1 (0): usedCores() = 2, workers = 2
[11:02:39.623] result() for MulticoreFuture ...
[11:02:39.624] result() for MulticoreFuture ...
[11:02:39.624] result() for MulticoreFuture ... done
[11:02:39.624] result() for MulticoreFuture ... done
[11:02:39.624] result() for MulticoreFuture ...
[11:02:39.625] result() for MulticoreFuture ... done
[11:02:39.627] MulticoreFuture started
[11:02:39.627] - Launch lazy future ... done
[11:02:39.628] run() for ‘MulticoreFuture’ ... done
[11:02:39.628] plan(): Setting new future strategy stack:
[11:02:39.630] getGlobalsAndPackages() ...
[11:02:39.629] List of future strategies:
[11:02:39.629] 1. sequential:
[11:02:39.629]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:39.629]    - tweaked: FALSE
[11:02:39.629]    - call: NULL
[11:02:39.630] Searching for globals...
[11:02:39.630] plan(): nbrOfWorkers() = 1
[11:02:39.632] - globals found: [1] ‘{’
[11:02:39.633] Searching for globals ... DONE
[11:02:39.633] Resolving globals: FALSE
[11:02:39.634] plan(): Setting new future strategy stack:
[11:02:39.634] 
[11:02:39.634] 
[11:02:39.634] getGlobalsAndPackages() ... DONE
[11:02:39.634] List of future strategies:
[11:02:39.634] 1. multicore:
[11:02:39.634]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:39.634]    - tweaked: FALSE
[11:02:39.634]    - call: plan(strategy)
[11:02:39.635] run() for ‘Future’ ...
[11:02:39.635] - state: ‘created’
[11:02:39.636] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:02:39.638] plan(): nbrOfWorkers() = 2
[11:02:39.639] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:39.640] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:02:39.640]   - Field: ‘label’
[11:02:39.640]   - Field: ‘local’
[11:02:39.640]   - Field: ‘owner’
[11:02:39.640]   - Field: ‘envir’
[11:02:39.640]   - Field: ‘workers’
[11:02:39.641]   - Field: ‘packages’
[11:02:39.641]   - Field: ‘gc’
[11:02:39.641]   - Field: ‘job’
[11:02:39.641]   - Field: ‘conditions’
[11:02:39.641]   - Field: ‘expr’
[11:02:39.642]   - Field: ‘uuid’
[11:02:39.642]   - Field: ‘seed’
[11:02:39.642]   - Field: ‘version’
[11:02:39.642]   - Field: ‘result’
[11:02:39.642]   - Field: ‘asynchronous’
[11:02:39.642]   - Field: ‘calls’
[11:02:39.642]   - Field: ‘globals’
[11:02:39.643]   - Field: ‘stdout’
[11:02:39.643]   - Field: ‘earlySignal’
[11:02:39.643]   - Field: ‘lazy’
[11:02:39.643]   - Field: ‘state’
[11:02:39.643] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:02:39.643] - Launch lazy future ...
[11:02:39.644] Packages needed by the future expression (n = 0): <none>
[11:02:39.644] Packages needed by future strategies (n = 0): <none>
[11:02:39.645] {
[11:02:39.645]     {
[11:02:39.645]         {
[11:02:39.645]             ...future.startTime <- base::Sys.time()
[11:02:39.645]             {
[11:02:39.645]                 {
[11:02:39.645]                   {
[11:02:39.645]                     {
[11:02:39.645]                       base::local({
[11:02:39.645]                         has_future <- base::requireNamespace("future", 
[11:02:39.645]                           quietly = TRUE)
[11:02:39.645]                         if (has_future) {
[11:02:39.645]                           ns <- base::getNamespace("future")
[11:02:39.645]                           version <- ns[[".package"]][["version"]]
[11:02:39.645]                           if (is.null(version)) 
[11:02:39.645]                             version <- utils::packageVersion("future")
[11:02:39.645]                         }
[11:02:39.645]                         else {
[11:02:39.645]                           version <- NULL
[11:02:39.645]                         }
[11:02:39.645]                         if (!has_future || version < "1.8.0") {
[11:02:39.645]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:39.645]                             "", base::R.version$version.string), 
[11:02:39.645]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:39.645]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:39.645]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:39.645]                               "release", "version")], collapse = " "), 
[11:02:39.645]                             hostname = base::Sys.info()[["nodename"]])
[11:02:39.645]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:39.645]                             info)
[11:02:39.645]                           info <- base::paste(info, collapse = "; ")
[11:02:39.645]                           if (!has_future) {
[11:02:39.645]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:39.645]                               info)
[11:02:39.645]                           }
[11:02:39.645]                           else {
[11:02:39.645]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:39.645]                               info, version)
[11:02:39.645]                           }
[11:02:39.645]                           base::stop(msg)
[11:02:39.645]                         }
[11:02:39.645]                       })
[11:02:39.645]                     }
[11:02:39.645]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:39.645]                     base::options(mc.cores = 1L)
[11:02:39.645]                   }
[11:02:39.645]                   ...future.strategy.old <- future::plan("list")
[11:02:39.645]                   options(future.plan = NULL)
[11:02:39.645]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:39.645]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:39.645]                 }
[11:02:39.645]                 ...future.workdir <- getwd()
[11:02:39.645]             }
[11:02:39.645]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:39.645]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:39.645]         }
[11:02:39.645]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:39.645]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:39.645]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:39.645]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:39.645]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:39.645]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:39.645]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:39.645]             base::names(...future.oldOptions))
[11:02:39.645]     }
[11:02:39.645]     if (FALSE) {
[11:02:39.645]     }
[11:02:39.645]     else {
[11:02:39.645]         if (TRUE) {
[11:02:39.645]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:39.645]                 open = "w")
[11:02:39.645]         }
[11:02:39.645]         else {
[11:02:39.645]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:39.645]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:39.645]         }
[11:02:39.645]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:39.645]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:39.645]             base::sink(type = "output", split = FALSE)
[11:02:39.645]             base::close(...future.stdout)
[11:02:39.645]         }, add = TRUE)
[11:02:39.645]     }
[11:02:39.645]     ...future.frame <- base::sys.nframe()
[11:02:39.645]     ...future.conditions <- base::list()
[11:02:39.645]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:39.645]     if (FALSE) {
[11:02:39.645]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:39.645]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:39.645]     }
[11:02:39.645]     ...future.result <- base::tryCatch({
[11:02:39.645]         base::withCallingHandlers({
[11:02:39.645]             ...future.value <- base::withVisible(base::local({
[11:02:39.645]                 withCallingHandlers({
[11:02:39.645]                   {
[11:02:39.645]                     2
[11:02:39.645]                   }
[11:02:39.645]                 }, immediateCondition = function(cond) {
[11:02:39.645]                   save_rds <- function (object, pathname, ...) 
[11:02:39.645]                   {
[11:02:39.645]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:02:39.645]                     if (file_test("-f", pathname_tmp)) {
[11:02:39.645]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.645]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:02:39.645]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.645]                         fi_tmp[["mtime"]])
[11:02:39.645]                     }
[11:02:39.645]                     tryCatch({
[11:02:39.645]                       saveRDS(object, file = pathname_tmp, ...)
[11:02:39.645]                     }, error = function(ex) {
[11:02:39.645]                       msg <- conditionMessage(ex)
[11:02:39.645]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.645]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:02:39.645]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.645]                         fi_tmp[["mtime"]], msg)
[11:02:39.645]                       ex$message <- msg
[11:02:39.645]                       stop(ex)
[11:02:39.645]                     })
[11:02:39.645]                     stopifnot(file_test("-f", pathname_tmp))
[11:02:39.645]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:02:39.645]                     if (!res || file_test("-f", pathname_tmp)) {
[11:02:39.645]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.645]                       fi <- file.info(pathname)
[11:02:39.645]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:02:39.645]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.645]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:02:39.645]                         fi[["size"]], fi[["mtime"]])
[11:02:39.645]                       stop(msg)
[11:02:39.645]                     }
[11:02:39.645]                     invisible(pathname)
[11:02:39.645]                   }
[11:02:39.645]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:02:39.645]                     rootPath = tempdir()) 
[11:02:39.645]                   {
[11:02:39.645]                     obj <- list(time = Sys.time(), condition = cond)
[11:02:39.645]                     file <- tempfile(pattern = class(cond)[1], 
[11:02:39.645]                       tmpdir = path, fileext = ".rds")
[11:02:39.645]                     save_rds(obj, file)
[11:02:39.645]                   }
[11:02:39.645]                   saveImmediateCondition(cond, path = "/tmp/RtmpPVwpFC/.future/immediateConditions")
[11:02:39.645]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.645]                   {
[11:02:39.645]                     inherits <- base::inherits
[11:02:39.645]                     invokeRestart <- base::invokeRestart
[11:02:39.645]                     is.null <- base::is.null
[11:02:39.645]                     muffled <- FALSE
[11:02:39.645]                     if (inherits(cond, "message")) {
[11:02:39.645]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:39.645]                       if (muffled) 
[11:02:39.645]                         invokeRestart("muffleMessage")
[11:02:39.645]                     }
[11:02:39.645]                     else if (inherits(cond, "warning")) {
[11:02:39.645]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:39.645]                       if (muffled) 
[11:02:39.645]                         invokeRestart("muffleWarning")
[11:02:39.645]                     }
[11:02:39.645]                     else if (inherits(cond, "condition")) {
[11:02:39.645]                       if (!is.null(pattern)) {
[11:02:39.645]                         computeRestarts <- base::computeRestarts
[11:02:39.645]                         grepl <- base::grepl
[11:02:39.645]                         restarts <- computeRestarts(cond)
[11:02:39.645]                         for (restart in restarts) {
[11:02:39.645]                           name <- restart$name
[11:02:39.645]                           if (is.null(name)) 
[11:02:39.645]                             next
[11:02:39.645]                           if (!grepl(pattern, name)) 
[11:02:39.645]                             next
[11:02:39.645]                           invokeRestart(restart)
[11:02:39.645]                           muffled <- TRUE
[11:02:39.645]                           break
[11:02:39.645]                         }
[11:02:39.645]                       }
[11:02:39.645]                     }
[11:02:39.645]                     invisible(muffled)
[11:02:39.645]                   }
[11:02:39.645]                   muffleCondition(cond)
[11:02:39.645]                 })
[11:02:39.645]             }))
[11:02:39.645]             future::FutureResult(value = ...future.value$value, 
[11:02:39.645]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:39.645]                   ...future.rng), globalenv = if (FALSE) 
[11:02:39.645]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:39.645]                     ...future.globalenv.names))
[11:02:39.645]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:39.645]         }, condition = base::local({
[11:02:39.645]             c <- base::c
[11:02:39.645]             inherits <- base::inherits
[11:02:39.645]             invokeRestart <- base::invokeRestart
[11:02:39.645]             length <- base::length
[11:02:39.645]             list <- base::list
[11:02:39.645]             seq.int <- base::seq.int
[11:02:39.645]             signalCondition <- base::signalCondition
[11:02:39.645]             sys.calls <- base::sys.calls
[11:02:39.645]             `[[` <- base::`[[`
[11:02:39.645]             `+` <- base::`+`
[11:02:39.645]             `<<-` <- base::`<<-`
[11:02:39.645]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:39.645]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:39.645]                   3L)]
[11:02:39.645]             }
[11:02:39.645]             function(cond) {
[11:02:39.645]                 is_error <- inherits(cond, "error")
[11:02:39.645]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:39.645]                   NULL)
[11:02:39.645]                 if (is_error) {
[11:02:39.645]                   sessionInformation <- function() {
[11:02:39.645]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:39.645]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:39.645]                       search = base::search(), system = base::Sys.info())
[11:02:39.645]                   }
[11:02:39.645]                   ...future.conditions[[length(...future.conditions) + 
[11:02:39.645]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:39.645]                     cond$call), session = sessionInformation(), 
[11:02:39.645]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:39.645]                   signalCondition(cond)
[11:02:39.645]                 }
[11:02:39.645]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:39.645]                 "immediateCondition"))) {
[11:02:39.645]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:39.645]                   ...future.conditions[[length(...future.conditions) + 
[11:02:39.645]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:39.645]                   if (TRUE && !signal) {
[11:02:39.645]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.645]                     {
[11:02:39.645]                       inherits <- base::inherits
[11:02:39.645]                       invokeRestart <- base::invokeRestart
[11:02:39.645]                       is.null <- base::is.null
[11:02:39.645]                       muffled <- FALSE
[11:02:39.645]                       if (inherits(cond, "message")) {
[11:02:39.645]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:39.645]                         if (muffled) 
[11:02:39.645]                           invokeRestart("muffleMessage")
[11:02:39.645]                       }
[11:02:39.645]                       else if (inherits(cond, "warning")) {
[11:02:39.645]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:39.645]                         if (muffled) 
[11:02:39.645]                           invokeRestart("muffleWarning")
[11:02:39.645]                       }
[11:02:39.645]                       else if (inherits(cond, "condition")) {
[11:02:39.645]                         if (!is.null(pattern)) {
[11:02:39.645]                           computeRestarts <- base::computeRestarts
[11:02:39.645]                           grepl <- base::grepl
[11:02:39.645]                           restarts <- computeRestarts(cond)
[11:02:39.645]                           for (restart in restarts) {
[11:02:39.645]                             name <- restart$name
[11:02:39.645]                             if (is.null(name)) 
[11:02:39.645]                               next
[11:02:39.645]                             if (!grepl(pattern, name)) 
[11:02:39.645]                               next
[11:02:39.645]                             invokeRestart(restart)
[11:02:39.645]                             muffled <- TRUE
[11:02:39.645]                             break
[11:02:39.645]                           }
[11:02:39.645]                         }
[11:02:39.645]                       }
[11:02:39.645]                       invisible(muffled)
[11:02:39.645]                     }
[11:02:39.645]                     muffleCondition(cond, pattern = "^muffle")
[11:02:39.645]                   }
[11:02:39.645]                 }
[11:02:39.645]                 else {
[11:02:39.645]                   if (TRUE) {
[11:02:39.645]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.645]                     {
[11:02:39.645]                       inherits <- base::inherits
[11:02:39.645]                       invokeRestart <- base::invokeRestart
[11:02:39.645]                       is.null <- base::is.null
[11:02:39.645]                       muffled <- FALSE
[11:02:39.645]                       if (inherits(cond, "message")) {
[11:02:39.645]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:39.645]                         if (muffled) 
[11:02:39.645]                           invokeRestart("muffleMessage")
[11:02:39.645]                       }
[11:02:39.645]                       else if (inherits(cond, "warning")) {
[11:02:39.645]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:39.645]                         if (muffled) 
[11:02:39.645]                           invokeRestart("muffleWarning")
[11:02:39.645]                       }
[11:02:39.645]                       else if (inherits(cond, "condition")) {
[11:02:39.645]                         if (!is.null(pattern)) {
[11:02:39.645]                           computeRestarts <- base::computeRestarts
[11:02:39.645]                           grepl <- base::grepl
[11:02:39.645]                           restarts <- computeRestarts(cond)
[11:02:39.645]                           for (restart in restarts) {
[11:02:39.645]                             name <- restart$name
[11:02:39.645]                             if (is.null(name)) 
[11:02:39.645]                               next
[11:02:39.645]                             if (!grepl(pattern, name)) 
[11:02:39.645]                               next
[11:02:39.645]                             invokeRestart(restart)
[11:02:39.645]                             muffled <- TRUE
[11:02:39.645]                             break
[11:02:39.645]                           }
[11:02:39.645]                         }
[11:02:39.645]                       }
[11:02:39.645]                       invisible(muffled)
[11:02:39.645]                     }
[11:02:39.645]                     muffleCondition(cond, pattern = "^muffle")
[11:02:39.645]                   }
[11:02:39.645]                 }
[11:02:39.645]             }
[11:02:39.645]         }))
[11:02:39.645]     }, error = function(ex) {
[11:02:39.645]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:39.645]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:39.645]                 ...future.rng), started = ...future.startTime, 
[11:02:39.645]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:39.645]             version = "1.8"), class = "FutureResult")
[11:02:39.645]     }, finally = {
[11:02:39.645]         if (!identical(...future.workdir, getwd())) 
[11:02:39.645]             setwd(...future.workdir)
[11:02:39.645]         {
[11:02:39.645]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:39.645]                 ...future.oldOptions$nwarnings <- NULL
[11:02:39.645]             }
[11:02:39.645]             base::options(...future.oldOptions)
[11:02:39.645]             if (.Platform$OS.type == "windows") {
[11:02:39.645]                 old_names <- names(...future.oldEnvVars)
[11:02:39.645]                 envs <- base::Sys.getenv()
[11:02:39.645]                 names <- names(envs)
[11:02:39.645]                 common <- intersect(names, old_names)
[11:02:39.645]                 added <- setdiff(names, old_names)
[11:02:39.645]                 removed <- setdiff(old_names, names)
[11:02:39.645]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:39.645]                   envs[common]]
[11:02:39.645]                 NAMES <- toupper(changed)
[11:02:39.645]                 args <- list()
[11:02:39.645]                 for (kk in seq_along(NAMES)) {
[11:02:39.645]                   name <- changed[[kk]]
[11:02:39.645]                   NAME <- NAMES[[kk]]
[11:02:39.645]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.645]                     next
[11:02:39.645]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:39.645]                 }
[11:02:39.645]                 NAMES <- toupper(added)
[11:02:39.645]                 for (kk in seq_along(NAMES)) {
[11:02:39.645]                   name <- added[[kk]]
[11:02:39.645]                   NAME <- NAMES[[kk]]
[11:02:39.645]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.645]                     next
[11:02:39.645]                   args[[name]] <- ""
[11:02:39.645]                 }
[11:02:39.645]                 NAMES <- toupper(removed)
[11:02:39.645]                 for (kk in seq_along(NAMES)) {
[11:02:39.645]                   name <- removed[[kk]]
[11:02:39.645]                   NAME <- NAMES[[kk]]
[11:02:39.645]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.645]                     next
[11:02:39.645]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:39.645]                 }
[11:02:39.645]                 if (length(args) > 0) 
[11:02:39.645]                   base::do.call(base::Sys.setenv, args = args)
[11:02:39.645]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:39.645]             }
[11:02:39.645]             else {
[11:02:39.645]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:39.645]             }
[11:02:39.645]             {
[11:02:39.645]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:39.645]                   0L) {
[11:02:39.645]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:39.645]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:39.645]                   base::options(opts)
[11:02:39.645]                 }
[11:02:39.645]                 {
[11:02:39.645]                   {
[11:02:39.645]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:39.645]                     NULL
[11:02:39.645]                   }
[11:02:39.645]                   options(future.plan = NULL)
[11:02:39.645]                   if (is.na(NA_character_)) 
[11:02:39.645]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:39.645]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:39.645]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:39.645]                     .init = FALSE)
[11:02:39.645]                 }
[11:02:39.645]             }
[11:02:39.645]         }
[11:02:39.645]     })
[11:02:39.645]     if (TRUE) {
[11:02:39.645]         base::sink(type = "output", split = FALSE)
[11:02:39.645]         if (TRUE) {
[11:02:39.645]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:39.645]         }
[11:02:39.645]         else {
[11:02:39.645]             ...future.result["stdout"] <- base::list(NULL)
[11:02:39.645]         }
[11:02:39.645]         base::close(...future.stdout)
[11:02:39.645]         ...future.stdout <- NULL
[11:02:39.645]     }
[11:02:39.645]     ...future.result$conditions <- ...future.conditions
[11:02:39.645]     ...future.result$finished <- base::Sys.time()
[11:02:39.645]     ...future.result
[11:02:39.645] }
[11:02:39.648] requestCore(): workers = 2
[11:02:39.648] Poll #1 (0): usedCores() = 2, workers = 2
[11:02:39.659] result() for MulticoreFuture ...
[11:02:39.660] result() for MulticoreFuture ...
[11:02:39.660] result() for MulticoreFuture ... done
[11:02:39.660] result() for MulticoreFuture ... done
[11:02:39.661] result() for MulticoreFuture ...
[11:02:39.661] result() for MulticoreFuture ... done
[11:02:39.663] MulticoreFuture started
[11:02:39.664] - Launch lazy future ... done
[11:02:39.664] run() for ‘MulticoreFuture’ ... done
[11:02:39.664] plan(): Setting new future strategy stack:
[11:02:39.665] List of future strategies:
[11:02:39.665] 1. sequential:
[11:02:39.665]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:39.665]    - tweaked: FALSE
[11:02:39.665]    - call: NULL
[11:02:39.666] resolve() on environment ...
[11:02:39.666]  recursive: 0
[11:02:39.666] plan(): nbrOfWorkers() = 1
[11:02:39.667]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[11:02:39.667] Future #1
[11:02:39.667]  length: 2 (resolved future 1)
[11:02:39.668] plan(): Setting new future strategy stack:
[11:02:39.668] List of future strategies:
[11:02:39.668] 1. multicore:
[11:02:39.668]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:39.668]    - tweaked: FALSE
[11:02:39.668]    - call: plan(strategy)
[11:02:39.671] plan(): nbrOfWorkers() = 2
[11:02:39.671] Future #2
[11:02:39.672]  length: 1 (resolved future 2)
[11:02:39.672]  length: 0 (resolved future 3)
[11:02:39.672] resolve() on environment ... DONE
[11:02:39.673] getGlobalsAndPackages() ...
[11:02:39.673] Searching for globals...
[11:02:39.674] - globals found: [1] ‘{’
[11:02:39.674] Searching for globals ... DONE
[11:02:39.674] Resolving globals: FALSE
[11:02:39.675] 
[11:02:39.675] 
[11:02:39.675] getGlobalsAndPackages() ... DONE
[11:02:39.675] run() for ‘Future’ ...
[11:02:39.676] - state: ‘created’
[11:02:39.676] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:02:39.678] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:39.679] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:02:39.679]   - Field: ‘label’
[11:02:39.679]   - Field: ‘local’
[11:02:39.679]   - Field: ‘owner’
[11:02:39.679]   - Field: ‘envir’
[11:02:39.679]   - Field: ‘workers’
[11:02:39.679]   - Field: ‘packages’
[11:02:39.680]   - Field: ‘gc’
[11:02:39.680]   - Field: ‘job’
[11:02:39.680]   - Field: ‘conditions’
[11:02:39.680]   - Field: ‘expr’
[11:02:39.680]   - Field: ‘uuid’
[11:02:39.680]   - Field: ‘seed’
[11:02:39.680]   - Field: ‘version’
[11:02:39.681]   - Field: ‘result’
[11:02:39.681]   - Field: ‘asynchronous’
[11:02:39.681]   - Field: ‘calls’
[11:02:39.681]   - Field: ‘globals’
[11:02:39.681]   - Field: ‘stdout’
[11:02:39.681]   - Field: ‘earlySignal’
[11:02:39.681]   - Field: ‘lazy’
[11:02:39.682]   - Field: ‘state’
[11:02:39.682] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:02:39.682] - Launch lazy future ...
[11:02:39.682] Packages needed by the future expression (n = 0): <none>
[11:02:39.683] Packages needed by future strategies (n = 0): <none>
[11:02:39.683] {
[11:02:39.683]     {
[11:02:39.683]         {
[11:02:39.683]             ...future.startTime <- base::Sys.time()
[11:02:39.683]             {
[11:02:39.683]                 {
[11:02:39.683]                   {
[11:02:39.683]                     {
[11:02:39.683]                       base::local({
[11:02:39.683]                         has_future <- base::requireNamespace("future", 
[11:02:39.683]                           quietly = TRUE)
[11:02:39.683]                         if (has_future) {
[11:02:39.683]                           ns <- base::getNamespace("future")
[11:02:39.683]                           version <- ns[[".package"]][["version"]]
[11:02:39.683]                           if (is.null(version)) 
[11:02:39.683]                             version <- utils::packageVersion("future")
[11:02:39.683]                         }
[11:02:39.683]                         else {
[11:02:39.683]                           version <- NULL
[11:02:39.683]                         }
[11:02:39.683]                         if (!has_future || version < "1.8.0") {
[11:02:39.683]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:39.683]                             "", base::R.version$version.string), 
[11:02:39.683]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:39.683]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:39.683]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:39.683]                               "release", "version")], collapse = " "), 
[11:02:39.683]                             hostname = base::Sys.info()[["nodename"]])
[11:02:39.683]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:39.683]                             info)
[11:02:39.683]                           info <- base::paste(info, collapse = "; ")
[11:02:39.683]                           if (!has_future) {
[11:02:39.683]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:39.683]                               info)
[11:02:39.683]                           }
[11:02:39.683]                           else {
[11:02:39.683]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:39.683]                               info, version)
[11:02:39.683]                           }
[11:02:39.683]                           base::stop(msg)
[11:02:39.683]                         }
[11:02:39.683]                       })
[11:02:39.683]                     }
[11:02:39.683]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:39.683]                     base::options(mc.cores = 1L)
[11:02:39.683]                   }
[11:02:39.683]                   ...future.strategy.old <- future::plan("list")
[11:02:39.683]                   options(future.plan = NULL)
[11:02:39.683]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:39.683]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:39.683]                 }
[11:02:39.683]                 ...future.workdir <- getwd()
[11:02:39.683]             }
[11:02:39.683]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:39.683]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:39.683]         }
[11:02:39.683]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:39.683]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:39.683]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:39.683]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:39.683]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:39.683]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:39.683]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:39.683]             base::names(...future.oldOptions))
[11:02:39.683]     }
[11:02:39.683]     if (FALSE) {
[11:02:39.683]     }
[11:02:39.683]     else {
[11:02:39.683]         if (TRUE) {
[11:02:39.683]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:39.683]                 open = "w")
[11:02:39.683]         }
[11:02:39.683]         else {
[11:02:39.683]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:39.683]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:39.683]         }
[11:02:39.683]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:39.683]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:39.683]             base::sink(type = "output", split = FALSE)
[11:02:39.683]             base::close(...future.stdout)
[11:02:39.683]         }, add = TRUE)
[11:02:39.683]     }
[11:02:39.683]     ...future.frame <- base::sys.nframe()
[11:02:39.683]     ...future.conditions <- base::list()
[11:02:39.683]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:39.683]     if (FALSE) {
[11:02:39.683]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:39.683]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:39.683]     }
[11:02:39.683]     ...future.result <- base::tryCatch({
[11:02:39.683]         base::withCallingHandlers({
[11:02:39.683]             ...future.value <- base::withVisible(base::local({
[11:02:39.683]                 withCallingHandlers({
[11:02:39.683]                   {
[11:02:39.683]                     1
[11:02:39.683]                   }
[11:02:39.683]                 }, immediateCondition = function(cond) {
[11:02:39.683]                   save_rds <- function (object, pathname, ...) 
[11:02:39.683]                   {
[11:02:39.683]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:02:39.683]                     if (file_test("-f", pathname_tmp)) {
[11:02:39.683]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.683]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:02:39.683]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.683]                         fi_tmp[["mtime"]])
[11:02:39.683]                     }
[11:02:39.683]                     tryCatch({
[11:02:39.683]                       saveRDS(object, file = pathname_tmp, ...)
[11:02:39.683]                     }, error = function(ex) {
[11:02:39.683]                       msg <- conditionMessage(ex)
[11:02:39.683]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.683]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:02:39.683]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.683]                         fi_tmp[["mtime"]], msg)
[11:02:39.683]                       ex$message <- msg
[11:02:39.683]                       stop(ex)
[11:02:39.683]                     })
[11:02:39.683]                     stopifnot(file_test("-f", pathname_tmp))
[11:02:39.683]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:02:39.683]                     if (!res || file_test("-f", pathname_tmp)) {
[11:02:39.683]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.683]                       fi <- file.info(pathname)
[11:02:39.683]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:02:39.683]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.683]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:02:39.683]                         fi[["size"]], fi[["mtime"]])
[11:02:39.683]                       stop(msg)
[11:02:39.683]                     }
[11:02:39.683]                     invisible(pathname)
[11:02:39.683]                   }
[11:02:39.683]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:02:39.683]                     rootPath = tempdir()) 
[11:02:39.683]                   {
[11:02:39.683]                     obj <- list(time = Sys.time(), condition = cond)
[11:02:39.683]                     file <- tempfile(pattern = class(cond)[1], 
[11:02:39.683]                       tmpdir = path, fileext = ".rds")
[11:02:39.683]                     save_rds(obj, file)
[11:02:39.683]                   }
[11:02:39.683]                   saveImmediateCondition(cond, path = "/tmp/RtmpPVwpFC/.future/immediateConditions")
[11:02:39.683]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.683]                   {
[11:02:39.683]                     inherits <- base::inherits
[11:02:39.683]                     invokeRestart <- base::invokeRestart
[11:02:39.683]                     is.null <- base::is.null
[11:02:39.683]                     muffled <- FALSE
[11:02:39.683]                     if (inherits(cond, "message")) {
[11:02:39.683]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:39.683]                       if (muffled) 
[11:02:39.683]                         invokeRestart("muffleMessage")
[11:02:39.683]                     }
[11:02:39.683]                     else if (inherits(cond, "warning")) {
[11:02:39.683]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:39.683]                       if (muffled) 
[11:02:39.683]                         invokeRestart("muffleWarning")
[11:02:39.683]                     }
[11:02:39.683]                     else if (inherits(cond, "condition")) {
[11:02:39.683]                       if (!is.null(pattern)) {
[11:02:39.683]                         computeRestarts <- base::computeRestarts
[11:02:39.683]                         grepl <- base::grepl
[11:02:39.683]                         restarts <- computeRestarts(cond)
[11:02:39.683]                         for (restart in restarts) {
[11:02:39.683]                           name <- restart$name
[11:02:39.683]                           if (is.null(name)) 
[11:02:39.683]                             next
[11:02:39.683]                           if (!grepl(pattern, name)) 
[11:02:39.683]                             next
[11:02:39.683]                           invokeRestart(restart)
[11:02:39.683]                           muffled <- TRUE
[11:02:39.683]                           break
[11:02:39.683]                         }
[11:02:39.683]                       }
[11:02:39.683]                     }
[11:02:39.683]                     invisible(muffled)
[11:02:39.683]                   }
[11:02:39.683]                   muffleCondition(cond)
[11:02:39.683]                 })
[11:02:39.683]             }))
[11:02:39.683]             future::FutureResult(value = ...future.value$value, 
[11:02:39.683]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:39.683]                   ...future.rng), globalenv = if (FALSE) 
[11:02:39.683]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:39.683]                     ...future.globalenv.names))
[11:02:39.683]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:39.683]         }, condition = base::local({
[11:02:39.683]             c <- base::c
[11:02:39.683]             inherits <- base::inherits
[11:02:39.683]             invokeRestart <- base::invokeRestart
[11:02:39.683]             length <- base::length
[11:02:39.683]             list <- base::list
[11:02:39.683]             seq.int <- base::seq.int
[11:02:39.683]             signalCondition <- base::signalCondition
[11:02:39.683]             sys.calls <- base::sys.calls
[11:02:39.683]             `[[` <- base::`[[`
[11:02:39.683]             `+` <- base::`+`
[11:02:39.683]             `<<-` <- base::`<<-`
[11:02:39.683]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:39.683]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:39.683]                   3L)]
[11:02:39.683]             }
[11:02:39.683]             function(cond) {
[11:02:39.683]                 is_error <- inherits(cond, "error")
[11:02:39.683]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:39.683]                   NULL)
[11:02:39.683]                 if (is_error) {
[11:02:39.683]                   sessionInformation <- function() {
[11:02:39.683]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:39.683]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:39.683]                       search = base::search(), system = base::Sys.info())
[11:02:39.683]                   }
[11:02:39.683]                   ...future.conditions[[length(...future.conditions) + 
[11:02:39.683]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:39.683]                     cond$call), session = sessionInformation(), 
[11:02:39.683]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:39.683]                   signalCondition(cond)
[11:02:39.683]                 }
[11:02:39.683]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:39.683]                 "immediateCondition"))) {
[11:02:39.683]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:39.683]                   ...future.conditions[[length(...future.conditions) + 
[11:02:39.683]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:39.683]                   if (TRUE && !signal) {
[11:02:39.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.683]                     {
[11:02:39.683]                       inherits <- base::inherits
[11:02:39.683]                       invokeRestart <- base::invokeRestart
[11:02:39.683]                       is.null <- base::is.null
[11:02:39.683]                       muffled <- FALSE
[11:02:39.683]                       if (inherits(cond, "message")) {
[11:02:39.683]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:39.683]                         if (muffled) 
[11:02:39.683]                           invokeRestart("muffleMessage")
[11:02:39.683]                       }
[11:02:39.683]                       else if (inherits(cond, "warning")) {
[11:02:39.683]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:39.683]                         if (muffled) 
[11:02:39.683]                           invokeRestart("muffleWarning")
[11:02:39.683]                       }
[11:02:39.683]                       else if (inherits(cond, "condition")) {
[11:02:39.683]                         if (!is.null(pattern)) {
[11:02:39.683]                           computeRestarts <- base::computeRestarts
[11:02:39.683]                           grepl <- base::grepl
[11:02:39.683]                           restarts <- computeRestarts(cond)
[11:02:39.683]                           for (restart in restarts) {
[11:02:39.683]                             name <- restart$name
[11:02:39.683]                             if (is.null(name)) 
[11:02:39.683]                               next
[11:02:39.683]                             if (!grepl(pattern, name)) 
[11:02:39.683]                               next
[11:02:39.683]                             invokeRestart(restart)
[11:02:39.683]                             muffled <- TRUE
[11:02:39.683]                             break
[11:02:39.683]                           }
[11:02:39.683]                         }
[11:02:39.683]                       }
[11:02:39.683]                       invisible(muffled)
[11:02:39.683]                     }
[11:02:39.683]                     muffleCondition(cond, pattern = "^muffle")
[11:02:39.683]                   }
[11:02:39.683]                 }
[11:02:39.683]                 else {
[11:02:39.683]                   if (TRUE) {
[11:02:39.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.683]                     {
[11:02:39.683]                       inherits <- base::inherits
[11:02:39.683]                       invokeRestart <- base::invokeRestart
[11:02:39.683]                       is.null <- base::is.null
[11:02:39.683]                       muffled <- FALSE
[11:02:39.683]                       if (inherits(cond, "message")) {
[11:02:39.683]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:39.683]                         if (muffled) 
[11:02:39.683]                           invokeRestart("muffleMessage")
[11:02:39.683]                       }
[11:02:39.683]                       else if (inherits(cond, "warning")) {
[11:02:39.683]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:39.683]                         if (muffled) 
[11:02:39.683]                           invokeRestart("muffleWarning")
[11:02:39.683]                       }
[11:02:39.683]                       else if (inherits(cond, "condition")) {
[11:02:39.683]                         if (!is.null(pattern)) {
[11:02:39.683]                           computeRestarts <- base::computeRestarts
[11:02:39.683]                           grepl <- base::grepl
[11:02:39.683]                           restarts <- computeRestarts(cond)
[11:02:39.683]                           for (restart in restarts) {
[11:02:39.683]                             name <- restart$name
[11:02:39.683]                             if (is.null(name)) 
[11:02:39.683]                               next
[11:02:39.683]                             if (!grepl(pattern, name)) 
[11:02:39.683]                               next
[11:02:39.683]                             invokeRestart(restart)
[11:02:39.683]                             muffled <- TRUE
[11:02:39.683]                             break
[11:02:39.683]                           }
[11:02:39.683]                         }
[11:02:39.683]                       }
[11:02:39.683]                       invisible(muffled)
[11:02:39.683]                     }
[11:02:39.683]                     muffleCondition(cond, pattern = "^muffle")
[11:02:39.683]                   }
[11:02:39.683]                 }
[11:02:39.683]             }
[11:02:39.683]         }))
[11:02:39.683]     }, error = function(ex) {
[11:02:39.683]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:39.683]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:39.683]                 ...future.rng), started = ...future.startTime, 
[11:02:39.683]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:39.683]             version = "1.8"), class = "FutureResult")
[11:02:39.683]     }, finally = {
[11:02:39.683]         if (!identical(...future.workdir, getwd())) 
[11:02:39.683]             setwd(...future.workdir)
[11:02:39.683]         {
[11:02:39.683]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:39.683]                 ...future.oldOptions$nwarnings <- NULL
[11:02:39.683]             }
[11:02:39.683]             base::options(...future.oldOptions)
[11:02:39.683]             if (.Platform$OS.type == "windows") {
[11:02:39.683]                 old_names <- names(...future.oldEnvVars)
[11:02:39.683]                 envs <- base::Sys.getenv()
[11:02:39.683]                 names <- names(envs)
[11:02:39.683]                 common <- intersect(names, old_names)
[11:02:39.683]                 added <- setdiff(names, old_names)
[11:02:39.683]                 removed <- setdiff(old_names, names)
[11:02:39.683]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:39.683]                   envs[common]]
[11:02:39.683]                 NAMES <- toupper(changed)
[11:02:39.683]                 args <- list()
[11:02:39.683]                 for (kk in seq_along(NAMES)) {
[11:02:39.683]                   name <- changed[[kk]]
[11:02:39.683]                   NAME <- NAMES[[kk]]
[11:02:39.683]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.683]                     next
[11:02:39.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:39.683]                 }
[11:02:39.683]                 NAMES <- toupper(added)
[11:02:39.683]                 for (kk in seq_along(NAMES)) {
[11:02:39.683]                   name <- added[[kk]]
[11:02:39.683]                   NAME <- NAMES[[kk]]
[11:02:39.683]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.683]                     next
[11:02:39.683]                   args[[name]] <- ""
[11:02:39.683]                 }
[11:02:39.683]                 NAMES <- toupper(removed)
[11:02:39.683]                 for (kk in seq_along(NAMES)) {
[11:02:39.683]                   name <- removed[[kk]]
[11:02:39.683]                   NAME <- NAMES[[kk]]
[11:02:39.683]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.683]                     next
[11:02:39.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:39.683]                 }
[11:02:39.683]                 if (length(args) > 0) 
[11:02:39.683]                   base::do.call(base::Sys.setenv, args = args)
[11:02:39.683]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:39.683]             }
[11:02:39.683]             else {
[11:02:39.683]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:39.683]             }
[11:02:39.683]             {
[11:02:39.683]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:39.683]                   0L) {
[11:02:39.683]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:39.683]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:39.683]                   base::options(opts)
[11:02:39.683]                 }
[11:02:39.683]                 {
[11:02:39.683]                   {
[11:02:39.683]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:39.683]                     NULL
[11:02:39.683]                   }
[11:02:39.683]                   options(future.plan = NULL)
[11:02:39.683]                   if (is.na(NA_character_)) 
[11:02:39.683]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:39.683]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:39.683]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:39.683]                     .init = FALSE)
[11:02:39.683]                 }
[11:02:39.683]             }
[11:02:39.683]         }
[11:02:39.683]     })
[11:02:39.683]     if (TRUE) {
[11:02:39.683]         base::sink(type = "output", split = FALSE)
[11:02:39.683]         if (TRUE) {
[11:02:39.683]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:39.683]         }
[11:02:39.683]         else {
[11:02:39.683]             ...future.result["stdout"] <- base::list(NULL)
[11:02:39.683]         }
[11:02:39.683]         base::close(...future.stdout)
[11:02:39.683]         ...future.stdout <- NULL
[11:02:39.683]     }
[11:02:39.683]     ...future.result$conditions <- ...future.conditions
[11:02:39.683]     ...future.result$finished <- base::Sys.time()
[11:02:39.683]     ...future.result
[11:02:39.683] }
[11:02:39.686] requestCore(): workers = 2
[11:02:39.687] Poll #1 (0): usedCores() = 2, workers = 2
[11:02:39.697] result() for MulticoreFuture ...
[11:02:39.698] result() for MulticoreFuture ...
[11:02:39.698] result() for MulticoreFuture ... done
[11:02:39.699] result() for MulticoreFuture ... done
[11:02:39.699] result() for MulticoreFuture ...
[11:02:39.699] result() for MulticoreFuture ... done
[11:02:39.701] MulticoreFuture started
[11:02:39.702] - Launch lazy future ... done
[11:02:39.702] run() for ‘MulticoreFuture’ ... done
[11:02:39.702] plan(): Setting new future strategy stack:
[11:02:39.703] getGlobalsAndPackages() ...
[11:02:39.703] Searching for globals...
[11:02:39.702] List of future strategies:
[11:02:39.702] 1. sequential:
[11:02:39.702]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:39.702]    - tweaked: FALSE
[11:02:39.702]    - call: NULL
[11:02:39.703] plan(): nbrOfWorkers() = 1
[11:02:39.704] - globals found: [1] ‘{’
[11:02:39.705] Searching for globals ... DONE
[11:02:39.705] Resolving globals: FALSE
[11:02:39.705] 
[11:02:39.706] plan(): Setting new future strategy stack:
[11:02:39.706] List of future strategies:
[11:02:39.706] 1. multicore:
[11:02:39.706]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:39.706]    - tweaked: FALSE
[11:02:39.706]    - call: plan(strategy)
[11:02:39.706] 
[11:02:39.710] getGlobalsAndPackages() ... DONE
[11:02:39.711] run() for ‘Future’ ...
[11:02:39.712] - state: ‘created’
[11:02:39.712] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:02:39.713] plan(): nbrOfWorkers() = 2
[11:02:39.716] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:39.717] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:02:39.717]   - Field: ‘label’
[11:02:39.717]   - Field: ‘local’
[11:02:39.717]   - Field: ‘owner’
[11:02:39.717]   - Field: ‘envir’
[11:02:39.718]   - Field: ‘workers’
[11:02:39.718]   - Field: ‘packages’
[11:02:39.718]   - Field: ‘gc’
[11:02:39.718]   - Field: ‘job’
[11:02:39.718]   - Field: ‘conditions’
[11:02:39.719]   - Field: ‘expr’
[11:02:39.719]   - Field: ‘uuid’
[11:02:39.719]   - Field: ‘seed’
[11:02:39.719]   - Field: ‘version’
[11:02:39.719]   - Field: ‘result’
[11:02:39.719]   - Field: ‘asynchronous’
[11:02:39.719]   - Field: ‘calls’
[11:02:39.720]   - Field: ‘globals’
[11:02:39.720]   - Field: ‘stdout’
[11:02:39.720]   - Field: ‘earlySignal’
[11:02:39.720]   - Field: ‘lazy’
[11:02:39.720]   - Field: ‘state’
[11:02:39.720] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:02:39.721] - Launch lazy future ...
[11:02:39.721] Packages needed by the future expression (n = 0): <none>
[11:02:39.721] Packages needed by future strategies (n = 0): <none>
[11:02:39.722] {
[11:02:39.722]     {
[11:02:39.722]         {
[11:02:39.722]             ...future.startTime <- base::Sys.time()
[11:02:39.722]             {
[11:02:39.722]                 {
[11:02:39.722]                   {
[11:02:39.722]                     {
[11:02:39.722]                       base::local({
[11:02:39.722]                         has_future <- base::requireNamespace("future", 
[11:02:39.722]                           quietly = TRUE)
[11:02:39.722]                         if (has_future) {
[11:02:39.722]                           ns <- base::getNamespace("future")
[11:02:39.722]                           version <- ns[[".package"]][["version"]]
[11:02:39.722]                           if (is.null(version)) 
[11:02:39.722]                             version <- utils::packageVersion("future")
[11:02:39.722]                         }
[11:02:39.722]                         else {
[11:02:39.722]                           version <- NULL
[11:02:39.722]                         }
[11:02:39.722]                         if (!has_future || version < "1.8.0") {
[11:02:39.722]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:39.722]                             "", base::R.version$version.string), 
[11:02:39.722]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:39.722]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:39.722]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:39.722]                               "release", "version")], collapse = " "), 
[11:02:39.722]                             hostname = base::Sys.info()[["nodename"]])
[11:02:39.722]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:39.722]                             info)
[11:02:39.722]                           info <- base::paste(info, collapse = "; ")
[11:02:39.722]                           if (!has_future) {
[11:02:39.722]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:39.722]                               info)
[11:02:39.722]                           }
[11:02:39.722]                           else {
[11:02:39.722]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:39.722]                               info, version)
[11:02:39.722]                           }
[11:02:39.722]                           base::stop(msg)
[11:02:39.722]                         }
[11:02:39.722]                       })
[11:02:39.722]                     }
[11:02:39.722]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:39.722]                     base::options(mc.cores = 1L)
[11:02:39.722]                   }
[11:02:39.722]                   ...future.strategy.old <- future::plan("list")
[11:02:39.722]                   options(future.plan = NULL)
[11:02:39.722]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:39.722]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:39.722]                 }
[11:02:39.722]                 ...future.workdir <- getwd()
[11:02:39.722]             }
[11:02:39.722]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:39.722]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:39.722]         }
[11:02:39.722]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:39.722]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:39.722]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:39.722]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:39.722]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:39.722]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:39.722]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:39.722]             base::names(...future.oldOptions))
[11:02:39.722]     }
[11:02:39.722]     if (FALSE) {
[11:02:39.722]     }
[11:02:39.722]     else {
[11:02:39.722]         if (TRUE) {
[11:02:39.722]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:39.722]                 open = "w")
[11:02:39.722]         }
[11:02:39.722]         else {
[11:02:39.722]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:39.722]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:39.722]         }
[11:02:39.722]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:39.722]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:39.722]             base::sink(type = "output", split = FALSE)
[11:02:39.722]             base::close(...future.stdout)
[11:02:39.722]         }, add = TRUE)
[11:02:39.722]     }
[11:02:39.722]     ...future.frame <- base::sys.nframe()
[11:02:39.722]     ...future.conditions <- base::list()
[11:02:39.722]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:39.722]     if (FALSE) {
[11:02:39.722]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:39.722]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:39.722]     }
[11:02:39.722]     ...future.result <- base::tryCatch({
[11:02:39.722]         base::withCallingHandlers({
[11:02:39.722]             ...future.value <- base::withVisible(base::local({
[11:02:39.722]                 withCallingHandlers({
[11:02:39.722]                   {
[11:02:39.722]                     2
[11:02:39.722]                   }
[11:02:39.722]                 }, immediateCondition = function(cond) {
[11:02:39.722]                   save_rds <- function (object, pathname, ...) 
[11:02:39.722]                   {
[11:02:39.722]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:02:39.722]                     if (file_test("-f", pathname_tmp)) {
[11:02:39.722]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.722]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:02:39.722]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.722]                         fi_tmp[["mtime"]])
[11:02:39.722]                     }
[11:02:39.722]                     tryCatch({
[11:02:39.722]                       saveRDS(object, file = pathname_tmp, ...)
[11:02:39.722]                     }, error = function(ex) {
[11:02:39.722]                       msg <- conditionMessage(ex)
[11:02:39.722]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.722]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:02:39.722]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.722]                         fi_tmp[["mtime"]], msg)
[11:02:39.722]                       ex$message <- msg
[11:02:39.722]                       stop(ex)
[11:02:39.722]                     })
[11:02:39.722]                     stopifnot(file_test("-f", pathname_tmp))
[11:02:39.722]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:02:39.722]                     if (!res || file_test("-f", pathname_tmp)) {
[11:02:39.722]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.722]                       fi <- file.info(pathname)
[11:02:39.722]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:02:39.722]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.722]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:02:39.722]                         fi[["size"]], fi[["mtime"]])
[11:02:39.722]                       stop(msg)
[11:02:39.722]                     }
[11:02:39.722]                     invisible(pathname)
[11:02:39.722]                   }
[11:02:39.722]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:02:39.722]                     rootPath = tempdir()) 
[11:02:39.722]                   {
[11:02:39.722]                     obj <- list(time = Sys.time(), condition = cond)
[11:02:39.722]                     file <- tempfile(pattern = class(cond)[1], 
[11:02:39.722]                       tmpdir = path, fileext = ".rds")
[11:02:39.722]                     save_rds(obj, file)
[11:02:39.722]                   }
[11:02:39.722]                   saveImmediateCondition(cond, path = "/tmp/RtmpPVwpFC/.future/immediateConditions")
[11:02:39.722]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.722]                   {
[11:02:39.722]                     inherits <- base::inherits
[11:02:39.722]                     invokeRestart <- base::invokeRestart
[11:02:39.722]                     is.null <- base::is.null
[11:02:39.722]                     muffled <- FALSE
[11:02:39.722]                     if (inherits(cond, "message")) {
[11:02:39.722]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:39.722]                       if (muffled) 
[11:02:39.722]                         invokeRestart("muffleMessage")
[11:02:39.722]                     }
[11:02:39.722]                     else if (inherits(cond, "warning")) {
[11:02:39.722]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:39.722]                       if (muffled) 
[11:02:39.722]                         invokeRestart("muffleWarning")
[11:02:39.722]                     }
[11:02:39.722]                     else if (inherits(cond, "condition")) {
[11:02:39.722]                       if (!is.null(pattern)) {
[11:02:39.722]                         computeRestarts <- base::computeRestarts
[11:02:39.722]                         grepl <- base::grepl
[11:02:39.722]                         restarts <- computeRestarts(cond)
[11:02:39.722]                         for (restart in restarts) {
[11:02:39.722]                           name <- restart$name
[11:02:39.722]                           if (is.null(name)) 
[11:02:39.722]                             next
[11:02:39.722]                           if (!grepl(pattern, name)) 
[11:02:39.722]                             next
[11:02:39.722]                           invokeRestart(restart)
[11:02:39.722]                           muffled <- TRUE
[11:02:39.722]                           break
[11:02:39.722]                         }
[11:02:39.722]                       }
[11:02:39.722]                     }
[11:02:39.722]                     invisible(muffled)
[11:02:39.722]                   }
[11:02:39.722]                   muffleCondition(cond)
[11:02:39.722]                 })
[11:02:39.722]             }))
[11:02:39.722]             future::FutureResult(value = ...future.value$value, 
[11:02:39.722]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:39.722]                   ...future.rng), globalenv = if (FALSE) 
[11:02:39.722]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:39.722]                     ...future.globalenv.names))
[11:02:39.722]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:39.722]         }, condition = base::local({
[11:02:39.722]             c <- base::c
[11:02:39.722]             inherits <- base::inherits
[11:02:39.722]             invokeRestart <- base::invokeRestart
[11:02:39.722]             length <- base::length
[11:02:39.722]             list <- base::list
[11:02:39.722]             seq.int <- base::seq.int
[11:02:39.722]             signalCondition <- base::signalCondition
[11:02:39.722]             sys.calls <- base::sys.calls
[11:02:39.722]             `[[` <- base::`[[`
[11:02:39.722]             `+` <- base::`+`
[11:02:39.722]             `<<-` <- base::`<<-`
[11:02:39.722]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:39.722]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:39.722]                   3L)]
[11:02:39.722]             }
[11:02:39.722]             function(cond) {
[11:02:39.722]                 is_error <- inherits(cond, "error")
[11:02:39.722]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:39.722]                   NULL)
[11:02:39.722]                 if (is_error) {
[11:02:39.722]                   sessionInformation <- function() {
[11:02:39.722]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:39.722]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:39.722]                       search = base::search(), system = base::Sys.info())
[11:02:39.722]                   }
[11:02:39.722]                   ...future.conditions[[length(...future.conditions) + 
[11:02:39.722]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:39.722]                     cond$call), session = sessionInformation(), 
[11:02:39.722]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:39.722]                   signalCondition(cond)
[11:02:39.722]                 }
[11:02:39.722]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:39.722]                 "immediateCondition"))) {
[11:02:39.722]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:39.722]                   ...future.conditions[[length(...future.conditions) + 
[11:02:39.722]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:39.722]                   if (TRUE && !signal) {
[11:02:39.722]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.722]                     {
[11:02:39.722]                       inherits <- base::inherits
[11:02:39.722]                       invokeRestart <- base::invokeRestart
[11:02:39.722]                       is.null <- base::is.null
[11:02:39.722]                       muffled <- FALSE
[11:02:39.722]                       if (inherits(cond, "message")) {
[11:02:39.722]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:39.722]                         if (muffled) 
[11:02:39.722]                           invokeRestart("muffleMessage")
[11:02:39.722]                       }
[11:02:39.722]                       else if (inherits(cond, "warning")) {
[11:02:39.722]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:39.722]                         if (muffled) 
[11:02:39.722]                           invokeRestart("muffleWarning")
[11:02:39.722]                       }
[11:02:39.722]                       else if (inherits(cond, "condition")) {
[11:02:39.722]                         if (!is.null(pattern)) {
[11:02:39.722]                           computeRestarts <- base::computeRestarts
[11:02:39.722]                           grepl <- base::grepl
[11:02:39.722]                           restarts <- computeRestarts(cond)
[11:02:39.722]                           for (restart in restarts) {
[11:02:39.722]                             name <- restart$name
[11:02:39.722]                             if (is.null(name)) 
[11:02:39.722]                               next
[11:02:39.722]                             if (!grepl(pattern, name)) 
[11:02:39.722]                               next
[11:02:39.722]                             invokeRestart(restart)
[11:02:39.722]                             muffled <- TRUE
[11:02:39.722]                             break
[11:02:39.722]                           }
[11:02:39.722]                         }
[11:02:39.722]                       }
[11:02:39.722]                       invisible(muffled)
[11:02:39.722]                     }
[11:02:39.722]                     muffleCondition(cond, pattern = "^muffle")
[11:02:39.722]                   }
[11:02:39.722]                 }
[11:02:39.722]                 else {
[11:02:39.722]                   if (TRUE) {
[11:02:39.722]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.722]                     {
[11:02:39.722]                       inherits <- base::inherits
[11:02:39.722]                       invokeRestart <- base::invokeRestart
[11:02:39.722]                       is.null <- base::is.null
[11:02:39.722]                       muffled <- FALSE
[11:02:39.722]                       if (inherits(cond, "message")) {
[11:02:39.722]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:39.722]                         if (muffled) 
[11:02:39.722]                           invokeRestart("muffleMessage")
[11:02:39.722]                       }
[11:02:39.722]                       else if (inherits(cond, "warning")) {
[11:02:39.722]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:39.722]                         if (muffled) 
[11:02:39.722]                           invokeRestart("muffleWarning")
[11:02:39.722]                       }
[11:02:39.722]                       else if (inherits(cond, "condition")) {
[11:02:39.722]                         if (!is.null(pattern)) {
[11:02:39.722]                           computeRestarts <- base::computeRestarts
[11:02:39.722]                           grepl <- base::grepl
[11:02:39.722]                           restarts <- computeRestarts(cond)
[11:02:39.722]                           for (restart in restarts) {
[11:02:39.722]                             name <- restart$name
[11:02:39.722]                             if (is.null(name)) 
[11:02:39.722]                               next
[11:02:39.722]                             if (!grepl(pattern, name)) 
[11:02:39.722]                               next
[11:02:39.722]                             invokeRestart(restart)
[11:02:39.722]                             muffled <- TRUE
[11:02:39.722]                             break
[11:02:39.722]                           }
[11:02:39.722]                         }
[11:02:39.722]                       }
[11:02:39.722]                       invisible(muffled)
[11:02:39.722]                     }
[11:02:39.722]                     muffleCondition(cond, pattern = "^muffle")
[11:02:39.722]                   }
[11:02:39.722]                 }
[11:02:39.722]             }
[11:02:39.722]         }))
[11:02:39.722]     }, error = function(ex) {
[11:02:39.722]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:39.722]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:39.722]                 ...future.rng), started = ...future.startTime, 
[11:02:39.722]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:39.722]             version = "1.8"), class = "FutureResult")
[11:02:39.722]     }, finally = {
[11:02:39.722]         if (!identical(...future.workdir, getwd())) 
[11:02:39.722]             setwd(...future.workdir)
[11:02:39.722]         {
[11:02:39.722]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:39.722]                 ...future.oldOptions$nwarnings <- NULL
[11:02:39.722]             }
[11:02:39.722]             base::options(...future.oldOptions)
[11:02:39.722]             if (.Platform$OS.type == "windows") {
[11:02:39.722]                 old_names <- names(...future.oldEnvVars)
[11:02:39.722]                 envs <- base::Sys.getenv()
[11:02:39.722]                 names <- names(envs)
[11:02:39.722]                 common <- intersect(names, old_names)
[11:02:39.722]                 added <- setdiff(names, old_names)
[11:02:39.722]                 removed <- setdiff(old_names, names)
[11:02:39.722]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:39.722]                   envs[common]]
[11:02:39.722]                 NAMES <- toupper(changed)
[11:02:39.722]                 args <- list()
[11:02:39.722]                 for (kk in seq_along(NAMES)) {
[11:02:39.722]                   name <- changed[[kk]]
[11:02:39.722]                   NAME <- NAMES[[kk]]
[11:02:39.722]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.722]                     next
[11:02:39.722]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:39.722]                 }
[11:02:39.722]                 NAMES <- toupper(added)
[11:02:39.722]                 for (kk in seq_along(NAMES)) {
[11:02:39.722]                   name <- added[[kk]]
[11:02:39.722]                   NAME <- NAMES[[kk]]
[11:02:39.722]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.722]                     next
[11:02:39.722]                   args[[name]] <- ""
[11:02:39.722]                 }
[11:02:39.722]                 NAMES <- toupper(removed)
[11:02:39.722]                 for (kk in seq_along(NAMES)) {
[11:02:39.722]                   name <- removed[[kk]]
[11:02:39.722]                   NAME <- NAMES[[kk]]
[11:02:39.722]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.722]                     next
[11:02:39.722]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:39.722]                 }
[11:02:39.722]                 if (length(args) > 0) 
[11:02:39.722]                   base::do.call(base::Sys.setenv, args = args)
[11:02:39.722]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:39.722]             }
[11:02:39.722]             else {
[11:02:39.722]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:39.722]             }
[11:02:39.722]             {
[11:02:39.722]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:39.722]                   0L) {
[11:02:39.722]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:39.722]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:39.722]                   base::options(opts)
[11:02:39.722]                 }
[11:02:39.722]                 {
[11:02:39.722]                   {
[11:02:39.722]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:39.722]                     NULL
[11:02:39.722]                   }
[11:02:39.722]                   options(future.plan = NULL)
[11:02:39.722]                   if (is.na(NA_character_)) 
[11:02:39.722]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:39.722]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:39.722]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:39.722]                     .init = FALSE)
[11:02:39.722]                 }
[11:02:39.722]             }
[11:02:39.722]         }
[11:02:39.722]     })
[11:02:39.722]     if (TRUE) {
[11:02:39.722]         base::sink(type = "output", split = FALSE)
[11:02:39.722]         if (TRUE) {
[11:02:39.722]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:39.722]         }
[11:02:39.722]         else {
[11:02:39.722]             ...future.result["stdout"] <- base::list(NULL)
[11:02:39.722]         }
[11:02:39.722]         base::close(...future.stdout)
[11:02:39.722]         ...future.stdout <- NULL
[11:02:39.722]     }
[11:02:39.722]     ...future.result$conditions <- ...future.conditions
[11:02:39.722]     ...future.result$finished <- base::Sys.time()
[11:02:39.722]     ...future.result
[11:02:39.722] }
[11:02:39.724] requestCore(): workers = 2
[11:02:39.725] Poll #1 (0): usedCores() = 2, workers = 2
[11:02:39.735] result() for MulticoreFuture ...
[11:02:39.736] result() for MulticoreFuture ...
[11:02:39.737] result() for MulticoreFuture ... done
[11:02:39.737] result() for MulticoreFuture ... done
[11:02:39.737] result() for MulticoreFuture ...
[11:02:39.737] result() for MulticoreFuture ... done
[11:02:39.739] MulticoreFuture started
[11:02:39.740] - Launch lazy future ... done
[11:02:39.740] run() for ‘MulticoreFuture’ ... done
[11:02:39.740] plan(): Setting new future strategy stack:
[11:02:39.741] List of future strategies:
[11:02:39.741] 1. sequential:
[11:02:39.741]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:39.741]    - tweaked: FALSE
[11:02:39.741]    - call: NULL
[11:02:39.742] resolve() on environment ...
[11:02:39.742]  recursive: 0
[11:02:39.742] plan(): nbrOfWorkers() = 1
[11:02:39.743]  elements: [3] ‘a’
[11:02:39.744] Future #1
[11:02:39.744]  length: 2 (resolved future 1)
[11:02:39.745] plan(): Setting new future strategy stack:
[11:02:39.745] List of future strategies:
[11:02:39.745] 1. multicore:
[11:02:39.745]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:39.745]    - tweaked: FALSE
[11:02:39.745]    - call: plan(strategy)
[11:02:39.748] plan(): nbrOfWorkers() = 2
[11:02:39.749] Future #2
[11:02:39.749]  length: 1 (resolved future 2)
[11:02:39.749]  length: 0 (resolved future 3)
[11:02:39.749] resolve() on environment ... DONE
[11:02:39.750] resolve() on environment ...
[11:02:39.750]  recursive: 0
[11:02:39.751]  elements: [3] ‘b’
[11:02:39.751] Future #1
[11:02:39.752]  length: 2 (resolved future 1)
[11:02:39.752] Future #2
[11:02:39.752]  length: 1 (resolved future 2)
[11:02:39.752]  length: 0 (resolved future 3)
[11:02:39.752] resolve() on environment ... DONE
[11:02:39.753] resolve() on environment ...
[11:02:39.753]  recursive: 0
[11:02:39.754]  elements: [3] ‘c’
[11:02:39.754] Future #1
[11:02:39.754]  length: 2 (resolved future 1)
[11:02:39.755] Future #2
[11:02:39.755]  length: 1 (resolved future 2)
[11:02:39.755]  length: 0 (resolved future 3)
[11:02:39.755] resolve() on environment ... DONE
[11:02:39.756] resolve() on environment ...
[11:02:39.756]  recursive: 0
[11:02:39.757]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[11:02:39.757] Future #1
[11:02:39.757] result() for MulticoreFuture ...
[11:02:39.758] result() for MulticoreFuture ...
[11:02:39.758] result() for MulticoreFuture ... done
[11:02:39.758] result() for MulticoreFuture ... done
[11:02:39.759] result() for MulticoreFuture ...
[11:02:39.759] result() for MulticoreFuture ... done
[11:02:39.759]  length: 2 (resolved future 1)
[11:02:39.759] Future #2
[11:02:39.759] result() for MulticoreFuture ...
[11:02:39.760] result() for MulticoreFuture ...
[11:02:39.760] result() for MulticoreFuture ... done
[11:02:39.760] result() for MulticoreFuture ... done
[11:02:39.761] result() for MulticoreFuture ...
[11:02:39.761] result() for MulticoreFuture ... done
[11:02:39.761]  length: 1 (resolved future 2)
[11:02:39.761]  length: 0 (resolved future 3)
[11:02:39.761] resolve() on environment ... DONE
[11:02:39.762] resolve() on environment ...
[11:02:39.762]  recursive: 99
[11:02:39.763]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[11:02:39.764] Future #1
[11:02:39.764] result() for MulticoreFuture ...
[11:02:39.764] result() for MulticoreFuture ... done
[11:02:39.764] result() for MulticoreFuture ...
[11:02:39.764] result() for MulticoreFuture ... done
[11:02:39.764] A MulticoreFuture was resolved
[11:02:39.764]  length: 2 (resolved future 1)
[11:02:39.764] Future #2
[11:02:39.765] result() for MulticoreFuture ...
[11:02:39.765] result() for MulticoreFuture ... done
[11:02:39.765] result() for MulticoreFuture ...
[11:02:39.765] result() for MulticoreFuture ... done
[11:02:39.765] A MulticoreFuture was resolved
[11:02:39.765]  length: 1 (resolved future 2)
[11:02:39.765]  length: 0 (resolved future 3)
[11:02:39.765] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[11:02:39.766] resolve() on list environment ...
[11:02:39.766]  recursive: 0
[11:02:39.767]  length: 2
[11:02:39.767]  elements: ‘a’, ‘b’
[11:02:39.767]  length: 1 (resolved future 1)
[11:02:39.767]  length: 0 (resolved future 2)
[11:02:39.767] resolve() on list environment ... DONE
[11:02:39.768] getGlobalsAndPackages() ...
[11:02:39.768] Searching for globals...
[11:02:39.768] 
[11:02:39.768] Searching for globals ... DONE
[11:02:39.768] - globals: [0] <none>
[11:02:39.768] getGlobalsAndPackages() ... DONE
[11:02:39.769] run() for ‘Future’ ...
[11:02:39.769] - state: ‘created’
[11:02:39.769] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:02:39.773] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:39.774] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:02:39.774]   - Field: ‘label’
[11:02:39.774]   - Field: ‘local’
[11:02:39.774]   - Field: ‘owner’
[11:02:39.774]   - Field: ‘envir’
[11:02:39.774]   - Field: ‘workers’
[11:02:39.775]   - Field: ‘packages’
[11:02:39.775]   - Field: ‘gc’
[11:02:39.775]   - Field: ‘job’
[11:02:39.775]   - Field: ‘conditions’
[11:02:39.775]   - Field: ‘expr’
[11:02:39.775]   - Field: ‘uuid’
[11:02:39.775]   - Field: ‘seed’
[11:02:39.775]   - Field: ‘version’
[11:02:39.775]   - Field: ‘result’
[11:02:39.776]   - Field: ‘asynchronous’
[11:02:39.776]   - Field: ‘calls’
[11:02:39.776]   - Field: ‘globals’
[11:02:39.776]   - Field: ‘stdout’
[11:02:39.776]   - Field: ‘earlySignal’
[11:02:39.776]   - Field: ‘lazy’
[11:02:39.776]   - Field: ‘state’
[11:02:39.776] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:02:39.776] - Launch lazy future ...
[11:02:39.777] Packages needed by the future expression (n = 0): <none>
[11:02:39.777] Packages needed by future strategies (n = 0): <none>
[11:02:39.777] {
[11:02:39.777]     {
[11:02:39.777]         {
[11:02:39.777]             ...future.startTime <- base::Sys.time()
[11:02:39.777]             {
[11:02:39.777]                 {
[11:02:39.777]                   {
[11:02:39.777]                     {
[11:02:39.777]                       base::local({
[11:02:39.777]                         has_future <- base::requireNamespace("future", 
[11:02:39.777]                           quietly = TRUE)
[11:02:39.777]                         if (has_future) {
[11:02:39.777]                           ns <- base::getNamespace("future")
[11:02:39.777]                           version <- ns[[".package"]][["version"]]
[11:02:39.777]                           if (is.null(version)) 
[11:02:39.777]                             version <- utils::packageVersion("future")
[11:02:39.777]                         }
[11:02:39.777]                         else {
[11:02:39.777]                           version <- NULL
[11:02:39.777]                         }
[11:02:39.777]                         if (!has_future || version < "1.8.0") {
[11:02:39.777]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:39.777]                             "", base::R.version$version.string), 
[11:02:39.777]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:39.777]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:39.777]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:39.777]                               "release", "version")], collapse = " "), 
[11:02:39.777]                             hostname = base::Sys.info()[["nodename"]])
[11:02:39.777]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:39.777]                             info)
[11:02:39.777]                           info <- base::paste(info, collapse = "; ")
[11:02:39.777]                           if (!has_future) {
[11:02:39.777]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:39.777]                               info)
[11:02:39.777]                           }
[11:02:39.777]                           else {
[11:02:39.777]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:39.777]                               info, version)
[11:02:39.777]                           }
[11:02:39.777]                           base::stop(msg)
[11:02:39.777]                         }
[11:02:39.777]                       })
[11:02:39.777]                     }
[11:02:39.777]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:39.777]                     base::options(mc.cores = 1L)
[11:02:39.777]                   }
[11:02:39.777]                   ...future.strategy.old <- future::plan("list")
[11:02:39.777]                   options(future.plan = NULL)
[11:02:39.777]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:39.777]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:39.777]                 }
[11:02:39.777]                 ...future.workdir <- getwd()
[11:02:39.777]             }
[11:02:39.777]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:39.777]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:39.777]         }
[11:02:39.777]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:39.777]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:39.777]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:39.777]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:39.777]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:39.777]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:39.777]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:39.777]             base::names(...future.oldOptions))
[11:02:39.777]     }
[11:02:39.777]     if (FALSE) {
[11:02:39.777]     }
[11:02:39.777]     else {
[11:02:39.777]         if (TRUE) {
[11:02:39.777]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:39.777]                 open = "w")
[11:02:39.777]         }
[11:02:39.777]         else {
[11:02:39.777]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:39.777]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:39.777]         }
[11:02:39.777]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:39.777]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:39.777]             base::sink(type = "output", split = FALSE)
[11:02:39.777]             base::close(...future.stdout)
[11:02:39.777]         }, add = TRUE)
[11:02:39.777]     }
[11:02:39.777]     ...future.frame <- base::sys.nframe()
[11:02:39.777]     ...future.conditions <- base::list()
[11:02:39.777]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:39.777]     if (FALSE) {
[11:02:39.777]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:39.777]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:39.777]     }
[11:02:39.777]     ...future.result <- base::tryCatch({
[11:02:39.777]         base::withCallingHandlers({
[11:02:39.777]             ...future.value <- base::withVisible(base::local({
[11:02:39.777]                 withCallingHandlers({
[11:02:39.777]                   1
[11:02:39.777]                 }, immediateCondition = function(cond) {
[11:02:39.777]                   save_rds <- function (object, pathname, ...) 
[11:02:39.777]                   {
[11:02:39.777]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:02:39.777]                     if (file_test("-f", pathname_tmp)) {
[11:02:39.777]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.777]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:02:39.777]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.777]                         fi_tmp[["mtime"]])
[11:02:39.777]                     }
[11:02:39.777]                     tryCatch({
[11:02:39.777]                       saveRDS(object, file = pathname_tmp, ...)
[11:02:39.777]                     }, error = function(ex) {
[11:02:39.777]                       msg <- conditionMessage(ex)
[11:02:39.777]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.777]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:02:39.777]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.777]                         fi_tmp[["mtime"]], msg)
[11:02:39.777]                       ex$message <- msg
[11:02:39.777]                       stop(ex)
[11:02:39.777]                     })
[11:02:39.777]                     stopifnot(file_test("-f", pathname_tmp))
[11:02:39.777]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:02:39.777]                     if (!res || file_test("-f", pathname_tmp)) {
[11:02:39.777]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.777]                       fi <- file.info(pathname)
[11:02:39.777]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:02:39.777]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.777]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:02:39.777]                         fi[["size"]], fi[["mtime"]])
[11:02:39.777]                       stop(msg)
[11:02:39.777]                     }
[11:02:39.777]                     invisible(pathname)
[11:02:39.777]                   }
[11:02:39.777]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:02:39.777]                     rootPath = tempdir()) 
[11:02:39.777]                   {
[11:02:39.777]                     obj <- list(time = Sys.time(), condition = cond)
[11:02:39.777]                     file <- tempfile(pattern = class(cond)[1], 
[11:02:39.777]                       tmpdir = path, fileext = ".rds")
[11:02:39.777]                     save_rds(obj, file)
[11:02:39.777]                   }
[11:02:39.777]                   saveImmediateCondition(cond, path = "/tmp/RtmpPVwpFC/.future/immediateConditions")
[11:02:39.777]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.777]                   {
[11:02:39.777]                     inherits <- base::inherits
[11:02:39.777]                     invokeRestart <- base::invokeRestart
[11:02:39.777]                     is.null <- base::is.null
[11:02:39.777]                     muffled <- FALSE
[11:02:39.777]                     if (inherits(cond, "message")) {
[11:02:39.777]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:39.777]                       if (muffled) 
[11:02:39.777]                         invokeRestart("muffleMessage")
[11:02:39.777]                     }
[11:02:39.777]                     else if (inherits(cond, "warning")) {
[11:02:39.777]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:39.777]                       if (muffled) 
[11:02:39.777]                         invokeRestart("muffleWarning")
[11:02:39.777]                     }
[11:02:39.777]                     else if (inherits(cond, "condition")) {
[11:02:39.777]                       if (!is.null(pattern)) {
[11:02:39.777]                         computeRestarts <- base::computeRestarts
[11:02:39.777]                         grepl <- base::grepl
[11:02:39.777]                         restarts <- computeRestarts(cond)
[11:02:39.777]                         for (restart in restarts) {
[11:02:39.777]                           name <- restart$name
[11:02:39.777]                           if (is.null(name)) 
[11:02:39.777]                             next
[11:02:39.777]                           if (!grepl(pattern, name)) 
[11:02:39.777]                             next
[11:02:39.777]                           invokeRestart(restart)
[11:02:39.777]                           muffled <- TRUE
[11:02:39.777]                           break
[11:02:39.777]                         }
[11:02:39.777]                       }
[11:02:39.777]                     }
[11:02:39.777]                     invisible(muffled)
[11:02:39.777]                   }
[11:02:39.777]                   muffleCondition(cond)
[11:02:39.777]                 })
[11:02:39.777]             }))
[11:02:39.777]             future::FutureResult(value = ...future.value$value, 
[11:02:39.777]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:39.777]                   ...future.rng), globalenv = if (FALSE) 
[11:02:39.777]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:39.777]                     ...future.globalenv.names))
[11:02:39.777]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:39.777]         }, condition = base::local({
[11:02:39.777]             c <- base::c
[11:02:39.777]             inherits <- base::inherits
[11:02:39.777]             invokeRestart <- base::invokeRestart
[11:02:39.777]             length <- base::length
[11:02:39.777]             list <- base::list
[11:02:39.777]             seq.int <- base::seq.int
[11:02:39.777]             signalCondition <- base::signalCondition
[11:02:39.777]             sys.calls <- base::sys.calls
[11:02:39.777]             `[[` <- base::`[[`
[11:02:39.777]             `+` <- base::`+`
[11:02:39.777]             `<<-` <- base::`<<-`
[11:02:39.777]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:39.777]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:39.777]                   3L)]
[11:02:39.777]             }
[11:02:39.777]             function(cond) {
[11:02:39.777]                 is_error <- inherits(cond, "error")
[11:02:39.777]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:39.777]                   NULL)
[11:02:39.777]                 if (is_error) {
[11:02:39.777]                   sessionInformation <- function() {
[11:02:39.777]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:39.777]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:39.777]                       search = base::search(), system = base::Sys.info())
[11:02:39.777]                   }
[11:02:39.777]                   ...future.conditions[[length(...future.conditions) + 
[11:02:39.777]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:39.777]                     cond$call), session = sessionInformation(), 
[11:02:39.777]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:39.777]                   signalCondition(cond)
[11:02:39.777]                 }
[11:02:39.777]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:39.777]                 "immediateCondition"))) {
[11:02:39.777]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:39.777]                   ...future.conditions[[length(...future.conditions) + 
[11:02:39.777]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:39.777]                   if (TRUE && !signal) {
[11:02:39.777]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.777]                     {
[11:02:39.777]                       inherits <- base::inherits
[11:02:39.777]                       invokeRestart <- base::invokeRestart
[11:02:39.777]                       is.null <- base::is.null
[11:02:39.777]                       muffled <- FALSE
[11:02:39.777]                       if (inherits(cond, "message")) {
[11:02:39.777]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:39.777]                         if (muffled) 
[11:02:39.777]                           invokeRestart("muffleMessage")
[11:02:39.777]                       }
[11:02:39.777]                       else if (inherits(cond, "warning")) {
[11:02:39.777]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:39.777]                         if (muffled) 
[11:02:39.777]                           invokeRestart("muffleWarning")
[11:02:39.777]                       }
[11:02:39.777]                       else if (inherits(cond, "condition")) {
[11:02:39.777]                         if (!is.null(pattern)) {
[11:02:39.777]                           computeRestarts <- base::computeRestarts
[11:02:39.777]                           grepl <- base::grepl
[11:02:39.777]                           restarts <- computeRestarts(cond)
[11:02:39.777]                           for (restart in restarts) {
[11:02:39.777]                             name <- restart$name
[11:02:39.777]                             if (is.null(name)) 
[11:02:39.777]                               next
[11:02:39.777]                             if (!grepl(pattern, name)) 
[11:02:39.777]                               next
[11:02:39.777]                             invokeRestart(restart)
[11:02:39.777]                             muffled <- TRUE
[11:02:39.777]                             break
[11:02:39.777]                           }
[11:02:39.777]                         }
[11:02:39.777]                       }
[11:02:39.777]                       invisible(muffled)
[11:02:39.777]                     }
[11:02:39.777]                     muffleCondition(cond, pattern = "^muffle")
[11:02:39.777]                   }
[11:02:39.777]                 }
[11:02:39.777]                 else {
[11:02:39.777]                   if (TRUE) {
[11:02:39.777]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.777]                     {
[11:02:39.777]                       inherits <- base::inherits
[11:02:39.777]                       invokeRestart <- base::invokeRestart
[11:02:39.777]                       is.null <- base::is.null
[11:02:39.777]                       muffled <- FALSE
[11:02:39.777]                       if (inherits(cond, "message")) {
[11:02:39.777]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:39.777]                         if (muffled) 
[11:02:39.777]                           invokeRestart("muffleMessage")
[11:02:39.777]                       }
[11:02:39.777]                       else if (inherits(cond, "warning")) {
[11:02:39.777]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:39.777]                         if (muffled) 
[11:02:39.777]                           invokeRestart("muffleWarning")
[11:02:39.777]                       }
[11:02:39.777]                       else if (inherits(cond, "condition")) {
[11:02:39.777]                         if (!is.null(pattern)) {
[11:02:39.777]                           computeRestarts <- base::computeRestarts
[11:02:39.777]                           grepl <- base::grepl
[11:02:39.777]                           restarts <- computeRestarts(cond)
[11:02:39.777]                           for (restart in restarts) {
[11:02:39.777]                             name <- restart$name
[11:02:39.777]                             if (is.null(name)) 
[11:02:39.777]                               next
[11:02:39.777]                             if (!grepl(pattern, name)) 
[11:02:39.777]                               next
[11:02:39.777]                             invokeRestart(restart)
[11:02:39.777]                             muffled <- TRUE
[11:02:39.777]                             break
[11:02:39.777]                           }
[11:02:39.777]                         }
[11:02:39.777]                       }
[11:02:39.777]                       invisible(muffled)
[11:02:39.777]                     }
[11:02:39.777]                     muffleCondition(cond, pattern = "^muffle")
[11:02:39.777]                   }
[11:02:39.777]                 }
[11:02:39.777]             }
[11:02:39.777]         }))
[11:02:39.777]     }, error = function(ex) {
[11:02:39.777]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:39.777]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:39.777]                 ...future.rng), started = ...future.startTime, 
[11:02:39.777]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:39.777]             version = "1.8"), class = "FutureResult")
[11:02:39.777]     }, finally = {
[11:02:39.777]         if (!identical(...future.workdir, getwd())) 
[11:02:39.777]             setwd(...future.workdir)
[11:02:39.777]         {
[11:02:39.777]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:39.777]                 ...future.oldOptions$nwarnings <- NULL
[11:02:39.777]             }
[11:02:39.777]             base::options(...future.oldOptions)
[11:02:39.777]             if (.Platform$OS.type == "windows") {
[11:02:39.777]                 old_names <- names(...future.oldEnvVars)
[11:02:39.777]                 envs <- base::Sys.getenv()
[11:02:39.777]                 names <- names(envs)
[11:02:39.777]                 common <- intersect(names, old_names)
[11:02:39.777]                 added <- setdiff(names, old_names)
[11:02:39.777]                 removed <- setdiff(old_names, names)
[11:02:39.777]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:39.777]                   envs[common]]
[11:02:39.777]                 NAMES <- toupper(changed)
[11:02:39.777]                 args <- list()
[11:02:39.777]                 for (kk in seq_along(NAMES)) {
[11:02:39.777]                   name <- changed[[kk]]
[11:02:39.777]                   NAME <- NAMES[[kk]]
[11:02:39.777]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.777]                     next
[11:02:39.777]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:39.777]                 }
[11:02:39.777]                 NAMES <- toupper(added)
[11:02:39.777]                 for (kk in seq_along(NAMES)) {
[11:02:39.777]                   name <- added[[kk]]
[11:02:39.777]                   NAME <- NAMES[[kk]]
[11:02:39.777]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.777]                     next
[11:02:39.777]                   args[[name]] <- ""
[11:02:39.777]                 }
[11:02:39.777]                 NAMES <- toupper(removed)
[11:02:39.777]                 for (kk in seq_along(NAMES)) {
[11:02:39.777]                   name <- removed[[kk]]
[11:02:39.777]                   NAME <- NAMES[[kk]]
[11:02:39.777]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.777]                     next
[11:02:39.777]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:39.777]                 }
[11:02:39.777]                 if (length(args) > 0) 
[11:02:39.777]                   base::do.call(base::Sys.setenv, args = args)
[11:02:39.777]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:39.777]             }
[11:02:39.777]             else {
[11:02:39.777]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:39.777]             }
[11:02:39.777]             {
[11:02:39.777]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:39.777]                   0L) {
[11:02:39.777]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:39.777]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:39.777]                   base::options(opts)
[11:02:39.777]                 }
[11:02:39.777]                 {
[11:02:39.777]                   {
[11:02:39.777]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:39.777]                     NULL
[11:02:39.777]                   }
[11:02:39.777]                   options(future.plan = NULL)
[11:02:39.777]                   if (is.na(NA_character_)) 
[11:02:39.777]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:39.777]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:39.777]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:39.777]                     .init = FALSE)
[11:02:39.777]                 }
[11:02:39.777]             }
[11:02:39.777]         }
[11:02:39.777]     })
[11:02:39.777]     if (TRUE) {
[11:02:39.777]         base::sink(type = "output", split = FALSE)
[11:02:39.777]         if (TRUE) {
[11:02:39.777]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:39.777]         }
[11:02:39.777]         else {
[11:02:39.777]             ...future.result["stdout"] <- base::list(NULL)
[11:02:39.777]         }
[11:02:39.777]         base::close(...future.stdout)
[11:02:39.777]         ...future.stdout <- NULL
[11:02:39.777]     }
[11:02:39.777]     ...future.result$conditions <- ...future.conditions
[11:02:39.777]     ...future.result$finished <- base::Sys.time()
[11:02:39.777]     ...future.result
[11:02:39.777] }
[11:02:39.780] requestCore(): workers = 2
[11:02:39.781] MulticoreFuture started
[11:02:39.782] - Launch lazy future ... done
[11:02:39.782] run() for ‘MulticoreFuture’ ... done
[11:02:39.782] plan(): Setting new future strategy stack:
[11:02:39.782] getGlobalsAndPackages() ...
[11:02:39.783] Searching for globals...
[11:02:39.783] List of future strategies:
[11:02:39.783] 1. sequential:
[11:02:39.783]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:39.783]    - tweaked: FALSE
[11:02:39.783]    - call: NULL
[11:02:39.783] 
[11:02:39.784] plan(): nbrOfWorkers() = 1
[11:02:39.784] Searching for globals ... DONE
[11:02:39.784] - globals: [0] <none>
[11:02:39.784] getGlobalsAndPackages() ... DONE
[11:02:39.785] run() for ‘Future’ ...
[11:02:39.785] - state: ‘created’
[11:02:39.785] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:02:39.786] plan(): Setting new future strategy stack:
[11:02:39.786] List of future strategies:
[11:02:39.786] 1. multicore:
[11:02:39.786]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:39.786]    - tweaked: FALSE
[11:02:39.786]    - call: plan(strategy)
[11:02:39.788] plan(): nbrOfWorkers() = 2
[11:02:39.788] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:39.788] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:02:39.789]   - Field: ‘label’
[11:02:39.789]   - Field: ‘local’
[11:02:39.789]   - Field: ‘owner’
[11:02:39.789]   - Field: ‘envir’
[11:02:39.789]   - Field: ‘workers’
[11:02:39.789]   - Field: ‘packages’
[11:02:39.790]   - Field: ‘gc’
[11:02:39.790]   - Field: ‘job’
[11:02:39.790]   - Field: ‘conditions’
[11:02:39.790]   - Field: ‘expr’
[11:02:39.790]   - Field: ‘uuid’
[11:02:39.790]   - Field: ‘seed’
[11:02:39.790]   - Field: ‘version’
[11:02:39.791]   - Field: ‘result’
[11:02:39.791]   - Field: ‘asynchronous’
[11:02:39.791]   - Field: ‘calls’
[11:02:39.791]   - Field: ‘globals’
[11:02:39.791]   - Field: ‘stdout’
[11:02:39.791]   - Field: ‘earlySignal’
[11:02:39.792]   - Field: ‘lazy’
[11:02:39.792]   - Field: ‘state’
[11:02:39.792] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:02:39.792] - Launch lazy future ...
[11:02:39.792] Packages needed by the future expression (n = 0): <none>
[11:02:39.793] Packages needed by future strategies (n = 0): <none>
[11:02:39.793] {
[11:02:39.793]     {
[11:02:39.793]         {
[11:02:39.793]             ...future.startTime <- base::Sys.time()
[11:02:39.793]             {
[11:02:39.793]                 {
[11:02:39.793]                   {
[11:02:39.793]                     {
[11:02:39.793]                       base::local({
[11:02:39.793]                         has_future <- base::requireNamespace("future", 
[11:02:39.793]                           quietly = TRUE)
[11:02:39.793]                         if (has_future) {
[11:02:39.793]                           ns <- base::getNamespace("future")
[11:02:39.793]                           version <- ns[[".package"]][["version"]]
[11:02:39.793]                           if (is.null(version)) 
[11:02:39.793]                             version <- utils::packageVersion("future")
[11:02:39.793]                         }
[11:02:39.793]                         else {
[11:02:39.793]                           version <- NULL
[11:02:39.793]                         }
[11:02:39.793]                         if (!has_future || version < "1.8.0") {
[11:02:39.793]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:39.793]                             "", base::R.version$version.string), 
[11:02:39.793]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:39.793]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:39.793]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:39.793]                               "release", "version")], collapse = " "), 
[11:02:39.793]                             hostname = base::Sys.info()[["nodename"]])
[11:02:39.793]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:39.793]                             info)
[11:02:39.793]                           info <- base::paste(info, collapse = "; ")
[11:02:39.793]                           if (!has_future) {
[11:02:39.793]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:39.793]                               info)
[11:02:39.793]                           }
[11:02:39.793]                           else {
[11:02:39.793]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:39.793]                               info, version)
[11:02:39.793]                           }
[11:02:39.793]                           base::stop(msg)
[11:02:39.793]                         }
[11:02:39.793]                       })
[11:02:39.793]                     }
[11:02:39.793]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:39.793]                     base::options(mc.cores = 1L)
[11:02:39.793]                   }
[11:02:39.793]                   ...future.strategy.old <- future::plan("list")
[11:02:39.793]                   options(future.plan = NULL)
[11:02:39.793]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:39.793]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:39.793]                 }
[11:02:39.793]                 ...future.workdir <- getwd()
[11:02:39.793]             }
[11:02:39.793]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:39.793]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:39.793]         }
[11:02:39.793]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:39.793]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:39.793]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:39.793]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:39.793]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:39.793]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:39.793]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:39.793]             base::names(...future.oldOptions))
[11:02:39.793]     }
[11:02:39.793]     if (FALSE) {
[11:02:39.793]     }
[11:02:39.793]     else {
[11:02:39.793]         if (TRUE) {
[11:02:39.793]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:39.793]                 open = "w")
[11:02:39.793]         }
[11:02:39.793]         else {
[11:02:39.793]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:39.793]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:39.793]         }
[11:02:39.793]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:39.793]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:39.793]             base::sink(type = "output", split = FALSE)
[11:02:39.793]             base::close(...future.stdout)
[11:02:39.793]         }, add = TRUE)
[11:02:39.793]     }
[11:02:39.793]     ...future.frame <- base::sys.nframe()
[11:02:39.793]     ...future.conditions <- base::list()
[11:02:39.793]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:39.793]     if (FALSE) {
[11:02:39.793]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:39.793]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:39.793]     }
[11:02:39.793]     ...future.result <- base::tryCatch({
[11:02:39.793]         base::withCallingHandlers({
[11:02:39.793]             ...future.value <- base::withVisible(base::local({
[11:02:39.793]                 withCallingHandlers({
[11:02:39.793]                   2
[11:02:39.793]                 }, immediateCondition = function(cond) {
[11:02:39.793]                   save_rds <- function (object, pathname, ...) 
[11:02:39.793]                   {
[11:02:39.793]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:02:39.793]                     if (file_test("-f", pathname_tmp)) {
[11:02:39.793]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.793]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:02:39.793]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.793]                         fi_tmp[["mtime"]])
[11:02:39.793]                     }
[11:02:39.793]                     tryCatch({
[11:02:39.793]                       saveRDS(object, file = pathname_tmp, ...)
[11:02:39.793]                     }, error = function(ex) {
[11:02:39.793]                       msg <- conditionMessage(ex)
[11:02:39.793]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.793]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:02:39.793]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.793]                         fi_tmp[["mtime"]], msg)
[11:02:39.793]                       ex$message <- msg
[11:02:39.793]                       stop(ex)
[11:02:39.793]                     })
[11:02:39.793]                     stopifnot(file_test("-f", pathname_tmp))
[11:02:39.793]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:02:39.793]                     if (!res || file_test("-f", pathname_tmp)) {
[11:02:39.793]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.793]                       fi <- file.info(pathname)
[11:02:39.793]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:02:39.793]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.793]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:02:39.793]                         fi[["size"]], fi[["mtime"]])
[11:02:39.793]                       stop(msg)
[11:02:39.793]                     }
[11:02:39.793]                     invisible(pathname)
[11:02:39.793]                   }
[11:02:39.793]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:02:39.793]                     rootPath = tempdir()) 
[11:02:39.793]                   {
[11:02:39.793]                     obj <- list(time = Sys.time(), condition = cond)
[11:02:39.793]                     file <- tempfile(pattern = class(cond)[1], 
[11:02:39.793]                       tmpdir = path, fileext = ".rds")
[11:02:39.793]                     save_rds(obj, file)
[11:02:39.793]                   }
[11:02:39.793]                   saveImmediateCondition(cond, path = "/tmp/RtmpPVwpFC/.future/immediateConditions")
[11:02:39.793]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.793]                   {
[11:02:39.793]                     inherits <- base::inherits
[11:02:39.793]                     invokeRestart <- base::invokeRestart
[11:02:39.793]                     is.null <- base::is.null
[11:02:39.793]                     muffled <- FALSE
[11:02:39.793]                     if (inherits(cond, "message")) {
[11:02:39.793]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:39.793]                       if (muffled) 
[11:02:39.793]                         invokeRestart("muffleMessage")
[11:02:39.793]                     }
[11:02:39.793]                     else if (inherits(cond, "warning")) {
[11:02:39.793]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:39.793]                       if (muffled) 
[11:02:39.793]                         invokeRestart("muffleWarning")
[11:02:39.793]                     }
[11:02:39.793]                     else if (inherits(cond, "condition")) {
[11:02:39.793]                       if (!is.null(pattern)) {
[11:02:39.793]                         computeRestarts <- base::computeRestarts
[11:02:39.793]                         grepl <- base::grepl
[11:02:39.793]                         restarts <- computeRestarts(cond)
[11:02:39.793]                         for (restart in restarts) {
[11:02:39.793]                           name <- restart$name
[11:02:39.793]                           if (is.null(name)) 
[11:02:39.793]                             next
[11:02:39.793]                           if (!grepl(pattern, name)) 
[11:02:39.793]                             next
[11:02:39.793]                           invokeRestart(restart)
[11:02:39.793]                           muffled <- TRUE
[11:02:39.793]                           break
[11:02:39.793]                         }
[11:02:39.793]                       }
[11:02:39.793]                     }
[11:02:39.793]                     invisible(muffled)
[11:02:39.793]                   }
[11:02:39.793]                   muffleCondition(cond)
[11:02:39.793]                 })
[11:02:39.793]             }))
[11:02:39.793]             future::FutureResult(value = ...future.value$value, 
[11:02:39.793]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:39.793]                   ...future.rng), globalenv = if (FALSE) 
[11:02:39.793]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:39.793]                     ...future.globalenv.names))
[11:02:39.793]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:39.793]         }, condition = base::local({
[11:02:39.793]             c <- base::c
[11:02:39.793]             inherits <- base::inherits
[11:02:39.793]             invokeRestart <- base::invokeRestart
[11:02:39.793]             length <- base::length
[11:02:39.793]             list <- base::list
[11:02:39.793]             seq.int <- base::seq.int
[11:02:39.793]             signalCondition <- base::signalCondition
[11:02:39.793]             sys.calls <- base::sys.calls
[11:02:39.793]             `[[` <- base::`[[`
[11:02:39.793]             `+` <- base::`+`
[11:02:39.793]             `<<-` <- base::`<<-`
[11:02:39.793]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:39.793]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:39.793]                   3L)]
[11:02:39.793]             }
[11:02:39.793]             function(cond) {
[11:02:39.793]                 is_error <- inherits(cond, "error")
[11:02:39.793]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:39.793]                   NULL)
[11:02:39.793]                 if (is_error) {
[11:02:39.793]                   sessionInformation <- function() {
[11:02:39.793]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:39.793]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:39.793]                       search = base::search(), system = base::Sys.info())
[11:02:39.793]                   }
[11:02:39.793]                   ...future.conditions[[length(...future.conditions) + 
[11:02:39.793]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:39.793]                     cond$call), session = sessionInformation(), 
[11:02:39.793]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:39.793]                   signalCondition(cond)
[11:02:39.793]                 }
[11:02:39.793]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:39.793]                 "immediateCondition"))) {
[11:02:39.793]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:39.793]                   ...future.conditions[[length(...future.conditions) + 
[11:02:39.793]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:39.793]                   if (TRUE && !signal) {
[11:02:39.793]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.793]                     {
[11:02:39.793]                       inherits <- base::inherits
[11:02:39.793]                       invokeRestart <- base::invokeRestart
[11:02:39.793]                       is.null <- base::is.null
[11:02:39.793]                       muffled <- FALSE
[11:02:39.793]                       if (inherits(cond, "message")) {
[11:02:39.793]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:39.793]                         if (muffled) 
[11:02:39.793]                           invokeRestart("muffleMessage")
[11:02:39.793]                       }
[11:02:39.793]                       else if (inherits(cond, "warning")) {
[11:02:39.793]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:39.793]                         if (muffled) 
[11:02:39.793]                           invokeRestart("muffleWarning")
[11:02:39.793]                       }
[11:02:39.793]                       else if (inherits(cond, "condition")) {
[11:02:39.793]                         if (!is.null(pattern)) {
[11:02:39.793]                           computeRestarts <- base::computeRestarts
[11:02:39.793]                           grepl <- base::grepl
[11:02:39.793]                           restarts <- computeRestarts(cond)
[11:02:39.793]                           for (restart in restarts) {
[11:02:39.793]                             name <- restart$name
[11:02:39.793]                             if (is.null(name)) 
[11:02:39.793]                               next
[11:02:39.793]                             if (!grepl(pattern, name)) 
[11:02:39.793]                               next
[11:02:39.793]                             invokeRestart(restart)
[11:02:39.793]                             muffled <- TRUE
[11:02:39.793]                             break
[11:02:39.793]                           }
[11:02:39.793]                         }
[11:02:39.793]                       }
[11:02:39.793]                       invisible(muffled)
[11:02:39.793]                     }
[11:02:39.793]                     muffleCondition(cond, pattern = "^muffle")
[11:02:39.793]                   }
[11:02:39.793]                 }
[11:02:39.793]                 else {
[11:02:39.793]                   if (TRUE) {
[11:02:39.793]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.793]                     {
[11:02:39.793]                       inherits <- base::inherits
[11:02:39.793]                       invokeRestart <- base::invokeRestart
[11:02:39.793]                       is.null <- base::is.null
[11:02:39.793]                       muffled <- FALSE
[11:02:39.793]                       if (inherits(cond, "message")) {
[11:02:39.793]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:39.793]                         if (muffled) 
[11:02:39.793]                           invokeRestart("muffleMessage")
[11:02:39.793]                       }
[11:02:39.793]                       else if (inherits(cond, "warning")) {
[11:02:39.793]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:39.793]                         if (muffled) 
[11:02:39.793]                           invokeRestart("muffleWarning")
[11:02:39.793]                       }
[11:02:39.793]                       else if (inherits(cond, "condition")) {
[11:02:39.793]                         if (!is.null(pattern)) {
[11:02:39.793]                           computeRestarts <- base::computeRestarts
[11:02:39.793]                           grepl <- base::grepl
[11:02:39.793]                           restarts <- computeRestarts(cond)
[11:02:39.793]                           for (restart in restarts) {
[11:02:39.793]                             name <- restart$name
[11:02:39.793]                             if (is.null(name)) 
[11:02:39.793]                               next
[11:02:39.793]                             if (!grepl(pattern, name)) 
[11:02:39.793]                               next
[11:02:39.793]                             invokeRestart(restart)
[11:02:39.793]                             muffled <- TRUE
[11:02:39.793]                             break
[11:02:39.793]                           }
[11:02:39.793]                         }
[11:02:39.793]                       }
[11:02:39.793]                       invisible(muffled)
[11:02:39.793]                     }
[11:02:39.793]                     muffleCondition(cond, pattern = "^muffle")
[11:02:39.793]                   }
[11:02:39.793]                 }
[11:02:39.793]             }
[11:02:39.793]         }))
[11:02:39.793]     }, error = function(ex) {
[11:02:39.793]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:39.793]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:39.793]                 ...future.rng), started = ...future.startTime, 
[11:02:39.793]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:39.793]             version = "1.8"), class = "FutureResult")
[11:02:39.793]     }, finally = {
[11:02:39.793]         if (!identical(...future.workdir, getwd())) 
[11:02:39.793]             setwd(...future.workdir)
[11:02:39.793]         {
[11:02:39.793]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:39.793]                 ...future.oldOptions$nwarnings <- NULL
[11:02:39.793]             }
[11:02:39.793]             base::options(...future.oldOptions)
[11:02:39.793]             if (.Platform$OS.type == "windows") {
[11:02:39.793]                 old_names <- names(...future.oldEnvVars)
[11:02:39.793]                 envs <- base::Sys.getenv()
[11:02:39.793]                 names <- names(envs)
[11:02:39.793]                 common <- intersect(names, old_names)
[11:02:39.793]                 added <- setdiff(names, old_names)
[11:02:39.793]                 removed <- setdiff(old_names, names)
[11:02:39.793]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:39.793]                   envs[common]]
[11:02:39.793]                 NAMES <- toupper(changed)
[11:02:39.793]                 args <- list()
[11:02:39.793]                 for (kk in seq_along(NAMES)) {
[11:02:39.793]                   name <- changed[[kk]]
[11:02:39.793]                   NAME <- NAMES[[kk]]
[11:02:39.793]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.793]                     next
[11:02:39.793]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:39.793]                 }
[11:02:39.793]                 NAMES <- toupper(added)
[11:02:39.793]                 for (kk in seq_along(NAMES)) {
[11:02:39.793]                   name <- added[[kk]]
[11:02:39.793]                   NAME <- NAMES[[kk]]
[11:02:39.793]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.793]                     next
[11:02:39.793]                   args[[name]] <- ""
[11:02:39.793]                 }
[11:02:39.793]                 NAMES <- toupper(removed)
[11:02:39.793]                 for (kk in seq_along(NAMES)) {
[11:02:39.793]                   name <- removed[[kk]]
[11:02:39.793]                   NAME <- NAMES[[kk]]
[11:02:39.793]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.793]                     next
[11:02:39.793]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:39.793]                 }
[11:02:39.793]                 if (length(args) > 0) 
[11:02:39.793]                   base::do.call(base::Sys.setenv, args = args)
[11:02:39.793]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:39.793]             }
[11:02:39.793]             else {
[11:02:39.793]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:39.793]             }
[11:02:39.793]             {
[11:02:39.793]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:39.793]                   0L) {
[11:02:39.793]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:39.793]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:39.793]                   base::options(opts)
[11:02:39.793]                 }
[11:02:39.793]                 {
[11:02:39.793]                   {
[11:02:39.793]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:39.793]                     NULL
[11:02:39.793]                   }
[11:02:39.793]                   options(future.plan = NULL)
[11:02:39.793]                   if (is.na(NA_character_)) 
[11:02:39.793]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:39.793]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:39.793]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:39.793]                     .init = FALSE)
[11:02:39.793]                 }
[11:02:39.793]             }
[11:02:39.793]         }
[11:02:39.793]     })
[11:02:39.793]     if (TRUE) {
[11:02:39.793]         base::sink(type = "output", split = FALSE)
[11:02:39.793]         if (TRUE) {
[11:02:39.793]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:39.793]         }
[11:02:39.793]         else {
[11:02:39.793]             ...future.result["stdout"] <- base::list(NULL)
[11:02:39.793]         }
[11:02:39.793]         base::close(...future.stdout)
[11:02:39.793]         ...future.stdout <- NULL
[11:02:39.793]     }
[11:02:39.793]     ...future.result$conditions <- ...future.conditions
[11:02:39.793]     ...future.result$finished <- base::Sys.time()
[11:02:39.793]     ...future.result
[11:02:39.793] }
[11:02:39.797] requestCore(): workers = 2
[11:02:39.799] MulticoreFuture started
[11:02:39.799] - Launch lazy future ... done
[11:02:39.799] run() for ‘MulticoreFuture’ ... done
[11:02:39.800] plan(): Setting new future strategy stack:
[11:02:39.800] resolve() on list environment ...
[11:02:39.800] List of future strategies:
[11:02:39.800] 1. sequential:
[11:02:39.800]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:39.800]    - tweaked: FALSE
[11:02:39.800]    - call: NULL
[11:02:39.801]  recursive: 0
[11:02:39.801] plan(): nbrOfWorkers() = 1
[11:02:39.802]  length: 3
[11:02:39.802]  elements: ‘a’, ‘b’, ‘c’
[11:02:39.802] Future #1
[11:02:39.802]  length: 2 (resolved future 1)
[11:02:39.803] plan(): Setting new future strategy stack:
[11:02:39.803] List of future strategies:
[11:02:39.803] 1. multicore:
[11:02:39.803]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:39.803]    - tweaked: FALSE
[11:02:39.803]    - call: plan(strategy)
[11:02:39.806] plan(): nbrOfWorkers() = 2
[11:02:39.806] Future #2
[11:02:39.807]  length: 1 (resolved future 2)
[11:02:39.807]  length: 0 (resolved future 3)
[11:02:39.807] resolve() on list environment ... DONE
[11:02:39.808] getGlobalsAndPackages() ...
[11:02:39.808] Searching for globals...
[11:02:39.810] - globals found: [1] ‘{’
[11:02:39.810] Searching for globals ... DONE
[11:02:39.810] Resolving globals: FALSE
[11:02:39.810] 
[11:02:39.811] 
[11:02:39.811] getGlobalsAndPackages() ... DONE
[11:02:39.811] run() for ‘Future’ ...
[11:02:39.811] - state: ‘created’
[11:02:39.811] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:02:39.814] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:39.814] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:02:39.814]   - Field: ‘label’
[11:02:39.815]   - Field: ‘local’
[11:02:39.815]   - Field: ‘owner’
[11:02:39.815]   - Field: ‘envir’
[11:02:39.815]   - Field: ‘workers’
[11:02:39.815]   - Field: ‘packages’
[11:02:39.815]   - Field: ‘gc’
[11:02:39.815]   - Field: ‘job’
[11:02:39.816]   - Field: ‘conditions’
[11:02:39.816]   - Field: ‘expr’
[11:02:39.816]   - Field: ‘uuid’
[11:02:39.816]   - Field: ‘seed’
[11:02:39.816]   - Field: ‘version’
[11:02:39.816]   - Field: ‘result’
[11:02:39.816]   - Field: ‘asynchronous’
[11:02:39.816]   - Field: ‘calls’
[11:02:39.817]   - Field: ‘globals’
[11:02:39.817]   - Field: ‘stdout’
[11:02:39.817]   - Field: ‘earlySignal’
[11:02:39.817]   - Field: ‘lazy’
[11:02:39.817]   - Field: ‘state’
[11:02:39.817] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:02:39.817] - Launch lazy future ...
[11:02:39.818] Packages needed by the future expression (n = 0): <none>
[11:02:39.818] Packages needed by future strategies (n = 0): <none>
[11:02:39.819] {
[11:02:39.819]     {
[11:02:39.819]         {
[11:02:39.819]             ...future.startTime <- base::Sys.time()
[11:02:39.819]             {
[11:02:39.819]                 {
[11:02:39.819]                   {
[11:02:39.819]                     {
[11:02:39.819]                       base::local({
[11:02:39.819]                         has_future <- base::requireNamespace("future", 
[11:02:39.819]                           quietly = TRUE)
[11:02:39.819]                         if (has_future) {
[11:02:39.819]                           ns <- base::getNamespace("future")
[11:02:39.819]                           version <- ns[[".package"]][["version"]]
[11:02:39.819]                           if (is.null(version)) 
[11:02:39.819]                             version <- utils::packageVersion("future")
[11:02:39.819]                         }
[11:02:39.819]                         else {
[11:02:39.819]                           version <- NULL
[11:02:39.819]                         }
[11:02:39.819]                         if (!has_future || version < "1.8.0") {
[11:02:39.819]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:39.819]                             "", base::R.version$version.string), 
[11:02:39.819]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:39.819]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:39.819]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:39.819]                               "release", "version")], collapse = " "), 
[11:02:39.819]                             hostname = base::Sys.info()[["nodename"]])
[11:02:39.819]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:39.819]                             info)
[11:02:39.819]                           info <- base::paste(info, collapse = "; ")
[11:02:39.819]                           if (!has_future) {
[11:02:39.819]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:39.819]                               info)
[11:02:39.819]                           }
[11:02:39.819]                           else {
[11:02:39.819]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:39.819]                               info, version)
[11:02:39.819]                           }
[11:02:39.819]                           base::stop(msg)
[11:02:39.819]                         }
[11:02:39.819]                       })
[11:02:39.819]                     }
[11:02:39.819]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:39.819]                     base::options(mc.cores = 1L)
[11:02:39.819]                   }
[11:02:39.819]                   ...future.strategy.old <- future::plan("list")
[11:02:39.819]                   options(future.plan = NULL)
[11:02:39.819]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:39.819]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:39.819]                 }
[11:02:39.819]                 ...future.workdir <- getwd()
[11:02:39.819]             }
[11:02:39.819]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:39.819]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:39.819]         }
[11:02:39.819]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:39.819]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:39.819]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:39.819]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:39.819]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:39.819]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:39.819]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:39.819]             base::names(...future.oldOptions))
[11:02:39.819]     }
[11:02:39.819]     if (FALSE) {
[11:02:39.819]     }
[11:02:39.819]     else {
[11:02:39.819]         if (TRUE) {
[11:02:39.819]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:39.819]                 open = "w")
[11:02:39.819]         }
[11:02:39.819]         else {
[11:02:39.819]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:39.819]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:39.819]         }
[11:02:39.819]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:39.819]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:39.819]             base::sink(type = "output", split = FALSE)
[11:02:39.819]             base::close(...future.stdout)
[11:02:39.819]         }, add = TRUE)
[11:02:39.819]     }
[11:02:39.819]     ...future.frame <- base::sys.nframe()
[11:02:39.819]     ...future.conditions <- base::list()
[11:02:39.819]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:39.819]     if (FALSE) {
[11:02:39.819]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:39.819]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:39.819]     }
[11:02:39.819]     ...future.result <- base::tryCatch({
[11:02:39.819]         base::withCallingHandlers({
[11:02:39.819]             ...future.value <- base::withVisible(base::local({
[11:02:39.819]                 withCallingHandlers({
[11:02:39.819]                   {
[11:02:39.819]                     1
[11:02:39.819]                   }
[11:02:39.819]                 }, immediateCondition = function(cond) {
[11:02:39.819]                   save_rds <- function (object, pathname, ...) 
[11:02:39.819]                   {
[11:02:39.819]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:02:39.819]                     if (file_test("-f", pathname_tmp)) {
[11:02:39.819]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.819]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:02:39.819]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.819]                         fi_tmp[["mtime"]])
[11:02:39.819]                     }
[11:02:39.819]                     tryCatch({
[11:02:39.819]                       saveRDS(object, file = pathname_tmp, ...)
[11:02:39.819]                     }, error = function(ex) {
[11:02:39.819]                       msg <- conditionMessage(ex)
[11:02:39.819]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.819]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:02:39.819]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.819]                         fi_tmp[["mtime"]], msg)
[11:02:39.819]                       ex$message <- msg
[11:02:39.819]                       stop(ex)
[11:02:39.819]                     })
[11:02:39.819]                     stopifnot(file_test("-f", pathname_tmp))
[11:02:39.819]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:02:39.819]                     if (!res || file_test("-f", pathname_tmp)) {
[11:02:39.819]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.819]                       fi <- file.info(pathname)
[11:02:39.819]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:02:39.819]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.819]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:02:39.819]                         fi[["size"]], fi[["mtime"]])
[11:02:39.819]                       stop(msg)
[11:02:39.819]                     }
[11:02:39.819]                     invisible(pathname)
[11:02:39.819]                   }
[11:02:39.819]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:02:39.819]                     rootPath = tempdir()) 
[11:02:39.819]                   {
[11:02:39.819]                     obj <- list(time = Sys.time(), condition = cond)
[11:02:39.819]                     file <- tempfile(pattern = class(cond)[1], 
[11:02:39.819]                       tmpdir = path, fileext = ".rds")
[11:02:39.819]                     save_rds(obj, file)
[11:02:39.819]                   }
[11:02:39.819]                   saveImmediateCondition(cond, path = "/tmp/RtmpPVwpFC/.future/immediateConditions")
[11:02:39.819]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.819]                   {
[11:02:39.819]                     inherits <- base::inherits
[11:02:39.819]                     invokeRestart <- base::invokeRestart
[11:02:39.819]                     is.null <- base::is.null
[11:02:39.819]                     muffled <- FALSE
[11:02:39.819]                     if (inherits(cond, "message")) {
[11:02:39.819]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:39.819]                       if (muffled) 
[11:02:39.819]                         invokeRestart("muffleMessage")
[11:02:39.819]                     }
[11:02:39.819]                     else if (inherits(cond, "warning")) {
[11:02:39.819]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:39.819]                       if (muffled) 
[11:02:39.819]                         invokeRestart("muffleWarning")
[11:02:39.819]                     }
[11:02:39.819]                     else if (inherits(cond, "condition")) {
[11:02:39.819]                       if (!is.null(pattern)) {
[11:02:39.819]                         computeRestarts <- base::computeRestarts
[11:02:39.819]                         grepl <- base::grepl
[11:02:39.819]                         restarts <- computeRestarts(cond)
[11:02:39.819]                         for (restart in restarts) {
[11:02:39.819]                           name <- restart$name
[11:02:39.819]                           if (is.null(name)) 
[11:02:39.819]                             next
[11:02:39.819]                           if (!grepl(pattern, name)) 
[11:02:39.819]                             next
[11:02:39.819]                           invokeRestart(restart)
[11:02:39.819]                           muffled <- TRUE
[11:02:39.819]                           break
[11:02:39.819]                         }
[11:02:39.819]                       }
[11:02:39.819]                     }
[11:02:39.819]                     invisible(muffled)
[11:02:39.819]                   }
[11:02:39.819]                   muffleCondition(cond)
[11:02:39.819]                 })
[11:02:39.819]             }))
[11:02:39.819]             future::FutureResult(value = ...future.value$value, 
[11:02:39.819]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:39.819]                   ...future.rng), globalenv = if (FALSE) 
[11:02:39.819]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:39.819]                     ...future.globalenv.names))
[11:02:39.819]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:39.819]         }, condition = base::local({
[11:02:39.819]             c <- base::c
[11:02:39.819]             inherits <- base::inherits
[11:02:39.819]             invokeRestart <- base::invokeRestart
[11:02:39.819]             length <- base::length
[11:02:39.819]             list <- base::list
[11:02:39.819]             seq.int <- base::seq.int
[11:02:39.819]             signalCondition <- base::signalCondition
[11:02:39.819]             sys.calls <- base::sys.calls
[11:02:39.819]             `[[` <- base::`[[`
[11:02:39.819]             `+` <- base::`+`
[11:02:39.819]             `<<-` <- base::`<<-`
[11:02:39.819]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:39.819]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:39.819]                   3L)]
[11:02:39.819]             }
[11:02:39.819]             function(cond) {
[11:02:39.819]                 is_error <- inherits(cond, "error")
[11:02:39.819]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:39.819]                   NULL)
[11:02:39.819]                 if (is_error) {
[11:02:39.819]                   sessionInformation <- function() {
[11:02:39.819]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:39.819]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:39.819]                       search = base::search(), system = base::Sys.info())
[11:02:39.819]                   }
[11:02:39.819]                   ...future.conditions[[length(...future.conditions) + 
[11:02:39.819]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:39.819]                     cond$call), session = sessionInformation(), 
[11:02:39.819]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:39.819]                   signalCondition(cond)
[11:02:39.819]                 }
[11:02:39.819]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:39.819]                 "immediateCondition"))) {
[11:02:39.819]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:39.819]                   ...future.conditions[[length(...future.conditions) + 
[11:02:39.819]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:39.819]                   if (TRUE && !signal) {
[11:02:39.819]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.819]                     {
[11:02:39.819]                       inherits <- base::inherits
[11:02:39.819]                       invokeRestart <- base::invokeRestart
[11:02:39.819]                       is.null <- base::is.null
[11:02:39.819]                       muffled <- FALSE
[11:02:39.819]                       if (inherits(cond, "message")) {
[11:02:39.819]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:39.819]                         if (muffled) 
[11:02:39.819]                           invokeRestart("muffleMessage")
[11:02:39.819]                       }
[11:02:39.819]                       else if (inherits(cond, "warning")) {
[11:02:39.819]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:39.819]                         if (muffled) 
[11:02:39.819]                           invokeRestart("muffleWarning")
[11:02:39.819]                       }
[11:02:39.819]                       else if (inherits(cond, "condition")) {
[11:02:39.819]                         if (!is.null(pattern)) {
[11:02:39.819]                           computeRestarts <- base::computeRestarts
[11:02:39.819]                           grepl <- base::grepl
[11:02:39.819]                           restarts <- computeRestarts(cond)
[11:02:39.819]                           for (restart in restarts) {
[11:02:39.819]                             name <- restart$name
[11:02:39.819]                             if (is.null(name)) 
[11:02:39.819]                               next
[11:02:39.819]                             if (!grepl(pattern, name)) 
[11:02:39.819]                               next
[11:02:39.819]                             invokeRestart(restart)
[11:02:39.819]                             muffled <- TRUE
[11:02:39.819]                             break
[11:02:39.819]                           }
[11:02:39.819]                         }
[11:02:39.819]                       }
[11:02:39.819]                       invisible(muffled)
[11:02:39.819]                     }
[11:02:39.819]                     muffleCondition(cond, pattern = "^muffle")
[11:02:39.819]                   }
[11:02:39.819]                 }
[11:02:39.819]                 else {
[11:02:39.819]                   if (TRUE) {
[11:02:39.819]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.819]                     {
[11:02:39.819]                       inherits <- base::inherits
[11:02:39.819]                       invokeRestart <- base::invokeRestart
[11:02:39.819]                       is.null <- base::is.null
[11:02:39.819]                       muffled <- FALSE
[11:02:39.819]                       if (inherits(cond, "message")) {
[11:02:39.819]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:39.819]                         if (muffled) 
[11:02:39.819]                           invokeRestart("muffleMessage")
[11:02:39.819]                       }
[11:02:39.819]                       else if (inherits(cond, "warning")) {
[11:02:39.819]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:39.819]                         if (muffled) 
[11:02:39.819]                           invokeRestart("muffleWarning")
[11:02:39.819]                       }
[11:02:39.819]                       else if (inherits(cond, "condition")) {
[11:02:39.819]                         if (!is.null(pattern)) {
[11:02:39.819]                           computeRestarts <- base::computeRestarts
[11:02:39.819]                           grepl <- base::grepl
[11:02:39.819]                           restarts <- computeRestarts(cond)
[11:02:39.819]                           for (restart in restarts) {
[11:02:39.819]                             name <- restart$name
[11:02:39.819]                             if (is.null(name)) 
[11:02:39.819]                               next
[11:02:39.819]                             if (!grepl(pattern, name)) 
[11:02:39.819]                               next
[11:02:39.819]                             invokeRestart(restart)
[11:02:39.819]                             muffled <- TRUE
[11:02:39.819]                             break
[11:02:39.819]                           }
[11:02:39.819]                         }
[11:02:39.819]                       }
[11:02:39.819]                       invisible(muffled)
[11:02:39.819]                     }
[11:02:39.819]                     muffleCondition(cond, pattern = "^muffle")
[11:02:39.819]                   }
[11:02:39.819]                 }
[11:02:39.819]             }
[11:02:39.819]         }))
[11:02:39.819]     }, error = function(ex) {
[11:02:39.819]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:39.819]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:39.819]                 ...future.rng), started = ...future.startTime, 
[11:02:39.819]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:39.819]             version = "1.8"), class = "FutureResult")
[11:02:39.819]     }, finally = {
[11:02:39.819]         if (!identical(...future.workdir, getwd())) 
[11:02:39.819]             setwd(...future.workdir)
[11:02:39.819]         {
[11:02:39.819]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:39.819]                 ...future.oldOptions$nwarnings <- NULL
[11:02:39.819]             }
[11:02:39.819]             base::options(...future.oldOptions)
[11:02:39.819]             if (.Platform$OS.type == "windows") {
[11:02:39.819]                 old_names <- names(...future.oldEnvVars)
[11:02:39.819]                 envs <- base::Sys.getenv()
[11:02:39.819]                 names <- names(envs)
[11:02:39.819]                 common <- intersect(names, old_names)
[11:02:39.819]                 added <- setdiff(names, old_names)
[11:02:39.819]                 removed <- setdiff(old_names, names)
[11:02:39.819]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:39.819]                   envs[common]]
[11:02:39.819]                 NAMES <- toupper(changed)
[11:02:39.819]                 args <- list()
[11:02:39.819]                 for (kk in seq_along(NAMES)) {
[11:02:39.819]                   name <- changed[[kk]]
[11:02:39.819]                   NAME <- NAMES[[kk]]
[11:02:39.819]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.819]                     next
[11:02:39.819]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:39.819]                 }
[11:02:39.819]                 NAMES <- toupper(added)
[11:02:39.819]                 for (kk in seq_along(NAMES)) {
[11:02:39.819]                   name <- added[[kk]]
[11:02:39.819]                   NAME <- NAMES[[kk]]
[11:02:39.819]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.819]                     next
[11:02:39.819]                   args[[name]] <- ""
[11:02:39.819]                 }
[11:02:39.819]                 NAMES <- toupper(removed)
[11:02:39.819]                 for (kk in seq_along(NAMES)) {
[11:02:39.819]                   name <- removed[[kk]]
[11:02:39.819]                   NAME <- NAMES[[kk]]
[11:02:39.819]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.819]                     next
[11:02:39.819]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:39.819]                 }
[11:02:39.819]                 if (length(args) > 0) 
[11:02:39.819]                   base::do.call(base::Sys.setenv, args = args)
[11:02:39.819]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:39.819]             }
[11:02:39.819]             else {
[11:02:39.819]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:39.819]             }
[11:02:39.819]             {
[11:02:39.819]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:39.819]                   0L) {
[11:02:39.819]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:39.819]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:39.819]                   base::options(opts)
[11:02:39.819]                 }
[11:02:39.819]                 {
[11:02:39.819]                   {
[11:02:39.819]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:39.819]                     NULL
[11:02:39.819]                   }
[11:02:39.819]                   options(future.plan = NULL)
[11:02:39.819]                   if (is.na(NA_character_)) 
[11:02:39.819]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:39.819]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:39.819]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:39.819]                     .init = FALSE)
[11:02:39.819]                 }
[11:02:39.819]             }
[11:02:39.819]         }
[11:02:39.819]     })
[11:02:39.819]     if (TRUE) {
[11:02:39.819]         base::sink(type = "output", split = FALSE)
[11:02:39.819]         if (TRUE) {
[11:02:39.819]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:39.819]         }
[11:02:39.819]         else {
[11:02:39.819]             ...future.result["stdout"] <- base::list(NULL)
[11:02:39.819]         }
[11:02:39.819]         base::close(...future.stdout)
[11:02:39.819]         ...future.stdout <- NULL
[11:02:39.819]     }
[11:02:39.819]     ...future.result$conditions <- ...future.conditions
[11:02:39.819]     ...future.result$finished <- base::Sys.time()
[11:02:39.819]     ...future.result
[11:02:39.819] }
[11:02:39.822] requestCore(): workers = 2
[11:02:39.822] Poll #1 (0): usedCores() = 2, workers = 2
[11:02:39.833] result() for MulticoreFuture ...
[11:02:39.834] result() for MulticoreFuture ...
[11:02:39.834] result() for MulticoreFuture ... done
[11:02:39.834] result() for MulticoreFuture ... done
[11:02:39.834] result() for MulticoreFuture ...
[11:02:39.834] result() for MulticoreFuture ... done
[11:02:39.837] MulticoreFuture started
[11:02:39.837] - Launch lazy future ... done
[11:02:39.837] run() for ‘MulticoreFuture’ ... done
[11:02:39.838] plan(): Setting new future strategy stack:
[11:02:39.845] getGlobalsAndPackages() ...
[11:02:39.838] List of future strategies:
[11:02:39.838] 1. sequential:
[11:02:39.838]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:39.838]    - tweaked: FALSE
[11:02:39.838]    - call: NULL
[11:02:39.846] Searching for globals...
[11:02:39.846] plan(): nbrOfWorkers() = 1
[11:02:39.849] plan(): Setting new future strategy stack:
[11:02:39.849] - globals found: [1] ‘{’
[11:02:39.850] Searching for globals ... DONE
[11:02:39.851] Resolving globals: FALSE
[11:02:39.850] List of future strategies:
[11:02:39.850] 1. multicore:
[11:02:39.850]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:39.850]    - tweaked: FALSE
[11:02:39.850]    - call: plan(strategy)
[11:02:39.852] 
[11:02:39.852] 
[11:02:39.852] getGlobalsAndPackages() ... DONE
[11:02:39.853] run() for ‘Future’ ...
[11:02:39.853] - state: ‘created’
[11:02:39.853] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:02:39.854] plan(): nbrOfWorkers() = 2
[11:02:39.857] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:39.857] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:02:39.857]   - Field: ‘label’
[11:02:39.857]   - Field: ‘local’
[11:02:39.858]   - Field: ‘owner’
[11:02:39.858]   - Field: ‘envir’
[11:02:39.858]   - Field: ‘workers’
[11:02:39.858]   - Field: ‘packages’
[11:02:39.858]   - Field: ‘gc’
[11:02:39.859]   - Field: ‘job’
[11:02:39.859]   - Field: ‘conditions’
[11:02:39.859]   - Field: ‘expr’
[11:02:39.859]   - Field: ‘uuid’
[11:02:39.859]   - Field: ‘seed’
[11:02:39.859]   - Field: ‘version’
[11:02:39.860]   - Field: ‘result’
[11:02:39.860]   - Field: ‘asynchronous’
[11:02:39.860]   - Field: ‘calls’
[11:02:39.860]   - Field: ‘globals’
[11:02:39.860]   - Field: ‘stdout’
[11:02:39.860]   - Field: ‘earlySignal’
[11:02:39.860]   - Field: ‘lazy’
[11:02:39.861]   - Field: ‘state’
[11:02:39.861] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:02:39.861] - Launch lazy future ...
[11:02:39.862] Packages needed by the future expression (n = 0): <none>
[11:02:39.862] Packages needed by future strategies (n = 0): <none>
[11:02:39.863] {
[11:02:39.863]     {
[11:02:39.863]         {
[11:02:39.863]             ...future.startTime <- base::Sys.time()
[11:02:39.863]             {
[11:02:39.863]                 {
[11:02:39.863]                   {
[11:02:39.863]                     {
[11:02:39.863]                       base::local({
[11:02:39.863]                         has_future <- base::requireNamespace("future", 
[11:02:39.863]                           quietly = TRUE)
[11:02:39.863]                         if (has_future) {
[11:02:39.863]                           ns <- base::getNamespace("future")
[11:02:39.863]                           version <- ns[[".package"]][["version"]]
[11:02:39.863]                           if (is.null(version)) 
[11:02:39.863]                             version <- utils::packageVersion("future")
[11:02:39.863]                         }
[11:02:39.863]                         else {
[11:02:39.863]                           version <- NULL
[11:02:39.863]                         }
[11:02:39.863]                         if (!has_future || version < "1.8.0") {
[11:02:39.863]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:39.863]                             "", base::R.version$version.string), 
[11:02:39.863]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:39.863]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:39.863]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:39.863]                               "release", "version")], collapse = " "), 
[11:02:39.863]                             hostname = base::Sys.info()[["nodename"]])
[11:02:39.863]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:39.863]                             info)
[11:02:39.863]                           info <- base::paste(info, collapse = "; ")
[11:02:39.863]                           if (!has_future) {
[11:02:39.863]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:39.863]                               info)
[11:02:39.863]                           }
[11:02:39.863]                           else {
[11:02:39.863]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:39.863]                               info, version)
[11:02:39.863]                           }
[11:02:39.863]                           base::stop(msg)
[11:02:39.863]                         }
[11:02:39.863]                       })
[11:02:39.863]                     }
[11:02:39.863]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:39.863]                     base::options(mc.cores = 1L)
[11:02:39.863]                   }
[11:02:39.863]                   ...future.strategy.old <- future::plan("list")
[11:02:39.863]                   options(future.plan = NULL)
[11:02:39.863]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:39.863]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:39.863]                 }
[11:02:39.863]                 ...future.workdir <- getwd()
[11:02:39.863]             }
[11:02:39.863]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:39.863]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:39.863]         }
[11:02:39.863]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:39.863]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:39.863]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:39.863]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:39.863]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:39.863]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:39.863]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:39.863]             base::names(...future.oldOptions))
[11:02:39.863]     }
[11:02:39.863]     if (FALSE) {
[11:02:39.863]     }
[11:02:39.863]     else {
[11:02:39.863]         if (TRUE) {
[11:02:39.863]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:39.863]                 open = "w")
[11:02:39.863]         }
[11:02:39.863]         else {
[11:02:39.863]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:39.863]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:39.863]         }
[11:02:39.863]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:39.863]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:39.863]             base::sink(type = "output", split = FALSE)
[11:02:39.863]             base::close(...future.stdout)
[11:02:39.863]         }, add = TRUE)
[11:02:39.863]     }
[11:02:39.863]     ...future.frame <- base::sys.nframe()
[11:02:39.863]     ...future.conditions <- base::list()
[11:02:39.863]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:39.863]     if (FALSE) {
[11:02:39.863]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:39.863]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:39.863]     }
[11:02:39.863]     ...future.result <- base::tryCatch({
[11:02:39.863]         base::withCallingHandlers({
[11:02:39.863]             ...future.value <- base::withVisible(base::local({
[11:02:39.863]                 withCallingHandlers({
[11:02:39.863]                   {
[11:02:39.863]                     2
[11:02:39.863]                   }
[11:02:39.863]                 }, immediateCondition = function(cond) {
[11:02:39.863]                   save_rds <- function (object, pathname, ...) 
[11:02:39.863]                   {
[11:02:39.863]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:02:39.863]                     if (file_test("-f", pathname_tmp)) {
[11:02:39.863]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.863]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:02:39.863]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.863]                         fi_tmp[["mtime"]])
[11:02:39.863]                     }
[11:02:39.863]                     tryCatch({
[11:02:39.863]                       saveRDS(object, file = pathname_tmp, ...)
[11:02:39.863]                     }, error = function(ex) {
[11:02:39.863]                       msg <- conditionMessage(ex)
[11:02:39.863]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.863]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:02:39.863]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.863]                         fi_tmp[["mtime"]], msg)
[11:02:39.863]                       ex$message <- msg
[11:02:39.863]                       stop(ex)
[11:02:39.863]                     })
[11:02:39.863]                     stopifnot(file_test("-f", pathname_tmp))
[11:02:39.863]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:02:39.863]                     if (!res || file_test("-f", pathname_tmp)) {
[11:02:39.863]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.863]                       fi <- file.info(pathname)
[11:02:39.863]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:02:39.863]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.863]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:02:39.863]                         fi[["size"]], fi[["mtime"]])
[11:02:39.863]                       stop(msg)
[11:02:39.863]                     }
[11:02:39.863]                     invisible(pathname)
[11:02:39.863]                   }
[11:02:39.863]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:02:39.863]                     rootPath = tempdir()) 
[11:02:39.863]                   {
[11:02:39.863]                     obj <- list(time = Sys.time(), condition = cond)
[11:02:39.863]                     file <- tempfile(pattern = class(cond)[1], 
[11:02:39.863]                       tmpdir = path, fileext = ".rds")
[11:02:39.863]                     save_rds(obj, file)
[11:02:39.863]                   }
[11:02:39.863]                   saveImmediateCondition(cond, path = "/tmp/RtmpPVwpFC/.future/immediateConditions")
[11:02:39.863]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.863]                   {
[11:02:39.863]                     inherits <- base::inherits
[11:02:39.863]                     invokeRestart <- base::invokeRestart
[11:02:39.863]                     is.null <- base::is.null
[11:02:39.863]                     muffled <- FALSE
[11:02:39.863]                     if (inherits(cond, "message")) {
[11:02:39.863]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:39.863]                       if (muffled) 
[11:02:39.863]                         invokeRestart("muffleMessage")
[11:02:39.863]                     }
[11:02:39.863]                     else if (inherits(cond, "warning")) {
[11:02:39.863]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:39.863]                       if (muffled) 
[11:02:39.863]                         invokeRestart("muffleWarning")
[11:02:39.863]                     }
[11:02:39.863]                     else if (inherits(cond, "condition")) {
[11:02:39.863]                       if (!is.null(pattern)) {
[11:02:39.863]                         computeRestarts <- base::computeRestarts
[11:02:39.863]                         grepl <- base::grepl
[11:02:39.863]                         restarts <- computeRestarts(cond)
[11:02:39.863]                         for (restart in restarts) {
[11:02:39.863]                           name <- restart$name
[11:02:39.863]                           if (is.null(name)) 
[11:02:39.863]                             next
[11:02:39.863]                           if (!grepl(pattern, name)) 
[11:02:39.863]                             next
[11:02:39.863]                           invokeRestart(restart)
[11:02:39.863]                           muffled <- TRUE
[11:02:39.863]                           break
[11:02:39.863]                         }
[11:02:39.863]                       }
[11:02:39.863]                     }
[11:02:39.863]                     invisible(muffled)
[11:02:39.863]                   }
[11:02:39.863]                   muffleCondition(cond)
[11:02:39.863]                 })
[11:02:39.863]             }))
[11:02:39.863]             future::FutureResult(value = ...future.value$value, 
[11:02:39.863]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:39.863]                   ...future.rng), globalenv = if (FALSE) 
[11:02:39.863]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:39.863]                     ...future.globalenv.names))
[11:02:39.863]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:39.863]         }, condition = base::local({
[11:02:39.863]             c <- base::c
[11:02:39.863]             inherits <- base::inherits
[11:02:39.863]             invokeRestart <- base::invokeRestart
[11:02:39.863]             length <- base::length
[11:02:39.863]             list <- base::list
[11:02:39.863]             seq.int <- base::seq.int
[11:02:39.863]             signalCondition <- base::signalCondition
[11:02:39.863]             sys.calls <- base::sys.calls
[11:02:39.863]             `[[` <- base::`[[`
[11:02:39.863]             `+` <- base::`+`
[11:02:39.863]             `<<-` <- base::`<<-`
[11:02:39.863]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:39.863]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:39.863]                   3L)]
[11:02:39.863]             }
[11:02:39.863]             function(cond) {
[11:02:39.863]                 is_error <- inherits(cond, "error")
[11:02:39.863]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:39.863]                   NULL)
[11:02:39.863]                 if (is_error) {
[11:02:39.863]                   sessionInformation <- function() {
[11:02:39.863]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:39.863]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:39.863]                       search = base::search(), system = base::Sys.info())
[11:02:39.863]                   }
[11:02:39.863]                   ...future.conditions[[length(...future.conditions) + 
[11:02:39.863]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:39.863]                     cond$call), session = sessionInformation(), 
[11:02:39.863]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:39.863]                   signalCondition(cond)
[11:02:39.863]                 }
[11:02:39.863]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:39.863]                 "immediateCondition"))) {
[11:02:39.863]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:39.863]                   ...future.conditions[[length(...future.conditions) + 
[11:02:39.863]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:39.863]                   if (TRUE && !signal) {
[11:02:39.863]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.863]                     {
[11:02:39.863]                       inherits <- base::inherits
[11:02:39.863]                       invokeRestart <- base::invokeRestart
[11:02:39.863]                       is.null <- base::is.null
[11:02:39.863]                       muffled <- FALSE
[11:02:39.863]                       if (inherits(cond, "message")) {
[11:02:39.863]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:39.863]                         if (muffled) 
[11:02:39.863]                           invokeRestart("muffleMessage")
[11:02:39.863]                       }
[11:02:39.863]                       else if (inherits(cond, "warning")) {
[11:02:39.863]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:39.863]                         if (muffled) 
[11:02:39.863]                           invokeRestart("muffleWarning")
[11:02:39.863]                       }
[11:02:39.863]                       else if (inherits(cond, "condition")) {
[11:02:39.863]                         if (!is.null(pattern)) {
[11:02:39.863]                           computeRestarts <- base::computeRestarts
[11:02:39.863]                           grepl <- base::grepl
[11:02:39.863]                           restarts <- computeRestarts(cond)
[11:02:39.863]                           for (restart in restarts) {
[11:02:39.863]                             name <- restart$name
[11:02:39.863]                             if (is.null(name)) 
[11:02:39.863]                               next
[11:02:39.863]                             if (!grepl(pattern, name)) 
[11:02:39.863]                               next
[11:02:39.863]                             invokeRestart(restart)
[11:02:39.863]                             muffled <- TRUE
[11:02:39.863]                             break
[11:02:39.863]                           }
[11:02:39.863]                         }
[11:02:39.863]                       }
[11:02:39.863]                       invisible(muffled)
[11:02:39.863]                     }
[11:02:39.863]                     muffleCondition(cond, pattern = "^muffle")
[11:02:39.863]                   }
[11:02:39.863]                 }
[11:02:39.863]                 else {
[11:02:39.863]                   if (TRUE) {
[11:02:39.863]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.863]                     {
[11:02:39.863]                       inherits <- base::inherits
[11:02:39.863]                       invokeRestart <- base::invokeRestart
[11:02:39.863]                       is.null <- base::is.null
[11:02:39.863]                       muffled <- FALSE
[11:02:39.863]                       if (inherits(cond, "message")) {
[11:02:39.863]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:39.863]                         if (muffled) 
[11:02:39.863]                           invokeRestart("muffleMessage")
[11:02:39.863]                       }
[11:02:39.863]                       else if (inherits(cond, "warning")) {
[11:02:39.863]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:39.863]                         if (muffled) 
[11:02:39.863]                           invokeRestart("muffleWarning")
[11:02:39.863]                       }
[11:02:39.863]                       else if (inherits(cond, "condition")) {
[11:02:39.863]                         if (!is.null(pattern)) {
[11:02:39.863]                           computeRestarts <- base::computeRestarts
[11:02:39.863]                           grepl <- base::grepl
[11:02:39.863]                           restarts <- computeRestarts(cond)
[11:02:39.863]                           for (restart in restarts) {
[11:02:39.863]                             name <- restart$name
[11:02:39.863]                             if (is.null(name)) 
[11:02:39.863]                               next
[11:02:39.863]                             if (!grepl(pattern, name)) 
[11:02:39.863]                               next
[11:02:39.863]                             invokeRestart(restart)
[11:02:39.863]                             muffled <- TRUE
[11:02:39.863]                             break
[11:02:39.863]                           }
[11:02:39.863]                         }
[11:02:39.863]                       }
[11:02:39.863]                       invisible(muffled)
[11:02:39.863]                     }
[11:02:39.863]                     muffleCondition(cond, pattern = "^muffle")
[11:02:39.863]                   }
[11:02:39.863]                 }
[11:02:39.863]             }
[11:02:39.863]         }))
[11:02:39.863]     }, error = function(ex) {
[11:02:39.863]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:39.863]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:39.863]                 ...future.rng), started = ...future.startTime, 
[11:02:39.863]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:39.863]             version = "1.8"), class = "FutureResult")
[11:02:39.863]     }, finally = {
[11:02:39.863]         if (!identical(...future.workdir, getwd())) 
[11:02:39.863]             setwd(...future.workdir)
[11:02:39.863]         {
[11:02:39.863]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:39.863]                 ...future.oldOptions$nwarnings <- NULL
[11:02:39.863]             }
[11:02:39.863]             base::options(...future.oldOptions)
[11:02:39.863]             if (.Platform$OS.type == "windows") {
[11:02:39.863]                 old_names <- names(...future.oldEnvVars)
[11:02:39.863]                 envs <- base::Sys.getenv()
[11:02:39.863]                 names <- names(envs)
[11:02:39.863]                 common <- intersect(names, old_names)
[11:02:39.863]                 added <- setdiff(names, old_names)
[11:02:39.863]                 removed <- setdiff(old_names, names)
[11:02:39.863]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:39.863]                   envs[common]]
[11:02:39.863]                 NAMES <- toupper(changed)
[11:02:39.863]                 args <- list()
[11:02:39.863]                 for (kk in seq_along(NAMES)) {
[11:02:39.863]                   name <- changed[[kk]]
[11:02:39.863]                   NAME <- NAMES[[kk]]
[11:02:39.863]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.863]                     next
[11:02:39.863]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:39.863]                 }
[11:02:39.863]                 NAMES <- toupper(added)
[11:02:39.863]                 for (kk in seq_along(NAMES)) {
[11:02:39.863]                   name <- added[[kk]]
[11:02:39.863]                   NAME <- NAMES[[kk]]
[11:02:39.863]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.863]                     next
[11:02:39.863]                   args[[name]] <- ""
[11:02:39.863]                 }
[11:02:39.863]                 NAMES <- toupper(removed)
[11:02:39.863]                 for (kk in seq_along(NAMES)) {
[11:02:39.863]                   name <- removed[[kk]]
[11:02:39.863]                   NAME <- NAMES[[kk]]
[11:02:39.863]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.863]                     next
[11:02:39.863]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:39.863]                 }
[11:02:39.863]                 if (length(args) > 0) 
[11:02:39.863]                   base::do.call(base::Sys.setenv, args = args)
[11:02:39.863]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:39.863]             }
[11:02:39.863]             else {
[11:02:39.863]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:39.863]             }
[11:02:39.863]             {
[11:02:39.863]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:39.863]                   0L) {
[11:02:39.863]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:39.863]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:39.863]                   base::options(opts)
[11:02:39.863]                 }
[11:02:39.863]                 {
[11:02:39.863]                   {
[11:02:39.863]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:39.863]                     NULL
[11:02:39.863]                   }
[11:02:39.863]                   options(future.plan = NULL)
[11:02:39.863]                   if (is.na(NA_character_)) 
[11:02:39.863]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:39.863]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:39.863]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:39.863]                     .init = FALSE)
[11:02:39.863]                 }
[11:02:39.863]             }
[11:02:39.863]         }
[11:02:39.863]     })
[11:02:39.863]     if (TRUE) {
[11:02:39.863]         base::sink(type = "output", split = FALSE)
[11:02:39.863]         if (TRUE) {
[11:02:39.863]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:39.863]         }
[11:02:39.863]         else {
[11:02:39.863]             ...future.result["stdout"] <- base::list(NULL)
[11:02:39.863]         }
[11:02:39.863]         base::close(...future.stdout)
[11:02:39.863]         ...future.stdout <- NULL
[11:02:39.863]     }
[11:02:39.863]     ...future.result$conditions <- ...future.conditions
[11:02:39.863]     ...future.result$finished <- base::Sys.time()
[11:02:39.863]     ...future.result
[11:02:39.863] }
[11:02:39.865] requestCore(): workers = 2
[11:02:39.866] Poll #1 (0): usedCores() = 2, workers = 2
[11:02:39.877] result() for MulticoreFuture ...
[11:02:39.877] result() for MulticoreFuture ...
[11:02:39.878] result() for MulticoreFuture ... done
[11:02:39.878] result() for MulticoreFuture ... done
[11:02:39.878] result() for MulticoreFuture ...
[11:02:39.878] result() for MulticoreFuture ... done
[11:02:39.880] MulticoreFuture started
[11:02:39.881] - Launch lazy future ... done
[11:02:39.881] run() for ‘MulticoreFuture’ ... done
[11:02:39.881] plan(): Setting new future strategy stack:
[11:02:39.882] List of future strategies:
[11:02:39.882] 1. sequential:
[11:02:39.882]    - args: function (..., envir = parent.[11:02:39.883] resolve() on list environment ...
frame(), workers = "<NULL>")
[11:02:39.882]    - tweaked: FALSE
[11:02:39.882]    - call: NULL
[11:02:39.883]  recursive: 0
[11:02:39.883] plan(): nbrOfWorkers() = 1
[11:02:39.884]  length: 3
[11:02:39.885]  elements: ‘a’, ‘b’, ‘c’
[11:02:39.885] Future #1
[11:02:39.886]  length: 2 (resolved future 1)
[11:02:39.886] plan(): Setting new future strategy stack:
[11:02:39.886] List of future strategies:
[11:02:39.886] 1. multicore:
[11:02:39.886]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:39.886]    - tweaked: FALSE
[11:02:39.886]    - call: plan(strategy)
[11:02:39.889] plan(): nbrOfWorkers() = 2
[11:02:39.890] Future #2
[11:02:39.890]  length: 1 (resolved future 2)
[11:02:39.890]  length: 0 (resolved future 3)
[11:02:39.890] resolve() on list environment ... DONE
[11:02:39.891] getGlobalsAndPackages() ...
[11:02:39.891] Searching for globals...
[11:02:39.892] - globals found: [1] ‘{’
[11:02:39.892] Searching for globals ... DONE
[11:02:39.893] Resolving globals: FALSE
[11:02:39.893] 
[11:02:39.893] 
[11:02:39.893] getGlobalsAndPackages() ... DONE
[11:02:39.894] run() for ‘Future’ ...
[11:02:39.894] - state: ‘created’
[11:02:39.894] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:02:39.897] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:39.897] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:02:39.897]   - Field: ‘label’
[11:02:39.897]   - Field: ‘local’
[11:02:39.897]   - Field: ‘owner’
[11:02:39.897]   - Field: ‘envir’
[11:02:39.897]   - Field: ‘workers’
[11:02:39.898]   - Field: ‘packages’
[11:02:39.898]   - Field: ‘gc’
[11:02:39.898]   - Field: ‘job’
[11:02:39.898]   - Field: ‘conditions’
[11:02:39.898]   - Field: ‘expr’
[11:02:39.898]   - Field: ‘uuid’
[11:02:39.898]   - Field: ‘seed’
[11:02:39.899]   - Field: ‘version’
[11:02:39.899]   - Field: ‘result’
[11:02:39.899]   - Field: ‘asynchronous’
[11:02:39.899]   - Field: ‘calls’
[11:02:39.899]   - Field: ‘globals’
[11:02:39.899]   - Field: ‘stdout’
[11:02:39.899]   - Field: ‘earlySignal’
[11:02:39.899]   - Field: ‘lazy’
[11:02:39.900]   - Field: ‘state’
[11:02:39.900] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:02:39.900] - Launch lazy future ...
[11:02:39.900] Packages needed by the future expression (n = 0): <none>
[11:02:39.900] Packages needed by future strategies (n = 0): <none>
[11:02:39.901] {
[11:02:39.901]     {
[11:02:39.901]         {
[11:02:39.901]             ...future.startTime <- base::Sys.time()
[11:02:39.901]             {
[11:02:39.901]                 {
[11:02:39.901]                   {
[11:02:39.901]                     {
[11:02:39.901]                       base::local({
[11:02:39.901]                         has_future <- base::requireNamespace("future", 
[11:02:39.901]                           quietly = TRUE)
[11:02:39.901]                         if (has_future) {
[11:02:39.901]                           ns <- base::getNamespace("future")
[11:02:39.901]                           version <- ns[[".package"]][["version"]]
[11:02:39.901]                           if (is.null(version)) 
[11:02:39.901]                             version <- utils::packageVersion("future")
[11:02:39.901]                         }
[11:02:39.901]                         else {
[11:02:39.901]                           version <- NULL
[11:02:39.901]                         }
[11:02:39.901]                         if (!has_future || version < "1.8.0") {
[11:02:39.901]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:39.901]                             "", base::R.version$version.string), 
[11:02:39.901]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:39.901]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:39.901]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:39.901]                               "release", "version")], collapse = " "), 
[11:02:39.901]                             hostname = base::Sys.info()[["nodename"]])
[11:02:39.901]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:39.901]                             info)
[11:02:39.901]                           info <- base::paste(info, collapse = "; ")
[11:02:39.901]                           if (!has_future) {
[11:02:39.901]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:39.901]                               info)
[11:02:39.901]                           }
[11:02:39.901]                           else {
[11:02:39.901]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:39.901]                               info, version)
[11:02:39.901]                           }
[11:02:39.901]                           base::stop(msg)
[11:02:39.901]                         }
[11:02:39.901]                       })
[11:02:39.901]                     }
[11:02:39.901]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:39.901]                     base::options(mc.cores = 1L)
[11:02:39.901]                   }
[11:02:39.901]                   ...future.strategy.old <- future::plan("list")
[11:02:39.901]                   options(future.plan = NULL)
[11:02:39.901]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:39.901]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:39.901]                 }
[11:02:39.901]                 ...future.workdir <- getwd()
[11:02:39.901]             }
[11:02:39.901]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:39.901]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:39.901]         }
[11:02:39.901]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:39.901]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:39.901]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:39.901]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:39.901]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:39.901]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:39.901]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:39.901]             base::names(...future.oldOptions))
[11:02:39.901]     }
[11:02:39.901]     if (FALSE) {
[11:02:39.901]     }
[11:02:39.901]     else {
[11:02:39.901]         if (TRUE) {
[11:02:39.901]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:39.901]                 open = "w")
[11:02:39.901]         }
[11:02:39.901]         else {
[11:02:39.901]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:39.901]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:39.901]         }
[11:02:39.901]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:39.901]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:39.901]             base::sink(type = "output", split = FALSE)
[11:02:39.901]             base::close(...future.stdout)
[11:02:39.901]         }, add = TRUE)
[11:02:39.901]     }
[11:02:39.901]     ...future.frame <- base::sys.nframe()
[11:02:39.901]     ...future.conditions <- base::list()
[11:02:39.901]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:39.901]     if (FALSE) {
[11:02:39.901]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:39.901]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:39.901]     }
[11:02:39.901]     ...future.result <- base::tryCatch({
[11:02:39.901]         base::withCallingHandlers({
[11:02:39.901]             ...future.value <- base::withVisible(base::local({
[11:02:39.901]                 withCallingHandlers({
[11:02:39.901]                   {
[11:02:39.901]                     1
[11:02:39.901]                   }
[11:02:39.901]                 }, immediateCondition = function(cond) {
[11:02:39.901]                   save_rds <- function (object, pathname, ...) 
[11:02:39.901]                   {
[11:02:39.901]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:02:39.901]                     if (file_test("-f", pathname_tmp)) {
[11:02:39.901]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.901]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:02:39.901]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.901]                         fi_tmp[["mtime"]])
[11:02:39.901]                     }
[11:02:39.901]                     tryCatch({
[11:02:39.901]                       saveRDS(object, file = pathname_tmp, ...)
[11:02:39.901]                     }, error = function(ex) {
[11:02:39.901]                       msg <- conditionMessage(ex)
[11:02:39.901]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.901]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:02:39.901]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.901]                         fi_tmp[["mtime"]], msg)
[11:02:39.901]                       ex$message <- msg
[11:02:39.901]                       stop(ex)
[11:02:39.901]                     })
[11:02:39.901]                     stopifnot(file_test("-f", pathname_tmp))
[11:02:39.901]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:02:39.901]                     if (!res || file_test("-f", pathname_tmp)) {
[11:02:39.901]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.901]                       fi <- file.info(pathname)
[11:02:39.901]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:02:39.901]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.901]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:02:39.901]                         fi[["size"]], fi[["mtime"]])
[11:02:39.901]                       stop(msg)
[11:02:39.901]                     }
[11:02:39.901]                     invisible(pathname)
[11:02:39.901]                   }
[11:02:39.901]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:02:39.901]                     rootPath = tempdir()) 
[11:02:39.901]                   {
[11:02:39.901]                     obj <- list(time = Sys.time(), condition = cond)
[11:02:39.901]                     file <- tempfile(pattern = class(cond)[1], 
[11:02:39.901]                       tmpdir = path, fileext = ".rds")
[11:02:39.901]                     save_rds(obj, file)
[11:02:39.901]                   }
[11:02:39.901]                   saveImmediateCondition(cond, path = "/tmp/RtmpPVwpFC/.future/immediateConditions")
[11:02:39.901]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.901]                   {
[11:02:39.901]                     inherits <- base::inherits
[11:02:39.901]                     invokeRestart <- base::invokeRestart
[11:02:39.901]                     is.null <- base::is.null
[11:02:39.901]                     muffled <- FALSE
[11:02:39.901]                     if (inherits(cond, "message")) {
[11:02:39.901]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:39.901]                       if (muffled) 
[11:02:39.901]                         invokeRestart("muffleMessage")
[11:02:39.901]                     }
[11:02:39.901]                     else if (inherits(cond, "warning")) {
[11:02:39.901]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:39.901]                       if (muffled) 
[11:02:39.901]                         invokeRestart("muffleWarning")
[11:02:39.901]                     }
[11:02:39.901]                     else if (inherits(cond, "condition")) {
[11:02:39.901]                       if (!is.null(pattern)) {
[11:02:39.901]                         computeRestarts <- base::computeRestarts
[11:02:39.901]                         grepl <- base::grepl
[11:02:39.901]                         restarts <- computeRestarts(cond)
[11:02:39.901]                         for (restart in restarts) {
[11:02:39.901]                           name <- restart$name
[11:02:39.901]                           if (is.null(name)) 
[11:02:39.901]                             next
[11:02:39.901]                           if (!grepl(pattern, name)) 
[11:02:39.901]                             next
[11:02:39.901]                           invokeRestart(restart)
[11:02:39.901]                           muffled <- TRUE
[11:02:39.901]                           break
[11:02:39.901]                         }
[11:02:39.901]                       }
[11:02:39.901]                     }
[11:02:39.901]                     invisible(muffled)
[11:02:39.901]                   }
[11:02:39.901]                   muffleCondition(cond)
[11:02:39.901]                 })
[11:02:39.901]             }))
[11:02:39.901]             future::FutureResult(value = ...future.value$value, 
[11:02:39.901]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:39.901]                   ...future.rng), globalenv = if (FALSE) 
[11:02:39.901]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:39.901]                     ...future.globalenv.names))
[11:02:39.901]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:39.901]         }, condition = base::local({
[11:02:39.901]             c <- base::c
[11:02:39.901]             inherits <- base::inherits
[11:02:39.901]             invokeRestart <- base::invokeRestart
[11:02:39.901]             length <- base::length
[11:02:39.901]             list <- base::list
[11:02:39.901]             seq.int <- base::seq.int
[11:02:39.901]             signalCondition <- base::signalCondition
[11:02:39.901]             sys.calls <- base::sys.calls
[11:02:39.901]             `[[` <- base::`[[`
[11:02:39.901]             `+` <- base::`+`
[11:02:39.901]             `<<-` <- base::`<<-`
[11:02:39.901]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:39.901]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:39.901]                   3L)]
[11:02:39.901]             }
[11:02:39.901]             function(cond) {
[11:02:39.901]                 is_error <- inherits(cond, "error")
[11:02:39.901]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:39.901]                   NULL)
[11:02:39.901]                 if (is_error) {
[11:02:39.901]                   sessionInformation <- function() {
[11:02:39.901]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:39.901]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:39.901]                       search = base::search(), system = base::Sys.info())
[11:02:39.901]                   }
[11:02:39.901]                   ...future.conditions[[length(...future.conditions) + 
[11:02:39.901]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:39.901]                     cond$call), session = sessionInformation(), 
[11:02:39.901]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:39.901]                   signalCondition(cond)
[11:02:39.901]                 }
[11:02:39.901]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:39.901]                 "immediateCondition"))) {
[11:02:39.901]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:39.901]                   ...future.conditions[[length(...future.conditions) + 
[11:02:39.901]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:39.901]                   if (TRUE && !signal) {
[11:02:39.901]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.901]                     {
[11:02:39.901]                       inherits <- base::inherits
[11:02:39.901]                       invokeRestart <- base::invokeRestart
[11:02:39.901]                       is.null <- base::is.null
[11:02:39.901]                       muffled <- FALSE
[11:02:39.901]                       if (inherits(cond, "message")) {
[11:02:39.901]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:39.901]                         if (muffled) 
[11:02:39.901]                           invokeRestart("muffleMessage")
[11:02:39.901]                       }
[11:02:39.901]                       else if (inherits(cond, "warning")) {
[11:02:39.901]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:39.901]                         if (muffled) 
[11:02:39.901]                           invokeRestart("muffleWarning")
[11:02:39.901]                       }
[11:02:39.901]                       else if (inherits(cond, "condition")) {
[11:02:39.901]                         if (!is.null(pattern)) {
[11:02:39.901]                           computeRestarts <- base::computeRestarts
[11:02:39.901]                           grepl <- base::grepl
[11:02:39.901]                           restarts <- computeRestarts(cond)
[11:02:39.901]                           for (restart in restarts) {
[11:02:39.901]                             name <- restart$name
[11:02:39.901]                             if (is.null(name)) 
[11:02:39.901]                               next
[11:02:39.901]                             if (!grepl(pattern, name)) 
[11:02:39.901]                               next
[11:02:39.901]                             invokeRestart(restart)
[11:02:39.901]                             muffled <- TRUE
[11:02:39.901]                             break
[11:02:39.901]                           }
[11:02:39.901]                         }
[11:02:39.901]                       }
[11:02:39.901]                       invisible(muffled)
[11:02:39.901]                     }
[11:02:39.901]                     muffleCondition(cond, pattern = "^muffle")
[11:02:39.901]                   }
[11:02:39.901]                 }
[11:02:39.901]                 else {
[11:02:39.901]                   if (TRUE) {
[11:02:39.901]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.901]                     {
[11:02:39.901]                       inherits <- base::inherits
[11:02:39.901]                       invokeRestart <- base::invokeRestart
[11:02:39.901]                       is.null <- base::is.null
[11:02:39.901]                       muffled <- FALSE
[11:02:39.901]                       if (inherits(cond, "message")) {
[11:02:39.901]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:39.901]                         if (muffled) 
[11:02:39.901]                           invokeRestart("muffleMessage")
[11:02:39.901]                       }
[11:02:39.901]                       else if (inherits(cond, "warning")) {
[11:02:39.901]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:39.901]                         if (muffled) 
[11:02:39.901]                           invokeRestart("muffleWarning")
[11:02:39.901]                       }
[11:02:39.901]                       else if (inherits(cond, "condition")) {
[11:02:39.901]                         if (!is.null(pattern)) {
[11:02:39.901]                           computeRestarts <- base::computeRestarts
[11:02:39.901]                           grepl <- base::grepl
[11:02:39.901]                           restarts <- computeRestarts(cond)
[11:02:39.901]                           for (restart in restarts) {
[11:02:39.901]                             name <- restart$name
[11:02:39.901]                             if (is.null(name)) 
[11:02:39.901]                               next
[11:02:39.901]                             if (!grepl(pattern, name)) 
[11:02:39.901]                               next
[11:02:39.901]                             invokeRestart(restart)
[11:02:39.901]                             muffled <- TRUE
[11:02:39.901]                             break
[11:02:39.901]                           }
[11:02:39.901]                         }
[11:02:39.901]                       }
[11:02:39.901]                       invisible(muffled)
[11:02:39.901]                     }
[11:02:39.901]                     muffleCondition(cond, pattern = "^muffle")
[11:02:39.901]                   }
[11:02:39.901]                 }
[11:02:39.901]             }
[11:02:39.901]         }))
[11:02:39.901]     }, error = function(ex) {
[11:02:39.901]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:39.901]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:39.901]                 ...future.rng), started = ...future.startTime, 
[11:02:39.901]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:39.901]             version = "1.8"), class = "FutureResult")
[11:02:39.901]     }, finally = {
[11:02:39.901]         if (!identical(...future.workdir, getwd())) 
[11:02:39.901]             setwd(...future.workdir)
[11:02:39.901]         {
[11:02:39.901]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:39.901]                 ...future.oldOptions$nwarnings <- NULL
[11:02:39.901]             }
[11:02:39.901]             base::options(...future.oldOptions)
[11:02:39.901]             if (.Platform$OS.type == "windows") {
[11:02:39.901]                 old_names <- names(...future.oldEnvVars)
[11:02:39.901]                 envs <- base::Sys.getenv()
[11:02:39.901]                 names <- names(envs)
[11:02:39.901]                 common <- intersect(names, old_names)
[11:02:39.901]                 added <- setdiff(names, old_names)
[11:02:39.901]                 removed <- setdiff(old_names, names)
[11:02:39.901]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:39.901]                   envs[common]]
[11:02:39.901]                 NAMES <- toupper(changed)
[11:02:39.901]                 args <- list()
[11:02:39.901]                 for (kk in seq_along(NAMES)) {
[11:02:39.901]                   name <- changed[[kk]]
[11:02:39.901]                   NAME <- NAMES[[kk]]
[11:02:39.901]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.901]                     next
[11:02:39.901]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:39.901]                 }
[11:02:39.901]                 NAMES <- toupper(added)
[11:02:39.901]                 for (kk in seq_along(NAMES)) {
[11:02:39.901]                   name <- added[[kk]]
[11:02:39.901]                   NAME <- NAMES[[kk]]
[11:02:39.901]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.901]                     next
[11:02:39.901]                   args[[name]] <- ""
[11:02:39.901]                 }
[11:02:39.901]                 NAMES <- toupper(removed)
[11:02:39.901]                 for (kk in seq_along(NAMES)) {
[11:02:39.901]                   name <- removed[[kk]]
[11:02:39.901]                   NAME <- NAMES[[kk]]
[11:02:39.901]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.901]                     next
[11:02:39.901]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:39.901]                 }
[11:02:39.901]                 if (length(args) > 0) 
[11:02:39.901]                   base::do.call(base::Sys.setenv, args = args)
[11:02:39.901]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:39.901]             }
[11:02:39.901]             else {
[11:02:39.901]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:39.901]             }
[11:02:39.901]             {
[11:02:39.901]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:39.901]                   0L) {
[11:02:39.901]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:39.901]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:39.901]                   base::options(opts)
[11:02:39.901]                 }
[11:02:39.901]                 {
[11:02:39.901]                   {
[11:02:39.901]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:39.901]                     NULL
[11:02:39.901]                   }
[11:02:39.901]                   options(future.plan = NULL)
[11:02:39.901]                   if (is.na(NA_character_)) 
[11:02:39.901]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:39.901]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:39.901]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:39.901]                     .init = FALSE)
[11:02:39.901]                 }
[11:02:39.901]             }
[11:02:39.901]         }
[11:02:39.901]     })
[11:02:39.901]     if (TRUE) {
[11:02:39.901]         base::sink(type = "output", split = FALSE)
[11:02:39.901]         if (TRUE) {
[11:02:39.901]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:39.901]         }
[11:02:39.901]         else {
[11:02:39.901]             ...future.result["stdout"] <- base::list(NULL)
[11:02:39.901]         }
[11:02:39.901]         base::close(...future.stdout)
[11:02:39.901]         ...future.stdout <- NULL
[11:02:39.901]     }
[11:02:39.901]     ...future.result$conditions <- ...future.conditions
[11:02:39.901]     ...future.result$finished <- base::Sys.time()
[11:02:39.901]     ...future.result
[11:02:39.901] }
[11:02:39.904] requestCore(): workers = 2
[11:02:39.905] Poll #1 (0): usedCores() = 2, workers = 2
[11:02:39.915] result() for MulticoreFuture ...
[11:02:39.916] result() for MulticoreFuture ...
[11:02:39.916] result() for MulticoreFuture ... done
[11:02:39.917] result() for MulticoreFuture ... done
[11:02:39.917] result() for MulticoreFuture ...
[11:02:39.917] result() for MulticoreFuture ... done
[11:02:39.919] MulticoreFuture started
[11:02:39.919] - Launch lazy future ... done
[11:02:39.920] run() for ‘MulticoreFuture’ ... done
[11:02:39.920] plan(): Setting new future strategy stack:
[11:02:39.921] getGlobalsAndPackages() ...
[11:02:39.921] Searching for globals...
[11:02:39.920] List of future strategies:
[11:02:39.920] 1. sequential:
[11:02:39.920]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:39.920]    - tweaked: FALSE
[11:02:39.920]    - call: NULL
[11:02:39.922] plan(): nbrOfWorkers() = 1
[11:02:39.924] - globals found: [2] ‘{’, ‘Sys.sleep’
[11:02:39.924] Searching for globals ... DONE
[11:02:39.924] Resolving globals: FALSE
[11:02:39.925] plan(): Setting new future strategy stack:
[11:02:39.925] 
[11:02:39.925] List of future strategies:
[11:02:39.925] 1. multicore:
[11:02:39.925]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:39.925]    - tweaked: FALSE
[11:02:39.925]    - call: plan(strategy)
[11:02:39.925] 
[11:02:39.926] getGlobalsAndPackages() ... DONE
[11:02:39.926] run() for ‘Future’ ...
[11:02:39.926] - state: ‘created’
[11:02:39.927] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:02:39.929] plan(): nbrOfWorkers() = 2
[11:02:39.936] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:39.936] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:02:39.937]   - Field: ‘label’
[11:02:39.937]   - Field: ‘local’
[11:02:39.937]   - Field: ‘owner’
[11:02:39.937]   - Field: ‘envir’
[11:02:39.937]   - Field: ‘workers’
[11:02:39.938]   - Field: ‘packages’
[11:02:39.938]   - Field: ‘gc’
[11:02:39.938]   - Field: ‘job’
[11:02:39.938]   - Field: ‘conditions’
[11:02:39.938]   - Field: ‘expr’
[11:02:39.939]   - Field: ‘uuid’
[11:02:39.939]   - Field: ‘seed’
[11:02:39.939]   - Field: ‘version’
[11:02:39.939]   - Field: ‘result’
[11:02:39.939]   - Field: ‘asynchronous’
[11:02:39.939]   - Field: ‘calls’
[11:02:39.940]   - Field: ‘globals’
[11:02:39.940]   - Field: ‘stdout’
[11:02:39.940]   - Field: ‘earlySignal’
[11:02:39.940]   - Field: ‘lazy’
[11:02:39.940]   - Field: ‘state’
[11:02:39.940] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:02:39.940] - Launch lazy future ...
[11:02:39.941] Packages needed by the future expression (n = 0): <none>
[11:02:39.941] Packages needed by future strategies (n = 0): <none>
[11:02:39.942] {
[11:02:39.942]     {
[11:02:39.942]         {
[11:02:39.942]             ...future.startTime <- base::Sys.time()
[11:02:39.942]             {
[11:02:39.942]                 {
[11:02:39.942]                   {
[11:02:39.942]                     {
[11:02:39.942]                       base::local({
[11:02:39.942]                         has_future <- base::requireNamespace("future", 
[11:02:39.942]                           quietly = TRUE)
[11:02:39.942]                         if (has_future) {
[11:02:39.942]                           ns <- base::getNamespace("future")
[11:02:39.942]                           version <- ns[[".package"]][["version"]]
[11:02:39.942]                           if (is.null(version)) 
[11:02:39.942]                             version <- utils::packageVersion("future")
[11:02:39.942]                         }
[11:02:39.942]                         else {
[11:02:39.942]                           version <- NULL
[11:02:39.942]                         }
[11:02:39.942]                         if (!has_future || version < "1.8.0") {
[11:02:39.942]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:39.942]                             "", base::R.version$version.string), 
[11:02:39.942]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:39.942]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:39.942]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:39.942]                               "release", "version")], collapse = " "), 
[11:02:39.942]                             hostname = base::Sys.info()[["nodename"]])
[11:02:39.942]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:39.942]                             info)
[11:02:39.942]                           info <- base::paste(info, collapse = "; ")
[11:02:39.942]                           if (!has_future) {
[11:02:39.942]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:39.942]                               info)
[11:02:39.942]                           }
[11:02:39.942]                           else {
[11:02:39.942]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:39.942]                               info, version)
[11:02:39.942]                           }
[11:02:39.942]                           base::stop(msg)
[11:02:39.942]                         }
[11:02:39.942]                       })
[11:02:39.942]                     }
[11:02:39.942]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:39.942]                     base::options(mc.cores = 1L)
[11:02:39.942]                   }
[11:02:39.942]                   ...future.strategy.old <- future::plan("list")
[11:02:39.942]                   options(future.plan = NULL)
[11:02:39.942]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:39.942]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:39.942]                 }
[11:02:39.942]                 ...future.workdir <- getwd()
[11:02:39.942]             }
[11:02:39.942]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:39.942]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:39.942]         }
[11:02:39.942]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:39.942]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:39.942]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:39.942]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:39.942]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:39.942]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:39.942]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:39.942]             base::names(...future.oldOptions))
[11:02:39.942]     }
[11:02:39.942]     if (FALSE) {
[11:02:39.942]     }
[11:02:39.942]     else {
[11:02:39.942]         if (TRUE) {
[11:02:39.942]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:39.942]                 open = "w")
[11:02:39.942]         }
[11:02:39.942]         else {
[11:02:39.942]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:39.942]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:39.942]         }
[11:02:39.942]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:39.942]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:39.942]             base::sink(type = "output", split = FALSE)
[11:02:39.942]             base::close(...future.stdout)
[11:02:39.942]         }, add = TRUE)
[11:02:39.942]     }
[11:02:39.942]     ...future.frame <- base::sys.nframe()
[11:02:39.942]     ...future.conditions <- base::list()
[11:02:39.942]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:39.942]     if (FALSE) {
[11:02:39.942]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:39.942]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:39.942]     }
[11:02:39.942]     ...future.result <- base::tryCatch({
[11:02:39.942]         base::withCallingHandlers({
[11:02:39.942]             ...future.value <- base::withVisible(base::local({
[11:02:39.942]                 withCallingHandlers({
[11:02:39.942]                   {
[11:02:39.942]                     Sys.sleep(0.5)
[11:02:39.942]                     2
[11:02:39.942]                   }
[11:02:39.942]                 }, immediateCondition = function(cond) {
[11:02:39.942]                   save_rds <- function (object, pathname, ...) 
[11:02:39.942]                   {
[11:02:39.942]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:02:39.942]                     if (file_test("-f", pathname_tmp)) {
[11:02:39.942]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.942]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:02:39.942]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.942]                         fi_tmp[["mtime"]])
[11:02:39.942]                     }
[11:02:39.942]                     tryCatch({
[11:02:39.942]                       saveRDS(object, file = pathname_tmp, ...)
[11:02:39.942]                     }, error = function(ex) {
[11:02:39.942]                       msg <- conditionMessage(ex)
[11:02:39.942]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.942]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:02:39.942]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.942]                         fi_tmp[["mtime"]], msg)
[11:02:39.942]                       ex$message <- msg
[11:02:39.942]                       stop(ex)
[11:02:39.942]                     })
[11:02:39.942]                     stopifnot(file_test("-f", pathname_tmp))
[11:02:39.942]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:02:39.942]                     if (!res || file_test("-f", pathname_tmp)) {
[11:02:39.942]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.942]                       fi <- file.info(pathname)
[11:02:39.942]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:02:39.942]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.942]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:02:39.942]                         fi[["size"]], fi[["mtime"]])
[11:02:39.942]                       stop(msg)
[11:02:39.942]                     }
[11:02:39.942]                     invisible(pathname)
[11:02:39.942]                   }
[11:02:39.942]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:02:39.942]                     rootPath = tempdir()) 
[11:02:39.942]                   {
[11:02:39.942]                     obj <- list(time = Sys.time(), condition = cond)
[11:02:39.942]                     file <- tempfile(pattern = class(cond)[1], 
[11:02:39.942]                       tmpdir = path, fileext = ".rds")
[11:02:39.942]                     save_rds(obj, file)
[11:02:39.942]                   }
[11:02:39.942]                   saveImmediateCondition(cond, path = "/tmp/RtmpPVwpFC/.future/immediateConditions")
[11:02:39.942]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.942]                   {
[11:02:39.942]                     inherits <- base::inherits
[11:02:39.942]                     invokeRestart <- base::invokeRestart
[11:02:39.942]                     is.null <- base::is.null
[11:02:39.942]                     muffled <- FALSE
[11:02:39.942]                     if (inherits(cond, "message")) {
[11:02:39.942]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:39.942]                       if (muffled) 
[11:02:39.942]                         invokeRestart("muffleMessage")
[11:02:39.942]                     }
[11:02:39.942]                     else if (inherits(cond, "warning")) {
[11:02:39.942]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:39.942]                       if (muffled) 
[11:02:39.942]                         invokeRestart("muffleWarning")
[11:02:39.942]                     }
[11:02:39.942]                     else if (inherits(cond, "condition")) {
[11:02:39.942]                       if (!is.null(pattern)) {
[11:02:39.942]                         computeRestarts <- base::computeRestarts
[11:02:39.942]                         grepl <- base::grepl
[11:02:39.942]                         restarts <- computeRestarts(cond)
[11:02:39.942]                         for (restart in restarts) {
[11:02:39.942]                           name <- restart$name
[11:02:39.942]                           if (is.null(name)) 
[11:02:39.942]                             next
[11:02:39.942]                           if (!grepl(pattern, name)) 
[11:02:39.942]                             next
[11:02:39.942]                           invokeRestart(restart)
[11:02:39.942]                           muffled <- TRUE
[11:02:39.942]                           break
[11:02:39.942]                         }
[11:02:39.942]                       }
[11:02:39.942]                     }
[11:02:39.942]                     invisible(muffled)
[11:02:39.942]                   }
[11:02:39.942]                   muffleCondition(cond)
[11:02:39.942]                 })
[11:02:39.942]             }))
[11:02:39.942]             future::FutureResult(value = ...future.value$value, 
[11:02:39.942]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:39.942]                   ...future.rng), globalenv = if (FALSE) 
[11:02:39.942]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:39.942]                     ...future.globalenv.names))
[11:02:39.942]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:39.942]         }, condition = base::local({
[11:02:39.942]             c <- base::c
[11:02:39.942]             inherits <- base::inherits
[11:02:39.942]             invokeRestart <- base::invokeRestart
[11:02:39.942]             length <- base::length
[11:02:39.942]             list <- base::list
[11:02:39.942]             seq.int <- base::seq.int
[11:02:39.942]             signalCondition <- base::signalCondition
[11:02:39.942]             sys.calls <- base::sys.calls
[11:02:39.942]             `[[` <- base::`[[`
[11:02:39.942]             `+` <- base::`+`
[11:02:39.942]             `<<-` <- base::`<<-`
[11:02:39.942]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:39.942]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:39.942]                   3L)]
[11:02:39.942]             }
[11:02:39.942]             function(cond) {
[11:02:39.942]                 is_error <- inherits(cond, "error")
[11:02:39.942]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:39.942]                   NULL)
[11:02:39.942]                 if (is_error) {
[11:02:39.942]                   sessionInformation <- function() {
[11:02:39.942]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:39.942]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:39.942]                       search = base::search(), system = base::Sys.info())
[11:02:39.942]                   }
[11:02:39.942]                   ...future.conditions[[length(...future.conditions) + 
[11:02:39.942]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:39.942]                     cond$call), session = sessionInformation(), 
[11:02:39.942]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:39.942]                   signalCondition(cond)
[11:02:39.942]                 }
[11:02:39.942]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:39.942]                 "immediateCondition"))) {
[11:02:39.942]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:39.942]                   ...future.conditions[[length(...future.conditions) + 
[11:02:39.942]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:39.942]                   if (TRUE && !signal) {
[11:02:39.942]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.942]                     {
[11:02:39.942]                       inherits <- base::inherits
[11:02:39.942]                       invokeRestart <- base::invokeRestart
[11:02:39.942]                       is.null <- base::is.null
[11:02:39.942]                       muffled <- FALSE
[11:02:39.942]                       if (inherits(cond, "message")) {
[11:02:39.942]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:39.942]                         if (muffled) 
[11:02:39.942]                           invokeRestart("muffleMessage")
[11:02:39.942]                       }
[11:02:39.942]                       else if (inherits(cond, "warning")) {
[11:02:39.942]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:39.942]                         if (muffled) 
[11:02:39.942]                           invokeRestart("muffleWarning")
[11:02:39.942]                       }
[11:02:39.942]                       else if (inherits(cond, "condition")) {
[11:02:39.942]                         if (!is.null(pattern)) {
[11:02:39.942]                           computeRestarts <- base::computeRestarts
[11:02:39.942]                           grepl <- base::grepl
[11:02:39.942]                           restarts <- computeRestarts(cond)
[11:02:39.942]                           for (restart in restarts) {
[11:02:39.942]                             name <- restart$name
[11:02:39.942]                             if (is.null(name)) 
[11:02:39.942]                               next
[11:02:39.942]                             if (!grepl(pattern, name)) 
[11:02:39.942]                               next
[11:02:39.942]                             invokeRestart(restart)
[11:02:39.942]                             muffled <- TRUE
[11:02:39.942]                             break
[11:02:39.942]                           }
[11:02:39.942]                         }
[11:02:39.942]                       }
[11:02:39.942]                       invisible(muffled)
[11:02:39.942]                     }
[11:02:39.942]                     muffleCondition(cond, pattern = "^muffle")
[11:02:39.942]                   }
[11:02:39.942]                 }
[11:02:39.942]                 else {
[11:02:39.942]                   if (TRUE) {
[11:02:39.942]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.942]                     {
[11:02:39.942]                       inherits <- base::inherits
[11:02:39.942]                       invokeRestart <- base::invokeRestart
[11:02:39.942]                       is.null <- base::is.null
[11:02:39.942]                       muffled <- FALSE
[11:02:39.942]                       if (inherits(cond, "message")) {
[11:02:39.942]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:39.942]                         if (muffled) 
[11:02:39.942]                           invokeRestart("muffleMessage")
[11:02:39.942]                       }
[11:02:39.942]                       else if (inherits(cond, "warning")) {
[11:02:39.942]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:39.942]                         if (muffled) 
[11:02:39.942]                           invokeRestart("muffleWarning")
[11:02:39.942]                       }
[11:02:39.942]                       else if (inherits(cond, "condition")) {
[11:02:39.942]                         if (!is.null(pattern)) {
[11:02:39.942]                           computeRestarts <- base::computeRestarts
[11:02:39.942]                           grepl <- base::grepl
[11:02:39.942]                           restarts <- computeRestarts(cond)
[11:02:39.942]                           for (restart in restarts) {
[11:02:39.942]                             name <- restart$name
[11:02:39.942]                             if (is.null(name)) 
[11:02:39.942]                               next
[11:02:39.942]                             if (!grepl(pattern, name)) 
[11:02:39.942]                               next
[11:02:39.942]                             invokeRestart(restart)
[11:02:39.942]                             muffled <- TRUE
[11:02:39.942]                             break
[11:02:39.942]                           }
[11:02:39.942]                         }
[11:02:39.942]                       }
[11:02:39.942]                       invisible(muffled)
[11:02:39.942]                     }
[11:02:39.942]                     muffleCondition(cond, pattern = "^muffle")
[11:02:39.942]                   }
[11:02:39.942]                 }
[11:02:39.942]             }
[11:02:39.942]         }))
[11:02:39.942]     }, error = function(ex) {
[11:02:39.942]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:39.942]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:39.942]                 ...future.rng), started = ...future.startTime, 
[11:02:39.942]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:39.942]             version = "1.8"), class = "FutureResult")
[11:02:39.942]     }, finally = {
[11:02:39.942]         if (!identical(...future.workdir, getwd())) 
[11:02:39.942]             setwd(...future.workdir)
[11:02:39.942]         {
[11:02:39.942]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:39.942]                 ...future.oldOptions$nwarnings <- NULL
[11:02:39.942]             }
[11:02:39.942]             base::options(...future.oldOptions)
[11:02:39.942]             if (.Platform$OS.type == "windows") {
[11:02:39.942]                 old_names <- names(...future.oldEnvVars)
[11:02:39.942]                 envs <- base::Sys.getenv()
[11:02:39.942]                 names <- names(envs)
[11:02:39.942]                 common <- intersect(names, old_names)
[11:02:39.942]                 added <- setdiff(names, old_names)
[11:02:39.942]                 removed <- setdiff(old_names, names)
[11:02:39.942]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:39.942]                   envs[common]]
[11:02:39.942]                 NAMES <- toupper(changed)
[11:02:39.942]                 args <- list()
[11:02:39.942]                 for (kk in seq_along(NAMES)) {
[11:02:39.942]                   name <- changed[[kk]]
[11:02:39.942]                   NAME <- NAMES[[kk]]
[11:02:39.942]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.942]                     next
[11:02:39.942]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:39.942]                 }
[11:02:39.942]                 NAMES <- toupper(added)
[11:02:39.942]                 for (kk in seq_along(NAMES)) {
[11:02:39.942]                   name <- added[[kk]]
[11:02:39.942]                   NAME <- NAMES[[kk]]
[11:02:39.942]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.942]                     next
[11:02:39.942]                   args[[name]] <- ""
[11:02:39.942]                 }
[11:02:39.942]                 NAMES <- toupper(removed)
[11:02:39.942]                 for (kk in seq_along(NAMES)) {
[11:02:39.942]                   name <- removed[[kk]]
[11:02:39.942]                   NAME <- NAMES[[kk]]
[11:02:39.942]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.942]                     next
[11:02:39.942]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:39.942]                 }
[11:02:39.942]                 if (length(args) > 0) 
[11:02:39.942]                   base::do.call(base::Sys.setenv, args = args)
[11:02:39.942]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:39.942]             }
[11:02:39.942]             else {
[11:02:39.942]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:39.942]             }
[11:02:39.942]             {
[11:02:39.942]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:39.942]                   0L) {
[11:02:39.942]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:39.942]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:39.942]                   base::options(opts)
[11:02:39.942]                 }
[11:02:39.942]                 {
[11:02:39.942]                   {
[11:02:39.942]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:39.942]                     NULL
[11:02:39.942]                   }
[11:02:39.942]                   options(future.plan = NULL)
[11:02:39.942]                   if (is.na(NA_character_)) 
[11:02:39.942]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:39.942]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:39.942]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:39.942]                     .init = FALSE)
[11:02:39.942]                 }
[11:02:39.942]             }
[11:02:39.942]         }
[11:02:39.942]     })
[11:02:39.942]     if (TRUE) {
[11:02:39.942]         base::sink(type = "output", split = FALSE)
[11:02:39.942]         if (TRUE) {
[11:02:39.942]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:39.942]         }
[11:02:39.942]         else {
[11:02:39.942]             ...future.result["stdout"] <- base::list(NULL)
[11:02:39.942]         }
[11:02:39.942]         base::close(...future.stdout)
[11:02:39.942]         ...future.stdout <- NULL
[11:02:39.942]     }
[11:02:39.942]     ...future.result$conditions <- ...future.conditions
[11:02:39.942]     ...future.result$finished <- base::Sys.time()
[11:02:39.942]     ...future.result
[11:02:39.942] }
[11:02:39.945] requestCore(): workers = 2
[11:02:39.945] Poll #1 (0): usedCores() = 2, workers = 2
[11:02:39.956] result() for MulticoreFuture ...
[11:02:39.956] result() for MulticoreFuture ...
[11:02:39.957] result() for MulticoreFuture ... done
[11:02:39.957] result() for MulticoreFuture ... done
[11:02:39.957] result() for MulticoreFuture ...
[11:02:39.957] result() for MulticoreFuture ... done
[11:02:39.960] MulticoreFuture started
[11:02:39.960] - Launch lazy future ... done
[11:02:39.961] run() for ‘MulticoreFuture’ ... done
[11:02:39.961] plan(): Setting new future strategy stack:
[11:02:39.962] getGlobalsAndPackages() ...
[11:02:39.962] Searching for globals...
[11:02:39.961] List of future strategies:
[11:02:39.961] 1. sequential:
[11:02:39.961]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:39.961]    - tweaked: FALSE
[11:02:39.961]    - call: NULL
[11:02:39.962] plan(): nbrOfWorkers() = 1
[11:02:39.964] - globals found: [1] ‘{’
[11:02:39.964] Searching for globals ... DONE
[11:02:39.964] Resolving globals: FALSE
[11:02:39.964] 
[11:02:39.965] 
[11:02:39.965] getGlobalsAndPackages() ... DONE
[11:02:39.965] run() for ‘Future’ ...
[11:02:39.965] - state: ‘created’
[11:02:39.966] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:02:39.969] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:39.969] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:02:39.969]   - Field: ‘label’
[11:02:39.969]   - Field: ‘local’
[11:02:39.969]   - Field: ‘owner’
[11:02:39.970]   - Field: ‘envir’
[11:02:39.970]   - Field: ‘workers’
[11:02:39.970]   - Field: ‘packages’
[11:02:39.970]   - Field: ‘gc’
[11:02:39.970]   - Field: ‘job’
[11:02:39.970]   - Field: ‘conditions’
[11:02:39.970]   - Field: ‘expr’
[11:02:39.971]   - Field: ‘uuid’
[11:02:39.971]   - Field: ‘seed’
[11:02:39.971]   - Field: ‘version’
[11:02:39.971]   - Field: ‘result’
[11:02:39.971]   - Field: ‘asynchronous’
[11:02:39.971]   - Field: ‘calls’
[11:02:39.971]   - Field: ‘globals’
[11:02:39.972]   - Field: ‘stdout’
[11:02:39.972]   - Field: ‘earlySignal’
[11:02:39.972]   - Field: ‘lazy’
[11:02:39.972]   - Field: ‘state’
[11:02:39.972] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:02:39.972] - Launch lazy future ...
[11:02:39.973] Packages needed by the future expression (n = 0): <none>
[11:02:39.973] Packages needed by future strategies (n = 0): <none>
[11:02:39.973] {
[11:02:39.973]     {
[11:02:39.973]         {
[11:02:39.973]             ...future.startTime <- base::Sys.time()
[11:02:39.973]             {
[11:02:39.973]                 {
[11:02:39.973]                   {
[11:02:39.973]                     {
[11:02:39.973]                       base::local({
[11:02:39.973]                         has_future <- base::requireNamespace("future", 
[11:02:39.973]                           quietly = TRUE)
[11:02:39.973]                         if (has_future) {
[11:02:39.973]                           ns <- base::getNamespace("future")
[11:02:39.973]                           version <- ns[[".package"]][["version"]]
[11:02:39.973]                           if (is.null(version)) 
[11:02:39.973]                             version <- utils::packageVersion("future")
[11:02:39.973]                         }
[11:02:39.973]                         else {
[11:02:39.973]                           version <- NULL
[11:02:39.973]                         }
[11:02:39.973]                         if (!has_future || version < "1.8.0") {
[11:02:39.973]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:39.973]                             "", base::R.version$version.string), 
[11:02:39.973]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:39.973]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:39.973]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:39.973]                               "release", "version")], collapse = " "), 
[11:02:39.973]                             hostname = base::Sys.info()[["nodename"]])
[11:02:39.973]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:39.973]                             info)
[11:02:39.973]                           info <- base::paste(info, collapse = "; ")
[11:02:39.973]                           if (!has_future) {
[11:02:39.973]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:39.973]                               info)
[11:02:39.973]                           }
[11:02:39.973]                           else {
[11:02:39.973]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:39.973]                               info, version)
[11:02:39.973]                           }
[11:02:39.973]                           base::stop(msg)
[11:02:39.973]                         }
[11:02:39.973]                       })
[11:02:39.973]                     }
[11:02:39.973]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:39.973]                     base::options(mc.cores = 1L)
[11:02:39.973]                   }
[11:02:39.973]                   ...future.strategy.old <- future::plan("list")
[11:02:39.973]                   options(future.plan = NULL)
[11:02:39.973]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:39.973]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:39.973]                 }
[11:02:39.973]                 ...future.workdir <- getwd()
[11:02:39.973]             }
[11:02:39.973]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:39.973]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:39.973]         }
[11:02:39.973]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:39.973]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:39.973]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:39.973]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:39.973]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:39.973]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:39.973]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:39.973]             base::names(...future.oldOptions))
[11:02:39.973]     }
[11:02:39.973]     if (FALSE) {
[11:02:39.973]     }
[11:02:39.973]     else {
[11:02:39.973]         if (TRUE) {
[11:02:39.973]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:39.973]                 open = "w")
[11:02:39.973]         }
[11:02:39.973]         else {
[11:02:39.973]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:39.973]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:39.973]         }
[11:02:39.973]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:39.973]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:39.973]             base::sink(type = "output", split = FALSE)
[11:02:39.973]             base::close(...future.stdout)
[11:02:39.973]         }, add = TRUE)
[11:02:39.973]     }
[11:02:39.973]     ...future.frame <- base::sys.nframe()
[11:02:39.973]     ...future.conditions <- base::list()
[11:02:39.973]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:39.973]     if (FALSE) {
[11:02:39.973]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:39.973]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:39.973]     }
[11:02:39.973]     ...future.result <- base::tryCatch({
[11:02:39.973]         base::withCallingHandlers({
[11:02:39.973]             ...future.value <- base::withVisible(base::local({
[11:02:39.973]                 withCallingHandlers({
[11:02:39.973]                   {
[11:02:39.973]                     3
[11:02:39.973]                   }
[11:02:39.973]                 }, immediateCondition = function(cond) {
[11:02:39.973]                   save_rds <- function (object, pathname, ...) 
[11:02:39.973]                   {
[11:02:39.973]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:02:39.973]                     if (file_test("-f", pathname_tmp)) {
[11:02:39.973]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.973]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:02:39.973]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.973]                         fi_tmp[["mtime"]])
[11:02:39.973]                     }
[11:02:39.973]                     tryCatch({
[11:02:39.973]                       saveRDS(object, file = pathname_tmp, ...)
[11:02:39.973]                     }, error = function(ex) {
[11:02:39.973]                       msg <- conditionMessage(ex)
[11:02:39.973]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.973]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:02:39.973]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.973]                         fi_tmp[["mtime"]], msg)
[11:02:39.973]                       ex$message <- msg
[11:02:39.973]                       stop(ex)
[11:02:39.973]                     })
[11:02:39.973]                     stopifnot(file_test("-f", pathname_tmp))
[11:02:39.973]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:02:39.973]                     if (!res || file_test("-f", pathname_tmp)) {
[11:02:39.973]                       fi_tmp <- file.info(pathname_tmp)
[11:02:39.973]                       fi <- file.info(pathname)
[11:02:39.973]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:02:39.973]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:39.973]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:02:39.973]                         fi[["size"]], fi[["mtime"]])
[11:02:39.973]                       stop(msg)
[11:02:39.973]                     }
[11:02:39.973]                     invisible(pathname)
[11:02:39.973]                   }
[11:02:39.973]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:02:39.973]                     rootPath = tempdir()) 
[11:02:39.973]                   {
[11:02:39.973]                     obj <- list(time = Sys.time(), condition = cond)
[11:02:39.973]                     file <- tempfile(pattern = class(cond)[1], 
[11:02:39.973]                       tmpdir = path, fileext = ".rds")
[11:02:39.973]                     save_rds(obj, file)
[11:02:39.973]                   }
[11:02:39.973]                   saveImmediateCondition(cond, path = "/tmp/RtmpPVwpFC/.future/immediateConditions")
[11:02:39.973]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.973]                   {
[11:02:39.973]                     inherits <- base::inherits
[11:02:39.973]                     invokeRestart <- base::invokeRestart
[11:02:39.973]                     is.null <- base::is.null
[11:02:39.973]                     muffled <- FALSE
[11:02:39.973]                     if (inherits(cond, "message")) {
[11:02:39.973]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:39.973]                       if (muffled) 
[11:02:39.973]                         invokeRestart("muffleMessage")
[11:02:39.973]                     }
[11:02:39.973]                     else if (inherits(cond, "warning")) {
[11:02:39.973]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:39.973]                       if (muffled) 
[11:02:39.973]                         invokeRestart("muffleWarning")
[11:02:39.973]                     }
[11:02:39.973]                     else if (inherits(cond, "condition")) {
[11:02:39.973]                       if (!is.null(pattern)) {
[11:02:39.973]                         computeRestarts <- base::computeRestarts
[11:02:39.973]                         grepl <- base::grepl
[11:02:39.973]                         restarts <- computeRestarts(cond)
[11:02:39.973]                         for (restart in restarts) {
[11:02:39.973]                           name <- restart$name
[11:02:39.973]                           if (is.null(name)) 
[11:02:39.973]                             next
[11:02:39.973]                           if (!grepl(pattern, name)) 
[11:02:39.973]                             next
[11:02:39.973]                           invokeRestart(restart)
[11:02:39.973]                           muffled <- TRUE
[11:02:39.973]                           break
[11:02:39.973]                         }
[11:02:39.973]                       }
[11:02:39.973]                     }
[11:02:39.973]                     invisible(muffled)
[11:02:39.973]                   }
[11:02:39.973]                   muffleCondition(cond)
[11:02:39.973]                 })
[11:02:39.973]             }))
[11:02:39.973]             future::FutureResult(value = ...future.value$value, 
[11:02:39.973]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:39.973]                   ...future.rng), globalenv = if (FALSE) 
[11:02:39.973]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:39.973]                     ...future.globalenv.names))
[11:02:39.973]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:39.973]         }, condition = base::local({
[11:02:39.973]             c <- base::c
[11:02:39.973]             inherits <- base::inherits
[11:02:39.973]             invokeRestart <- base::invokeRestart
[11:02:39.973]             length <- base::length
[11:02:39.973]             list <- base::list
[11:02:39.973]             seq.int <- base::seq.int
[11:02:39.973]             signalCondition <- base::signalCondition
[11:02:39.973]             sys.calls <- base::sys.calls
[11:02:39.973]             `[[` <- base::`[[`
[11:02:39.973]             `+` <- base::`+`
[11:02:39.973]             `<<-` <- base::`<<-`
[11:02:39.973]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:39.973]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:39.973]                   3L)]
[11:02:39.973]             }
[11:02:39.973]             function(cond) {
[11:02:39.973]                 is_error <- inherits(cond, "error")
[11:02:39.973]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:39.973]                   NULL)
[11:02:39.973]                 if (is_error) {
[11:02:39.973]                   sessionInformation <- function() {
[11:02:39.973]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:39.973]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:39.973]                       search = base::search(), system = base::Sys.info())
[11:02:39.973]                   }
[11:02:39.973]                   ...future.conditions[[length(...future.conditions) + 
[11:02:39.973]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:39.973]                     cond$call), session = sessionInformation(), 
[11:02:39.973]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:39.973]                   signalCondition(cond)
[11:02:39.973]                 }
[11:02:39.973]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:39.973]                 "immediateCondition"))) {
[11:02:39.973]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:39.973]                   ...future.conditions[[length(...future.conditions) + 
[11:02:39.973]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:39.973]                   if (TRUE && !signal) {
[11:02:39.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.973]                     {
[11:02:39.973]                       inherits <- base::inherits
[11:02:39.973]                       invokeRestart <- base::invokeRestart
[11:02:39.973]                       is.null <- base::is.null
[11:02:39.973]                       muffled <- FALSE
[11:02:39.973]                       if (inherits(cond, "message")) {
[11:02:39.973]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:39.973]                         if (muffled) 
[11:02:39.973]                           invokeRestart("muffleMessage")
[11:02:39.973]                       }
[11:02:39.973]                       else if (inherits(cond, "warning")) {
[11:02:39.973]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:39.973]                         if (muffled) 
[11:02:39.973]                           invokeRestart("muffleWarning")
[11:02:39.973]                       }
[11:02:39.973]                       else if (inherits(cond, "condition")) {
[11:02:39.973]                         if (!is.null(pattern)) {
[11:02:39.973]                           computeRestarts <- base::computeRestarts
[11:02:39.973]                           grepl <- base::grepl
[11:02:39.973]                           restarts <- computeRestarts(cond)
[11:02:39.973]                           for (restart in restarts) {
[11:02:39.973]                             name <- restart$name
[11:02:39.973]                             if (is.null(name)) 
[11:02:39.973]                               next
[11:02:39.973]                             if (!grepl(pattern, name)) 
[11:02:39.973]                               next
[11:02:39.973]                             invokeRestart(restart)
[11:02:39.973]                             muffled <- TRUE
[11:02:39.973]                             break
[11:02:39.973]                           }
[11:02:39.973]                         }
[11:02:39.973]                       }
[11:02:39.973]                       invisible(muffled)
[11:02:39.973]                     }
[11:02:39.973]                     muffleCondition(cond, pattern = "^muffle")
[11:02:39.973]                   }
[11:02:39.973]                 }
[11:02:39.973]                 else {
[11:02:39.973]                   if (TRUE) {
[11:02:39.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:39.973]                     {
[11:02:39.973]                       inherits <- base::inherits
[11:02:39.973]                       invokeRestart <- base::invokeRestart
[11:02:39.973]                       is.null <- base::is.null
[11:02:39.973]                       muffled <- FALSE
[11:02:39.973]                       if (inherits(cond, "message")) {
[11:02:39.973]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:39.973]                         if (muffled) 
[11:02:39.973]                           invokeRestart("muffleMessage")
[11:02:39.973]                       }
[11:02:39.973]                       else if (inherits(cond, "warning")) {
[11:02:39.973]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:39.973]                         if (muffled) 
[11:02:39.973]                           invokeRestart("muffleWarning")
[11:02:39.973]                       }
[11:02:39.973]                       else if (inherits(cond, "condition")) {
[11:02:39.973]                         if (!is.null(pattern)) {
[11:02:39.973]                           computeRestarts <- base::computeRestarts
[11:02:39.973]                           grepl <- base::grepl
[11:02:39.973]                           restarts <- computeRestarts(cond)
[11:02:39.973]                           for (restart in restarts) {
[11:02:39.973]                             name <- restart$name
[11:02:39.973]                             if (is.null(name)) 
[11:02:39.973]                               next
[11:02:39.973]                             if (!grepl(pattern, name)) 
[11:02:39.973]                               next
[11:02:39.973]                             invokeRestart(restart)
[11:02:39.973]                             muffled <- TRUE
[11:02:39.973]                             break
[11:02:39.973]                           }
[11:02:39.973]                         }
[11:02:39.973]                       }
[11:02:39.973]                       invisible(muffled)
[11:02:39.973]                     }
[11:02:39.973]                     muffleCondition(cond, pattern = "^muffle")
[11:02:39.973]                   }
[11:02:39.973]                 }
[11:02:39.973]             }
[11:02:39.973]         }))
[11:02:39.973]     }, error = function(ex) {
[11:02:39.973]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:39.973]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:39.973]                 ...future.rng), started = ...future.startTime, 
[11:02:39.973]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:39.973]             version = "1.8"), class = "FutureResult")
[11:02:39.973]     }, finally = {
[11:02:39.973]         if (!identical(...future.workdir, getwd())) 
[11:02:39.973]             setwd(...future.workdir)
[11:02:39.973]         {
[11:02:39.973]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:39.973]                 ...future.oldOptions$nwarnings <- NULL
[11:02:39.973]             }
[11:02:39.973]             base::options(...future.oldOptions)
[11:02:39.973]             if (.Platform$OS.type == "windows") {
[11:02:39.973]                 old_names <- names(...future.oldEnvVars)
[11:02:39.973]                 envs <- base::Sys.getenv()
[11:02:39.973]                 names <- names(envs)
[11:02:39.973]                 common <- intersect(names, old_names)
[11:02:39.973]                 added <- setdiff(names, old_names)
[11:02:39.973]                 removed <- setdiff(old_names, names)
[11:02:39.973]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:39.973]                   envs[common]]
[11:02:39.973]                 NAMES <- toupper(changed)
[11:02:39.973]                 args <- list()
[11:02:39.973]                 for (kk in seq_along(NAMES)) {
[11:02:39.973]                   name <- changed[[kk]]
[11:02:39.973]                   NAME <- NAMES[[kk]]
[11:02:39.973]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.973]                     next
[11:02:39.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:39.973]                 }
[11:02:39.973]                 NAMES <- toupper(added)
[11:02:39.973]                 for (kk in seq_along(NAMES)) {
[11:02:39.973]                   name <- added[[kk]]
[11:02:39.973]                   NAME <- NAMES[[kk]]
[11:02:39.973]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.973]                     next
[11:02:39.973]                   args[[name]] <- ""
[11:02:39.973]                 }
[11:02:39.973]                 NAMES <- toupper(removed)
[11:02:39.973]                 for (kk in seq_along(NAMES)) {
[11:02:39.973]                   name <- removed[[kk]]
[11:02:39.973]                   NAME <- NAMES[[kk]]
[11:02:39.973]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:39.973]                     next
[11:02:39.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:39.973]                 }
[11:02:39.973]                 if (length(args) > 0) 
[11:02:39.973]                   base::do.call(base::Sys.setenv, args = args)
[11:02:39.973]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:39.973]             }
[11:02:39.973]             else {
[11:02:39.973]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:39.973]             }
[11:02:39.973]             {
[11:02:39.973]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:39.973]                   0L) {
[11:02:39.973]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:39.973]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:39.973]                   base::options(opts)
[11:02:39.973]                 }
[11:02:39.973]                 {
[11:02:39.973]                   {
[11:02:39.973]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:39.973]                     NULL
[11:02:39.973]                   }
[11:02:39.973]                   options(future.plan = NULL)
[11:02:39.973]                   if (is.na(NA_character_)) 
[11:02:39.973]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:39.973]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:39.973]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:39.973]                     .init = FALSE)
[11:02:39.973]                 }
[11:02:39.973]             }
[11:02:39.973]         }
[11:02:39.973]     })
[11:02:39.973]     if (TRUE) {
[11:02:39.973]         base::sink(type = "output", split = FALSE)
[11:02:39.973]         if (TRUE) {
[11:02:39.973]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:39.973]         }
[11:02:39.973]         else {
[11:02:39.973]             ...future.result["stdout"] <- base::list(NULL)
[11:02:39.973]         }
[11:02:39.973]         base::close(...future.stdout)
[11:02:39.973]         ...future.stdout <- NULL
[11:02:39.973]     }
[11:02:39.973]     ...future.result$conditions <- ...future.conditions
[11:02:39.973]     ...future.result$finished <- base::Sys.time()
[11:02:39.973]     ...future.result
[11:02:39.973] }
[11:02:39.977] requestCore(): workers = 2
[11:02:39.977] Poll #1 (0): usedCores() = 2, workers = 2
[11:02:39.988] result() for MulticoreFuture ...
[11:02:39.989] result() for MulticoreFuture ...
[11:02:39.989] result() for MulticoreFuture ... done
[11:02:39.989] result() for MulticoreFuture ... done
[11:02:39.990] result() for MulticoreFuture ...
[11:02:39.990] result() for MulticoreFuture ... done
[11:02:39.992] MulticoreFuture started
[11:02:39.993] - Launch lazy future ... done
[11:02:39.993] run() for ‘MulticoreFuture’ ... done
[11:02:39.993] plan(): Setting new future strategy stack:
[11:02:39.994] List of future strategies:
[11:02:39.994] 1. sequential:
[11:02:39.994]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:39.994]    - tweaked: FALSE
[11:02:39.994]    - call: NULL
[11:02:39.995] resolve() on list environment ...
[11:02:39.995] plan(): nbrOfWorkers() = 1
[11:02:39.995]  recursive: 0
[11:02:39.996]  length: 4
[11:02:39.996]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[11:02:39.996] Future #1
[11:02:39.996]  length: 3 (resolved future 1)
[11:02:39.997] plan(): Setting new future strategy stack:
[11:02:39.997] List of future strategies:
[11:02:39.997] 1. multicore:
[11:02:39.997]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:39.997]    - tweaked: FALSE
[11:02:39.997]    - call: plan(strategy)
[11:02:40.000] plan(): nbrOfWorkers() = 2
[11:02:40.007] Future #3
[11:02:40.007]  length: 2 (resolved future 3)
[11:02:40.008]  length: 1 (resolved future 4)
[11:02:40.465] plan(): Setting new future strategy stack:
[11:02:40.465] List of future strategies:
[11:02:40.465] 1. multicore:
[11:02:40.465]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:40.465]    - tweaked: FALSE
[11:02:40.465]    - call: plan(strategy)
[11:02:40.468] plan(): nbrOfWorkers() = 2
[11:02:40.468] Future #2
[11:02:40.469]  length: 0 (resolved future 2)
[11:02:40.469] resolve() on list environment ... DONE
[11:02:40.469] resolve() on list environment ...
[11:02:40.469]  recursive: 0
[11:02:40.470]  length: 4
[11:02:40.470]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[11:02:40.471] Future #1
[11:02:40.471]  length: 3 (resolved future 1)
[11:02:40.471] Future #2
[11:02:40.471]  length: 2 (resolved future 2)
[11:02:40.472] Future #3
[11:02:40.472]  length: 1 (resolved future 3)
[11:02:40.472]  length: 0 (resolved future 4)
[11:02:40.472] resolve() on list environment ... DONE
[11:02:40.477] resolve() on list environment ...
[11:02:40.478]  recursive: 0
[11:02:40.480]  length: 4
[11:02:40.480]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[11:02:40.480] Future #1
[11:02:40.481]  length: 3 (resolved future 1)
[11:02:40.481] Future #2
[11:02:40.481]  length: 2 (resolved future 2)
[11:02:40.481] Future #3
[11:02:40.482]  length: 1 (resolved future 3)
[11:02:40.482]  length: 0 (resolved future 4)
[11:02:40.482] resolve() on list environment ... DONE
[11:02:40.483] resolve() on list environment ...
[11:02:40.483]  recursive: 0
[11:02:40.484]  length: 4
[11:02:40.484]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[11:02:40.485] Future #1
[11:02:40.485]  length: 3 (resolved future 1)
[11:02:40.485] Future #2
[11:02:40.485]  length: 2 (resolved future 2)
[11:02:40.486] Future #3
[11:02:40.486]  length: 1 (resolved future 3)
[11:02:40.486]  length: 0 (resolved future 4)
[11:02:40.486] resolve() on list environment ... DONE
[11:02:40.487] resolve() on list environment ...
[11:02:40.487]  recursive: 0
[11:02:40.488]  length: 4
[11:02:40.488]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[11:02:40.488] Future #1
[11:02:40.488] result() for MulticoreFuture ...
[11:02:40.488] result() for MulticoreFuture ... done
[11:02:40.488] result() for MulticoreFuture ...
[11:02:40.489] result() for MulticoreFuture ... done
[11:02:40.489]  length: 3 (resolved future 1)
[11:02:40.489] Future #2
[11:02:40.489] result() for MulticoreFuture ...
[11:02:40.490] result() for MulticoreFuture ...
[11:02:40.490] result() for MulticoreFuture ... done
[11:02:40.490] result() for MulticoreFuture ... done
[11:02:40.490] result() for MulticoreFuture ...
[11:02:40.490] result() for MulticoreFuture ... done
[11:02:40.491]  length: 2 (resolved future 2)
[11:02:40.491] Future #3
[11:02:40.491] result() for MulticoreFuture ...
[11:02:40.492] result() for MulticoreFuture ...
[11:02:40.492] result() for MulticoreFuture ... done
[11:02:40.492] result() for MulticoreFuture ... done
[11:02:40.492] result() for MulticoreFuture ...
[11:02:40.492] result() for MulticoreFuture ... done
[11:02:40.492]  length: 1 (resolved future 3)
[11:02:40.492]  length: 0 (resolved future 4)
[11:02:40.493] resolve() on list environment ... DONE
[11:02:40.493] resolve() on list environment ...
[11:02:40.493]  recursive: 99
[11:02:40.494]  length: 4
[11:02:40.494]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[11:02:40.494] Future #1
[11:02:40.494] result() for MulticoreFuture ...
[11:02:40.495] result() for MulticoreFuture ... done
[11:02:40.495] result() for MulticoreFuture ...
[11:02:40.495] result() for MulticoreFuture ... done
[11:02:40.495] A MulticoreFuture was resolved
[11:02:40.495]  length: 3 (resolved future 1)
[11:02:40.495] Future #2
[11:02:40.495] result() for MulticoreFuture ...
[11:02:40.495] result() for MulticoreFuture ... done
[11:02:40.496] result() for MulticoreFuture ...
[11:02:40.496] result() for MulticoreFuture ... done
[11:02:40.496] A MulticoreFuture was resolved
[11:02:40.496]  length: 2 (resolved future 2)
[11:02:40.496] Future #3
[11:02:40.496] result() for MulticoreFuture ...
[11:02:40.496] result() for MulticoreFuture ... done
[11:02:40.496] result() for MulticoreFuture ...
[11:02:40.496] result() for MulticoreFuture ... done
[11:02:40.497] A MulticoreFuture was resolved
[11:02:40.497]  length: 1 (resolved future 3)
[11:02:40.497]  length: 0 (resolved future 4)
[11:02:40.497] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('multicore') ...
- plan('multisession') ...
[11:02:40.498] plan(): Setting new future strategy stack:
[11:02:40.498] List of future strategies:
[11:02:40.498] 1. multisession:
[11:02:40.498]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:02:40.498]    - tweaked: FALSE
[11:02:40.498]    - call: plan(strategy)
[11:02:40.498] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[11:02:40.498] multisession:
[11:02:40.498] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:02:40.498] - tweaked: FALSE
[11:02:40.498] - call: plan(strategy)
[11:02:40.502] getGlobalsAndPackages() ...
[11:02:40.502] Not searching for globals
[11:02:40.502] - globals: [0] <none>
[11:02:40.502] getGlobalsAndPackages() ... DONE
[11:02:40.991] Packages needed by the future expression (n = 0): <none>
[11:02:40.991] Packages needed by future strategies (n = 0): <none>
[11:02:40.991] {
[11:02:40.991]     {
[11:02:40.991]         {
[11:02:40.991]             ...future.startTime <- base::Sys.time()
[11:02:40.991]             {
[11:02:40.991]                 {
[11:02:40.991]                   {
[11:02:40.991]                     {
[11:02:40.991]                       base::local({
[11:02:40.991]                         has_future <- base::requireNamespace("future", 
[11:02:40.991]                           quietly = TRUE)
[11:02:40.991]                         if (has_future) {
[11:02:40.991]                           ns <- base::getNamespace("future")
[11:02:40.991]                           version <- ns[[".package"]][["version"]]
[11:02:40.991]                           if (is.null(version)) 
[11:02:40.991]                             version <- utils::packageVersion("future")
[11:02:40.991]                         }
[11:02:40.991]                         else {
[11:02:40.991]                           version <- NULL
[11:02:40.991]                         }
[11:02:40.991]                         if (!has_future || version < "1.8.0") {
[11:02:40.991]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:40.991]                             "", base::R.version$version.string), 
[11:02:40.991]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:40.991]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:40.991]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:40.991]                               "release", "version")], collapse = " "), 
[11:02:40.991]                             hostname = base::Sys.info()[["nodename"]])
[11:02:40.991]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:40.991]                             info)
[11:02:40.991]                           info <- base::paste(info, collapse = "; ")
[11:02:40.991]                           if (!has_future) {
[11:02:40.991]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:40.991]                               info)
[11:02:40.991]                           }
[11:02:40.991]                           else {
[11:02:40.991]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:40.991]                               info, version)
[11:02:40.991]                           }
[11:02:40.991]                           base::stop(msg)
[11:02:40.991]                         }
[11:02:40.991]                       })
[11:02:40.991]                     }
[11:02:40.991]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:40.991]                     base::options(mc.cores = 1L)
[11:02:40.991]                   }
[11:02:40.991]                   ...future.strategy.old <- future::plan("list")
[11:02:40.991]                   options(future.plan = NULL)
[11:02:40.991]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:40.991]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:40.991]                 }
[11:02:40.991]                 ...future.workdir <- getwd()
[11:02:40.991]             }
[11:02:40.991]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:40.991]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:40.991]         }
[11:02:40.991]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:40.991]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:40.991]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:40.991]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:40.991]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:40.991]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:40.991]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:40.991]             base::names(...future.oldOptions))
[11:02:40.991]     }
[11:02:40.991]     if (FALSE) {
[11:02:40.991]     }
[11:02:40.991]     else {
[11:02:40.991]         if (TRUE) {
[11:02:40.991]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:40.991]                 open = "w")
[11:02:40.991]         }
[11:02:40.991]         else {
[11:02:40.991]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:40.991]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:40.991]         }
[11:02:40.991]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:40.991]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:40.991]             base::sink(type = "output", split = FALSE)
[11:02:40.991]             base::close(...future.stdout)
[11:02:40.991]         }, add = TRUE)
[11:02:40.991]     }
[11:02:40.991]     ...future.frame <- base::sys.nframe()
[11:02:40.991]     ...future.conditions <- base::list()
[11:02:40.991]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:40.991]     if (FALSE) {
[11:02:40.991]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:40.991]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:40.991]     }
[11:02:40.991]     ...future.result <- base::tryCatch({
[11:02:40.991]         base::withCallingHandlers({
[11:02:40.991]             ...future.value <- base::withVisible(base::local({
[11:02:40.991]                 ...future.makeSendCondition <- base::local({
[11:02:40.991]                   sendCondition <- NULL
[11:02:40.991]                   function(frame = 1L) {
[11:02:40.991]                     if (is.function(sendCondition)) 
[11:02:40.991]                       return(sendCondition)
[11:02:40.991]                     ns <- getNamespace("parallel")
[11:02:40.991]                     if (exists("sendData", mode = "function", 
[11:02:40.991]                       envir = ns)) {
[11:02:40.991]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:40.991]                         envir = ns)
[11:02:40.991]                       envir <- sys.frame(frame)
[11:02:40.991]                       master <- NULL
[11:02:40.991]                       while (!identical(envir, .GlobalEnv) && 
[11:02:40.991]                         !identical(envir, emptyenv())) {
[11:02:40.991]                         if (exists("master", mode = "list", envir = envir, 
[11:02:40.991]                           inherits = FALSE)) {
[11:02:40.991]                           master <- get("master", mode = "list", 
[11:02:40.991]                             envir = envir, inherits = FALSE)
[11:02:40.991]                           if (inherits(master, c("SOCKnode", 
[11:02:40.991]                             "SOCK0node"))) {
[11:02:40.991]                             sendCondition <<- function(cond) {
[11:02:40.991]                               data <- list(type = "VALUE", value = cond, 
[11:02:40.991]                                 success = TRUE)
[11:02:40.991]                               parallel_sendData(master, data)
[11:02:40.991]                             }
[11:02:40.991]                             return(sendCondition)
[11:02:40.991]                           }
[11:02:40.991]                         }
[11:02:40.991]                         frame <- frame + 1L
[11:02:40.991]                         envir <- sys.frame(frame)
[11:02:40.991]                       }
[11:02:40.991]                     }
[11:02:40.991]                     sendCondition <<- function(cond) NULL
[11:02:40.991]                   }
[11:02:40.991]                 })
[11:02:40.991]                 withCallingHandlers({
[11:02:40.991]                   NA
[11:02:40.991]                 }, immediateCondition = function(cond) {
[11:02:40.991]                   sendCondition <- ...future.makeSendCondition()
[11:02:40.991]                   sendCondition(cond)
[11:02:40.991]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:40.991]                   {
[11:02:40.991]                     inherits <- base::inherits
[11:02:40.991]                     invokeRestart <- base::invokeRestart
[11:02:40.991]                     is.null <- base::is.null
[11:02:40.991]                     muffled <- FALSE
[11:02:40.991]                     if (inherits(cond, "message")) {
[11:02:40.991]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:40.991]                       if (muffled) 
[11:02:40.991]                         invokeRestart("muffleMessage")
[11:02:40.991]                     }
[11:02:40.991]                     else if (inherits(cond, "warning")) {
[11:02:40.991]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:40.991]                       if (muffled) 
[11:02:40.991]                         invokeRestart("muffleWarning")
[11:02:40.991]                     }
[11:02:40.991]                     else if (inherits(cond, "condition")) {
[11:02:40.991]                       if (!is.null(pattern)) {
[11:02:40.991]                         computeRestarts <- base::computeRestarts
[11:02:40.991]                         grepl <- base::grepl
[11:02:40.991]                         restarts <- computeRestarts(cond)
[11:02:40.991]                         for (restart in restarts) {
[11:02:40.991]                           name <- restart$name
[11:02:40.991]                           if (is.null(name)) 
[11:02:40.991]                             next
[11:02:40.991]                           if (!grepl(pattern, name)) 
[11:02:40.991]                             next
[11:02:40.991]                           invokeRestart(restart)
[11:02:40.991]                           muffled <- TRUE
[11:02:40.991]                           break
[11:02:40.991]                         }
[11:02:40.991]                       }
[11:02:40.991]                     }
[11:02:40.991]                     invisible(muffled)
[11:02:40.991]                   }
[11:02:40.991]                   muffleCondition(cond)
[11:02:40.991]                 })
[11:02:40.991]             }))
[11:02:40.991]             future::FutureResult(value = ...future.value$value, 
[11:02:40.991]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:40.991]                   ...future.rng), globalenv = if (FALSE) 
[11:02:40.991]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:40.991]                     ...future.globalenv.names))
[11:02:40.991]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:40.991]         }, condition = base::local({
[11:02:40.991]             c <- base::c
[11:02:40.991]             inherits <- base::inherits
[11:02:40.991]             invokeRestart <- base::invokeRestart
[11:02:40.991]             length <- base::length
[11:02:40.991]             list <- base::list
[11:02:40.991]             seq.int <- base::seq.int
[11:02:40.991]             signalCondition <- base::signalCondition
[11:02:40.991]             sys.calls <- base::sys.calls
[11:02:40.991]             `[[` <- base::`[[`
[11:02:40.991]             `+` <- base::`+`
[11:02:40.991]             `<<-` <- base::`<<-`
[11:02:40.991]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:40.991]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:40.991]                   3L)]
[11:02:40.991]             }
[11:02:40.991]             function(cond) {
[11:02:40.991]                 is_error <- inherits(cond, "error")
[11:02:40.991]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:40.991]                   NULL)
[11:02:40.991]                 if (is_error) {
[11:02:40.991]                   sessionInformation <- function() {
[11:02:40.991]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:40.991]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:40.991]                       search = base::search(), system = base::Sys.info())
[11:02:40.991]                   }
[11:02:40.991]                   ...future.conditions[[length(...future.conditions) + 
[11:02:40.991]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:40.991]                     cond$call), session = sessionInformation(), 
[11:02:40.991]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:40.991]                   signalCondition(cond)
[11:02:40.991]                 }
[11:02:40.991]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:40.991]                 "immediateCondition"))) {
[11:02:40.991]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:40.991]                   ...future.conditions[[length(...future.conditions) + 
[11:02:40.991]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:40.991]                   if (TRUE && !signal) {
[11:02:40.991]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:40.991]                     {
[11:02:40.991]                       inherits <- base::inherits
[11:02:40.991]                       invokeRestart <- base::invokeRestart
[11:02:40.991]                       is.null <- base::is.null
[11:02:40.991]                       muffled <- FALSE
[11:02:40.991]                       if (inherits(cond, "message")) {
[11:02:40.991]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:40.991]                         if (muffled) 
[11:02:40.991]                           invokeRestart("muffleMessage")
[11:02:40.991]                       }
[11:02:40.991]                       else if (inherits(cond, "warning")) {
[11:02:40.991]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:40.991]                         if (muffled) 
[11:02:40.991]                           invokeRestart("muffleWarning")
[11:02:40.991]                       }
[11:02:40.991]                       else if (inherits(cond, "condition")) {
[11:02:40.991]                         if (!is.null(pattern)) {
[11:02:40.991]                           computeRestarts <- base::computeRestarts
[11:02:40.991]                           grepl <- base::grepl
[11:02:40.991]                           restarts <- computeRestarts(cond)
[11:02:40.991]                           for (restart in restarts) {
[11:02:40.991]                             name <- restart$name
[11:02:40.991]                             if (is.null(name)) 
[11:02:40.991]                               next
[11:02:40.991]                             if (!grepl(pattern, name)) 
[11:02:40.991]                               next
[11:02:40.991]                             invokeRestart(restart)
[11:02:40.991]                             muffled <- TRUE
[11:02:40.991]                             break
[11:02:40.991]                           }
[11:02:40.991]                         }
[11:02:40.991]                       }
[11:02:40.991]                       invisible(muffled)
[11:02:40.991]                     }
[11:02:40.991]                     muffleCondition(cond, pattern = "^muffle")
[11:02:40.991]                   }
[11:02:40.991]                 }
[11:02:40.991]                 else {
[11:02:40.991]                   if (TRUE) {
[11:02:40.991]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:40.991]                     {
[11:02:40.991]                       inherits <- base::inherits
[11:02:40.991]                       invokeRestart <- base::invokeRestart
[11:02:40.991]                       is.null <- base::is.null
[11:02:40.991]                       muffled <- FALSE
[11:02:40.991]                       if (inherits(cond, "message")) {
[11:02:40.991]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:40.991]                         if (muffled) 
[11:02:40.991]                           invokeRestart("muffleMessage")
[11:02:40.991]                       }
[11:02:40.991]                       else if (inherits(cond, "warning")) {
[11:02:40.991]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:40.991]                         if (muffled) 
[11:02:40.991]                           invokeRestart("muffleWarning")
[11:02:40.991]                       }
[11:02:40.991]                       else if (inherits(cond, "condition")) {
[11:02:40.991]                         if (!is.null(pattern)) {
[11:02:40.991]                           computeRestarts <- base::computeRestarts
[11:02:40.991]                           grepl <- base::grepl
[11:02:40.991]                           restarts <- computeRestarts(cond)
[11:02:40.991]                           for (restart in restarts) {
[11:02:40.991]                             name <- restart$name
[11:02:40.991]                             if (is.null(name)) 
[11:02:40.991]                               next
[11:02:40.991]                             if (!grepl(pattern, name)) 
[11:02:40.991]                               next
[11:02:40.991]                             invokeRestart(restart)
[11:02:40.991]                             muffled <- TRUE
[11:02:40.991]                             break
[11:02:40.991]                           }
[11:02:40.991]                         }
[11:02:40.991]                       }
[11:02:40.991]                       invisible(muffled)
[11:02:40.991]                     }
[11:02:40.991]                     muffleCondition(cond, pattern = "^muffle")
[11:02:40.991]                   }
[11:02:40.991]                 }
[11:02:40.991]             }
[11:02:40.991]         }))
[11:02:40.991]     }, error = function(ex) {
[11:02:40.991]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:40.991]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:40.991]                 ...future.rng), started = ...future.startTime, 
[11:02:40.991]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:40.991]             version = "1.8"), class = "FutureResult")
[11:02:40.991]     }, finally = {
[11:02:40.991]         if (!identical(...future.workdir, getwd())) 
[11:02:40.991]             setwd(...future.workdir)
[11:02:40.991]         {
[11:02:40.991]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:40.991]                 ...future.oldOptions$nwarnings <- NULL
[11:02:40.991]             }
[11:02:40.991]             base::options(...future.oldOptions)
[11:02:40.991]             if (.Platform$OS.type == "windows") {
[11:02:40.991]                 old_names <- names(...future.oldEnvVars)
[11:02:40.991]                 envs <- base::Sys.getenv()
[11:02:40.991]                 names <- names(envs)
[11:02:40.991]                 common <- intersect(names, old_names)
[11:02:40.991]                 added <- setdiff(names, old_names)
[11:02:40.991]                 removed <- setdiff(old_names, names)
[11:02:40.991]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:40.991]                   envs[common]]
[11:02:40.991]                 NAMES <- toupper(changed)
[11:02:40.991]                 args <- list()
[11:02:40.991]                 for (kk in seq_along(NAMES)) {
[11:02:40.991]                   name <- changed[[kk]]
[11:02:40.991]                   NAME <- NAMES[[kk]]
[11:02:40.991]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:40.991]                     next
[11:02:40.991]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:40.991]                 }
[11:02:40.991]                 NAMES <- toupper(added)
[11:02:40.991]                 for (kk in seq_along(NAMES)) {
[11:02:40.991]                   name <- added[[kk]]
[11:02:40.991]                   NAME <- NAMES[[kk]]
[11:02:40.991]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:40.991]                     next
[11:02:40.991]                   args[[name]] <- ""
[11:02:40.991]                 }
[11:02:40.991]                 NAMES <- toupper(removed)
[11:02:40.991]                 for (kk in seq_along(NAMES)) {
[11:02:40.991]                   name <- removed[[kk]]
[11:02:40.991]                   NAME <- NAMES[[kk]]
[11:02:40.991]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:40.991]                     next
[11:02:40.991]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:40.991]                 }
[11:02:40.991]                 if (length(args) > 0) 
[11:02:40.991]                   base::do.call(base::Sys.setenv, args = args)
[11:02:40.991]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:40.991]             }
[11:02:40.991]             else {
[11:02:40.991]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:40.991]             }
[11:02:40.991]             {
[11:02:40.991]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:40.991]                   0L) {
[11:02:40.991]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:40.991]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:40.991]                   base::options(opts)
[11:02:40.991]                 }
[11:02:40.991]                 {
[11:02:40.991]                   {
[11:02:40.991]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:40.991]                     NULL
[11:02:40.991]                   }
[11:02:40.991]                   options(future.plan = NULL)
[11:02:40.991]                   if (is.na(NA_character_)) 
[11:02:40.991]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:40.991]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:40.991]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:40.991]                     .init = FALSE)
[11:02:40.991]                 }
[11:02:40.991]             }
[11:02:40.991]         }
[11:02:40.991]     })
[11:02:40.991]     if (TRUE) {
[11:02:40.991]         base::sink(type = "output", split = FALSE)
[11:02:40.991]         if (TRUE) {
[11:02:40.991]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:40.991]         }
[11:02:40.991]         else {
[11:02:40.991]             ...future.result["stdout"] <- base::list(NULL)
[11:02:40.991]         }
[11:02:40.991]         base::close(...future.stdout)
[11:02:40.991]         ...future.stdout <- NULL
[11:02:40.991]     }
[11:02:40.991]     ...future.result$conditions <- ...future.conditions
[11:02:40.991]     ...future.result$finished <- base::Sys.time()
[11:02:40.991]     ...future.result
[11:02:40.991] }
[11:02:41.042] MultisessionFuture started
[11:02:41.043] result() for ClusterFuture ...
[11:02:41.043] receiveMessageFromWorker() for ClusterFuture ...
[11:02:41.043] - Validating connection of MultisessionFuture
[11:02:41.073] - received message: FutureResult
[11:02:41.074] - Received FutureResult
[11:02:41.074] - Erased future from FutureRegistry
[11:02:41.074] result() for ClusterFuture ...
[11:02:41.074] - result already collected: FutureResult
[11:02:41.074] result() for ClusterFuture ... done
[11:02:41.074] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:41.074] result() for ClusterFuture ... done
[11:02:41.074] result() for ClusterFuture ...
[11:02:41.074] - result already collected: FutureResult
[11:02:41.074] result() for ClusterFuture ... done
[11:02:41.074] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[11:02:41.076] plan(): nbrOfWorkers() = 2
*** resolve() for Future objects ...
- result = FALSE, recursive = FALSE ...
[11:02:41.077] getGlobalsAndPackages() ...
[11:02:41.077] Searching for globals...
[11:02:41.079] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[11:02:41.079] Searching for globals ... DONE
[11:02:41.079] Resolving globals: FALSE
[11:02:41.079] 
[11:02:41.079] 
[11:02:41.079] getGlobalsAndPackages() ... DONE
[11:02:41.080] run() for ‘Future’ ...
[11:02:41.080] - state: ‘created’
[11:02:41.080] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:41.093] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:41.093] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:41.094]   - Field: ‘node’
[11:02:41.094]   - Field: ‘label’
[11:02:41.094]   - Field: ‘local’
[11:02:41.094]   - Field: ‘owner’
[11:02:41.094]   - Field: ‘envir’
[11:02:41.094]   - Field: ‘workers’
[11:02:41.094]   - Field: ‘packages’
[11:02:41.094]   - Field: ‘gc’
[11:02:41.094]   - Field: ‘conditions’
[11:02:41.094]   - Field: ‘persistent’
[11:02:41.094]   - Field: ‘expr’
[11:02:41.095]   - Field: ‘uuid’
[11:02:41.095]   - Field: ‘seed’
[11:02:41.095]   - Field: ‘version’
[11:02:41.095]   - Field: ‘result’
[11:02:41.095]   - Field: ‘asynchronous’
[11:02:41.095]   - Field: ‘calls’
[11:02:41.095]   - Field: ‘globals’
[11:02:41.095]   - Field: ‘stdout’
[11:02:41.095]   - Field: ‘earlySignal’
[11:02:41.095]   - Field: ‘lazy’
[11:02:41.095]   - Field: ‘state’
[11:02:41.095] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:41.096] - Launch lazy future ...
[11:02:41.096] Packages needed by the future expression (n = 0): <none>
[11:02:41.096] Packages needed by future strategies (n = 0): <none>
[11:02:41.096] {
[11:02:41.096]     {
[11:02:41.096]         {
[11:02:41.096]             ...future.startTime <- base::Sys.time()
[11:02:41.096]             {
[11:02:41.096]                 {
[11:02:41.096]                   {
[11:02:41.096]                     {
[11:02:41.096]                       base::local({
[11:02:41.096]                         has_future <- base::requireNamespace("future", 
[11:02:41.096]                           quietly = TRUE)
[11:02:41.096]                         if (has_future) {
[11:02:41.096]                           ns <- base::getNamespace("future")
[11:02:41.096]                           version <- ns[[".package"]][["version"]]
[11:02:41.096]                           if (is.null(version)) 
[11:02:41.096]                             version <- utils::packageVersion("future")
[11:02:41.096]                         }
[11:02:41.096]                         else {
[11:02:41.096]                           version <- NULL
[11:02:41.096]                         }
[11:02:41.096]                         if (!has_future || version < "1.8.0") {
[11:02:41.096]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:41.096]                             "", base::R.version$version.string), 
[11:02:41.096]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:41.096]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:41.096]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:41.096]                               "release", "version")], collapse = " "), 
[11:02:41.096]                             hostname = base::Sys.info()[["nodename"]])
[11:02:41.096]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:41.096]                             info)
[11:02:41.096]                           info <- base::paste(info, collapse = "; ")
[11:02:41.096]                           if (!has_future) {
[11:02:41.096]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:41.096]                               info)
[11:02:41.096]                           }
[11:02:41.096]                           else {
[11:02:41.096]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:41.096]                               info, version)
[11:02:41.096]                           }
[11:02:41.096]                           base::stop(msg)
[11:02:41.096]                         }
[11:02:41.096]                       })
[11:02:41.096]                     }
[11:02:41.096]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:41.096]                     base::options(mc.cores = 1L)
[11:02:41.096]                   }
[11:02:41.096]                   ...future.strategy.old <- future::plan("list")
[11:02:41.096]                   options(future.plan = NULL)
[11:02:41.096]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:41.096]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:41.096]                 }
[11:02:41.096]                 ...future.workdir <- getwd()
[11:02:41.096]             }
[11:02:41.096]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:41.096]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:41.096]         }
[11:02:41.096]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:41.096]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:41.096]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:41.096]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:41.096]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:41.096]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:41.096]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:41.096]             base::names(...future.oldOptions))
[11:02:41.096]     }
[11:02:41.096]     if (FALSE) {
[11:02:41.096]     }
[11:02:41.096]     else {
[11:02:41.096]         if (TRUE) {
[11:02:41.096]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:41.096]                 open = "w")
[11:02:41.096]         }
[11:02:41.096]         else {
[11:02:41.096]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:41.096]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:41.096]         }
[11:02:41.096]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:41.096]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:41.096]             base::sink(type = "output", split = FALSE)
[11:02:41.096]             base::close(...future.stdout)
[11:02:41.096]         }, add = TRUE)
[11:02:41.096]     }
[11:02:41.096]     ...future.frame <- base::sys.nframe()
[11:02:41.096]     ...future.conditions <- base::list()
[11:02:41.096]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:41.096]     if (FALSE) {
[11:02:41.096]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:41.096]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:41.096]     }
[11:02:41.096]     ...future.result <- base::tryCatch({
[11:02:41.096]         base::withCallingHandlers({
[11:02:41.096]             ...future.value <- base::withVisible(base::local({
[11:02:41.096]                 ...future.makeSendCondition <- base::local({
[11:02:41.096]                   sendCondition <- NULL
[11:02:41.096]                   function(frame = 1L) {
[11:02:41.096]                     if (is.function(sendCondition)) 
[11:02:41.096]                       return(sendCondition)
[11:02:41.096]                     ns <- getNamespace("parallel")
[11:02:41.096]                     if (exists("sendData", mode = "function", 
[11:02:41.096]                       envir = ns)) {
[11:02:41.096]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:41.096]                         envir = ns)
[11:02:41.096]                       envir <- sys.frame(frame)
[11:02:41.096]                       master <- NULL
[11:02:41.096]                       while (!identical(envir, .GlobalEnv) && 
[11:02:41.096]                         !identical(envir, emptyenv())) {
[11:02:41.096]                         if (exists("master", mode = "list", envir = envir, 
[11:02:41.096]                           inherits = FALSE)) {
[11:02:41.096]                           master <- get("master", mode = "list", 
[11:02:41.096]                             envir = envir, inherits = FALSE)
[11:02:41.096]                           if (inherits(master, c("SOCKnode", 
[11:02:41.096]                             "SOCK0node"))) {
[11:02:41.096]                             sendCondition <<- function(cond) {
[11:02:41.096]                               data <- list(type = "VALUE", value = cond, 
[11:02:41.096]                                 success = TRUE)
[11:02:41.096]                               parallel_sendData(master, data)
[11:02:41.096]                             }
[11:02:41.096]                             return(sendCondition)
[11:02:41.096]                           }
[11:02:41.096]                         }
[11:02:41.096]                         frame <- frame + 1L
[11:02:41.096]                         envir <- sys.frame(frame)
[11:02:41.096]                       }
[11:02:41.096]                     }
[11:02:41.096]                     sendCondition <<- function(cond) NULL
[11:02:41.096]                   }
[11:02:41.096]                 })
[11:02:41.096]                 withCallingHandlers({
[11:02:41.096]                   {
[11:02:41.096]                     Sys.sleep(0.5)
[11:02:41.096]                     list(a = 1, b = 42L)
[11:02:41.096]                   }
[11:02:41.096]                 }, immediateCondition = function(cond) {
[11:02:41.096]                   sendCondition <- ...future.makeSendCondition()
[11:02:41.096]                   sendCondition(cond)
[11:02:41.096]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:41.096]                   {
[11:02:41.096]                     inherits <- base::inherits
[11:02:41.096]                     invokeRestart <- base::invokeRestart
[11:02:41.096]                     is.null <- base::is.null
[11:02:41.096]                     muffled <- FALSE
[11:02:41.096]                     if (inherits(cond, "message")) {
[11:02:41.096]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:41.096]                       if (muffled) 
[11:02:41.096]                         invokeRestart("muffleMessage")
[11:02:41.096]                     }
[11:02:41.096]                     else if (inherits(cond, "warning")) {
[11:02:41.096]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:41.096]                       if (muffled) 
[11:02:41.096]                         invokeRestart("muffleWarning")
[11:02:41.096]                     }
[11:02:41.096]                     else if (inherits(cond, "condition")) {
[11:02:41.096]                       if (!is.null(pattern)) {
[11:02:41.096]                         computeRestarts <- base::computeRestarts
[11:02:41.096]                         grepl <- base::grepl
[11:02:41.096]                         restarts <- computeRestarts(cond)
[11:02:41.096]                         for (restart in restarts) {
[11:02:41.096]                           name <- restart$name
[11:02:41.096]                           if (is.null(name)) 
[11:02:41.096]                             next
[11:02:41.096]                           if (!grepl(pattern, name)) 
[11:02:41.096]                             next
[11:02:41.096]                           invokeRestart(restart)
[11:02:41.096]                           muffled <- TRUE
[11:02:41.096]                           break
[11:02:41.096]                         }
[11:02:41.096]                       }
[11:02:41.096]                     }
[11:02:41.096]                     invisible(muffled)
[11:02:41.096]                   }
[11:02:41.096]                   muffleCondition(cond)
[11:02:41.096]                 })
[11:02:41.096]             }))
[11:02:41.096]             future::FutureResult(value = ...future.value$value, 
[11:02:41.096]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:41.096]                   ...future.rng), globalenv = if (FALSE) 
[11:02:41.096]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:41.096]                     ...future.globalenv.names))
[11:02:41.096]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:41.096]         }, condition = base::local({
[11:02:41.096]             c <- base::c
[11:02:41.096]             inherits <- base::inherits
[11:02:41.096]             invokeRestart <- base::invokeRestart
[11:02:41.096]             length <- base::length
[11:02:41.096]             list <- base::list
[11:02:41.096]             seq.int <- base::seq.int
[11:02:41.096]             signalCondition <- base::signalCondition
[11:02:41.096]             sys.calls <- base::sys.calls
[11:02:41.096]             `[[` <- base::`[[`
[11:02:41.096]             `+` <- base::`+`
[11:02:41.096]             `<<-` <- base::`<<-`
[11:02:41.096]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:41.096]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:41.096]                   3L)]
[11:02:41.096]             }
[11:02:41.096]             function(cond) {
[11:02:41.096]                 is_error <- inherits(cond, "error")
[11:02:41.096]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:41.096]                   NULL)
[11:02:41.096]                 if (is_error) {
[11:02:41.096]                   sessionInformation <- function() {
[11:02:41.096]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:41.096]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:41.096]                       search = base::search(), system = base::Sys.info())
[11:02:41.096]                   }
[11:02:41.096]                   ...future.conditions[[length(...future.conditions) + 
[11:02:41.096]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:41.096]                     cond$call), session = sessionInformation(), 
[11:02:41.096]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:41.096]                   signalCondition(cond)
[11:02:41.096]                 }
[11:02:41.096]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:41.096]                 "immediateCondition"))) {
[11:02:41.096]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:41.096]                   ...future.conditions[[length(...future.conditions) + 
[11:02:41.096]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:41.096]                   if (TRUE && !signal) {
[11:02:41.096]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:41.096]                     {
[11:02:41.096]                       inherits <- base::inherits
[11:02:41.096]                       invokeRestart <- base::invokeRestart
[11:02:41.096]                       is.null <- base::is.null
[11:02:41.096]                       muffled <- FALSE
[11:02:41.096]                       if (inherits(cond, "message")) {
[11:02:41.096]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:41.096]                         if (muffled) 
[11:02:41.096]                           invokeRestart("muffleMessage")
[11:02:41.096]                       }
[11:02:41.096]                       else if (inherits(cond, "warning")) {
[11:02:41.096]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:41.096]                         if (muffled) 
[11:02:41.096]                           invokeRestart("muffleWarning")
[11:02:41.096]                       }
[11:02:41.096]                       else if (inherits(cond, "condition")) {
[11:02:41.096]                         if (!is.null(pattern)) {
[11:02:41.096]                           computeRestarts <- base::computeRestarts
[11:02:41.096]                           grepl <- base::grepl
[11:02:41.096]                           restarts <- computeRestarts(cond)
[11:02:41.096]                           for (restart in restarts) {
[11:02:41.096]                             name <- restart$name
[11:02:41.096]                             if (is.null(name)) 
[11:02:41.096]                               next
[11:02:41.096]                             if (!grepl(pattern, name)) 
[11:02:41.096]                               next
[11:02:41.096]                             invokeRestart(restart)
[11:02:41.096]                             muffled <- TRUE
[11:02:41.096]                             break
[11:02:41.096]                           }
[11:02:41.096]                         }
[11:02:41.096]                       }
[11:02:41.096]                       invisible(muffled)
[11:02:41.096]                     }
[11:02:41.096]                     muffleCondition(cond, pattern = "^muffle")
[11:02:41.096]                   }
[11:02:41.096]                 }
[11:02:41.096]                 else {
[11:02:41.096]                   if (TRUE) {
[11:02:41.096]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:41.096]                     {
[11:02:41.096]                       inherits <- base::inherits
[11:02:41.096]                       invokeRestart <- base::invokeRestart
[11:02:41.096]                       is.null <- base::is.null
[11:02:41.096]                       muffled <- FALSE
[11:02:41.096]                       if (inherits(cond, "message")) {
[11:02:41.096]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:41.096]                         if (muffled) 
[11:02:41.096]                           invokeRestart("muffleMessage")
[11:02:41.096]                       }
[11:02:41.096]                       else if (inherits(cond, "warning")) {
[11:02:41.096]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:41.096]                         if (muffled) 
[11:02:41.096]                           invokeRestart("muffleWarning")
[11:02:41.096]                       }
[11:02:41.096]                       else if (inherits(cond, "condition")) {
[11:02:41.096]                         if (!is.null(pattern)) {
[11:02:41.096]                           computeRestarts <- base::computeRestarts
[11:02:41.096]                           grepl <- base::grepl
[11:02:41.096]                           restarts <- computeRestarts(cond)
[11:02:41.096]                           for (restart in restarts) {
[11:02:41.096]                             name <- restart$name
[11:02:41.096]                             if (is.null(name)) 
[11:02:41.096]                               next
[11:02:41.096]                             if (!grepl(pattern, name)) 
[11:02:41.096]                               next
[11:02:41.096]                             invokeRestart(restart)
[11:02:41.096]                             muffled <- TRUE
[11:02:41.096]                             break
[11:02:41.096]                           }
[11:02:41.096]                         }
[11:02:41.096]                       }
[11:02:41.096]                       invisible(muffled)
[11:02:41.096]                     }
[11:02:41.096]                     muffleCondition(cond, pattern = "^muffle")
[11:02:41.096]                   }
[11:02:41.096]                 }
[11:02:41.096]             }
[11:02:41.096]         }))
[11:02:41.096]     }, error = function(ex) {
[11:02:41.096]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:41.096]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:41.096]                 ...future.rng), started = ...future.startTime, 
[11:02:41.096]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:41.096]             version = "1.8"), class = "FutureResult")
[11:02:41.096]     }, finally = {
[11:02:41.096]         if (!identical(...future.workdir, getwd())) 
[11:02:41.096]             setwd(...future.workdir)
[11:02:41.096]         {
[11:02:41.096]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:41.096]                 ...future.oldOptions$nwarnings <- NULL
[11:02:41.096]             }
[11:02:41.096]             base::options(...future.oldOptions)
[11:02:41.096]             if (.Platform$OS.type == "windows") {
[11:02:41.096]                 old_names <- names(...future.oldEnvVars)
[11:02:41.096]                 envs <- base::Sys.getenv()
[11:02:41.096]                 names <- names(envs)
[11:02:41.096]                 common <- intersect(names, old_names)
[11:02:41.096]                 added <- setdiff(names, old_names)
[11:02:41.096]                 removed <- setdiff(old_names, names)
[11:02:41.096]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:41.096]                   envs[common]]
[11:02:41.096]                 NAMES <- toupper(changed)
[11:02:41.096]                 args <- list()
[11:02:41.096]                 for (kk in seq_along(NAMES)) {
[11:02:41.096]                   name <- changed[[kk]]
[11:02:41.096]                   NAME <- NAMES[[kk]]
[11:02:41.096]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:41.096]                     next
[11:02:41.096]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:41.096]                 }
[11:02:41.096]                 NAMES <- toupper(added)
[11:02:41.096]                 for (kk in seq_along(NAMES)) {
[11:02:41.096]                   name <- added[[kk]]
[11:02:41.096]                   NAME <- NAMES[[kk]]
[11:02:41.096]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:41.096]                     next
[11:02:41.096]                   args[[name]] <- ""
[11:02:41.096]                 }
[11:02:41.096]                 NAMES <- toupper(removed)
[11:02:41.096]                 for (kk in seq_along(NAMES)) {
[11:02:41.096]                   name <- removed[[kk]]
[11:02:41.096]                   NAME <- NAMES[[kk]]
[11:02:41.096]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:41.096]                     next
[11:02:41.096]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:41.096]                 }
[11:02:41.096]                 if (length(args) > 0) 
[11:02:41.096]                   base::do.call(base::Sys.setenv, args = args)
[11:02:41.096]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:41.096]             }
[11:02:41.096]             else {
[11:02:41.096]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:41.096]             }
[11:02:41.096]             {
[11:02:41.096]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:41.096]                   0L) {
[11:02:41.096]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:41.096]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:41.096]                   base::options(opts)
[11:02:41.096]                 }
[11:02:41.096]                 {
[11:02:41.096]                   {
[11:02:41.096]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:41.096]                     NULL
[11:02:41.096]                   }
[11:02:41.096]                   options(future.plan = NULL)
[11:02:41.096]                   if (is.na(NA_character_)) 
[11:02:41.096]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:41.096]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:41.096]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:41.096]                     .init = FALSE)
[11:02:41.096]                 }
[11:02:41.096]             }
[11:02:41.096]         }
[11:02:41.096]     })
[11:02:41.096]     if (TRUE) {
[11:02:41.096]         base::sink(type = "output", split = FALSE)
[11:02:41.096]         if (TRUE) {
[11:02:41.096]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:41.096]         }
[11:02:41.096]         else {
[11:02:41.096]             ...future.result["stdout"] <- base::list(NULL)
[11:02:41.096]         }
[11:02:41.096]         base::close(...future.stdout)
[11:02:41.096]         ...future.stdout <- NULL
[11:02:41.096]     }
[11:02:41.096]     ...future.result$conditions <- ...future.conditions
[11:02:41.096]     ...future.result$finished <- base::Sys.time()
[11:02:41.096]     ...future.result
[11:02:41.096] }
[11:02:41.099] MultisessionFuture started
[11:02:41.099] - Launch lazy future ... done
[11:02:41.100] run() for ‘MultisessionFuture’ ... done
[11:02:41.642] receiveMessageFromWorker() for ClusterFuture ...
[11:02:41.642] - Validating connection of MultisessionFuture
[11:02:41.642] - received message: FutureResult
[11:02:41.642] - Received FutureResult
[11:02:41.642] - Erased future from FutureRegistry
[11:02:41.643] result() for ClusterFuture ...
[11:02:41.643] - result already collected: FutureResult
[11:02:41.643] result() for ClusterFuture ... done
[11:02:41.643] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:41.643] A MultisessionFuture was resolved (result was not collected)
[11:02:41.643] getGlobalsAndPackages() ...
[11:02:41.643] Searching for globals...
[11:02:41.645] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[11:02:41.645] Searching for globals ... DONE
[11:02:41.645] Resolving globals: FALSE
[11:02:41.645] 
[11:02:41.645] 
[11:02:41.645] getGlobalsAndPackages() ... DONE
[11:02:41.646] run() for ‘Future’ ...
[11:02:41.646] - state: ‘created’
[11:02:41.646] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:41.661] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:41.661] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:41.661]   - Field: ‘node’
[11:02:41.661]   - Field: ‘label’
[11:02:41.661]   - Field: ‘local’
[11:02:41.661]   - Field: ‘owner’
[11:02:41.661]   - Field: ‘envir’
[11:02:41.661]   - Field: ‘workers’
[11:02:41.661]   - Field: ‘packages’
[11:02:41.661]   - Field: ‘gc’
[11:02:41.662]   - Field: ‘conditions’
[11:02:41.662]   - Field: ‘persistent’
[11:02:41.662]   - Field: ‘expr’
[11:02:41.662]   - Field: ‘uuid’
[11:02:41.662]   - Field: ‘seed’
[11:02:41.662]   - Field: ‘version’
[11:02:41.662]   - Field: ‘result’
[11:02:41.662]   - Field: ‘asynchronous’
[11:02:41.662]   - Field: ‘calls’
[11:02:41.663]   - Field: ‘globals’
[11:02:41.663]   - Field: ‘stdout’
[11:02:41.663]   - Field: ‘earlySignal’
[11:02:41.663]   - Field: ‘lazy’
[11:02:41.663]   - Field: ‘state’
[11:02:41.663] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:41.663] - Launch lazy future ...
[11:02:41.664] Packages needed by the future expression (n = 0): <none>
[11:02:41.664] Packages needed by future strategies (n = 0): <none>
[11:02:41.664] {
[11:02:41.664]     {
[11:02:41.664]         {
[11:02:41.664]             ...future.startTime <- base::Sys.time()
[11:02:41.664]             {
[11:02:41.664]                 {
[11:02:41.664]                   {
[11:02:41.664]                     {
[11:02:41.664]                       base::local({
[11:02:41.664]                         has_future <- base::requireNamespace("future", 
[11:02:41.664]                           quietly = TRUE)
[11:02:41.664]                         if (has_future) {
[11:02:41.664]                           ns <- base::getNamespace("future")
[11:02:41.664]                           version <- ns[[".package"]][["version"]]
[11:02:41.664]                           if (is.null(version)) 
[11:02:41.664]                             version <- utils::packageVersion("future")
[11:02:41.664]                         }
[11:02:41.664]                         else {
[11:02:41.664]                           version <- NULL
[11:02:41.664]                         }
[11:02:41.664]                         if (!has_future || version < "1.8.0") {
[11:02:41.664]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:41.664]                             "", base::R.version$version.string), 
[11:02:41.664]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:41.664]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:41.664]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:41.664]                               "release", "version")], collapse = " "), 
[11:02:41.664]                             hostname = base::Sys.info()[["nodename"]])
[11:02:41.664]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:41.664]                             info)
[11:02:41.664]                           info <- base::paste(info, collapse = "; ")
[11:02:41.664]                           if (!has_future) {
[11:02:41.664]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:41.664]                               info)
[11:02:41.664]                           }
[11:02:41.664]                           else {
[11:02:41.664]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:41.664]                               info, version)
[11:02:41.664]                           }
[11:02:41.664]                           base::stop(msg)
[11:02:41.664]                         }
[11:02:41.664]                       })
[11:02:41.664]                     }
[11:02:41.664]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:41.664]                     base::options(mc.cores = 1L)
[11:02:41.664]                   }
[11:02:41.664]                   ...future.strategy.old <- future::plan("list")
[11:02:41.664]                   options(future.plan = NULL)
[11:02:41.664]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:41.664]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:41.664]                 }
[11:02:41.664]                 ...future.workdir <- getwd()
[11:02:41.664]             }
[11:02:41.664]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:41.664]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:41.664]         }
[11:02:41.664]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:41.664]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:41.664]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:41.664]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:41.664]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:41.664]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:41.664]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:41.664]             base::names(...future.oldOptions))
[11:02:41.664]     }
[11:02:41.664]     if (FALSE) {
[11:02:41.664]     }
[11:02:41.664]     else {
[11:02:41.664]         if (TRUE) {
[11:02:41.664]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:41.664]                 open = "w")
[11:02:41.664]         }
[11:02:41.664]         else {
[11:02:41.664]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:41.664]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:41.664]         }
[11:02:41.664]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:41.664]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:41.664]             base::sink(type = "output", split = FALSE)
[11:02:41.664]             base::close(...future.stdout)
[11:02:41.664]         }, add = TRUE)
[11:02:41.664]     }
[11:02:41.664]     ...future.frame <- base::sys.nframe()
[11:02:41.664]     ...future.conditions <- base::list()
[11:02:41.664]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:41.664]     if (FALSE) {
[11:02:41.664]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:41.664]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:41.664]     }
[11:02:41.664]     ...future.result <- base::tryCatch({
[11:02:41.664]         base::withCallingHandlers({
[11:02:41.664]             ...future.value <- base::withVisible(base::local({
[11:02:41.664]                 ...future.makeSendCondition <- base::local({
[11:02:41.664]                   sendCondition <- NULL
[11:02:41.664]                   function(frame = 1L) {
[11:02:41.664]                     if (is.function(sendCondition)) 
[11:02:41.664]                       return(sendCondition)
[11:02:41.664]                     ns <- getNamespace("parallel")
[11:02:41.664]                     if (exists("sendData", mode = "function", 
[11:02:41.664]                       envir = ns)) {
[11:02:41.664]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:41.664]                         envir = ns)
[11:02:41.664]                       envir <- sys.frame(frame)
[11:02:41.664]                       master <- NULL
[11:02:41.664]                       while (!identical(envir, .GlobalEnv) && 
[11:02:41.664]                         !identical(envir, emptyenv())) {
[11:02:41.664]                         if (exists("master", mode = "list", envir = envir, 
[11:02:41.664]                           inherits = FALSE)) {
[11:02:41.664]                           master <- get("master", mode = "list", 
[11:02:41.664]                             envir = envir, inherits = FALSE)
[11:02:41.664]                           if (inherits(master, c("SOCKnode", 
[11:02:41.664]                             "SOCK0node"))) {
[11:02:41.664]                             sendCondition <<- function(cond) {
[11:02:41.664]                               data <- list(type = "VALUE", value = cond, 
[11:02:41.664]                                 success = TRUE)
[11:02:41.664]                               parallel_sendData(master, data)
[11:02:41.664]                             }
[11:02:41.664]                             return(sendCondition)
[11:02:41.664]                           }
[11:02:41.664]                         }
[11:02:41.664]                         frame <- frame + 1L
[11:02:41.664]                         envir <- sys.frame(frame)
[11:02:41.664]                       }
[11:02:41.664]                     }
[11:02:41.664]                     sendCondition <<- function(cond) NULL
[11:02:41.664]                   }
[11:02:41.664]                 })
[11:02:41.664]                 withCallingHandlers({
[11:02:41.664]                   {
[11:02:41.664]                     Sys.sleep(0.5)
[11:02:41.664]                     list(a = 1, b = 42L)
[11:02:41.664]                   }
[11:02:41.664]                 }, immediateCondition = function(cond) {
[11:02:41.664]                   sendCondition <- ...future.makeSendCondition()
[11:02:41.664]                   sendCondition(cond)
[11:02:41.664]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:41.664]                   {
[11:02:41.664]                     inherits <- base::inherits
[11:02:41.664]                     invokeRestart <- base::invokeRestart
[11:02:41.664]                     is.null <- base::is.null
[11:02:41.664]                     muffled <- FALSE
[11:02:41.664]                     if (inherits(cond, "message")) {
[11:02:41.664]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:41.664]                       if (muffled) 
[11:02:41.664]                         invokeRestart("muffleMessage")
[11:02:41.664]                     }
[11:02:41.664]                     else if (inherits(cond, "warning")) {
[11:02:41.664]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:41.664]                       if (muffled) 
[11:02:41.664]                         invokeRestart("muffleWarning")
[11:02:41.664]                     }
[11:02:41.664]                     else if (inherits(cond, "condition")) {
[11:02:41.664]                       if (!is.null(pattern)) {
[11:02:41.664]                         computeRestarts <- base::computeRestarts
[11:02:41.664]                         grepl <- base::grepl
[11:02:41.664]                         restarts <- computeRestarts(cond)
[11:02:41.664]                         for (restart in restarts) {
[11:02:41.664]                           name <- restart$name
[11:02:41.664]                           if (is.null(name)) 
[11:02:41.664]                             next
[11:02:41.664]                           if (!grepl(pattern, name)) 
[11:02:41.664]                             next
[11:02:41.664]                           invokeRestart(restart)
[11:02:41.664]                           muffled <- TRUE
[11:02:41.664]                           break
[11:02:41.664]                         }
[11:02:41.664]                       }
[11:02:41.664]                     }
[11:02:41.664]                     invisible(muffled)
[11:02:41.664]                   }
[11:02:41.664]                   muffleCondition(cond)
[11:02:41.664]                 })
[11:02:41.664]             }))
[11:02:41.664]             future::FutureResult(value = ...future.value$value, 
[11:02:41.664]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:41.664]                   ...future.rng), globalenv = if (FALSE) 
[11:02:41.664]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:41.664]                     ...future.globalenv.names))
[11:02:41.664]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:41.664]         }, condition = base::local({
[11:02:41.664]             c <- base::c
[11:02:41.664]             inherits <- base::inherits
[11:02:41.664]             invokeRestart <- base::invokeRestart
[11:02:41.664]             length <- base::length
[11:02:41.664]             list <- base::list
[11:02:41.664]             seq.int <- base::seq.int
[11:02:41.664]             signalCondition <- base::signalCondition
[11:02:41.664]             sys.calls <- base::sys.calls
[11:02:41.664]             `[[` <- base::`[[`
[11:02:41.664]             `+` <- base::`+`
[11:02:41.664]             `<<-` <- base::`<<-`
[11:02:41.664]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:41.664]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:41.664]                   3L)]
[11:02:41.664]             }
[11:02:41.664]             function(cond) {
[11:02:41.664]                 is_error <- inherits(cond, "error")
[11:02:41.664]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:41.664]                   NULL)
[11:02:41.664]                 if (is_error) {
[11:02:41.664]                   sessionInformation <- function() {
[11:02:41.664]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:41.664]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:41.664]                       search = base::search(), system = base::Sys.info())
[11:02:41.664]                   }
[11:02:41.664]                   ...future.conditions[[length(...future.conditions) + 
[11:02:41.664]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:41.664]                     cond$call), session = sessionInformation(), 
[11:02:41.664]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:41.664]                   signalCondition(cond)
[11:02:41.664]                 }
[11:02:41.664]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:41.664]                 "immediateCondition"))) {
[11:02:41.664]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:41.664]                   ...future.conditions[[length(...future.conditions) + 
[11:02:41.664]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:41.664]                   if (TRUE && !signal) {
[11:02:41.664]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:41.664]                     {
[11:02:41.664]                       inherits <- base::inherits
[11:02:41.664]                       invokeRestart <- base::invokeRestart
[11:02:41.664]                       is.null <- base::is.null
[11:02:41.664]                       muffled <- FALSE
[11:02:41.664]                       if (inherits(cond, "message")) {
[11:02:41.664]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:41.664]                         if (muffled) 
[11:02:41.664]                           invokeRestart("muffleMessage")
[11:02:41.664]                       }
[11:02:41.664]                       else if (inherits(cond, "warning")) {
[11:02:41.664]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:41.664]                         if (muffled) 
[11:02:41.664]                           invokeRestart("muffleWarning")
[11:02:41.664]                       }
[11:02:41.664]                       else if (inherits(cond, "condition")) {
[11:02:41.664]                         if (!is.null(pattern)) {
[11:02:41.664]                           computeRestarts <- base::computeRestarts
[11:02:41.664]                           grepl <- base::grepl
[11:02:41.664]                           restarts <- computeRestarts(cond)
[11:02:41.664]                           for (restart in restarts) {
[11:02:41.664]                             name <- restart$name
[11:02:41.664]                             if (is.null(name)) 
[11:02:41.664]                               next
[11:02:41.664]                             if (!grepl(pattern, name)) 
[11:02:41.664]                               next
[11:02:41.664]                             invokeRestart(restart)
[11:02:41.664]                             muffled <- TRUE
[11:02:41.664]                             break
[11:02:41.664]                           }
[11:02:41.664]                         }
[11:02:41.664]                       }
[11:02:41.664]                       invisible(muffled)
[11:02:41.664]                     }
[11:02:41.664]                     muffleCondition(cond, pattern = "^muffle")
[11:02:41.664]                   }
[11:02:41.664]                 }
[11:02:41.664]                 else {
[11:02:41.664]                   if (TRUE) {
[11:02:41.664]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:41.664]                     {
[11:02:41.664]                       inherits <- base::inherits
[11:02:41.664]                       invokeRestart <- base::invokeRestart
[11:02:41.664]                       is.null <- base::is.null
[11:02:41.664]                       muffled <- FALSE
[11:02:41.664]                       if (inherits(cond, "message")) {
[11:02:41.664]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:41.664]                         if (muffled) 
[11:02:41.664]                           invokeRestart("muffleMessage")
[11:02:41.664]                       }
[11:02:41.664]                       else if (inherits(cond, "warning")) {
[11:02:41.664]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:41.664]                         if (muffled) 
[11:02:41.664]                           invokeRestart("muffleWarning")
[11:02:41.664]                       }
[11:02:41.664]                       else if (inherits(cond, "condition")) {
[11:02:41.664]                         if (!is.null(pattern)) {
[11:02:41.664]                           computeRestarts <- base::computeRestarts
[11:02:41.664]                           grepl <- base::grepl
[11:02:41.664]                           restarts <- computeRestarts(cond)
[11:02:41.664]                           for (restart in restarts) {
[11:02:41.664]                             name <- restart$name
[11:02:41.664]                             if (is.null(name)) 
[11:02:41.664]                               next
[11:02:41.664]                             if (!grepl(pattern, name)) 
[11:02:41.664]                               next
[11:02:41.664]                             invokeRestart(restart)
[11:02:41.664]                             muffled <- TRUE
[11:02:41.664]                             break
[11:02:41.664]                           }
[11:02:41.664]                         }
[11:02:41.664]                       }
[11:02:41.664]                       invisible(muffled)
[11:02:41.664]                     }
[11:02:41.664]                     muffleCondition(cond, pattern = "^muffle")
[11:02:41.664]                   }
[11:02:41.664]                 }
[11:02:41.664]             }
[11:02:41.664]         }))
[11:02:41.664]     }, error = function(ex) {
[11:02:41.664]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:41.664]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:41.664]                 ...future.rng), started = ...future.startTime, 
[11:02:41.664]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:41.664]             version = "1.8"), class = "FutureResult")
[11:02:41.664]     }, finally = {
[11:02:41.664]         if (!identical(...future.workdir, getwd())) 
[11:02:41.664]             setwd(...future.workdir)
[11:02:41.664]         {
[11:02:41.664]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:41.664]                 ...future.oldOptions$nwarnings <- NULL
[11:02:41.664]             }
[11:02:41.664]             base::options(...future.oldOptions)
[11:02:41.664]             if (.Platform$OS.type == "windows") {
[11:02:41.664]                 old_names <- names(...future.oldEnvVars)
[11:02:41.664]                 envs <- base::Sys.getenv()
[11:02:41.664]                 names <- names(envs)
[11:02:41.664]                 common <- intersect(names, old_names)
[11:02:41.664]                 added <- setdiff(names, old_names)
[11:02:41.664]                 removed <- setdiff(old_names, names)
[11:02:41.664]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:41.664]                   envs[common]]
[11:02:41.664]                 NAMES <- toupper(changed)
[11:02:41.664]                 args <- list()
[11:02:41.664]                 for (kk in seq_along(NAMES)) {
[11:02:41.664]                   name <- changed[[kk]]
[11:02:41.664]                   NAME <- NAMES[[kk]]
[11:02:41.664]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:41.664]                     next
[11:02:41.664]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:41.664]                 }
[11:02:41.664]                 NAMES <- toupper(added)
[11:02:41.664]                 for (kk in seq_along(NAMES)) {
[11:02:41.664]                   name <- added[[kk]]
[11:02:41.664]                   NAME <- NAMES[[kk]]
[11:02:41.664]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:41.664]                     next
[11:02:41.664]                   args[[name]] <- ""
[11:02:41.664]                 }
[11:02:41.664]                 NAMES <- toupper(removed)
[11:02:41.664]                 for (kk in seq_along(NAMES)) {
[11:02:41.664]                   name <- removed[[kk]]
[11:02:41.664]                   NAME <- NAMES[[kk]]
[11:02:41.664]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:41.664]                     next
[11:02:41.664]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:41.664]                 }
[11:02:41.664]                 if (length(args) > 0) 
[11:02:41.664]                   base::do.call(base::Sys.setenv, args = args)
[11:02:41.664]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:41.664]             }
[11:02:41.664]             else {
[11:02:41.664]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:41.664]             }
[11:02:41.664]             {
[11:02:41.664]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:41.664]                   0L) {
[11:02:41.664]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:41.664]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:41.664]                   base::options(opts)
[11:02:41.664]                 }
[11:02:41.664]                 {
[11:02:41.664]                   {
[11:02:41.664]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:41.664]                     NULL
[11:02:41.664]                   }
[11:02:41.664]                   options(future.plan = NULL)
[11:02:41.664]                   if (is.na(NA_character_)) 
[11:02:41.664]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:41.664]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:41.664]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:41.664]                     .init = FALSE)
[11:02:41.664]                 }
[11:02:41.664]             }
[11:02:41.664]         }
[11:02:41.664]     })
[11:02:41.664]     if (TRUE) {
[11:02:41.664]         base::sink(type = "output", split = FALSE)
[11:02:41.664]         if (TRUE) {
[11:02:41.664]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:41.664]         }
[11:02:41.664]         else {
[11:02:41.664]             ...future.result["stdout"] <- base::list(NULL)
[11:02:41.664]         }
[11:02:41.664]         base::close(...future.stdout)
[11:02:41.664]         ...future.stdout <- NULL
[11:02:41.664]     }
[11:02:41.664]     ...future.result$conditions <- ...future.conditions
[11:02:41.664]     ...future.result$finished <- base::Sys.time()
[11:02:41.664]     ...future.result
[11:02:41.664] }
[11:02:41.668] MultisessionFuture started
[11:02:41.668] - Launch lazy future ... done
[11:02:41.668] run() for ‘MultisessionFuture’ ... done
[11:02:42.210] receiveMessageFromWorker() for ClusterFuture ...
[11:02:42.210] - Validating connection of MultisessionFuture
[11:02:42.210] - received message: FutureResult
[11:02:42.211] - Received FutureResult
[11:02:42.211] - Erased future from FutureRegistry
[11:02:42.211] result() for ClusterFuture ...
[11:02:42.211] - result already collected: FutureResult
[11:02:42.211] result() for ClusterFuture ... done
[11:02:42.211] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:42.211] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[11:02:42.211] getGlobalsAndPackages() ...
[11:02:42.212] Searching for globals...
[11:02:42.212] - globals found: [2] ‘list’, ‘stop’
[11:02:42.213] Searching for globals ... DONE
[11:02:42.213] Resolving globals: FALSE
[11:02:42.213] 
[11:02:42.213] 
[11:02:42.213] getGlobalsAndPackages() ... DONE
[11:02:42.214] run() for ‘Future’ ...
[11:02:42.214] - state: ‘created’
[11:02:42.214] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:42.229] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:42.229] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:42.229]   - Field: ‘node’
[11:02:42.229]   - Field: ‘label’
[11:02:42.229]   - Field: ‘local’
[11:02:42.229]   - Field: ‘owner’
[11:02:42.229]   - Field: ‘envir’
[11:02:42.229]   - Field: ‘workers’
[11:02:42.229]   - Field: ‘packages’
[11:02:42.229]   - Field: ‘gc’
[11:02:42.230]   - Field: ‘conditions’
[11:02:42.230]   - Field: ‘persistent’
[11:02:42.230]   - Field: ‘expr’
[11:02:42.230]   - Field: ‘uuid’
[11:02:42.230]   - Field: ‘seed’
[11:02:42.230]   - Field: ‘version’
[11:02:42.230]   - Field: ‘result’
[11:02:42.230]   - Field: ‘asynchronous’
[11:02:42.230]   - Field: ‘calls’
[11:02:42.231]   - Field: ‘globals’
[11:02:42.231]   - Field: ‘stdout’
[11:02:42.231]   - Field: ‘earlySignal’
[11:02:42.231]   - Field: ‘lazy’
[11:02:42.231]   - Field: ‘state’
[11:02:42.231] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:42.231] - Launch lazy future ...
[11:02:42.232] Packages needed by the future expression (n = 0): <none>
[11:02:42.232] Packages needed by future strategies (n = 0): <none>
[11:02:42.232] {
[11:02:42.232]     {
[11:02:42.232]         {
[11:02:42.232]             ...future.startTime <- base::Sys.time()
[11:02:42.232]             {
[11:02:42.232]                 {
[11:02:42.232]                   {
[11:02:42.232]                     {
[11:02:42.232]                       base::local({
[11:02:42.232]                         has_future <- base::requireNamespace("future", 
[11:02:42.232]                           quietly = TRUE)
[11:02:42.232]                         if (has_future) {
[11:02:42.232]                           ns <- base::getNamespace("future")
[11:02:42.232]                           version <- ns[[".package"]][["version"]]
[11:02:42.232]                           if (is.null(version)) 
[11:02:42.232]                             version <- utils::packageVersion("future")
[11:02:42.232]                         }
[11:02:42.232]                         else {
[11:02:42.232]                           version <- NULL
[11:02:42.232]                         }
[11:02:42.232]                         if (!has_future || version < "1.8.0") {
[11:02:42.232]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:42.232]                             "", base::R.version$version.string), 
[11:02:42.232]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:42.232]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:42.232]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:42.232]                               "release", "version")], collapse = " "), 
[11:02:42.232]                             hostname = base::Sys.info()[["nodename"]])
[11:02:42.232]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:42.232]                             info)
[11:02:42.232]                           info <- base::paste(info, collapse = "; ")
[11:02:42.232]                           if (!has_future) {
[11:02:42.232]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:42.232]                               info)
[11:02:42.232]                           }
[11:02:42.232]                           else {
[11:02:42.232]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:42.232]                               info, version)
[11:02:42.232]                           }
[11:02:42.232]                           base::stop(msg)
[11:02:42.232]                         }
[11:02:42.232]                       })
[11:02:42.232]                     }
[11:02:42.232]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:42.232]                     base::options(mc.cores = 1L)
[11:02:42.232]                   }
[11:02:42.232]                   ...future.strategy.old <- future::plan("list")
[11:02:42.232]                   options(future.plan = NULL)
[11:02:42.232]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:42.232]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:42.232]                 }
[11:02:42.232]                 ...future.workdir <- getwd()
[11:02:42.232]             }
[11:02:42.232]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:42.232]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:42.232]         }
[11:02:42.232]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:42.232]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:42.232]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:42.232]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:42.232]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:42.232]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:42.232]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:42.232]             base::names(...future.oldOptions))
[11:02:42.232]     }
[11:02:42.232]     if (FALSE) {
[11:02:42.232]     }
[11:02:42.232]     else {
[11:02:42.232]         if (TRUE) {
[11:02:42.232]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:42.232]                 open = "w")
[11:02:42.232]         }
[11:02:42.232]         else {
[11:02:42.232]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:42.232]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:42.232]         }
[11:02:42.232]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:42.232]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:42.232]             base::sink(type = "output", split = FALSE)
[11:02:42.232]             base::close(...future.stdout)
[11:02:42.232]         }, add = TRUE)
[11:02:42.232]     }
[11:02:42.232]     ...future.frame <- base::sys.nframe()
[11:02:42.232]     ...future.conditions <- base::list()
[11:02:42.232]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:42.232]     if (FALSE) {
[11:02:42.232]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:42.232]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:42.232]     }
[11:02:42.232]     ...future.result <- base::tryCatch({
[11:02:42.232]         base::withCallingHandlers({
[11:02:42.232]             ...future.value <- base::withVisible(base::local({
[11:02:42.232]                 ...future.makeSendCondition <- base::local({
[11:02:42.232]                   sendCondition <- NULL
[11:02:42.232]                   function(frame = 1L) {
[11:02:42.232]                     if (is.function(sendCondition)) 
[11:02:42.232]                       return(sendCondition)
[11:02:42.232]                     ns <- getNamespace("parallel")
[11:02:42.232]                     if (exists("sendData", mode = "function", 
[11:02:42.232]                       envir = ns)) {
[11:02:42.232]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:42.232]                         envir = ns)
[11:02:42.232]                       envir <- sys.frame(frame)
[11:02:42.232]                       master <- NULL
[11:02:42.232]                       while (!identical(envir, .GlobalEnv) && 
[11:02:42.232]                         !identical(envir, emptyenv())) {
[11:02:42.232]                         if (exists("master", mode = "list", envir = envir, 
[11:02:42.232]                           inherits = FALSE)) {
[11:02:42.232]                           master <- get("master", mode = "list", 
[11:02:42.232]                             envir = envir, inherits = FALSE)
[11:02:42.232]                           if (inherits(master, c("SOCKnode", 
[11:02:42.232]                             "SOCK0node"))) {
[11:02:42.232]                             sendCondition <<- function(cond) {
[11:02:42.232]                               data <- list(type = "VALUE", value = cond, 
[11:02:42.232]                                 success = TRUE)
[11:02:42.232]                               parallel_sendData(master, data)
[11:02:42.232]                             }
[11:02:42.232]                             return(sendCondition)
[11:02:42.232]                           }
[11:02:42.232]                         }
[11:02:42.232]                         frame <- frame + 1L
[11:02:42.232]                         envir <- sys.frame(frame)
[11:02:42.232]                       }
[11:02:42.232]                     }
[11:02:42.232]                     sendCondition <<- function(cond) NULL
[11:02:42.232]                   }
[11:02:42.232]                 })
[11:02:42.232]                 withCallingHandlers({
[11:02:42.232]                   list(a = 1, b = 42L, c = stop("Nah!"))
[11:02:42.232]                 }, immediateCondition = function(cond) {
[11:02:42.232]                   sendCondition <- ...future.makeSendCondition()
[11:02:42.232]                   sendCondition(cond)
[11:02:42.232]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:42.232]                   {
[11:02:42.232]                     inherits <- base::inherits
[11:02:42.232]                     invokeRestart <- base::invokeRestart
[11:02:42.232]                     is.null <- base::is.null
[11:02:42.232]                     muffled <- FALSE
[11:02:42.232]                     if (inherits(cond, "message")) {
[11:02:42.232]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:42.232]                       if (muffled) 
[11:02:42.232]                         invokeRestart("muffleMessage")
[11:02:42.232]                     }
[11:02:42.232]                     else if (inherits(cond, "warning")) {
[11:02:42.232]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:42.232]                       if (muffled) 
[11:02:42.232]                         invokeRestart("muffleWarning")
[11:02:42.232]                     }
[11:02:42.232]                     else if (inherits(cond, "condition")) {
[11:02:42.232]                       if (!is.null(pattern)) {
[11:02:42.232]                         computeRestarts <- base::computeRestarts
[11:02:42.232]                         grepl <- base::grepl
[11:02:42.232]                         restarts <- computeRestarts(cond)
[11:02:42.232]                         for (restart in restarts) {
[11:02:42.232]                           name <- restart$name
[11:02:42.232]                           if (is.null(name)) 
[11:02:42.232]                             next
[11:02:42.232]                           if (!grepl(pattern, name)) 
[11:02:42.232]                             next
[11:02:42.232]                           invokeRestart(restart)
[11:02:42.232]                           muffled <- TRUE
[11:02:42.232]                           break
[11:02:42.232]                         }
[11:02:42.232]                       }
[11:02:42.232]                     }
[11:02:42.232]                     invisible(muffled)
[11:02:42.232]                   }
[11:02:42.232]                   muffleCondition(cond)
[11:02:42.232]                 })
[11:02:42.232]             }))
[11:02:42.232]             future::FutureResult(value = ...future.value$value, 
[11:02:42.232]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:42.232]                   ...future.rng), globalenv = if (FALSE) 
[11:02:42.232]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:42.232]                     ...future.globalenv.names))
[11:02:42.232]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:42.232]         }, condition = base::local({
[11:02:42.232]             c <- base::c
[11:02:42.232]             inherits <- base::inherits
[11:02:42.232]             invokeRestart <- base::invokeRestart
[11:02:42.232]             length <- base::length
[11:02:42.232]             list <- base::list
[11:02:42.232]             seq.int <- base::seq.int
[11:02:42.232]             signalCondition <- base::signalCondition
[11:02:42.232]             sys.calls <- base::sys.calls
[11:02:42.232]             `[[` <- base::`[[`
[11:02:42.232]             `+` <- base::`+`
[11:02:42.232]             `<<-` <- base::`<<-`
[11:02:42.232]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:42.232]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:42.232]                   3L)]
[11:02:42.232]             }
[11:02:42.232]             function(cond) {
[11:02:42.232]                 is_error <- inherits(cond, "error")
[11:02:42.232]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:42.232]                   NULL)
[11:02:42.232]                 if (is_error) {
[11:02:42.232]                   sessionInformation <- function() {
[11:02:42.232]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:42.232]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:42.232]                       search = base::search(), system = base::Sys.info())
[11:02:42.232]                   }
[11:02:42.232]                   ...future.conditions[[length(...future.conditions) + 
[11:02:42.232]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:42.232]                     cond$call), session = sessionInformation(), 
[11:02:42.232]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:42.232]                   signalCondition(cond)
[11:02:42.232]                 }
[11:02:42.232]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:42.232]                 "immediateCondition"))) {
[11:02:42.232]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:42.232]                   ...future.conditions[[length(...future.conditions) + 
[11:02:42.232]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:42.232]                   if (TRUE && !signal) {
[11:02:42.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:42.232]                     {
[11:02:42.232]                       inherits <- base::inherits
[11:02:42.232]                       invokeRestart <- base::invokeRestart
[11:02:42.232]                       is.null <- base::is.null
[11:02:42.232]                       muffled <- FALSE
[11:02:42.232]                       if (inherits(cond, "message")) {
[11:02:42.232]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:42.232]                         if (muffled) 
[11:02:42.232]                           invokeRestart("muffleMessage")
[11:02:42.232]                       }
[11:02:42.232]                       else if (inherits(cond, "warning")) {
[11:02:42.232]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:42.232]                         if (muffled) 
[11:02:42.232]                           invokeRestart("muffleWarning")
[11:02:42.232]                       }
[11:02:42.232]                       else if (inherits(cond, "condition")) {
[11:02:42.232]                         if (!is.null(pattern)) {
[11:02:42.232]                           computeRestarts <- base::computeRestarts
[11:02:42.232]                           grepl <- base::grepl
[11:02:42.232]                           restarts <- computeRestarts(cond)
[11:02:42.232]                           for (restart in restarts) {
[11:02:42.232]                             name <- restart$name
[11:02:42.232]                             if (is.null(name)) 
[11:02:42.232]                               next
[11:02:42.232]                             if (!grepl(pattern, name)) 
[11:02:42.232]                               next
[11:02:42.232]                             invokeRestart(restart)
[11:02:42.232]                             muffled <- TRUE
[11:02:42.232]                             break
[11:02:42.232]                           }
[11:02:42.232]                         }
[11:02:42.232]                       }
[11:02:42.232]                       invisible(muffled)
[11:02:42.232]                     }
[11:02:42.232]                     muffleCondition(cond, pattern = "^muffle")
[11:02:42.232]                   }
[11:02:42.232]                 }
[11:02:42.232]                 else {
[11:02:42.232]                   if (TRUE) {
[11:02:42.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:42.232]                     {
[11:02:42.232]                       inherits <- base::inherits
[11:02:42.232]                       invokeRestart <- base::invokeRestart
[11:02:42.232]                       is.null <- base::is.null
[11:02:42.232]                       muffled <- FALSE
[11:02:42.232]                       if (inherits(cond, "message")) {
[11:02:42.232]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:42.232]                         if (muffled) 
[11:02:42.232]                           invokeRestart("muffleMessage")
[11:02:42.232]                       }
[11:02:42.232]                       else if (inherits(cond, "warning")) {
[11:02:42.232]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:42.232]                         if (muffled) 
[11:02:42.232]                           invokeRestart("muffleWarning")
[11:02:42.232]                       }
[11:02:42.232]                       else if (inherits(cond, "condition")) {
[11:02:42.232]                         if (!is.null(pattern)) {
[11:02:42.232]                           computeRestarts <- base::computeRestarts
[11:02:42.232]                           grepl <- base::grepl
[11:02:42.232]                           restarts <- computeRestarts(cond)
[11:02:42.232]                           for (restart in restarts) {
[11:02:42.232]                             name <- restart$name
[11:02:42.232]                             if (is.null(name)) 
[11:02:42.232]                               next
[11:02:42.232]                             if (!grepl(pattern, name)) 
[11:02:42.232]                               next
[11:02:42.232]                             invokeRestart(restart)
[11:02:42.232]                             muffled <- TRUE
[11:02:42.232]                             break
[11:02:42.232]                           }
[11:02:42.232]                         }
[11:02:42.232]                       }
[11:02:42.232]                       invisible(muffled)
[11:02:42.232]                     }
[11:02:42.232]                     muffleCondition(cond, pattern = "^muffle")
[11:02:42.232]                   }
[11:02:42.232]                 }
[11:02:42.232]             }
[11:02:42.232]         }))
[11:02:42.232]     }, error = function(ex) {
[11:02:42.232]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:42.232]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:42.232]                 ...future.rng), started = ...future.startTime, 
[11:02:42.232]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:42.232]             version = "1.8"), class = "FutureResult")
[11:02:42.232]     }, finally = {
[11:02:42.232]         if (!identical(...future.workdir, getwd())) 
[11:02:42.232]             setwd(...future.workdir)
[11:02:42.232]         {
[11:02:42.232]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:42.232]                 ...future.oldOptions$nwarnings <- NULL
[11:02:42.232]             }
[11:02:42.232]             base::options(...future.oldOptions)
[11:02:42.232]             if (.Platform$OS.type == "windows") {
[11:02:42.232]                 old_names <- names(...future.oldEnvVars)
[11:02:42.232]                 envs <- base::Sys.getenv()
[11:02:42.232]                 names <- names(envs)
[11:02:42.232]                 common <- intersect(names, old_names)
[11:02:42.232]                 added <- setdiff(names, old_names)
[11:02:42.232]                 removed <- setdiff(old_names, names)
[11:02:42.232]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:42.232]                   envs[common]]
[11:02:42.232]                 NAMES <- toupper(changed)
[11:02:42.232]                 args <- list()
[11:02:42.232]                 for (kk in seq_along(NAMES)) {
[11:02:42.232]                   name <- changed[[kk]]
[11:02:42.232]                   NAME <- NAMES[[kk]]
[11:02:42.232]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:42.232]                     next
[11:02:42.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:42.232]                 }
[11:02:42.232]                 NAMES <- toupper(added)
[11:02:42.232]                 for (kk in seq_along(NAMES)) {
[11:02:42.232]                   name <- added[[kk]]
[11:02:42.232]                   NAME <- NAMES[[kk]]
[11:02:42.232]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:42.232]                     next
[11:02:42.232]                   args[[name]] <- ""
[11:02:42.232]                 }
[11:02:42.232]                 NAMES <- toupper(removed)
[11:02:42.232]                 for (kk in seq_along(NAMES)) {
[11:02:42.232]                   name <- removed[[kk]]
[11:02:42.232]                   NAME <- NAMES[[kk]]
[11:02:42.232]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:42.232]                     next
[11:02:42.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:42.232]                 }
[11:02:42.232]                 if (length(args) > 0) 
[11:02:42.232]                   base::do.call(base::Sys.setenv, args = args)
[11:02:42.232]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:42.232]             }
[11:02:42.232]             else {
[11:02:42.232]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:42.232]             }
[11:02:42.232]             {
[11:02:42.232]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:42.232]                   0L) {
[11:02:42.232]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:42.232]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:42.232]                   base::options(opts)
[11:02:42.232]                 }
[11:02:42.232]                 {
[11:02:42.232]                   {
[11:02:42.232]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:42.232]                     NULL
[11:02:42.232]                   }
[11:02:42.232]                   options(future.plan = NULL)
[11:02:42.232]                   if (is.na(NA_character_)) 
[11:02:42.232]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:42.232]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:42.232]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:42.232]                     .init = FALSE)
[11:02:42.232]                 }
[11:02:42.232]             }
[11:02:42.232]         }
[11:02:42.232]     })
[11:02:42.232]     if (TRUE) {
[11:02:42.232]         base::sink(type = "output", split = FALSE)
[11:02:42.232]         if (TRUE) {
[11:02:42.232]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:42.232]         }
[11:02:42.232]         else {
[11:02:42.232]             ...future.result["stdout"] <- base::list(NULL)
[11:02:42.232]         }
[11:02:42.232]         base::close(...future.stdout)
[11:02:42.232]         ...future.stdout <- NULL
[11:02:42.232]     }
[11:02:42.232]     ...future.result$conditions <- ...future.conditions
[11:02:42.232]     ...future.result$finished <- base::Sys.time()
[11:02:42.232]     ...future.result
[11:02:42.232] }
[11:02:42.236] MultisessionFuture started
[11:02:42.236] - Launch lazy future ... done
[11:02:42.236] run() for ‘MultisessionFuture’ ... done
[11:02:42.278] receiveMessageFromWorker() for ClusterFuture ...
[11:02:42.278] - Validating connection of MultisessionFuture
[11:02:42.278] - received message: FutureResult
[11:02:42.278] - Received FutureResult
[11:02:42.279] - Erased future from FutureRegistry
[11:02:42.279] result() for ClusterFuture ...
[11:02:42.279] - result already collected: FutureResult
[11:02:42.279] result() for ClusterFuture ... done
[11:02:42.279] signalConditions() ...
[11:02:42.279]  - include = ‘immediateCondition’
[11:02:42.279]  - exclude = 
[11:02:42.279]  - resignal = FALSE
[11:02:42.279]  - Number of conditions: 1
[11:02:42.280] signalConditions() ... done
[11:02:42.280] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:42.280] A MultisessionFuture was resolved (result was not collected)
[11:02:42.280] getGlobalsAndPackages() ...
[11:02:42.280] Searching for globals...
[11:02:42.281] - globals found: [2] ‘list’, ‘stop’
[11:02:42.281] Searching for globals ... DONE
[11:02:42.281] Resolving globals: FALSE
[11:02:42.281] 
[11:02:42.281] 
[11:02:42.282] getGlobalsAndPackages() ... DONE
[11:02:42.282] run() for ‘Future’ ...
[11:02:42.282] - state: ‘created’
[11:02:42.282] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:42.297] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:42.297] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:42.297]   - Field: ‘node’
[11:02:42.297]   - Field: ‘label’
[11:02:42.297]   - Field: ‘local’
[11:02:42.297]   - Field: ‘owner’
[11:02:42.297]   - Field: ‘envir’
[11:02:42.297]   - Field: ‘workers’
[11:02:42.297]   - Field: ‘packages’
[11:02:42.298]   - Field: ‘gc’
[11:02:42.298]   - Field: ‘conditions’
[11:02:42.298]   - Field: ‘persistent’
[11:02:42.298]   - Field: ‘expr’
[11:02:42.298]   - Field: ‘uuid’
[11:02:42.298]   - Field: ‘seed’
[11:02:42.298]   - Field: ‘version’
[11:02:42.298]   - Field: ‘result’
[11:02:42.298]   - Field: ‘asynchronous’
[11:02:42.299]   - Field: ‘calls’
[11:02:42.299]   - Field: ‘globals’
[11:02:42.299]   - Field: ‘stdout’
[11:02:42.299]   - Field: ‘earlySignal’
[11:02:42.299]   - Field: ‘lazy’
[11:02:42.299]   - Field: ‘state’
[11:02:42.299] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:42.299] - Launch lazy future ...
[11:02:42.300] Packages needed by the future expression (n = 0): <none>
[11:02:42.300] Packages needed by future strategies (n = 0): <none>
[11:02:42.300] {
[11:02:42.300]     {
[11:02:42.300]         {
[11:02:42.300]             ...future.startTime <- base::Sys.time()
[11:02:42.300]             {
[11:02:42.300]                 {
[11:02:42.300]                   {
[11:02:42.300]                     {
[11:02:42.300]                       base::local({
[11:02:42.300]                         has_future <- base::requireNamespace("future", 
[11:02:42.300]                           quietly = TRUE)
[11:02:42.300]                         if (has_future) {
[11:02:42.300]                           ns <- base::getNamespace("future")
[11:02:42.300]                           version <- ns[[".package"]][["version"]]
[11:02:42.300]                           if (is.null(version)) 
[11:02:42.300]                             version <- utils::packageVersion("future")
[11:02:42.300]                         }
[11:02:42.300]                         else {
[11:02:42.300]                           version <- NULL
[11:02:42.300]                         }
[11:02:42.300]                         if (!has_future || version < "1.8.0") {
[11:02:42.300]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:42.300]                             "", base::R.version$version.string), 
[11:02:42.300]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:42.300]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:42.300]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:42.300]                               "release", "version")], collapse = " "), 
[11:02:42.300]                             hostname = base::Sys.info()[["nodename"]])
[11:02:42.300]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:42.300]                             info)
[11:02:42.300]                           info <- base::paste(info, collapse = "; ")
[11:02:42.300]                           if (!has_future) {
[11:02:42.300]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:42.300]                               info)
[11:02:42.300]                           }
[11:02:42.300]                           else {
[11:02:42.300]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:42.300]                               info, version)
[11:02:42.300]                           }
[11:02:42.300]                           base::stop(msg)
[11:02:42.300]                         }
[11:02:42.300]                       })
[11:02:42.300]                     }
[11:02:42.300]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:42.300]                     base::options(mc.cores = 1L)
[11:02:42.300]                   }
[11:02:42.300]                   ...future.strategy.old <- future::plan("list")
[11:02:42.300]                   options(future.plan = NULL)
[11:02:42.300]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:42.300]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:42.300]                 }
[11:02:42.300]                 ...future.workdir <- getwd()
[11:02:42.300]             }
[11:02:42.300]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:42.300]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:42.300]         }
[11:02:42.300]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:42.300]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:42.300]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:42.300]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:42.300]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:42.300]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:42.300]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:42.300]             base::names(...future.oldOptions))
[11:02:42.300]     }
[11:02:42.300]     if (FALSE) {
[11:02:42.300]     }
[11:02:42.300]     else {
[11:02:42.300]         if (TRUE) {
[11:02:42.300]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:42.300]                 open = "w")
[11:02:42.300]         }
[11:02:42.300]         else {
[11:02:42.300]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:42.300]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:42.300]         }
[11:02:42.300]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:42.300]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:42.300]             base::sink(type = "output", split = FALSE)
[11:02:42.300]             base::close(...future.stdout)
[11:02:42.300]         }, add = TRUE)
[11:02:42.300]     }
[11:02:42.300]     ...future.frame <- base::sys.nframe()
[11:02:42.300]     ...future.conditions <- base::list()
[11:02:42.300]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:42.300]     if (FALSE) {
[11:02:42.300]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:42.300]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:42.300]     }
[11:02:42.300]     ...future.result <- base::tryCatch({
[11:02:42.300]         base::withCallingHandlers({
[11:02:42.300]             ...future.value <- base::withVisible(base::local({
[11:02:42.300]                 ...future.makeSendCondition <- base::local({
[11:02:42.300]                   sendCondition <- NULL
[11:02:42.300]                   function(frame = 1L) {
[11:02:42.300]                     if (is.function(sendCondition)) 
[11:02:42.300]                       return(sendCondition)
[11:02:42.300]                     ns <- getNamespace("parallel")
[11:02:42.300]                     if (exists("sendData", mode = "function", 
[11:02:42.300]                       envir = ns)) {
[11:02:42.300]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:42.300]                         envir = ns)
[11:02:42.300]                       envir <- sys.frame(frame)
[11:02:42.300]                       master <- NULL
[11:02:42.300]                       while (!identical(envir, .GlobalEnv) && 
[11:02:42.300]                         !identical(envir, emptyenv())) {
[11:02:42.300]                         if (exists("master", mode = "list", envir = envir, 
[11:02:42.300]                           inherits = FALSE)) {
[11:02:42.300]                           master <- get("master", mode = "list", 
[11:02:42.300]                             envir = envir, inherits = FALSE)
[11:02:42.300]                           if (inherits(master, c("SOCKnode", 
[11:02:42.300]                             "SOCK0node"))) {
[11:02:42.300]                             sendCondition <<- function(cond) {
[11:02:42.300]                               data <- list(type = "VALUE", value = cond, 
[11:02:42.300]                                 success = TRUE)
[11:02:42.300]                               parallel_sendData(master, data)
[11:02:42.300]                             }
[11:02:42.300]                             return(sendCondition)
[11:02:42.300]                           }
[11:02:42.300]                         }
[11:02:42.300]                         frame <- frame + 1L
[11:02:42.300]                         envir <- sys.frame(frame)
[11:02:42.300]                       }
[11:02:42.300]                     }
[11:02:42.300]                     sendCondition <<- function(cond) NULL
[11:02:42.300]                   }
[11:02:42.300]                 })
[11:02:42.300]                 withCallingHandlers({
[11:02:42.300]                   list(a = 1, b = 42L, c = stop("Nah!"))
[11:02:42.300]                 }, immediateCondition = function(cond) {
[11:02:42.300]                   sendCondition <- ...future.makeSendCondition()
[11:02:42.300]                   sendCondition(cond)
[11:02:42.300]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:42.300]                   {
[11:02:42.300]                     inherits <- base::inherits
[11:02:42.300]                     invokeRestart <- base::invokeRestart
[11:02:42.300]                     is.null <- base::is.null
[11:02:42.300]                     muffled <- FALSE
[11:02:42.300]                     if (inherits(cond, "message")) {
[11:02:42.300]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:42.300]                       if (muffled) 
[11:02:42.300]                         invokeRestart("muffleMessage")
[11:02:42.300]                     }
[11:02:42.300]                     else if (inherits(cond, "warning")) {
[11:02:42.300]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:42.300]                       if (muffled) 
[11:02:42.300]                         invokeRestart("muffleWarning")
[11:02:42.300]                     }
[11:02:42.300]                     else if (inherits(cond, "condition")) {
[11:02:42.300]                       if (!is.null(pattern)) {
[11:02:42.300]                         computeRestarts <- base::computeRestarts
[11:02:42.300]                         grepl <- base::grepl
[11:02:42.300]                         restarts <- computeRestarts(cond)
[11:02:42.300]                         for (restart in restarts) {
[11:02:42.300]                           name <- restart$name
[11:02:42.300]                           if (is.null(name)) 
[11:02:42.300]                             next
[11:02:42.300]                           if (!grepl(pattern, name)) 
[11:02:42.300]                             next
[11:02:42.300]                           invokeRestart(restart)
[11:02:42.300]                           muffled <- TRUE
[11:02:42.300]                           break
[11:02:42.300]                         }
[11:02:42.300]                       }
[11:02:42.300]                     }
[11:02:42.300]                     invisible(muffled)
[11:02:42.300]                   }
[11:02:42.300]                   muffleCondition(cond)
[11:02:42.300]                 })
[11:02:42.300]             }))
[11:02:42.300]             future::FutureResult(value = ...future.value$value, 
[11:02:42.300]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:42.300]                   ...future.rng), globalenv = if (FALSE) 
[11:02:42.300]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:42.300]                     ...future.globalenv.names))
[11:02:42.300]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:42.300]         }, condition = base::local({
[11:02:42.300]             c <- base::c
[11:02:42.300]             inherits <- base::inherits
[11:02:42.300]             invokeRestart <- base::invokeRestart
[11:02:42.300]             length <- base::length
[11:02:42.300]             list <- base::list
[11:02:42.300]             seq.int <- base::seq.int
[11:02:42.300]             signalCondition <- base::signalCondition
[11:02:42.300]             sys.calls <- base::sys.calls
[11:02:42.300]             `[[` <- base::`[[`
[11:02:42.300]             `+` <- base::`+`
[11:02:42.300]             `<<-` <- base::`<<-`
[11:02:42.300]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:42.300]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:42.300]                   3L)]
[11:02:42.300]             }
[11:02:42.300]             function(cond) {
[11:02:42.300]                 is_error <- inherits(cond, "error")
[11:02:42.300]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:42.300]                   NULL)
[11:02:42.300]                 if (is_error) {
[11:02:42.300]                   sessionInformation <- function() {
[11:02:42.300]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:42.300]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:42.300]                       search = base::search(), system = base::Sys.info())
[11:02:42.300]                   }
[11:02:42.300]                   ...future.conditions[[length(...future.conditions) + 
[11:02:42.300]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:42.300]                     cond$call), session = sessionInformation(), 
[11:02:42.300]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:42.300]                   signalCondition(cond)
[11:02:42.300]                 }
[11:02:42.300]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:42.300]                 "immediateCondition"))) {
[11:02:42.300]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:42.300]                   ...future.conditions[[length(...future.conditions) + 
[11:02:42.300]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:42.300]                   if (TRUE && !signal) {
[11:02:42.300]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:42.300]                     {
[11:02:42.300]                       inherits <- base::inherits
[11:02:42.300]                       invokeRestart <- base::invokeRestart
[11:02:42.300]                       is.null <- base::is.null
[11:02:42.300]                       muffled <- FALSE
[11:02:42.300]                       if (inherits(cond, "message")) {
[11:02:42.300]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:42.300]                         if (muffled) 
[11:02:42.300]                           invokeRestart("muffleMessage")
[11:02:42.300]                       }
[11:02:42.300]                       else if (inherits(cond, "warning")) {
[11:02:42.300]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:42.300]                         if (muffled) 
[11:02:42.300]                           invokeRestart("muffleWarning")
[11:02:42.300]                       }
[11:02:42.300]                       else if (inherits(cond, "condition")) {
[11:02:42.300]                         if (!is.null(pattern)) {
[11:02:42.300]                           computeRestarts <- base::computeRestarts
[11:02:42.300]                           grepl <- base::grepl
[11:02:42.300]                           restarts <- computeRestarts(cond)
[11:02:42.300]                           for (restart in restarts) {
[11:02:42.300]                             name <- restart$name
[11:02:42.300]                             if (is.null(name)) 
[11:02:42.300]                               next
[11:02:42.300]                             if (!grepl(pattern, name)) 
[11:02:42.300]                               next
[11:02:42.300]                             invokeRestart(restart)
[11:02:42.300]                             muffled <- TRUE
[11:02:42.300]                             break
[11:02:42.300]                           }
[11:02:42.300]                         }
[11:02:42.300]                       }
[11:02:42.300]                       invisible(muffled)
[11:02:42.300]                     }
[11:02:42.300]                     muffleCondition(cond, pattern = "^muffle")
[11:02:42.300]                   }
[11:02:42.300]                 }
[11:02:42.300]                 else {
[11:02:42.300]                   if (TRUE) {
[11:02:42.300]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:42.300]                     {
[11:02:42.300]                       inherits <- base::inherits
[11:02:42.300]                       invokeRestart <- base::invokeRestart
[11:02:42.300]                       is.null <- base::is.null
[11:02:42.300]                       muffled <- FALSE
[11:02:42.300]                       if (inherits(cond, "message")) {
[11:02:42.300]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:42.300]                         if (muffled) 
[11:02:42.300]                           invokeRestart("muffleMessage")
[11:02:42.300]                       }
[11:02:42.300]                       else if (inherits(cond, "warning")) {
[11:02:42.300]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:42.300]                         if (muffled) 
[11:02:42.300]                           invokeRestart("muffleWarning")
[11:02:42.300]                       }
[11:02:42.300]                       else if (inherits(cond, "condition")) {
[11:02:42.300]                         if (!is.null(pattern)) {
[11:02:42.300]                           computeRestarts <- base::computeRestarts
[11:02:42.300]                           grepl <- base::grepl
[11:02:42.300]                           restarts <- computeRestarts(cond)
[11:02:42.300]                           for (restart in restarts) {
[11:02:42.300]                             name <- restart$name
[11:02:42.300]                             if (is.null(name)) 
[11:02:42.300]                               next
[11:02:42.300]                             if (!grepl(pattern, name)) 
[11:02:42.300]                               next
[11:02:42.300]                             invokeRestart(restart)
[11:02:42.300]                             muffled <- TRUE
[11:02:42.300]                             break
[11:02:42.300]                           }
[11:02:42.300]                         }
[11:02:42.300]                       }
[11:02:42.300]                       invisible(muffled)
[11:02:42.300]                     }
[11:02:42.300]                     muffleCondition(cond, pattern = "^muffle")
[11:02:42.300]                   }
[11:02:42.300]                 }
[11:02:42.300]             }
[11:02:42.300]         }))
[11:02:42.300]     }, error = function(ex) {
[11:02:42.300]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:42.300]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:42.300]                 ...future.rng), started = ...future.startTime, 
[11:02:42.300]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:42.300]             version = "1.8"), class = "FutureResult")
[11:02:42.300]     }, finally = {
[11:02:42.300]         if (!identical(...future.workdir, getwd())) 
[11:02:42.300]             setwd(...future.workdir)
[11:02:42.300]         {
[11:02:42.300]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:42.300]                 ...future.oldOptions$nwarnings <- NULL
[11:02:42.300]             }
[11:02:42.300]             base::options(...future.oldOptions)
[11:02:42.300]             if (.Platform$OS.type == "windows") {
[11:02:42.300]                 old_names <- names(...future.oldEnvVars)
[11:02:42.300]                 envs <- base::Sys.getenv()
[11:02:42.300]                 names <- names(envs)
[11:02:42.300]                 common <- intersect(names, old_names)
[11:02:42.300]                 added <- setdiff(names, old_names)
[11:02:42.300]                 removed <- setdiff(old_names, names)
[11:02:42.300]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:42.300]                   envs[common]]
[11:02:42.300]                 NAMES <- toupper(changed)
[11:02:42.300]                 args <- list()
[11:02:42.300]                 for (kk in seq_along(NAMES)) {
[11:02:42.300]                   name <- changed[[kk]]
[11:02:42.300]                   NAME <- NAMES[[kk]]
[11:02:42.300]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:42.300]                     next
[11:02:42.300]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:42.300]                 }
[11:02:42.300]                 NAMES <- toupper(added)
[11:02:42.300]                 for (kk in seq_along(NAMES)) {
[11:02:42.300]                   name <- added[[kk]]
[11:02:42.300]                   NAME <- NAMES[[kk]]
[11:02:42.300]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:42.300]                     next
[11:02:42.300]                   args[[name]] <- ""
[11:02:42.300]                 }
[11:02:42.300]                 NAMES <- toupper(removed)
[11:02:42.300]                 for (kk in seq_along(NAMES)) {
[11:02:42.300]                   name <- removed[[kk]]
[11:02:42.300]                   NAME <- NAMES[[kk]]
[11:02:42.300]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:42.300]                     next
[11:02:42.300]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:42.300]                 }
[11:02:42.300]                 if (length(args) > 0) 
[11:02:42.300]                   base::do.call(base::Sys.setenv, args = args)
[11:02:42.300]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:42.300]             }
[11:02:42.300]             else {
[11:02:42.300]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:42.300]             }
[11:02:42.300]             {
[11:02:42.300]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:42.300]                   0L) {
[11:02:42.300]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:42.300]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:42.300]                   base::options(opts)
[11:02:42.300]                 }
[11:02:42.300]                 {
[11:02:42.300]                   {
[11:02:42.300]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:42.300]                     NULL
[11:02:42.300]                   }
[11:02:42.300]                   options(future.plan = NULL)
[11:02:42.300]                   if (is.na(NA_character_)) 
[11:02:42.300]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:42.300]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:42.300]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:42.300]                     .init = FALSE)
[11:02:42.300]                 }
[11:02:42.300]             }
[11:02:42.300]         }
[11:02:42.300]     })
[11:02:42.300]     if (TRUE) {
[11:02:42.300]         base::sink(type = "output", split = FALSE)
[11:02:42.300]         if (TRUE) {
[11:02:42.300]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:42.300]         }
[11:02:42.300]         else {
[11:02:42.300]             ...future.result["stdout"] <- base::list(NULL)
[11:02:42.300]         }
[11:02:42.300]         base::close(...future.stdout)
[11:02:42.300]         ...future.stdout <- NULL
[11:02:42.300]     }
[11:02:42.300]     ...future.result$conditions <- ...future.conditions
[11:02:42.300]     ...future.result$finished <- base::Sys.time()
[11:02:42.300]     ...future.result
[11:02:42.300] }
[11:02:42.303] MultisessionFuture started
[11:02:42.304] - Launch lazy future ... done
[11:02:42.304] run() for ‘MultisessionFuture’ ... done
[11:02:42.346] receiveMessageFromWorker() for ClusterFuture ...
[11:02:42.346] - Validating connection of MultisessionFuture
[11:02:42.346] - received message: FutureResult
[11:02:42.346] - Received FutureResult
[11:02:42.346] - Erased future from FutureRegistry
[11:02:42.347] result() for ClusterFuture ...
[11:02:42.347] - result already collected: FutureResult
[11:02:42.347] result() for ClusterFuture ... done
[11:02:42.347] signalConditions() ...
[11:02:42.347]  - include = ‘immediateCondition’
[11:02:42.347]  - exclude = 
[11:02:42.347]  - resignal = FALSE
[11:02:42.347]  - Number of conditions: 1
[11:02:42.347] signalConditions() ... done
[11:02:42.348] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:42.348] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = FALSE ... DONE
- result = FALSE, recursive = TRUE ...
[11:02:42.348] getGlobalsAndPackages() ...
[11:02:42.348] Searching for globals...
[11:02:42.349] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[11:02:42.350] Searching for globals ... DONE
[11:02:42.350] Resolving globals: FALSE
[11:02:42.350] 
[11:02:42.350] 
[11:02:42.350] getGlobalsAndPackages() ... DONE
[11:02:42.351] run() for ‘Future’ ...
[11:02:42.351] - state: ‘created’
[11:02:42.351] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:42.365] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:42.365] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:42.367]   - Field: ‘node’
[11:02:42.367]   - Field: ‘label’
[11:02:42.367]   - Field: ‘local’
[11:02:42.368]   - Field: ‘owner’
[11:02:42.368]   - Field: ‘envir’
[11:02:42.368]   - Field: ‘workers’
[11:02:42.368]   - Field: ‘packages’
[11:02:42.368]   - Field: ‘gc’
[11:02:42.368]   - Field: ‘conditions’
[11:02:42.368]   - Field: ‘persistent’
[11:02:42.368]   - Field: ‘expr’
[11:02:42.368]   - Field: ‘uuid’
[11:02:42.368]   - Field: ‘seed’
[11:02:42.368]   - Field: ‘version’
[11:02:42.368]   - Field: ‘result’
[11:02:42.369]   - Field: ‘asynchronous’
[11:02:42.369]   - Field: ‘calls’
[11:02:42.369]   - Field: ‘globals’
[11:02:42.369]   - Field: ‘stdout’
[11:02:42.369]   - Field: ‘earlySignal’
[11:02:42.369]   - Field: ‘lazy’
[11:02:42.369]   - Field: ‘state’
[11:02:42.369] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:42.369] - Launch lazy future ...
[11:02:42.369] Packages needed by the future expression (n = 0): <none>
[11:02:42.370] Packages needed by future strategies (n = 0): <none>
[11:02:42.370] {
[11:02:42.370]     {
[11:02:42.370]         {
[11:02:42.370]             ...future.startTime <- base::Sys.time()
[11:02:42.370]             {
[11:02:42.370]                 {
[11:02:42.370]                   {
[11:02:42.370]                     {
[11:02:42.370]                       base::local({
[11:02:42.370]                         has_future <- base::requireNamespace("future", 
[11:02:42.370]                           quietly = TRUE)
[11:02:42.370]                         if (has_future) {
[11:02:42.370]                           ns <- base::getNamespace("future")
[11:02:42.370]                           version <- ns[[".package"]][["version"]]
[11:02:42.370]                           if (is.null(version)) 
[11:02:42.370]                             version <- utils::packageVersion("future")
[11:02:42.370]                         }
[11:02:42.370]                         else {
[11:02:42.370]                           version <- NULL
[11:02:42.370]                         }
[11:02:42.370]                         if (!has_future || version < "1.8.0") {
[11:02:42.370]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:42.370]                             "", base::R.version$version.string), 
[11:02:42.370]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:42.370]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:42.370]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:42.370]                               "release", "version")], collapse = " "), 
[11:02:42.370]                             hostname = base::Sys.info()[["nodename"]])
[11:02:42.370]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:42.370]                             info)
[11:02:42.370]                           info <- base::paste(info, collapse = "; ")
[11:02:42.370]                           if (!has_future) {
[11:02:42.370]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:42.370]                               info)
[11:02:42.370]                           }
[11:02:42.370]                           else {
[11:02:42.370]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:42.370]                               info, version)
[11:02:42.370]                           }
[11:02:42.370]                           base::stop(msg)
[11:02:42.370]                         }
[11:02:42.370]                       })
[11:02:42.370]                     }
[11:02:42.370]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:42.370]                     base::options(mc.cores = 1L)
[11:02:42.370]                   }
[11:02:42.370]                   ...future.strategy.old <- future::plan("list")
[11:02:42.370]                   options(future.plan = NULL)
[11:02:42.370]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:42.370]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:42.370]                 }
[11:02:42.370]                 ...future.workdir <- getwd()
[11:02:42.370]             }
[11:02:42.370]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:42.370]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:42.370]         }
[11:02:42.370]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:42.370]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:42.370]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:42.370]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:42.370]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:42.370]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:42.370]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:42.370]             base::names(...future.oldOptions))
[11:02:42.370]     }
[11:02:42.370]     if (FALSE) {
[11:02:42.370]     }
[11:02:42.370]     else {
[11:02:42.370]         if (TRUE) {
[11:02:42.370]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:42.370]                 open = "w")
[11:02:42.370]         }
[11:02:42.370]         else {
[11:02:42.370]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:42.370]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:42.370]         }
[11:02:42.370]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:42.370]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:42.370]             base::sink(type = "output", split = FALSE)
[11:02:42.370]             base::close(...future.stdout)
[11:02:42.370]         }, add = TRUE)
[11:02:42.370]     }
[11:02:42.370]     ...future.frame <- base::sys.nframe()
[11:02:42.370]     ...future.conditions <- base::list()
[11:02:42.370]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:42.370]     if (FALSE) {
[11:02:42.370]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:42.370]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:42.370]     }
[11:02:42.370]     ...future.result <- base::tryCatch({
[11:02:42.370]         base::withCallingHandlers({
[11:02:42.370]             ...future.value <- base::withVisible(base::local({
[11:02:42.370]                 ...future.makeSendCondition <- base::local({
[11:02:42.370]                   sendCondition <- NULL
[11:02:42.370]                   function(frame = 1L) {
[11:02:42.370]                     if (is.function(sendCondition)) 
[11:02:42.370]                       return(sendCondition)
[11:02:42.370]                     ns <- getNamespace("parallel")
[11:02:42.370]                     if (exists("sendData", mode = "function", 
[11:02:42.370]                       envir = ns)) {
[11:02:42.370]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:42.370]                         envir = ns)
[11:02:42.370]                       envir <- sys.frame(frame)
[11:02:42.370]                       master <- NULL
[11:02:42.370]                       while (!identical(envir, .GlobalEnv) && 
[11:02:42.370]                         !identical(envir, emptyenv())) {
[11:02:42.370]                         if (exists("master", mode = "list", envir = envir, 
[11:02:42.370]                           inherits = FALSE)) {
[11:02:42.370]                           master <- get("master", mode = "list", 
[11:02:42.370]                             envir = envir, inherits = FALSE)
[11:02:42.370]                           if (inherits(master, c("SOCKnode", 
[11:02:42.370]                             "SOCK0node"))) {
[11:02:42.370]                             sendCondition <<- function(cond) {
[11:02:42.370]                               data <- list(type = "VALUE", value = cond, 
[11:02:42.370]                                 success = TRUE)
[11:02:42.370]                               parallel_sendData(master, data)
[11:02:42.370]                             }
[11:02:42.370]                             return(sendCondition)
[11:02:42.370]                           }
[11:02:42.370]                         }
[11:02:42.370]                         frame <- frame + 1L
[11:02:42.370]                         envir <- sys.frame(frame)
[11:02:42.370]                       }
[11:02:42.370]                     }
[11:02:42.370]                     sendCondition <<- function(cond) NULL
[11:02:42.370]                   }
[11:02:42.370]                 })
[11:02:42.370]                 withCallingHandlers({
[11:02:42.370]                   {
[11:02:42.370]                     Sys.sleep(0.5)
[11:02:42.370]                     list(a = 1, b = 42L)
[11:02:42.370]                   }
[11:02:42.370]                 }, immediateCondition = function(cond) {
[11:02:42.370]                   sendCondition <- ...future.makeSendCondition()
[11:02:42.370]                   sendCondition(cond)
[11:02:42.370]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:42.370]                   {
[11:02:42.370]                     inherits <- base::inherits
[11:02:42.370]                     invokeRestart <- base::invokeRestart
[11:02:42.370]                     is.null <- base::is.null
[11:02:42.370]                     muffled <- FALSE
[11:02:42.370]                     if (inherits(cond, "message")) {
[11:02:42.370]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:42.370]                       if (muffled) 
[11:02:42.370]                         invokeRestart("muffleMessage")
[11:02:42.370]                     }
[11:02:42.370]                     else if (inherits(cond, "warning")) {
[11:02:42.370]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:42.370]                       if (muffled) 
[11:02:42.370]                         invokeRestart("muffleWarning")
[11:02:42.370]                     }
[11:02:42.370]                     else if (inherits(cond, "condition")) {
[11:02:42.370]                       if (!is.null(pattern)) {
[11:02:42.370]                         computeRestarts <- base::computeRestarts
[11:02:42.370]                         grepl <- base::grepl
[11:02:42.370]                         restarts <- computeRestarts(cond)
[11:02:42.370]                         for (restart in restarts) {
[11:02:42.370]                           name <- restart$name
[11:02:42.370]                           if (is.null(name)) 
[11:02:42.370]                             next
[11:02:42.370]                           if (!grepl(pattern, name)) 
[11:02:42.370]                             next
[11:02:42.370]                           invokeRestart(restart)
[11:02:42.370]                           muffled <- TRUE
[11:02:42.370]                           break
[11:02:42.370]                         }
[11:02:42.370]                       }
[11:02:42.370]                     }
[11:02:42.370]                     invisible(muffled)
[11:02:42.370]                   }
[11:02:42.370]                   muffleCondition(cond)
[11:02:42.370]                 })
[11:02:42.370]             }))
[11:02:42.370]             future::FutureResult(value = ...future.value$value, 
[11:02:42.370]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:42.370]                   ...future.rng), globalenv = if (FALSE) 
[11:02:42.370]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:42.370]                     ...future.globalenv.names))
[11:02:42.370]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:42.370]         }, condition = base::local({
[11:02:42.370]             c <- base::c
[11:02:42.370]             inherits <- base::inherits
[11:02:42.370]             invokeRestart <- base::invokeRestart
[11:02:42.370]             length <- base::length
[11:02:42.370]             list <- base::list
[11:02:42.370]             seq.int <- base::seq.int
[11:02:42.370]             signalCondition <- base::signalCondition
[11:02:42.370]             sys.calls <- base::sys.calls
[11:02:42.370]             `[[` <- base::`[[`
[11:02:42.370]             `+` <- base::`+`
[11:02:42.370]             `<<-` <- base::`<<-`
[11:02:42.370]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:42.370]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:42.370]                   3L)]
[11:02:42.370]             }
[11:02:42.370]             function(cond) {
[11:02:42.370]                 is_error <- inherits(cond, "error")
[11:02:42.370]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:42.370]                   NULL)
[11:02:42.370]                 if (is_error) {
[11:02:42.370]                   sessionInformation <- function() {
[11:02:42.370]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:42.370]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:42.370]                       search = base::search(), system = base::Sys.info())
[11:02:42.370]                   }
[11:02:42.370]                   ...future.conditions[[length(...future.conditions) + 
[11:02:42.370]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:42.370]                     cond$call), session = sessionInformation(), 
[11:02:42.370]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:42.370]                   signalCondition(cond)
[11:02:42.370]                 }
[11:02:42.370]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:42.370]                 "immediateCondition"))) {
[11:02:42.370]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:42.370]                   ...future.conditions[[length(...future.conditions) + 
[11:02:42.370]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:42.370]                   if (TRUE && !signal) {
[11:02:42.370]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:42.370]                     {
[11:02:42.370]                       inherits <- base::inherits
[11:02:42.370]                       invokeRestart <- base::invokeRestart
[11:02:42.370]                       is.null <- base::is.null
[11:02:42.370]                       muffled <- FALSE
[11:02:42.370]                       if (inherits(cond, "message")) {
[11:02:42.370]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:42.370]                         if (muffled) 
[11:02:42.370]                           invokeRestart("muffleMessage")
[11:02:42.370]                       }
[11:02:42.370]                       else if (inherits(cond, "warning")) {
[11:02:42.370]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:42.370]                         if (muffled) 
[11:02:42.370]                           invokeRestart("muffleWarning")
[11:02:42.370]                       }
[11:02:42.370]                       else if (inherits(cond, "condition")) {
[11:02:42.370]                         if (!is.null(pattern)) {
[11:02:42.370]                           computeRestarts <- base::computeRestarts
[11:02:42.370]                           grepl <- base::grepl
[11:02:42.370]                           restarts <- computeRestarts(cond)
[11:02:42.370]                           for (restart in restarts) {
[11:02:42.370]                             name <- restart$name
[11:02:42.370]                             if (is.null(name)) 
[11:02:42.370]                               next
[11:02:42.370]                             if (!grepl(pattern, name)) 
[11:02:42.370]                               next
[11:02:42.370]                             invokeRestart(restart)
[11:02:42.370]                             muffled <- TRUE
[11:02:42.370]                             break
[11:02:42.370]                           }
[11:02:42.370]                         }
[11:02:42.370]                       }
[11:02:42.370]                       invisible(muffled)
[11:02:42.370]                     }
[11:02:42.370]                     muffleCondition(cond, pattern = "^muffle")
[11:02:42.370]                   }
[11:02:42.370]                 }
[11:02:42.370]                 else {
[11:02:42.370]                   if (TRUE) {
[11:02:42.370]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:42.370]                     {
[11:02:42.370]                       inherits <- base::inherits
[11:02:42.370]                       invokeRestart <- base::invokeRestart
[11:02:42.370]                       is.null <- base::is.null
[11:02:42.370]                       muffled <- FALSE
[11:02:42.370]                       if (inherits(cond, "message")) {
[11:02:42.370]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:42.370]                         if (muffled) 
[11:02:42.370]                           invokeRestart("muffleMessage")
[11:02:42.370]                       }
[11:02:42.370]                       else if (inherits(cond, "warning")) {
[11:02:42.370]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:42.370]                         if (muffled) 
[11:02:42.370]                           invokeRestart("muffleWarning")
[11:02:42.370]                       }
[11:02:42.370]                       else if (inherits(cond, "condition")) {
[11:02:42.370]                         if (!is.null(pattern)) {
[11:02:42.370]                           computeRestarts <- base::computeRestarts
[11:02:42.370]                           grepl <- base::grepl
[11:02:42.370]                           restarts <- computeRestarts(cond)
[11:02:42.370]                           for (restart in restarts) {
[11:02:42.370]                             name <- restart$name
[11:02:42.370]                             if (is.null(name)) 
[11:02:42.370]                               next
[11:02:42.370]                             if (!grepl(pattern, name)) 
[11:02:42.370]                               next
[11:02:42.370]                             invokeRestart(restart)
[11:02:42.370]                             muffled <- TRUE
[11:02:42.370]                             break
[11:02:42.370]                           }
[11:02:42.370]                         }
[11:02:42.370]                       }
[11:02:42.370]                       invisible(muffled)
[11:02:42.370]                     }
[11:02:42.370]                     muffleCondition(cond, pattern = "^muffle")
[11:02:42.370]                   }
[11:02:42.370]                 }
[11:02:42.370]             }
[11:02:42.370]         }))
[11:02:42.370]     }, error = function(ex) {
[11:02:42.370]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:42.370]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:42.370]                 ...future.rng), started = ...future.startTime, 
[11:02:42.370]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:42.370]             version = "1.8"), class = "FutureResult")
[11:02:42.370]     }, finally = {
[11:02:42.370]         if (!identical(...future.workdir, getwd())) 
[11:02:42.370]             setwd(...future.workdir)
[11:02:42.370]         {
[11:02:42.370]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:42.370]                 ...future.oldOptions$nwarnings <- NULL
[11:02:42.370]             }
[11:02:42.370]             base::options(...future.oldOptions)
[11:02:42.370]             if (.Platform$OS.type == "windows") {
[11:02:42.370]                 old_names <- names(...future.oldEnvVars)
[11:02:42.370]                 envs <- base::Sys.getenv()
[11:02:42.370]                 names <- names(envs)
[11:02:42.370]                 common <- intersect(names, old_names)
[11:02:42.370]                 added <- setdiff(names, old_names)
[11:02:42.370]                 removed <- setdiff(old_names, names)
[11:02:42.370]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:42.370]                   envs[common]]
[11:02:42.370]                 NAMES <- toupper(changed)
[11:02:42.370]                 args <- list()
[11:02:42.370]                 for (kk in seq_along(NAMES)) {
[11:02:42.370]                   name <- changed[[kk]]
[11:02:42.370]                   NAME <- NAMES[[kk]]
[11:02:42.370]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:42.370]                     next
[11:02:42.370]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:42.370]                 }
[11:02:42.370]                 NAMES <- toupper(added)
[11:02:42.370]                 for (kk in seq_along(NAMES)) {
[11:02:42.370]                   name <- added[[kk]]
[11:02:42.370]                   NAME <- NAMES[[kk]]
[11:02:42.370]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:42.370]                     next
[11:02:42.370]                   args[[name]] <- ""
[11:02:42.370]                 }
[11:02:42.370]                 NAMES <- toupper(removed)
[11:02:42.370]                 for (kk in seq_along(NAMES)) {
[11:02:42.370]                   name <- removed[[kk]]
[11:02:42.370]                   NAME <- NAMES[[kk]]
[11:02:42.370]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:42.370]                     next
[11:02:42.370]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:42.370]                 }
[11:02:42.370]                 if (length(args) > 0) 
[11:02:42.370]                   base::do.call(base::Sys.setenv, args = args)
[11:02:42.370]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:42.370]             }
[11:02:42.370]             else {
[11:02:42.370]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:42.370]             }
[11:02:42.370]             {
[11:02:42.370]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:42.370]                   0L) {
[11:02:42.370]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:42.370]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:42.370]                   base::options(opts)
[11:02:42.370]                 }
[11:02:42.370]                 {
[11:02:42.370]                   {
[11:02:42.370]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:42.370]                     NULL
[11:02:42.370]                   }
[11:02:42.370]                   options(future.plan = NULL)
[11:02:42.370]                   if (is.na(NA_character_)) 
[11:02:42.370]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:42.370]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:42.370]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:42.370]                     .init = FALSE)
[11:02:42.370]                 }
[11:02:42.370]             }
[11:02:42.370]         }
[11:02:42.370]     })
[11:02:42.370]     if (TRUE) {
[11:02:42.370]         base::sink(type = "output", split = FALSE)
[11:02:42.370]         if (TRUE) {
[11:02:42.370]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:42.370]         }
[11:02:42.370]         else {
[11:02:42.370]             ...future.result["stdout"] <- base::list(NULL)
[11:02:42.370]         }
[11:02:42.370]         base::close(...future.stdout)
[11:02:42.370]         ...future.stdout <- NULL
[11:02:42.370]     }
[11:02:42.370]     ...future.result$conditions <- ...future.conditions
[11:02:42.370]     ...future.result$finished <- base::Sys.time()
[11:02:42.370]     ...future.result
[11:02:42.370] }
[11:02:42.373] MultisessionFuture started
[11:02:42.373] - Launch lazy future ... done
[11:02:42.373] run() for ‘MultisessionFuture’ ... done
[11:02:42.916] receiveMessageFromWorker() for ClusterFuture ...
[11:02:42.916] - Validating connection of MultisessionFuture
[11:02:42.916] - received message: FutureResult
[11:02:42.917] - Received FutureResult
[11:02:42.917] - Erased future from FutureRegistry
[11:02:42.917] result() for ClusterFuture ...
[11:02:42.917] - result already collected: FutureResult
[11:02:42.917] result() for ClusterFuture ... done
[11:02:42.917] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:42.917] A MultisessionFuture was resolved (result was not collected)
[11:02:42.917] getGlobalsAndPackages() ...
[11:02:42.917] Searching for globals...
[11:02:42.918] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[11:02:42.918] Searching for globals ... DONE
[11:02:42.919] Resolving globals: FALSE
[11:02:42.919] 
[11:02:42.919] 
[11:02:42.919] getGlobalsAndPackages() ... DONE
[11:02:42.919] run() for ‘Future’ ...
[11:02:42.919] - state: ‘created’
[11:02:42.920] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:42.933] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:42.933] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:42.933]   - Field: ‘node’
[11:02:42.934]   - Field: ‘label’
[11:02:42.934]   - Field: ‘local’
[11:02:42.934]   - Field: ‘owner’
[11:02:42.934]   - Field: ‘envir’
[11:02:42.934]   - Field: ‘workers’
[11:02:42.934]   - Field: ‘packages’
[11:02:42.934]   - Field: ‘gc’
[11:02:42.934]   - Field: ‘conditions’
[11:02:42.934]   - Field: ‘persistent’
[11:02:42.934]   - Field: ‘expr’
[11:02:42.934]   - Field: ‘uuid’
[11:02:42.934]   - Field: ‘seed’
[11:02:42.935]   - Field: ‘version’
[11:02:42.935]   - Field: ‘result’
[11:02:42.935]   - Field: ‘asynchronous’
[11:02:42.935]   - Field: ‘calls’
[11:02:42.935]   - Field: ‘globals’
[11:02:42.935]   - Field: ‘stdout’
[11:02:42.935]   - Field: ‘earlySignal’
[11:02:42.935]   - Field: ‘lazy’
[11:02:42.935]   - Field: ‘state’
[11:02:42.935] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:42.935] - Launch lazy future ...
[11:02:42.936] Packages needed by the future expression (n = 0): <none>
[11:02:42.936] Packages needed by future strategies (n = 0): <none>
[11:02:42.936] {
[11:02:42.936]     {
[11:02:42.936]         {
[11:02:42.936]             ...future.startTime <- base::Sys.time()
[11:02:42.936]             {
[11:02:42.936]                 {
[11:02:42.936]                   {
[11:02:42.936]                     {
[11:02:42.936]                       base::local({
[11:02:42.936]                         has_future <- base::requireNamespace("future", 
[11:02:42.936]                           quietly = TRUE)
[11:02:42.936]                         if (has_future) {
[11:02:42.936]                           ns <- base::getNamespace("future")
[11:02:42.936]                           version <- ns[[".package"]][["version"]]
[11:02:42.936]                           if (is.null(version)) 
[11:02:42.936]                             version <- utils::packageVersion("future")
[11:02:42.936]                         }
[11:02:42.936]                         else {
[11:02:42.936]                           version <- NULL
[11:02:42.936]                         }
[11:02:42.936]                         if (!has_future || version < "1.8.0") {
[11:02:42.936]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:42.936]                             "", base::R.version$version.string), 
[11:02:42.936]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:42.936]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:42.936]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:42.936]                               "release", "version")], collapse = " "), 
[11:02:42.936]                             hostname = base::Sys.info()[["nodename"]])
[11:02:42.936]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:42.936]                             info)
[11:02:42.936]                           info <- base::paste(info, collapse = "; ")
[11:02:42.936]                           if (!has_future) {
[11:02:42.936]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:42.936]                               info)
[11:02:42.936]                           }
[11:02:42.936]                           else {
[11:02:42.936]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:42.936]                               info, version)
[11:02:42.936]                           }
[11:02:42.936]                           base::stop(msg)
[11:02:42.936]                         }
[11:02:42.936]                       })
[11:02:42.936]                     }
[11:02:42.936]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:42.936]                     base::options(mc.cores = 1L)
[11:02:42.936]                   }
[11:02:42.936]                   ...future.strategy.old <- future::plan("list")
[11:02:42.936]                   options(future.plan = NULL)
[11:02:42.936]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:42.936]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:42.936]                 }
[11:02:42.936]                 ...future.workdir <- getwd()
[11:02:42.936]             }
[11:02:42.936]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:42.936]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:42.936]         }
[11:02:42.936]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:42.936]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:42.936]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:42.936]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:42.936]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:42.936]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:42.936]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:42.936]             base::names(...future.oldOptions))
[11:02:42.936]     }
[11:02:42.936]     if (FALSE) {
[11:02:42.936]     }
[11:02:42.936]     else {
[11:02:42.936]         if (TRUE) {
[11:02:42.936]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:42.936]                 open = "w")
[11:02:42.936]         }
[11:02:42.936]         else {
[11:02:42.936]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:42.936]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:42.936]         }
[11:02:42.936]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:42.936]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:42.936]             base::sink(type = "output", split = FALSE)
[11:02:42.936]             base::close(...future.stdout)
[11:02:42.936]         }, add = TRUE)
[11:02:42.936]     }
[11:02:42.936]     ...future.frame <- base::sys.nframe()
[11:02:42.936]     ...future.conditions <- base::list()
[11:02:42.936]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:42.936]     if (FALSE) {
[11:02:42.936]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:42.936]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:42.936]     }
[11:02:42.936]     ...future.result <- base::tryCatch({
[11:02:42.936]         base::withCallingHandlers({
[11:02:42.936]             ...future.value <- base::withVisible(base::local({
[11:02:42.936]                 ...future.makeSendCondition <- base::local({
[11:02:42.936]                   sendCondition <- NULL
[11:02:42.936]                   function(frame = 1L) {
[11:02:42.936]                     if (is.function(sendCondition)) 
[11:02:42.936]                       return(sendCondition)
[11:02:42.936]                     ns <- getNamespace("parallel")
[11:02:42.936]                     if (exists("sendData", mode = "function", 
[11:02:42.936]                       envir = ns)) {
[11:02:42.936]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:42.936]                         envir = ns)
[11:02:42.936]                       envir <- sys.frame(frame)
[11:02:42.936]                       master <- NULL
[11:02:42.936]                       while (!identical(envir, .GlobalEnv) && 
[11:02:42.936]                         !identical(envir, emptyenv())) {
[11:02:42.936]                         if (exists("master", mode = "list", envir = envir, 
[11:02:42.936]                           inherits = FALSE)) {
[11:02:42.936]                           master <- get("master", mode = "list", 
[11:02:42.936]                             envir = envir, inherits = FALSE)
[11:02:42.936]                           if (inherits(master, c("SOCKnode", 
[11:02:42.936]                             "SOCK0node"))) {
[11:02:42.936]                             sendCondition <<- function(cond) {
[11:02:42.936]                               data <- list(type = "VALUE", value = cond, 
[11:02:42.936]                                 success = TRUE)
[11:02:42.936]                               parallel_sendData(master, data)
[11:02:42.936]                             }
[11:02:42.936]                             return(sendCondition)
[11:02:42.936]                           }
[11:02:42.936]                         }
[11:02:42.936]                         frame <- frame + 1L
[11:02:42.936]                         envir <- sys.frame(frame)
[11:02:42.936]                       }
[11:02:42.936]                     }
[11:02:42.936]                     sendCondition <<- function(cond) NULL
[11:02:42.936]                   }
[11:02:42.936]                 })
[11:02:42.936]                 withCallingHandlers({
[11:02:42.936]                   {
[11:02:42.936]                     Sys.sleep(0.5)
[11:02:42.936]                     list(a = 1, b = 42L)
[11:02:42.936]                   }
[11:02:42.936]                 }, immediateCondition = function(cond) {
[11:02:42.936]                   sendCondition <- ...future.makeSendCondition()
[11:02:42.936]                   sendCondition(cond)
[11:02:42.936]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:42.936]                   {
[11:02:42.936]                     inherits <- base::inherits
[11:02:42.936]                     invokeRestart <- base::invokeRestart
[11:02:42.936]                     is.null <- base::is.null
[11:02:42.936]                     muffled <- FALSE
[11:02:42.936]                     if (inherits(cond, "message")) {
[11:02:42.936]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:42.936]                       if (muffled) 
[11:02:42.936]                         invokeRestart("muffleMessage")
[11:02:42.936]                     }
[11:02:42.936]                     else if (inherits(cond, "warning")) {
[11:02:42.936]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:42.936]                       if (muffled) 
[11:02:42.936]                         invokeRestart("muffleWarning")
[11:02:42.936]                     }
[11:02:42.936]                     else if (inherits(cond, "condition")) {
[11:02:42.936]                       if (!is.null(pattern)) {
[11:02:42.936]                         computeRestarts <- base::computeRestarts
[11:02:42.936]                         grepl <- base::grepl
[11:02:42.936]                         restarts <- computeRestarts(cond)
[11:02:42.936]                         for (restart in restarts) {
[11:02:42.936]                           name <- restart$name
[11:02:42.936]                           if (is.null(name)) 
[11:02:42.936]                             next
[11:02:42.936]                           if (!grepl(pattern, name)) 
[11:02:42.936]                             next
[11:02:42.936]                           invokeRestart(restart)
[11:02:42.936]                           muffled <- TRUE
[11:02:42.936]                           break
[11:02:42.936]                         }
[11:02:42.936]                       }
[11:02:42.936]                     }
[11:02:42.936]                     invisible(muffled)
[11:02:42.936]                   }
[11:02:42.936]                   muffleCondition(cond)
[11:02:42.936]                 })
[11:02:42.936]             }))
[11:02:42.936]             future::FutureResult(value = ...future.value$value, 
[11:02:42.936]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:42.936]                   ...future.rng), globalenv = if (FALSE) 
[11:02:42.936]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:42.936]                     ...future.globalenv.names))
[11:02:42.936]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:42.936]         }, condition = base::local({
[11:02:42.936]             c <- base::c
[11:02:42.936]             inherits <- base::inherits
[11:02:42.936]             invokeRestart <- base::invokeRestart
[11:02:42.936]             length <- base::length
[11:02:42.936]             list <- base::list
[11:02:42.936]             seq.int <- base::seq.int
[11:02:42.936]             signalCondition <- base::signalCondition
[11:02:42.936]             sys.calls <- base::sys.calls
[11:02:42.936]             `[[` <- base::`[[`
[11:02:42.936]             `+` <- base::`+`
[11:02:42.936]             `<<-` <- base::`<<-`
[11:02:42.936]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:42.936]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:42.936]                   3L)]
[11:02:42.936]             }
[11:02:42.936]             function(cond) {
[11:02:42.936]                 is_error <- inherits(cond, "error")
[11:02:42.936]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:42.936]                   NULL)
[11:02:42.936]                 if (is_error) {
[11:02:42.936]                   sessionInformation <- function() {
[11:02:42.936]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:42.936]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:42.936]                       search = base::search(), system = base::Sys.info())
[11:02:42.936]                   }
[11:02:42.936]                   ...future.conditions[[length(...future.conditions) + 
[11:02:42.936]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:42.936]                     cond$call), session = sessionInformation(), 
[11:02:42.936]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:42.936]                   signalCondition(cond)
[11:02:42.936]                 }
[11:02:42.936]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:42.936]                 "immediateCondition"))) {
[11:02:42.936]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:42.936]                   ...future.conditions[[length(...future.conditions) + 
[11:02:42.936]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:42.936]                   if (TRUE && !signal) {
[11:02:42.936]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:42.936]                     {
[11:02:42.936]                       inherits <- base::inherits
[11:02:42.936]                       invokeRestart <- base::invokeRestart
[11:02:42.936]                       is.null <- base::is.null
[11:02:42.936]                       muffled <- FALSE
[11:02:42.936]                       if (inherits(cond, "message")) {
[11:02:42.936]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:42.936]                         if (muffled) 
[11:02:42.936]                           invokeRestart("muffleMessage")
[11:02:42.936]                       }
[11:02:42.936]                       else if (inherits(cond, "warning")) {
[11:02:42.936]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:42.936]                         if (muffled) 
[11:02:42.936]                           invokeRestart("muffleWarning")
[11:02:42.936]                       }
[11:02:42.936]                       else if (inherits(cond, "condition")) {
[11:02:42.936]                         if (!is.null(pattern)) {
[11:02:42.936]                           computeRestarts <- base::computeRestarts
[11:02:42.936]                           grepl <- base::grepl
[11:02:42.936]                           restarts <- computeRestarts(cond)
[11:02:42.936]                           for (restart in restarts) {
[11:02:42.936]                             name <- restart$name
[11:02:42.936]                             if (is.null(name)) 
[11:02:42.936]                               next
[11:02:42.936]                             if (!grepl(pattern, name)) 
[11:02:42.936]                               next
[11:02:42.936]                             invokeRestart(restart)
[11:02:42.936]                             muffled <- TRUE
[11:02:42.936]                             break
[11:02:42.936]                           }
[11:02:42.936]                         }
[11:02:42.936]                       }
[11:02:42.936]                       invisible(muffled)
[11:02:42.936]                     }
[11:02:42.936]                     muffleCondition(cond, pattern = "^muffle")
[11:02:42.936]                   }
[11:02:42.936]                 }
[11:02:42.936]                 else {
[11:02:42.936]                   if (TRUE) {
[11:02:42.936]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:42.936]                     {
[11:02:42.936]                       inherits <- base::inherits
[11:02:42.936]                       invokeRestart <- base::invokeRestart
[11:02:42.936]                       is.null <- base::is.null
[11:02:42.936]                       muffled <- FALSE
[11:02:42.936]                       if (inherits(cond, "message")) {
[11:02:42.936]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:42.936]                         if (muffled) 
[11:02:42.936]                           invokeRestart("muffleMessage")
[11:02:42.936]                       }
[11:02:42.936]                       else if (inherits(cond, "warning")) {
[11:02:42.936]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:42.936]                         if (muffled) 
[11:02:42.936]                           invokeRestart("muffleWarning")
[11:02:42.936]                       }
[11:02:42.936]                       else if (inherits(cond, "condition")) {
[11:02:42.936]                         if (!is.null(pattern)) {
[11:02:42.936]                           computeRestarts <- base::computeRestarts
[11:02:42.936]                           grepl <- base::grepl
[11:02:42.936]                           restarts <- computeRestarts(cond)
[11:02:42.936]                           for (restart in restarts) {
[11:02:42.936]                             name <- restart$name
[11:02:42.936]                             if (is.null(name)) 
[11:02:42.936]                               next
[11:02:42.936]                             if (!grepl(pattern, name)) 
[11:02:42.936]                               next
[11:02:42.936]                             invokeRestart(restart)
[11:02:42.936]                             muffled <- TRUE
[11:02:42.936]                             break
[11:02:42.936]                           }
[11:02:42.936]                         }
[11:02:42.936]                       }
[11:02:42.936]                       invisible(muffled)
[11:02:42.936]                     }
[11:02:42.936]                     muffleCondition(cond, pattern = "^muffle")
[11:02:42.936]                   }
[11:02:42.936]                 }
[11:02:42.936]             }
[11:02:42.936]         }))
[11:02:42.936]     }, error = function(ex) {
[11:02:42.936]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:42.936]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:42.936]                 ...future.rng), started = ...future.startTime, 
[11:02:42.936]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:42.936]             version = "1.8"), class = "FutureResult")
[11:02:42.936]     }, finally = {
[11:02:42.936]         if (!identical(...future.workdir, getwd())) 
[11:02:42.936]             setwd(...future.workdir)
[11:02:42.936]         {
[11:02:42.936]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:42.936]                 ...future.oldOptions$nwarnings <- NULL
[11:02:42.936]             }
[11:02:42.936]             base::options(...future.oldOptions)
[11:02:42.936]             if (.Platform$OS.type == "windows") {
[11:02:42.936]                 old_names <- names(...future.oldEnvVars)
[11:02:42.936]                 envs <- base::Sys.getenv()
[11:02:42.936]                 names <- names(envs)
[11:02:42.936]                 common <- intersect(names, old_names)
[11:02:42.936]                 added <- setdiff(names, old_names)
[11:02:42.936]                 removed <- setdiff(old_names, names)
[11:02:42.936]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:42.936]                   envs[common]]
[11:02:42.936]                 NAMES <- toupper(changed)
[11:02:42.936]                 args <- list()
[11:02:42.936]                 for (kk in seq_along(NAMES)) {
[11:02:42.936]                   name <- changed[[kk]]
[11:02:42.936]                   NAME <- NAMES[[kk]]
[11:02:42.936]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:42.936]                     next
[11:02:42.936]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:42.936]                 }
[11:02:42.936]                 NAMES <- toupper(added)
[11:02:42.936]                 for (kk in seq_along(NAMES)) {
[11:02:42.936]                   name <- added[[kk]]
[11:02:42.936]                   NAME <- NAMES[[kk]]
[11:02:42.936]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:42.936]                     next
[11:02:42.936]                   args[[name]] <- ""
[11:02:42.936]                 }
[11:02:42.936]                 NAMES <- toupper(removed)
[11:02:42.936]                 for (kk in seq_along(NAMES)) {
[11:02:42.936]                   name <- removed[[kk]]
[11:02:42.936]                   NAME <- NAMES[[kk]]
[11:02:42.936]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:42.936]                     next
[11:02:42.936]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:42.936]                 }
[11:02:42.936]                 if (length(args) > 0) 
[11:02:42.936]                   base::do.call(base::Sys.setenv, args = args)
[11:02:42.936]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:42.936]             }
[11:02:42.936]             else {
[11:02:42.936]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:42.936]             }
[11:02:42.936]             {
[11:02:42.936]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:42.936]                   0L) {
[11:02:42.936]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:42.936]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:42.936]                   base::options(opts)
[11:02:42.936]                 }
[11:02:42.936]                 {
[11:02:42.936]                   {
[11:02:42.936]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:42.936]                     NULL
[11:02:42.936]                   }
[11:02:42.936]                   options(future.plan = NULL)
[11:02:42.936]                   if (is.na(NA_character_)) 
[11:02:42.936]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:42.936]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:42.936]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:42.936]                     .init = FALSE)
[11:02:42.936]                 }
[11:02:42.936]             }
[11:02:42.936]         }
[11:02:42.936]     })
[11:02:42.936]     if (TRUE) {
[11:02:42.936]         base::sink(type = "output", split = FALSE)
[11:02:42.936]         if (TRUE) {
[11:02:42.936]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:42.936]         }
[11:02:42.936]         else {
[11:02:42.936]             ...future.result["stdout"] <- base::list(NULL)
[11:02:42.936]         }
[11:02:42.936]         base::close(...future.stdout)
[11:02:42.936]         ...future.stdout <- NULL
[11:02:42.936]     }
[11:02:42.936]     ...future.result$conditions <- ...future.conditions
[11:02:42.936]     ...future.result$finished <- base::Sys.time()
[11:02:42.936]     ...future.result
[11:02:42.936] }
[11:02:42.939] MultisessionFuture started
[11:02:42.939] - Launch lazy future ... done
[11:02:42.939] run() for ‘MultisessionFuture’ ... done
[11:02:43.482] receiveMessageFromWorker() for ClusterFuture ...
[11:02:43.482] - Validating connection of MultisessionFuture
[11:02:43.483] - received message: FutureResult
[11:02:43.483] - Received FutureResult
[11:02:43.483] - Erased future from FutureRegistry
[11:02:43.483] result() for ClusterFuture ...
[11:02:43.483] - result already collected: FutureResult
[11:02:43.483] result() for ClusterFuture ... done
[11:02:43.483] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:43.483] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[11:02:43.483] getGlobalsAndPackages() ...
[11:02:43.484] Searching for globals...
[11:02:43.484] - globals found: [2] ‘list’, ‘stop’
[11:02:43.484] Searching for globals ... DONE
[11:02:43.484] Resolving globals: FALSE
[11:02:43.485] 
[11:02:43.485] 
[11:02:43.485] getGlobalsAndPackages() ... DONE
[11:02:43.485] run() for ‘Future’ ...
[11:02:43.485] - state: ‘created’
[11:02:43.485] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:43.499] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:43.499] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:43.499]   - Field: ‘node’
[11:02:43.499]   - Field: ‘label’
[11:02:43.499]   - Field: ‘local’
[11:02:43.499]   - Field: ‘owner’
[11:02:43.500]   - Field: ‘envir’
[11:02:43.500]   - Field: ‘workers’
[11:02:43.500]   - Field: ‘packages’
[11:02:43.500]   - Field: ‘gc’
[11:02:43.500]   - Field: ‘conditions’
[11:02:43.500]   - Field: ‘persistent’
[11:02:43.500]   - Field: ‘expr’
[11:02:43.500]   - Field: ‘uuid’
[11:02:43.500]   - Field: ‘seed’
[11:02:43.500]   - Field: ‘version’
[11:02:43.500]   - Field: ‘result’
[11:02:43.500]   - Field: ‘asynchronous’
[11:02:43.501]   - Field: ‘calls’
[11:02:43.501]   - Field: ‘globals’
[11:02:43.501]   - Field: ‘stdout’
[11:02:43.501]   - Field: ‘earlySignal’
[11:02:43.501]   - Field: ‘lazy’
[11:02:43.501]   - Field: ‘state’
[11:02:43.501] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:43.501] - Launch lazy future ...
[11:02:43.501] Packages needed by the future expression (n = 0): <none>
[11:02:43.501] Packages needed by future strategies (n = 0): <none>
[11:02:43.502] {
[11:02:43.502]     {
[11:02:43.502]         {
[11:02:43.502]             ...future.startTime <- base::Sys.time()
[11:02:43.502]             {
[11:02:43.502]                 {
[11:02:43.502]                   {
[11:02:43.502]                     {
[11:02:43.502]                       base::local({
[11:02:43.502]                         has_future <- base::requireNamespace("future", 
[11:02:43.502]                           quietly = TRUE)
[11:02:43.502]                         if (has_future) {
[11:02:43.502]                           ns <- base::getNamespace("future")
[11:02:43.502]                           version <- ns[[".package"]][["version"]]
[11:02:43.502]                           if (is.null(version)) 
[11:02:43.502]                             version <- utils::packageVersion("future")
[11:02:43.502]                         }
[11:02:43.502]                         else {
[11:02:43.502]                           version <- NULL
[11:02:43.502]                         }
[11:02:43.502]                         if (!has_future || version < "1.8.0") {
[11:02:43.502]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:43.502]                             "", base::R.version$version.string), 
[11:02:43.502]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:43.502]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:43.502]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:43.502]                               "release", "version")], collapse = " "), 
[11:02:43.502]                             hostname = base::Sys.info()[["nodename"]])
[11:02:43.502]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:43.502]                             info)
[11:02:43.502]                           info <- base::paste(info, collapse = "; ")
[11:02:43.502]                           if (!has_future) {
[11:02:43.502]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:43.502]                               info)
[11:02:43.502]                           }
[11:02:43.502]                           else {
[11:02:43.502]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:43.502]                               info, version)
[11:02:43.502]                           }
[11:02:43.502]                           base::stop(msg)
[11:02:43.502]                         }
[11:02:43.502]                       })
[11:02:43.502]                     }
[11:02:43.502]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:43.502]                     base::options(mc.cores = 1L)
[11:02:43.502]                   }
[11:02:43.502]                   ...future.strategy.old <- future::plan("list")
[11:02:43.502]                   options(future.plan = NULL)
[11:02:43.502]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:43.502]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:43.502]                 }
[11:02:43.502]                 ...future.workdir <- getwd()
[11:02:43.502]             }
[11:02:43.502]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:43.502]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:43.502]         }
[11:02:43.502]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:43.502]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:43.502]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:43.502]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:43.502]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:43.502]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:43.502]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:43.502]             base::names(...future.oldOptions))
[11:02:43.502]     }
[11:02:43.502]     if (FALSE) {
[11:02:43.502]     }
[11:02:43.502]     else {
[11:02:43.502]         if (TRUE) {
[11:02:43.502]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:43.502]                 open = "w")
[11:02:43.502]         }
[11:02:43.502]         else {
[11:02:43.502]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:43.502]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:43.502]         }
[11:02:43.502]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:43.502]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:43.502]             base::sink(type = "output", split = FALSE)
[11:02:43.502]             base::close(...future.stdout)
[11:02:43.502]         }, add = TRUE)
[11:02:43.502]     }
[11:02:43.502]     ...future.frame <- base::sys.nframe()
[11:02:43.502]     ...future.conditions <- base::list()
[11:02:43.502]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:43.502]     if (FALSE) {
[11:02:43.502]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:43.502]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:43.502]     }
[11:02:43.502]     ...future.result <- base::tryCatch({
[11:02:43.502]         base::withCallingHandlers({
[11:02:43.502]             ...future.value <- base::withVisible(base::local({
[11:02:43.502]                 ...future.makeSendCondition <- base::local({
[11:02:43.502]                   sendCondition <- NULL
[11:02:43.502]                   function(frame = 1L) {
[11:02:43.502]                     if (is.function(sendCondition)) 
[11:02:43.502]                       return(sendCondition)
[11:02:43.502]                     ns <- getNamespace("parallel")
[11:02:43.502]                     if (exists("sendData", mode = "function", 
[11:02:43.502]                       envir = ns)) {
[11:02:43.502]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:43.502]                         envir = ns)
[11:02:43.502]                       envir <- sys.frame(frame)
[11:02:43.502]                       master <- NULL
[11:02:43.502]                       while (!identical(envir, .GlobalEnv) && 
[11:02:43.502]                         !identical(envir, emptyenv())) {
[11:02:43.502]                         if (exists("master", mode = "list", envir = envir, 
[11:02:43.502]                           inherits = FALSE)) {
[11:02:43.502]                           master <- get("master", mode = "list", 
[11:02:43.502]                             envir = envir, inherits = FALSE)
[11:02:43.502]                           if (inherits(master, c("SOCKnode", 
[11:02:43.502]                             "SOCK0node"))) {
[11:02:43.502]                             sendCondition <<- function(cond) {
[11:02:43.502]                               data <- list(type = "VALUE", value = cond, 
[11:02:43.502]                                 success = TRUE)
[11:02:43.502]                               parallel_sendData(master, data)
[11:02:43.502]                             }
[11:02:43.502]                             return(sendCondition)
[11:02:43.502]                           }
[11:02:43.502]                         }
[11:02:43.502]                         frame <- frame + 1L
[11:02:43.502]                         envir <- sys.frame(frame)
[11:02:43.502]                       }
[11:02:43.502]                     }
[11:02:43.502]                     sendCondition <<- function(cond) NULL
[11:02:43.502]                   }
[11:02:43.502]                 })
[11:02:43.502]                 withCallingHandlers({
[11:02:43.502]                   list(a = 1, b = 42L, c = stop("Nah!"))
[11:02:43.502]                 }, immediateCondition = function(cond) {
[11:02:43.502]                   sendCondition <- ...future.makeSendCondition()
[11:02:43.502]                   sendCondition(cond)
[11:02:43.502]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:43.502]                   {
[11:02:43.502]                     inherits <- base::inherits
[11:02:43.502]                     invokeRestart <- base::invokeRestart
[11:02:43.502]                     is.null <- base::is.null
[11:02:43.502]                     muffled <- FALSE
[11:02:43.502]                     if (inherits(cond, "message")) {
[11:02:43.502]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:43.502]                       if (muffled) 
[11:02:43.502]                         invokeRestart("muffleMessage")
[11:02:43.502]                     }
[11:02:43.502]                     else if (inherits(cond, "warning")) {
[11:02:43.502]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:43.502]                       if (muffled) 
[11:02:43.502]                         invokeRestart("muffleWarning")
[11:02:43.502]                     }
[11:02:43.502]                     else if (inherits(cond, "condition")) {
[11:02:43.502]                       if (!is.null(pattern)) {
[11:02:43.502]                         computeRestarts <- base::computeRestarts
[11:02:43.502]                         grepl <- base::grepl
[11:02:43.502]                         restarts <- computeRestarts(cond)
[11:02:43.502]                         for (restart in restarts) {
[11:02:43.502]                           name <- restart$name
[11:02:43.502]                           if (is.null(name)) 
[11:02:43.502]                             next
[11:02:43.502]                           if (!grepl(pattern, name)) 
[11:02:43.502]                             next
[11:02:43.502]                           invokeRestart(restart)
[11:02:43.502]                           muffled <- TRUE
[11:02:43.502]                           break
[11:02:43.502]                         }
[11:02:43.502]                       }
[11:02:43.502]                     }
[11:02:43.502]                     invisible(muffled)
[11:02:43.502]                   }
[11:02:43.502]                   muffleCondition(cond)
[11:02:43.502]                 })
[11:02:43.502]             }))
[11:02:43.502]             future::FutureResult(value = ...future.value$value, 
[11:02:43.502]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:43.502]                   ...future.rng), globalenv = if (FALSE) 
[11:02:43.502]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:43.502]                     ...future.globalenv.names))
[11:02:43.502]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:43.502]         }, condition = base::local({
[11:02:43.502]             c <- base::c
[11:02:43.502]             inherits <- base::inherits
[11:02:43.502]             invokeRestart <- base::invokeRestart
[11:02:43.502]             length <- base::length
[11:02:43.502]             list <- base::list
[11:02:43.502]             seq.int <- base::seq.int
[11:02:43.502]             signalCondition <- base::signalCondition
[11:02:43.502]             sys.calls <- base::sys.calls
[11:02:43.502]             `[[` <- base::`[[`
[11:02:43.502]             `+` <- base::`+`
[11:02:43.502]             `<<-` <- base::`<<-`
[11:02:43.502]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:43.502]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:43.502]                   3L)]
[11:02:43.502]             }
[11:02:43.502]             function(cond) {
[11:02:43.502]                 is_error <- inherits(cond, "error")
[11:02:43.502]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:43.502]                   NULL)
[11:02:43.502]                 if (is_error) {
[11:02:43.502]                   sessionInformation <- function() {
[11:02:43.502]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:43.502]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:43.502]                       search = base::search(), system = base::Sys.info())
[11:02:43.502]                   }
[11:02:43.502]                   ...future.conditions[[length(...future.conditions) + 
[11:02:43.502]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:43.502]                     cond$call), session = sessionInformation(), 
[11:02:43.502]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:43.502]                   signalCondition(cond)
[11:02:43.502]                 }
[11:02:43.502]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:43.502]                 "immediateCondition"))) {
[11:02:43.502]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:43.502]                   ...future.conditions[[length(...future.conditions) + 
[11:02:43.502]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:43.502]                   if (TRUE && !signal) {
[11:02:43.502]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:43.502]                     {
[11:02:43.502]                       inherits <- base::inherits
[11:02:43.502]                       invokeRestart <- base::invokeRestart
[11:02:43.502]                       is.null <- base::is.null
[11:02:43.502]                       muffled <- FALSE
[11:02:43.502]                       if (inherits(cond, "message")) {
[11:02:43.502]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:43.502]                         if (muffled) 
[11:02:43.502]                           invokeRestart("muffleMessage")
[11:02:43.502]                       }
[11:02:43.502]                       else if (inherits(cond, "warning")) {
[11:02:43.502]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:43.502]                         if (muffled) 
[11:02:43.502]                           invokeRestart("muffleWarning")
[11:02:43.502]                       }
[11:02:43.502]                       else if (inherits(cond, "condition")) {
[11:02:43.502]                         if (!is.null(pattern)) {
[11:02:43.502]                           computeRestarts <- base::computeRestarts
[11:02:43.502]                           grepl <- base::grepl
[11:02:43.502]                           restarts <- computeRestarts(cond)
[11:02:43.502]                           for (restart in restarts) {
[11:02:43.502]                             name <- restart$name
[11:02:43.502]                             if (is.null(name)) 
[11:02:43.502]                               next
[11:02:43.502]                             if (!grepl(pattern, name)) 
[11:02:43.502]                               next
[11:02:43.502]                             invokeRestart(restart)
[11:02:43.502]                             muffled <- TRUE
[11:02:43.502]                             break
[11:02:43.502]                           }
[11:02:43.502]                         }
[11:02:43.502]                       }
[11:02:43.502]                       invisible(muffled)
[11:02:43.502]                     }
[11:02:43.502]                     muffleCondition(cond, pattern = "^muffle")
[11:02:43.502]                   }
[11:02:43.502]                 }
[11:02:43.502]                 else {
[11:02:43.502]                   if (TRUE) {
[11:02:43.502]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:43.502]                     {
[11:02:43.502]                       inherits <- base::inherits
[11:02:43.502]                       invokeRestart <- base::invokeRestart
[11:02:43.502]                       is.null <- base::is.null
[11:02:43.502]                       muffled <- FALSE
[11:02:43.502]                       if (inherits(cond, "message")) {
[11:02:43.502]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:43.502]                         if (muffled) 
[11:02:43.502]                           invokeRestart("muffleMessage")
[11:02:43.502]                       }
[11:02:43.502]                       else if (inherits(cond, "warning")) {
[11:02:43.502]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:43.502]                         if (muffled) 
[11:02:43.502]                           invokeRestart("muffleWarning")
[11:02:43.502]                       }
[11:02:43.502]                       else if (inherits(cond, "condition")) {
[11:02:43.502]                         if (!is.null(pattern)) {
[11:02:43.502]                           computeRestarts <- base::computeRestarts
[11:02:43.502]                           grepl <- base::grepl
[11:02:43.502]                           restarts <- computeRestarts(cond)
[11:02:43.502]                           for (restart in restarts) {
[11:02:43.502]                             name <- restart$name
[11:02:43.502]                             if (is.null(name)) 
[11:02:43.502]                               next
[11:02:43.502]                             if (!grepl(pattern, name)) 
[11:02:43.502]                               next
[11:02:43.502]                             invokeRestart(restart)
[11:02:43.502]                             muffled <- TRUE
[11:02:43.502]                             break
[11:02:43.502]                           }
[11:02:43.502]                         }
[11:02:43.502]                       }
[11:02:43.502]                       invisible(muffled)
[11:02:43.502]                     }
[11:02:43.502]                     muffleCondition(cond, pattern = "^muffle")
[11:02:43.502]                   }
[11:02:43.502]                 }
[11:02:43.502]             }
[11:02:43.502]         }))
[11:02:43.502]     }, error = function(ex) {
[11:02:43.502]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:43.502]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:43.502]                 ...future.rng), started = ...future.startTime, 
[11:02:43.502]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:43.502]             version = "1.8"), class = "FutureResult")
[11:02:43.502]     }, finally = {
[11:02:43.502]         if (!identical(...future.workdir, getwd())) 
[11:02:43.502]             setwd(...future.workdir)
[11:02:43.502]         {
[11:02:43.502]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:43.502]                 ...future.oldOptions$nwarnings <- NULL
[11:02:43.502]             }
[11:02:43.502]             base::options(...future.oldOptions)
[11:02:43.502]             if (.Platform$OS.type == "windows") {
[11:02:43.502]                 old_names <- names(...future.oldEnvVars)
[11:02:43.502]                 envs <- base::Sys.getenv()
[11:02:43.502]                 names <- names(envs)
[11:02:43.502]                 common <- intersect(names, old_names)
[11:02:43.502]                 added <- setdiff(names, old_names)
[11:02:43.502]                 removed <- setdiff(old_names, names)
[11:02:43.502]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:43.502]                   envs[common]]
[11:02:43.502]                 NAMES <- toupper(changed)
[11:02:43.502]                 args <- list()
[11:02:43.502]                 for (kk in seq_along(NAMES)) {
[11:02:43.502]                   name <- changed[[kk]]
[11:02:43.502]                   NAME <- NAMES[[kk]]
[11:02:43.502]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:43.502]                     next
[11:02:43.502]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:43.502]                 }
[11:02:43.502]                 NAMES <- toupper(added)
[11:02:43.502]                 for (kk in seq_along(NAMES)) {
[11:02:43.502]                   name <- added[[kk]]
[11:02:43.502]                   NAME <- NAMES[[kk]]
[11:02:43.502]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:43.502]                     next
[11:02:43.502]                   args[[name]] <- ""
[11:02:43.502]                 }
[11:02:43.502]                 NAMES <- toupper(removed)
[11:02:43.502]                 for (kk in seq_along(NAMES)) {
[11:02:43.502]                   name <- removed[[kk]]
[11:02:43.502]                   NAME <- NAMES[[kk]]
[11:02:43.502]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:43.502]                     next
[11:02:43.502]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:43.502]                 }
[11:02:43.502]                 if (length(args) > 0) 
[11:02:43.502]                   base::do.call(base::Sys.setenv, args = args)
[11:02:43.502]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:43.502]             }
[11:02:43.502]             else {
[11:02:43.502]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:43.502]             }
[11:02:43.502]             {
[11:02:43.502]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:43.502]                   0L) {
[11:02:43.502]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:43.502]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:43.502]                   base::options(opts)
[11:02:43.502]                 }
[11:02:43.502]                 {
[11:02:43.502]                   {
[11:02:43.502]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:43.502]                     NULL
[11:02:43.502]                   }
[11:02:43.502]                   options(future.plan = NULL)
[11:02:43.502]                   if (is.na(NA_character_)) 
[11:02:43.502]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:43.502]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:43.502]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:43.502]                     .init = FALSE)
[11:02:43.502]                 }
[11:02:43.502]             }
[11:02:43.502]         }
[11:02:43.502]     })
[11:02:43.502]     if (TRUE) {
[11:02:43.502]         base::sink(type = "output", split = FALSE)
[11:02:43.502]         if (TRUE) {
[11:02:43.502]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:43.502]         }
[11:02:43.502]         else {
[11:02:43.502]             ...future.result["stdout"] <- base::list(NULL)
[11:02:43.502]         }
[11:02:43.502]         base::close(...future.stdout)
[11:02:43.502]         ...future.stdout <- NULL
[11:02:43.502]     }
[11:02:43.502]     ...future.result$conditions <- ...future.conditions
[11:02:43.502]     ...future.result$finished <- base::Sys.time()
[11:02:43.502]     ...future.result
[11:02:43.502] }
[11:02:43.505] MultisessionFuture started
[11:02:43.505] - Launch lazy future ... done
[11:02:43.505] run() for ‘MultisessionFuture’ ... done
[11:02:43.547] receiveMessageFromWorker() for ClusterFuture ...
[11:02:43.547] - Validating connection of MultisessionFuture
[11:02:43.548] - received message: FutureResult
[11:02:43.548] - Received FutureResult
[11:02:43.548] - Erased future from FutureRegistry
[11:02:43.548] result() for ClusterFuture ...
[11:02:43.548] - result already collected: FutureResult
[11:02:43.548] result() for ClusterFuture ... done
[11:02:43.548] signalConditions() ...
[11:02:43.549]  - include = ‘immediateCondition’
[11:02:43.549]  - exclude = 
[11:02:43.549]  - resignal = FALSE
[11:02:43.549]  - Number of conditions: 1
[11:02:43.549] signalConditions() ... done
[11:02:43.549] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:43.549] A MultisessionFuture was resolved (result was not collected)
[11:02:43.549] getGlobalsAndPackages() ...
[11:02:43.549] Searching for globals...
[11:02:43.550] - globals found: [2] ‘list’, ‘stop’
[11:02:43.550] Searching for globals ... DONE
[11:02:43.550] Resolving globals: FALSE
[11:02:43.550] 
[11:02:43.550] 
[11:02:43.550] getGlobalsAndPackages() ... DONE
[11:02:43.551] run() for ‘Future’ ...
[11:02:43.551] - state: ‘created’
[11:02:43.551] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:43.564] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:43.564] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:43.564]   - Field: ‘node’
[11:02:43.564]   - Field: ‘label’
[11:02:43.565]   - Field: ‘local’
[11:02:43.565]   - Field: ‘owner’
[11:02:43.565]   - Field: ‘envir’
[11:02:43.565]   - Field: ‘workers’
[11:02:43.565]   - Field: ‘packages’
[11:02:43.565]   - Field: ‘gc’
[11:02:43.565]   - Field: ‘conditions’
[11:02:43.565]   - Field: ‘persistent’
[11:02:43.565]   - Field: ‘expr’
[11:02:43.565]   - Field: ‘uuid’
[11:02:43.565]   - Field: ‘seed’
[11:02:43.566]   - Field: ‘version’
[11:02:43.566]   - Field: ‘result’
[11:02:43.566]   - Field: ‘asynchronous’
[11:02:43.566]   - Field: ‘calls’
[11:02:43.566]   - Field: ‘globals’
[11:02:43.566]   - Field: ‘stdout’
[11:02:43.566]   - Field: ‘earlySignal’
[11:02:43.566]   - Field: ‘lazy’
[11:02:43.566]   - Field: ‘state’
[11:02:43.566] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:43.566] - Launch lazy future ...
[11:02:43.567] Packages needed by the future expression (n = 0): <none>
[11:02:43.567] Packages needed by future strategies (n = 0): <none>
[11:02:43.567] {
[11:02:43.567]     {
[11:02:43.567]         {
[11:02:43.567]             ...future.startTime <- base::Sys.time()
[11:02:43.567]             {
[11:02:43.567]                 {
[11:02:43.567]                   {
[11:02:43.567]                     {
[11:02:43.567]                       base::local({
[11:02:43.567]                         has_future <- base::requireNamespace("future", 
[11:02:43.567]                           quietly = TRUE)
[11:02:43.567]                         if (has_future) {
[11:02:43.567]                           ns <- base::getNamespace("future")
[11:02:43.567]                           version <- ns[[".package"]][["version"]]
[11:02:43.567]                           if (is.null(version)) 
[11:02:43.567]                             version <- utils::packageVersion("future")
[11:02:43.567]                         }
[11:02:43.567]                         else {
[11:02:43.567]                           version <- NULL
[11:02:43.567]                         }
[11:02:43.567]                         if (!has_future || version < "1.8.0") {
[11:02:43.567]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:43.567]                             "", base::R.version$version.string), 
[11:02:43.567]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:43.567]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:43.567]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:43.567]                               "release", "version")], collapse = " "), 
[11:02:43.567]                             hostname = base::Sys.info()[["nodename"]])
[11:02:43.567]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:43.567]                             info)
[11:02:43.567]                           info <- base::paste(info, collapse = "; ")
[11:02:43.567]                           if (!has_future) {
[11:02:43.567]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:43.567]                               info)
[11:02:43.567]                           }
[11:02:43.567]                           else {
[11:02:43.567]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:43.567]                               info, version)
[11:02:43.567]                           }
[11:02:43.567]                           base::stop(msg)
[11:02:43.567]                         }
[11:02:43.567]                       })
[11:02:43.567]                     }
[11:02:43.567]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:43.567]                     base::options(mc.cores = 1L)
[11:02:43.567]                   }
[11:02:43.567]                   ...future.strategy.old <- future::plan("list")
[11:02:43.567]                   options(future.plan = NULL)
[11:02:43.567]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:43.567]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:43.567]                 }
[11:02:43.567]                 ...future.workdir <- getwd()
[11:02:43.567]             }
[11:02:43.567]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:43.567]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:43.567]         }
[11:02:43.567]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:43.567]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:43.567]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:43.567]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:43.567]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:43.567]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:43.567]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:43.567]             base::names(...future.oldOptions))
[11:02:43.567]     }
[11:02:43.567]     if (FALSE) {
[11:02:43.567]     }
[11:02:43.567]     else {
[11:02:43.567]         if (TRUE) {
[11:02:43.567]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:43.567]                 open = "w")
[11:02:43.567]         }
[11:02:43.567]         else {
[11:02:43.567]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:43.567]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:43.567]         }
[11:02:43.567]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:43.567]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:43.567]             base::sink(type = "output", split = FALSE)
[11:02:43.567]             base::close(...future.stdout)
[11:02:43.567]         }, add = TRUE)
[11:02:43.567]     }
[11:02:43.567]     ...future.frame <- base::sys.nframe()
[11:02:43.567]     ...future.conditions <- base::list()
[11:02:43.567]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:43.567]     if (FALSE) {
[11:02:43.567]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:43.567]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:43.567]     }
[11:02:43.567]     ...future.result <- base::tryCatch({
[11:02:43.567]         base::withCallingHandlers({
[11:02:43.567]             ...future.value <- base::withVisible(base::local({
[11:02:43.567]                 ...future.makeSendCondition <- base::local({
[11:02:43.567]                   sendCondition <- NULL
[11:02:43.567]                   function(frame = 1L) {
[11:02:43.567]                     if (is.function(sendCondition)) 
[11:02:43.567]                       return(sendCondition)
[11:02:43.567]                     ns <- getNamespace("parallel")
[11:02:43.567]                     if (exists("sendData", mode = "function", 
[11:02:43.567]                       envir = ns)) {
[11:02:43.567]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:43.567]                         envir = ns)
[11:02:43.567]                       envir <- sys.frame(frame)
[11:02:43.567]                       master <- NULL
[11:02:43.567]                       while (!identical(envir, .GlobalEnv) && 
[11:02:43.567]                         !identical(envir, emptyenv())) {
[11:02:43.567]                         if (exists("master", mode = "list", envir = envir, 
[11:02:43.567]                           inherits = FALSE)) {
[11:02:43.567]                           master <- get("master", mode = "list", 
[11:02:43.567]                             envir = envir, inherits = FALSE)
[11:02:43.567]                           if (inherits(master, c("SOCKnode", 
[11:02:43.567]                             "SOCK0node"))) {
[11:02:43.567]                             sendCondition <<- function(cond) {
[11:02:43.567]                               data <- list(type = "VALUE", value = cond, 
[11:02:43.567]                                 success = TRUE)
[11:02:43.567]                               parallel_sendData(master, data)
[11:02:43.567]                             }
[11:02:43.567]                             return(sendCondition)
[11:02:43.567]                           }
[11:02:43.567]                         }
[11:02:43.567]                         frame <- frame + 1L
[11:02:43.567]                         envir <- sys.frame(frame)
[11:02:43.567]                       }
[11:02:43.567]                     }
[11:02:43.567]                     sendCondition <<- function(cond) NULL
[11:02:43.567]                   }
[11:02:43.567]                 })
[11:02:43.567]                 withCallingHandlers({
[11:02:43.567]                   list(a = 1, b = 42L, c = stop("Nah!"))
[11:02:43.567]                 }, immediateCondition = function(cond) {
[11:02:43.567]                   sendCondition <- ...future.makeSendCondition()
[11:02:43.567]                   sendCondition(cond)
[11:02:43.567]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:43.567]                   {
[11:02:43.567]                     inherits <- base::inherits
[11:02:43.567]                     invokeRestart <- base::invokeRestart
[11:02:43.567]                     is.null <- base::is.null
[11:02:43.567]                     muffled <- FALSE
[11:02:43.567]                     if (inherits(cond, "message")) {
[11:02:43.567]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:43.567]                       if (muffled) 
[11:02:43.567]                         invokeRestart("muffleMessage")
[11:02:43.567]                     }
[11:02:43.567]                     else if (inherits(cond, "warning")) {
[11:02:43.567]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:43.567]                       if (muffled) 
[11:02:43.567]                         invokeRestart("muffleWarning")
[11:02:43.567]                     }
[11:02:43.567]                     else if (inherits(cond, "condition")) {
[11:02:43.567]                       if (!is.null(pattern)) {
[11:02:43.567]                         computeRestarts <- base::computeRestarts
[11:02:43.567]                         grepl <- base::grepl
[11:02:43.567]                         restarts <- computeRestarts(cond)
[11:02:43.567]                         for (restart in restarts) {
[11:02:43.567]                           name <- restart$name
[11:02:43.567]                           if (is.null(name)) 
[11:02:43.567]                             next
[11:02:43.567]                           if (!grepl(pattern, name)) 
[11:02:43.567]                             next
[11:02:43.567]                           invokeRestart(restart)
[11:02:43.567]                           muffled <- TRUE
[11:02:43.567]                           break
[11:02:43.567]                         }
[11:02:43.567]                       }
[11:02:43.567]                     }
[11:02:43.567]                     invisible(muffled)
[11:02:43.567]                   }
[11:02:43.567]                   muffleCondition(cond)
[11:02:43.567]                 })
[11:02:43.567]             }))
[11:02:43.567]             future::FutureResult(value = ...future.value$value, 
[11:02:43.567]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:43.567]                   ...future.rng), globalenv = if (FALSE) 
[11:02:43.567]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:43.567]                     ...future.globalenv.names))
[11:02:43.567]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:43.567]         }, condition = base::local({
[11:02:43.567]             c <- base::c
[11:02:43.567]             inherits <- base::inherits
[11:02:43.567]             invokeRestart <- base::invokeRestart
[11:02:43.567]             length <- base::length
[11:02:43.567]             list <- base::list
[11:02:43.567]             seq.int <- base::seq.int
[11:02:43.567]             signalCondition <- base::signalCondition
[11:02:43.567]             sys.calls <- base::sys.calls
[11:02:43.567]             `[[` <- base::`[[`
[11:02:43.567]             `+` <- base::`+`
[11:02:43.567]             `<<-` <- base::`<<-`
[11:02:43.567]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:43.567]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:43.567]                   3L)]
[11:02:43.567]             }
[11:02:43.567]             function(cond) {
[11:02:43.567]                 is_error <- inherits(cond, "error")
[11:02:43.567]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:43.567]                   NULL)
[11:02:43.567]                 if (is_error) {
[11:02:43.567]                   sessionInformation <- function() {
[11:02:43.567]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:43.567]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:43.567]                       search = base::search(), system = base::Sys.info())
[11:02:43.567]                   }
[11:02:43.567]                   ...future.conditions[[length(...future.conditions) + 
[11:02:43.567]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:43.567]                     cond$call), session = sessionInformation(), 
[11:02:43.567]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:43.567]                   signalCondition(cond)
[11:02:43.567]                 }
[11:02:43.567]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:43.567]                 "immediateCondition"))) {
[11:02:43.567]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:43.567]                   ...future.conditions[[length(...future.conditions) + 
[11:02:43.567]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:43.567]                   if (TRUE && !signal) {
[11:02:43.567]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:43.567]                     {
[11:02:43.567]                       inherits <- base::inherits
[11:02:43.567]                       invokeRestart <- base::invokeRestart
[11:02:43.567]                       is.null <- base::is.null
[11:02:43.567]                       muffled <- FALSE
[11:02:43.567]                       if (inherits(cond, "message")) {
[11:02:43.567]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:43.567]                         if (muffled) 
[11:02:43.567]                           invokeRestart("muffleMessage")
[11:02:43.567]                       }
[11:02:43.567]                       else if (inherits(cond, "warning")) {
[11:02:43.567]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:43.567]                         if (muffled) 
[11:02:43.567]                           invokeRestart("muffleWarning")
[11:02:43.567]                       }
[11:02:43.567]                       else if (inherits(cond, "condition")) {
[11:02:43.567]                         if (!is.null(pattern)) {
[11:02:43.567]                           computeRestarts <- base::computeRestarts
[11:02:43.567]                           grepl <- base::grepl
[11:02:43.567]                           restarts <- computeRestarts(cond)
[11:02:43.567]                           for (restart in restarts) {
[11:02:43.567]                             name <- restart$name
[11:02:43.567]                             if (is.null(name)) 
[11:02:43.567]                               next
[11:02:43.567]                             if (!grepl(pattern, name)) 
[11:02:43.567]                               next
[11:02:43.567]                             invokeRestart(restart)
[11:02:43.567]                             muffled <- TRUE
[11:02:43.567]                             break
[11:02:43.567]                           }
[11:02:43.567]                         }
[11:02:43.567]                       }
[11:02:43.567]                       invisible(muffled)
[11:02:43.567]                     }
[11:02:43.567]                     muffleCondition(cond, pattern = "^muffle")
[11:02:43.567]                   }
[11:02:43.567]                 }
[11:02:43.567]                 else {
[11:02:43.567]                   if (TRUE) {
[11:02:43.567]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:43.567]                     {
[11:02:43.567]                       inherits <- base::inherits
[11:02:43.567]                       invokeRestart <- base::invokeRestart
[11:02:43.567]                       is.null <- base::is.null
[11:02:43.567]                       muffled <- FALSE
[11:02:43.567]                       if (inherits(cond, "message")) {
[11:02:43.567]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:43.567]                         if (muffled) 
[11:02:43.567]                           invokeRestart("muffleMessage")
[11:02:43.567]                       }
[11:02:43.567]                       else if (inherits(cond, "warning")) {
[11:02:43.567]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:43.567]                         if (muffled) 
[11:02:43.567]                           invokeRestart("muffleWarning")
[11:02:43.567]                       }
[11:02:43.567]                       else if (inherits(cond, "condition")) {
[11:02:43.567]                         if (!is.null(pattern)) {
[11:02:43.567]                           computeRestarts <- base::computeRestarts
[11:02:43.567]                           grepl <- base::grepl
[11:02:43.567]                           restarts <- computeRestarts(cond)
[11:02:43.567]                           for (restart in restarts) {
[11:02:43.567]                             name <- restart$name
[11:02:43.567]                             if (is.null(name)) 
[11:02:43.567]                               next
[11:02:43.567]                             if (!grepl(pattern, name)) 
[11:02:43.567]                               next
[11:02:43.567]                             invokeRestart(restart)
[11:02:43.567]                             muffled <- TRUE
[11:02:43.567]                             break
[11:02:43.567]                           }
[11:02:43.567]                         }
[11:02:43.567]                       }
[11:02:43.567]                       invisible(muffled)
[11:02:43.567]                     }
[11:02:43.567]                     muffleCondition(cond, pattern = "^muffle")
[11:02:43.567]                   }
[11:02:43.567]                 }
[11:02:43.567]             }
[11:02:43.567]         }))
[11:02:43.567]     }, error = function(ex) {
[11:02:43.567]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:43.567]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:43.567]                 ...future.rng), started = ...future.startTime, 
[11:02:43.567]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:43.567]             version = "1.8"), class = "FutureResult")
[11:02:43.567]     }, finally = {
[11:02:43.567]         if (!identical(...future.workdir, getwd())) 
[11:02:43.567]             setwd(...future.workdir)
[11:02:43.567]         {
[11:02:43.567]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:43.567]                 ...future.oldOptions$nwarnings <- NULL
[11:02:43.567]             }
[11:02:43.567]             base::options(...future.oldOptions)
[11:02:43.567]             if (.Platform$OS.type == "windows") {
[11:02:43.567]                 old_names <- names(...future.oldEnvVars)
[11:02:43.567]                 envs <- base::Sys.getenv()
[11:02:43.567]                 names <- names(envs)
[11:02:43.567]                 common <- intersect(names, old_names)
[11:02:43.567]                 added <- setdiff(names, old_names)
[11:02:43.567]                 removed <- setdiff(old_names, names)
[11:02:43.567]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:43.567]                   envs[common]]
[11:02:43.567]                 NAMES <- toupper(changed)
[11:02:43.567]                 args <- list()
[11:02:43.567]                 for (kk in seq_along(NAMES)) {
[11:02:43.567]                   name <- changed[[kk]]
[11:02:43.567]                   NAME <- NAMES[[kk]]
[11:02:43.567]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:43.567]                     next
[11:02:43.567]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:43.567]                 }
[11:02:43.567]                 NAMES <- toupper(added)
[11:02:43.567]                 for (kk in seq_along(NAMES)) {
[11:02:43.567]                   name <- added[[kk]]
[11:02:43.567]                   NAME <- NAMES[[kk]]
[11:02:43.567]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:43.567]                     next
[11:02:43.567]                   args[[name]] <- ""
[11:02:43.567]                 }
[11:02:43.567]                 NAMES <- toupper(removed)
[11:02:43.567]                 for (kk in seq_along(NAMES)) {
[11:02:43.567]                   name <- removed[[kk]]
[11:02:43.567]                   NAME <- NAMES[[kk]]
[11:02:43.567]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:43.567]                     next
[11:02:43.567]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:43.567]                 }
[11:02:43.567]                 if (length(args) > 0) 
[11:02:43.567]                   base::do.call(base::Sys.setenv, args = args)
[11:02:43.567]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:43.567]             }
[11:02:43.567]             else {
[11:02:43.567]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:43.567]             }
[11:02:43.567]             {
[11:02:43.567]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:43.567]                   0L) {
[11:02:43.567]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:43.567]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:43.567]                   base::options(opts)
[11:02:43.567]                 }
[11:02:43.567]                 {
[11:02:43.567]                   {
[11:02:43.567]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:43.567]                     NULL
[11:02:43.567]                   }
[11:02:43.567]                   options(future.plan = NULL)
[11:02:43.567]                   if (is.na(NA_character_)) 
[11:02:43.567]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:43.567]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:43.567]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:43.567]                     .init = FALSE)
[11:02:43.567]                 }
[11:02:43.567]             }
[11:02:43.567]         }
[11:02:43.567]     })
[11:02:43.567]     if (TRUE) {
[11:02:43.567]         base::sink(type = "output", split = FALSE)
[11:02:43.567]         if (TRUE) {
[11:02:43.567]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:43.567]         }
[11:02:43.567]         else {
[11:02:43.567]             ...future.result["stdout"] <- base::list(NULL)
[11:02:43.567]         }
[11:02:43.567]         base::close(...future.stdout)
[11:02:43.567]         ...future.stdout <- NULL
[11:02:43.567]     }
[11:02:43.567]     ...future.result$conditions <- ...future.conditions
[11:02:43.567]     ...future.result$finished <- base::Sys.time()
[11:02:43.567]     ...future.result
[11:02:43.567] }
[11:02:43.570] MultisessionFuture started
[11:02:43.570] - Launch lazy future ... done
[11:02:43.570] run() for ‘MultisessionFuture’ ... done
[11:02:43.612] receiveMessageFromWorker() for ClusterFuture ...
[11:02:43.612] - Validating connection of MultisessionFuture
[11:02:43.613] - received message: FutureResult
[11:02:43.613] - Received FutureResult
[11:02:43.613] - Erased future from FutureRegistry
[11:02:43.613] result() for ClusterFuture ...
[11:02:43.613] - result already collected: FutureResult
[11:02:43.613] result() for ClusterFuture ... done
[11:02:43.613] signalConditions() ...
[11:02:43.613]  - include = ‘immediateCondition’
[11:02:43.613]  - exclude = 
[11:02:43.614]  - resignal = FALSE
[11:02:43.614]  - Number of conditions: 1
[11:02:43.614] signalConditions() ... done
[11:02:43.614] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:43.614] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = TRUE ... DONE
- result = FALSE, recursive = -1 ...
[11:02:43.614] getGlobalsAndPackages() ...
[11:02:43.614] Searching for globals...
[11:02:43.615] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[11:02:43.615] Searching for globals ... DONE
[11:02:43.615] Resolving globals: FALSE
[11:02:43.616] 
[11:02:43.616] 
[11:02:43.616] getGlobalsAndPackages() ... DONE
[11:02:43.616] run() for ‘Future’ ...
[11:02:43.616] - state: ‘created’
[11:02:43.616] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:43.630] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:43.630] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:43.630]   - Field: ‘node’
[11:02:43.630]   - Field: ‘label’
[11:02:43.630]   - Field: ‘local’
[11:02:43.630]   - Field: ‘owner’
[11:02:43.630]   - Field: ‘envir’
[11:02:43.630]   - Field: ‘workers’
[11:02:43.631]   - Field: ‘packages’
[11:02:43.631]   - Field: ‘gc’
[11:02:43.631]   - Field: ‘conditions’
[11:02:43.631]   - Field: ‘persistent’
[11:02:43.631]   - Field: ‘expr’
[11:02:43.631]   - Field: ‘uuid’
[11:02:43.631]   - Field: ‘seed’
[11:02:43.631]   - Field: ‘version’
[11:02:43.631]   - Field: ‘result’
[11:02:43.631]   - Field: ‘asynchronous’
[11:02:43.631]   - Field: ‘calls’
[11:02:43.631]   - Field: ‘globals’
[11:02:43.632]   - Field: ‘stdout’
[11:02:43.632]   - Field: ‘earlySignal’
[11:02:43.632]   - Field: ‘lazy’
[11:02:43.632]   - Field: ‘state’
[11:02:43.632] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:43.632] - Launch lazy future ...
[11:02:43.632] Packages needed by the future expression (n = 0): <none>
[11:02:43.632] Packages needed by future strategies (n = 0): <none>
[11:02:43.633] {
[11:02:43.633]     {
[11:02:43.633]         {
[11:02:43.633]             ...future.startTime <- base::Sys.time()
[11:02:43.633]             {
[11:02:43.633]                 {
[11:02:43.633]                   {
[11:02:43.633]                     {
[11:02:43.633]                       base::local({
[11:02:43.633]                         has_future <- base::requireNamespace("future", 
[11:02:43.633]                           quietly = TRUE)
[11:02:43.633]                         if (has_future) {
[11:02:43.633]                           ns <- base::getNamespace("future")
[11:02:43.633]                           version <- ns[[".package"]][["version"]]
[11:02:43.633]                           if (is.null(version)) 
[11:02:43.633]                             version <- utils::packageVersion("future")
[11:02:43.633]                         }
[11:02:43.633]                         else {
[11:02:43.633]                           version <- NULL
[11:02:43.633]                         }
[11:02:43.633]                         if (!has_future || version < "1.8.0") {
[11:02:43.633]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:43.633]                             "", base::R.version$version.string), 
[11:02:43.633]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:43.633]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:43.633]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:43.633]                               "release", "version")], collapse = " "), 
[11:02:43.633]                             hostname = base::Sys.info()[["nodename"]])
[11:02:43.633]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:43.633]                             info)
[11:02:43.633]                           info <- base::paste(info, collapse = "; ")
[11:02:43.633]                           if (!has_future) {
[11:02:43.633]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:43.633]                               info)
[11:02:43.633]                           }
[11:02:43.633]                           else {
[11:02:43.633]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:43.633]                               info, version)
[11:02:43.633]                           }
[11:02:43.633]                           base::stop(msg)
[11:02:43.633]                         }
[11:02:43.633]                       })
[11:02:43.633]                     }
[11:02:43.633]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:43.633]                     base::options(mc.cores = 1L)
[11:02:43.633]                   }
[11:02:43.633]                   ...future.strategy.old <- future::plan("list")
[11:02:43.633]                   options(future.plan = NULL)
[11:02:43.633]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:43.633]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:43.633]                 }
[11:02:43.633]                 ...future.workdir <- getwd()
[11:02:43.633]             }
[11:02:43.633]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:43.633]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:43.633]         }
[11:02:43.633]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:43.633]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:43.633]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:43.633]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:43.633]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:43.633]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:43.633]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:43.633]             base::names(...future.oldOptions))
[11:02:43.633]     }
[11:02:43.633]     if (FALSE) {
[11:02:43.633]     }
[11:02:43.633]     else {
[11:02:43.633]         if (TRUE) {
[11:02:43.633]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:43.633]                 open = "w")
[11:02:43.633]         }
[11:02:43.633]         else {
[11:02:43.633]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:43.633]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:43.633]         }
[11:02:43.633]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:43.633]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:43.633]             base::sink(type = "output", split = FALSE)
[11:02:43.633]             base::close(...future.stdout)
[11:02:43.633]         }, add = TRUE)
[11:02:43.633]     }
[11:02:43.633]     ...future.frame <- base::sys.nframe()
[11:02:43.633]     ...future.conditions <- base::list()
[11:02:43.633]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:43.633]     if (FALSE) {
[11:02:43.633]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:43.633]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:43.633]     }
[11:02:43.633]     ...future.result <- base::tryCatch({
[11:02:43.633]         base::withCallingHandlers({
[11:02:43.633]             ...future.value <- base::withVisible(base::local({
[11:02:43.633]                 ...future.makeSendCondition <- base::local({
[11:02:43.633]                   sendCondition <- NULL
[11:02:43.633]                   function(frame = 1L) {
[11:02:43.633]                     if (is.function(sendCondition)) 
[11:02:43.633]                       return(sendCondition)
[11:02:43.633]                     ns <- getNamespace("parallel")
[11:02:43.633]                     if (exists("sendData", mode = "function", 
[11:02:43.633]                       envir = ns)) {
[11:02:43.633]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:43.633]                         envir = ns)
[11:02:43.633]                       envir <- sys.frame(frame)
[11:02:43.633]                       master <- NULL
[11:02:43.633]                       while (!identical(envir, .GlobalEnv) && 
[11:02:43.633]                         !identical(envir, emptyenv())) {
[11:02:43.633]                         if (exists("master", mode = "list", envir = envir, 
[11:02:43.633]                           inherits = FALSE)) {
[11:02:43.633]                           master <- get("master", mode = "list", 
[11:02:43.633]                             envir = envir, inherits = FALSE)
[11:02:43.633]                           if (inherits(master, c("SOCKnode", 
[11:02:43.633]                             "SOCK0node"))) {
[11:02:43.633]                             sendCondition <<- function(cond) {
[11:02:43.633]                               data <- list(type = "VALUE", value = cond, 
[11:02:43.633]                                 success = TRUE)
[11:02:43.633]                               parallel_sendData(master, data)
[11:02:43.633]                             }
[11:02:43.633]                             return(sendCondition)
[11:02:43.633]                           }
[11:02:43.633]                         }
[11:02:43.633]                         frame <- frame + 1L
[11:02:43.633]                         envir <- sys.frame(frame)
[11:02:43.633]                       }
[11:02:43.633]                     }
[11:02:43.633]                     sendCondition <<- function(cond) NULL
[11:02:43.633]                   }
[11:02:43.633]                 })
[11:02:43.633]                 withCallingHandlers({
[11:02:43.633]                   {
[11:02:43.633]                     Sys.sleep(0.5)
[11:02:43.633]                     list(a = 1, b = 42L)
[11:02:43.633]                   }
[11:02:43.633]                 }, immediateCondition = function(cond) {
[11:02:43.633]                   sendCondition <- ...future.makeSendCondition()
[11:02:43.633]                   sendCondition(cond)
[11:02:43.633]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:43.633]                   {
[11:02:43.633]                     inherits <- base::inherits
[11:02:43.633]                     invokeRestart <- base::invokeRestart
[11:02:43.633]                     is.null <- base::is.null
[11:02:43.633]                     muffled <- FALSE
[11:02:43.633]                     if (inherits(cond, "message")) {
[11:02:43.633]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:43.633]                       if (muffled) 
[11:02:43.633]                         invokeRestart("muffleMessage")
[11:02:43.633]                     }
[11:02:43.633]                     else if (inherits(cond, "warning")) {
[11:02:43.633]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:43.633]                       if (muffled) 
[11:02:43.633]                         invokeRestart("muffleWarning")
[11:02:43.633]                     }
[11:02:43.633]                     else if (inherits(cond, "condition")) {
[11:02:43.633]                       if (!is.null(pattern)) {
[11:02:43.633]                         computeRestarts <- base::computeRestarts
[11:02:43.633]                         grepl <- base::grepl
[11:02:43.633]                         restarts <- computeRestarts(cond)
[11:02:43.633]                         for (restart in restarts) {
[11:02:43.633]                           name <- restart$name
[11:02:43.633]                           if (is.null(name)) 
[11:02:43.633]                             next
[11:02:43.633]                           if (!grepl(pattern, name)) 
[11:02:43.633]                             next
[11:02:43.633]                           invokeRestart(restart)
[11:02:43.633]                           muffled <- TRUE
[11:02:43.633]                           break
[11:02:43.633]                         }
[11:02:43.633]                       }
[11:02:43.633]                     }
[11:02:43.633]                     invisible(muffled)
[11:02:43.633]                   }
[11:02:43.633]                   muffleCondition(cond)
[11:02:43.633]                 })
[11:02:43.633]             }))
[11:02:43.633]             future::FutureResult(value = ...future.value$value, 
[11:02:43.633]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:43.633]                   ...future.rng), globalenv = if (FALSE) 
[11:02:43.633]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:43.633]                     ...future.globalenv.names))
[11:02:43.633]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:43.633]         }, condition = base::local({
[11:02:43.633]             c <- base::c
[11:02:43.633]             inherits <- base::inherits
[11:02:43.633]             invokeRestart <- base::invokeRestart
[11:02:43.633]             length <- base::length
[11:02:43.633]             list <- base::list
[11:02:43.633]             seq.int <- base::seq.int
[11:02:43.633]             signalCondition <- base::signalCondition
[11:02:43.633]             sys.calls <- base::sys.calls
[11:02:43.633]             `[[` <- base::`[[`
[11:02:43.633]             `+` <- base::`+`
[11:02:43.633]             `<<-` <- base::`<<-`
[11:02:43.633]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:43.633]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:43.633]                   3L)]
[11:02:43.633]             }
[11:02:43.633]             function(cond) {
[11:02:43.633]                 is_error <- inherits(cond, "error")
[11:02:43.633]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:43.633]                   NULL)
[11:02:43.633]                 if (is_error) {
[11:02:43.633]                   sessionInformation <- function() {
[11:02:43.633]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:43.633]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:43.633]                       search = base::search(), system = base::Sys.info())
[11:02:43.633]                   }
[11:02:43.633]                   ...future.conditions[[length(...future.conditions) + 
[11:02:43.633]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:43.633]                     cond$call), session = sessionInformation(), 
[11:02:43.633]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:43.633]                   signalCondition(cond)
[11:02:43.633]                 }
[11:02:43.633]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:43.633]                 "immediateCondition"))) {
[11:02:43.633]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:43.633]                   ...future.conditions[[length(...future.conditions) + 
[11:02:43.633]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:43.633]                   if (TRUE && !signal) {
[11:02:43.633]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:43.633]                     {
[11:02:43.633]                       inherits <- base::inherits
[11:02:43.633]                       invokeRestart <- base::invokeRestart
[11:02:43.633]                       is.null <- base::is.null
[11:02:43.633]                       muffled <- FALSE
[11:02:43.633]                       if (inherits(cond, "message")) {
[11:02:43.633]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:43.633]                         if (muffled) 
[11:02:43.633]                           invokeRestart("muffleMessage")
[11:02:43.633]                       }
[11:02:43.633]                       else if (inherits(cond, "warning")) {
[11:02:43.633]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:43.633]                         if (muffled) 
[11:02:43.633]                           invokeRestart("muffleWarning")
[11:02:43.633]                       }
[11:02:43.633]                       else if (inherits(cond, "condition")) {
[11:02:43.633]                         if (!is.null(pattern)) {
[11:02:43.633]                           computeRestarts <- base::computeRestarts
[11:02:43.633]                           grepl <- base::grepl
[11:02:43.633]                           restarts <- computeRestarts(cond)
[11:02:43.633]                           for (restart in restarts) {
[11:02:43.633]                             name <- restart$name
[11:02:43.633]                             if (is.null(name)) 
[11:02:43.633]                               next
[11:02:43.633]                             if (!grepl(pattern, name)) 
[11:02:43.633]                               next
[11:02:43.633]                             invokeRestart(restart)
[11:02:43.633]                             muffled <- TRUE
[11:02:43.633]                             break
[11:02:43.633]                           }
[11:02:43.633]                         }
[11:02:43.633]                       }
[11:02:43.633]                       invisible(muffled)
[11:02:43.633]                     }
[11:02:43.633]                     muffleCondition(cond, pattern = "^muffle")
[11:02:43.633]                   }
[11:02:43.633]                 }
[11:02:43.633]                 else {
[11:02:43.633]                   if (TRUE) {
[11:02:43.633]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:43.633]                     {
[11:02:43.633]                       inherits <- base::inherits
[11:02:43.633]                       invokeRestart <- base::invokeRestart
[11:02:43.633]                       is.null <- base::is.null
[11:02:43.633]                       muffled <- FALSE
[11:02:43.633]                       if (inherits(cond, "message")) {
[11:02:43.633]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:43.633]                         if (muffled) 
[11:02:43.633]                           invokeRestart("muffleMessage")
[11:02:43.633]                       }
[11:02:43.633]                       else if (inherits(cond, "warning")) {
[11:02:43.633]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:43.633]                         if (muffled) 
[11:02:43.633]                           invokeRestart("muffleWarning")
[11:02:43.633]                       }
[11:02:43.633]                       else if (inherits(cond, "condition")) {
[11:02:43.633]                         if (!is.null(pattern)) {
[11:02:43.633]                           computeRestarts <- base::computeRestarts
[11:02:43.633]                           grepl <- base::grepl
[11:02:43.633]                           restarts <- computeRestarts(cond)
[11:02:43.633]                           for (restart in restarts) {
[11:02:43.633]                             name <- restart$name
[11:02:43.633]                             if (is.null(name)) 
[11:02:43.633]                               next
[11:02:43.633]                             if (!grepl(pattern, name)) 
[11:02:43.633]                               next
[11:02:43.633]                             invokeRestart(restart)
[11:02:43.633]                             muffled <- TRUE
[11:02:43.633]                             break
[11:02:43.633]                           }
[11:02:43.633]                         }
[11:02:43.633]                       }
[11:02:43.633]                       invisible(muffled)
[11:02:43.633]                     }
[11:02:43.633]                     muffleCondition(cond, pattern = "^muffle")
[11:02:43.633]                   }
[11:02:43.633]                 }
[11:02:43.633]             }
[11:02:43.633]         }))
[11:02:43.633]     }, error = function(ex) {
[11:02:43.633]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:43.633]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:43.633]                 ...future.rng), started = ...future.startTime, 
[11:02:43.633]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:43.633]             version = "1.8"), class = "FutureResult")
[11:02:43.633]     }, finally = {
[11:02:43.633]         if (!identical(...future.workdir, getwd())) 
[11:02:43.633]             setwd(...future.workdir)
[11:02:43.633]         {
[11:02:43.633]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:43.633]                 ...future.oldOptions$nwarnings <- NULL
[11:02:43.633]             }
[11:02:43.633]             base::options(...future.oldOptions)
[11:02:43.633]             if (.Platform$OS.type == "windows") {
[11:02:43.633]                 old_names <- names(...future.oldEnvVars)
[11:02:43.633]                 envs <- base::Sys.getenv()
[11:02:43.633]                 names <- names(envs)
[11:02:43.633]                 common <- intersect(names, old_names)
[11:02:43.633]                 added <- setdiff(names, old_names)
[11:02:43.633]                 removed <- setdiff(old_names, names)
[11:02:43.633]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:43.633]                   envs[common]]
[11:02:43.633]                 NAMES <- toupper(changed)
[11:02:43.633]                 args <- list()
[11:02:43.633]                 for (kk in seq_along(NAMES)) {
[11:02:43.633]                   name <- changed[[kk]]
[11:02:43.633]                   NAME <- NAMES[[kk]]
[11:02:43.633]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:43.633]                     next
[11:02:43.633]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:43.633]                 }
[11:02:43.633]                 NAMES <- toupper(added)
[11:02:43.633]                 for (kk in seq_along(NAMES)) {
[11:02:43.633]                   name <- added[[kk]]
[11:02:43.633]                   NAME <- NAMES[[kk]]
[11:02:43.633]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:43.633]                     next
[11:02:43.633]                   args[[name]] <- ""
[11:02:43.633]                 }
[11:02:43.633]                 NAMES <- toupper(removed)
[11:02:43.633]                 for (kk in seq_along(NAMES)) {
[11:02:43.633]                   name <- removed[[kk]]
[11:02:43.633]                   NAME <- NAMES[[kk]]
[11:02:43.633]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:43.633]                     next
[11:02:43.633]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:43.633]                 }
[11:02:43.633]                 if (length(args) > 0) 
[11:02:43.633]                   base::do.call(base::Sys.setenv, args = args)
[11:02:43.633]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:43.633]             }
[11:02:43.633]             else {
[11:02:43.633]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:43.633]             }
[11:02:43.633]             {
[11:02:43.633]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:43.633]                   0L) {
[11:02:43.633]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:43.633]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:43.633]                   base::options(opts)
[11:02:43.633]                 }
[11:02:43.633]                 {
[11:02:43.633]                   {
[11:02:43.633]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:43.633]                     NULL
[11:02:43.633]                   }
[11:02:43.633]                   options(future.plan = NULL)
[11:02:43.633]                   if (is.na(NA_character_)) 
[11:02:43.633]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:43.633]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:43.633]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:43.633]                     .init = FALSE)
[11:02:43.633]                 }
[11:02:43.633]             }
[11:02:43.633]         }
[11:02:43.633]     })
[11:02:43.633]     if (TRUE) {
[11:02:43.633]         base::sink(type = "output", split = FALSE)
[11:02:43.633]         if (TRUE) {
[11:02:43.633]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:43.633]         }
[11:02:43.633]         else {
[11:02:43.633]             ...future.result["stdout"] <- base::list(NULL)
[11:02:43.633]         }
[11:02:43.633]         base::close(...future.stdout)
[11:02:43.633]         ...future.stdout <- NULL
[11:02:43.633]     }
[11:02:43.633]     ...future.result$conditions <- ...future.conditions
[11:02:43.633]     ...future.result$finished <- base::Sys.time()
[11:02:43.633]     ...future.result
[11:02:43.633] }
[11:02:43.636] MultisessionFuture started
[11:02:43.636] - Launch lazy future ... done
[11:02:43.636] run() for ‘MultisessionFuture’ ... done
[11:02:43.636] getGlobalsAndPackages() ...
[11:02:43.636] Searching for globals...
[11:02:43.637] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[11:02:43.637] Searching for globals ... DONE
[11:02:43.637] Resolving globals: FALSE
[11:02:43.637] 
[11:02:43.638] 
[11:02:43.638] getGlobalsAndPackages() ... DONE
- w/ exception ...
[11:02:43.638] getGlobalsAndPackages() ...
[11:02:43.638] Searching for globals...
[11:02:43.639] - globals found: [2] ‘list’, ‘stop’
[11:02:43.639] Searching for globals ... DONE
[11:02:43.639] Resolving globals: FALSE
[11:02:43.639] 
[11:02:43.639] 
[11:02:43.639] getGlobalsAndPackages() ... DONE
[11:02:43.639] run() for ‘Future’ ...
[11:02:43.639] - state: ‘created’
[11:02:43.640] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:43.653] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:43.653] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:43.653]   - Field: ‘node’
[11:02:43.653]   - Field: ‘label’
[11:02:43.654]   - Field: ‘local’
[11:02:43.654]   - Field: ‘owner’
[11:02:43.654]   - Field: ‘envir’
[11:02:43.654]   - Field: ‘workers’
[11:02:43.654]   - Field: ‘packages’
[11:02:43.654]   - Field: ‘gc’
[11:02:43.654]   - Field: ‘conditions’
[11:02:43.654]   - Field: ‘persistent’
[11:02:43.654]   - Field: ‘expr’
[11:02:43.654]   - Field: ‘uuid’
[11:02:43.654]   - Field: ‘seed’
[11:02:43.654]   - Field: ‘version’
[11:02:43.655]   - Field: ‘result’
[11:02:43.655]   - Field: ‘asynchronous’
[11:02:43.655]   - Field: ‘calls’
[11:02:43.655]   - Field: ‘globals’
[11:02:43.655]   - Field: ‘stdout’
[11:02:43.655]   - Field: ‘earlySignal’
[11:02:43.655]   - Field: ‘lazy’
[11:02:43.655]   - Field: ‘state’
[11:02:43.655] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:43.655] - Launch lazy future ...
[11:02:43.656] Packages needed by the future expression (n = 0): <none>
[11:02:43.656] Packages needed by future strategies (n = 0): <none>
[11:02:43.656] {
[11:02:43.656]     {
[11:02:43.656]         {
[11:02:43.656]             ...future.startTime <- base::Sys.time()
[11:02:43.656]             {
[11:02:43.656]                 {
[11:02:43.656]                   {
[11:02:43.656]                     {
[11:02:43.656]                       base::local({
[11:02:43.656]                         has_future <- base::requireNamespace("future", 
[11:02:43.656]                           quietly = TRUE)
[11:02:43.656]                         if (has_future) {
[11:02:43.656]                           ns <- base::getNamespace("future")
[11:02:43.656]                           version <- ns[[".package"]][["version"]]
[11:02:43.656]                           if (is.null(version)) 
[11:02:43.656]                             version <- utils::packageVersion("future")
[11:02:43.656]                         }
[11:02:43.656]                         else {
[11:02:43.656]                           version <- NULL
[11:02:43.656]                         }
[11:02:43.656]                         if (!has_future || version < "1.8.0") {
[11:02:43.656]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:43.656]                             "", base::R.version$version.string), 
[11:02:43.656]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:43.656]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:43.656]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:43.656]                               "release", "version")], collapse = " "), 
[11:02:43.656]                             hostname = base::Sys.info()[["nodename"]])
[11:02:43.656]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:43.656]                             info)
[11:02:43.656]                           info <- base::paste(info, collapse = "; ")
[11:02:43.656]                           if (!has_future) {
[11:02:43.656]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:43.656]                               info)
[11:02:43.656]                           }
[11:02:43.656]                           else {
[11:02:43.656]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:43.656]                               info, version)
[11:02:43.656]                           }
[11:02:43.656]                           base::stop(msg)
[11:02:43.656]                         }
[11:02:43.656]                       })
[11:02:43.656]                     }
[11:02:43.656]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:43.656]                     base::options(mc.cores = 1L)
[11:02:43.656]                   }
[11:02:43.656]                   ...future.strategy.old <- future::plan("list")
[11:02:43.656]                   options(future.plan = NULL)
[11:02:43.656]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:43.656]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:43.656]                 }
[11:02:43.656]                 ...future.workdir <- getwd()
[11:02:43.656]             }
[11:02:43.656]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:43.656]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:43.656]         }
[11:02:43.656]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:43.656]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:43.656]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:43.656]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:43.656]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:43.656]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:43.656]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:43.656]             base::names(...future.oldOptions))
[11:02:43.656]     }
[11:02:43.656]     if (FALSE) {
[11:02:43.656]     }
[11:02:43.656]     else {
[11:02:43.656]         if (TRUE) {
[11:02:43.656]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:43.656]                 open = "w")
[11:02:43.656]         }
[11:02:43.656]         else {
[11:02:43.656]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:43.656]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:43.656]         }
[11:02:43.656]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:43.656]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:43.656]             base::sink(type = "output", split = FALSE)
[11:02:43.656]             base::close(...future.stdout)
[11:02:43.656]         }, add = TRUE)
[11:02:43.656]     }
[11:02:43.656]     ...future.frame <- base::sys.nframe()
[11:02:43.656]     ...future.conditions <- base::list()
[11:02:43.656]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:43.656]     if (FALSE) {
[11:02:43.656]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:43.656]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:43.656]     }
[11:02:43.656]     ...future.result <- base::tryCatch({
[11:02:43.656]         base::withCallingHandlers({
[11:02:43.656]             ...future.value <- base::withVisible(base::local({
[11:02:43.656]                 ...future.makeSendCondition <- base::local({
[11:02:43.656]                   sendCondition <- NULL
[11:02:43.656]                   function(frame = 1L) {
[11:02:43.656]                     if (is.function(sendCondition)) 
[11:02:43.656]                       return(sendCondition)
[11:02:43.656]                     ns <- getNamespace("parallel")
[11:02:43.656]                     if (exists("sendData", mode = "function", 
[11:02:43.656]                       envir = ns)) {
[11:02:43.656]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:43.656]                         envir = ns)
[11:02:43.656]                       envir <- sys.frame(frame)
[11:02:43.656]                       master <- NULL
[11:02:43.656]                       while (!identical(envir, .GlobalEnv) && 
[11:02:43.656]                         !identical(envir, emptyenv())) {
[11:02:43.656]                         if (exists("master", mode = "list", envir = envir, 
[11:02:43.656]                           inherits = FALSE)) {
[11:02:43.656]                           master <- get("master", mode = "list", 
[11:02:43.656]                             envir = envir, inherits = FALSE)
[11:02:43.656]                           if (inherits(master, c("SOCKnode", 
[11:02:43.656]                             "SOCK0node"))) {
[11:02:43.656]                             sendCondition <<- function(cond) {
[11:02:43.656]                               data <- list(type = "VALUE", value = cond, 
[11:02:43.656]                                 success = TRUE)
[11:02:43.656]                               parallel_sendData(master, data)
[11:02:43.656]                             }
[11:02:43.656]                             return(sendCondition)
[11:02:43.656]                           }
[11:02:43.656]                         }
[11:02:43.656]                         frame <- frame + 1L
[11:02:43.656]                         envir <- sys.frame(frame)
[11:02:43.656]                       }
[11:02:43.656]                     }
[11:02:43.656]                     sendCondition <<- function(cond) NULL
[11:02:43.656]                   }
[11:02:43.656]                 })
[11:02:43.656]                 withCallingHandlers({
[11:02:43.656]                   list(a = 1, b = 42L, c = stop("Nah!"))
[11:02:43.656]                 }, immediateCondition = function(cond) {
[11:02:43.656]                   sendCondition <- ...future.makeSendCondition()
[11:02:43.656]                   sendCondition(cond)
[11:02:43.656]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:43.656]                   {
[11:02:43.656]                     inherits <- base::inherits
[11:02:43.656]                     invokeRestart <- base::invokeRestart
[11:02:43.656]                     is.null <- base::is.null
[11:02:43.656]                     muffled <- FALSE
[11:02:43.656]                     if (inherits(cond, "message")) {
[11:02:43.656]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:43.656]                       if (muffled) 
[11:02:43.656]                         invokeRestart("muffleMessage")
[11:02:43.656]                     }
[11:02:43.656]                     else if (inherits(cond, "warning")) {
[11:02:43.656]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:43.656]                       if (muffled) 
[11:02:43.656]                         invokeRestart("muffleWarning")
[11:02:43.656]                     }
[11:02:43.656]                     else if (inherits(cond, "condition")) {
[11:02:43.656]                       if (!is.null(pattern)) {
[11:02:43.656]                         computeRestarts <- base::computeRestarts
[11:02:43.656]                         grepl <- base::grepl
[11:02:43.656]                         restarts <- computeRestarts(cond)
[11:02:43.656]                         for (restart in restarts) {
[11:02:43.656]                           name <- restart$name
[11:02:43.656]                           if (is.null(name)) 
[11:02:43.656]                             next
[11:02:43.656]                           if (!grepl(pattern, name)) 
[11:02:43.656]                             next
[11:02:43.656]                           invokeRestart(restart)
[11:02:43.656]                           muffled <- TRUE
[11:02:43.656]                           break
[11:02:43.656]                         }
[11:02:43.656]                       }
[11:02:43.656]                     }
[11:02:43.656]                     invisible(muffled)
[11:02:43.656]                   }
[11:02:43.656]                   muffleCondition(cond)
[11:02:43.656]                 })
[11:02:43.656]             }))
[11:02:43.656]             future::FutureResult(value = ...future.value$value, 
[11:02:43.656]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:43.656]                   ...future.rng), globalenv = if (FALSE) 
[11:02:43.656]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:43.656]                     ...future.globalenv.names))
[11:02:43.656]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:43.656]         }, condition = base::local({
[11:02:43.656]             c <- base::c
[11:02:43.656]             inherits <- base::inherits
[11:02:43.656]             invokeRestart <- base::invokeRestart
[11:02:43.656]             length <- base::length
[11:02:43.656]             list <- base::list
[11:02:43.656]             seq.int <- base::seq.int
[11:02:43.656]             signalCondition <- base::signalCondition
[11:02:43.656]             sys.calls <- base::sys.calls
[11:02:43.656]             `[[` <- base::`[[`
[11:02:43.656]             `+` <- base::`+`
[11:02:43.656]             `<<-` <- base::`<<-`
[11:02:43.656]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:43.656]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:43.656]                   3L)]
[11:02:43.656]             }
[11:02:43.656]             function(cond) {
[11:02:43.656]                 is_error <- inherits(cond, "error")
[11:02:43.656]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:43.656]                   NULL)
[11:02:43.656]                 if (is_error) {
[11:02:43.656]                   sessionInformation <- function() {
[11:02:43.656]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:43.656]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:43.656]                       search = base::search(), system = base::Sys.info())
[11:02:43.656]                   }
[11:02:43.656]                   ...future.conditions[[length(...future.conditions) + 
[11:02:43.656]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:43.656]                     cond$call), session = sessionInformation(), 
[11:02:43.656]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:43.656]                   signalCondition(cond)
[11:02:43.656]                 }
[11:02:43.656]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:43.656]                 "immediateCondition"))) {
[11:02:43.656]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:43.656]                   ...future.conditions[[length(...future.conditions) + 
[11:02:43.656]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:43.656]                   if (TRUE && !signal) {
[11:02:43.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:43.656]                     {
[11:02:43.656]                       inherits <- base::inherits
[11:02:43.656]                       invokeRestart <- base::invokeRestart
[11:02:43.656]                       is.null <- base::is.null
[11:02:43.656]                       muffled <- FALSE
[11:02:43.656]                       if (inherits(cond, "message")) {
[11:02:43.656]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:43.656]                         if (muffled) 
[11:02:43.656]                           invokeRestart("muffleMessage")
[11:02:43.656]                       }
[11:02:43.656]                       else if (inherits(cond, "warning")) {
[11:02:43.656]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:43.656]                         if (muffled) 
[11:02:43.656]                           invokeRestart("muffleWarning")
[11:02:43.656]                       }
[11:02:43.656]                       else if (inherits(cond, "condition")) {
[11:02:43.656]                         if (!is.null(pattern)) {
[11:02:43.656]                           computeRestarts <- base::computeRestarts
[11:02:43.656]                           grepl <- base::grepl
[11:02:43.656]                           restarts <- computeRestarts(cond)
[11:02:43.656]                           for (restart in restarts) {
[11:02:43.656]                             name <- restart$name
[11:02:43.656]                             if (is.null(name)) 
[11:02:43.656]                               next
[11:02:43.656]                             if (!grepl(pattern, name)) 
[11:02:43.656]                               next
[11:02:43.656]                             invokeRestart(restart)
[11:02:43.656]                             muffled <- TRUE
[11:02:43.656]                             break
[11:02:43.656]                           }
[11:02:43.656]                         }
[11:02:43.656]                       }
[11:02:43.656]                       invisible(muffled)
[11:02:43.656]                     }
[11:02:43.656]                     muffleCondition(cond, pattern = "^muffle")
[11:02:43.656]                   }
[11:02:43.656]                 }
[11:02:43.656]                 else {
[11:02:43.656]                   if (TRUE) {
[11:02:43.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:43.656]                     {
[11:02:43.656]                       inherits <- base::inherits
[11:02:43.656]                       invokeRestart <- base::invokeRestart
[11:02:43.656]                       is.null <- base::is.null
[11:02:43.656]                       muffled <- FALSE
[11:02:43.656]                       if (inherits(cond, "message")) {
[11:02:43.656]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:43.656]                         if (muffled) 
[11:02:43.656]                           invokeRestart("muffleMessage")
[11:02:43.656]                       }
[11:02:43.656]                       else if (inherits(cond, "warning")) {
[11:02:43.656]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:43.656]                         if (muffled) 
[11:02:43.656]                           invokeRestart("muffleWarning")
[11:02:43.656]                       }
[11:02:43.656]                       else if (inherits(cond, "condition")) {
[11:02:43.656]                         if (!is.null(pattern)) {
[11:02:43.656]                           computeRestarts <- base::computeRestarts
[11:02:43.656]                           grepl <- base::grepl
[11:02:43.656]                           restarts <- computeRestarts(cond)
[11:02:43.656]                           for (restart in restarts) {
[11:02:43.656]                             name <- restart$name
[11:02:43.656]                             if (is.null(name)) 
[11:02:43.656]                               next
[11:02:43.656]                             if (!grepl(pattern, name)) 
[11:02:43.656]                               next
[11:02:43.656]                             invokeRestart(restart)
[11:02:43.656]                             muffled <- TRUE
[11:02:43.656]                             break
[11:02:43.656]                           }
[11:02:43.656]                         }
[11:02:43.656]                       }
[11:02:43.656]                       invisible(muffled)
[11:02:43.656]                     }
[11:02:43.656]                     muffleCondition(cond, pattern = "^muffle")
[11:02:43.656]                   }
[11:02:43.656]                 }
[11:02:43.656]             }
[11:02:43.656]         }))
[11:02:43.656]     }, error = function(ex) {
[11:02:43.656]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:43.656]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:43.656]                 ...future.rng), started = ...future.startTime, 
[11:02:43.656]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:43.656]             version = "1.8"), class = "FutureResult")
[11:02:43.656]     }, finally = {
[11:02:43.656]         if (!identical(...future.workdir, getwd())) 
[11:02:43.656]             setwd(...future.workdir)
[11:02:43.656]         {
[11:02:43.656]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:43.656]                 ...future.oldOptions$nwarnings <- NULL
[11:02:43.656]             }
[11:02:43.656]             base::options(...future.oldOptions)
[11:02:43.656]             if (.Platform$OS.type == "windows") {
[11:02:43.656]                 old_names <- names(...future.oldEnvVars)
[11:02:43.656]                 envs <- base::Sys.getenv()
[11:02:43.656]                 names <- names(envs)
[11:02:43.656]                 common <- intersect(names, old_names)
[11:02:43.656]                 added <- setdiff(names, old_names)
[11:02:43.656]                 removed <- setdiff(old_names, names)
[11:02:43.656]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:43.656]                   envs[common]]
[11:02:43.656]                 NAMES <- toupper(changed)
[11:02:43.656]                 args <- list()
[11:02:43.656]                 for (kk in seq_along(NAMES)) {
[11:02:43.656]                   name <- changed[[kk]]
[11:02:43.656]                   NAME <- NAMES[[kk]]
[11:02:43.656]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:43.656]                     next
[11:02:43.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:43.656]                 }
[11:02:43.656]                 NAMES <- toupper(added)
[11:02:43.656]                 for (kk in seq_along(NAMES)) {
[11:02:43.656]                   name <- added[[kk]]
[11:02:43.656]                   NAME <- NAMES[[kk]]
[11:02:43.656]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:43.656]                     next
[11:02:43.656]                   args[[name]] <- ""
[11:02:43.656]                 }
[11:02:43.656]                 NAMES <- toupper(removed)
[11:02:43.656]                 for (kk in seq_along(NAMES)) {
[11:02:43.656]                   name <- removed[[kk]]
[11:02:43.656]                   NAME <- NAMES[[kk]]
[11:02:43.656]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:43.656]                     next
[11:02:43.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:43.656]                 }
[11:02:43.656]                 if (length(args) > 0) 
[11:02:43.656]                   base::do.call(base::Sys.setenv, args = args)
[11:02:43.656]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:43.656]             }
[11:02:43.656]             else {
[11:02:43.656]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:43.656]             }
[11:02:43.656]             {
[11:02:43.656]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:43.656]                   0L) {
[11:02:43.656]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:43.656]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:43.656]                   base::options(opts)
[11:02:43.656]                 }
[11:02:43.656]                 {
[11:02:43.656]                   {
[11:02:43.656]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:43.656]                     NULL
[11:02:43.656]                   }
[11:02:43.656]                   options(future.plan = NULL)
[11:02:43.656]                   if (is.na(NA_character_)) 
[11:02:43.656]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:43.656]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:43.656]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:43.656]                     .init = FALSE)
[11:02:43.656]                 }
[11:02:43.656]             }
[11:02:43.656]         }
[11:02:43.656]     })
[11:02:43.656]     if (TRUE) {
[11:02:43.656]         base::sink(type = "output", split = FALSE)
[11:02:43.656]         if (TRUE) {
[11:02:43.656]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:43.656]         }
[11:02:43.656]         else {
[11:02:43.656]             ...future.result["stdout"] <- base::list(NULL)
[11:02:43.656]         }
[11:02:43.656]         base::close(...future.stdout)
[11:02:43.656]         ...future.stdout <- NULL
[11:02:43.656]     }
[11:02:43.656]     ...future.result$conditions <- ...future.conditions
[11:02:43.656]     ...future.result$finished <- base::Sys.time()
[11:02:43.656]     ...future.result
[11:02:43.656] }
[11:02:43.708] MultisessionFuture started
[11:02:43.708] - Launch lazy future ... done
[11:02:43.708] run() for ‘MultisessionFuture’ ... done
[11:02:43.708] getGlobalsAndPackages() ...
[11:02:43.709] Searching for globals...
[11:02:43.712] - globals found: [2] ‘list’, ‘stop’
[11:02:43.712] Searching for globals ... DONE
[11:02:43.713] Resolving globals: FALSE
[11:02:43.713] 
[11:02:43.713] 
[11:02:43.713] getGlobalsAndPackages() ... DONE
- result = FALSE, recursive = -1 ... DONE
- result = FALSE, recursive = 0 ...
[11:02:43.714] getGlobalsAndPackages() ...
[11:02:43.714] Searching for globals...
[11:02:43.716] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[11:02:43.716] Searching for globals ... DONE
[11:02:43.716] Resolving globals: FALSE
[11:02:43.716] 
[11:02:43.717] 
[11:02:43.717] getGlobalsAndPackages() ... DONE
[11:02:43.717] run() for ‘Future’ ...
[11:02:43.717] - state: ‘created’
[11:02:43.717] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:43.732] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:43.733] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:43.733]   - Field: ‘node’
[11:02:43.733]   - Field: ‘label’
[11:02:43.733]   - Field: ‘local’
[11:02:43.733]   - Field: ‘owner’
[11:02:43.733]   - Field: ‘envir’
[11:02:43.733]   - Field: ‘workers’
[11:02:43.733]   - Field: ‘packages’
[11:02:43.733]   - Field: ‘gc’
[11:02:43.733]   - Field: ‘conditions’
[11:02:43.733]   - Field: ‘persistent’
[11:02:43.734]   - Field: ‘expr’
[11:02:43.734]   - Field: ‘uuid’
[11:02:43.734]   - Field: ‘seed’
[11:02:43.734]   - Field: ‘version’
[11:02:43.734]   - Field: ‘result’
[11:02:43.734]   - Field: ‘asynchronous’
[11:02:43.734]   - Field: ‘calls’
[11:02:43.734]   - Field: ‘globals’
[11:02:43.734]   - Field: ‘stdout’
[11:02:43.734]   - Field: ‘earlySignal’
[11:02:43.734]   - Field: ‘lazy’
[11:02:43.734]   - Field: ‘state’
[11:02:43.735] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:43.735] - Launch lazy future ...
[11:02:43.735] Packages needed by the future expression (n = 0): <none>
[11:02:43.735] Packages needed by future strategies (n = 0): <none>
[11:02:43.735] {
[11:02:43.735]     {
[11:02:43.735]         {
[11:02:43.735]             ...future.startTime <- base::Sys.time()
[11:02:43.735]             {
[11:02:43.735]                 {
[11:02:43.735]                   {
[11:02:43.735]                     {
[11:02:43.735]                       base::local({
[11:02:43.735]                         has_future <- base::requireNamespace("future", 
[11:02:43.735]                           quietly = TRUE)
[11:02:43.735]                         if (has_future) {
[11:02:43.735]                           ns <- base::getNamespace("future")
[11:02:43.735]                           version <- ns[[".package"]][["version"]]
[11:02:43.735]                           if (is.null(version)) 
[11:02:43.735]                             version <- utils::packageVersion("future")
[11:02:43.735]                         }
[11:02:43.735]                         else {
[11:02:43.735]                           version <- NULL
[11:02:43.735]                         }
[11:02:43.735]                         if (!has_future || version < "1.8.0") {
[11:02:43.735]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:43.735]                             "", base::R.version$version.string), 
[11:02:43.735]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:43.735]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:43.735]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:43.735]                               "release", "version")], collapse = " "), 
[11:02:43.735]                             hostname = base::Sys.info()[["nodename"]])
[11:02:43.735]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:43.735]                             info)
[11:02:43.735]                           info <- base::paste(info, collapse = "; ")
[11:02:43.735]                           if (!has_future) {
[11:02:43.735]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:43.735]                               info)
[11:02:43.735]                           }
[11:02:43.735]                           else {
[11:02:43.735]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:43.735]                               info, version)
[11:02:43.735]                           }
[11:02:43.735]                           base::stop(msg)
[11:02:43.735]                         }
[11:02:43.735]                       })
[11:02:43.735]                     }
[11:02:43.735]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:43.735]                     base::options(mc.cores = 1L)
[11:02:43.735]                   }
[11:02:43.735]                   ...future.strategy.old <- future::plan("list")
[11:02:43.735]                   options(future.plan = NULL)
[11:02:43.735]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:43.735]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:43.735]                 }
[11:02:43.735]                 ...future.workdir <- getwd()
[11:02:43.735]             }
[11:02:43.735]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:43.735]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:43.735]         }
[11:02:43.735]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:43.735]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:43.735]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:43.735]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:43.735]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:43.735]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:43.735]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:43.735]             base::names(...future.oldOptions))
[11:02:43.735]     }
[11:02:43.735]     if (FALSE) {
[11:02:43.735]     }
[11:02:43.735]     else {
[11:02:43.735]         if (TRUE) {
[11:02:43.735]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:43.735]                 open = "w")
[11:02:43.735]         }
[11:02:43.735]         else {
[11:02:43.735]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:43.735]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:43.735]         }
[11:02:43.735]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:43.735]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:43.735]             base::sink(type = "output", split = FALSE)
[11:02:43.735]             base::close(...future.stdout)
[11:02:43.735]         }, add = TRUE)
[11:02:43.735]     }
[11:02:43.735]     ...future.frame <- base::sys.nframe()
[11:02:43.735]     ...future.conditions <- base::list()
[11:02:43.735]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:43.735]     if (FALSE) {
[11:02:43.735]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:43.735]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:43.735]     }
[11:02:43.735]     ...future.result <- base::tryCatch({
[11:02:43.735]         base::withCallingHandlers({
[11:02:43.735]             ...future.value <- base::withVisible(base::local({
[11:02:43.735]                 ...future.makeSendCondition <- base::local({
[11:02:43.735]                   sendCondition <- NULL
[11:02:43.735]                   function(frame = 1L) {
[11:02:43.735]                     if (is.function(sendCondition)) 
[11:02:43.735]                       return(sendCondition)
[11:02:43.735]                     ns <- getNamespace("parallel")
[11:02:43.735]                     if (exists("sendData", mode = "function", 
[11:02:43.735]                       envir = ns)) {
[11:02:43.735]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:43.735]                         envir = ns)
[11:02:43.735]                       envir <- sys.frame(frame)
[11:02:43.735]                       master <- NULL
[11:02:43.735]                       while (!identical(envir, .GlobalEnv) && 
[11:02:43.735]                         !identical(envir, emptyenv())) {
[11:02:43.735]                         if (exists("master", mode = "list", envir = envir, 
[11:02:43.735]                           inherits = FALSE)) {
[11:02:43.735]                           master <- get("master", mode = "list", 
[11:02:43.735]                             envir = envir, inherits = FALSE)
[11:02:43.735]                           if (inherits(master, c("SOCKnode", 
[11:02:43.735]                             "SOCK0node"))) {
[11:02:43.735]                             sendCondition <<- function(cond) {
[11:02:43.735]                               data <- list(type = "VALUE", value = cond, 
[11:02:43.735]                                 success = TRUE)
[11:02:43.735]                               parallel_sendData(master, data)
[11:02:43.735]                             }
[11:02:43.735]                             return(sendCondition)
[11:02:43.735]                           }
[11:02:43.735]                         }
[11:02:43.735]                         frame <- frame + 1L
[11:02:43.735]                         envir <- sys.frame(frame)
[11:02:43.735]                       }
[11:02:43.735]                     }
[11:02:43.735]                     sendCondition <<- function(cond) NULL
[11:02:43.735]                   }
[11:02:43.735]                 })
[11:02:43.735]                 withCallingHandlers({
[11:02:43.735]                   {
[11:02:43.735]                     Sys.sleep(0.5)
[11:02:43.735]                     list(a = 1, b = 42L)
[11:02:43.735]                   }
[11:02:43.735]                 }, immediateCondition = function(cond) {
[11:02:43.735]                   sendCondition <- ...future.makeSendCondition()
[11:02:43.735]                   sendCondition(cond)
[11:02:43.735]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:43.735]                   {
[11:02:43.735]                     inherits <- base::inherits
[11:02:43.735]                     invokeRestart <- base::invokeRestart
[11:02:43.735]                     is.null <- base::is.null
[11:02:43.735]                     muffled <- FALSE
[11:02:43.735]                     if (inherits(cond, "message")) {
[11:02:43.735]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:43.735]                       if (muffled) 
[11:02:43.735]                         invokeRestart("muffleMessage")
[11:02:43.735]                     }
[11:02:43.735]                     else if (inherits(cond, "warning")) {
[11:02:43.735]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:43.735]                       if (muffled) 
[11:02:43.735]                         invokeRestart("muffleWarning")
[11:02:43.735]                     }
[11:02:43.735]                     else if (inherits(cond, "condition")) {
[11:02:43.735]                       if (!is.null(pattern)) {
[11:02:43.735]                         computeRestarts <- base::computeRestarts
[11:02:43.735]                         grepl <- base::grepl
[11:02:43.735]                         restarts <- computeRestarts(cond)
[11:02:43.735]                         for (restart in restarts) {
[11:02:43.735]                           name <- restart$name
[11:02:43.735]                           if (is.null(name)) 
[11:02:43.735]                             next
[11:02:43.735]                           if (!grepl(pattern, name)) 
[11:02:43.735]                             next
[11:02:43.735]                           invokeRestart(restart)
[11:02:43.735]                           muffled <- TRUE
[11:02:43.735]                           break
[11:02:43.735]                         }
[11:02:43.735]                       }
[11:02:43.735]                     }
[11:02:43.735]                     invisible(muffled)
[11:02:43.735]                   }
[11:02:43.735]                   muffleCondition(cond)
[11:02:43.735]                 })
[11:02:43.735]             }))
[11:02:43.735]             future::FutureResult(value = ...future.value$value, 
[11:02:43.735]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:43.735]                   ...future.rng), globalenv = if (FALSE) 
[11:02:43.735]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:43.735]                     ...future.globalenv.names))
[11:02:43.735]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:43.735]         }, condition = base::local({
[11:02:43.735]             c <- base::c
[11:02:43.735]             inherits <- base::inherits
[11:02:43.735]             invokeRestart <- base::invokeRestart
[11:02:43.735]             length <- base::length
[11:02:43.735]             list <- base::list
[11:02:43.735]             seq.int <- base::seq.int
[11:02:43.735]             signalCondition <- base::signalCondition
[11:02:43.735]             sys.calls <- base::sys.calls
[11:02:43.735]             `[[` <- base::`[[`
[11:02:43.735]             `+` <- base::`+`
[11:02:43.735]             `<<-` <- base::`<<-`
[11:02:43.735]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:43.735]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:43.735]                   3L)]
[11:02:43.735]             }
[11:02:43.735]             function(cond) {
[11:02:43.735]                 is_error <- inherits(cond, "error")
[11:02:43.735]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:43.735]                   NULL)
[11:02:43.735]                 if (is_error) {
[11:02:43.735]                   sessionInformation <- function() {
[11:02:43.735]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:43.735]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:43.735]                       search = base::search(), system = base::Sys.info())
[11:02:43.735]                   }
[11:02:43.735]                   ...future.conditions[[length(...future.conditions) + 
[11:02:43.735]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:43.735]                     cond$call), session = sessionInformation(), 
[11:02:43.735]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:43.735]                   signalCondition(cond)
[11:02:43.735]                 }
[11:02:43.735]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:43.735]                 "immediateCondition"))) {
[11:02:43.735]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:43.735]                   ...future.conditions[[length(...future.conditions) + 
[11:02:43.735]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:43.735]                   if (TRUE && !signal) {
[11:02:43.735]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:43.735]                     {
[11:02:43.735]                       inherits <- base::inherits
[11:02:43.735]                       invokeRestart <- base::invokeRestart
[11:02:43.735]                       is.null <- base::is.null
[11:02:43.735]                       muffled <- FALSE
[11:02:43.735]                       if (inherits(cond, "message")) {
[11:02:43.735]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:43.735]                         if (muffled) 
[11:02:43.735]                           invokeRestart("muffleMessage")
[11:02:43.735]                       }
[11:02:43.735]                       else if (inherits(cond, "warning")) {
[11:02:43.735]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:43.735]                         if (muffled) 
[11:02:43.735]                           invokeRestart("muffleWarning")
[11:02:43.735]                       }
[11:02:43.735]                       else if (inherits(cond, "condition")) {
[11:02:43.735]                         if (!is.null(pattern)) {
[11:02:43.735]                           computeRestarts <- base::computeRestarts
[11:02:43.735]                           grepl <- base::grepl
[11:02:43.735]                           restarts <- computeRestarts(cond)
[11:02:43.735]                           for (restart in restarts) {
[11:02:43.735]                             name <- restart$name
[11:02:43.735]                             if (is.null(name)) 
[11:02:43.735]                               next
[11:02:43.735]                             if (!grepl(pattern, name)) 
[11:02:43.735]                               next
[11:02:43.735]                             invokeRestart(restart)
[11:02:43.735]                             muffled <- TRUE
[11:02:43.735]                             break
[11:02:43.735]                           }
[11:02:43.735]                         }
[11:02:43.735]                       }
[11:02:43.735]                       invisible(muffled)
[11:02:43.735]                     }
[11:02:43.735]                     muffleCondition(cond, pattern = "^muffle")
[11:02:43.735]                   }
[11:02:43.735]                 }
[11:02:43.735]                 else {
[11:02:43.735]                   if (TRUE) {
[11:02:43.735]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:43.735]                     {
[11:02:43.735]                       inherits <- base::inherits
[11:02:43.735]                       invokeRestart <- base::invokeRestart
[11:02:43.735]                       is.null <- base::is.null
[11:02:43.735]                       muffled <- FALSE
[11:02:43.735]                       if (inherits(cond, "message")) {
[11:02:43.735]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:43.735]                         if (muffled) 
[11:02:43.735]                           invokeRestart("muffleMessage")
[11:02:43.735]                       }
[11:02:43.735]                       else if (inherits(cond, "warning")) {
[11:02:43.735]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:43.735]                         if (muffled) 
[11:02:43.735]                           invokeRestart("muffleWarning")
[11:02:43.735]                       }
[11:02:43.735]                       else if (inherits(cond, "condition")) {
[11:02:43.735]                         if (!is.null(pattern)) {
[11:02:43.735]                           computeRestarts <- base::computeRestarts
[11:02:43.735]                           grepl <- base::grepl
[11:02:43.735]                           restarts <- computeRestarts(cond)
[11:02:43.735]                           for (restart in restarts) {
[11:02:43.735]                             name <- restart$name
[11:02:43.735]                             if (is.null(name)) 
[11:02:43.735]                               next
[11:02:43.735]                             if (!grepl(pattern, name)) 
[11:02:43.735]                               next
[11:02:43.735]                             invokeRestart(restart)
[11:02:43.735]                             muffled <- TRUE
[11:02:43.735]                             break
[11:02:43.735]                           }
[11:02:43.735]                         }
[11:02:43.735]                       }
[11:02:43.735]                       invisible(muffled)
[11:02:43.735]                     }
[11:02:43.735]                     muffleCondition(cond, pattern = "^muffle")
[11:02:43.735]                   }
[11:02:43.735]                 }
[11:02:43.735]             }
[11:02:43.735]         }))
[11:02:43.735]     }, error = function(ex) {
[11:02:43.735]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:43.735]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:43.735]                 ...future.rng), started = ...future.startTime, 
[11:02:43.735]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:43.735]             version = "1.8"), class = "FutureResult")
[11:02:43.735]     }, finally = {
[11:02:43.735]         if (!identical(...future.workdir, getwd())) 
[11:02:43.735]             setwd(...future.workdir)
[11:02:43.735]         {
[11:02:43.735]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:43.735]                 ...future.oldOptions$nwarnings <- NULL
[11:02:43.735]             }
[11:02:43.735]             base::options(...future.oldOptions)
[11:02:43.735]             if (.Platform$OS.type == "windows") {
[11:02:43.735]                 old_names <- names(...future.oldEnvVars)
[11:02:43.735]                 envs <- base::Sys.getenv()
[11:02:43.735]                 names <- names(envs)
[11:02:43.735]                 common <- intersect(names, old_names)
[11:02:43.735]                 added <- setdiff(names, old_names)
[11:02:43.735]                 removed <- setdiff(old_names, names)
[11:02:43.735]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:43.735]                   envs[common]]
[11:02:43.735]                 NAMES <- toupper(changed)
[11:02:43.735]                 args <- list()
[11:02:43.735]                 for (kk in seq_along(NAMES)) {
[11:02:43.735]                   name <- changed[[kk]]
[11:02:43.735]                   NAME <- NAMES[[kk]]
[11:02:43.735]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:43.735]                     next
[11:02:43.735]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:43.735]                 }
[11:02:43.735]                 NAMES <- toupper(added)
[11:02:43.735]                 for (kk in seq_along(NAMES)) {
[11:02:43.735]                   name <- added[[kk]]
[11:02:43.735]                   NAME <- NAMES[[kk]]
[11:02:43.735]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:43.735]                     next
[11:02:43.735]                   args[[name]] <- ""
[11:02:43.735]                 }
[11:02:43.735]                 NAMES <- toupper(removed)
[11:02:43.735]                 for (kk in seq_along(NAMES)) {
[11:02:43.735]                   name <- removed[[kk]]
[11:02:43.735]                   NAME <- NAMES[[kk]]
[11:02:43.735]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:43.735]                     next
[11:02:43.735]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:43.735]                 }
[11:02:43.735]                 if (length(args) > 0) 
[11:02:43.735]                   base::do.call(base::Sys.setenv, args = args)
[11:02:43.735]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:43.735]             }
[11:02:43.735]             else {
[11:02:43.735]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:43.735]             }
[11:02:43.735]             {
[11:02:43.735]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:43.735]                   0L) {
[11:02:43.735]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:43.735]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:43.735]                   base::options(opts)
[11:02:43.735]                 }
[11:02:43.735]                 {
[11:02:43.735]                   {
[11:02:43.735]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:43.735]                     NULL
[11:02:43.735]                   }
[11:02:43.735]                   options(future.plan = NULL)
[11:02:43.735]                   if (is.na(NA_character_)) 
[11:02:43.735]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:43.735]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:43.735]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:43.735]                     .init = FALSE)
[11:02:43.735]                 }
[11:02:43.735]             }
[11:02:43.735]         }
[11:02:43.735]     })
[11:02:43.735]     if (TRUE) {
[11:02:43.735]         base::sink(type = "output", split = FALSE)
[11:02:43.735]         if (TRUE) {
[11:02:43.735]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:43.735]         }
[11:02:43.735]         else {
[11:02:43.735]             ...future.result["stdout"] <- base::list(NULL)
[11:02:43.735]         }
[11:02:43.735]         base::close(...future.stdout)
[11:02:43.735]         ...future.stdout <- NULL
[11:02:43.735]     }
[11:02:43.735]     ...future.result$conditions <- ...future.conditions
[11:02:43.735]     ...future.result$finished <- base::Sys.time()
[11:02:43.735]     ...future.result
[11:02:43.735] }
[11:02:43.737] Poll #1 (0): usedNodes() = 2, workers = 2
[11:02:43.759] receiveMessageFromWorker() for ClusterFuture ...
[11:02:43.759] - Validating connection of MultisessionFuture
[11:02:43.759] - received message: FutureResult
[11:02:43.759] - Received FutureResult
[11:02:43.759] - Erased future from FutureRegistry
[11:02:43.760] result() for ClusterFuture ...
[11:02:43.760] - result already collected: FutureResult
[11:02:43.760] result() for ClusterFuture ... done
[11:02:43.760] signalConditions() ...
[11:02:43.760]  - include = ‘immediateCondition’
[11:02:43.760]  - exclude = 
[11:02:43.760]  - resignal = FALSE
[11:02:43.760]  - Number of conditions: 1
[11:02:43.760] signalConditions() ... done
[11:02:43.760] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:43.760] result() for ClusterFuture ...
[11:02:43.760] - result already collected: FutureResult
[11:02:43.760] result() for ClusterFuture ... done
[11:02:43.761] result() for ClusterFuture ...
[11:02:43.761] - result already collected: FutureResult
[11:02:43.761] result() for ClusterFuture ... done
[11:02:43.761] signalConditions() ...
[11:02:43.761]  - include = ‘immediateCondition’
[11:02:43.761]  - exclude = 
[11:02:43.761]  - resignal = FALSE
[11:02:43.761]  - Number of conditions: 1
[11:02:43.761] signalConditions() ... done
[11:02:43.762] MultisessionFuture started
[11:02:43.762] - Launch lazy future ... done
[11:02:43.762] run() for ‘MultisessionFuture’ ... done
[11:02:44.308] receiveMessageFromWorker() for ClusterFuture ...
[11:02:44.309] - Validating connection of MultisessionFuture
[11:02:44.309] - received message: FutureResult
[11:02:44.309] - Received FutureResult
[11:02:44.309] - Erased future from FutureRegistry
[11:02:44.309] result() for ClusterFuture ...
[11:02:44.309] - result already collected: FutureResult
[11:02:44.310] result() for ClusterFuture ... done
[11:02:44.310] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:44.310] A MultisessionFuture was resolved (result was not collected)
[11:02:44.310] getGlobalsAndPackages() ...
[11:02:44.310] Searching for globals...
[11:02:44.311] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[11:02:44.311] Searching for globals ... DONE
[11:02:44.311] Resolving globals: FALSE
[11:02:44.312] 
[11:02:44.312] 
[11:02:44.312] getGlobalsAndPackages() ... DONE
[11:02:44.312] run() for ‘Future’ ...
[11:02:44.312] - state: ‘created’
[11:02:44.312] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:44.326] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:44.326] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:44.326]   - Field: ‘node’
[11:02:44.326]   - Field: ‘label’
[11:02:44.326]   - Field: ‘local’
[11:02:44.327]   - Field: ‘owner’
[11:02:44.327]   - Field: ‘envir’
[11:02:44.327]   - Field: ‘workers’
[11:02:44.327]   - Field: ‘packages’
[11:02:44.327]   - Field: ‘gc’
[11:02:44.327]   - Field: ‘conditions’
[11:02:44.327]   - Field: ‘persistent’
[11:02:44.327]   - Field: ‘expr’
[11:02:44.327]   - Field: ‘uuid’
[11:02:44.327]   - Field: ‘seed’
[11:02:44.327]   - Field: ‘version’
[11:02:44.327]   - Field: ‘result’
[11:02:44.328]   - Field: ‘asynchronous’
[11:02:44.328]   - Field: ‘calls’
[11:02:44.328]   - Field: ‘globals’
[11:02:44.328]   - Field: ‘stdout’
[11:02:44.328]   - Field: ‘earlySignal’
[11:02:44.328]   - Field: ‘lazy’
[11:02:44.328]   - Field: ‘state’
[11:02:44.328] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:44.328] - Launch lazy future ...
[11:02:44.328] Packages needed by the future expression (n = 0): <none>
[11:02:44.329] Packages needed by future strategies (n = 0): <none>
[11:02:44.329] {
[11:02:44.329]     {
[11:02:44.329]         {
[11:02:44.329]             ...future.startTime <- base::Sys.time()
[11:02:44.329]             {
[11:02:44.329]                 {
[11:02:44.329]                   {
[11:02:44.329]                     {
[11:02:44.329]                       base::local({
[11:02:44.329]                         has_future <- base::requireNamespace("future", 
[11:02:44.329]                           quietly = TRUE)
[11:02:44.329]                         if (has_future) {
[11:02:44.329]                           ns <- base::getNamespace("future")
[11:02:44.329]                           version <- ns[[".package"]][["version"]]
[11:02:44.329]                           if (is.null(version)) 
[11:02:44.329]                             version <- utils::packageVersion("future")
[11:02:44.329]                         }
[11:02:44.329]                         else {
[11:02:44.329]                           version <- NULL
[11:02:44.329]                         }
[11:02:44.329]                         if (!has_future || version < "1.8.0") {
[11:02:44.329]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:44.329]                             "", base::R.version$version.string), 
[11:02:44.329]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:44.329]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:44.329]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:44.329]                               "release", "version")], collapse = " "), 
[11:02:44.329]                             hostname = base::Sys.info()[["nodename"]])
[11:02:44.329]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:44.329]                             info)
[11:02:44.329]                           info <- base::paste(info, collapse = "; ")
[11:02:44.329]                           if (!has_future) {
[11:02:44.329]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:44.329]                               info)
[11:02:44.329]                           }
[11:02:44.329]                           else {
[11:02:44.329]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:44.329]                               info, version)
[11:02:44.329]                           }
[11:02:44.329]                           base::stop(msg)
[11:02:44.329]                         }
[11:02:44.329]                       })
[11:02:44.329]                     }
[11:02:44.329]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:44.329]                     base::options(mc.cores = 1L)
[11:02:44.329]                   }
[11:02:44.329]                   ...future.strategy.old <- future::plan("list")
[11:02:44.329]                   options(future.plan = NULL)
[11:02:44.329]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:44.329]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:44.329]                 }
[11:02:44.329]                 ...future.workdir <- getwd()
[11:02:44.329]             }
[11:02:44.329]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:44.329]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:44.329]         }
[11:02:44.329]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:44.329]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:44.329]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:44.329]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:44.329]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:44.329]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:44.329]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:44.329]             base::names(...future.oldOptions))
[11:02:44.329]     }
[11:02:44.329]     if (FALSE) {
[11:02:44.329]     }
[11:02:44.329]     else {
[11:02:44.329]         if (TRUE) {
[11:02:44.329]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:44.329]                 open = "w")
[11:02:44.329]         }
[11:02:44.329]         else {
[11:02:44.329]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:44.329]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:44.329]         }
[11:02:44.329]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:44.329]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:44.329]             base::sink(type = "output", split = FALSE)
[11:02:44.329]             base::close(...future.stdout)
[11:02:44.329]         }, add = TRUE)
[11:02:44.329]     }
[11:02:44.329]     ...future.frame <- base::sys.nframe()
[11:02:44.329]     ...future.conditions <- base::list()
[11:02:44.329]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:44.329]     if (FALSE) {
[11:02:44.329]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:44.329]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:44.329]     }
[11:02:44.329]     ...future.result <- base::tryCatch({
[11:02:44.329]         base::withCallingHandlers({
[11:02:44.329]             ...future.value <- base::withVisible(base::local({
[11:02:44.329]                 ...future.makeSendCondition <- base::local({
[11:02:44.329]                   sendCondition <- NULL
[11:02:44.329]                   function(frame = 1L) {
[11:02:44.329]                     if (is.function(sendCondition)) 
[11:02:44.329]                       return(sendCondition)
[11:02:44.329]                     ns <- getNamespace("parallel")
[11:02:44.329]                     if (exists("sendData", mode = "function", 
[11:02:44.329]                       envir = ns)) {
[11:02:44.329]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:44.329]                         envir = ns)
[11:02:44.329]                       envir <- sys.frame(frame)
[11:02:44.329]                       master <- NULL
[11:02:44.329]                       while (!identical(envir, .GlobalEnv) && 
[11:02:44.329]                         !identical(envir, emptyenv())) {
[11:02:44.329]                         if (exists("master", mode = "list", envir = envir, 
[11:02:44.329]                           inherits = FALSE)) {
[11:02:44.329]                           master <- get("master", mode = "list", 
[11:02:44.329]                             envir = envir, inherits = FALSE)
[11:02:44.329]                           if (inherits(master, c("SOCKnode", 
[11:02:44.329]                             "SOCK0node"))) {
[11:02:44.329]                             sendCondition <<- function(cond) {
[11:02:44.329]                               data <- list(type = "VALUE", value = cond, 
[11:02:44.329]                                 success = TRUE)
[11:02:44.329]                               parallel_sendData(master, data)
[11:02:44.329]                             }
[11:02:44.329]                             return(sendCondition)
[11:02:44.329]                           }
[11:02:44.329]                         }
[11:02:44.329]                         frame <- frame + 1L
[11:02:44.329]                         envir <- sys.frame(frame)
[11:02:44.329]                       }
[11:02:44.329]                     }
[11:02:44.329]                     sendCondition <<- function(cond) NULL
[11:02:44.329]                   }
[11:02:44.329]                 })
[11:02:44.329]                 withCallingHandlers({
[11:02:44.329]                   {
[11:02:44.329]                     Sys.sleep(0.5)
[11:02:44.329]                     list(a = 1, b = 42L)
[11:02:44.329]                   }
[11:02:44.329]                 }, immediateCondition = function(cond) {
[11:02:44.329]                   sendCondition <- ...future.makeSendCondition()
[11:02:44.329]                   sendCondition(cond)
[11:02:44.329]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:44.329]                   {
[11:02:44.329]                     inherits <- base::inherits
[11:02:44.329]                     invokeRestart <- base::invokeRestart
[11:02:44.329]                     is.null <- base::is.null
[11:02:44.329]                     muffled <- FALSE
[11:02:44.329]                     if (inherits(cond, "message")) {
[11:02:44.329]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:44.329]                       if (muffled) 
[11:02:44.329]                         invokeRestart("muffleMessage")
[11:02:44.329]                     }
[11:02:44.329]                     else if (inherits(cond, "warning")) {
[11:02:44.329]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:44.329]                       if (muffled) 
[11:02:44.329]                         invokeRestart("muffleWarning")
[11:02:44.329]                     }
[11:02:44.329]                     else if (inherits(cond, "condition")) {
[11:02:44.329]                       if (!is.null(pattern)) {
[11:02:44.329]                         computeRestarts <- base::computeRestarts
[11:02:44.329]                         grepl <- base::grepl
[11:02:44.329]                         restarts <- computeRestarts(cond)
[11:02:44.329]                         for (restart in restarts) {
[11:02:44.329]                           name <- restart$name
[11:02:44.329]                           if (is.null(name)) 
[11:02:44.329]                             next
[11:02:44.329]                           if (!grepl(pattern, name)) 
[11:02:44.329]                             next
[11:02:44.329]                           invokeRestart(restart)
[11:02:44.329]                           muffled <- TRUE
[11:02:44.329]                           break
[11:02:44.329]                         }
[11:02:44.329]                       }
[11:02:44.329]                     }
[11:02:44.329]                     invisible(muffled)
[11:02:44.329]                   }
[11:02:44.329]                   muffleCondition(cond)
[11:02:44.329]                 })
[11:02:44.329]             }))
[11:02:44.329]             future::FutureResult(value = ...future.value$value, 
[11:02:44.329]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:44.329]                   ...future.rng), globalenv = if (FALSE) 
[11:02:44.329]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:44.329]                     ...future.globalenv.names))
[11:02:44.329]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:44.329]         }, condition = base::local({
[11:02:44.329]             c <- base::c
[11:02:44.329]             inherits <- base::inherits
[11:02:44.329]             invokeRestart <- base::invokeRestart
[11:02:44.329]             length <- base::length
[11:02:44.329]             list <- base::list
[11:02:44.329]             seq.int <- base::seq.int
[11:02:44.329]             signalCondition <- base::signalCondition
[11:02:44.329]             sys.calls <- base::sys.calls
[11:02:44.329]             `[[` <- base::`[[`
[11:02:44.329]             `+` <- base::`+`
[11:02:44.329]             `<<-` <- base::`<<-`
[11:02:44.329]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:44.329]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:44.329]                   3L)]
[11:02:44.329]             }
[11:02:44.329]             function(cond) {
[11:02:44.329]                 is_error <- inherits(cond, "error")
[11:02:44.329]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:44.329]                   NULL)
[11:02:44.329]                 if (is_error) {
[11:02:44.329]                   sessionInformation <- function() {
[11:02:44.329]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:44.329]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:44.329]                       search = base::search(), system = base::Sys.info())
[11:02:44.329]                   }
[11:02:44.329]                   ...future.conditions[[length(...future.conditions) + 
[11:02:44.329]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:44.329]                     cond$call), session = sessionInformation(), 
[11:02:44.329]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:44.329]                   signalCondition(cond)
[11:02:44.329]                 }
[11:02:44.329]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:44.329]                 "immediateCondition"))) {
[11:02:44.329]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:44.329]                   ...future.conditions[[length(...future.conditions) + 
[11:02:44.329]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:44.329]                   if (TRUE && !signal) {
[11:02:44.329]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:44.329]                     {
[11:02:44.329]                       inherits <- base::inherits
[11:02:44.329]                       invokeRestart <- base::invokeRestart
[11:02:44.329]                       is.null <- base::is.null
[11:02:44.329]                       muffled <- FALSE
[11:02:44.329]                       if (inherits(cond, "message")) {
[11:02:44.329]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:44.329]                         if (muffled) 
[11:02:44.329]                           invokeRestart("muffleMessage")
[11:02:44.329]                       }
[11:02:44.329]                       else if (inherits(cond, "warning")) {
[11:02:44.329]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:44.329]                         if (muffled) 
[11:02:44.329]                           invokeRestart("muffleWarning")
[11:02:44.329]                       }
[11:02:44.329]                       else if (inherits(cond, "condition")) {
[11:02:44.329]                         if (!is.null(pattern)) {
[11:02:44.329]                           computeRestarts <- base::computeRestarts
[11:02:44.329]                           grepl <- base::grepl
[11:02:44.329]                           restarts <- computeRestarts(cond)
[11:02:44.329]                           for (restart in restarts) {
[11:02:44.329]                             name <- restart$name
[11:02:44.329]                             if (is.null(name)) 
[11:02:44.329]                               next
[11:02:44.329]                             if (!grepl(pattern, name)) 
[11:02:44.329]                               next
[11:02:44.329]                             invokeRestart(restart)
[11:02:44.329]                             muffled <- TRUE
[11:02:44.329]                             break
[11:02:44.329]                           }
[11:02:44.329]                         }
[11:02:44.329]                       }
[11:02:44.329]                       invisible(muffled)
[11:02:44.329]                     }
[11:02:44.329]                     muffleCondition(cond, pattern = "^muffle")
[11:02:44.329]                   }
[11:02:44.329]                 }
[11:02:44.329]                 else {
[11:02:44.329]                   if (TRUE) {
[11:02:44.329]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:44.329]                     {
[11:02:44.329]                       inherits <- base::inherits
[11:02:44.329]                       invokeRestart <- base::invokeRestart
[11:02:44.329]                       is.null <- base::is.null
[11:02:44.329]                       muffled <- FALSE
[11:02:44.329]                       if (inherits(cond, "message")) {
[11:02:44.329]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:44.329]                         if (muffled) 
[11:02:44.329]                           invokeRestart("muffleMessage")
[11:02:44.329]                       }
[11:02:44.329]                       else if (inherits(cond, "warning")) {
[11:02:44.329]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:44.329]                         if (muffled) 
[11:02:44.329]                           invokeRestart("muffleWarning")
[11:02:44.329]                       }
[11:02:44.329]                       else if (inherits(cond, "condition")) {
[11:02:44.329]                         if (!is.null(pattern)) {
[11:02:44.329]                           computeRestarts <- base::computeRestarts
[11:02:44.329]                           grepl <- base::grepl
[11:02:44.329]                           restarts <- computeRestarts(cond)
[11:02:44.329]                           for (restart in restarts) {
[11:02:44.329]                             name <- restart$name
[11:02:44.329]                             if (is.null(name)) 
[11:02:44.329]                               next
[11:02:44.329]                             if (!grepl(pattern, name)) 
[11:02:44.329]                               next
[11:02:44.329]                             invokeRestart(restart)
[11:02:44.329]                             muffled <- TRUE
[11:02:44.329]                             break
[11:02:44.329]                           }
[11:02:44.329]                         }
[11:02:44.329]                       }
[11:02:44.329]                       invisible(muffled)
[11:02:44.329]                     }
[11:02:44.329]                     muffleCondition(cond, pattern = "^muffle")
[11:02:44.329]                   }
[11:02:44.329]                 }
[11:02:44.329]             }
[11:02:44.329]         }))
[11:02:44.329]     }, error = function(ex) {
[11:02:44.329]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:44.329]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:44.329]                 ...future.rng), started = ...future.startTime, 
[11:02:44.329]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:44.329]             version = "1.8"), class = "FutureResult")
[11:02:44.329]     }, finally = {
[11:02:44.329]         if (!identical(...future.workdir, getwd())) 
[11:02:44.329]             setwd(...future.workdir)
[11:02:44.329]         {
[11:02:44.329]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:44.329]                 ...future.oldOptions$nwarnings <- NULL
[11:02:44.329]             }
[11:02:44.329]             base::options(...future.oldOptions)
[11:02:44.329]             if (.Platform$OS.type == "windows") {
[11:02:44.329]                 old_names <- names(...future.oldEnvVars)
[11:02:44.329]                 envs <- base::Sys.getenv()
[11:02:44.329]                 names <- names(envs)
[11:02:44.329]                 common <- intersect(names, old_names)
[11:02:44.329]                 added <- setdiff(names, old_names)
[11:02:44.329]                 removed <- setdiff(old_names, names)
[11:02:44.329]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:44.329]                   envs[common]]
[11:02:44.329]                 NAMES <- toupper(changed)
[11:02:44.329]                 args <- list()
[11:02:44.329]                 for (kk in seq_along(NAMES)) {
[11:02:44.329]                   name <- changed[[kk]]
[11:02:44.329]                   NAME <- NAMES[[kk]]
[11:02:44.329]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:44.329]                     next
[11:02:44.329]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:44.329]                 }
[11:02:44.329]                 NAMES <- toupper(added)
[11:02:44.329]                 for (kk in seq_along(NAMES)) {
[11:02:44.329]                   name <- added[[kk]]
[11:02:44.329]                   NAME <- NAMES[[kk]]
[11:02:44.329]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:44.329]                     next
[11:02:44.329]                   args[[name]] <- ""
[11:02:44.329]                 }
[11:02:44.329]                 NAMES <- toupper(removed)
[11:02:44.329]                 for (kk in seq_along(NAMES)) {
[11:02:44.329]                   name <- removed[[kk]]
[11:02:44.329]                   NAME <- NAMES[[kk]]
[11:02:44.329]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:44.329]                     next
[11:02:44.329]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:44.329]                 }
[11:02:44.329]                 if (length(args) > 0) 
[11:02:44.329]                   base::do.call(base::Sys.setenv, args = args)
[11:02:44.329]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:44.329]             }
[11:02:44.329]             else {
[11:02:44.329]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:44.329]             }
[11:02:44.329]             {
[11:02:44.329]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:44.329]                   0L) {
[11:02:44.329]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:44.329]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:44.329]                   base::options(opts)
[11:02:44.329]                 }
[11:02:44.329]                 {
[11:02:44.329]                   {
[11:02:44.329]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:44.329]                     NULL
[11:02:44.329]                   }
[11:02:44.329]                   options(future.plan = NULL)
[11:02:44.329]                   if (is.na(NA_character_)) 
[11:02:44.329]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:44.329]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:44.329]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:44.329]                     .init = FALSE)
[11:02:44.329]                 }
[11:02:44.329]             }
[11:02:44.329]         }
[11:02:44.329]     })
[11:02:44.329]     if (TRUE) {
[11:02:44.329]         base::sink(type = "output", split = FALSE)
[11:02:44.329]         if (TRUE) {
[11:02:44.329]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:44.329]         }
[11:02:44.329]         else {
[11:02:44.329]             ...future.result["stdout"] <- base::list(NULL)
[11:02:44.329]         }
[11:02:44.329]         base::close(...future.stdout)
[11:02:44.329]         ...future.stdout <- NULL
[11:02:44.329]     }
[11:02:44.329]     ...future.result$conditions <- ...future.conditions
[11:02:44.329]     ...future.result$finished <- base::Sys.time()
[11:02:44.329]     ...future.result
[11:02:44.329] }
[11:02:44.332] MultisessionFuture started
[11:02:44.332] - Launch lazy future ... done
[11:02:44.332] run() for ‘MultisessionFuture’ ... done
[11:02:44.875] receiveMessageFromWorker() for ClusterFuture ...
[11:02:44.875] - Validating connection of MultisessionFuture
[11:02:44.875] - received message: FutureResult
[11:02:44.876] - Received FutureResult
[11:02:44.876] - Erased future from FutureRegistry
[11:02:44.876] result() for ClusterFuture ...
[11:02:44.876] - result already collected: FutureResult
[11:02:44.876] result() for ClusterFuture ... done
[11:02:44.876] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:44.876] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[11:02:44.876] getGlobalsAndPackages() ...
[11:02:44.876] Searching for globals...
[11:02:44.877] - globals found: [2] ‘list’, ‘stop’
[11:02:44.877] Searching for globals ... DONE
[11:02:44.877] Resolving globals: FALSE
[11:02:44.878] 
[11:02:44.878] 
[11:02:44.878] getGlobalsAndPackages() ... DONE
[11:02:44.878] run() for ‘Future’ ...
[11:02:44.878] - state: ‘created’
[11:02:44.878] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:44.892] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:44.892] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:44.892]   - Field: ‘node’
[11:02:44.892]   - Field: ‘label’
[11:02:44.892]   - Field: ‘local’
[11:02:44.892]   - Field: ‘owner’
[11:02:44.893]   - Field: ‘envir’
[11:02:44.893]   - Field: ‘workers’
[11:02:44.893]   - Field: ‘packages’
[11:02:44.893]   - Field: ‘gc’
[11:02:44.893]   - Field: ‘conditions’
[11:02:44.893]   - Field: ‘persistent’
[11:02:44.893]   - Field: ‘expr’
[11:02:44.893]   - Field: ‘uuid’
[11:02:44.893]   - Field: ‘seed’
[11:02:44.893]   - Field: ‘version’
[11:02:44.893]   - Field: ‘result’
[11:02:44.893]   - Field: ‘asynchronous’
[11:02:44.894]   - Field: ‘calls’
[11:02:44.894]   - Field: ‘globals’
[11:02:44.894]   - Field: ‘stdout’
[11:02:44.894]   - Field: ‘earlySignal’
[11:02:44.894]   - Field: ‘lazy’
[11:02:44.894]   - Field: ‘state’
[11:02:44.894] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:44.894] - Launch lazy future ...
[11:02:44.894] Packages needed by the future expression (n = 0): <none>
[11:02:44.895] Packages needed by future strategies (n = 0): <none>
[11:02:44.895] {
[11:02:44.895]     {
[11:02:44.895]         {
[11:02:44.895]             ...future.startTime <- base::Sys.time()
[11:02:44.895]             {
[11:02:44.895]                 {
[11:02:44.895]                   {
[11:02:44.895]                     {
[11:02:44.895]                       base::local({
[11:02:44.895]                         has_future <- base::requireNamespace("future", 
[11:02:44.895]                           quietly = TRUE)
[11:02:44.895]                         if (has_future) {
[11:02:44.895]                           ns <- base::getNamespace("future")
[11:02:44.895]                           version <- ns[[".package"]][["version"]]
[11:02:44.895]                           if (is.null(version)) 
[11:02:44.895]                             version <- utils::packageVersion("future")
[11:02:44.895]                         }
[11:02:44.895]                         else {
[11:02:44.895]                           version <- NULL
[11:02:44.895]                         }
[11:02:44.895]                         if (!has_future || version < "1.8.0") {
[11:02:44.895]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:44.895]                             "", base::R.version$version.string), 
[11:02:44.895]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:44.895]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:44.895]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:44.895]                               "release", "version")], collapse = " "), 
[11:02:44.895]                             hostname = base::Sys.info()[["nodename"]])
[11:02:44.895]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:44.895]                             info)
[11:02:44.895]                           info <- base::paste(info, collapse = "; ")
[11:02:44.895]                           if (!has_future) {
[11:02:44.895]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:44.895]                               info)
[11:02:44.895]                           }
[11:02:44.895]                           else {
[11:02:44.895]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:44.895]                               info, version)
[11:02:44.895]                           }
[11:02:44.895]                           base::stop(msg)
[11:02:44.895]                         }
[11:02:44.895]                       })
[11:02:44.895]                     }
[11:02:44.895]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:44.895]                     base::options(mc.cores = 1L)
[11:02:44.895]                   }
[11:02:44.895]                   ...future.strategy.old <- future::plan("list")
[11:02:44.895]                   options(future.plan = NULL)
[11:02:44.895]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:44.895]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:44.895]                 }
[11:02:44.895]                 ...future.workdir <- getwd()
[11:02:44.895]             }
[11:02:44.895]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:44.895]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:44.895]         }
[11:02:44.895]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:44.895]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:44.895]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:44.895]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:44.895]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:44.895]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:44.895]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:44.895]             base::names(...future.oldOptions))
[11:02:44.895]     }
[11:02:44.895]     if (FALSE) {
[11:02:44.895]     }
[11:02:44.895]     else {
[11:02:44.895]         if (TRUE) {
[11:02:44.895]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:44.895]                 open = "w")
[11:02:44.895]         }
[11:02:44.895]         else {
[11:02:44.895]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:44.895]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:44.895]         }
[11:02:44.895]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:44.895]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:44.895]             base::sink(type = "output", split = FALSE)
[11:02:44.895]             base::close(...future.stdout)
[11:02:44.895]         }, add = TRUE)
[11:02:44.895]     }
[11:02:44.895]     ...future.frame <- base::sys.nframe()
[11:02:44.895]     ...future.conditions <- base::list()
[11:02:44.895]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:44.895]     if (FALSE) {
[11:02:44.895]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:44.895]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:44.895]     }
[11:02:44.895]     ...future.result <- base::tryCatch({
[11:02:44.895]         base::withCallingHandlers({
[11:02:44.895]             ...future.value <- base::withVisible(base::local({
[11:02:44.895]                 ...future.makeSendCondition <- base::local({
[11:02:44.895]                   sendCondition <- NULL
[11:02:44.895]                   function(frame = 1L) {
[11:02:44.895]                     if (is.function(sendCondition)) 
[11:02:44.895]                       return(sendCondition)
[11:02:44.895]                     ns <- getNamespace("parallel")
[11:02:44.895]                     if (exists("sendData", mode = "function", 
[11:02:44.895]                       envir = ns)) {
[11:02:44.895]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:44.895]                         envir = ns)
[11:02:44.895]                       envir <- sys.frame(frame)
[11:02:44.895]                       master <- NULL
[11:02:44.895]                       while (!identical(envir, .GlobalEnv) && 
[11:02:44.895]                         !identical(envir, emptyenv())) {
[11:02:44.895]                         if (exists("master", mode = "list", envir = envir, 
[11:02:44.895]                           inherits = FALSE)) {
[11:02:44.895]                           master <- get("master", mode = "list", 
[11:02:44.895]                             envir = envir, inherits = FALSE)
[11:02:44.895]                           if (inherits(master, c("SOCKnode", 
[11:02:44.895]                             "SOCK0node"))) {
[11:02:44.895]                             sendCondition <<- function(cond) {
[11:02:44.895]                               data <- list(type = "VALUE", value = cond, 
[11:02:44.895]                                 success = TRUE)
[11:02:44.895]                               parallel_sendData(master, data)
[11:02:44.895]                             }
[11:02:44.895]                             return(sendCondition)
[11:02:44.895]                           }
[11:02:44.895]                         }
[11:02:44.895]                         frame <- frame + 1L
[11:02:44.895]                         envir <- sys.frame(frame)
[11:02:44.895]                       }
[11:02:44.895]                     }
[11:02:44.895]                     sendCondition <<- function(cond) NULL
[11:02:44.895]                   }
[11:02:44.895]                 })
[11:02:44.895]                 withCallingHandlers({
[11:02:44.895]                   list(a = 1, b = 42L, c = stop("Nah!"))
[11:02:44.895]                 }, immediateCondition = function(cond) {
[11:02:44.895]                   sendCondition <- ...future.makeSendCondition()
[11:02:44.895]                   sendCondition(cond)
[11:02:44.895]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:44.895]                   {
[11:02:44.895]                     inherits <- base::inherits
[11:02:44.895]                     invokeRestart <- base::invokeRestart
[11:02:44.895]                     is.null <- base::is.null
[11:02:44.895]                     muffled <- FALSE
[11:02:44.895]                     if (inherits(cond, "message")) {
[11:02:44.895]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:44.895]                       if (muffled) 
[11:02:44.895]                         invokeRestart("muffleMessage")
[11:02:44.895]                     }
[11:02:44.895]                     else if (inherits(cond, "warning")) {
[11:02:44.895]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:44.895]                       if (muffled) 
[11:02:44.895]                         invokeRestart("muffleWarning")
[11:02:44.895]                     }
[11:02:44.895]                     else if (inherits(cond, "condition")) {
[11:02:44.895]                       if (!is.null(pattern)) {
[11:02:44.895]                         computeRestarts <- base::computeRestarts
[11:02:44.895]                         grepl <- base::grepl
[11:02:44.895]                         restarts <- computeRestarts(cond)
[11:02:44.895]                         for (restart in restarts) {
[11:02:44.895]                           name <- restart$name
[11:02:44.895]                           if (is.null(name)) 
[11:02:44.895]                             next
[11:02:44.895]                           if (!grepl(pattern, name)) 
[11:02:44.895]                             next
[11:02:44.895]                           invokeRestart(restart)
[11:02:44.895]                           muffled <- TRUE
[11:02:44.895]                           break
[11:02:44.895]                         }
[11:02:44.895]                       }
[11:02:44.895]                     }
[11:02:44.895]                     invisible(muffled)
[11:02:44.895]                   }
[11:02:44.895]                   muffleCondition(cond)
[11:02:44.895]                 })
[11:02:44.895]             }))
[11:02:44.895]             future::FutureResult(value = ...future.value$value, 
[11:02:44.895]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:44.895]                   ...future.rng), globalenv = if (FALSE) 
[11:02:44.895]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:44.895]                     ...future.globalenv.names))
[11:02:44.895]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:44.895]         }, condition = base::local({
[11:02:44.895]             c <- base::c
[11:02:44.895]             inherits <- base::inherits
[11:02:44.895]             invokeRestart <- base::invokeRestart
[11:02:44.895]             length <- base::length
[11:02:44.895]             list <- base::list
[11:02:44.895]             seq.int <- base::seq.int
[11:02:44.895]             signalCondition <- base::signalCondition
[11:02:44.895]             sys.calls <- base::sys.calls
[11:02:44.895]             `[[` <- base::`[[`
[11:02:44.895]             `+` <- base::`+`
[11:02:44.895]             `<<-` <- base::`<<-`
[11:02:44.895]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:44.895]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:44.895]                   3L)]
[11:02:44.895]             }
[11:02:44.895]             function(cond) {
[11:02:44.895]                 is_error <- inherits(cond, "error")
[11:02:44.895]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:44.895]                   NULL)
[11:02:44.895]                 if (is_error) {
[11:02:44.895]                   sessionInformation <- function() {
[11:02:44.895]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:44.895]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:44.895]                       search = base::search(), system = base::Sys.info())
[11:02:44.895]                   }
[11:02:44.895]                   ...future.conditions[[length(...future.conditions) + 
[11:02:44.895]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:44.895]                     cond$call), session = sessionInformation(), 
[11:02:44.895]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:44.895]                   signalCondition(cond)
[11:02:44.895]                 }
[11:02:44.895]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:44.895]                 "immediateCondition"))) {
[11:02:44.895]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:44.895]                   ...future.conditions[[length(...future.conditions) + 
[11:02:44.895]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:44.895]                   if (TRUE && !signal) {
[11:02:44.895]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:44.895]                     {
[11:02:44.895]                       inherits <- base::inherits
[11:02:44.895]                       invokeRestart <- base::invokeRestart
[11:02:44.895]                       is.null <- base::is.null
[11:02:44.895]                       muffled <- FALSE
[11:02:44.895]                       if (inherits(cond, "message")) {
[11:02:44.895]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:44.895]                         if (muffled) 
[11:02:44.895]                           invokeRestart("muffleMessage")
[11:02:44.895]                       }
[11:02:44.895]                       else if (inherits(cond, "warning")) {
[11:02:44.895]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:44.895]                         if (muffled) 
[11:02:44.895]                           invokeRestart("muffleWarning")
[11:02:44.895]                       }
[11:02:44.895]                       else if (inherits(cond, "condition")) {
[11:02:44.895]                         if (!is.null(pattern)) {
[11:02:44.895]                           computeRestarts <- base::computeRestarts
[11:02:44.895]                           grepl <- base::grepl
[11:02:44.895]                           restarts <- computeRestarts(cond)
[11:02:44.895]                           for (restart in restarts) {
[11:02:44.895]                             name <- restart$name
[11:02:44.895]                             if (is.null(name)) 
[11:02:44.895]                               next
[11:02:44.895]                             if (!grepl(pattern, name)) 
[11:02:44.895]                               next
[11:02:44.895]                             invokeRestart(restart)
[11:02:44.895]                             muffled <- TRUE
[11:02:44.895]                             break
[11:02:44.895]                           }
[11:02:44.895]                         }
[11:02:44.895]                       }
[11:02:44.895]                       invisible(muffled)
[11:02:44.895]                     }
[11:02:44.895]                     muffleCondition(cond, pattern = "^muffle")
[11:02:44.895]                   }
[11:02:44.895]                 }
[11:02:44.895]                 else {
[11:02:44.895]                   if (TRUE) {
[11:02:44.895]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:44.895]                     {
[11:02:44.895]                       inherits <- base::inherits
[11:02:44.895]                       invokeRestart <- base::invokeRestart
[11:02:44.895]                       is.null <- base::is.null
[11:02:44.895]                       muffled <- FALSE
[11:02:44.895]                       if (inherits(cond, "message")) {
[11:02:44.895]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:44.895]                         if (muffled) 
[11:02:44.895]                           invokeRestart("muffleMessage")
[11:02:44.895]                       }
[11:02:44.895]                       else if (inherits(cond, "warning")) {
[11:02:44.895]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:44.895]                         if (muffled) 
[11:02:44.895]                           invokeRestart("muffleWarning")
[11:02:44.895]                       }
[11:02:44.895]                       else if (inherits(cond, "condition")) {
[11:02:44.895]                         if (!is.null(pattern)) {
[11:02:44.895]                           computeRestarts <- base::computeRestarts
[11:02:44.895]                           grepl <- base::grepl
[11:02:44.895]                           restarts <- computeRestarts(cond)
[11:02:44.895]                           for (restart in restarts) {
[11:02:44.895]                             name <- restart$name
[11:02:44.895]                             if (is.null(name)) 
[11:02:44.895]                               next
[11:02:44.895]                             if (!grepl(pattern, name)) 
[11:02:44.895]                               next
[11:02:44.895]                             invokeRestart(restart)
[11:02:44.895]                             muffled <- TRUE
[11:02:44.895]                             break
[11:02:44.895]                           }
[11:02:44.895]                         }
[11:02:44.895]                       }
[11:02:44.895]                       invisible(muffled)
[11:02:44.895]                     }
[11:02:44.895]                     muffleCondition(cond, pattern = "^muffle")
[11:02:44.895]                   }
[11:02:44.895]                 }
[11:02:44.895]             }
[11:02:44.895]         }))
[11:02:44.895]     }, error = function(ex) {
[11:02:44.895]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:44.895]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:44.895]                 ...future.rng), started = ...future.startTime, 
[11:02:44.895]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:44.895]             version = "1.8"), class = "FutureResult")
[11:02:44.895]     }, finally = {
[11:02:44.895]         if (!identical(...future.workdir, getwd())) 
[11:02:44.895]             setwd(...future.workdir)
[11:02:44.895]         {
[11:02:44.895]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:44.895]                 ...future.oldOptions$nwarnings <- NULL
[11:02:44.895]             }
[11:02:44.895]             base::options(...future.oldOptions)
[11:02:44.895]             if (.Platform$OS.type == "windows") {
[11:02:44.895]                 old_names <- names(...future.oldEnvVars)
[11:02:44.895]                 envs <- base::Sys.getenv()
[11:02:44.895]                 names <- names(envs)
[11:02:44.895]                 common <- intersect(names, old_names)
[11:02:44.895]                 added <- setdiff(names, old_names)
[11:02:44.895]                 removed <- setdiff(old_names, names)
[11:02:44.895]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:44.895]                   envs[common]]
[11:02:44.895]                 NAMES <- toupper(changed)
[11:02:44.895]                 args <- list()
[11:02:44.895]                 for (kk in seq_along(NAMES)) {
[11:02:44.895]                   name <- changed[[kk]]
[11:02:44.895]                   NAME <- NAMES[[kk]]
[11:02:44.895]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:44.895]                     next
[11:02:44.895]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:44.895]                 }
[11:02:44.895]                 NAMES <- toupper(added)
[11:02:44.895]                 for (kk in seq_along(NAMES)) {
[11:02:44.895]                   name <- added[[kk]]
[11:02:44.895]                   NAME <- NAMES[[kk]]
[11:02:44.895]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:44.895]                     next
[11:02:44.895]                   args[[name]] <- ""
[11:02:44.895]                 }
[11:02:44.895]                 NAMES <- toupper(removed)
[11:02:44.895]                 for (kk in seq_along(NAMES)) {
[11:02:44.895]                   name <- removed[[kk]]
[11:02:44.895]                   NAME <- NAMES[[kk]]
[11:02:44.895]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:44.895]                     next
[11:02:44.895]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:44.895]                 }
[11:02:44.895]                 if (length(args) > 0) 
[11:02:44.895]                   base::do.call(base::Sys.setenv, args = args)
[11:02:44.895]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:44.895]             }
[11:02:44.895]             else {
[11:02:44.895]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:44.895]             }
[11:02:44.895]             {
[11:02:44.895]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:44.895]                   0L) {
[11:02:44.895]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:44.895]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:44.895]                   base::options(opts)
[11:02:44.895]                 }
[11:02:44.895]                 {
[11:02:44.895]                   {
[11:02:44.895]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:44.895]                     NULL
[11:02:44.895]                   }
[11:02:44.895]                   options(future.plan = NULL)
[11:02:44.895]                   if (is.na(NA_character_)) 
[11:02:44.895]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:44.895]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:44.895]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:44.895]                     .init = FALSE)
[11:02:44.895]                 }
[11:02:44.895]             }
[11:02:44.895]         }
[11:02:44.895]     })
[11:02:44.895]     if (TRUE) {
[11:02:44.895]         base::sink(type = "output", split = FALSE)
[11:02:44.895]         if (TRUE) {
[11:02:44.895]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:44.895]         }
[11:02:44.895]         else {
[11:02:44.895]             ...future.result["stdout"] <- base::list(NULL)
[11:02:44.895]         }
[11:02:44.895]         base::close(...future.stdout)
[11:02:44.895]         ...future.stdout <- NULL
[11:02:44.895]     }
[11:02:44.895]     ...future.result$conditions <- ...future.conditions
[11:02:44.895]     ...future.result$finished <- base::Sys.time()
[11:02:44.895]     ...future.result
[11:02:44.895] }
[11:02:44.898] MultisessionFuture started
[11:02:44.898] - Launch lazy future ... done
[11:02:44.898] run() for ‘MultisessionFuture’ ... done
[11:02:44.940] receiveMessageFromWorker() for ClusterFuture ...
[11:02:44.940] - Validating connection of MultisessionFuture
[11:02:44.941] - received message: FutureResult
[11:02:44.941] - Received FutureResult
[11:02:44.941] - Erased future from FutureRegistry
[11:02:44.941] result() for ClusterFuture ...
[11:02:44.941] - result already collected: FutureResult
[11:02:44.941] result() for ClusterFuture ... done
[11:02:44.941] signalConditions() ...
[11:02:44.941]  - include = ‘immediateCondition’
[11:02:44.942]  - exclude = 
[11:02:44.942]  - resignal = FALSE
[11:02:44.942]  - Number of conditions: 1
[11:02:44.942] signalConditions() ... done
[11:02:44.942] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:44.942] A MultisessionFuture was resolved (result was not collected)
[11:02:44.942] getGlobalsAndPackages() ...
[11:02:44.942] Searching for globals...
[11:02:44.943] - globals found: [2] ‘list’, ‘stop’
[11:02:44.943] Searching for globals ... DONE
[11:02:44.943] Resolving globals: FALSE
[11:02:44.943] 
[11:02:44.943] 
[11:02:44.943] getGlobalsAndPackages() ... DONE
[11:02:44.944] run() for ‘Future’ ...
[11:02:44.944] - state: ‘created’
[11:02:44.944] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:44.957] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:44.957] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:44.958]   - Field: ‘node’
[11:02:44.958]   - Field: ‘label’
[11:02:44.958]   - Field: ‘local’
[11:02:44.958]   - Field: ‘owner’
[11:02:44.958]   - Field: ‘envir’
[11:02:44.958]   - Field: ‘workers’
[11:02:44.958]   - Field: ‘packages’
[11:02:44.958]   - Field: ‘gc’
[11:02:44.958]   - Field: ‘conditions’
[11:02:44.958]   - Field: ‘persistent’
[11:02:44.958]   - Field: ‘expr’
[11:02:44.959]   - Field: ‘uuid’
[11:02:44.959]   - Field: ‘seed’
[11:02:44.959]   - Field: ‘version’
[11:02:44.959]   - Field: ‘result’
[11:02:44.959]   - Field: ‘asynchronous’
[11:02:44.959]   - Field: ‘calls’
[11:02:44.959]   - Field: ‘globals’
[11:02:44.959]   - Field: ‘stdout’
[11:02:44.959]   - Field: ‘earlySignal’
[11:02:44.959]   - Field: ‘lazy’
[11:02:44.959]   - Field: ‘state’
[11:02:44.959] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:44.960] - Launch lazy future ...
[11:02:44.960] Packages needed by the future expression (n = 0): <none>
[11:02:44.960] Packages needed by future strategies (n = 0): <none>
[11:02:44.960] {
[11:02:44.960]     {
[11:02:44.960]         {
[11:02:44.960]             ...future.startTime <- base::Sys.time()
[11:02:44.960]             {
[11:02:44.960]                 {
[11:02:44.960]                   {
[11:02:44.960]                     {
[11:02:44.960]                       base::local({
[11:02:44.960]                         has_future <- base::requireNamespace("future", 
[11:02:44.960]                           quietly = TRUE)
[11:02:44.960]                         if (has_future) {
[11:02:44.960]                           ns <- base::getNamespace("future")
[11:02:44.960]                           version <- ns[[".package"]][["version"]]
[11:02:44.960]                           if (is.null(version)) 
[11:02:44.960]                             version <- utils::packageVersion("future")
[11:02:44.960]                         }
[11:02:44.960]                         else {
[11:02:44.960]                           version <- NULL
[11:02:44.960]                         }
[11:02:44.960]                         if (!has_future || version < "1.8.0") {
[11:02:44.960]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:44.960]                             "", base::R.version$version.string), 
[11:02:44.960]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:44.960]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:44.960]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:44.960]                               "release", "version")], collapse = " "), 
[11:02:44.960]                             hostname = base::Sys.info()[["nodename"]])
[11:02:44.960]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:44.960]                             info)
[11:02:44.960]                           info <- base::paste(info, collapse = "; ")
[11:02:44.960]                           if (!has_future) {
[11:02:44.960]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:44.960]                               info)
[11:02:44.960]                           }
[11:02:44.960]                           else {
[11:02:44.960]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:44.960]                               info, version)
[11:02:44.960]                           }
[11:02:44.960]                           base::stop(msg)
[11:02:44.960]                         }
[11:02:44.960]                       })
[11:02:44.960]                     }
[11:02:44.960]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:44.960]                     base::options(mc.cores = 1L)
[11:02:44.960]                   }
[11:02:44.960]                   ...future.strategy.old <- future::plan("list")
[11:02:44.960]                   options(future.plan = NULL)
[11:02:44.960]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:44.960]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:44.960]                 }
[11:02:44.960]                 ...future.workdir <- getwd()
[11:02:44.960]             }
[11:02:44.960]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:44.960]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:44.960]         }
[11:02:44.960]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:44.960]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:44.960]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:44.960]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:44.960]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:44.960]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:44.960]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:44.960]             base::names(...future.oldOptions))
[11:02:44.960]     }
[11:02:44.960]     if (FALSE) {
[11:02:44.960]     }
[11:02:44.960]     else {
[11:02:44.960]         if (TRUE) {
[11:02:44.960]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:44.960]                 open = "w")
[11:02:44.960]         }
[11:02:44.960]         else {
[11:02:44.960]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:44.960]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:44.960]         }
[11:02:44.960]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:44.960]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:44.960]             base::sink(type = "output", split = FALSE)
[11:02:44.960]             base::close(...future.stdout)
[11:02:44.960]         }, add = TRUE)
[11:02:44.960]     }
[11:02:44.960]     ...future.frame <- base::sys.nframe()
[11:02:44.960]     ...future.conditions <- base::list()
[11:02:44.960]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:44.960]     if (FALSE) {
[11:02:44.960]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:44.960]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:44.960]     }
[11:02:44.960]     ...future.result <- base::tryCatch({
[11:02:44.960]         base::withCallingHandlers({
[11:02:44.960]             ...future.value <- base::withVisible(base::local({
[11:02:44.960]                 ...future.makeSendCondition <- base::local({
[11:02:44.960]                   sendCondition <- NULL
[11:02:44.960]                   function(frame = 1L) {
[11:02:44.960]                     if (is.function(sendCondition)) 
[11:02:44.960]                       return(sendCondition)
[11:02:44.960]                     ns <- getNamespace("parallel")
[11:02:44.960]                     if (exists("sendData", mode = "function", 
[11:02:44.960]                       envir = ns)) {
[11:02:44.960]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:44.960]                         envir = ns)
[11:02:44.960]                       envir <- sys.frame(frame)
[11:02:44.960]                       master <- NULL
[11:02:44.960]                       while (!identical(envir, .GlobalEnv) && 
[11:02:44.960]                         !identical(envir, emptyenv())) {
[11:02:44.960]                         if (exists("master", mode = "list", envir = envir, 
[11:02:44.960]                           inherits = FALSE)) {
[11:02:44.960]                           master <- get("master", mode = "list", 
[11:02:44.960]                             envir = envir, inherits = FALSE)
[11:02:44.960]                           if (inherits(master, c("SOCKnode", 
[11:02:44.960]                             "SOCK0node"))) {
[11:02:44.960]                             sendCondition <<- function(cond) {
[11:02:44.960]                               data <- list(type = "VALUE", value = cond, 
[11:02:44.960]                                 success = TRUE)
[11:02:44.960]                               parallel_sendData(master, data)
[11:02:44.960]                             }
[11:02:44.960]                             return(sendCondition)
[11:02:44.960]                           }
[11:02:44.960]                         }
[11:02:44.960]                         frame <- frame + 1L
[11:02:44.960]                         envir <- sys.frame(frame)
[11:02:44.960]                       }
[11:02:44.960]                     }
[11:02:44.960]                     sendCondition <<- function(cond) NULL
[11:02:44.960]                   }
[11:02:44.960]                 })
[11:02:44.960]                 withCallingHandlers({
[11:02:44.960]                   list(a = 1, b = 42L, c = stop("Nah!"))
[11:02:44.960]                 }, immediateCondition = function(cond) {
[11:02:44.960]                   sendCondition <- ...future.makeSendCondition()
[11:02:44.960]                   sendCondition(cond)
[11:02:44.960]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:44.960]                   {
[11:02:44.960]                     inherits <- base::inherits
[11:02:44.960]                     invokeRestart <- base::invokeRestart
[11:02:44.960]                     is.null <- base::is.null
[11:02:44.960]                     muffled <- FALSE
[11:02:44.960]                     if (inherits(cond, "message")) {
[11:02:44.960]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:44.960]                       if (muffled) 
[11:02:44.960]                         invokeRestart("muffleMessage")
[11:02:44.960]                     }
[11:02:44.960]                     else if (inherits(cond, "warning")) {
[11:02:44.960]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:44.960]                       if (muffled) 
[11:02:44.960]                         invokeRestart("muffleWarning")
[11:02:44.960]                     }
[11:02:44.960]                     else if (inherits(cond, "condition")) {
[11:02:44.960]                       if (!is.null(pattern)) {
[11:02:44.960]                         computeRestarts <- base::computeRestarts
[11:02:44.960]                         grepl <- base::grepl
[11:02:44.960]                         restarts <- computeRestarts(cond)
[11:02:44.960]                         for (restart in restarts) {
[11:02:44.960]                           name <- restart$name
[11:02:44.960]                           if (is.null(name)) 
[11:02:44.960]                             next
[11:02:44.960]                           if (!grepl(pattern, name)) 
[11:02:44.960]                             next
[11:02:44.960]                           invokeRestart(restart)
[11:02:44.960]                           muffled <- TRUE
[11:02:44.960]                           break
[11:02:44.960]                         }
[11:02:44.960]                       }
[11:02:44.960]                     }
[11:02:44.960]                     invisible(muffled)
[11:02:44.960]                   }
[11:02:44.960]                   muffleCondition(cond)
[11:02:44.960]                 })
[11:02:44.960]             }))
[11:02:44.960]             future::FutureResult(value = ...future.value$value, 
[11:02:44.960]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:44.960]                   ...future.rng), globalenv = if (FALSE) 
[11:02:44.960]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:44.960]                     ...future.globalenv.names))
[11:02:44.960]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:44.960]         }, condition = base::local({
[11:02:44.960]             c <- base::c
[11:02:44.960]             inherits <- base::inherits
[11:02:44.960]             invokeRestart <- base::invokeRestart
[11:02:44.960]             length <- base::length
[11:02:44.960]             list <- base::list
[11:02:44.960]             seq.int <- base::seq.int
[11:02:44.960]             signalCondition <- base::signalCondition
[11:02:44.960]             sys.calls <- base::sys.calls
[11:02:44.960]             `[[` <- base::`[[`
[11:02:44.960]             `+` <- base::`+`
[11:02:44.960]             `<<-` <- base::`<<-`
[11:02:44.960]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:44.960]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:44.960]                   3L)]
[11:02:44.960]             }
[11:02:44.960]             function(cond) {
[11:02:44.960]                 is_error <- inherits(cond, "error")
[11:02:44.960]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:44.960]                   NULL)
[11:02:44.960]                 if (is_error) {
[11:02:44.960]                   sessionInformation <- function() {
[11:02:44.960]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:44.960]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:44.960]                       search = base::search(), system = base::Sys.info())
[11:02:44.960]                   }
[11:02:44.960]                   ...future.conditions[[length(...future.conditions) + 
[11:02:44.960]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:44.960]                     cond$call), session = sessionInformation(), 
[11:02:44.960]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:44.960]                   signalCondition(cond)
[11:02:44.960]                 }
[11:02:44.960]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:44.960]                 "immediateCondition"))) {
[11:02:44.960]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:44.960]                   ...future.conditions[[length(...future.conditions) + 
[11:02:44.960]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:44.960]                   if (TRUE && !signal) {
[11:02:44.960]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:44.960]                     {
[11:02:44.960]                       inherits <- base::inherits
[11:02:44.960]                       invokeRestart <- base::invokeRestart
[11:02:44.960]                       is.null <- base::is.null
[11:02:44.960]                       muffled <- FALSE
[11:02:44.960]                       if (inherits(cond, "message")) {
[11:02:44.960]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:44.960]                         if (muffled) 
[11:02:44.960]                           invokeRestart("muffleMessage")
[11:02:44.960]                       }
[11:02:44.960]                       else if (inherits(cond, "warning")) {
[11:02:44.960]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:44.960]                         if (muffled) 
[11:02:44.960]                           invokeRestart("muffleWarning")
[11:02:44.960]                       }
[11:02:44.960]                       else if (inherits(cond, "condition")) {
[11:02:44.960]                         if (!is.null(pattern)) {
[11:02:44.960]                           computeRestarts <- base::computeRestarts
[11:02:44.960]                           grepl <- base::grepl
[11:02:44.960]                           restarts <- computeRestarts(cond)
[11:02:44.960]                           for (restart in restarts) {
[11:02:44.960]                             name <- restart$name
[11:02:44.960]                             if (is.null(name)) 
[11:02:44.960]                               next
[11:02:44.960]                             if (!grepl(pattern, name)) 
[11:02:44.960]                               next
[11:02:44.960]                             invokeRestart(restart)
[11:02:44.960]                             muffled <- TRUE
[11:02:44.960]                             break
[11:02:44.960]                           }
[11:02:44.960]                         }
[11:02:44.960]                       }
[11:02:44.960]                       invisible(muffled)
[11:02:44.960]                     }
[11:02:44.960]                     muffleCondition(cond, pattern = "^muffle")
[11:02:44.960]                   }
[11:02:44.960]                 }
[11:02:44.960]                 else {
[11:02:44.960]                   if (TRUE) {
[11:02:44.960]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:44.960]                     {
[11:02:44.960]                       inherits <- base::inherits
[11:02:44.960]                       invokeRestart <- base::invokeRestart
[11:02:44.960]                       is.null <- base::is.null
[11:02:44.960]                       muffled <- FALSE
[11:02:44.960]                       if (inherits(cond, "message")) {
[11:02:44.960]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:44.960]                         if (muffled) 
[11:02:44.960]                           invokeRestart("muffleMessage")
[11:02:44.960]                       }
[11:02:44.960]                       else if (inherits(cond, "warning")) {
[11:02:44.960]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:44.960]                         if (muffled) 
[11:02:44.960]                           invokeRestart("muffleWarning")
[11:02:44.960]                       }
[11:02:44.960]                       else if (inherits(cond, "condition")) {
[11:02:44.960]                         if (!is.null(pattern)) {
[11:02:44.960]                           computeRestarts <- base::computeRestarts
[11:02:44.960]                           grepl <- base::grepl
[11:02:44.960]                           restarts <- computeRestarts(cond)
[11:02:44.960]                           for (restart in restarts) {
[11:02:44.960]                             name <- restart$name
[11:02:44.960]                             if (is.null(name)) 
[11:02:44.960]                               next
[11:02:44.960]                             if (!grepl(pattern, name)) 
[11:02:44.960]                               next
[11:02:44.960]                             invokeRestart(restart)
[11:02:44.960]                             muffled <- TRUE
[11:02:44.960]                             break
[11:02:44.960]                           }
[11:02:44.960]                         }
[11:02:44.960]                       }
[11:02:44.960]                       invisible(muffled)
[11:02:44.960]                     }
[11:02:44.960]                     muffleCondition(cond, pattern = "^muffle")
[11:02:44.960]                   }
[11:02:44.960]                 }
[11:02:44.960]             }
[11:02:44.960]         }))
[11:02:44.960]     }, error = function(ex) {
[11:02:44.960]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:44.960]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:44.960]                 ...future.rng), started = ...future.startTime, 
[11:02:44.960]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:44.960]             version = "1.8"), class = "FutureResult")
[11:02:44.960]     }, finally = {
[11:02:44.960]         if (!identical(...future.workdir, getwd())) 
[11:02:44.960]             setwd(...future.workdir)
[11:02:44.960]         {
[11:02:44.960]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:44.960]                 ...future.oldOptions$nwarnings <- NULL
[11:02:44.960]             }
[11:02:44.960]             base::options(...future.oldOptions)
[11:02:44.960]             if (.Platform$OS.type == "windows") {
[11:02:44.960]                 old_names <- names(...future.oldEnvVars)
[11:02:44.960]                 envs <- base::Sys.getenv()
[11:02:44.960]                 names <- names(envs)
[11:02:44.960]                 common <- intersect(names, old_names)
[11:02:44.960]                 added <- setdiff(names, old_names)
[11:02:44.960]                 removed <- setdiff(old_names, names)
[11:02:44.960]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:44.960]                   envs[common]]
[11:02:44.960]                 NAMES <- toupper(changed)
[11:02:44.960]                 args <- list()
[11:02:44.960]                 for (kk in seq_along(NAMES)) {
[11:02:44.960]                   name <- changed[[kk]]
[11:02:44.960]                   NAME <- NAMES[[kk]]
[11:02:44.960]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:44.960]                     next
[11:02:44.960]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:44.960]                 }
[11:02:44.960]                 NAMES <- toupper(added)
[11:02:44.960]                 for (kk in seq_along(NAMES)) {
[11:02:44.960]                   name <- added[[kk]]
[11:02:44.960]                   NAME <- NAMES[[kk]]
[11:02:44.960]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:44.960]                     next
[11:02:44.960]                   args[[name]] <- ""
[11:02:44.960]                 }
[11:02:44.960]                 NAMES <- toupper(removed)
[11:02:44.960]                 for (kk in seq_along(NAMES)) {
[11:02:44.960]                   name <- removed[[kk]]
[11:02:44.960]                   NAME <- NAMES[[kk]]
[11:02:44.960]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:44.960]                     next
[11:02:44.960]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:44.960]                 }
[11:02:44.960]                 if (length(args) > 0) 
[11:02:44.960]                   base::do.call(base::Sys.setenv, args = args)
[11:02:44.960]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:44.960]             }
[11:02:44.960]             else {
[11:02:44.960]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:44.960]             }
[11:02:44.960]             {
[11:02:44.960]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:44.960]                   0L) {
[11:02:44.960]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:44.960]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:44.960]                   base::options(opts)
[11:02:44.960]                 }
[11:02:44.960]                 {
[11:02:44.960]                   {
[11:02:44.960]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:44.960]                     NULL
[11:02:44.960]                   }
[11:02:44.960]                   options(future.plan = NULL)
[11:02:44.960]                   if (is.na(NA_character_)) 
[11:02:44.960]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:44.960]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:44.960]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:44.960]                     .init = FALSE)
[11:02:44.960]                 }
[11:02:44.960]             }
[11:02:44.960]         }
[11:02:44.960]     })
[11:02:44.960]     if (TRUE) {
[11:02:44.960]         base::sink(type = "output", split = FALSE)
[11:02:44.960]         if (TRUE) {
[11:02:44.960]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:44.960]         }
[11:02:44.960]         else {
[11:02:44.960]             ...future.result["stdout"] <- base::list(NULL)
[11:02:44.960]         }
[11:02:44.960]         base::close(...future.stdout)
[11:02:44.960]         ...future.stdout <- NULL
[11:02:44.960]     }
[11:02:44.960]     ...future.result$conditions <- ...future.conditions
[11:02:44.960]     ...future.result$finished <- base::Sys.time()
[11:02:44.960]     ...future.result
[11:02:44.960] }
[11:02:44.963] MultisessionFuture started
[11:02:44.963] - Launch lazy future ... done
[11:02:44.963] run() for ‘MultisessionFuture’ ... done
[11:02:45.005] receiveMessageFromWorker() for ClusterFuture ...
[11:02:45.005] - Validating connection of MultisessionFuture
[11:02:45.005] - received message: FutureResult
[11:02:45.005] - Received FutureResult
[11:02:45.006] - Erased future from FutureRegistry
[11:02:45.006] result() for ClusterFuture ...
[11:02:45.006] - result already collected: FutureResult
[11:02:45.006] result() for ClusterFuture ... done
[11:02:45.006] signalConditions() ...
[11:02:45.006]  - include = ‘immediateCondition’
[11:02:45.006]  - exclude = 
[11:02:45.006]  - resignal = FALSE
[11:02:45.006]  - Number of conditions: 1
[11:02:45.006] signalConditions() ... done
[11:02:45.006] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:45.007] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 0 ... DONE
- result = FALSE, recursive = 1 ...
[11:02:45.007] getGlobalsAndPackages() ...
[11:02:45.007] Searching for globals...
[11:02:45.008] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[11:02:45.008] Searching for globals ... DONE
[11:02:45.008] Resolving globals: FALSE
[11:02:45.008] 
[11:02:45.008] 
[11:02:45.009] getGlobalsAndPackages() ... DONE
[11:02:45.009] run() for ‘Future’ ...
[11:02:45.009] - state: ‘created’
[11:02:45.009] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:45.022] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:45.022] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:45.022]   - Field: ‘node’
[11:02:45.023]   - Field: ‘label’
[11:02:45.023]   - Field: ‘local’
[11:02:45.023]   - Field: ‘owner’
[11:02:45.023]   - Field: ‘envir’
[11:02:45.023]   - Field: ‘workers’
[11:02:45.023]   - Field: ‘packages’
[11:02:45.023]   - Field: ‘gc’
[11:02:45.023]   - Field: ‘conditions’
[11:02:45.023]   - Field: ‘persistent’
[11:02:45.023]   - Field: ‘expr’
[11:02:45.023]   - Field: ‘uuid’
[11:02:45.023]   - Field: ‘seed’
[11:02:45.024]   - Field: ‘version’
[11:02:45.024]   - Field: ‘result’
[11:02:45.024]   - Field: ‘asynchronous’
[11:02:45.024]   - Field: ‘calls’
[11:02:45.024]   - Field: ‘globals’
[11:02:45.024]   - Field: ‘stdout’
[11:02:45.024]   - Field: ‘earlySignal’
[11:02:45.024]   - Field: ‘lazy’
[11:02:45.024]   - Field: ‘state’
[11:02:45.024] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:45.024] - Launch lazy future ...
[11:02:45.025] Packages needed by the future expression (n = 0): <none>
[11:02:45.025] Packages needed by future strategies (n = 0): <none>
[11:02:45.025] {
[11:02:45.025]     {
[11:02:45.025]         {
[11:02:45.025]             ...future.startTime <- base::Sys.time()
[11:02:45.025]             {
[11:02:45.025]                 {
[11:02:45.025]                   {
[11:02:45.025]                     {
[11:02:45.025]                       base::local({
[11:02:45.025]                         has_future <- base::requireNamespace("future", 
[11:02:45.025]                           quietly = TRUE)
[11:02:45.025]                         if (has_future) {
[11:02:45.025]                           ns <- base::getNamespace("future")
[11:02:45.025]                           version <- ns[[".package"]][["version"]]
[11:02:45.025]                           if (is.null(version)) 
[11:02:45.025]                             version <- utils::packageVersion("future")
[11:02:45.025]                         }
[11:02:45.025]                         else {
[11:02:45.025]                           version <- NULL
[11:02:45.025]                         }
[11:02:45.025]                         if (!has_future || version < "1.8.0") {
[11:02:45.025]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:45.025]                             "", base::R.version$version.string), 
[11:02:45.025]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:45.025]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:45.025]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:45.025]                               "release", "version")], collapse = " "), 
[11:02:45.025]                             hostname = base::Sys.info()[["nodename"]])
[11:02:45.025]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:45.025]                             info)
[11:02:45.025]                           info <- base::paste(info, collapse = "; ")
[11:02:45.025]                           if (!has_future) {
[11:02:45.025]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:45.025]                               info)
[11:02:45.025]                           }
[11:02:45.025]                           else {
[11:02:45.025]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:45.025]                               info, version)
[11:02:45.025]                           }
[11:02:45.025]                           base::stop(msg)
[11:02:45.025]                         }
[11:02:45.025]                       })
[11:02:45.025]                     }
[11:02:45.025]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:45.025]                     base::options(mc.cores = 1L)
[11:02:45.025]                   }
[11:02:45.025]                   ...future.strategy.old <- future::plan("list")
[11:02:45.025]                   options(future.plan = NULL)
[11:02:45.025]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:45.025]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:45.025]                 }
[11:02:45.025]                 ...future.workdir <- getwd()
[11:02:45.025]             }
[11:02:45.025]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:45.025]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:45.025]         }
[11:02:45.025]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:45.025]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:45.025]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:45.025]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:45.025]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:45.025]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:45.025]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:45.025]             base::names(...future.oldOptions))
[11:02:45.025]     }
[11:02:45.025]     if (FALSE) {
[11:02:45.025]     }
[11:02:45.025]     else {
[11:02:45.025]         if (TRUE) {
[11:02:45.025]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:45.025]                 open = "w")
[11:02:45.025]         }
[11:02:45.025]         else {
[11:02:45.025]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:45.025]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:45.025]         }
[11:02:45.025]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:45.025]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:45.025]             base::sink(type = "output", split = FALSE)
[11:02:45.025]             base::close(...future.stdout)
[11:02:45.025]         }, add = TRUE)
[11:02:45.025]     }
[11:02:45.025]     ...future.frame <- base::sys.nframe()
[11:02:45.025]     ...future.conditions <- base::list()
[11:02:45.025]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:45.025]     if (FALSE) {
[11:02:45.025]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:45.025]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:45.025]     }
[11:02:45.025]     ...future.result <- base::tryCatch({
[11:02:45.025]         base::withCallingHandlers({
[11:02:45.025]             ...future.value <- base::withVisible(base::local({
[11:02:45.025]                 ...future.makeSendCondition <- base::local({
[11:02:45.025]                   sendCondition <- NULL
[11:02:45.025]                   function(frame = 1L) {
[11:02:45.025]                     if (is.function(sendCondition)) 
[11:02:45.025]                       return(sendCondition)
[11:02:45.025]                     ns <- getNamespace("parallel")
[11:02:45.025]                     if (exists("sendData", mode = "function", 
[11:02:45.025]                       envir = ns)) {
[11:02:45.025]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:45.025]                         envir = ns)
[11:02:45.025]                       envir <- sys.frame(frame)
[11:02:45.025]                       master <- NULL
[11:02:45.025]                       while (!identical(envir, .GlobalEnv) && 
[11:02:45.025]                         !identical(envir, emptyenv())) {
[11:02:45.025]                         if (exists("master", mode = "list", envir = envir, 
[11:02:45.025]                           inherits = FALSE)) {
[11:02:45.025]                           master <- get("master", mode = "list", 
[11:02:45.025]                             envir = envir, inherits = FALSE)
[11:02:45.025]                           if (inherits(master, c("SOCKnode", 
[11:02:45.025]                             "SOCK0node"))) {
[11:02:45.025]                             sendCondition <<- function(cond) {
[11:02:45.025]                               data <- list(type = "VALUE", value = cond, 
[11:02:45.025]                                 success = TRUE)
[11:02:45.025]                               parallel_sendData(master, data)
[11:02:45.025]                             }
[11:02:45.025]                             return(sendCondition)
[11:02:45.025]                           }
[11:02:45.025]                         }
[11:02:45.025]                         frame <- frame + 1L
[11:02:45.025]                         envir <- sys.frame(frame)
[11:02:45.025]                       }
[11:02:45.025]                     }
[11:02:45.025]                     sendCondition <<- function(cond) NULL
[11:02:45.025]                   }
[11:02:45.025]                 })
[11:02:45.025]                 withCallingHandlers({
[11:02:45.025]                   {
[11:02:45.025]                     Sys.sleep(0.5)
[11:02:45.025]                     list(a = 1, b = 42L)
[11:02:45.025]                   }
[11:02:45.025]                 }, immediateCondition = function(cond) {
[11:02:45.025]                   sendCondition <- ...future.makeSendCondition()
[11:02:45.025]                   sendCondition(cond)
[11:02:45.025]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:45.025]                   {
[11:02:45.025]                     inherits <- base::inherits
[11:02:45.025]                     invokeRestart <- base::invokeRestart
[11:02:45.025]                     is.null <- base::is.null
[11:02:45.025]                     muffled <- FALSE
[11:02:45.025]                     if (inherits(cond, "message")) {
[11:02:45.025]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:45.025]                       if (muffled) 
[11:02:45.025]                         invokeRestart("muffleMessage")
[11:02:45.025]                     }
[11:02:45.025]                     else if (inherits(cond, "warning")) {
[11:02:45.025]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:45.025]                       if (muffled) 
[11:02:45.025]                         invokeRestart("muffleWarning")
[11:02:45.025]                     }
[11:02:45.025]                     else if (inherits(cond, "condition")) {
[11:02:45.025]                       if (!is.null(pattern)) {
[11:02:45.025]                         computeRestarts <- base::computeRestarts
[11:02:45.025]                         grepl <- base::grepl
[11:02:45.025]                         restarts <- computeRestarts(cond)
[11:02:45.025]                         for (restart in restarts) {
[11:02:45.025]                           name <- restart$name
[11:02:45.025]                           if (is.null(name)) 
[11:02:45.025]                             next
[11:02:45.025]                           if (!grepl(pattern, name)) 
[11:02:45.025]                             next
[11:02:45.025]                           invokeRestart(restart)
[11:02:45.025]                           muffled <- TRUE
[11:02:45.025]                           break
[11:02:45.025]                         }
[11:02:45.025]                       }
[11:02:45.025]                     }
[11:02:45.025]                     invisible(muffled)
[11:02:45.025]                   }
[11:02:45.025]                   muffleCondition(cond)
[11:02:45.025]                 })
[11:02:45.025]             }))
[11:02:45.025]             future::FutureResult(value = ...future.value$value, 
[11:02:45.025]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:45.025]                   ...future.rng), globalenv = if (FALSE) 
[11:02:45.025]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:45.025]                     ...future.globalenv.names))
[11:02:45.025]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:45.025]         }, condition = base::local({
[11:02:45.025]             c <- base::c
[11:02:45.025]             inherits <- base::inherits
[11:02:45.025]             invokeRestart <- base::invokeRestart
[11:02:45.025]             length <- base::length
[11:02:45.025]             list <- base::list
[11:02:45.025]             seq.int <- base::seq.int
[11:02:45.025]             signalCondition <- base::signalCondition
[11:02:45.025]             sys.calls <- base::sys.calls
[11:02:45.025]             `[[` <- base::`[[`
[11:02:45.025]             `+` <- base::`+`
[11:02:45.025]             `<<-` <- base::`<<-`
[11:02:45.025]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:45.025]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:45.025]                   3L)]
[11:02:45.025]             }
[11:02:45.025]             function(cond) {
[11:02:45.025]                 is_error <- inherits(cond, "error")
[11:02:45.025]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:45.025]                   NULL)
[11:02:45.025]                 if (is_error) {
[11:02:45.025]                   sessionInformation <- function() {
[11:02:45.025]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:45.025]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:45.025]                       search = base::search(), system = base::Sys.info())
[11:02:45.025]                   }
[11:02:45.025]                   ...future.conditions[[length(...future.conditions) + 
[11:02:45.025]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:45.025]                     cond$call), session = sessionInformation(), 
[11:02:45.025]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:45.025]                   signalCondition(cond)
[11:02:45.025]                 }
[11:02:45.025]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:45.025]                 "immediateCondition"))) {
[11:02:45.025]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:45.025]                   ...future.conditions[[length(...future.conditions) + 
[11:02:45.025]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:45.025]                   if (TRUE && !signal) {
[11:02:45.025]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:45.025]                     {
[11:02:45.025]                       inherits <- base::inherits
[11:02:45.025]                       invokeRestart <- base::invokeRestart
[11:02:45.025]                       is.null <- base::is.null
[11:02:45.025]                       muffled <- FALSE
[11:02:45.025]                       if (inherits(cond, "message")) {
[11:02:45.025]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:45.025]                         if (muffled) 
[11:02:45.025]                           invokeRestart("muffleMessage")
[11:02:45.025]                       }
[11:02:45.025]                       else if (inherits(cond, "warning")) {
[11:02:45.025]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:45.025]                         if (muffled) 
[11:02:45.025]                           invokeRestart("muffleWarning")
[11:02:45.025]                       }
[11:02:45.025]                       else if (inherits(cond, "condition")) {
[11:02:45.025]                         if (!is.null(pattern)) {
[11:02:45.025]                           computeRestarts <- base::computeRestarts
[11:02:45.025]                           grepl <- base::grepl
[11:02:45.025]                           restarts <- computeRestarts(cond)
[11:02:45.025]                           for (restart in restarts) {
[11:02:45.025]                             name <- restart$name
[11:02:45.025]                             if (is.null(name)) 
[11:02:45.025]                               next
[11:02:45.025]                             if (!grepl(pattern, name)) 
[11:02:45.025]                               next
[11:02:45.025]                             invokeRestart(restart)
[11:02:45.025]                             muffled <- TRUE
[11:02:45.025]                             break
[11:02:45.025]                           }
[11:02:45.025]                         }
[11:02:45.025]                       }
[11:02:45.025]                       invisible(muffled)
[11:02:45.025]                     }
[11:02:45.025]                     muffleCondition(cond, pattern = "^muffle")
[11:02:45.025]                   }
[11:02:45.025]                 }
[11:02:45.025]                 else {
[11:02:45.025]                   if (TRUE) {
[11:02:45.025]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:45.025]                     {
[11:02:45.025]                       inherits <- base::inherits
[11:02:45.025]                       invokeRestart <- base::invokeRestart
[11:02:45.025]                       is.null <- base::is.null
[11:02:45.025]                       muffled <- FALSE
[11:02:45.025]                       if (inherits(cond, "message")) {
[11:02:45.025]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:45.025]                         if (muffled) 
[11:02:45.025]                           invokeRestart("muffleMessage")
[11:02:45.025]                       }
[11:02:45.025]                       else if (inherits(cond, "warning")) {
[11:02:45.025]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:45.025]                         if (muffled) 
[11:02:45.025]                           invokeRestart("muffleWarning")
[11:02:45.025]                       }
[11:02:45.025]                       else if (inherits(cond, "condition")) {
[11:02:45.025]                         if (!is.null(pattern)) {
[11:02:45.025]                           computeRestarts <- base::computeRestarts
[11:02:45.025]                           grepl <- base::grepl
[11:02:45.025]                           restarts <- computeRestarts(cond)
[11:02:45.025]                           for (restart in restarts) {
[11:02:45.025]                             name <- restart$name
[11:02:45.025]                             if (is.null(name)) 
[11:02:45.025]                               next
[11:02:45.025]                             if (!grepl(pattern, name)) 
[11:02:45.025]                               next
[11:02:45.025]                             invokeRestart(restart)
[11:02:45.025]                             muffled <- TRUE
[11:02:45.025]                             break
[11:02:45.025]                           }
[11:02:45.025]                         }
[11:02:45.025]                       }
[11:02:45.025]                       invisible(muffled)
[11:02:45.025]                     }
[11:02:45.025]                     muffleCondition(cond, pattern = "^muffle")
[11:02:45.025]                   }
[11:02:45.025]                 }
[11:02:45.025]             }
[11:02:45.025]         }))
[11:02:45.025]     }, error = function(ex) {
[11:02:45.025]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:45.025]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:45.025]                 ...future.rng), started = ...future.startTime, 
[11:02:45.025]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:45.025]             version = "1.8"), class = "FutureResult")
[11:02:45.025]     }, finally = {
[11:02:45.025]         if (!identical(...future.workdir, getwd())) 
[11:02:45.025]             setwd(...future.workdir)
[11:02:45.025]         {
[11:02:45.025]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:45.025]                 ...future.oldOptions$nwarnings <- NULL
[11:02:45.025]             }
[11:02:45.025]             base::options(...future.oldOptions)
[11:02:45.025]             if (.Platform$OS.type == "windows") {
[11:02:45.025]                 old_names <- names(...future.oldEnvVars)
[11:02:45.025]                 envs <- base::Sys.getenv()
[11:02:45.025]                 names <- names(envs)
[11:02:45.025]                 common <- intersect(names, old_names)
[11:02:45.025]                 added <- setdiff(names, old_names)
[11:02:45.025]                 removed <- setdiff(old_names, names)
[11:02:45.025]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:45.025]                   envs[common]]
[11:02:45.025]                 NAMES <- toupper(changed)
[11:02:45.025]                 args <- list()
[11:02:45.025]                 for (kk in seq_along(NAMES)) {
[11:02:45.025]                   name <- changed[[kk]]
[11:02:45.025]                   NAME <- NAMES[[kk]]
[11:02:45.025]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:45.025]                     next
[11:02:45.025]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:45.025]                 }
[11:02:45.025]                 NAMES <- toupper(added)
[11:02:45.025]                 for (kk in seq_along(NAMES)) {
[11:02:45.025]                   name <- added[[kk]]
[11:02:45.025]                   NAME <- NAMES[[kk]]
[11:02:45.025]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:45.025]                     next
[11:02:45.025]                   args[[name]] <- ""
[11:02:45.025]                 }
[11:02:45.025]                 NAMES <- toupper(removed)
[11:02:45.025]                 for (kk in seq_along(NAMES)) {
[11:02:45.025]                   name <- removed[[kk]]
[11:02:45.025]                   NAME <- NAMES[[kk]]
[11:02:45.025]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:45.025]                     next
[11:02:45.025]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:45.025]                 }
[11:02:45.025]                 if (length(args) > 0) 
[11:02:45.025]                   base::do.call(base::Sys.setenv, args = args)
[11:02:45.025]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:45.025]             }
[11:02:45.025]             else {
[11:02:45.025]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:45.025]             }
[11:02:45.025]             {
[11:02:45.025]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:45.025]                   0L) {
[11:02:45.025]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:45.025]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:45.025]                   base::options(opts)
[11:02:45.025]                 }
[11:02:45.025]                 {
[11:02:45.025]                   {
[11:02:45.025]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:45.025]                     NULL
[11:02:45.025]                   }
[11:02:45.025]                   options(future.plan = NULL)
[11:02:45.025]                   if (is.na(NA_character_)) 
[11:02:45.025]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:45.025]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:45.025]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:45.025]                     .init = FALSE)
[11:02:45.025]                 }
[11:02:45.025]             }
[11:02:45.025]         }
[11:02:45.025]     })
[11:02:45.025]     if (TRUE) {
[11:02:45.025]         base::sink(type = "output", split = FALSE)
[11:02:45.025]         if (TRUE) {
[11:02:45.025]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:45.025]         }
[11:02:45.025]         else {
[11:02:45.025]             ...future.result["stdout"] <- base::list(NULL)
[11:02:45.025]         }
[11:02:45.025]         base::close(...future.stdout)
[11:02:45.025]         ...future.stdout <- NULL
[11:02:45.025]     }
[11:02:45.025]     ...future.result$conditions <- ...future.conditions
[11:02:45.025]     ...future.result$finished <- base::Sys.time()
[11:02:45.025]     ...future.result
[11:02:45.025] }
[11:02:45.028] MultisessionFuture started
[11:02:45.028] - Launch lazy future ... done
[11:02:45.028] run() for ‘MultisessionFuture’ ... done
[11:02:45.571] receiveMessageFromWorker() for ClusterFuture ...
[11:02:45.571] - Validating connection of MultisessionFuture
[11:02:45.571] - received message: FutureResult
[11:02:45.572] - Received FutureResult
[11:02:45.572] - Erased future from FutureRegistry
[11:02:45.572] result() for ClusterFuture ...
[11:02:45.572] - result already collected: FutureResult
[11:02:45.572] result() for ClusterFuture ... done
[11:02:45.572] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:45.572] A MultisessionFuture was resolved (result was not collected)
[11:02:45.572] getGlobalsAndPackages() ...
[11:02:45.572] Searching for globals...
[11:02:45.573] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[11:02:45.573] Searching for globals ... DONE
[11:02:45.574] Resolving globals: FALSE
[11:02:45.574] 
[11:02:45.574] 
[11:02:45.574] getGlobalsAndPackages() ... DONE
[11:02:45.574] run() for ‘Future’ ...
[11:02:45.574] - state: ‘created’
[11:02:45.575] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:45.588] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:45.588] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:45.588]   - Field: ‘node’
[11:02:45.588]   - Field: ‘label’
[11:02:45.588]   - Field: ‘local’
[11:02:45.588]   - Field: ‘owner’
[11:02:45.589]   - Field: ‘envir’
[11:02:45.589]   - Field: ‘workers’
[11:02:45.589]   - Field: ‘packages’
[11:02:45.589]   - Field: ‘gc’
[11:02:45.589]   - Field: ‘conditions’
[11:02:45.589]   - Field: ‘persistent’
[11:02:45.589]   - Field: ‘expr’
[11:02:45.589]   - Field: ‘uuid’
[11:02:45.589]   - Field: ‘seed’
[11:02:45.589]   - Field: ‘version’
[11:02:45.589]   - Field: ‘result’
[11:02:45.589]   - Field: ‘asynchronous’
[11:02:45.589]   - Field: ‘calls’
[11:02:45.590]   - Field: ‘globals’
[11:02:45.590]   - Field: ‘stdout’
[11:02:45.590]   - Field: ‘earlySignal’
[11:02:45.590]   - Field: ‘lazy’
[11:02:45.590]   - Field: ‘state’
[11:02:45.590] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:45.590] - Launch lazy future ...
[11:02:45.590] Packages needed by the future expression (n = 0): <none>
[11:02:45.590] Packages needed by future strategies (n = 0): <none>
[11:02:45.591] {
[11:02:45.591]     {
[11:02:45.591]         {
[11:02:45.591]             ...future.startTime <- base::Sys.time()
[11:02:45.591]             {
[11:02:45.591]                 {
[11:02:45.591]                   {
[11:02:45.591]                     {
[11:02:45.591]                       base::local({
[11:02:45.591]                         has_future <- base::requireNamespace("future", 
[11:02:45.591]                           quietly = TRUE)
[11:02:45.591]                         if (has_future) {
[11:02:45.591]                           ns <- base::getNamespace("future")
[11:02:45.591]                           version <- ns[[".package"]][["version"]]
[11:02:45.591]                           if (is.null(version)) 
[11:02:45.591]                             version <- utils::packageVersion("future")
[11:02:45.591]                         }
[11:02:45.591]                         else {
[11:02:45.591]                           version <- NULL
[11:02:45.591]                         }
[11:02:45.591]                         if (!has_future || version < "1.8.0") {
[11:02:45.591]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:45.591]                             "", base::R.version$version.string), 
[11:02:45.591]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:45.591]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:45.591]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:45.591]                               "release", "version")], collapse = " "), 
[11:02:45.591]                             hostname = base::Sys.info()[["nodename"]])
[11:02:45.591]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:45.591]                             info)
[11:02:45.591]                           info <- base::paste(info, collapse = "; ")
[11:02:45.591]                           if (!has_future) {
[11:02:45.591]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:45.591]                               info)
[11:02:45.591]                           }
[11:02:45.591]                           else {
[11:02:45.591]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:45.591]                               info, version)
[11:02:45.591]                           }
[11:02:45.591]                           base::stop(msg)
[11:02:45.591]                         }
[11:02:45.591]                       })
[11:02:45.591]                     }
[11:02:45.591]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:45.591]                     base::options(mc.cores = 1L)
[11:02:45.591]                   }
[11:02:45.591]                   ...future.strategy.old <- future::plan("list")
[11:02:45.591]                   options(future.plan = NULL)
[11:02:45.591]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:45.591]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:45.591]                 }
[11:02:45.591]                 ...future.workdir <- getwd()
[11:02:45.591]             }
[11:02:45.591]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:45.591]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:45.591]         }
[11:02:45.591]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:45.591]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:45.591]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:45.591]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:45.591]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:45.591]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:45.591]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:45.591]             base::names(...future.oldOptions))
[11:02:45.591]     }
[11:02:45.591]     if (FALSE) {
[11:02:45.591]     }
[11:02:45.591]     else {
[11:02:45.591]         if (TRUE) {
[11:02:45.591]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:45.591]                 open = "w")
[11:02:45.591]         }
[11:02:45.591]         else {
[11:02:45.591]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:45.591]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:45.591]         }
[11:02:45.591]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:45.591]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:45.591]             base::sink(type = "output", split = FALSE)
[11:02:45.591]             base::close(...future.stdout)
[11:02:45.591]         }, add = TRUE)
[11:02:45.591]     }
[11:02:45.591]     ...future.frame <- base::sys.nframe()
[11:02:45.591]     ...future.conditions <- base::list()
[11:02:45.591]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:45.591]     if (FALSE) {
[11:02:45.591]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:45.591]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:45.591]     }
[11:02:45.591]     ...future.result <- base::tryCatch({
[11:02:45.591]         base::withCallingHandlers({
[11:02:45.591]             ...future.value <- base::withVisible(base::local({
[11:02:45.591]                 ...future.makeSendCondition <- base::local({
[11:02:45.591]                   sendCondition <- NULL
[11:02:45.591]                   function(frame = 1L) {
[11:02:45.591]                     if (is.function(sendCondition)) 
[11:02:45.591]                       return(sendCondition)
[11:02:45.591]                     ns <- getNamespace("parallel")
[11:02:45.591]                     if (exists("sendData", mode = "function", 
[11:02:45.591]                       envir = ns)) {
[11:02:45.591]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:45.591]                         envir = ns)
[11:02:45.591]                       envir <- sys.frame(frame)
[11:02:45.591]                       master <- NULL
[11:02:45.591]                       while (!identical(envir, .GlobalEnv) && 
[11:02:45.591]                         !identical(envir, emptyenv())) {
[11:02:45.591]                         if (exists("master", mode = "list", envir = envir, 
[11:02:45.591]                           inherits = FALSE)) {
[11:02:45.591]                           master <- get("master", mode = "list", 
[11:02:45.591]                             envir = envir, inherits = FALSE)
[11:02:45.591]                           if (inherits(master, c("SOCKnode", 
[11:02:45.591]                             "SOCK0node"))) {
[11:02:45.591]                             sendCondition <<- function(cond) {
[11:02:45.591]                               data <- list(type = "VALUE", value = cond, 
[11:02:45.591]                                 success = TRUE)
[11:02:45.591]                               parallel_sendData(master, data)
[11:02:45.591]                             }
[11:02:45.591]                             return(sendCondition)
[11:02:45.591]                           }
[11:02:45.591]                         }
[11:02:45.591]                         frame <- frame + 1L
[11:02:45.591]                         envir <- sys.frame(frame)
[11:02:45.591]                       }
[11:02:45.591]                     }
[11:02:45.591]                     sendCondition <<- function(cond) NULL
[11:02:45.591]                   }
[11:02:45.591]                 })
[11:02:45.591]                 withCallingHandlers({
[11:02:45.591]                   {
[11:02:45.591]                     Sys.sleep(0.5)
[11:02:45.591]                     list(a = 1, b = 42L)
[11:02:45.591]                   }
[11:02:45.591]                 }, immediateCondition = function(cond) {
[11:02:45.591]                   sendCondition <- ...future.makeSendCondition()
[11:02:45.591]                   sendCondition(cond)
[11:02:45.591]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:45.591]                   {
[11:02:45.591]                     inherits <- base::inherits
[11:02:45.591]                     invokeRestart <- base::invokeRestart
[11:02:45.591]                     is.null <- base::is.null
[11:02:45.591]                     muffled <- FALSE
[11:02:45.591]                     if (inherits(cond, "message")) {
[11:02:45.591]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:45.591]                       if (muffled) 
[11:02:45.591]                         invokeRestart("muffleMessage")
[11:02:45.591]                     }
[11:02:45.591]                     else if (inherits(cond, "warning")) {
[11:02:45.591]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:45.591]                       if (muffled) 
[11:02:45.591]                         invokeRestart("muffleWarning")
[11:02:45.591]                     }
[11:02:45.591]                     else if (inherits(cond, "condition")) {
[11:02:45.591]                       if (!is.null(pattern)) {
[11:02:45.591]                         computeRestarts <- base::computeRestarts
[11:02:45.591]                         grepl <- base::grepl
[11:02:45.591]                         restarts <- computeRestarts(cond)
[11:02:45.591]                         for (restart in restarts) {
[11:02:45.591]                           name <- restart$name
[11:02:45.591]                           if (is.null(name)) 
[11:02:45.591]                             next
[11:02:45.591]                           if (!grepl(pattern, name)) 
[11:02:45.591]                             next
[11:02:45.591]                           invokeRestart(restart)
[11:02:45.591]                           muffled <- TRUE
[11:02:45.591]                           break
[11:02:45.591]                         }
[11:02:45.591]                       }
[11:02:45.591]                     }
[11:02:45.591]                     invisible(muffled)
[11:02:45.591]                   }
[11:02:45.591]                   muffleCondition(cond)
[11:02:45.591]                 })
[11:02:45.591]             }))
[11:02:45.591]             future::FutureResult(value = ...future.value$value, 
[11:02:45.591]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:45.591]                   ...future.rng), globalenv = if (FALSE) 
[11:02:45.591]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:45.591]                     ...future.globalenv.names))
[11:02:45.591]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:45.591]         }, condition = base::local({
[11:02:45.591]             c <- base::c
[11:02:45.591]             inherits <- base::inherits
[11:02:45.591]             invokeRestart <- base::invokeRestart
[11:02:45.591]             length <- base::length
[11:02:45.591]             list <- base::list
[11:02:45.591]             seq.int <- base::seq.int
[11:02:45.591]             signalCondition <- base::signalCondition
[11:02:45.591]             sys.calls <- base::sys.calls
[11:02:45.591]             `[[` <- base::`[[`
[11:02:45.591]             `+` <- base::`+`
[11:02:45.591]             `<<-` <- base::`<<-`
[11:02:45.591]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:45.591]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:45.591]                   3L)]
[11:02:45.591]             }
[11:02:45.591]             function(cond) {
[11:02:45.591]                 is_error <- inherits(cond, "error")
[11:02:45.591]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:45.591]                   NULL)
[11:02:45.591]                 if (is_error) {
[11:02:45.591]                   sessionInformation <- function() {
[11:02:45.591]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:45.591]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:45.591]                       search = base::search(), system = base::Sys.info())
[11:02:45.591]                   }
[11:02:45.591]                   ...future.conditions[[length(...future.conditions) + 
[11:02:45.591]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:45.591]                     cond$call), session = sessionInformation(), 
[11:02:45.591]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:45.591]                   signalCondition(cond)
[11:02:45.591]                 }
[11:02:45.591]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:45.591]                 "immediateCondition"))) {
[11:02:45.591]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:45.591]                   ...future.conditions[[length(...future.conditions) + 
[11:02:45.591]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:45.591]                   if (TRUE && !signal) {
[11:02:45.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:45.591]                     {
[11:02:45.591]                       inherits <- base::inherits
[11:02:45.591]                       invokeRestart <- base::invokeRestart
[11:02:45.591]                       is.null <- base::is.null
[11:02:45.591]                       muffled <- FALSE
[11:02:45.591]                       if (inherits(cond, "message")) {
[11:02:45.591]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:45.591]                         if (muffled) 
[11:02:45.591]                           invokeRestart("muffleMessage")
[11:02:45.591]                       }
[11:02:45.591]                       else if (inherits(cond, "warning")) {
[11:02:45.591]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:45.591]                         if (muffled) 
[11:02:45.591]                           invokeRestart("muffleWarning")
[11:02:45.591]                       }
[11:02:45.591]                       else if (inherits(cond, "condition")) {
[11:02:45.591]                         if (!is.null(pattern)) {
[11:02:45.591]                           computeRestarts <- base::computeRestarts
[11:02:45.591]                           grepl <- base::grepl
[11:02:45.591]                           restarts <- computeRestarts(cond)
[11:02:45.591]                           for (restart in restarts) {
[11:02:45.591]                             name <- restart$name
[11:02:45.591]                             if (is.null(name)) 
[11:02:45.591]                               next
[11:02:45.591]                             if (!grepl(pattern, name)) 
[11:02:45.591]                               next
[11:02:45.591]                             invokeRestart(restart)
[11:02:45.591]                             muffled <- TRUE
[11:02:45.591]                             break
[11:02:45.591]                           }
[11:02:45.591]                         }
[11:02:45.591]                       }
[11:02:45.591]                       invisible(muffled)
[11:02:45.591]                     }
[11:02:45.591]                     muffleCondition(cond, pattern = "^muffle")
[11:02:45.591]                   }
[11:02:45.591]                 }
[11:02:45.591]                 else {
[11:02:45.591]                   if (TRUE) {
[11:02:45.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:45.591]                     {
[11:02:45.591]                       inherits <- base::inherits
[11:02:45.591]                       invokeRestart <- base::invokeRestart
[11:02:45.591]                       is.null <- base::is.null
[11:02:45.591]                       muffled <- FALSE
[11:02:45.591]                       if (inherits(cond, "message")) {
[11:02:45.591]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:45.591]                         if (muffled) 
[11:02:45.591]                           invokeRestart("muffleMessage")
[11:02:45.591]                       }
[11:02:45.591]                       else if (inherits(cond, "warning")) {
[11:02:45.591]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:45.591]                         if (muffled) 
[11:02:45.591]                           invokeRestart("muffleWarning")
[11:02:45.591]                       }
[11:02:45.591]                       else if (inherits(cond, "condition")) {
[11:02:45.591]                         if (!is.null(pattern)) {
[11:02:45.591]                           computeRestarts <- base::computeRestarts
[11:02:45.591]                           grepl <- base::grepl
[11:02:45.591]                           restarts <- computeRestarts(cond)
[11:02:45.591]                           for (restart in restarts) {
[11:02:45.591]                             name <- restart$name
[11:02:45.591]                             if (is.null(name)) 
[11:02:45.591]                               next
[11:02:45.591]                             if (!grepl(pattern, name)) 
[11:02:45.591]                               next
[11:02:45.591]                             invokeRestart(restart)
[11:02:45.591]                             muffled <- TRUE
[11:02:45.591]                             break
[11:02:45.591]                           }
[11:02:45.591]                         }
[11:02:45.591]                       }
[11:02:45.591]                       invisible(muffled)
[11:02:45.591]                     }
[11:02:45.591]                     muffleCondition(cond, pattern = "^muffle")
[11:02:45.591]                   }
[11:02:45.591]                 }
[11:02:45.591]             }
[11:02:45.591]         }))
[11:02:45.591]     }, error = function(ex) {
[11:02:45.591]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:45.591]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:45.591]                 ...future.rng), started = ...future.startTime, 
[11:02:45.591]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:45.591]             version = "1.8"), class = "FutureResult")
[11:02:45.591]     }, finally = {
[11:02:45.591]         if (!identical(...future.workdir, getwd())) 
[11:02:45.591]             setwd(...future.workdir)
[11:02:45.591]         {
[11:02:45.591]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:45.591]                 ...future.oldOptions$nwarnings <- NULL
[11:02:45.591]             }
[11:02:45.591]             base::options(...future.oldOptions)
[11:02:45.591]             if (.Platform$OS.type == "windows") {
[11:02:45.591]                 old_names <- names(...future.oldEnvVars)
[11:02:45.591]                 envs <- base::Sys.getenv()
[11:02:45.591]                 names <- names(envs)
[11:02:45.591]                 common <- intersect(names, old_names)
[11:02:45.591]                 added <- setdiff(names, old_names)
[11:02:45.591]                 removed <- setdiff(old_names, names)
[11:02:45.591]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:45.591]                   envs[common]]
[11:02:45.591]                 NAMES <- toupper(changed)
[11:02:45.591]                 args <- list()
[11:02:45.591]                 for (kk in seq_along(NAMES)) {
[11:02:45.591]                   name <- changed[[kk]]
[11:02:45.591]                   NAME <- NAMES[[kk]]
[11:02:45.591]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:45.591]                     next
[11:02:45.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:45.591]                 }
[11:02:45.591]                 NAMES <- toupper(added)
[11:02:45.591]                 for (kk in seq_along(NAMES)) {
[11:02:45.591]                   name <- added[[kk]]
[11:02:45.591]                   NAME <- NAMES[[kk]]
[11:02:45.591]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:45.591]                     next
[11:02:45.591]                   args[[name]] <- ""
[11:02:45.591]                 }
[11:02:45.591]                 NAMES <- toupper(removed)
[11:02:45.591]                 for (kk in seq_along(NAMES)) {
[11:02:45.591]                   name <- removed[[kk]]
[11:02:45.591]                   NAME <- NAMES[[kk]]
[11:02:45.591]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:45.591]                     next
[11:02:45.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:45.591]                 }
[11:02:45.591]                 if (length(args) > 0) 
[11:02:45.591]                   base::do.call(base::Sys.setenv, args = args)
[11:02:45.591]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:45.591]             }
[11:02:45.591]             else {
[11:02:45.591]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:45.591]             }
[11:02:45.591]             {
[11:02:45.591]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:45.591]                   0L) {
[11:02:45.591]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:45.591]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:45.591]                   base::options(opts)
[11:02:45.591]                 }
[11:02:45.591]                 {
[11:02:45.591]                   {
[11:02:45.591]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:45.591]                     NULL
[11:02:45.591]                   }
[11:02:45.591]                   options(future.plan = NULL)
[11:02:45.591]                   if (is.na(NA_character_)) 
[11:02:45.591]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:45.591]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:45.591]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:45.591]                     .init = FALSE)
[11:02:45.591]                 }
[11:02:45.591]             }
[11:02:45.591]         }
[11:02:45.591]     })
[11:02:45.591]     if (TRUE) {
[11:02:45.591]         base::sink(type = "output", split = FALSE)
[11:02:45.591]         if (TRUE) {
[11:02:45.591]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:45.591]         }
[11:02:45.591]         else {
[11:02:45.591]             ...future.result["stdout"] <- base::list(NULL)
[11:02:45.591]         }
[11:02:45.591]         base::close(...future.stdout)
[11:02:45.591]         ...future.stdout <- NULL
[11:02:45.591]     }
[11:02:45.591]     ...future.result$conditions <- ...future.conditions
[11:02:45.591]     ...future.result$finished <- base::Sys.time()
[11:02:45.591]     ...future.result
[11:02:45.591] }
[11:02:45.594] MultisessionFuture started
[11:02:45.594] - Launch lazy future ... done
[11:02:45.594] run() for ‘MultisessionFuture’ ... done
[11:02:46.137] receiveMessageFromWorker() for ClusterFuture ...
[11:02:46.137] - Validating connection of MultisessionFuture
[11:02:46.137] - received message: FutureResult
[11:02:46.137] - Received FutureResult
[11:02:46.137] - Erased future from FutureRegistry
[11:02:46.138] result() for ClusterFuture ...
[11:02:46.138] - result already collected: FutureResult
[11:02:46.138] result() for ClusterFuture ... done
[11:02:46.138] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:46.138] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[11:02:46.138] getGlobalsAndPackages() ...
[11:02:46.138] Searching for globals...
[11:02:46.139] - globals found: [2] ‘list’, ‘stop’
[11:02:46.139] Searching for globals ... DONE
[11:02:46.139] Resolving globals: FALSE
[11:02:46.139] 
[11:02:46.139] 
[11:02:46.140] getGlobalsAndPackages() ... DONE
[11:02:46.140] run() for ‘Future’ ...
[11:02:46.140] - state: ‘created’
[11:02:46.140] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:46.154] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:46.154] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:46.154]   - Field: ‘node’
[11:02:46.154]   - Field: ‘label’
[11:02:46.154]   - Field: ‘local’
[11:02:46.154]   - Field: ‘owner’
[11:02:46.154]   - Field: ‘envir’
[11:02:46.154]   - Field: ‘workers’
[11:02:46.154]   - Field: ‘packages’
[11:02:46.155]   - Field: ‘gc’
[11:02:46.155]   - Field: ‘conditions’
[11:02:46.155]   - Field: ‘persistent’
[11:02:46.155]   - Field: ‘expr’
[11:02:46.155]   - Field: ‘uuid’
[11:02:46.155]   - Field: ‘seed’
[11:02:46.155]   - Field: ‘version’
[11:02:46.155]   - Field: ‘result’
[11:02:46.155]   - Field: ‘asynchronous’
[11:02:46.155]   - Field: ‘calls’
[11:02:46.155]   - Field: ‘globals’
[11:02:46.155]   - Field: ‘stdout’
[11:02:46.156]   - Field: ‘earlySignal’
[11:02:46.156]   - Field: ‘lazy’
[11:02:46.156]   - Field: ‘state’
[11:02:46.156] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:46.156] - Launch lazy future ...
[11:02:46.156] Packages needed by the future expression (n = 0): <none>
[11:02:46.156] Packages needed by future strategies (n = 0): <none>
[11:02:46.157] {
[11:02:46.157]     {
[11:02:46.157]         {
[11:02:46.157]             ...future.startTime <- base::Sys.time()
[11:02:46.157]             {
[11:02:46.157]                 {
[11:02:46.157]                   {
[11:02:46.157]                     {
[11:02:46.157]                       base::local({
[11:02:46.157]                         has_future <- base::requireNamespace("future", 
[11:02:46.157]                           quietly = TRUE)
[11:02:46.157]                         if (has_future) {
[11:02:46.157]                           ns <- base::getNamespace("future")
[11:02:46.157]                           version <- ns[[".package"]][["version"]]
[11:02:46.157]                           if (is.null(version)) 
[11:02:46.157]                             version <- utils::packageVersion("future")
[11:02:46.157]                         }
[11:02:46.157]                         else {
[11:02:46.157]                           version <- NULL
[11:02:46.157]                         }
[11:02:46.157]                         if (!has_future || version < "1.8.0") {
[11:02:46.157]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:46.157]                             "", base::R.version$version.string), 
[11:02:46.157]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:46.157]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:46.157]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:46.157]                               "release", "version")], collapse = " "), 
[11:02:46.157]                             hostname = base::Sys.info()[["nodename"]])
[11:02:46.157]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:46.157]                             info)
[11:02:46.157]                           info <- base::paste(info, collapse = "; ")
[11:02:46.157]                           if (!has_future) {
[11:02:46.157]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:46.157]                               info)
[11:02:46.157]                           }
[11:02:46.157]                           else {
[11:02:46.157]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:46.157]                               info, version)
[11:02:46.157]                           }
[11:02:46.157]                           base::stop(msg)
[11:02:46.157]                         }
[11:02:46.157]                       })
[11:02:46.157]                     }
[11:02:46.157]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:46.157]                     base::options(mc.cores = 1L)
[11:02:46.157]                   }
[11:02:46.157]                   ...future.strategy.old <- future::plan("list")
[11:02:46.157]                   options(future.plan = NULL)
[11:02:46.157]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:46.157]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:46.157]                 }
[11:02:46.157]                 ...future.workdir <- getwd()
[11:02:46.157]             }
[11:02:46.157]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:46.157]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:46.157]         }
[11:02:46.157]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:46.157]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:46.157]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:46.157]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:46.157]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:46.157]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:46.157]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:46.157]             base::names(...future.oldOptions))
[11:02:46.157]     }
[11:02:46.157]     if (FALSE) {
[11:02:46.157]     }
[11:02:46.157]     else {
[11:02:46.157]         if (TRUE) {
[11:02:46.157]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:46.157]                 open = "w")
[11:02:46.157]         }
[11:02:46.157]         else {
[11:02:46.157]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:46.157]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:46.157]         }
[11:02:46.157]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:46.157]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:46.157]             base::sink(type = "output", split = FALSE)
[11:02:46.157]             base::close(...future.stdout)
[11:02:46.157]         }, add = TRUE)
[11:02:46.157]     }
[11:02:46.157]     ...future.frame <- base::sys.nframe()
[11:02:46.157]     ...future.conditions <- base::list()
[11:02:46.157]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:46.157]     if (FALSE) {
[11:02:46.157]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:46.157]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:46.157]     }
[11:02:46.157]     ...future.result <- base::tryCatch({
[11:02:46.157]         base::withCallingHandlers({
[11:02:46.157]             ...future.value <- base::withVisible(base::local({
[11:02:46.157]                 ...future.makeSendCondition <- base::local({
[11:02:46.157]                   sendCondition <- NULL
[11:02:46.157]                   function(frame = 1L) {
[11:02:46.157]                     if (is.function(sendCondition)) 
[11:02:46.157]                       return(sendCondition)
[11:02:46.157]                     ns <- getNamespace("parallel")
[11:02:46.157]                     if (exists("sendData", mode = "function", 
[11:02:46.157]                       envir = ns)) {
[11:02:46.157]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:46.157]                         envir = ns)
[11:02:46.157]                       envir <- sys.frame(frame)
[11:02:46.157]                       master <- NULL
[11:02:46.157]                       while (!identical(envir, .GlobalEnv) && 
[11:02:46.157]                         !identical(envir, emptyenv())) {
[11:02:46.157]                         if (exists("master", mode = "list", envir = envir, 
[11:02:46.157]                           inherits = FALSE)) {
[11:02:46.157]                           master <- get("master", mode = "list", 
[11:02:46.157]                             envir = envir, inherits = FALSE)
[11:02:46.157]                           if (inherits(master, c("SOCKnode", 
[11:02:46.157]                             "SOCK0node"))) {
[11:02:46.157]                             sendCondition <<- function(cond) {
[11:02:46.157]                               data <- list(type = "VALUE", value = cond, 
[11:02:46.157]                                 success = TRUE)
[11:02:46.157]                               parallel_sendData(master, data)
[11:02:46.157]                             }
[11:02:46.157]                             return(sendCondition)
[11:02:46.157]                           }
[11:02:46.157]                         }
[11:02:46.157]                         frame <- frame + 1L
[11:02:46.157]                         envir <- sys.frame(frame)
[11:02:46.157]                       }
[11:02:46.157]                     }
[11:02:46.157]                     sendCondition <<- function(cond) NULL
[11:02:46.157]                   }
[11:02:46.157]                 })
[11:02:46.157]                 withCallingHandlers({
[11:02:46.157]                   list(a = 1, b = 42L, c = stop("Nah!"))
[11:02:46.157]                 }, immediateCondition = function(cond) {
[11:02:46.157]                   sendCondition <- ...future.makeSendCondition()
[11:02:46.157]                   sendCondition(cond)
[11:02:46.157]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:46.157]                   {
[11:02:46.157]                     inherits <- base::inherits
[11:02:46.157]                     invokeRestart <- base::invokeRestart
[11:02:46.157]                     is.null <- base::is.null
[11:02:46.157]                     muffled <- FALSE
[11:02:46.157]                     if (inherits(cond, "message")) {
[11:02:46.157]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:46.157]                       if (muffled) 
[11:02:46.157]                         invokeRestart("muffleMessage")
[11:02:46.157]                     }
[11:02:46.157]                     else if (inherits(cond, "warning")) {
[11:02:46.157]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:46.157]                       if (muffled) 
[11:02:46.157]                         invokeRestart("muffleWarning")
[11:02:46.157]                     }
[11:02:46.157]                     else if (inherits(cond, "condition")) {
[11:02:46.157]                       if (!is.null(pattern)) {
[11:02:46.157]                         computeRestarts <- base::computeRestarts
[11:02:46.157]                         grepl <- base::grepl
[11:02:46.157]                         restarts <- computeRestarts(cond)
[11:02:46.157]                         for (restart in restarts) {
[11:02:46.157]                           name <- restart$name
[11:02:46.157]                           if (is.null(name)) 
[11:02:46.157]                             next
[11:02:46.157]                           if (!grepl(pattern, name)) 
[11:02:46.157]                             next
[11:02:46.157]                           invokeRestart(restart)
[11:02:46.157]                           muffled <- TRUE
[11:02:46.157]                           break
[11:02:46.157]                         }
[11:02:46.157]                       }
[11:02:46.157]                     }
[11:02:46.157]                     invisible(muffled)
[11:02:46.157]                   }
[11:02:46.157]                   muffleCondition(cond)
[11:02:46.157]                 })
[11:02:46.157]             }))
[11:02:46.157]             future::FutureResult(value = ...future.value$value, 
[11:02:46.157]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:46.157]                   ...future.rng), globalenv = if (FALSE) 
[11:02:46.157]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:46.157]                     ...future.globalenv.names))
[11:02:46.157]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:46.157]         }, condition = base::local({
[11:02:46.157]             c <- base::c
[11:02:46.157]             inherits <- base::inherits
[11:02:46.157]             invokeRestart <- base::invokeRestart
[11:02:46.157]             length <- base::length
[11:02:46.157]             list <- base::list
[11:02:46.157]             seq.int <- base::seq.int
[11:02:46.157]             signalCondition <- base::signalCondition
[11:02:46.157]             sys.calls <- base::sys.calls
[11:02:46.157]             `[[` <- base::`[[`
[11:02:46.157]             `+` <- base::`+`
[11:02:46.157]             `<<-` <- base::`<<-`
[11:02:46.157]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:46.157]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:46.157]                   3L)]
[11:02:46.157]             }
[11:02:46.157]             function(cond) {
[11:02:46.157]                 is_error <- inherits(cond, "error")
[11:02:46.157]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:46.157]                   NULL)
[11:02:46.157]                 if (is_error) {
[11:02:46.157]                   sessionInformation <- function() {
[11:02:46.157]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:46.157]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:46.157]                       search = base::search(), system = base::Sys.info())
[11:02:46.157]                   }
[11:02:46.157]                   ...future.conditions[[length(...future.conditions) + 
[11:02:46.157]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:46.157]                     cond$call), session = sessionInformation(), 
[11:02:46.157]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:46.157]                   signalCondition(cond)
[11:02:46.157]                 }
[11:02:46.157]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:46.157]                 "immediateCondition"))) {
[11:02:46.157]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:46.157]                   ...future.conditions[[length(...future.conditions) + 
[11:02:46.157]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:46.157]                   if (TRUE && !signal) {
[11:02:46.157]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:46.157]                     {
[11:02:46.157]                       inherits <- base::inherits
[11:02:46.157]                       invokeRestart <- base::invokeRestart
[11:02:46.157]                       is.null <- base::is.null
[11:02:46.157]                       muffled <- FALSE
[11:02:46.157]                       if (inherits(cond, "message")) {
[11:02:46.157]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:46.157]                         if (muffled) 
[11:02:46.157]                           invokeRestart("muffleMessage")
[11:02:46.157]                       }
[11:02:46.157]                       else if (inherits(cond, "warning")) {
[11:02:46.157]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:46.157]                         if (muffled) 
[11:02:46.157]                           invokeRestart("muffleWarning")
[11:02:46.157]                       }
[11:02:46.157]                       else if (inherits(cond, "condition")) {
[11:02:46.157]                         if (!is.null(pattern)) {
[11:02:46.157]                           computeRestarts <- base::computeRestarts
[11:02:46.157]                           grepl <- base::grepl
[11:02:46.157]                           restarts <- computeRestarts(cond)
[11:02:46.157]                           for (restart in restarts) {
[11:02:46.157]                             name <- restart$name
[11:02:46.157]                             if (is.null(name)) 
[11:02:46.157]                               next
[11:02:46.157]                             if (!grepl(pattern, name)) 
[11:02:46.157]                               next
[11:02:46.157]                             invokeRestart(restart)
[11:02:46.157]                             muffled <- TRUE
[11:02:46.157]                             break
[11:02:46.157]                           }
[11:02:46.157]                         }
[11:02:46.157]                       }
[11:02:46.157]                       invisible(muffled)
[11:02:46.157]                     }
[11:02:46.157]                     muffleCondition(cond, pattern = "^muffle")
[11:02:46.157]                   }
[11:02:46.157]                 }
[11:02:46.157]                 else {
[11:02:46.157]                   if (TRUE) {
[11:02:46.157]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:46.157]                     {
[11:02:46.157]                       inherits <- base::inherits
[11:02:46.157]                       invokeRestart <- base::invokeRestart
[11:02:46.157]                       is.null <- base::is.null
[11:02:46.157]                       muffled <- FALSE
[11:02:46.157]                       if (inherits(cond, "message")) {
[11:02:46.157]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:46.157]                         if (muffled) 
[11:02:46.157]                           invokeRestart("muffleMessage")
[11:02:46.157]                       }
[11:02:46.157]                       else if (inherits(cond, "warning")) {
[11:02:46.157]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:46.157]                         if (muffled) 
[11:02:46.157]                           invokeRestart("muffleWarning")
[11:02:46.157]                       }
[11:02:46.157]                       else if (inherits(cond, "condition")) {
[11:02:46.157]                         if (!is.null(pattern)) {
[11:02:46.157]                           computeRestarts <- base::computeRestarts
[11:02:46.157]                           grepl <- base::grepl
[11:02:46.157]                           restarts <- computeRestarts(cond)
[11:02:46.157]                           for (restart in restarts) {
[11:02:46.157]                             name <- restart$name
[11:02:46.157]                             if (is.null(name)) 
[11:02:46.157]                               next
[11:02:46.157]                             if (!grepl(pattern, name)) 
[11:02:46.157]                               next
[11:02:46.157]                             invokeRestart(restart)
[11:02:46.157]                             muffled <- TRUE
[11:02:46.157]                             break
[11:02:46.157]                           }
[11:02:46.157]                         }
[11:02:46.157]                       }
[11:02:46.157]                       invisible(muffled)
[11:02:46.157]                     }
[11:02:46.157]                     muffleCondition(cond, pattern = "^muffle")
[11:02:46.157]                   }
[11:02:46.157]                 }
[11:02:46.157]             }
[11:02:46.157]         }))
[11:02:46.157]     }, error = function(ex) {
[11:02:46.157]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:46.157]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:46.157]                 ...future.rng), started = ...future.startTime, 
[11:02:46.157]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:46.157]             version = "1.8"), class = "FutureResult")
[11:02:46.157]     }, finally = {
[11:02:46.157]         if (!identical(...future.workdir, getwd())) 
[11:02:46.157]             setwd(...future.workdir)
[11:02:46.157]         {
[11:02:46.157]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:46.157]                 ...future.oldOptions$nwarnings <- NULL
[11:02:46.157]             }
[11:02:46.157]             base::options(...future.oldOptions)
[11:02:46.157]             if (.Platform$OS.type == "windows") {
[11:02:46.157]                 old_names <- names(...future.oldEnvVars)
[11:02:46.157]                 envs <- base::Sys.getenv()
[11:02:46.157]                 names <- names(envs)
[11:02:46.157]                 common <- intersect(names, old_names)
[11:02:46.157]                 added <- setdiff(names, old_names)
[11:02:46.157]                 removed <- setdiff(old_names, names)
[11:02:46.157]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:46.157]                   envs[common]]
[11:02:46.157]                 NAMES <- toupper(changed)
[11:02:46.157]                 args <- list()
[11:02:46.157]                 for (kk in seq_along(NAMES)) {
[11:02:46.157]                   name <- changed[[kk]]
[11:02:46.157]                   NAME <- NAMES[[kk]]
[11:02:46.157]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:46.157]                     next
[11:02:46.157]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:46.157]                 }
[11:02:46.157]                 NAMES <- toupper(added)
[11:02:46.157]                 for (kk in seq_along(NAMES)) {
[11:02:46.157]                   name <- added[[kk]]
[11:02:46.157]                   NAME <- NAMES[[kk]]
[11:02:46.157]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:46.157]                     next
[11:02:46.157]                   args[[name]] <- ""
[11:02:46.157]                 }
[11:02:46.157]                 NAMES <- toupper(removed)
[11:02:46.157]                 for (kk in seq_along(NAMES)) {
[11:02:46.157]                   name <- removed[[kk]]
[11:02:46.157]                   NAME <- NAMES[[kk]]
[11:02:46.157]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:46.157]                     next
[11:02:46.157]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:46.157]                 }
[11:02:46.157]                 if (length(args) > 0) 
[11:02:46.157]                   base::do.call(base::Sys.setenv, args = args)
[11:02:46.157]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:46.157]             }
[11:02:46.157]             else {
[11:02:46.157]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:46.157]             }
[11:02:46.157]             {
[11:02:46.157]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:46.157]                   0L) {
[11:02:46.157]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:46.157]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:46.157]                   base::options(opts)
[11:02:46.157]                 }
[11:02:46.157]                 {
[11:02:46.157]                   {
[11:02:46.157]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:46.157]                     NULL
[11:02:46.157]                   }
[11:02:46.157]                   options(future.plan = NULL)
[11:02:46.157]                   if (is.na(NA_character_)) 
[11:02:46.157]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:46.157]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:46.157]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:46.157]                     .init = FALSE)
[11:02:46.157]                 }
[11:02:46.157]             }
[11:02:46.157]         }
[11:02:46.157]     })
[11:02:46.157]     if (TRUE) {
[11:02:46.157]         base::sink(type = "output", split = FALSE)
[11:02:46.157]         if (TRUE) {
[11:02:46.157]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:46.157]         }
[11:02:46.157]         else {
[11:02:46.157]             ...future.result["stdout"] <- base::list(NULL)
[11:02:46.157]         }
[11:02:46.157]         base::close(...future.stdout)
[11:02:46.157]         ...future.stdout <- NULL
[11:02:46.157]     }
[11:02:46.157]     ...future.result$conditions <- ...future.conditions
[11:02:46.157]     ...future.result$finished <- base::Sys.time()
[11:02:46.157]     ...future.result
[11:02:46.157] }
[11:02:46.160] MultisessionFuture started
[11:02:46.160] - Launch lazy future ... done
[11:02:46.160] run() for ‘MultisessionFuture’ ... done
[11:02:46.201] receiveMessageFromWorker() for ClusterFuture ...
[11:02:46.201] - Validating connection of MultisessionFuture
[11:02:46.202] - received message: FutureResult
[11:02:46.202] - Received FutureResult
[11:02:46.202] - Erased future from FutureRegistry
[11:02:46.202] result() for ClusterFuture ...
[11:02:46.202] - result already collected: FutureResult
[11:02:46.202] result() for ClusterFuture ... done
[11:02:46.202] signalConditions() ...
[11:02:46.202]  - include = ‘immediateCondition’
[11:02:46.203]  - exclude = 
[11:02:46.203]  - resignal = FALSE
[11:02:46.203]  - Number of conditions: 1
[11:02:46.203] signalConditions() ... done
[11:02:46.203] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:46.203] A MultisessionFuture was resolved (result was not collected)
[11:02:46.203] getGlobalsAndPackages() ...
[11:02:46.203] Searching for globals...
[11:02:46.204] - globals found: [2] ‘list’, ‘stop’
[11:02:46.204] Searching for globals ... DONE
[11:02:46.204] Resolving globals: FALSE
[11:02:46.204] 
[11:02:46.204] 
[11:02:46.204] getGlobalsAndPackages() ... DONE
[11:02:46.205] run() for ‘Future’ ...
[11:02:46.205] - state: ‘created’
[11:02:46.205] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:46.218] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:46.219] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:46.219]   - Field: ‘node’
[11:02:46.219]   - Field: ‘label’
[11:02:46.219]   - Field: ‘local’
[11:02:46.219]   - Field: ‘owner’
[11:02:46.219]   - Field: ‘envir’
[11:02:46.219]   - Field: ‘workers’
[11:02:46.219]   - Field: ‘packages’
[11:02:46.219]   - Field: ‘gc’
[11:02:46.219]   - Field: ‘conditions’
[11:02:46.219]   - Field: ‘persistent’
[11:02:46.220]   - Field: ‘expr’
[11:02:46.220]   - Field: ‘uuid’
[11:02:46.220]   - Field: ‘seed’
[11:02:46.220]   - Field: ‘version’
[11:02:46.220]   - Field: ‘result’
[11:02:46.220]   - Field: ‘asynchronous’
[11:02:46.220]   - Field: ‘calls’
[11:02:46.220]   - Field: ‘globals’
[11:02:46.220]   - Field: ‘stdout’
[11:02:46.220]   - Field: ‘earlySignal’
[11:02:46.220]   - Field: ‘lazy’
[11:02:46.220]   - Field: ‘state’
[11:02:46.221] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:46.221] - Launch lazy future ...
[11:02:46.221] Packages needed by the future expression (n = 0): <none>
[11:02:46.221] Packages needed by future strategies (n = 0): <none>
[11:02:46.221] {
[11:02:46.221]     {
[11:02:46.221]         {
[11:02:46.221]             ...future.startTime <- base::Sys.time()
[11:02:46.221]             {
[11:02:46.221]                 {
[11:02:46.221]                   {
[11:02:46.221]                     {
[11:02:46.221]                       base::local({
[11:02:46.221]                         has_future <- base::requireNamespace("future", 
[11:02:46.221]                           quietly = TRUE)
[11:02:46.221]                         if (has_future) {
[11:02:46.221]                           ns <- base::getNamespace("future")
[11:02:46.221]                           version <- ns[[".package"]][["version"]]
[11:02:46.221]                           if (is.null(version)) 
[11:02:46.221]                             version <- utils::packageVersion("future")
[11:02:46.221]                         }
[11:02:46.221]                         else {
[11:02:46.221]                           version <- NULL
[11:02:46.221]                         }
[11:02:46.221]                         if (!has_future || version < "1.8.0") {
[11:02:46.221]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:46.221]                             "", base::R.version$version.string), 
[11:02:46.221]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:46.221]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:46.221]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:46.221]                               "release", "version")], collapse = " "), 
[11:02:46.221]                             hostname = base::Sys.info()[["nodename"]])
[11:02:46.221]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:46.221]                             info)
[11:02:46.221]                           info <- base::paste(info, collapse = "; ")
[11:02:46.221]                           if (!has_future) {
[11:02:46.221]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:46.221]                               info)
[11:02:46.221]                           }
[11:02:46.221]                           else {
[11:02:46.221]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:46.221]                               info, version)
[11:02:46.221]                           }
[11:02:46.221]                           base::stop(msg)
[11:02:46.221]                         }
[11:02:46.221]                       })
[11:02:46.221]                     }
[11:02:46.221]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:46.221]                     base::options(mc.cores = 1L)
[11:02:46.221]                   }
[11:02:46.221]                   ...future.strategy.old <- future::plan("list")
[11:02:46.221]                   options(future.plan = NULL)
[11:02:46.221]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:46.221]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:46.221]                 }
[11:02:46.221]                 ...future.workdir <- getwd()
[11:02:46.221]             }
[11:02:46.221]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:46.221]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:46.221]         }
[11:02:46.221]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:46.221]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:46.221]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:46.221]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:46.221]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:46.221]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:46.221]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:46.221]             base::names(...future.oldOptions))
[11:02:46.221]     }
[11:02:46.221]     if (FALSE) {
[11:02:46.221]     }
[11:02:46.221]     else {
[11:02:46.221]         if (TRUE) {
[11:02:46.221]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:46.221]                 open = "w")
[11:02:46.221]         }
[11:02:46.221]         else {
[11:02:46.221]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:46.221]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:46.221]         }
[11:02:46.221]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:46.221]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:46.221]             base::sink(type = "output", split = FALSE)
[11:02:46.221]             base::close(...future.stdout)
[11:02:46.221]         }, add = TRUE)
[11:02:46.221]     }
[11:02:46.221]     ...future.frame <- base::sys.nframe()
[11:02:46.221]     ...future.conditions <- base::list()
[11:02:46.221]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:46.221]     if (FALSE) {
[11:02:46.221]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:46.221]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:46.221]     }
[11:02:46.221]     ...future.result <- base::tryCatch({
[11:02:46.221]         base::withCallingHandlers({
[11:02:46.221]             ...future.value <- base::withVisible(base::local({
[11:02:46.221]                 ...future.makeSendCondition <- base::local({
[11:02:46.221]                   sendCondition <- NULL
[11:02:46.221]                   function(frame = 1L) {
[11:02:46.221]                     if (is.function(sendCondition)) 
[11:02:46.221]                       return(sendCondition)
[11:02:46.221]                     ns <- getNamespace("parallel")
[11:02:46.221]                     if (exists("sendData", mode = "function", 
[11:02:46.221]                       envir = ns)) {
[11:02:46.221]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:46.221]                         envir = ns)
[11:02:46.221]                       envir <- sys.frame(frame)
[11:02:46.221]                       master <- NULL
[11:02:46.221]                       while (!identical(envir, .GlobalEnv) && 
[11:02:46.221]                         !identical(envir, emptyenv())) {
[11:02:46.221]                         if (exists("master", mode = "list", envir = envir, 
[11:02:46.221]                           inherits = FALSE)) {
[11:02:46.221]                           master <- get("master", mode = "list", 
[11:02:46.221]                             envir = envir, inherits = FALSE)
[11:02:46.221]                           if (inherits(master, c("SOCKnode", 
[11:02:46.221]                             "SOCK0node"))) {
[11:02:46.221]                             sendCondition <<- function(cond) {
[11:02:46.221]                               data <- list(type = "VALUE", value = cond, 
[11:02:46.221]                                 success = TRUE)
[11:02:46.221]                               parallel_sendData(master, data)
[11:02:46.221]                             }
[11:02:46.221]                             return(sendCondition)
[11:02:46.221]                           }
[11:02:46.221]                         }
[11:02:46.221]                         frame <- frame + 1L
[11:02:46.221]                         envir <- sys.frame(frame)
[11:02:46.221]                       }
[11:02:46.221]                     }
[11:02:46.221]                     sendCondition <<- function(cond) NULL
[11:02:46.221]                   }
[11:02:46.221]                 })
[11:02:46.221]                 withCallingHandlers({
[11:02:46.221]                   list(a = 1, b = 42L, c = stop("Nah!"))
[11:02:46.221]                 }, immediateCondition = function(cond) {
[11:02:46.221]                   sendCondition <- ...future.makeSendCondition()
[11:02:46.221]                   sendCondition(cond)
[11:02:46.221]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:46.221]                   {
[11:02:46.221]                     inherits <- base::inherits
[11:02:46.221]                     invokeRestart <- base::invokeRestart
[11:02:46.221]                     is.null <- base::is.null
[11:02:46.221]                     muffled <- FALSE
[11:02:46.221]                     if (inherits(cond, "message")) {
[11:02:46.221]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:46.221]                       if (muffled) 
[11:02:46.221]                         invokeRestart("muffleMessage")
[11:02:46.221]                     }
[11:02:46.221]                     else if (inherits(cond, "warning")) {
[11:02:46.221]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:46.221]                       if (muffled) 
[11:02:46.221]                         invokeRestart("muffleWarning")
[11:02:46.221]                     }
[11:02:46.221]                     else if (inherits(cond, "condition")) {
[11:02:46.221]                       if (!is.null(pattern)) {
[11:02:46.221]                         computeRestarts <- base::computeRestarts
[11:02:46.221]                         grepl <- base::grepl
[11:02:46.221]                         restarts <- computeRestarts(cond)
[11:02:46.221]                         for (restart in restarts) {
[11:02:46.221]                           name <- restart$name
[11:02:46.221]                           if (is.null(name)) 
[11:02:46.221]                             next
[11:02:46.221]                           if (!grepl(pattern, name)) 
[11:02:46.221]                             next
[11:02:46.221]                           invokeRestart(restart)
[11:02:46.221]                           muffled <- TRUE
[11:02:46.221]                           break
[11:02:46.221]                         }
[11:02:46.221]                       }
[11:02:46.221]                     }
[11:02:46.221]                     invisible(muffled)
[11:02:46.221]                   }
[11:02:46.221]                   muffleCondition(cond)
[11:02:46.221]                 })
[11:02:46.221]             }))
[11:02:46.221]             future::FutureResult(value = ...future.value$value, 
[11:02:46.221]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:46.221]                   ...future.rng), globalenv = if (FALSE) 
[11:02:46.221]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:46.221]                     ...future.globalenv.names))
[11:02:46.221]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:46.221]         }, condition = base::local({
[11:02:46.221]             c <- base::c
[11:02:46.221]             inherits <- base::inherits
[11:02:46.221]             invokeRestart <- base::invokeRestart
[11:02:46.221]             length <- base::length
[11:02:46.221]             list <- base::list
[11:02:46.221]             seq.int <- base::seq.int
[11:02:46.221]             signalCondition <- base::signalCondition
[11:02:46.221]             sys.calls <- base::sys.calls
[11:02:46.221]             `[[` <- base::`[[`
[11:02:46.221]             `+` <- base::`+`
[11:02:46.221]             `<<-` <- base::`<<-`
[11:02:46.221]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:46.221]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:46.221]                   3L)]
[11:02:46.221]             }
[11:02:46.221]             function(cond) {
[11:02:46.221]                 is_error <- inherits(cond, "error")
[11:02:46.221]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:46.221]                   NULL)
[11:02:46.221]                 if (is_error) {
[11:02:46.221]                   sessionInformation <- function() {
[11:02:46.221]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:46.221]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:46.221]                       search = base::search(), system = base::Sys.info())
[11:02:46.221]                   }
[11:02:46.221]                   ...future.conditions[[length(...future.conditions) + 
[11:02:46.221]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:46.221]                     cond$call), session = sessionInformation(), 
[11:02:46.221]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:46.221]                   signalCondition(cond)
[11:02:46.221]                 }
[11:02:46.221]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:46.221]                 "immediateCondition"))) {
[11:02:46.221]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:46.221]                   ...future.conditions[[length(...future.conditions) + 
[11:02:46.221]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:46.221]                   if (TRUE && !signal) {
[11:02:46.221]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:46.221]                     {
[11:02:46.221]                       inherits <- base::inherits
[11:02:46.221]                       invokeRestart <- base::invokeRestart
[11:02:46.221]                       is.null <- base::is.null
[11:02:46.221]                       muffled <- FALSE
[11:02:46.221]                       if (inherits(cond, "message")) {
[11:02:46.221]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:46.221]                         if (muffled) 
[11:02:46.221]                           invokeRestart("muffleMessage")
[11:02:46.221]                       }
[11:02:46.221]                       else if (inherits(cond, "warning")) {
[11:02:46.221]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:46.221]                         if (muffled) 
[11:02:46.221]                           invokeRestart("muffleWarning")
[11:02:46.221]                       }
[11:02:46.221]                       else if (inherits(cond, "condition")) {
[11:02:46.221]                         if (!is.null(pattern)) {
[11:02:46.221]                           computeRestarts <- base::computeRestarts
[11:02:46.221]                           grepl <- base::grepl
[11:02:46.221]                           restarts <- computeRestarts(cond)
[11:02:46.221]                           for (restart in restarts) {
[11:02:46.221]                             name <- restart$name
[11:02:46.221]                             if (is.null(name)) 
[11:02:46.221]                               next
[11:02:46.221]                             if (!grepl(pattern, name)) 
[11:02:46.221]                               next
[11:02:46.221]                             invokeRestart(restart)
[11:02:46.221]                             muffled <- TRUE
[11:02:46.221]                             break
[11:02:46.221]                           }
[11:02:46.221]                         }
[11:02:46.221]                       }
[11:02:46.221]                       invisible(muffled)
[11:02:46.221]                     }
[11:02:46.221]                     muffleCondition(cond, pattern = "^muffle")
[11:02:46.221]                   }
[11:02:46.221]                 }
[11:02:46.221]                 else {
[11:02:46.221]                   if (TRUE) {
[11:02:46.221]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:46.221]                     {
[11:02:46.221]                       inherits <- base::inherits
[11:02:46.221]                       invokeRestart <- base::invokeRestart
[11:02:46.221]                       is.null <- base::is.null
[11:02:46.221]                       muffled <- FALSE
[11:02:46.221]                       if (inherits(cond, "message")) {
[11:02:46.221]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:46.221]                         if (muffled) 
[11:02:46.221]                           invokeRestart("muffleMessage")
[11:02:46.221]                       }
[11:02:46.221]                       else if (inherits(cond, "warning")) {
[11:02:46.221]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:46.221]                         if (muffled) 
[11:02:46.221]                           invokeRestart("muffleWarning")
[11:02:46.221]                       }
[11:02:46.221]                       else if (inherits(cond, "condition")) {
[11:02:46.221]                         if (!is.null(pattern)) {
[11:02:46.221]                           computeRestarts <- base::computeRestarts
[11:02:46.221]                           grepl <- base::grepl
[11:02:46.221]                           restarts <- computeRestarts(cond)
[11:02:46.221]                           for (restart in restarts) {
[11:02:46.221]                             name <- restart$name
[11:02:46.221]                             if (is.null(name)) 
[11:02:46.221]                               next
[11:02:46.221]                             if (!grepl(pattern, name)) 
[11:02:46.221]                               next
[11:02:46.221]                             invokeRestart(restart)
[11:02:46.221]                             muffled <- TRUE
[11:02:46.221]                             break
[11:02:46.221]                           }
[11:02:46.221]                         }
[11:02:46.221]                       }
[11:02:46.221]                       invisible(muffled)
[11:02:46.221]                     }
[11:02:46.221]                     muffleCondition(cond, pattern = "^muffle")
[11:02:46.221]                   }
[11:02:46.221]                 }
[11:02:46.221]             }
[11:02:46.221]         }))
[11:02:46.221]     }, error = function(ex) {
[11:02:46.221]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:46.221]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:46.221]                 ...future.rng), started = ...future.startTime, 
[11:02:46.221]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:46.221]             version = "1.8"), class = "FutureResult")
[11:02:46.221]     }, finally = {
[11:02:46.221]         if (!identical(...future.workdir, getwd())) 
[11:02:46.221]             setwd(...future.workdir)
[11:02:46.221]         {
[11:02:46.221]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:46.221]                 ...future.oldOptions$nwarnings <- NULL
[11:02:46.221]             }
[11:02:46.221]             base::options(...future.oldOptions)
[11:02:46.221]             if (.Platform$OS.type == "windows") {
[11:02:46.221]                 old_names <- names(...future.oldEnvVars)
[11:02:46.221]                 envs <- base::Sys.getenv()
[11:02:46.221]                 names <- names(envs)
[11:02:46.221]                 common <- intersect(names, old_names)
[11:02:46.221]                 added <- setdiff(names, old_names)
[11:02:46.221]                 removed <- setdiff(old_names, names)
[11:02:46.221]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:46.221]                   envs[common]]
[11:02:46.221]                 NAMES <- toupper(changed)
[11:02:46.221]                 args <- list()
[11:02:46.221]                 for (kk in seq_along(NAMES)) {
[11:02:46.221]                   name <- changed[[kk]]
[11:02:46.221]                   NAME <- NAMES[[kk]]
[11:02:46.221]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:46.221]                     next
[11:02:46.221]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:46.221]                 }
[11:02:46.221]                 NAMES <- toupper(added)
[11:02:46.221]                 for (kk in seq_along(NAMES)) {
[11:02:46.221]                   name <- added[[kk]]
[11:02:46.221]                   NAME <- NAMES[[kk]]
[11:02:46.221]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:46.221]                     next
[11:02:46.221]                   args[[name]] <- ""
[11:02:46.221]                 }
[11:02:46.221]                 NAMES <- toupper(removed)
[11:02:46.221]                 for (kk in seq_along(NAMES)) {
[11:02:46.221]                   name <- removed[[kk]]
[11:02:46.221]                   NAME <- NAMES[[kk]]
[11:02:46.221]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:46.221]                     next
[11:02:46.221]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:46.221]                 }
[11:02:46.221]                 if (length(args) > 0) 
[11:02:46.221]                   base::do.call(base::Sys.setenv, args = args)
[11:02:46.221]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:46.221]             }
[11:02:46.221]             else {
[11:02:46.221]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:46.221]             }
[11:02:46.221]             {
[11:02:46.221]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:46.221]                   0L) {
[11:02:46.221]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:46.221]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:46.221]                   base::options(opts)
[11:02:46.221]                 }
[11:02:46.221]                 {
[11:02:46.221]                   {
[11:02:46.221]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:46.221]                     NULL
[11:02:46.221]                   }
[11:02:46.221]                   options(future.plan = NULL)
[11:02:46.221]                   if (is.na(NA_character_)) 
[11:02:46.221]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:46.221]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:46.221]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:46.221]                     .init = FALSE)
[11:02:46.221]                 }
[11:02:46.221]             }
[11:02:46.221]         }
[11:02:46.221]     })
[11:02:46.221]     if (TRUE) {
[11:02:46.221]         base::sink(type = "output", split = FALSE)
[11:02:46.221]         if (TRUE) {
[11:02:46.221]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:46.221]         }
[11:02:46.221]         else {
[11:02:46.221]             ...future.result["stdout"] <- base::list(NULL)
[11:02:46.221]         }
[11:02:46.221]         base::close(...future.stdout)
[11:02:46.221]         ...future.stdout <- NULL
[11:02:46.221]     }
[11:02:46.221]     ...future.result$conditions <- ...future.conditions
[11:02:46.221]     ...future.result$finished <- base::Sys.time()
[11:02:46.221]     ...future.result
[11:02:46.221] }
[11:02:46.224] MultisessionFuture started
[11:02:46.224] - Launch lazy future ... done
[11:02:46.224] run() for ‘MultisessionFuture’ ... done
[11:02:46.266] receiveMessageFromWorker() for ClusterFuture ...
[11:02:46.266] - Validating connection of MultisessionFuture
[11:02:46.267] - received message: FutureResult
[11:02:46.267] - Received FutureResult
[11:02:46.267] - Erased future from FutureRegistry
[11:02:46.267] result() for ClusterFuture ...
[11:02:46.267] - result already collected: FutureResult
[11:02:46.267] result() for ClusterFuture ... done
[11:02:46.267] signalConditions() ...
[11:02:46.267]  - include = ‘immediateCondition’
[11:02:46.267]  - exclude = 
[11:02:46.267]  - resignal = FALSE
[11:02:46.268]  - Number of conditions: 1
[11:02:46.268] signalConditions() ... done
[11:02:46.268] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:46.268] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 1 ... DONE
- result = FALSE, recursive = 2 ...
[11:02:46.268] getGlobalsAndPackages() ...
[11:02:46.268] Searching for globals...
[11:02:46.269] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[11:02:46.269] Searching for globals ... DONE
[11:02:46.269] Resolving globals: FALSE
[11:02:46.270] 
[11:02:46.270] 
[11:02:46.270] getGlobalsAndPackages() ... DONE
[11:02:46.270] run() for ‘Future’ ...
[11:02:46.270] - state: ‘created’
[11:02:46.270] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:46.284] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:46.284] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:46.284]   - Field: ‘node’
[11:02:46.284]   - Field: ‘label’
[11:02:46.284]   - Field: ‘local’
[11:02:46.284]   - Field: ‘owner’
[11:02:46.284]   - Field: ‘envir’
[11:02:46.284]   - Field: ‘workers’
[11:02:46.284]   - Field: ‘packages’
[11:02:46.285]   - Field: ‘gc’
[11:02:46.285]   - Field: ‘conditions’
[11:02:46.285]   - Field: ‘persistent’
[11:02:46.285]   - Field: ‘expr’
[11:02:46.285]   - Field: ‘uuid’
[11:02:46.285]   - Field: ‘seed’
[11:02:46.285]   - Field: ‘version’
[11:02:46.285]   - Field: ‘result’
[11:02:46.285]   - Field: ‘asynchronous’
[11:02:46.285]   - Field: ‘calls’
[11:02:46.285]   - Field: ‘globals’
[11:02:46.285]   - Field: ‘stdout’
[11:02:46.286]   - Field: ‘earlySignal’
[11:02:46.286]   - Field: ‘lazy’
[11:02:46.286]   - Field: ‘state’
[11:02:46.286] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:46.286] - Launch lazy future ...
[11:02:46.286] Packages needed by the future expression (n = 0): <none>
[11:02:46.286] Packages needed by future strategies (n = 0): <none>
[11:02:46.287] {
[11:02:46.287]     {
[11:02:46.287]         {
[11:02:46.287]             ...future.startTime <- base::Sys.time()
[11:02:46.287]             {
[11:02:46.287]                 {
[11:02:46.287]                   {
[11:02:46.287]                     {
[11:02:46.287]                       base::local({
[11:02:46.287]                         has_future <- base::requireNamespace("future", 
[11:02:46.287]                           quietly = TRUE)
[11:02:46.287]                         if (has_future) {
[11:02:46.287]                           ns <- base::getNamespace("future")
[11:02:46.287]                           version <- ns[[".package"]][["version"]]
[11:02:46.287]                           if (is.null(version)) 
[11:02:46.287]                             version <- utils::packageVersion("future")
[11:02:46.287]                         }
[11:02:46.287]                         else {
[11:02:46.287]                           version <- NULL
[11:02:46.287]                         }
[11:02:46.287]                         if (!has_future || version < "1.8.0") {
[11:02:46.287]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:46.287]                             "", base::R.version$version.string), 
[11:02:46.287]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:46.287]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:46.287]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:46.287]                               "release", "version")], collapse = " "), 
[11:02:46.287]                             hostname = base::Sys.info()[["nodename"]])
[11:02:46.287]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:46.287]                             info)
[11:02:46.287]                           info <- base::paste(info, collapse = "; ")
[11:02:46.287]                           if (!has_future) {
[11:02:46.287]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:46.287]                               info)
[11:02:46.287]                           }
[11:02:46.287]                           else {
[11:02:46.287]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:46.287]                               info, version)
[11:02:46.287]                           }
[11:02:46.287]                           base::stop(msg)
[11:02:46.287]                         }
[11:02:46.287]                       })
[11:02:46.287]                     }
[11:02:46.287]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:46.287]                     base::options(mc.cores = 1L)
[11:02:46.287]                   }
[11:02:46.287]                   ...future.strategy.old <- future::plan("list")
[11:02:46.287]                   options(future.plan = NULL)
[11:02:46.287]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:46.287]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:46.287]                 }
[11:02:46.287]                 ...future.workdir <- getwd()
[11:02:46.287]             }
[11:02:46.287]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:46.287]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:46.287]         }
[11:02:46.287]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:46.287]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:46.287]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:46.287]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:46.287]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:46.287]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:46.287]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:46.287]             base::names(...future.oldOptions))
[11:02:46.287]     }
[11:02:46.287]     if (FALSE) {
[11:02:46.287]     }
[11:02:46.287]     else {
[11:02:46.287]         if (TRUE) {
[11:02:46.287]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:46.287]                 open = "w")
[11:02:46.287]         }
[11:02:46.287]         else {
[11:02:46.287]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:46.287]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:46.287]         }
[11:02:46.287]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:46.287]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:46.287]             base::sink(type = "output", split = FALSE)
[11:02:46.287]             base::close(...future.stdout)
[11:02:46.287]         }, add = TRUE)
[11:02:46.287]     }
[11:02:46.287]     ...future.frame <- base::sys.nframe()
[11:02:46.287]     ...future.conditions <- base::list()
[11:02:46.287]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:46.287]     if (FALSE) {
[11:02:46.287]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:46.287]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:46.287]     }
[11:02:46.287]     ...future.result <- base::tryCatch({
[11:02:46.287]         base::withCallingHandlers({
[11:02:46.287]             ...future.value <- base::withVisible(base::local({
[11:02:46.287]                 ...future.makeSendCondition <- base::local({
[11:02:46.287]                   sendCondition <- NULL
[11:02:46.287]                   function(frame = 1L) {
[11:02:46.287]                     if (is.function(sendCondition)) 
[11:02:46.287]                       return(sendCondition)
[11:02:46.287]                     ns <- getNamespace("parallel")
[11:02:46.287]                     if (exists("sendData", mode = "function", 
[11:02:46.287]                       envir = ns)) {
[11:02:46.287]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:46.287]                         envir = ns)
[11:02:46.287]                       envir <- sys.frame(frame)
[11:02:46.287]                       master <- NULL
[11:02:46.287]                       while (!identical(envir, .GlobalEnv) && 
[11:02:46.287]                         !identical(envir, emptyenv())) {
[11:02:46.287]                         if (exists("master", mode = "list", envir = envir, 
[11:02:46.287]                           inherits = FALSE)) {
[11:02:46.287]                           master <- get("master", mode = "list", 
[11:02:46.287]                             envir = envir, inherits = FALSE)
[11:02:46.287]                           if (inherits(master, c("SOCKnode", 
[11:02:46.287]                             "SOCK0node"))) {
[11:02:46.287]                             sendCondition <<- function(cond) {
[11:02:46.287]                               data <- list(type = "VALUE", value = cond, 
[11:02:46.287]                                 success = TRUE)
[11:02:46.287]                               parallel_sendData(master, data)
[11:02:46.287]                             }
[11:02:46.287]                             return(sendCondition)
[11:02:46.287]                           }
[11:02:46.287]                         }
[11:02:46.287]                         frame <- frame + 1L
[11:02:46.287]                         envir <- sys.frame(frame)
[11:02:46.287]                       }
[11:02:46.287]                     }
[11:02:46.287]                     sendCondition <<- function(cond) NULL
[11:02:46.287]                   }
[11:02:46.287]                 })
[11:02:46.287]                 withCallingHandlers({
[11:02:46.287]                   {
[11:02:46.287]                     Sys.sleep(0.5)
[11:02:46.287]                     list(a = 1, b = 42L)
[11:02:46.287]                   }
[11:02:46.287]                 }, immediateCondition = function(cond) {
[11:02:46.287]                   sendCondition <- ...future.makeSendCondition()
[11:02:46.287]                   sendCondition(cond)
[11:02:46.287]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:46.287]                   {
[11:02:46.287]                     inherits <- base::inherits
[11:02:46.287]                     invokeRestart <- base::invokeRestart
[11:02:46.287]                     is.null <- base::is.null
[11:02:46.287]                     muffled <- FALSE
[11:02:46.287]                     if (inherits(cond, "message")) {
[11:02:46.287]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:46.287]                       if (muffled) 
[11:02:46.287]                         invokeRestart("muffleMessage")
[11:02:46.287]                     }
[11:02:46.287]                     else if (inherits(cond, "warning")) {
[11:02:46.287]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:46.287]                       if (muffled) 
[11:02:46.287]                         invokeRestart("muffleWarning")
[11:02:46.287]                     }
[11:02:46.287]                     else if (inherits(cond, "condition")) {
[11:02:46.287]                       if (!is.null(pattern)) {
[11:02:46.287]                         computeRestarts <- base::computeRestarts
[11:02:46.287]                         grepl <- base::grepl
[11:02:46.287]                         restarts <- computeRestarts(cond)
[11:02:46.287]                         for (restart in restarts) {
[11:02:46.287]                           name <- restart$name
[11:02:46.287]                           if (is.null(name)) 
[11:02:46.287]                             next
[11:02:46.287]                           if (!grepl(pattern, name)) 
[11:02:46.287]                             next
[11:02:46.287]                           invokeRestart(restart)
[11:02:46.287]                           muffled <- TRUE
[11:02:46.287]                           break
[11:02:46.287]                         }
[11:02:46.287]                       }
[11:02:46.287]                     }
[11:02:46.287]                     invisible(muffled)
[11:02:46.287]                   }
[11:02:46.287]                   muffleCondition(cond)
[11:02:46.287]                 })
[11:02:46.287]             }))
[11:02:46.287]             future::FutureResult(value = ...future.value$value, 
[11:02:46.287]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:46.287]                   ...future.rng), globalenv = if (FALSE) 
[11:02:46.287]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:46.287]                     ...future.globalenv.names))
[11:02:46.287]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:46.287]         }, condition = base::local({
[11:02:46.287]             c <- base::c
[11:02:46.287]             inherits <- base::inherits
[11:02:46.287]             invokeRestart <- base::invokeRestart
[11:02:46.287]             length <- base::length
[11:02:46.287]             list <- base::list
[11:02:46.287]             seq.int <- base::seq.int
[11:02:46.287]             signalCondition <- base::signalCondition
[11:02:46.287]             sys.calls <- base::sys.calls
[11:02:46.287]             `[[` <- base::`[[`
[11:02:46.287]             `+` <- base::`+`
[11:02:46.287]             `<<-` <- base::`<<-`
[11:02:46.287]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:46.287]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:46.287]                   3L)]
[11:02:46.287]             }
[11:02:46.287]             function(cond) {
[11:02:46.287]                 is_error <- inherits(cond, "error")
[11:02:46.287]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:46.287]                   NULL)
[11:02:46.287]                 if (is_error) {
[11:02:46.287]                   sessionInformation <- function() {
[11:02:46.287]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:46.287]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:46.287]                       search = base::search(), system = base::Sys.info())
[11:02:46.287]                   }
[11:02:46.287]                   ...future.conditions[[length(...future.conditions) + 
[11:02:46.287]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:46.287]                     cond$call), session = sessionInformation(), 
[11:02:46.287]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:46.287]                   signalCondition(cond)
[11:02:46.287]                 }
[11:02:46.287]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:46.287]                 "immediateCondition"))) {
[11:02:46.287]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:46.287]                   ...future.conditions[[length(...future.conditions) + 
[11:02:46.287]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:46.287]                   if (TRUE && !signal) {
[11:02:46.287]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:46.287]                     {
[11:02:46.287]                       inherits <- base::inherits
[11:02:46.287]                       invokeRestart <- base::invokeRestart
[11:02:46.287]                       is.null <- base::is.null
[11:02:46.287]                       muffled <- FALSE
[11:02:46.287]                       if (inherits(cond, "message")) {
[11:02:46.287]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:46.287]                         if (muffled) 
[11:02:46.287]                           invokeRestart("muffleMessage")
[11:02:46.287]                       }
[11:02:46.287]                       else if (inherits(cond, "warning")) {
[11:02:46.287]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:46.287]                         if (muffled) 
[11:02:46.287]                           invokeRestart("muffleWarning")
[11:02:46.287]                       }
[11:02:46.287]                       else if (inherits(cond, "condition")) {
[11:02:46.287]                         if (!is.null(pattern)) {
[11:02:46.287]                           computeRestarts <- base::computeRestarts
[11:02:46.287]                           grepl <- base::grepl
[11:02:46.287]                           restarts <- computeRestarts(cond)
[11:02:46.287]                           for (restart in restarts) {
[11:02:46.287]                             name <- restart$name
[11:02:46.287]                             if (is.null(name)) 
[11:02:46.287]                               next
[11:02:46.287]                             if (!grepl(pattern, name)) 
[11:02:46.287]                               next
[11:02:46.287]                             invokeRestart(restart)
[11:02:46.287]                             muffled <- TRUE
[11:02:46.287]                             break
[11:02:46.287]                           }
[11:02:46.287]                         }
[11:02:46.287]                       }
[11:02:46.287]                       invisible(muffled)
[11:02:46.287]                     }
[11:02:46.287]                     muffleCondition(cond, pattern = "^muffle")
[11:02:46.287]                   }
[11:02:46.287]                 }
[11:02:46.287]                 else {
[11:02:46.287]                   if (TRUE) {
[11:02:46.287]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:46.287]                     {
[11:02:46.287]                       inherits <- base::inherits
[11:02:46.287]                       invokeRestart <- base::invokeRestart
[11:02:46.287]                       is.null <- base::is.null
[11:02:46.287]                       muffled <- FALSE
[11:02:46.287]                       if (inherits(cond, "message")) {
[11:02:46.287]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:46.287]                         if (muffled) 
[11:02:46.287]                           invokeRestart("muffleMessage")
[11:02:46.287]                       }
[11:02:46.287]                       else if (inherits(cond, "warning")) {
[11:02:46.287]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:46.287]                         if (muffled) 
[11:02:46.287]                           invokeRestart("muffleWarning")
[11:02:46.287]                       }
[11:02:46.287]                       else if (inherits(cond, "condition")) {
[11:02:46.287]                         if (!is.null(pattern)) {
[11:02:46.287]                           computeRestarts <- base::computeRestarts
[11:02:46.287]                           grepl <- base::grepl
[11:02:46.287]                           restarts <- computeRestarts(cond)
[11:02:46.287]                           for (restart in restarts) {
[11:02:46.287]                             name <- restart$name
[11:02:46.287]                             if (is.null(name)) 
[11:02:46.287]                               next
[11:02:46.287]                             if (!grepl(pattern, name)) 
[11:02:46.287]                               next
[11:02:46.287]                             invokeRestart(restart)
[11:02:46.287]                             muffled <- TRUE
[11:02:46.287]                             break
[11:02:46.287]                           }
[11:02:46.287]                         }
[11:02:46.287]                       }
[11:02:46.287]                       invisible(muffled)
[11:02:46.287]                     }
[11:02:46.287]                     muffleCondition(cond, pattern = "^muffle")
[11:02:46.287]                   }
[11:02:46.287]                 }
[11:02:46.287]             }
[11:02:46.287]         }))
[11:02:46.287]     }, error = function(ex) {
[11:02:46.287]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:46.287]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:46.287]                 ...future.rng), started = ...future.startTime, 
[11:02:46.287]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:46.287]             version = "1.8"), class = "FutureResult")
[11:02:46.287]     }, finally = {
[11:02:46.287]         if (!identical(...future.workdir, getwd())) 
[11:02:46.287]             setwd(...future.workdir)
[11:02:46.287]         {
[11:02:46.287]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:46.287]                 ...future.oldOptions$nwarnings <- NULL
[11:02:46.287]             }
[11:02:46.287]             base::options(...future.oldOptions)
[11:02:46.287]             if (.Platform$OS.type == "windows") {
[11:02:46.287]                 old_names <- names(...future.oldEnvVars)
[11:02:46.287]                 envs <- base::Sys.getenv()
[11:02:46.287]                 names <- names(envs)
[11:02:46.287]                 common <- intersect(names, old_names)
[11:02:46.287]                 added <- setdiff(names, old_names)
[11:02:46.287]                 removed <- setdiff(old_names, names)
[11:02:46.287]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:46.287]                   envs[common]]
[11:02:46.287]                 NAMES <- toupper(changed)
[11:02:46.287]                 args <- list()
[11:02:46.287]                 for (kk in seq_along(NAMES)) {
[11:02:46.287]                   name <- changed[[kk]]
[11:02:46.287]                   NAME <- NAMES[[kk]]
[11:02:46.287]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:46.287]                     next
[11:02:46.287]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:46.287]                 }
[11:02:46.287]                 NAMES <- toupper(added)
[11:02:46.287]                 for (kk in seq_along(NAMES)) {
[11:02:46.287]                   name <- added[[kk]]
[11:02:46.287]                   NAME <- NAMES[[kk]]
[11:02:46.287]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:46.287]                     next
[11:02:46.287]                   args[[name]] <- ""
[11:02:46.287]                 }
[11:02:46.287]                 NAMES <- toupper(removed)
[11:02:46.287]                 for (kk in seq_along(NAMES)) {
[11:02:46.287]                   name <- removed[[kk]]
[11:02:46.287]                   NAME <- NAMES[[kk]]
[11:02:46.287]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:46.287]                     next
[11:02:46.287]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:46.287]                 }
[11:02:46.287]                 if (length(args) > 0) 
[11:02:46.287]                   base::do.call(base::Sys.setenv, args = args)
[11:02:46.287]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:46.287]             }
[11:02:46.287]             else {
[11:02:46.287]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:46.287]             }
[11:02:46.287]             {
[11:02:46.287]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:46.287]                   0L) {
[11:02:46.287]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:46.287]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:46.287]                   base::options(opts)
[11:02:46.287]                 }
[11:02:46.287]                 {
[11:02:46.287]                   {
[11:02:46.287]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:46.287]                     NULL
[11:02:46.287]                   }
[11:02:46.287]                   options(future.plan = NULL)
[11:02:46.287]                   if (is.na(NA_character_)) 
[11:02:46.287]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:46.287]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:46.287]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:46.287]                     .init = FALSE)
[11:02:46.287]                 }
[11:02:46.287]             }
[11:02:46.287]         }
[11:02:46.287]     })
[11:02:46.287]     if (TRUE) {
[11:02:46.287]         base::sink(type = "output", split = FALSE)
[11:02:46.287]         if (TRUE) {
[11:02:46.287]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:46.287]         }
[11:02:46.287]         else {
[11:02:46.287]             ...future.result["stdout"] <- base::list(NULL)
[11:02:46.287]         }
[11:02:46.287]         base::close(...future.stdout)
[11:02:46.287]         ...future.stdout <- NULL
[11:02:46.287]     }
[11:02:46.287]     ...future.result$conditions <- ...future.conditions
[11:02:46.287]     ...future.result$finished <- base::Sys.time()
[11:02:46.287]     ...future.result
[11:02:46.287] }
[11:02:46.290] MultisessionFuture started
[11:02:46.290] - Launch lazy future ... done
[11:02:46.290] run() for ‘MultisessionFuture’ ... done
[11:02:46.833] receiveMessageFromWorker() for ClusterFuture ...
[11:02:46.833] - Validating connection of MultisessionFuture
[11:02:46.833] - received message: FutureResult
[11:02:46.833] - Received FutureResult
[11:02:46.833] - Erased future from FutureRegistry
[11:02:46.834] result() for ClusterFuture ...
[11:02:46.834] - result already collected: FutureResult
[11:02:46.834] result() for ClusterFuture ... done
[11:02:46.834] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:46.834] A MultisessionFuture was resolved (result was not collected)
[11:02:46.834] getGlobalsAndPackages() ...
[11:02:46.834] Searching for globals...
[11:02:46.835] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[11:02:46.835] Searching for globals ... DONE
[11:02:46.835] Resolving globals: FALSE
[11:02:46.836] 
[11:02:46.836] 
[11:02:46.836] getGlobalsAndPackages() ... DONE
[11:02:46.836] run() for ‘Future’ ...
[11:02:46.836] - state: ‘created’
[11:02:46.836] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:46.850] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:46.850] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:46.850]   - Field: ‘node’
[11:02:46.850]   - Field: ‘label’
[11:02:46.850]   - Field: ‘local’
[11:02:46.850]   - Field: ‘owner’
[11:02:46.851]   - Field: ‘envir’
[11:02:46.851]   - Field: ‘workers’
[11:02:46.851]   - Field: ‘packages’
[11:02:46.851]   - Field: ‘gc’
[11:02:46.851]   - Field: ‘conditions’
[11:02:46.851]   - Field: ‘persistent’
[11:02:46.851]   - Field: ‘expr’
[11:02:46.851]   - Field: ‘uuid’
[11:02:46.851]   - Field: ‘seed’
[11:02:46.851]   - Field: ‘version’
[11:02:46.851]   - Field: ‘result’
[11:02:46.851]   - Field: ‘asynchronous’
[11:02:46.852]   - Field: ‘calls’
[11:02:46.852]   - Field: ‘globals’
[11:02:46.852]   - Field: ‘stdout’
[11:02:46.852]   - Field: ‘earlySignal’
[11:02:46.852]   - Field: ‘lazy’
[11:02:46.852]   - Field: ‘state’
[11:02:46.852] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:46.852] - Launch lazy future ...
[11:02:46.852] Packages needed by the future expression (n = 0): <none>
[11:02:46.852] Packages needed by future strategies (n = 0): <none>
[11:02:46.853] {
[11:02:46.853]     {
[11:02:46.853]         {
[11:02:46.853]             ...future.startTime <- base::Sys.time()
[11:02:46.853]             {
[11:02:46.853]                 {
[11:02:46.853]                   {
[11:02:46.853]                     {
[11:02:46.853]                       base::local({
[11:02:46.853]                         has_future <- base::requireNamespace("future", 
[11:02:46.853]                           quietly = TRUE)
[11:02:46.853]                         if (has_future) {
[11:02:46.853]                           ns <- base::getNamespace("future")
[11:02:46.853]                           version <- ns[[".package"]][["version"]]
[11:02:46.853]                           if (is.null(version)) 
[11:02:46.853]                             version <- utils::packageVersion("future")
[11:02:46.853]                         }
[11:02:46.853]                         else {
[11:02:46.853]                           version <- NULL
[11:02:46.853]                         }
[11:02:46.853]                         if (!has_future || version < "1.8.0") {
[11:02:46.853]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:46.853]                             "", base::R.version$version.string), 
[11:02:46.853]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:46.853]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:46.853]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:46.853]                               "release", "version")], collapse = " "), 
[11:02:46.853]                             hostname = base::Sys.info()[["nodename"]])
[11:02:46.853]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:46.853]                             info)
[11:02:46.853]                           info <- base::paste(info, collapse = "; ")
[11:02:46.853]                           if (!has_future) {
[11:02:46.853]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:46.853]                               info)
[11:02:46.853]                           }
[11:02:46.853]                           else {
[11:02:46.853]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:46.853]                               info, version)
[11:02:46.853]                           }
[11:02:46.853]                           base::stop(msg)
[11:02:46.853]                         }
[11:02:46.853]                       })
[11:02:46.853]                     }
[11:02:46.853]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:46.853]                     base::options(mc.cores = 1L)
[11:02:46.853]                   }
[11:02:46.853]                   ...future.strategy.old <- future::plan("list")
[11:02:46.853]                   options(future.plan = NULL)
[11:02:46.853]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:46.853]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:46.853]                 }
[11:02:46.853]                 ...future.workdir <- getwd()
[11:02:46.853]             }
[11:02:46.853]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:46.853]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:46.853]         }
[11:02:46.853]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:46.853]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:46.853]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:46.853]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:46.853]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:46.853]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:46.853]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:46.853]             base::names(...future.oldOptions))
[11:02:46.853]     }
[11:02:46.853]     if (FALSE) {
[11:02:46.853]     }
[11:02:46.853]     else {
[11:02:46.853]         if (TRUE) {
[11:02:46.853]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:46.853]                 open = "w")
[11:02:46.853]         }
[11:02:46.853]         else {
[11:02:46.853]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:46.853]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:46.853]         }
[11:02:46.853]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:46.853]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:46.853]             base::sink(type = "output", split = FALSE)
[11:02:46.853]             base::close(...future.stdout)
[11:02:46.853]         }, add = TRUE)
[11:02:46.853]     }
[11:02:46.853]     ...future.frame <- base::sys.nframe()
[11:02:46.853]     ...future.conditions <- base::list()
[11:02:46.853]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:46.853]     if (FALSE) {
[11:02:46.853]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:46.853]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:46.853]     }
[11:02:46.853]     ...future.result <- base::tryCatch({
[11:02:46.853]         base::withCallingHandlers({
[11:02:46.853]             ...future.value <- base::withVisible(base::local({
[11:02:46.853]                 ...future.makeSendCondition <- base::local({
[11:02:46.853]                   sendCondition <- NULL
[11:02:46.853]                   function(frame = 1L) {
[11:02:46.853]                     if (is.function(sendCondition)) 
[11:02:46.853]                       return(sendCondition)
[11:02:46.853]                     ns <- getNamespace("parallel")
[11:02:46.853]                     if (exists("sendData", mode = "function", 
[11:02:46.853]                       envir = ns)) {
[11:02:46.853]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:46.853]                         envir = ns)
[11:02:46.853]                       envir <- sys.frame(frame)
[11:02:46.853]                       master <- NULL
[11:02:46.853]                       while (!identical(envir, .GlobalEnv) && 
[11:02:46.853]                         !identical(envir, emptyenv())) {
[11:02:46.853]                         if (exists("master", mode = "list", envir = envir, 
[11:02:46.853]                           inherits = FALSE)) {
[11:02:46.853]                           master <- get("master", mode = "list", 
[11:02:46.853]                             envir = envir, inherits = FALSE)
[11:02:46.853]                           if (inherits(master, c("SOCKnode", 
[11:02:46.853]                             "SOCK0node"))) {
[11:02:46.853]                             sendCondition <<- function(cond) {
[11:02:46.853]                               data <- list(type = "VALUE", value = cond, 
[11:02:46.853]                                 success = TRUE)
[11:02:46.853]                               parallel_sendData(master, data)
[11:02:46.853]                             }
[11:02:46.853]                             return(sendCondition)
[11:02:46.853]                           }
[11:02:46.853]                         }
[11:02:46.853]                         frame <- frame + 1L
[11:02:46.853]                         envir <- sys.frame(frame)
[11:02:46.853]                       }
[11:02:46.853]                     }
[11:02:46.853]                     sendCondition <<- function(cond) NULL
[11:02:46.853]                   }
[11:02:46.853]                 })
[11:02:46.853]                 withCallingHandlers({
[11:02:46.853]                   {
[11:02:46.853]                     Sys.sleep(0.5)
[11:02:46.853]                     list(a = 1, b = 42L)
[11:02:46.853]                   }
[11:02:46.853]                 }, immediateCondition = function(cond) {
[11:02:46.853]                   sendCondition <- ...future.makeSendCondition()
[11:02:46.853]                   sendCondition(cond)
[11:02:46.853]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:46.853]                   {
[11:02:46.853]                     inherits <- base::inherits
[11:02:46.853]                     invokeRestart <- base::invokeRestart
[11:02:46.853]                     is.null <- base::is.null
[11:02:46.853]                     muffled <- FALSE
[11:02:46.853]                     if (inherits(cond, "message")) {
[11:02:46.853]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:46.853]                       if (muffled) 
[11:02:46.853]                         invokeRestart("muffleMessage")
[11:02:46.853]                     }
[11:02:46.853]                     else if (inherits(cond, "warning")) {
[11:02:46.853]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:46.853]                       if (muffled) 
[11:02:46.853]                         invokeRestart("muffleWarning")
[11:02:46.853]                     }
[11:02:46.853]                     else if (inherits(cond, "condition")) {
[11:02:46.853]                       if (!is.null(pattern)) {
[11:02:46.853]                         computeRestarts <- base::computeRestarts
[11:02:46.853]                         grepl <- base::grepl
[11:02:46.853]                         restarts <- computeRestarts(cond)
[11:02:46.853]                         for (restart in restarts) {
[11:02:46.853]                           name <- restart$name
[11:02:46.853]                           if (is.null(name)) 
[11:02:46.853]                             next
[11:02:46.853]                           if (!grepl(pattern, name)) 
[11:02:46.853]                             next
[11:02:46.853]                           invokeRestart(restart)
[11:02:46.853]                           muffled <- TRUE
[11:02:46.853]                           break
[11:02:46.853]                         }
[11:02:46.853]                       }
[11:02:46.853]                     }
[11:02:46.853]                     invisible(muffled)
[11:02:46.853]                   }
[11:02:46.853]                   muffleCondition(cond)
[11:02:46.853]                 })
[11:02:46.853]             }))
[11:02:46.853]             future::FutureResult(value = ...future.value$value, 
[11:02:46.853]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:46.853]                   ...future.rng), globalenv = if (FALSE) 
[11:02:46.853]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:46.853]                     ...future.globalenv.names))
[11:02:46.853]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:46.853]         }, condition = base::local({
[11:02:46.853]             c <- base::c
[11:02:46.853]             inherits <- base::inherits
[11:02:46.853]             invokeRestart <- base::invokeRestart
[11:02:46.853]             length <- base::length
[11:02:46.853]             list <- base::list
[11:02:46.853]             seq.int <- base::seq.int
[11:02:46.853]             signalCondition <- base::signalCondition
[11:02:46.853]             sys.calls <- base::sys.calls
[11:02:46.853]             `[[` <- base::`[[`
[11:02:46.853]             `+` <- base::`+`
[11:02:46.853]             `<<-` <- base::`<<-`
[11:02:46.853]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:46.853]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:46.853]                   3L)]
[11:02:46.853]             }
[11:02:46.853]             function(cond) {
[11:02:46.853]                 is_error <- inherits(cond, "error")
[11:02:46.853]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:46.853]                   NULL)
[11:02:46.853]                 if (is_error) {
[11:02:46.853]                   sessionInformation <- function() {
[11:02:46.853]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:46.853]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:46.853]                       search = base::search(), system = base::Sys.info())
[11:02:46.853]                   }
[11:02:46.853]                   ...future.conditions[[length(...future.conditions) + 
[11:02:46.853]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:46.853]                     cond$call), session = sessionInformation(), 
[11:02:46.853]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:46.853]                   signalCondition(cond)
[11:02:46.853]                 }
[11:02:46.853]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:46.853]                 "immediateCondition"))) {
[11:02:46.853]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:46.853]                   ...future.conditions[[length(...future.conditions) + 
[11:02:46.853]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:46.853]                   if (TRUE && !signal) {
[11:02:46.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:46.853]                     {
[11:02:46.853]                       inherits <- base::inherits
[11:02:46.853]                       invokeRestart <- base::invokeRestart
[11:02:46.853]                       is.null <- base::is.null
[11:02:46.853]                       muffled <- FALSE
[11:02:46.853]                       if (inherits(cond, "message")) {
[11:02:46.853]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:46.853]                         if (muffled) 
[11:02:46.853]                           invokeRestart("muffleMessage")
[11:02:46.853]                       }
[11:02:46.853]                       else if (inherits(cond, "warning")) {
[11:02:46.853]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:46.853]                         if (muffled) 
[11:02:46.853]                           invokeRestart("muffleWarning")
[11:02:46.853]                       }
[11:02:46.853]                       else if (inherits(cond, "condition")) {
[11:02:46.853]                         if (!is.null(pattern)) {
[11:02:46.853]                           computeRestarts <- base::computeRestarts
[11:02:46.853]                           grepl <- base::grepl
[11:02:46.853]                           restarts <- computeRestarts(cond)
[11:02:46.853]                           for (restart in restarts) {
[11:02:46.853]                             name <- restart$name
[11:02:46.853]                             if (is.null(name)) 
[11:02:46.853]                               next
[11:02:46.853]                             if (!grepl(pattern, name)) 
[11:02:46.853]                               next
[11:02:46.853]                             invokeRestart(restart)
[11:02:46.853]                             muffled <- TRUE
[11:02:46.853]                             break
[11:02:46.853]                           }
[11:02:46.853]                         }
[11:02:46.853]                       }
[11:02:46.853]                       invisible(muffled)
[11:02:46.853]                     }
[11:02:46.853]                     muffleCondition(cond, pattern = "^muffle")
[11:02:46.853]                   }
[11:02:46.853]                 }
[11:02:46.853]                 else {
[11:02:46.853]                   if (TRUE) {
[11:02:46.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:46.853]                     {
[11:02:46.853]                       inherits <- base::inherits
[11:02:46.853]                       invokeRestart <- base::invokeRestart
[11:02:46.853]                       is.null <- base::is.null
[11:02:46.853]                       muffled <- FALSE
[11:02:46.853]                       if (inherits(cond, "message")) {
[11:02:46.853]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:46.853]                         if (muffled) 
[11:02:46.853]                           invokeRestart("muffleMessage")
[11:02:46.853]                       }
[11:02:46.853]                       else if (inherits(cond, "warning")) {
[11:02:46.853]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:46.853]                         if (muffled) 
[11:02:46.853]                           invokeRestart("muffleWarning")
[11:02:46.853]                       }
[11:02:46.853]                       else if (inherits(cond, "condition")) {
[11:02:46.853]                         if (!is.null(pattern)) {
[11:02:46.853]                           computeRestarts <- base::computeRestarts
[11:02:46.853]                           grepl <- base::grepl
[11:02:46.853]                           restarts <- computeRestarts(cond)
[11:02:46.853]                           for (restart in restarts) {
[11:02:46.853]                             name <- restart$name
[11:02:46.853]                             if (is.null(name)) 
[11:02:46.853]                               next
[11:02:46.853]                             if (!grepl(pattern, name)) 
[11:02:46.853]                               next
[11:02:46.853]                             invokeRestart(restart)
[11:02:46.853]                             muffled <- TRUE
[11:02:46.853]                             break
[11:02:46.853]                           }
[11:02:46.853]                         }
[11:02:46.853]                       }
[11:02:46.853]                       invisible(muffled)
[11:02:46.853]                     }
[11:02:46.853]                     muffleCondition(cond, pattern = "^muffle")
[11:02:46.853]                   }
[11:02:46.853]                 }
[11:02:46.853]             }
[11:02:46.853]         }))
[11:02:46.853]     }, error = function(ex) {
[11:02:46.853]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:46.853]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:46.853]                 ...future.rng), started = ...future.startTime, 
[11:02:46.853]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:46.853]             version = "1.8"), class = "FutureResult")
[11:02:46.853]     }, finally = {
[11:02:46.853]         if (!identical(...future.workdir, getwd())) 
[11:02:46.853]             setwd(...future.workdir)
[11:02:46.853]         {
[11:02:46.853]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:46.853]                 ...future.oldOptions$nwarnings <- NULL
[11:02:46.853]             }
[11:02:46.853]             base::options(...future.oldOptions)
[11:02:46.853]             if (.Platform$OS.type == "windows") {
[11:02:46.853]                 old_names <- names(...future.oldEnvVars)
[11:02:46.853]                 envs <- base::Sys.getenv()
[11:02:46.853]                 names <- names(envs)
[11:02:46.853]                 common <- intersect(names, old_names)
[11:02:46.853]                 added <- setdiff(names, old_names)
[11:02:46.853]                 removed <- setdiff(old_names, names)
[11:02:46.853]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:46.853]                   envs[common]]
[11:02:46.853]                 NAMES <- toupper(changed)
[11:02:46.853]                 args <- list()
[11:02:46.853]                 for (kk in seq_along(NAMES)) {
[11:02:46.853]                   name <- changed[[kk]]
[11:02:46.853]                   NAME <- NAMES[[kk]]
[11:02:46.853]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:46.853]                     next
[11:02:46.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:46.853]                 }
[11:02:46.853]                 NAMES <- toupper(added)
[11:02:46.853]                 for (kk in seq_along(NAMES)) {
[11:02:46.853]                   name <- added[[kk]]
[11:02:46.853]                   NAME <- NAMES[[kk]]
[11:02:46.853]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:46.853]                     next
[11:02:46.853]                   args[[name]] <- ""
[11:02:46.853]                 }
[11:02:46.853]                 NAMES <- toupper(removed)
[11:02:46.853]                 for (kk in seq_along(NAMES)) {
[11:02:46.853]                   name <- removed[[kk]]
[11:02:46.853]                   NAME <- NAMES[[kk]]
[11:02:46.853]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:46.853]                     next
[11:02:46.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:46.853]                 }
[11:02:46.853]                 if (length(args) > 0) 
[11:02:46.853]                   base::do.call(base::Sys.setenv, args = args)
[11:02:46.853]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:46.853]             }
[11:02:46.853]             else {
[11:02:46.853]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:46.853]             }
[11:02:46.853]             {
[11:02:46.853]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:46.853]                   0L) {
[11:02:46.853]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:46.853]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:46.853]                   base::options(opts)
[11:02:46.853]                 }
[11:02:46.853]                 {
[11:02:46.853]                   {
[11:02:46.853]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:46.853]                     NULL
[11:02:46.853]                   }
[11:02:46.853]                   options(future.plan = NULL)
[11:02:46.853]                   if (is.na(NA_character_)) 
[11:02:46.853]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:46.853]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:46.853]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:46.853]                     .init = FALSE)
[11:02:46.853]                 }
[11:02:46.853]             }
[11:02:46.853]         }
[11:02:46.853]     })
[11:02:46.853]     if (TRUE) {
[11:02:46.853]         base::sink(type = "output", split = FALSE)
[11:02:46.853]         if (TRUE) {
[11:02:46.853]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:46.853]         }
[11:02:46.853]         else {
[11:02:46.853]             ...future.result["stdout"] <- base::list(NULL)
[11:02:46.853]         }
[11:02:46.853]         base::close(...future.stdout)
[11:02:46.853]         ...future.stdout <- NULL
[11:02:46.853]     }
[11:02:46.853]     ...future.result$conditions <- ...future.conditions
[11:02:46.853]     ...future.result$finished <- base::Sys.time()
[11:02:46.853]     ...future.result
[11:02:46.853] }
[11:02:46.858] MultisessionFuture started
[11:02:46.858] - Launch lazy future ... done
[11:02:46.858] run() for ‘MultisessionFuture’ ... done
[11:02:47.401] receiveMessageFromWorker() for ClusterFuture ...
[11:02:47.401] - Validating connection of MultisessionFuture
[11:02:47.401] - received message: FutureResult
[11:02:47.401] - Received FutureResult
[11:02:47.401] - Erased future from FutureRegistry
[11:02:47.402] result() for ClusterFuture ...
[11:02:47.402] - result already collected: FutureResult
[11:02:47.402] result() for ClusterFuture ... done
[11:02:47.402] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:47.402] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[11:02:47.402] getGlobalsAndPackages() ...
[11:02:47.402] Searching for globals...
[11:02:47.403] - globals found: [2] ‘list’, ‘stop’
[11:02:47.403] Searching for globals ... DONE
[11:02:47.403] Resolving globals: FALSE
[11:02:47.403] 
[11:02:47.404] 
[11:02:47.404] getGlobalsAndPackages() ... DONE
[11:02:47.404] run() for ‘Future’ ...
[11:02:47.404] - state: ‘created’
[11:02:47.404] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:47.418] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:47.418] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:47.418]   - Field: ‘node’
[11:02:47.418]   - Field: ‘label’
[11:02:47.418]   - Field: ‘local’
[11:02:47.418]   - Field: ‘owner’
[11:02:47.418]   - Field: ‘envir’
[11:02:47.418]   - Field: ‘workers’
[11:02:47.419]   - Field: ‘packages’
[11:02:47.419]   - Field: ‘gc’
[11:02:47.419]   - Field: ‘conditions’
[11:02:47.419]   - Field: ‘persistent’
[11:02:47.419]   - Field: ‘expr’
[11:02:47.419]   - Field: ‘uuid’
[11:02:47.419]   - Field: ‘seed’
[11:02:47.419]   - Field: ‘version’
[11:02:47.419]   - Field: ‘result’
[11:02:47.419]   - Field: ‘asynchronous’
[11:02:47.419]   - Field: ‘calls’
[11:02:47.419]   - Field: ‘globals’
[11:02:47.419]   - Field: ‘stdout’
[11:02:47.420]   - Field: ‘earlySignal’
[11:02:47.420]   - Field: ‘lazy’
[11:02:47.420]   - Field: ‘state’
[11:02:47.420] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:47.420] - Launch lazy future ...
[11:02:47.420] Packages needed by the future expression (n = 0): <none>
[11:02:47.420] Packages needed by future strategies (n = 0): <none>
[11:02:47.421] {
[11:02:47.421]     {
[11:02:47.421]         {
[11:02:47.421]             ...future.startTime <- base::Sys.time()
[11:02:47.421]             {
[11:02:47.421]                 {
[11:02:47.421]                   {
[11:02:47.421]                     {
[11:02:47.421]                       base::local({
[11:02:47.421]                         has_future <- base::requireNamespace("future", 
[11:02:47.421]                           quietly = TRUE)
[11:02:47.421]                         if (has_future) {
[11:02:47.421]                           ns <- base::getNamespace("future")
[11:02:47.421]                           version <- ns[[".package"]][["version"]]
[11:02:47.421]                           if (is.null(version)) 
[11:02:47.421]                             version <- utils::packageVersion("future")
[11:02:47.421]                         }
[11:02:47.421]                         else {
[11:02:47.421]                           version <- NULL
[11:02:47.421]                         }
[11:02:47.421]                         if (!has_future || version < "1.8.0") {
[11:02:47.421]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:47.421]                             "", base::R.version$version.string), 
[11:02:47.421]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:47.421]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:47.421]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:47.421]                               "release", "version")], collapse = " "), 
[11:02:47.421]                             hostname = base::Sys.info()[["nodename"]])
[11:02:47.421]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:47.421]                             info)
[11:02:47.421]                           info <- base::paste(info, collapse = "; ")
[11:02:47.421]                           if (!has_future) {
[11:02:47.421]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:47.421]                               info)
[11:02:47.421]                           }
[11:02:47.421]                           else {
[11:02:47.421]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:47.421]                               info, version)
[11:02:47.421]                           }
[11:02:47.421]                           base::stop(msg)
[11:02:47.421]                         }
[11:02:47.421]                       })
[11:02:47.421]                     }
[11:02:47.421]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:47.421]                     base::options(mc.cores = 1L)
[11:02:47.421]                   }
[11:02:47.421]                   ...future.strategy.old <- future::plan("list")
[11:02:47.421]                   options(future.plan = NULL)
[11:02:47.421]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:47.421]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:47.421]                 }
[11:02:47.421]                 ...future.workdir <- getwd()
[11:02:47.421]             }
[11:02:47.421]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:47.421]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:47.421]         }
[11:02:47.421]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:47.421]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:47.421]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:47.421]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:47.421]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:47.421]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:47.421]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:47.421]             base::names(...future.oldOptions))
[11:02:47.421]     }
[11:02:47.421]     if (FALSE) {
[11:02:47.421]     }
[11:02:47.421]     else {
[11:02:47.421]         if (TRUE) {
[11:02:47.421]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:47.421]                 open = "w")
[11:02:47.421]         }
[11:02:47.421]         else {
[11:02:47.421]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:47.421]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:47.421]         }
[11:02:47.421]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:47.421]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:47.421]             base::sink(type = "output", split = FALSE)
[11:02:47.421]             base::close(...future.stdout)
[11:02:47.421]         }, add = TRUE)
[11:02:47.421]     }
[11:02:47.421]     ...future.frame <- base::sys.nframe()
[11:02:47.421]     ...future.conditions <- base::list()
[11:02:47.421]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:47.421]     if (FALSE) {
[11:02:47.421]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:47.421]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:47.421]     }
[11:02:47.421]     ...future.result <- base::tryCatch({
[11:02:47.421]         base::withCallingHandlers({
[11:02:47.421]             ...future.value <- base::withVisible(base::local({
[11:02:47.421]                 ...future.makeSendCondition <- base::local({
[11:02:47.421]                   sendCondition <- NULL
[11:02:47.421]                   function(frame = 1L) {
[11:02:47.421]                     if (is.function(sendCondition)) 
[11:02:47.421]                       return(sendCondition)
[11:02:47.421]                     ns <- getNamespace("parallel")
[11:02:47.421]                     if (exists("sendData", mode = "function", 
[11:02:47.421]                       envir = ns)) {
[11:02:47.421]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:47.421]                         envir = ns)
[11:02:47.421]                       envir <- sys.frame(frame)
[11:02:47.421]                       master <- NULL
[11:02:47.421]                       while (!identical(envir, .GlobalEnv) && 
[11:02:47.421]                         !identical(envir, emptyenv())) {
[11:02:47.421]                         if (exists("master", mode = "list", envir = envir, 
[11:02:47.421]                           inherits = FALSE)) {
[11:02:47.421]                           master <- get("master", mode = "list", 
[11:02:47.421]                             envir = envir, inherits = FALSE)
[11:02:47.421]                           if (inherits(master, c("SOCKnode", 
[11:02:47.421]                             "SOCK0node"))) {
[11:02:47.421]                             sendCondition <<- function(cond) {
[11:02:47.421]                               data <- list(type = "VALUE", value = cond, 
[11:02:47.421]                                 success = TRUE)
[11:02:47.421]                               parallel_sendData(master, data)
[11:02:47.421]                             }
[11:02:47.421]                             return(sendCondition)
[11:02:47.421]                           }
[11:02:47.421]                         }
[11:02:47.421]                         frame <- frame + 1L
[11:02:47.421]                         envir <- sys.frame(frame)
[11:02:47.421]                       }
[11:02:47.421]                     }
[11:02:47.421]                     sendCondition <<- function(cond) NULL
[11:02:47.421]                   }
[11:02:47.421]                 })
[11:02:47.421]                 withCallingHandlers({
[11:02:47.421]                   list(a = 1, b = 42L, c = stop("Nah!"))
[11:02:47.421]                 }, immediateCondition = function(cond) {
[11:02:47.421]                   sendCondition <- ...future.makeSendCondition()
[11:02:47.421]                   sendCondition(cond)
[11:02:47.421]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:47.421]                   {
[11:02:47.421]                     inherits <- base::inherits
[11:02:47.421]                     invokeRestart <- base::invokeRestart
[11:02:47.421]                     is.null <- base::is.null
[11:02:47.421]                     muffled <- FALSE
[11:02:47.421]                     if (inherits(cond, "message")) {
[11:02:47.421]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:47.421]                       if (muffled) 
[11:02:47.421]                         invokeRestart("muffleMessage")
[11:02:47.421]                     }
[11:02:47.421]                     else if (inherits(cond, "warning")) {
[11:02:47.421]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:47.421]                       if (muffled) 
[11:02:47.421]                         invokeRestart("muffleWarning")
[11:02:47.421]                     }
[11:02:47.421]                     else if (inherits(cond, "condition")) {
[11:02:47.421]                       if (!is.null(pattern)) {
[11:02:47.421]                         computeRestarts <- base::computeRestarts
[11:02:47.421]                         grepl <- base::grepl
[11:02:47.421]                         restarts <- computeRestarts(cond)
[11:02:47.421]                         for (restart in restarts) {
[11:02:47.421]                           name <- restart$name
[11:02:47.421]                           if (is.null(name)) 
[11:02:47.421]                             next
[11:02:47.421]                           if (!grepl(pattern, name)) 
[11:02:47.421]                             next
[11:02:47.421]                           invokeRestart(restart)
[11:02:47.421]                           muffled <- TRUE
[11:02:47.421]                           break
[11:02:47.421]                         }
[11:02:47.421]                       }
[11:02:47.421]                     }
[11:02:47.421]                     invisible(muffled)
[11:02:47.421]                   }
[11:02:47.421]                   muffleCondition(cond)
[11:02:47.421]                 })
[11:02:47.421]             }))
[11:02:47.421]             future::FutureResult(value = ...future.value$value, 
[11:02:47.421]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:47.421]                   ...future.rng), globalenv = if (FALSE) 
[11:02:47.421]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:47.421]                     ...future.globalenv.names))
[11:02:47.421]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:47.421]         }, condition = base::local({
[11:02:47.421]             c <- base::c
[11:02:47.421]             inherits <- base::inherits
[11:02:47.421]             invokeRestart <- base::invokeRestart
[11:02:47.421]             length <- base::length
[11:02:47.421]             list <- base::list
[11:02:47.421]             seq.int <- base::seq.int
[11:02:47.421]             signalCondition <- base::signalCondition
[11:02:47.421]             sys.calls <- base::sys.calls
[11:02:47.421]             `[[` <- base::`[[`
[11:02:47.421]             `+` <- base::`+`
[11:02:47.421]             `<<-` <- base::`<<-`
[11:02:47.421]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:47.421]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:47.421]                   3L)]
[11:02:47.421]             }
[11:02:47.421]             function(cond) {
[11:02:47.421]                 is_error <- inherits(cond, "error")
[11:02:47.421]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:47.421]                   NULL)
[11:02:47.421]                 if (is_error) {
[11:02:47.421]                   sessionInformation <- function() {
[11:02:47.421]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:47.421]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:47.421]                       search = base::search(), system = base::Sys.info())
[11:02:47.421]                   }
[11:02:47.421]                   ...future.conditions[[length(...future.conditions) + 
[11:02:47.421]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:47.421]                     cond$call), session = sessionInformation(), 
[11:02:47.421]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:47.421]                   signalCondition(cond)
[11:02:47.421]                 }
[11:02:47.421]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:47.421]                 "immediateCondition"))) {
[11:02:47.421]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:47.421]                   ...future.conditions[[length(...future.conditions) + 
[11:02:47.421]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:47.421]                   if (TRUE && !signal) {
[11:02:47.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:47.421]                     {
[11:02:47.421]                       inherits <- base::inherits
[11:02:47.421]                       invokeRestart <- base::invokeRestart
[11:02:47.421]                       is.null <- base::is.null
[11:02:47.421]                       muffled <- FALSE
[11:02:47.421]                       if (inherits(cond, "message")) {
[11:02:47.421]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:47.421]                         if (muffled) 
[11:02:47.421]                           invokeRestart("muffleMessage")
[11:02:47.421]                       }
[11:02:47.421]                       else if (inherits(cond, "warning")) {
[11:02:47.421]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:47.421]                         if (muffled) 
[11:02:47.421]                           invokeRestart("muffleWarning")
[11:02:47.421]                       }
[11:02:47.421]                       else if (inherits(cond, "condition")) {
[11:02:47.421]                         if (!is.null(pattern)) {
[11:02:47.421]                           computeRestarts <- base::computeRestarts
[11:02:47.421]                           grepl <- base::grepl
[11:02:47.421]                           restarts <- computeRestarts(cond)
[11:02:47.421]                           for (restart in restarts) {
[11:02:47.421]                             name <- restart$name
[11:02:47.421]                             if (is.null(name)) 
[11:02:47.421]                               next
[11:02:47.421]                             if (!grepl(pattern, name)) 
[11:02:47.421]                               next
[11:02:47.421]                             invokeRestart(restart)
[11:02:47.421]                             muffled <- TRUE
[11:02:47.421]                             break
[11:02:47.421]                           }
[11:02:47.421]                         }
[11:02:47.421]                       }
[11:02:47.421]                       invisible(muffled)
[11:02:47.421]                     }
[11:02:47.421]                     muffleCondition(cond, pattern = "^muffle")
[11:02:47.421]                   }
[11:02:47.421]                 }
[11:02:47.421]                 else {
[11:02:47.421]                   if (TRUE) {
[11:02:47.421]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:47.421]                     {
[11:02:47.421]                       inherits <- base::inherits
[11:02:47.421]                       invokeRestart <- base::invokeRestart
[11:02:47.421]                       is.null <- base::is.null
[11:02:47.421]                       muffled <- FALSE
[11:02:47.421]                       if (inherits(cond, "message")) {
[11:02:47.421]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:47.421]                         if (muffled) 
[11:02:47.421]                           invokeRestart("muffleMessage")
[11:02:47.421]                       }
[11:02:47.421]                       else if (inherits(cond, "warning")) {
[11:02:47.421]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:47.421]                         if (muffled) 
[11:02:47.421]                           invokeRestart("muffleWarning")
[11:02:47.421]                       }
[11:02:47.421]                       else if (inherits(cond, "condition")) {
[11:02:47.421]                         if (!is.null(pattern)) {
[11:02:47.421]                           computeRestarts <- base::computeRestarts
[11:02:47.421]                           grepl <- base::grepl
[11:02:47.421]                           restarts <- computeRestarts(cond)
[11:02:47.421]                           for (restart in restarts) {
[11:02:47.421]                             name <- restart$name
[11:02:47.421]                             if (is.null(name)) 
[11:02:47.421]                               next
[11:02:47.421]                             if (!grepl(pattern, name)) 
[11:02:47.421]                               next
[11:02:47.421]                             invokeRestart(restart)
[11:02:47.421]                             muffled <- TRUE
[11:02:47.421]                             break
[11:02:47.421]                           }
[11:02:47.421]                         }
[11:02:47.421]                       }
[11:02:47.421]                       invisible(muffled)
[11:02:47.421]                     }
[11:02:47.421]                     muffleCondition(cond, pattern = "^muffle")
[11:02:47.421]                   }
[11:02:47.421]                 }
[11:02:47.421]             }
[11:02:47.421]         }))
[11:02:47.421]     }, error = function(ex) {
[11:02:47.421]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:47.421]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:47.421]                 ...future.rng), started = ...future.startTime, 
[11:02:47.421]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:47.421]             version = "1.8"), class = "FutureResult")
[11:02:47.421]     }, finally = {
[11:02:47.421]         if (!identical(...future.workdir, getwd())) 
[11:02:47.421]             setwd(...future.workdir)
[11:02:47.421]         {
[11:02:47.421]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:47.421]                 ...future.oldOptions$nwarnings <- NULL
[11:02:47.421]             }
[11:02:47.421]             base::options(...future.oldOptions)
[11:02:47.421]             if (.Platform$OS.type == "windows") {
[11:02:47.421]                 old_names <- names(...future.oldEnvVars)
[11:02:47.421]                 envs <- base::Sys.getenv()
[11:02:47.421]                 names <- names(envs)
[11:02:47.421]                 common <- intersect(names, old_names)
[11:02:47.421]                 added <- setdiff(names, old_names)
[11:02:47.421]                 removed <- setdiff(old_names, names)
[11:02:47.421]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:47.421]                   envs[common]]
[11:02:47.421]                 NAMES <- toupper(changed)
[11:02:47.421]                 args <- list()
[11:02:47.421]                 for (kk in seq_along(NAMES)) {
[11:02:47.421]                   name <- changed[[kk]]
[11:02:47.421]                   NAME <- NAMES[[kk]]
[11:02:47.421]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:47.421]                     next
[11:02:47.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:47.421]                 }
[11:02:47.421]                 NAMES <- toupper(added)
[11:02:47.421]                 for (kk in seq_along(NAMES)) {
[11:02:47.421]                   name <- added[[kk]]
[11:02:47.421]                   NAME <- NAMES[[kk]]
[11:02:47.421]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:47.421]                     next
[11:02:47.421]                   args[[name]] <- ""
[11:02:47.421]                 }
[11:02:47.421]                 NAMES <- toupper(removed)
[11:02:47.421]                 for (kk in seq_along(NAMES)) {
[11:02:47.421]                   name <- removed[[kk]]
[11:02:47.421]                   NAME <- NAMES[[kk]]
[11:02:47.421]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:47.421]                     next
[11:02:47.421]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:47.421]                 }
[11:02:47.421]                 if (length(args) > 0) 
[11:02:47.421]                   base::do.call(base::Sys.setenv, args = args)
[11:02:47.421]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:47.421]             }
[11:02:47.421]             else {
[11:02:47.421]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:47.421]             }
[11:02:47.421]             {
[11:02:47.421]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:47.421]                   0L) {
[11:02:47.421]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:47.421]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:47.421]                   base::options(opts)
[11:02:47.421]                 }
[11:02:47.421]                 {
[11:02:47.421]                   {
[11:02:47.421]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:47.421]                     NULL
[11:02:47.421]                   }
[11:02:47.421]                   options(future.plan = NULL)
[11:02:47.421]                   if (is.na(NA_character_)) 
[11:02:47.421]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:47.421]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:47.421]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:47.421]                     .init = FALSE)
[11:02:47.421]                 }
[11:02:47.421]             }
[11:02:47.421]         }
[11:02:47.421]     })
[11:02:47.421]     if (TRUE) {
[11:02:47.421]         base::sink(type = "output", split = FALSE)
[11:02:47.421]         if (TRUE) {
[11:02:47.421]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:47.421]         }
[11:02:47.421]         else {
[11:02:47.421]             ...future.result["stdout"] <- base::list(NULL)
[11:02:47.421]         }
[11:02:47.421]         base::close(...future.stdout)
[11:02:47.421]         ...future.stdout <- NULL
[11:02:47.421]     }
[11:02:47.421]     ...future.result$conditions <- ...future.conditions
[11:02:47.421]     ...future.result$finished <- base::Sys.time()
[11:02:47.421]     ...future.result
[11:02:47.421] }
[11:02:47.424] MultisessionFuture started
[11:02:47.424] - Launch lazy future ... done
[11:02:47.424] run() for ‘MultisessionFuture’ ... done
[11:02:47.466] receiveMessageFromWorker() for ClusterFuture ...
[11:02:47.466] - Validating connection of MultisessionFuture
[11:02:47.467] - received message: FutureResult
[11:02:47.467] - Received FutureResult
[11:02:47.467] - Erased future from FutureRegistry
[11:02:47.467] result() for ClusterFuture ...
[11:02:47.467] - result already collected: FutureResult
[11:02:47.467] result() for ClusterFuture ... done
[11:02:47.467] signalConditions() ...
[11:02:47.467]  - include = ‘immediateCondition’
[11:02:47.467]  - exclude = 
[11:02:47.467]  - resignal = FALSE
[11:02:47.468]  - Number of conditions: 1
[11:02:47.468] signalConditions() ... done
[11:02:47.468] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:47.468] A MultisessionFuture was resolved (result was not collected)
[11:02:47.468] getGlobalsAndPackages() ...
[11:02:47.468] Searching for globals...
[11:02:47.469] - globals found: [2] ‘list’, ‘stop’
[11:02:47.469] Searching for globals ... DONE
[11:02:47.469] Resolving globals: FALSE
[11:02:47.469] 
[11:02:47.469] 
[11:02:47.469] getGlobalsAndPackages() ... DONE
[11:02:47.470] run() for ‘Future’ ...
[11:02:47.470] - state: ‘created’
[11:02:47.470] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:47.484] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:47.484] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:47.484]   - Field: ‘node’
[11:02:47.484]   - Field: ‘label’
[11:02:47.484]   - Field: ‘local’
[11:02:47.484]   - Field: ‘owner’
[11:02:47.484]   - Field: ‘envir’
[11:02:47.485]   - Field: ‘workers’
[11:02:47.485]   - Field: ‘packages’
[11:02:47.485]   - Field: ‘gc’
[11:02:47.485]   - Field: ‘conditions’
[11:02:47.485]   - Field: ‘persistent’
[11:02:47.485]   - Field: ‘expr’
[11:02:47.485]   - Field: ‘uuid’
[11:02:47.485]   - Field: ‘seed’
[11:02:47.485]   - Field: ‘version’
[11:02:47.485]   - Field: ‘result’
[11:02:47.485]   - Field: ‘asynchronous’
[11:02:47.486]   - Field: ‘calls’
[11:02:47.486]   - Field: ‘globals’
[11:02:47.486]   - Field: ‘stdout’
[11:02:47.486]   - Field: ‘earlySignal’
[11:02:47.486]   - Field: ‘lazy’
[11:02:47.486]   - Field: ‘state’
[11:02:47.486] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:47.486] - Launch lazy future ...
[11:02:47.486] Packages needed by the future expression (n = 0): <none>
[11:02:47.486] Packages needed by future strategies (n = 0): <none>
[11:02:47.487] {
[11:02:47.487]     {
[11:02:47.487]         {
[11:02:47.487]             ...future.startTime <- base::Sys.time()
[11:02:47.487]             {
[11:02:47.487]                 {
[11:02:47.487]                   {
[11:02:47.487]                     {
[11:02:47.487]                       base::local({
[11:02:47.487]                         has_future <- base::requireNamespace("future", 
[11:02:47.487]                           quietly = TRUE)
[11:02:47.487]                         if (has_future) {
[11:02:47.487]                           ns <- base::getNamespace("future")
[11:02:47.487]                           version <- ns[[".package"]][["version"]]
[11:02:47.487]                           if (is.null(version)) 
[11:02:47.487]                             version <- utils::packageVersion("future")
[11:02:47.487]                         }
[11:02:47.487]                         else {
[11:02:47.487]                           version <- NULL
[11:02:47.487]                         }
[11:02:47.487]                         if (!has_future || version < "1.8.0") {
[11:02:47.487]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:47.487]                             "", base::R.version$version.string), 
[11:02:47.487]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:47.487]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:47.487]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:47.487]                               "release", "version")], collapse = " "), 
[11:02:47.487]                             hostname = base::Sys.info()[["nodename"]])
[11:02:47.487]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:47.487]                             info)
[11:02:47.487]                           info <- base::paste(info, collapse = "; ")
[11:02:47.487]                           if (!has_future) {
[11:02:47.487]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:47.487]                               info)
[11:02:47.487]                           }
[11:02:47.487]                           else {
[11:02:47.487]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:47.487]                               info, version)
[11:02:47.487]                           }
[11:02:47.487]                           base::stop(msg)
[11:02:47.487]                         }
[11:02:47.487]                       })
[11:02:47.487]                     }
[11:02:47.487]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:47.487]                     base::options(mc.cores = 1L)
[11:02:47.487]                   }
[11:02:47.487]                   ...future.strategy.old <- future::plan("list")
[11:02:47.487]                   options(future.plan = NULL)
[11:02:47.487]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:47.487]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:47.487]                 }
[11:02:47.487]                 ...future.workdir <- getwd()
[11:02:47.487]             }
[11:02:47.487]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:47.487]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:47.487]         }
[11:02:47.487]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:47.487]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:47.487]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:47.487]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:47.487]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:47.487]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:47.487]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:47.487]             base::names(...future.oldOptions))
[11:02:47.487]     }
[11:02:47.487]     if (FALSE) {
[11:02:47.487]     }
[11:02:47.487]     else {
[11:02:47.487]         if (TRUE) {
[11:02:47.487]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:47.487]                 open = "w")
[11:02:47.487]         }
[11:02:47.487]         else {
[11:02:47.487]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:47.487]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:47.487]         }
[11:02:47.487]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:47.487]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:47.487]             base::sink(type = "output", split = FALSE)
[11:02:47.487]             base::close(...future.stdout)
[11:02:47.487]         }, add = TRUE)
[11:02:47.487]     }
[11:02:47.487]     ...future.frame <- base::sys.nframe()
[11:02:47.487]     ...future.conditions <- base::list()
[11:02:47.487]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:47.487]     if (FALSE) {
[11:02:47.487]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:47.487]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:47.487]     }
[11:02:47.487]     ...future.result <- base::tryCatch({
[11:02:47.487]         base::withCallingHandlers({
[11:02:47.487]             ...future.value <- base::withVisible(base::local({
[11:02:47.487]                 ...future.makeSendCondition <- base::local({
[11:02:47.487]                   sendCondition <- NULL
[11:02:47.487]                   function(frame = 1L) {
[11:02:47.487]                     if (is.function(sendCondition)) 
[11:02:47.487]                       return(sendCondition)
[11:02:47.487]                     ns <- getNamespace("parallel")
[11:02:47.487]                     if (exists("sendData", mode = "function", 
[11:02:47.487]                       envir = ns)) {
[11:02:47.487]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:47.487]                         envir = ns)
[11:02:47.487]                       envir <- sys.frame(frame)
[11:02:47.487]                       master <- NULL
[11:02:47.487]                       while (!identical(envir, .GlobalEnv) && 
[11:02:47.487]                         !identical(envir, emptyenv())) {
[11:02:47.487]                         if (exists("master", mode = "list", envir = envir, 
[11:02:47.487]                           inherits = FALSE)) {
[11:02:47.487]                           master <- get("master", mode = "list", 
[11:02:47.487]                             envir = envir, inherits = FALSE)
[11:02:47.487]                           if (inherits(master, c("SOCKnode", 
[11:02:47.487]                             "SOCK0node"))) {
[11:02:47.487]                             sendCondition <<- function(cond) {
[11:02:47.487]                               data <- list(type = "VALUE", value = cond, 
[11:02:47.487]                                 success = TRUE)
[11:02:47.487]                               parallel_sendData(master, data)
[11:02:47.487]                             }
[11:02:47.487]                             return(sendCondition)
[11:02:47.487]                           }
[11:02:47.487]                         }
[11:02:47.487]                         frame <- frame + 1L
[11:02:47.487]                         envir <- sys.frame(frame)
[11:02:47.487]                       }
[11:02:47.487]                     }
[11:02:47.487]                     sendCondition <<- function(cond) NULL
[11:02:47.487]                   }
[11:02:47.487]                 })
[11:02:47.487]                 withCallingHandlers({
[11:02:47.487]                   list(a = 1, b = 42L, c = stop("Nah!"))
[11:02:47.487]                 }, immediateCondition = function(cond) {
[11:02:47.487]                   sendCondition <- ...future.makeSendCondition()
[11:02:47.487]                   sendCondition(cond)
[11:02:47.487]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:47.487]                   {
[11:02:47.487]                     inherits <- base::inherits
[11:02:47.487]                     invokeRestart <- base::invokeRestart
[11:02:47.487]                     is.null <- base::is.null
[11:02:47.487]                     muffled <- FALSE
[11:02:47.487]                     if (inherits(cond, "message")) {
[11:02:47.487]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:47.487]                       if (muffled) 
[11:02:47.487]                         invokeRestart("muffleMessage")
[11:02:47.487]                     }
[11:02:47.487]                     else if (inherits(cond, "warning")) {
[11:02:47.487]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:47.487]                       if (muffled) 
[11:02:47.487]                         invokeRestart("muffleWarning")
[11:02:47.487]                     }
[11:02:47.487]                     else if (inherits(cond, "condition")) {
[11:02:47.487]                       if (!is.null(pattern)) {
[11:02:47.487]                         computeRestarts <- base::computeRestarts
[11:02:47.487]                         grepl <- base::grepl
[11:02:47.487]                         restarts <- computeRestarts(cond)
[11:02:47.487]                         for (restart in restarts) {
[11:02:47.487]                           name <- restart$name
[11:02:47.487]                           if (is.null(name)) 
[11:02:47.487]                             next
[11:02:47.487]                           if (!grepl(pattern, name)) 
[11:02:47.487]                             next
[11:02:47.487]                           invokeRestart(restart)
[11:02:47.487]                           muffled <- TRUE
[11:02:47.487]                           break
[11:02:47.487]                         }
[11:02:47.487]                       }
[11:02:47.487]                     }
[11:02:47.487]                     invisible(muffled)
[11:02:47.487]                   }
[11:02:47.487]                   muffleCondition(cond)
[11:02:47.487]                 })
[11:02:47.487]             }))
[11:02:47.487]             future::FutureResult(value = ...future.value$value, 
[11:02:47.487]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:47.487]                   ...future.rng), globalenv = if (FALSE) 
[11:02:47.487]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:47.487]                     ...future.globalenv.names))
[11:02:47.487]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:47.487]         }, condition = base::local({
[11:02:47.487]             c <- base::c
[11:02:47.487]             inherits <- base::inherits
[11:02:47.487]             invokeRestart <- base::invokeRestart
[11:02:47.487]             length <- base::length
[11:02:47.487]             list <- base::list
[11:02:47.487]             seq.int <- base::seq.int
[11:02:47.487]             signalCondition <- base::signalCondition
[11:02:47.487]             sys.calls <- base::sys.calls
[11:02:47.487]             `[[` <- base::`[[`
[11:02:47.487]             `+` <- base::`+`
[11:02:47.487]             `<<-` <- base::`<<-`
[11:02:47.487]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:47.487]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:47.487]                   3L)]
[11:02:47.487]             }
[11:02:47.487]             function(cond) {
[11:02:47.487]                 is_error <- inherits(cond, "error")
[11:02:47.487]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:47.487]                   NULL)
[11:02:47.487]                 if (is_error) {
[11:02:47.487]                   sessionInformation <- function() {
[11:02:47.487]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:47.487]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:47.487]                       search = base::search(), system = base::Sys.info())
[11:02:47.487]                   }
[11:02:47.487]                   ...future.conditions[[length(...future.conditions) + 
[11:02:47.487]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:47.487]                     cond$call), session = sessionInformation(), 
[11:02:47.487]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:47.487]                   signalCondition(cond)
[11:02:47.487]                 }
[11:02:47.487]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:47.487]                 "immediateCondition"))) {
[11:02:47.487]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:47.487]                   ...future.conditions[[length(...future.conditions) + 
[11:02:47.487]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:47.487]                   if (TRUE && !signal) {
[11:02:47.487]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:47.487]                     {
[11:02:47.487]                       inherits <- base::inherits
[11:02:47.487]                       invokeRestart <- base::invokeRestart
[11:02:47.487]                       is.null <- base::is.null
[11:02:47.487]                       muffled <- FALSE
[11:02:47.487]                       if (inherits(cond, "message")) {
[11:02:47.487]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:47.487]                         if (muffled) 
[11:02:47.487]                           invokeRestart("muffleMessage")
[11:02:47.487]                       }
[11:02:47.487]                       else if (inherits(cond, "warning")) {
[11:02:47.487]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:47.487]                         if (muffled) 
[11:02:47.487]                           invokeRestart("muffleWarning")
[11:02:47.487]                       }
[11:02:47.487]                       else if (inherits(cond, "condition")) {
[11:02:47.487]                         if (!is.null(pattern)) {
[11:02:47.487]                           computeRestarts <- base::computeRestarts
[11:02:47.487]                           grepl <- base::grepl
[11:02:47.487]                           restarts <- computeRestarts(cond)
[11:02:47.487]                           for (restart in restarts) {
[11:02:47.487]                             name <- restart$name
[11:02:47.487]                             if (is.null(name)) 
[11:02:47.487]                               next
[11:02:47.487]                             if (!grepl(pattern, name)) 
[11:02:47.487]                               next
[11:02:47.487]                             invokeRestart(restart)
[11:02:47.487]                             muffled <- TRUE
[11:02:47.487]                             break
[11:02:47.487]                           }
[11:02:47.487]                         }
[11:02:47.487]                       }
[11:02:47.487]                       invisible(muffled)
[11:02:47.487]                     }
[11:02:47.487]                     muffleCondition(cond, pattern = "^muffle")
[11:02:47.487]                   }
[11:02:47.487]                 }
[11:02:47.487]                 else {
[11:02:47.487]                   if (TRUE) {
[11:02:47.487]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:47.487]                     {
[11:02:47.487]                       inherits <- base::inherits
[11:02:47.487]                       invokeRestart <- base::invokeRestart
[11:02:47.487]                       is.null <- base::is.null
[11:02:47.487]                       muffled <- FALSE
[11:02:47.487]                       if (inherits(cond, "message")) {
[11:02:47.487]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:47.487]                         if (muffled) 
[11:02:47.487]                           invokeRestart("muffleMessage")
[11:02:47.487]                       }
[11:02:47.487]                       else if (inherits(cond, "warning")) {
[11:02:47.487]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:47.487]                         if (muffled) 
[11:02:47.487]                           invokeRestart("muffleWarning")
[11:02:47.487]                       }
[11:02:47.487]                       else if (inherits(cond, "condition")) {
[11:02:47.487]                         if (!is.null(pattern)) {
[11:02:47.487]                           computeRestarts <- base::computeRestarts
[11:02:47.487]                           grepl <- base::grepl
[11:02:47.487]                           restarts <- computeRestarts(cond)
[11:02:47.487]                           for (restart in restarts) {
[11:02:47.487]                             name <- restart$name
[11:02:47.487]                             if (is.null(name)) 
[11:02:47.487]                               next
[11:02:47.487]                             if (!grepl(pattern, name)) 
[11:02:47.487]                               next
[11:02:47.487]                             invokeRestart(restart)
[11:02:47.487]                             muffled <- TRUE
[11:02:47.487]                             break
[11:02:47.487]                           }
[11:02:47.487]                         }
[11:02:47.487]                       }
[11:02:47.487]                       invisible(muffled)
[11:02:47.487]                     }
[11:02:47.487]                     muffleCondition(cond, pattern = "^muffle")
[11:02:47.487]                   }
[11:02:47.487]                 }
[11:02:47.487]             }
[11:02:47.487]         }))
[11:02:47.487]     }, error = function(ex) {
[11:02:47.487]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:47.487]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:47.487]                 ...future.rng), started = ...future.startTime, 
[11:02:47.487]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:47.487]             version = "1.8"), class = "FutureResult")
[11:02:47.487]     }, finally = {
[11:02:47.487]         if (!identical(...future.workdir, getwd())) 
[11:02:47.487]             setwd(...future.workdir)
[11:02:47.487]         {
[11:02:47.487]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:47.487]                 ...future.oldOptions$nwarnings <- NULL
[11:02:47.487]             }
[11:02:47.487]             base::options(...future.oldOptions)
[11:02:47.487]             if (.Platform$OS.type == "windows") {
[11:02:47.487]                 old_names <- names(...future.oldEnvVars)
[11:02:47.487]                 envs <- base::Sys.getenv()
[11:02:47.487]                 names <- names(envs)
[11:02:47.487]                 common <- intersect(names, old_names)
[11:02:47.487]                 added <- setdiff(names, old_names)
[11:02:47.487]                 removed <- setdiff(old_names, names)
[11:02:47.487]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:47.487]                   envs[common]]
[11:02:47.487]                 NAMES <- toupper(changed)
[11:02:47.487]                 args <- list()
[11:02:47.487]                 for (kk in seq_along(NAMES)) {
[11:02:47.487]                   name <- changed[[kk]]
[11:02:47.487]                   NAME <- NAMES[[kk]]
[11:02:47.487]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:47.487]                     next
[11:02:47.487]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:47.487]                 }
[11:02:47.487]                 NAMES <- toupper(added)
[11:02:47.487]                 for (kk in seq_along(NAMES)) {
[11:02:47.487]                   name <- added[[kk]]
[11:02:47.487]                   NAME <- NAMES[[kk]]
[11:02:47.487]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:47.487]                     next
[11:02:47.487]                   args[[name]] <- ""
[11:02:47.487]                 }
[11:02:47.487]                 NAMES <- toupper(removed)
[11:02:47.487]                 for (kk in seq_along(NAMES)) {
[11:02:47.487]                   name <- removed[[kk]]
[11:02:47.487]                   NAME <- NAMES[[kk]]
[11:02:47.487]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:47.487]                     next
[11:02:47.487]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:47.487]                 }
[11:02:47.487]                 if (length(args) > 0) 
[11:02:47.487]                   base::do.call(base::Sys.setenv, args = args)
[11:02:47.487]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:47.487]             }
[11:02:47.487]             else {
[11:02:47.487]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:47.487]             }
[11:02:47.487]             {
[11:02:47.487]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:47.487]                   0L) {
[11:02:47.487]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:47.487]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:47.487]                   base::options(opts)
[11:02:47.487]                 }
[11:02:47.487]                 {
[11:02:47.487]                   {
[11:02:47.487]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:47.487]                     NULL
[11:02:47.487]                   }
[11:02:47.487]                   options(future.plan = NULL)
[11:02:47.487]                   if (is.na(NA_character_)) 
[11:02:47.487]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:47.487]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:47.487]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:47.487]                     .init = FALSE)
[11:02:47.487]                 }
[11:02:47.487]             }
[11:02:47.487]         }
[11:02:47.487]     })
[11:02:47.487]     if (TRUE) {
[11:02:47.487]         base::sink(type = "output", split = FALSE)
[11:02:47.487]         if (TRUE) {
[11:02:47.487]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:47.487]         }
[11:02:47.487]         else {
[11:02:47.487]             ...future.result["stdout"] <- base::list(NULL)
[11:02:47.487]         }
[11:02:47.487]         base::close(...future.stdout)
[11:02:47.487]         ...future.stdout <- NULL
[11:02:47.487]     }
[11:02:47.487]     ...future.result$conditions <- ...future.conditions
[11:02:47.487]     ...future.result$finished <- base::Sys.time()
[11:02:47.487]     ...future.result
[11:02:47.487] }
[11:02:47.490] MultisessionFuture started
[11:02:47.490] - Launch lazy future ... done
[11:02:47.490] run() for ‘MultisessionFuture’ ... done
[11:02:47.532] receiveMessageFromWorker() for ClusterFuture ...
[11:02:47.532] - Validating connection of MultisessionFuture
[11:02:47.533] - received message: FutureResult
[11:02:47.533] - Received FutureResult
[11:02:47.533] - Erased future from FutureRegistry
[11:02:47.533] result() for ClusterFuture ...
[11:02:47.533] - result already collected: FutureResult
[11:02:47.533] result() for ClusterFuture ... done
[11:02:47.533] signalConditions() ...
[11:02:47.533]  - include = ‘immediateCondition’
[11:02:47.533]  - exclude = 
[11:02:47.533]  - resignal = FALSE
[11:02:47.533]  - Number of conditions: 1
[11:02:47.533] signalConditions() ... done
[11:02:47.534] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:47.534] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = 2 ... DONE
- result = FALSE, recursive = Inf ...
[11:02:47.534] getGlobalsAndPackages() ...
[11:02:47.534] Searching for globals...
[11:02:47.535] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[11:02:47.535] Searching for globals ... DONE
[11:02:47.535] Resolving globals: FALSE
[11:02:47.535] 
[11:02:47.536] 
[11:02:47.536] getGlobalsAndPackages() ... DONE
[11:02:47.536] run() for ‘Future’ ...
[11:02:47.536] - state: ‘created’
[11:02:47.536] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:47.549] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:47.550] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:47.550]   - Field: ‘node’
[11:02:47.550]   - Field: ‘label’
[11:02:47.550]   - Field: ‘local’
[11:02:47.550]   - Field: ‘owner’
[11:02:47.550]   - Field: ‘envir’
[11:02:47.550]   - Field: ‘workers’
[11:02:47.550]   - Field: ‘packages’
[11:02:47.550]   - Field: ‘gc’
[11:02:47.550]   - Field: ‘conditions’
[11:02:47.551]   - Field: ‘persistent’
[11:02:47.551]   - Field: ‘expr’
[11:02:47.551]   - Field: ‘uuid’
[11:02:47.551]   - Field: ‘seed’
[11:02:47.551]   - Field: ‘version’
[11:02:47.551]   - Field: ‘result’
[11:02:47.551]   - Field: ‘asynchronous’
[11:02:47.551]   - Field: ‘calls’
[11:02:47.551]   - Field: ‘globals’
[11:02:47.551]   - Field: ‘stdout’
[11:02:47.551]   - Field: ‘earlySignal’
[11:02:47.551]   - Field: ‘lazy’
[11:02:47.552]   - Field: ‘state’
[11:02:47.552] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:47.552] - Launch lazy future ...
[11:02:47.552] Packages needed by the future expression (n = 0): <none>
[11:02:47.552] Packages needed by future strategies (n = 0): <none>
[11:02:47.552] {
[11:02:47.552]     {
[11:02:47.552]         {
[11:02:47.552]             ...future.startTime <- base::Sys.time()
[11:02:47.552]             {
[11:02:47.552]                 {
[11:02:47.552]                   {
[11:02:47.552]                     {
[11:02:47.552]                       base::local({
[11:02:47.552]                         has_future <- base::requireNamespace("future", 
[11:02:47.552]                           quietly = TRUE)
[11:02:47.552]                         if (has_future) {
[11:02:47.552]                           ns <- base::getNamespace("future")
[11:02:47.552]                           version <- ns[[".package"]][["version"]]
[11:02:47.552]                           if (is.null(version)) 
[11:02:47.552]                             version <- utils::packageVersion("future")
[11:02:47.552]                         }
[11:02:47.552]                         else {
[11:02:47.552]                           version <- NULL
[11:02:47.552]                         }
[11:02:47.552]                         if (!has_future || version < "1.8.0") {
[11:02:47.552]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:47.552]                             "", base::R.version$version.string), 
[11:02:47.552]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:47.552]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:47.552]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:47.552]                               "release", "version")], collapse = " "), 
[11:02:47.552]                             hostname = base::Sys.info()[["nodename"]])
[11:02:47.552]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:47.552]                             info)
[11:02:47.552]                           info <- base::paste(info, collapse = "; ")
[11:02:47.552]                           if (!has_future) {
[11:02:47.552]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:47.552]                               info)
[11:02:47.552]                           }
[11:02:47.552]                           else {
[11:02:47.552]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:47.552]                               info, version)
[11:02:47.552]                           }
[11:02:47.552]                           base::stop(msg)
[11:02:47.552]                         }
[11:02:47.552]                       })
[11:02:47.552]                     }
[11:02:47.552]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:47.552]                     base::options(mc.cores = 1L)
[11:02:47.552]                   }
[11:02:47.552]                   ...future.strategy.old <- future::plan("list")
[11:02:47.552]                   options(future.plan = NULL)
[11:02:47.552]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:47.552]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:47.552]                 }
[11:02:47.552]                 ...future.workdir <- getwd()
[11:02:47.552]             }
[11:02:47.552]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:47.552]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:47.552]         }
[11:02:47.552]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:47.552]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:47.552]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:47.552]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:47.552]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:47.552]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:47.552]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:47.552]             base::names(...future.oldOptions))
[11:02:47.552]     }
[11:02:47.552]     if (FALSE) {
[11:02:47.552]     }
[11:02:47.552]     else {
[11:02:47.552]         if (TRUE) {
[11:02:47.552]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:47.552]                 open = "w")
[11:02:47.552]         }
[11:02:47.552]         else {
[11:02:47.552]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:47.552]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:47.552]         }
[11:02:47.552]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:47.552]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:47.552]             base::sink(type = "output", split = FALSE)
[11:02:47.552]             base::close(...future.stdout)
[11:02:47.552]         }, add = TRUE)
[11:02:47.552]     }
[11:02:47.552]     ...future.frame <- base::sys.nframe()
[11:02:47.552]     ...future.conditions <- base::list()
[11:02:47.552]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:47.552]     if (FALSE) {
[11:02:47.552]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:47.552]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:47.552]     }
[11:02:47.552]     ...future.result <- base::tryCatch({
[11:02:47.552]         base::withCallingHandlers({
[11:02:47.552]             ...future.value <- base::withVisible(base::local({
[11:02:47.552]                 ...future.makeSendCondition <- base::local({
[11:02:47.552]                   sendCondition <- NULL
[11:02:47.552]                   function(frame = 1L) {
[11:02:47.552]                     if (is.function(sendCondition)) 
[11:02:47.552]                       return(sendCondition)
[11:02:47.552]                     ns <- getNamespace("parallel")
[11:02:47.552]                     if (exists("sendData", mode = "function", 
[11:02:47.552]                       envir = ns)) {
[11:02:47.552]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:47.552]                         envir = ns)
[11:02:47.552]                       envir <- sys.frame(frame)
[11:02:47.552]                       master <- NULL
[11:02:47.552]                       while (!identical(envir, .GlobalEnv) && 
[11:02:47.552]                         !identical(envir, emptyenv())) {
[11:02:47.552]                         if (exists("master", mode = "list", envir = envir, 
[11:02:47.552]                           inherits = FALSE)) {
[11:02:47.552]                           master <- get("master", mode = "list", 
[11:02:47.552]                             envir = envir, inherits = FALSE)
[11:02:47.552]                           if (inherits(master, c("SOCKnode", 
[11:02:47.552]                             "SOCK0node"))) {
[11:02:47.552]                             sendCondition <<- function(cond) {
[11:02:47.552]                               data <- list(type = "VALUE", value = cond, 
[11:02:47.552]                                 success = TRUE)
[11:02:47.552]                               parallel_sendData(master, data)
[11:02:47.552]                             }
[11:02:47.552]                             return(sendCondition)
[11:02:47.552]                           }
[11:02:47.552]                         }
[11:02:47.552]                         frame <- frame + 1L
[11:02:47.552]                         envir <- sys.frame(frame)
[11:02:47.552]                       }
[11:02:47.552]                     }
[11:02:47.552]                     sendCondition <<- function(cond) NULL
[11:02:47.552]                   }
[11:02:47.552]                 })
[11:02:47.552]                 withCallingHandlers({
[11:02:47.552]                   {
[11:02:47.552]                     Sys.sleep(0.5)
[11:02:47.552]                     list(a = 1, b = 42L)
[11:02:47.552]                   }
[11:02:47.552]                 }, immediateCondition = function(cond) {
[11:02:47.552]                   sendCondition <- ...future.makeSendCondition()
[11:02:47.552]                   sendCondition(cond)
[11:02:47.552]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:47.552]                   {
[11:02:47.552]                     inherits <- base::inherits
[11:02:47.552]                     invokeRestart <- base::invokeRestart
[11:02:47.552]                     is.null <- base::is.null
[11:02:47.552]                     muffled <- FALSE
[11:02:47.552]                     if (inherits(cond, "message")) {
[11:02:47.552]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:47.552]                       if (muffled) 
[11:02:47.552]                         invokeRestart("muffleMessage")
[11:02:47.552]                     }
[11:02:47.552]                     else if (inherits(cond, "warning")) {
[11:02:47.552]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:47.552]                       if (muffled) 
[11:02:47.552]                         invokeRestart("muffleWarning")
[11:02:47.552]                     }
[11:02:47.552]                     else if (inherits(cond, "condition")) {
[11:02:47.552]                       if (!is.null(pattern)) {
[11:02:47.552]                         computeRestarts <- base::computeRestarts
[11:02:47.552]                         grepl <- base::grepl
[11:02:47.552]                         restarts <- computeRestarts(cond)
[11:02:47.552]                         for (restart in restarts) {
[11:02:47.552]                           name <- restart$name
[11:02:47.552]                           if (is.null(name)) 
[11:02:47.552]                             next
[11:02:47.552]                           if (!grepl(pattern, name)) 
[11:02:47.552]                             next
[11:02:47.552]                           invokeRestart(restart)
[11:02:47.552]                           muffled <- TRUE
[11:02:47.552]                           break
[11:02:47.552]                         }
[11:02:47.552]                       }
[11:02:47.552]                     }
[11:02:47.552]                     invisible(muffled)
[11:02:47.552]                   }
[11:02:47.552]                   muffleCondition(cond)
[11:02:47.552]                 })
[11:02:47.552]             }))
[11:02:47.552]             future::FutureResult(value = ...future.value$value, 
[11:02:47.552]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:47.552]                   ...future.rng), globalenv = if (FALSE) 
[11:02:47.552]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:47.552]                     ...future.globalenv.names))
[11:02:47.552]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:47.552]         }, condition = base::local({
[11:02:47.552]             c <- base::c
[11:02:47.552]             inherits <- base::inherits
[11:02:47.552]             invokeRestart <- base::invokeRestart
[11:02:47.552]             length <- base::length
[11:02:47.552]             list <- base::list
[11:02:47.552]             seq.int <- base::seq.int
[11:02:47.552]             signalCondition <- base::signalCondition
[11:02:47.552]             sys.calls <- base::sys.calls
[11:02:47.552]             `[[` <- base::`[[`
[11:02:47.552]             `+` <- base::`+`
[11:02:47.552]             `<<-` <- base::`<<-`
[11:02:47.552]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:47.552]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:47.552]                   3L)]
[11:02:47.552]             }
[11:02:47.552]             function(cond) {
[11:02:47.552]                 is_error <- inherits(cond, "error")
[11:02:47.552]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:47.552]                   NULL)
[11:02:47.552]                 if (is_error) {
[11:02:47.552]                   sessionInformation <- function() {
[11:02:47.552]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:47.552]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:47.552]                       search = base::search(), system = base::Sys.info())
[11:02:47.552]                   }
[11:02:47.552]                   ...future.conditions[[length(...future.conditions) + 
[11:02:47.552]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:47.552]                     cond$call), session = sessionInformation(), 
[11:02:47.552]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:47.552]                   signalCondition(cond)
[11:02:47.552]                 }
[11:02:47.552]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:47.552]                 "immediateCondition"))) {
[11:02:47.552]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:47.552]                   ...future.conditions[[length(...future.conditions) + 
[11:02:47.552]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:47.552]                   if (TRUE && !signal) {
[11:02:47.552]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:47.552]                     {
[11:02:47.552]                       inherits <- base::inherits
[11:02:47.552]                       invokeRestart <- base::invokeRestart
[11:02:47.552]                       is.null <- base::is.null
[11:02:47.552]                       muffled <- FALSE
[11:02:47.552]                       if (inherits(cond, "message")) {
[11:02:47.552]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:47.552]                         if (muffled) 
[11:02:47.552]                           invokeRestart("muffleMessage")
[11:02:47.552]                       }
[11:02:47.552]                       else if (inherits(cond, "warning")) {
[11:02:47.552]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:47.552]                         if (muffled) 
[11:02:47.552]                           invokeRestart("muffleWarning")
[11:02:47.552]                       }
[11:02:47.552]                       else if (inherits(cond, "condition")) {
[11:02:47.552]                         if (!is.null(pattern)) {
[11:02:47.552]                           computeRestarts <- base::computeRestarts
[11:02:47.552]                           grepl <- base::grepl
[11:02:47.552]                           restarts <- computeRestarts(cond)
[11:02:47.552]                           for (restart in restarts) {
[11:02:47.552]                             name <- restart$name
[11:02:47.552]                             if (is.null(name)) 
[11:02:47.552]                               next
[11:02:47.552]                             if (!grepl(pattern, name)) 
[11:02:47.552]                               next
[11:02:47.552]                             invokeRestart(restart)
[11:02:47.552]                             muffled <- TRUE
[11:02:47.552]                             break
[11:02:47.552]                           }
[11:02:47.552]                         }
[11:02:47.552]                       }
[11:02:47.552]                       invisible(muffled)
[11:02:47.552]                     }
[11:02:47.552]                     muffleCondition(cond, pattern = "^muffle")
[11:02:47.552]                   }
[11:02:47.552]                 }
[11:02:47.552]                 else {
[11:02:47.552]                   if (TRUE) {
[11:02:47.552]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:47.552]                     {
[11:02:47.552]                       inherits <- base::inherits
[11:02:47.552]                       invokeRestart <- base::invokeRestart
[11:02:47.552]                       is.null <- base::is.null
[11:02:47.552]                       muffled <- FALSE
[11:02:47.552]                       if (inherits(cond, "message")) {
[11:02:47.552]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:47.552]                         if (muffled) 
[11:02:47.552]                           invokeRestart("muffleMessage")
[11:02:47.552]                       }
[11:02:47.552]                       else if (inherits(cond, "warning")) {
[11:02:47.552]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:47.552]                         if (muffled) 
[11:02:47.552]                           invokeRestart("muffleWarning")
[11:02:47.552]                       }
[11:02:47.552]                       else if (inherits(cond, "condition")) {
[11:02:47.552]                         if (!is.null(pattern)) {
[11:02:47.552]                           computeRestarts <- base::computeRestarts
[11:02:47.552]                           grepl <- base::grepl
[11:02:47.552]                           restarts <- computeRestarts(cond)
[11:02:47.552]                           for (restart in restarts) {
[11:02:47.552]                             name <- restart$name
[11:02:47.552]                             if (is.null(name)) 
[11:02:47.552]                               next
[11:02:47.552]                             if (!grepl(pattern, name)) 
[11:02:47.552]                               next
[11:02:47.552]                             invokeRestart(restart)
[11:02:47.552]                             muffled <- TRUE
[11:02:47.552]                             break
[11:02:47.552]                           }
[11:02:47.552]                         }
[11:02:47.552]                       }
[11:02:47.552]                       invisible(muffled)
[11:02:47.552]                     }
[11:02:47.552]                     muffleCondition(cond, pattern = "^muffle")
[11:02:47.552]                   }
[11:02:47.552]                 }
[11:02:47.552]             }
[11:02:47.552]         }))
[11:02:47.552]     }, error = function(ex) {
[11:02:47.552]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:47.552]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:47.552]                 ...future.rng), started = ...future.startTime, 
[11:02:47.552]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:47.552]             version = "1.8"), class = "FutureResult")
[11:02:47.552]     }, finally = {
[11:02:47.552]         if (!identical(...future.workdir, getwd())) 
[11:02:47.552]             setwd(...future.workdir)
[11:02:47.552]         {
[11:02:47.552]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:47.552]                 ...future.oldOptions$nwarnings <- NULL
[11:02:47.552]             }
[11:02:47.552]             base::options(...future.oldOptions)
[11:02:47.552]             if (.Platform$OS.type == "windows") {
[11:02:47.552]                 old_names <- names(...future.oldEnvVars)
[11:02:47.552]                 envs <- base::Sys.getenv()
[11:02:47.552]                 names <- names(envs)
[11:02:47.552]                 common <- intersect(names, old_names)
[11:02:47.552]                 added <- setdiff(names, old_names)
[11:02:47.552]                 removed <- setdiff(old_names, names)
[11:02:47.552]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:47.552]                   envs[common]]
[11:02:47.552]                 NAMES <- toupper(changed)
[11:02:47.552]                 args <- list()
[11:02:47.552]                 for (kk in seq_along(NAMES)) {
[11:02:47.552]                   name <- changed[[kk]]
[11:02:47.552]                   NAME <- NAMES[[kk]]
[11:02:47.552]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:47.552]                     next
[11:02:47.552]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:47.552]                 }
[11:02:47.552]                 NAMES <- toupper(added)
[11:02:47.552]                 for (kk in seq_along(NAMES)) {
[11:02:47.552]                   name <- added[[kk]]
[11:02:47.552]                   NAME <- NAMES[[kk]]
[11:02:47.552]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:47.552]                     next
[11:02:47.552]                   args[[name]] <- ""
[11:02:47.552]                 }
[11:02:47.552]                 NAMES <- toupper(removed)
[11:02:47.552]                 for (kk in seq_along(NAMES)) {
[11:02:47.552]                   name <- removed[[kk]]
[11:02:47.552]                   NAME <- NAMES[[kk]]
[11:02:47.552]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:47.552]                     next
[11:02:47.552]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:47.552]                 }
[11:02:47.552]                 if (length(args) > 0) 
[11:02:47.552]                   base::do.call(base::Sys.setenv, args = args)
[11:02:47.552]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:47.552]             }
[11:02:47.552]             else {
[11:02:47.552]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:47.552]             }
[11:02:47.552]             {
[11:02:47.552]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:47.552]                   0L) {
[11:02:47.552]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:47.552]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:47.552]                   base::options(opts)
[11:02:47.552]                 }
[11:02:47.552]                 {
[11:02:47.552]                   {
[11:02:47.552]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:47.552]                     NULL
[11:02:47.552]                   }
[11:02:47.552]                   options(future.plan = NULL)
[11:02:47.552]                   if (is.na(NA_character_)) 
[11:02:47.552]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:47.552]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:47.552]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:47.552]                     .init = FALSE)
[11:02:47.552]                 }
[11:02:47.552]             }
[11:02:47.552]         }
[11:02:47.552]     })
[11:02:47.552]     if (TRUE) {
[11:02:47.552]         base::sink(type = "output", split = FALSE)
[11:02:47.552]         if (TRUE) {
[11:02:47.552]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:47.552]         }
[11:02:47.552]         else {
[11:02:47.552]             ...future.result["stdout"] <- base::list(NULL)
[11:02:47.552]         }
[11:02:47.552]         base::close(...future.stdout)
[11:02:47.552]         ...future.stdout <- NULL
[11:02:47.552]     }
[11:02:47.552]     ...future.result$conditions <- ...future.conditions
[11:02:47.552]     ...future.result$finished <- base::Sys.time()
[11:02:47.552]     ...future.result
[11:02:47.552] }
[11:02:47.555] MultisessionFuture started
[11:02:47.555] - Launch lazy future ... done
[11:02:47.555] run() for ‘MultisessionFuture’ ... done
[11:02:48.098] receiveMessageFromWorker() for ClusterFuture ...
[11:02:48.098] - Validating connection of MultisessionFuture
[11:02:48.098] - received message: FutureResult
[11:02:48.098] - Received FutureResult
[11:02:48.099] - Erased future from FutureRegistry
[11:02:48.099] result() for ClusterFuture ...
[11:02:48.099] - result already collected: FutureResult
[11:02:48.099] result() for ClusterFuture ... done
[11:02:48.099] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:48.099] A MultisessionFuture was resolved (result was not collected)
[11:02:48.099] getGlobalsAndPackages() ...
[11:02:48.099] Searching for globals...
[11:02:48.100] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[11:02:48.101] Searching for globals ... DONE
[11:02:48.101] Resolving globals: FALSE
[11:02:48.101] 
[11:02:48.101] 
[11:02:48.101] getGlobalsAndPackages() ... DONE
[11:02:48.101] run() for ‘Future’ ...
[11:02:48.101] - state: ‘created’
[11:02:48.102] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:48.115] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:48.115] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:48.115]   - Field: ‘node’
[11:02:48.116]   - Field: ‘label’
[11:02:48.116]   - Field: ‘local’
[11:02:48.116]   - Field: ‘owner’
[11:02:48.116]   - Field: ‘envir’
[11:02:48.116]   - Field: ‘workers’
[11:02:48.116]   - Field: ‘packages’
[11:02:48.116]   - Field: ‘gc’
[11:02:48.116]   - Field: ‘conditions’
[11:02:48.116]   - Field: ‘persistent’
[11:02:48.116]   - Field: ‘expr’
[11:02:48.116]   - Field: ‘uuid’
[11:02:48.117]   - Field: ‘seed’
[11:02:48.117]   - Field: ‘version’
[11:02:48.117]   - Field: ‘result’
[11:02:48.117]   - Field: ‘asynchronous’
[11:02:48.117]   - Field: ‘calls’
[11:02:48.117]   - Field: ‘globals’
[11:02:48.117]   - Field: ‘stdout’
[11:02:48.117]   - Field: ‘earlySignal’
[11:02:48.117]   - Field: ‘lazy’
[11:02:48.117]   - Field: ‘state’
[11:02:48.117] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:48.117] - Launch lazy future ...
[11:02:48.118] Packages needed by the future expression (n = 0): <none>
[11:02:48.118] Packages needed by future strategies (n = 0): <none>
[11:02:48.118] {
[11:02:48.118]     {
[11:02:48.118]         {
[11:02:48.118]             ...future.startTime <- base::Sys.time()
[11:02:48.118]             {
[11:02:48.118]                 {
[11:02:48.118]                   {
[11:02:48.118]                     {
[11:02:48.118]                       base::local({
[11:02:48.118]                         has_future <- base::requireNamespace("future", 
[11:02:48.118]                           quietly = TRUE)
[11:02:48.118]                         if (has_future) {
[11:02:48.118]                           ns <- base::getNamespace("future")
[11:02:48.118]                           version <- ns[[".package"]][["version"]]
[11:02:48.118]                           if (is.null(version)) 
[11:02:48.118]                             version <- utils::packageVersion("future")
[11:02:48.118]                         }
[11:02:48.118]                         else {
[11:02:48.118]                           version <- NULL
[11:02:48.118]                         }
[11:02:48.118]                         if (!has_future || version < "1.8.0") {
[11:02:48.118]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:48.118]                             "", base::R.version$version.string), 
[11:02:48.118]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:48.118]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:48.118]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:48.118]                               "release", "version")], collapse = " "), 
[11:02:48.118]                             hostname = base::Sys.info()[["nodename"]])
[11:02:48.118]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:48.118]                             info)
[11:02:48.118]                           info <- base::paste(info, collapse = "; ")
[11:02:48.118]                           if (!has_future) {
[11:02:48.118]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:48.118]                               info)
[11:02:48.118]                           }
[11:02:48.118]                           else {
[11:02:48.118]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:48.118]                               info, version)
[11:02:48.118]                           }
[11:02:48.118]                           base::stop(msg)
[11:02:48.118]                         }
[11:02:48.118]                       })
[11:02:48.118]                     }
[11:02:48.118]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:48.118]                     base::options(mc.cores = 1L)
[11:02:48.118]                   }
[11:02:48.118]                   ...future.strategy.old <- future::plan("list")
[11:02:48.118]                   options(future.plan = NULL)
[11:02:48.118]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:48.118]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:48.118]                 }
[11:02:48.118]                 ...future.workdir <- getwd()
[11:02:48.118]             }
[11:02:48.118]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:48.118]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:48.118]         }
[11:02:48.118]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:48.118]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:48.118]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:48.118]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:48.118]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:48.118]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:48.118]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:48.118]             base::names(...future.oldOptions))
[11:02:48.118]     }
[11:02:48.118]     if (FALSE) {
[11:02:48.118]     }
[11:02:48.118]     else {
[11:02:48.118]         if (TRUE) {
[11:02:48.118]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:48.118]                 open = "w")
[11:02:48.118]         }
[11:02:48.118]         else {
[11:02:48.118]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:48.118]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:48.118]         }
[11:02:48.118]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:48.118]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:48.118]             base::sink(type = "output", split = FALSE)
[11:02:48.118]             base::close(...future.stdout)
[11:02:48.118]         }, add = TRUE)
[11:02:48.118]     }
[11:02:48.118]     ...future.frame <- base::sys.nframe()
[11:02:48.118]     ...future.conditions <- base::list()
[11:02:48.118]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:48.118]     if (FALSE) {
[11:02:48.118]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:48.118]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:48.118]     }
[11:02:48.118]     ...future.result <- base::tryCatch({
[11:02:48.118]         base::withCallingHandlers({
[11:02:48.118]             ...future.value <- base::withVisible(base::local({
[11:02:48.118]                 ...future.makeSendCondition <- base::local({
[11:02:48.118]                   sendCondition <- NULL
[11:02:48.118]                   function(frame = 1L) {
[11:02:48.118]                     if (is.function(sendCondition)) 
[11:02:48.118]                       return(sendCondition)
[11:02:48.118]                     ns <- getNamespace("parallel")
[11:02:48.118]                     if (exists("sendData", mode = "function", 
[11:02:48.118]                       envir = ns)) {
[11:02:48.118]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:48.118]                         envir = ns)
[11:02:48.118]                       envir <- sys.frame(frame)
[11:02:48.118]                       master <- NULL
[11:02:48.118]                       while (!identical(envir, .GlobalEnv) && 
[11:02:48.118]                         !identical(envir, emptyenv())) {
[11:02:48.118]                         if (exists("master", mode = "list", envir = envir, 
[11:02:48.118]                           inherits = FALSE)) {
[11:02:48.118]                           master <- get("master", mode = "list", 
[11:02:48.118]                             envir = envir, inherits = FALSE)
[11:02:48.118]                           if (inherits(master, c("SOCKnode", 
[11:02:48.118]                             "SOCK0node"))) {
[11:02:48.118]                             sendCondition <<- function(cond) {
[11:02:48.118]                               data <- list(type = "VALUE", value = cond, 
[11:02:48.118]                                 success = TRUE)
[11:02:48.118]                               parallel_sendData(master, data)
[11:02:48.118]                             }
[11:02:48.118]                             return(sendCondition)
[11:02:48.118]                           }
[11:02:48.118]                         }
[11:02:48.118]                         frame <- frame + 1L
[11:02:48.118]                         envir <- sys.frame(frame)
[11:02:48.118]                       }
[11:02:48.118]                     }
[11:02:48.118]                     sendCondition <<- function(cond) NULL
[11:02:48.118]                   }
[11:02:48.118]                 })
[11:02:48.118]                 withCallingHandlers({
[11:02:48.118]                   {
[11:02:48.118]                     Sys.sleep(0.5)
[11:02:48.118]                     list(a = 1, b = 42L)
[11:02:48.118]                   }
[11:02:48.118]                 }, immediateCondition = function(cond) {
[11:02:48.118]                   sendCondition <- ...future.makeSendCondition()
[11:02:48.118]                   sendCondition(cond)
[11:02:48.118]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:48.118]                   {
[11:02:48.118]                     inherits <- base::inherits
[11:02:48.118]                     invokeRestart <- base::invokeRestart
[11:02:48.118]                     is.null <- base::is.null
[11:02:48.118]                     muffled <- FALSE
[11:02:48.118]                     if (inherits(cond, "message")) {
[11:02:48.118]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:48.118]                       if (muffled) 
[11:02:48.118]                         invokeRestart("muffleMessage")
[11:02:48.118]                     }
[11:02:48.118]                     else if (inherits(cond, "warning")) {
[11:02:48.118]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:48.118]                       if (muffled) 
[11:02:48.118]                         invokeRestart("muffleWarning")
[11:02:48.118]                     }
[11:02:48.118]                     else if (inherits(cond, "condition")) {
[11:02:48.118]                       if (!is.null(pattern)) {
[11:02:48.118]                         computeRestarts <- base::computeRestarts
[11:02:48.118]                         grepl <- base::grepl
[11:02:48.118]                         restarts <- computeRestarts(cond)
[11:02:48.118]                         for (restart in restarts) {
[11:02:48.118]                           name <- restart$name
[11:02:48.118]                           if (is.null(name)) 
[11:02:48.118]                             next
[11:02:48.118]                           if (!grepl(pattern, name)) 
[11:02:48.118]                             next
[11:02:48.118]                           invokeRestart(restart)
[11:02:48.118]                           muffled <- TRUE
[11:02:48.118]                           break
[11:02:48.118]                         }
[11:02:48.118]                       }
[11:02:48.118]                     }
[11:02:48.118]                     invisible(muffled)
[11:02:48.118]                   }
[11:02:48.118]                   muffleCondition(cond)
[11:02:48.118]                 })
[11:02:48.118]             }))
[11:02:48.118]             future::FutureResult(value = ...future.value$value, 
[11:02:48.118]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:48.118]                   ...future.rng), globalenv = if (FALSE) 
[11:02:48.118]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:48.118]                     ...future.globalenv.names))
[11:02:48.118]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:48.118]         }, condition = base::local({
[11:02:48.118]             c <- base::c
[11:02:48.118]             inherits <- base::inherits
[11:02:48.118]             invokeRestart <- base::invokeRestart
[11:02:48.118]             length <- base::length
[11:02:48.118]             list <- base::list
[11:02:48.118]             seq.int <- base::seq.int
[11:02:48.118]             signalCondition <- base::signalCondition
[11:02:48.118]             sys.calls <- base::sys.calls
[11:02:48.118]             `[[` <- base::`[[`
[11:02:48.118]             `+` <- base::`+`
[11:02:48.118]             `<<-` <- base::`<<-`
[11:02:48.118]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:48.118]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:48.118]                   3L)]
[11:02:48.118]             }
[11:02:48.118]             function(cond) {
[11:02:48.118]                 is_error <- inherits(cond, "error")
[11:02:48.118]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:48.118]                   NULL)
[11:02:48.118]                 if (is_error) {
[11:02:48.118]                   sessionInformation <- function() {
[11:02:48.118]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:48.118]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:48.118]                       search = base::search(), system = base::Sys.info())
[11:02:48.118]                   }
[11:02:48.118]                   ...future.conditions[[length(...future.conditions) + 
[11:02:48.118]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:48.118]                     cond$call), session = sessionInformation(), 
[11:02:48.118]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:48.118]                   signalCondition(cond)
[11:02:48.118]                 }
[11:02:48.118]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:48.118]                 "immediateCondition"))) {
[11:02:48.118]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:48.118]                   ...future.conditions[[length(...future.conditions) + 
[11:02:48.118]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:48.118]                   if (TRUE && !signal) {
[11:02:48.118]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:48.118]                     {
[11:02:48.118]                       inherits <- base::inherits
[11:02:48.118]                       invokeRestart <- base::invokeRestart
[11:02:48.118]                       is.null <- base::is.null
[11:02:48.118]                       muffled <- FALSE
[11:02:48.118]                       if (inherits(cond, "message")) {
[11:02:48.118]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:48.118]                         if (muffled) 
[11:02:48.118]                           invokeRestart("muffleMessage")
[11:02:48.118]                       }
[11:02:48.118]                       else if (inherits(cond, "warning")) {
[11:02:48.118]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:48.118]                         if (muffled) 
[11:02:48.118]                           invokeRestart("muffleWarning")
[11:02:48.118]                       }
[11:02:48.118]                       else if (inherits(cond, "condition")) {
[11:02:48.118]                         if (!is.null(pattern)) {
[11:02:48.118]                           computeRestarts <- base::computeRestarts
[11:02:48.118]                           grepl <- base::grepl
[11:02:48.118]                           restarts <- computeRestarts(cond)
[11:02:48.118]                           for (restart in restarts) {
[11:02:48.118]                             name <- restart$name
[11:02:48.118]                             if (is.null(name)) 
[11:02:48.118]                               next
[11:02:48.118]                             if (!grepl(pattern, name)) 
[11:02:48.118]                               next
[11:02:48.118]                             invokeRestart(restart)
[11:02:48.118]                             muffled <- TRUE
[11:02:48.118]                             break
[11:02:48.118]                           }
[11:02:48.118]                         }
[11:02:48.118]                       }
[11:02:48.118]                       invisible(muffled)
[11:02:48.118]                     }
[11:02:48.118]                     muffleCondition(cond, pattern = "^muffle")
[11:02:48.118]                   }
[11:02:48.118]                 }
[11:02:48.118]                 else {
[11:02:48.118]                   if (TRUE) {
[11:02:48.118]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:48.118]                     {
[11:02:48.118]                       inherits <- base::inherits
[11:02:48.118]                       invokeRestart <- base::invokeRestart
[11:02:48.118]                       is.null <- base::is.null
[11:02:48.118]                       muffled <- FALSE
[11:02:48.118]                       if (inherits(cond, "message")) {
[11:02:48.118]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:48.118]                         if (muffled) 
[11:02:48.118]                           invokeRestart("muffleMessage")
[11:02:48.118]                       }
[11:02:48.118]                       else if (inherits(cond, "warning")) {
[11:02:48.118]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:48.118]                         if (muffled) 
[11:02:48.118]                           invokeRestart("muffleWarning")
[11:02:48.118]                       }
[11:02:48.118]                       else if (inherits(cond, "condition")) {
[11:02:48.118]                         if (!is.null(pattern)) {
[11:02:48.118]                           computeRestarts <- base::computeRestarts
[11:02:48.118]                           grepl <- base::grepl
[11:02:48.118]                           restarts <- computeRestarts(cond)
[11:02:48.118]                           for (restart in restarts) {
[11:02:48.118]                             name <- restart$name
[11:02:48.118]                             if (is.null(name)) 
[11:02:48.118]                               next
[11:02:48.118]                             if (!grepl(pattern, name)) 
[11:02:48.118]                               next
[11:02:48.118]                             invokeRestart(restart)
[11:02:48.118]                             muffled <- TRUE
[11:02:48.118]                             break
[11:02:48.118]                           }
[11:02:48.118]                         }
[11:02:48.118]                       }
[11:02:48.118]                       invisible(muffled)
[11:02:48.118]                     }
[11:02:48.118]                     muffleCondition(cond, pattern = "^muffle")
[11:02:48.118]                   }
[11:02:48.118]                 }
[11:02:48.118]             }
[11:02:48.118]         }))
[11:02:48.118]     }, error = function(ex) {
[11:02:48.118]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:48.118]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:48.118]                 ...future.rng), started = ...future.startTime, 
[11:02:48.118]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:48.118]             version = "1.8"), class = "FutureResult")
[11:02:48.118]     }, finally = {
[11:02:48.118]         if (!identical(...future.workdir, getwd())) 
[11:02:48.118]             setwd(...future.workdir)
[11:02:48.118]         {
[11:02:48.118]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:48.118]                 ...future.oldOptions$nwarnings <- NULL
[11:02:48.118]             }
[11:02:48.118]             base::options(...future.oldOptions)
[11:02:48.118]             if (.Platform$OS.type == "windows") {
[11:02:48.118]                 old_names <- names(...future.oldEnvVars)
[11:02:48.118]                 envs <- base::Sys.getenv()
[11:02:48.118]                 names <- names(envs)
[11:02:48.118]                 common <- intersect(names, old_names)
[11:02:48.118]                 added <- setdiff(names, old_names)
[11:02:48.118]                 removed <- setdiff(old_names, names)
[11:02:48.118]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:48.118]                   envs[common]]
[11:02:48.118]                 NAMES <- toupper(changed)
[11:02:48.118]                 args <- list()
[11:02:48.118]                 for (kk in seq_along(NAMES)) {
[11:02:48.118]                   name <- changed[[kk]]
[11:02:48.118]                   NAME <- NAMES[[kk]]
[11:02:48.118]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:48.118]                     next
[11:02:48.118]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:48.118]                 }
[11:02:48.118]                 NAMES <- toupper(added)
[11:02:48.118]                 for (kk in seq_along(NAMES)) {
[11:02:48.118]                   name <- added[[kk]]
[11:02:48.118]                   NAME <- NAMES[[kk]]
[11:02:48.118]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:48.118]                     next
[11:02:48.118]                   args[[name]] <- ""
[11:02:48.118]                 }
[11:02:48.118]                 NAMES <- toupper(removed)
[11:02:48.118]                 for (kk in seq_along(NAMES)) {
[11:02:48.118]                   name <- removed[[kk]]
[11:02:48.118]                   NAME <- NAMES[[kk]]
[11:02:48.118]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:48.118]                     next
[11:02:48.118]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:48.118]                 }
[11:02:48.118]                 if (length(args) > 0) 
[11:02:48.118]                   base::do.call(base::Sys.setenv, args = args)
[11:02:48.118]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:48.118]             }
[11:02:48.118]             else {
[11:02:48.118]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:48.118]             }
[11:02:48.118]             {
[11:02:48.118]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:48.118]                   0L) {
[11:02:48.118]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:48.118]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:48.118]                   base::options(opts)
[11:02:48.118]                 }
[11:02:48.118]                 {
[11:02:48.118]                   {
[11:02:48.118]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:48.118]                     NULL
[11:02:48.118]                   }
[11:02:48.118]                   options(future.plan = NULL)
[11:02:48.118]                   if (is.na(NA_character_)) 
[11:02:48.118]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:48.118]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:48.118]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:48.118]                     .init = FALSE)
[11:02:48.118]                 }
[11:02:48.118]             }
[11:02:48.118]         }
[11:02:48.118]     })
[11:02:48.118]     if (TRUE) {
[11:02:48.118]         base::sink(type = "output", split = FALSE)
[11:02:48.118]         if (TRUE) {
[11:02:48.118]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:48.118]         }
[11:02:48.118]         else {
[11:02:48.118]             ...future.result["stdout"] <- base::list(NULL)
[11:02:48.118]         }
[11:02:48.118]         base::close(...future.stdout)
[11:02:48.118]         ...future.stdout <- NULL
[11:02:48.118]     }
[11:02:48.118]     ...future.result$conditions <- ...future.conditions
[11:02:48.118]     ...future.result$finished <- base::Sys.time()
[11:02:48.118]     ...future.result
[11:02:48.118] }
[11:02:48.121] MultisessionFuture started
[11:02:48.121] - Launch lazy future ... done
[11:02:48.121] run() for ‘MultisessionFuture’ ... done
[11:02:48.664] receiveMessageFromWorker() for ClusterFuture ...
[11:02:48.664] - Validating connection of MultisessionFuture
[11:02:48.664] - received message: FutureResult
[11:02:48.664] - Received FutureResult
[11:02:48.665] - Erased future from FutureRegistry
[11:02:48.665] result() for ClusterFuture ...
[11:02:48.665] - result already collected: FutureResult
[11:02:48.665] result() for ClusterFuture ... done
[11:02:48.665] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:48.665] A MultisessionFuture was resolved (result was not collected)
- w/ exception ...
[11:02:48.665] getGlobalsAndPackages() ...
[11:02:48.665] Searching for globals...
[11:02:48.666] - globals found: [2] ‘list’, ‘stop’
[11:02:48.666] Searching for globals ... DONE
[11:02:48.666] Resolving globals: FALSE
[11:02:48.667] 
[11:02:48.667] 
[11:02:48.667] getGlobalsAndPackages() ... DONE
[11:02:48.667] run() for ‘Future’ ...
[11:02:48.667] - state: ‘created’
[11:02:48.667] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:48.681] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:48.681] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:48.681]   - Field: ‘node’
[11:02:48.681]   - Field: ‘label’
[11:02:48.681]   - Field: ‘local’
[11:02:48.681]   - Field: ‘owner’
[11:02:48.681]   - Field: ‘envir’
[11:02:48.682]   - Field: ‘workers’
[11:02:48.682]   - Field: ‘packages’
[11:02:48.682]   - Field: ‘gc’
[11:02:48.682]   - Field: ‘conditions’
[11:02:48.682]   - Field: ‘persistent’
[11:02:48.682]   - Field: ‘expr’
[11:02:48.682]   - Field: ‘uuid’
[11:02:48.682]   - Field: ‘seed’
[11:02:48.684]   - Field: ‘version’
[11:02:48.684]   - Field: ‘result’
[11:02:48.684]   - Field: ‘asynchronous’
[11:02:48.684]   - Field: ‘calls’
[11:02:48.684]   - Field: ‘globals’
[11:02:48.684]   - Field: ‘stdout’
[11:02:48.685]   - Field: ‘earlySignal’
[11:02:48.685]   - Field: ‘lazy’
[11:02:48.685]   - Field: ‘state’
[11:02:48.685] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:48.685] - Launch lazy future ...
[11:02:48.685] Packages needed by the future expression (n = 0): <none>
[11:02:48.685] Packages needed by future strategies (n = 0): <none>
[11:02:48.686] {
[11:02:48.686]     {
[11:02:48.686]         {
[11:02:48.686]             ...future.startTime <- base::Sys.time()
[11:02:48.686]             {
[11:02:48.686]                 {
[11:02:48.686]                   {
[11:02:48.686]                     {
[11:02:48.686]                       base::local({
[11:02:48.686]                         has_future <- base::requireNamespace("future", 
[11:02:48.686]                           quietly = TRUE)
[11:02:48.686]                         if (has_future) {
[11:02:48.686]                           ns <- base::getNamespace("future")
[11:02:48.686]                           version <- ns[[".package"]][["version"]]
[11:02:48.686]                           if (is.null(version)) 
[11:02:48.686]                             version <- utils::packageVersion("future")
[11:02:48.686]                         }
[11:02:48.686]                         else {
[11:02:48.686]                           version <- NULL
[11:02:48.686]                         }
[11:02:48.686]                         if (!has_future || version < "1.8.0") {
[11:02:48.686]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:48.686]                             "", base::R.version$version.string), 
[11:02:48.686]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:48.686]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:48.686]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:48.686]                               "release", "version")], collapse = " "), 
[11:02:48.686]                             hostname = base::Sys.info()[["nodename"]])
[11:02:48.686]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:48.686]                             info)
[11:02:48.686]                           info <- base::paste(info, collapse = "; ")
[11:02:48.686]                           if (!has_future) {
[11:02:48.686]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:48.686]                               info)
[11:02:48.686]                           }
[11:02:48.686]                           else {
[11:02:48.686]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:48.686]                               info, version)
[11:02:48.686]                           }
[11:02:48.686]                           base::stop(msg)
[11:02:48.686]                         }
[11:02:48.686]                       })
[11:02:48.686]                     }
[11:02:48.686]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:48.686]                     base::options(mc.cores = 1L)
[11:02:48.686]                   }
[11:02:48.686]                   ...future.strategy.old <- future::plan("list")
[11:02:48.686]                   options(future.plan = NULL)
[11:02:48.686]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:48.686]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:48.686]                 }
[11:02:48.686]                 ...future.workdir <- getwd()
[11:02:48.686]             }
[11:02:48.686]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:48.686]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:48.686]         }
[11:02:48.686]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:48.686]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:48.686]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:48.686]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:48.686]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:48.686]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:48.686]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:48.686]             base::names(...future.oldOptions))
[11:02:48.686]     }
[11:02:48.686]     if (FALSE) {
[11:02:48.686]     }
[11:02:48.686]     else {
[11:02:48.686]         if (TRUE) {
[11:02:48.686]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:48.686]                 open = "w")
[11:02:48.686]         }
[11:02:48.686]         else {
[11:02:48.686]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:48.686]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:48.686]         }
[11:02:48.686]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:48.686]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:48.686]             base::sink(type = "output", split = FALSE)
[11:02:48.686]             base::close(...future.stdout)
[11:02:48.686]         }, add = TRUE)
[11:02:48.686]     }
[11:02:48.686]     ...future.frame <- base::sys.nframe()
[11:02:48.686]     ...future.conditions <- base::list()
[11:02:48.686]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:48.686]     if (FALSE) {
[11:02:48.686]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:48.686]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:48.686]     }
[11:02:48.686]     ...future.result <- base::tryCatch({
[11:02:48.686]         base::withCallingHandlers({
[11:02:48.686]             ...future.value <- base::withVisible(base::local({
[11:02:48.686]                 ...future.makeSendCondition <- base::local({
[11:02:48.686]                   sendCondition <- NULL
[11:02:48.686]                   function(frame = 1L) {
[11:02:48.686]                     if (is.function(sendCondition)) 
[11:02:48.686]                       return(sendCondition)
[11:02:48.686]                     ns <- getNamespace("parallel")
[11:02:48.686]                     if (exists("sendData", mode = "function", 
[11:02:48.686]                       envir = ns)) {
[11:02:48.686]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:48.686]                         envir = ns)
[11:02:48.686]                       envir <- sys.frame(frame)
[11:02:48.686]                       master <- NULL
[11:02:48.686]                       while (!identical(envir, .GlobalEnv) && 
[11:02:48.686]                         !identical(envir, emptyenv())) {
[11:02:48.686]                         if (exists("master", mode = "list", envir = envir, 
[11:02:48.686]                           inherits = FALSE)) {
[11:02:48.686]                           master <- get("master", mode = "list", 
[11:02:48.686]                             envir = envir, inherits = FALSE)
[11:02:48.686]                           if (inherits(master, c("SOCKnode", 
[11:02:48.686]                             "SOCK0node"))) {
[11:02:48.686]                             sendCondition <<- function(cond) {
[11:02:48.686]                               data <- list(type = "VALUE", value = cond, 
[11:02:48.686]                                 success = TRUE)
[11:02:48.686]                               parallel_sendData(master, data)
[11:02:48.686]                             }
[11:02:48.686]                             return(sendCondition)
[11:02:48.686]                           }
[11:02:48.686]                         }
[11:02:48.686]                         frame <- frame + 1L
[11:02:48.686]                         envir <- sys.frame(frame)
[11:02:48.686]                       }
[11:02:48.686]                     }
[11:02:48.686]                     sendCondition <<- function(cond) NULL
[11:02:48.686]                   }
[11:02:48.686]                 })
[11:02:48.686]                 withCallingHandlers({
[11:02:48.686]                   list(a = 1, b = 42L, c = stop("Nah!"))
[11:02:48.686]                 }, immediateCondition = function(cond) {
[11:02:48.686]                   sendCondition <- ...future.makeSendCondition()
[11:02:48.686]                   sendCondition(cond)
[11:02:48.686]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:48.686]                   {
[11:02:48.686]                     inherits <- base::inherits
[11:02:48.686]                     invokeRestart <- base::invokeRestart
[11:02:48.686]                     is.null <- base::is.null
[11:02:48.686]                     muffled <- FALSE
[11:02:48.686]                     if (inherits(cond, "message")) {
[11:02:48.686]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:48.686]                       if (muffled) 
[11:02:48.686]                         invokeRestart("muffleMessage")
[11:02:48.686]                     }
[11:02:48.686]                     else if (inherits(cond, "warning")) {
[11:02:48.686]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:48.686]                       if (muffled) 
[11:02:48.686]                         invokeRestart("muffleWarning")
[11:02:48.686]                     }
[11:02:48.686]                     else if (inherits(cond, "condition")) {
[11:02:48.686]                       if (!is.null(pattern)) {
[11:02:48.686]                         computeRestarts <- base::computeRestarts
[11:02:48.686]                         grepl <- base::grepl
[11:02:48.686]                         restarts <- computeRestarts(cond)
[11:02:48.686]                         for (restart in restarts) {
[11:02:48.686]                           name <- restart$name
[11:02:48.686]                           if (is.null(name)) 
[11:02:48.686]                             next
[11:02:48.686]                           if (!grepl(pattern, name)) 
[11:02:48.686]                             next
[11:02:48.686]                           invokeRestart(restart)
[11:02:48.686]                           muffled <- TRUE
[11:02:48.686]                           break
[11:02:48.686]                         }
[11:02:48.686]                       }
[11:02:48.686]                     }
[11:02:48.686]                     invisible(muffled)
[11:02:48.686]                   }
[11:02:48.686]                   muffleCondition(cond)
[11:02:48.686]                 })
[11:02:48.686]             }))
[11:02:48.686]             future::FutureResult(value = ...future.value$value, 
[11:02:48.686]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:48.686]                   ...future.rng), globalenv = if (FALSE) 
[11:02:48.686]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:48.686]                     ...future.globalenv.names))
[11:02:48.686]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:48.686]         }, condition = base::local({
[11:02:48.686]             c <- base::c
[11:02:48.686]             inherits <- base::inherits
[11:02:48.686]             invokeRestart <- base::invokeRestart
[11:02:48.686]             length <- base::length
[11:02:48.686]             list <- base::list
[11:02:48.686]             seq.int <- base::seq.int
[11:02:48.686]             signalCondition <- base::signalCondition
[11:02:48.686]             sys.calls <- base::sys.calls
[11:02:48.686]             `[[` <- base::`[[`
[11:02:48.686]             `+` <- base::`+`
[11:02:48.686]             `<<-` <- base::`<<-`
[11:02:48.686]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:48.686]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:48.686]                   3L)]
[11:02:48.686]             }
[11:02:48.686]             function(cond) {
[11:02:48.686]                 is_error <- inherits(cond, "error")
[11:02:48.686]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:48.686]                   NULL)
[11:02:48.686]                 if (is_error) {
[11:02:48.686]                   sessionInformation <- function() {
[11:02:48.686]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:48.686]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:48.686]                       search = base::search(), system = base::Sys.info())
[11:02:48.686]                   }
[11:02:48.686]                   ...future.conditions[[length(...future.conditions) + 
[11:02:48.686]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:48.686]                     cond$call), session = sessionInformation(), 
[11:02:48.686]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:48.686]                   signalCondition(cond)
[11:02:48.686]                 }
[11:02:48.686]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:48.686]                 "immediateCondition"))) {
[11:02:48.686]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:48.686]                   ...future.conditions[[length(...future.conditions) + 
[11:02:48.686]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:48.686]                   if (TRUE && !signal) {
[11:02:48.686]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:48.686]                     {
[11:02:48.686]                       inherits <- base::inherits
[11:02:48.686]                       invokeRestart <- base::invokeRestart
[11:02:48.686]                       is.null <- base::is.null
[11:02:48.686]                       muffled <- FALSE
[11:02:48.686]                       if (inherits(cond, "message")) {
[11:02:48.686]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:48.686]                         if (muffled) 
[11:02:48.686]                           invokeRestart("muffleMessage")
[11:02:48.686]                       }
[11:02:48.686]                       else if (inherits(cond, "warning")) {
[11:02:48.686]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:48.686]                         if (muffled) 
[11:02:48.686]                           invokeRestart("muffleWarning")
[11:02:48.686]                       }
[11:02:48.686]                       else if (inherits(cond, "condition")) {
[11:02:48.686]                         if (!is.null(pattern)) {
[11:02:48.686]                           computeRestarts <- base::computeRestarts
[11:02:48.686]                           grepl <- base::grepl
[11:02:48.686]                           restarts <- computeRestarts(cond)
[11:02:48.686]                           for (restart in restarts) {
[11:02:48.686]                             name <- restart$name
[11:02:48.686]                             if (is.null(name)) 
[11:02:48.686]                               next
[11:02:48.686]                             if (!grepl(pattern, name)) 
[11:02:48.686]                               next
[11:02:48.686]                             invokeRestart(restart)
[11:02:48.686]                             muffled <- TRUE
[11:02:48.686]                             break
[11:02:48.686]                           }
[11:02:48.686]                         }
[11:02:48.686]                       }
[11:02:48.686]                       invisible(muffled)
[11:02:48.686]                     }
[11:02:48.686]                     muffleCondition(cond, pattern = "^muffle")
[11:02:48.686]                   }
[11:02:48.686]                 }
[11:02:48.686]                 else {
[11:02:48.686]                   if (TRUE) {
[11:02:48.686]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:48.686]                     {
[11:02:48.686]                       inherits <- base::inherits
[11:02:48.686]                       invokeRestart <- base::invokeRestart
[11:02:48.686]                       is.null <- base::is.null
[11:02:48.686]                       muffled <- FALSE
[11:02:48.686]                       if (inherits(cond, "message")) {
[11:02:48.686]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:48.686]                         if (muffled) 
[11:02:48.686]                           invokeRestart("muffleMessage")
[11:02:48.686]                       }
[11:02:48.686]                       else if (inherits(cond, "warning")) {
[11:02:48.686]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:48.686]                         if (muffled) 
[11:02:48.686]                           invokeRestart("muffleWarning")
[11:02:48.686]                       }
[11:02:48.686]                       else if (inherits(cond, "condition")) {
[11:02:48.686]                         if (!is.null(pattern)) {
[11:02:48.686]                           computeRestarts <- base::computeRestarts
[11:02:48.686]                           grepl <- base::grepl
[11:02:48.686]                           restarts <- computeRestarts(cond)
[11:02:48.686]                           for (restart in restarts) {
[11:02:48.686]                             name <- restart$name
[11:02:48.686]                             if (is.null(name)) 
[11:02:48.686]                               next
[11:02:48.686]                             if (!grepl(pattern, name)) 
[11:02:48.686]                               next
[11:02:48.686]                             invokeRestart(restart)
[11:02:48.686]                             muffled <- TRUE
[11:02:48.686]                             break
[11:02:48.686]                           }
[11:02:48.686]                         }
[11:02:48.686]                       }
[11:02:48.686]                       invisible(muffled)
[11:02:48.686]                     }
[11:02:48.686]                     muffleCondition(cond, pattern = "^muffle")
[11:02:48.686]                   }
[11:02:48.686]                 }
[11:02:48.686]             }
[11:02:48.686]         }))
[11:02:48.686]     }, error = function(ex) {
[11:02:48.686]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:48.686]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:48.686]                 ...future.rng), started = ...future.startTime, 
[11:02:48.686]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:48.686]             version = "1.8"), class = "FutureResult")
[11:02:48.686]     }, finally = {
[11:02:48.686]         if (!identical(...future.workdir, getwd())) 
[11:02:48.686]             setwd(...future.workdir)
[11:02:48.686]         {
[11:02:48.686]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:48.686]                 ...future.oldOptions$nwarnings <- NULL
[11:02:48.686]             }
[11:02:48.686]             base::options(...future.oldOptions)
[11:02:48.686]             if (.Platform$OS.type == "windows") {
[11:02:48.686]                 old_names <- names(...future.oldEnvVars)
[11:02:48.686]                 envs <- base::Sys.getenv()
[11:02:48.686]                 names <- names(envs)
[11:02:48.686]                 common <- intersect(names, old_names)
[11:02:48.686]                 added <- setdiff(names, old_names)
[11:02:48.686]                 removed <- setdiff(old_names, names)
[11:02:48.686]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:48.686]                   envs[common]]
[11:02:48.686]                 NAMES <- toupper(changed)
[11:02:48.686]                 args <- list()
[11:02:48.686]                 for (kk in seq_along(NAMES)) {
[11:02:48.686]                   name <- changed[[kk]]
[11:02:48.686]                   NAME <- NAMES[[kk]]
[11:02:48.686]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:48.686]                     next
[11:02:48.686]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:48.686]                 }
[11:02:48.686]                 NAMES <- toupper(added)
[11:02:48.686]                 for (kk in seq_along(NAMES)) {
[11:02:48.686]                   name <- added[[kk]]
[11:02:48.686]                   NAME <- NAMES[[kk]]
[11:02:48.686]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:48.686]                     next
[11:02:48.686]                   args[[name]] <- ""
[11:02:48.686]                 }
[11:02:48.686]                 NAMES <- toupper(removed)
[11:02:48.686]                 for (kk in seq_along(NAMES)) {
[11:02:48.686]                   name <- removed[[kk]]
[11:02:48.686]                   NAME <- NAMES[[kk]]
[11:02:48.686]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:48.686]                     next
[11:02:48.686]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:48.686]                 }
[11:02:48.686]                 if (length(args) > 0) 
[11:02:48.686]                   base::do.call(base::Sys.setenv, args = args)
[11:02:48.686]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:48.686]             }
[11:02:48.686]             else {
[11:02:48.686]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:48.686]             }
[11:02:48.686]             {
[11:02:48.686]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:48.686]                   0L) {
[11:02:48.686]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:48.686]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:48.686]                   base::options(opts)
[11:02:48.686]                 }
[11:02:48.686]                 {
[11:02:48.686]                   {
[11:02:48.686]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:48.686]                     NULL
[11:02:48.686]                   }
[11:02:48.686]                   options(future.plan = NULL)
[11:02:48.686]                   if (is.na(NA_character_)) 
[11:02:48.686]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:48.686]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:48.686]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:48.686]                     .init = FALSE)
[11:02:48.686]                 }
[11:02:48.686]             }
[11:02:48.686]         }
[11:02:48.686]     })
[11:02:48.686]     if (TRUE) {
[11:02:48.686]         base::sink(type = "output", split = FALSE)
[11:02:48.686]         if (TRUE) {
[11:02:48.686]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:48.686]         }
[11:02:48.686]         else {
[11:02:48.686]             ...future.result["stdout"] <- base::list(NULL)
[11:02:48.686]         }
[11:02:48.686]         base::close(...future.stdout)
[11:02:48.686]         ...future.stdout <- NULL
[11:02:48.686]     }
[11:02:48.686]     ...future.result$conditions <- ...future.conditions
[11:02:48.686]     ...future.result$finished <- base::Sys.time()
[11:02:48.686]     ...future.result
[11:02:48.686] }
[11:02:48.689] MultisessionFuture started
[11:02:48.689] - Launch lazy future ... done
[11:02:48.689] run() for ‘MultisessionFuture’ ... done
[11:02:48.730] receiveMessageFromWorker() for ClusterFuture ...
[11:02:48.730] - Validating connection of MultisessionFuture
[11:02:48.731] - received message: FutureResult
[11:02:48.731] - Received FutureResult
[11:02:48.731] - Erased future from FutureRegistry
[11:02:48.731] result() for ClusterFuture ...
[11:02:48.731] - result already collected: FutureResult
[11:02:48.731] result() for ClusterFuture ... done
[11:02:48.731] signalConditions() ...
[11:02:48.732]  - include = ‘immediateCondition’
[11:02:48.732]  - exclude = 
[11:02:48.732]  - resignal = FALSE
[11:02:48.732]  - Number of conditions: 1
[11:02:48.732] signalConditions() ... done
[11:02:48.732] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:48.732] A MultisessionFuture was resolved (result was not collected)
[11:02:48.732] getGlobalsAndPackages() ...
[11:02:48.732] Searching for globals...
[11:02:48.733] - globals found: [2] ‘list’, ‘stop’
[11:02:48.733] Searching for globals ... DONE
[11:02:48.733] Resolving globals: FALSE
[11:02:48.733] 
[11:02:48.733] 
[11:02:48.733] getGlobalsAndPackages() ... DONE
[11:02:48.734] run() for ‘Future’ ...
[11:02:48.734] - state: ‘created’
[11:02:48.734] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:48.747] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:48.747] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:48.748]   - Field: ‘node’
[11:02:48.748]   - Field: ‘label’
[11:02:48.748]   - Field: ‘local’
[11:02:48.748]   - Field: ‘owner’
[11:02:48.748]   - Field: ‘envir’
[11:02:48.748]   - Field: ‘workers’
[11:02:48.748]   - Field: ‘packages’
[11:02:48.748]   - Field: ‘gc’
[11:02:48.748]   - Field: ‘conditions’
[11:02:48.748]   - Field: ‘persistent’
[11:02:48.748]   - Field: ‘expr’
[11:02:48.748]   - Field: ‘uuid’
[11:02:48.749]   - Field: ‘seed’
[11:02:48.749]   - Field: ‘version’
[11:02:48.749]   - Field: ‘result’
[11:02:48.749]   - Field: ‘asynchronous’
[11:02:48.749]   - Field: ‘calls’
[11:02:48.749]   - Field: ‘globals’
[11:02:48.749]   - Field: ‘stdout’
[11:02:48.749]   - Field: ‘earlySignal’
[11:02:48.749]   - Field: ‘lazy’
[11:02:48.749]   - Field: ‘state’
[11:02:48.749] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:48.749] - Launch lazy future ...
[11:02:48.750] Packages needed by the future expression (n = 0): <none>
[11:02:48.750] Packages needed by future strategies (n = 0): <none>
[11:02:48.750] {
[11:02:48.750]     {
[11:02:48.750]         {
[11:02:48.750]             ...future.startTime <- base::Sys.time()
[11:02:48.750]             {
[11:02:48.750]                 {
[11:02:48.750]                   {
[11:02:48.750]                     {
[11:02:48.750]                       base::local({
[11:02:48.750]                         has_future <- base::requireNamespace("future", 
[11:02:48.750]                           quietly = TRUE)
[11:02:48.750]                         if (has_future) {
[11:02:48.750]                           ns <- base::getNamespace("future")
[11:02:48.750]                           version <- ns[[".package"]][["version"]]
[11:02:48.750]                           if (is.null(version)) 
[11:02:48.750]                             version <- utils::packageVersion("future")
[11:02:48.750]                         }
[11:02:48.750]                         else {
[11:02:48.750]                           version <- NULL
[11:02:48.750]                         }
[11:02:48.750]                         if (!has_future || version < "1.8.0") {
[11:02:48.750]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:48.750]                             "", base::R.version$version.string), 
[11:02:48.750]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:48.750]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:48.750]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:48.750]                               "release", "version")], collapse = " "), 
[11:02:48.750]                             hostname = base::Sys.info()[["nodename"]])
[11:02:48.750]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:48.750]                             info)
[11:02:48.750]                           info <- base::paste(info, collapse = "; ")
[11:02:48.750]                           if (!has_future) {
[11:02:48.750]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:48.750]                               info)
[11:02:48.750]                           }
[11:02:48.750]                           else {
[11:02:48.750]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:48.750]                               info, version)
[11:02:48.750]                           }
[11:02:48.750]                           base::stop(msg)
[11:02:48.750]                         }
[11:02:48.750]                       })
[11:02:48.750]                     }
[11:02:48.750]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:48.750]                     base::options(mc.cores = 1L)
[11:02:48.750]                   }
[11:02:48.750]                   ...future.strategy.old <- future::plan("list")
[11:02:48.750]                   options(future.plan = NULL)
[11:02:48.750]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:48.750]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:48.750]                 }
[11:02:48.750]                 ...future.workdir <- getwd()
[11:02:48.750]             }
[11:02:48.750]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:48.750]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:48.750]         }
[11:02:48.750]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:48.750]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:48.750]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:48.750]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:48.750]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:48.750]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:48.750]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:48.750]             base::names(...future.oldOptions))
[11:02:48.750]     }
[11:02:48.750]     if (FALSE) {
[11:02:48.750]     }
[11:02:48.750]     else {
[11:02:48.750]         if (TRUE) {
[11:02:48.750]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:48.750]                 open = "w")
[11:02:48.750]         }
[11:02:48.750]         else {
[11:02:48.750]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:48.750]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:48.750]         }
[11:02:48.750]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:48.750]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:48.750]             base::sink(type = "output", split = FALSE)
[11:02:48.750]             base::close(...future.stdout)
[11:02:48.750]         }, add = TRUE)
[11:02:48.750]     }
[11:02:48.750]     ...future.frame <- base::sys.nframe()
[11:02:48.750]     ...future.conditions <- base::list()
[11:02:48.750]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:48.750]     if (FALSE) {
[11:02:48.750]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:48.750]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:48.750]     }
[11:02:48.750]     ...future.result <- base::tryCatch({
[11:02:48.750]         base::withCallingHandlers({
[11:02:48.750]             ...future.value <- base::withVisible(base::local({
[11:02:48.750]                 ...future.makeSendCondition <- base::local({
[11:02:48.750]                   sendCondition <- NULL
[11:02:48.750]                   function(frame = 1L) {
[11:02:48.750]                     if (is.function(sendCondition)) 
[11:02:48.750]                       return(sendCondition)
[11:02:48.750]                     ns <- getNamespace("parallel")
[11:02:48.750]                     if (exists("sendData", mode = "function", 
[11:02:48.750]                       envir = ns)) {
[11:02:48.750]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:48.750]                         envir = ns)
[11:02:48.750]                       envir <- sys.frame(frame)
[11:02:48.750]                       master <- NULL
[11:02:48.750]                       while (!identical(envir, .GlobalEnv) && 
[11:02:48.750]                         !identical(envir, emptyenv())) {
[11:02:48.750]                         if (exists("master", mode = "list", envir = envir, 
[11:02:48.750]                           inherits = FALSE)) {
[11:02:48.750]                           master <- get("master", mode = "list", 
[11:02:48.750]                             envir = envir, inherits = FALSE)
[11:02:48.750]                           if (inherits(master, c("SOCKnode", 
[11:02:48.750]                             "SOCK0node"))) {
[11:02:48.750]                             sendCondition <<- function(cond) {
[11:02:48.750]                               data <- list(type = "VALUE", value = cond, 
[11:02:48.750]                                 success = TRUE)
[11:02:48.750]                               parallel_sendData(master, data)
[11:02:48.750]                             }
[11:02:48.750]                             return(sendCondition)
[11:02:48.750]                           }
[11:02:48.750]                         }
[11:02:48.750]                         frame <- frame + 1L
[11:02:48.750]                         envir <- sys.frame(frame)
[11:02:48.750]                       }
[11:02:48.750]                     }
[11:02:48.750]                     sendCondition <<- function(cond) NULL
[11:02:48.750]                   }
[11:02:48.750]                 })
[11:02:48.750]                 withCallingHandlers({
[11:02:48.750]                   list(a = 1, b = 42L, c = stop("Nah!"))
[11:02:48.750]                 }, immediateCondition = function(cond) {
[11:02:48.750]                   sendCondition <- ...future.makeSendCondition()
[11:02:48.750]                   sendCondition(cond)
[11:02:48.750]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:48.750]                   {
[11:02:48.750]                     inherits <- base::inherits
[11:02:48.750]                     invokeRestart <- base::invokeRestart
[11:02:48.750]                     is.null <- base::is.null
[11:02:48.750]                     muffled <- FALSE
[11:02:48.750]                     if (inherits(cond, "message")) {
[11:02:48.750]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:48.750]                       if (muffled) 
[11:02:48.750]                         invokeRestart("muffleMessage")
[11:02:48.750]                     }
[11:02:48.750]                     else if (inherits(cond, "warning")) {
[11:02:48.750]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:48.750]                       if (muffled) 
[11:02:48.750]                         invokeRestart("muffleWarning")
[11:02:48.750]                     }
[11:02:48.750]                     else if (inherits(cond, "condition")) {
[11:02:48.750]                       if (!is.null(pattern)) {
[11:02:48.750]                         computeRestarts <- base::computeRestarts
[11:02:48.750]                         grepl <- base::grepl
[11:02:48.750]                         restarts <- computeRestarts(cond)
[11:02:48.750]                         for (restart in restarts) {
[11:02:48.750]                           name <- restart$name
[11:02:48.750]                           if (is.null(name)) 
[11:02:48.750]                             next
[11:02:48.750]                           if (!grepl(pattern, name)) 
[11:02:48.750]                             next
[11:02:48.750]                           invokeRestart(restart)
[11:02:48.750]                           muffled <- TRUE
[11:02:48.750]                           break
[11:02:48.750]                         }
[11:02:48.750]                       }
[11:02:48.750]                     }
[11:02:48.750]                     invisible(muffled)
[11:02:48.750]                   }
[11:02:48.750]                   muffleCondition(cond)
[11:02:48.750]                 })
[11:02:48.750]             }))
[11:02:48.750]             future::FutureResult(value = ...future.value$value, 
[11:02:48.750]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:48.750]                   ...future.rng), globalenv = if (FALSE) 
[11:02:48.750]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:48.750]                     ...future.globalenv.names))
[11:02:48.750]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:48.750]         }, condition = base::local({
[11:02:48.750]             c <- base::c
[11:02:48.750]             inherits <- base::inherits
[11:02:48.750]             invokeRestart <- base::invokeRestart
[11:02:48.750]             length <- base::length
[11:02:48.750]             list <- base::list
[11:02:48.750]             seq.int <- base::seq.int
[11:02:48.750]             signalCondition <- base::signalCondition
[11:02:48.750]             sys.calls <- base::sys.calls
[11:02:48.750]             `[[` <- base::`[[`
[11:02:48.750]             `+` <- base::`+`
[11:02:48.750]             `<<-` <- base::`<<-`
[11:02:48.750]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:48.750]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:48.750]                   3L)]
[11:02:48.750]             }
[11:02:48.750]             function(cond) {
[11:02:48.750]                 is_error <- inherits(cond, "error")
[11:02:48.750]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:48.750]                   NULL)
[11:02:48.750]                 if (is_error) {
[11:02:48.750]                   sessionInformation <- function() {
[11:02:48.750]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:48.750]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:48.750]                       search = base::search(), system = base::Sys.info())
[11:02:48.750]                   }
[11:02:48.750]                   ...future.conditions[[length(...future.conditions) + 
[11:02:48.750]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:48.750]                     cond$call), session = sessionInformation(), 
[11:02:48.750]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:48.750]                   signalCondition(cond)
[11:02:48.750]                 }
[11:02:48.750]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:48.750]                 "immediateCondition"))) {
[11:02:48.750]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:48.750]                   ...future.conditions[[length(...future.conditions) + 
[11:02:48.750]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:48.750]                   if (TRUE && !signal) {
[11:02:48.750]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:48.750]                     {
[11:02:48.750]                       inherits <- base::inherits
[11:02:48.750]                       invokeRestart <- base::invokeRestart
[11:02:48.750]                       is.null <- base::is.null
[11:02:48.750]                       muffled <- FALSE
[11:02:48.750]                       if (inherits(cond, "message")) {
[11:02:48.750]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:48.750]                         if (muffled) 
[11:02:48.750]                           invokeRestart("muffleMessage")
[11:02:48.750]                       }
[11:02:48.750]                       else if (inherits(cond, "warning")) {
[11:02:48.750]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:48.750]                         if (muffled) 
[11:02:48.750]                           invokeRestart("muffleWarning")
[11:02:48.750]                       }
[11:02:48.750]                       else if (inherits(cond, "condition")) {
[11:02:48.750]                         if (!is.null(pattern)) {
[11:02:48.750]                           computeRestarts <- base::computeRestarts
[11:02:48.750]                           grepl <- base::grepl
[11:02:48.750]                           restarts <- computeRestarts(cond)
[11:02:48.750]                           for (restart in restarts) {
[11:02:48.750]                             name <- restart$name
[11:02:48.750]                             if (is.null(name)) 
[11:02:48.750]                               next
[11:02:48.750]                             if (!grepl(pattern, name)) 
[11:02:48.750]                               next
[11:02:48.750]                             invokeRestart(restart)
[11:02:48.750]                             muffled <- TRUE
[11:02:48.750]                             break
[11:02:48.750]                           }
[11:02:48.750]                         }
[11:02:48.750]                       }
[11:02:48.750]                       invisible(muffled)
[11:02:48.750]                     }
[11:02:48.750]                     muffleCondition(cond, pattern = "^muffle")
[11:02:48.750]                   }
[11:02:48.750]                 }
[11:02:48.750]                 else {
[11:02:48.750]                   if (TRUE) {
[11:02:48.750]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:48.750]                     {
[11:02:48.750]                       inherits <- base::inherits
[11:02:48.750]                       invokeRestart <- base::invokeRestart
[11:02:48.750]                       is.null <- base::is.null
[11:02:48.750]                       muffled <- FALSE
[11:02:48.750]                       if (inherits(cond, "message")) {
[11:02:48.750]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:48.750]                         if (muffled) 
[11:02:48.750]                           invokeRestart("muffleMessage")
[11:02:48.750]                       }
[11:02:48.750]                       else if (inherits(cond, "warning")) {
[11:02:48.750]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:48.750]                         if (muffled) 
[11:02:48.750]                           invokeRestart("muffleWarning")
[11:02:48.750]                       }
[11:02:48.750]                       else if (inherits(cond, "condition")) {
[11:02:48.750]                         if (!is.null(pattern)) {
[11:02:48.750]                           computeRestarts <- base::computeRestarts
[11:02:48.750]                           grepl <- base::grepl
[11:02:48.750]                           restarts <- computeRestarts(cond)
[11:02:48.750]                           for (restart in restarts) {
[11:02:48.750]                             name <- restart$name
[11:02:48.750]                             if (is.null(name)) 
[11:02:48.750]                               next
[11:02:48.750]                             if (!grepl(pattern, name)) 
[11:02:48.750]                               next
[11:02:48.750]                             invokeRestart(restart)
[11:02:48.750]                             muffled <- TRUE
[11:02:48.750]                             break
[11:02:48.750]                           }
[11:02:48.750]                         }
[11:02:48.750]                       }
[11:02:48.750]                       invisible(muffled)
[11:02:48.750]                     }
[11:02:48.750]                     muffleCondition(cond, pattern = "^muffle")
[11:02:48.750]                   }
[11:02:48.750]                 }
[11:02:48.750]             }
[11:02:48.750]         }))
[11:02:48.750]     }, error = function(ex) {
[11:02:48.750]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:48.750]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:48.750]                 ...future.rng), started = ...future.startTime, 
[11:02:48.750]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:48.750]             version = "1.8"), class = "FutureResult")
[11:02:48.750]     }, finally = {
[11:02:48.750]         if (!identical(...future.workdir, getwd())) 
[11:02:48.750]             setwd(...future.workdir)
[11:02:48.750]         {
[11:02:48.750]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:48.750]                 ...future.oldOptions$nwarnings <- NULL
[11:02:48.750]             }
[11:02:48.750]             base::options(...future.oldOptions)
[11:02:48.750]             if (.Platform$OS.type == "windows") {
[11:02:48.750]                 old_names <- names(...future.oldEnvVars)
[11:02:48.750]                 envs <- base::Sys.getenv()
[11:02:48.750]                 names <- names(envs)
[11:02:48.750]                 common <- intersect(names, old_names)
[11:02:48.750]                 added <- setdiff(names, old_names)
[11:02:48.750]                 removed <- setdiff(old_names, names)
[11:02:48.750]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:48.750]                   envs[common]]
[11:02:48.750]                 NAMES <- toupper(changed)
[11:02:48.750]                 args <- list()
[11:02:48.750]                 for (kk in seq_along(NAMES)) {
[11:02:48.750]                   name <- changed[[kk]]
[11:02:48.750]                   NAME <- NAMES[[kk]]
[11:02:48.750]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:48.750]                     next
[11:02:48.750]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:48.750]                 }
[11:02:48.750]                 NAMES <- toupper(added)
[11:02:48.750]                 for (kk in seq_along(NAMES)) {
[11:02:48.750]                   name <- added[[kk]]
[11:02:48.750]                   NAME <- NAMES[[kk]]
[11:02:48.750]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:48.750]                     next
[11:02:48.750]                   args[[name]] <- ""
[11:02:48.750]                 }
[11:02:48.750]                 NAMES <- toupper(removed)
[11:02:48.750]                 for (kk in seq_along(NAMES)) {
[11:02:48.750]                   name <- removed[[kk]]
[11:02:48.750]                   NAME <- NAMES[[kk]]
[11:02:48.750]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:48.750]                     next
[11:02:48.750]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:48.750]                 }
[11:02:48.750]                 if (length(args) > 0) 
[11:02:48.750]                   base::do.call(base::Sys.setenv, args = args)
[11:02:48.750]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:48.750]             }
[11:02:48.750]             else {
[11:02:48.750]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:48.750]             }
[11:02:48.750]             {
[11:02:48.750]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:48.750]                   0L) {
[11:02:48.750]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:48.750]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:48.750]                   base::options(opts)
[11:02:48.750]                 }
[11:02:48.750]                 {
[11:02:48.750]                   {
[11:02:48.750]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:48.750]                     NULL
[11:02:48.750]                   }
[11:02:48.750]                   options(future.plan = NULL)
[11:02:48.750]                   if (is.na(NA_character_)) 
[11:02:48.750]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:48.750]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:48.750]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:48.750]                     .init = FALSE)
[11:02:48.750]                 }
[11:02:48.750]             }
[11:02:48.750]         }
[11:02:48.750]     })
[11:02:48.750]     if (TRUE) {
[11:02:48.750]         base::sink(type = "output", split = FALSE)
[11:02:48.750]         if (TRUE) {
[11:02:48.750]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:48.750]         }
[11:02:48.750]         else {
[11:02:48.750]             ...future.result["stdout"] <- base::list(NULL)
[11:02:48.750]         }
[11:02:48.750]         base::close(...future.stdout)
[11:02:48.750]         ...future.stdout <- NULL
[11:02:48.750]     }
[11:02:48.750]     ...future.result$conditions <- ...future.conditions
[11:02:48.750]     ...future.result$finished <- base::Sys.time()
[11:02:48.750]     ...future.result
[11:02:48.750] }
[11:02:48.753] MultisessionFuture started
[11:02:48.753] - Launch lazy future ... done
[11:02:48.753] run() for ‘MultisessionFuture’ ... done
[11:02:48.795] receiveMessageFromWorker() for ClusterFuture ...
[11:02:48.795] - Validating connection of MultisessionFuture
[11:02:48.796] - received message: FutureResult
[11:02:48.796] - Received FutureResult
[11:02:48.796] - Erased future from FutureRegistry
[11:02:48.796] result() for ClusterFuture ...
[11:02:48.796] - result already collected: FutureResult
[11:02:48.796] result() for ClusterFuture ... done
[11:02:48.796] signalConditions() ...
[11:02:48.796]  - include = ‘immediateCondition’
[11:02:48.796]  - exclude = 
[11:02:48.796]  - resignal = FALSE
[11:02:48.796]  - Number of conditions: 1
[11:02:48.797] signalConditions() ... done
[11:02:48.797] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:48.797] A MultisessionFuture was resolved (result was not collected)
- result = FALSE, recursive = Inf ... DONE
- result = TRUE, recursive = FALSE ...
[11:02:48.797] getGlobalsAndPackages() ...
[11:02:48.797] Searching for globals...
[11:02:48.798] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[11:02:48.798] Searching for globals ... DONE
[11:02:48.798] Resolving globals: FALSE
[11:02:48.799] 
[11:02:48.799] 
[11:02:48.799] getGlobalsAndPackages() ... DONE
[11:02:48.799] run() for ‘Future’ ...
[11:02:48.799] - state: ‘created’
[11:02:48.799] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:48.814] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:48.815] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:48.815]   - Field: ‘node’
[11:02:48.815]   - Field: ‘label’
[11:02:48.815]   - Field: ‘local’
[11:02:48.815]   - Field: ‘owner’
[11:02:48.815]   - Field: ‘envir’
[11:02:48.815]   - Field: ‘workers’
[11:02:48.815]   - Field: ‘packages’
[11:02:48.815]   - Field: ‘gc’
[11:02:48.815]   - Field: ‘conditions’
[11:02:48.815]   - Field: ‘persistent’
[11:02:48.816]   - Field: ‘expr’
[11:02:48.816]   - Field: ‘uuid’
[11:02:48.816]   - Field: ‘seed’
[11:02:48.816]   - Field: ‘version’
[11:02:48.816]   - Field: ‘result’
[11:02:48.816]   - Field: ‘asynchronous’
[11:02:48.816]   - Field: ‘calls’
[11:02:48.816]   - Field: ‘globals’
[11:02:48.816]   - Field: ‘stdout’
[11:02:48.816]   - Field: ‘earlySignal’
[11:02:48.816]   - Field: ‘lazy’
[11:02:48.816]   - Field: ‘state’
[11:02:48.817] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:48.817] - Launch lazy future ...
[11:02:48.817] Packages needed by the future expression (n = 0): <none>
[11:02:48.817] Packages needed by future strategies (n = 0): <none>
[11:02:48.817] {
[11:02:48.817]     {
[11:02:48.817]         {
[11:02:48.817]             ...future.startTime <- base::Sys.time()
[11:02:48.817]             {
[11:02:48.817]                 {
[11:02:48.817]                   {
[11:02:48.817]                     {
[11:02:48.817]                       base::local({
[11:02:48.817]                         has_future <- base::requireNamespace("future", 
[11:02:48.817]                           quietly = TRUE)
[11:02:48.817]                         if (has_future) {
[11:02:48.817]                           ns <- base::getNamespace("future")
[11:02:48.817]                           version <- ns[[".package"]][["version"]]
[11:02:48.817]                           if (is.null(version)) 
[11:02:48.817]                             version <- utils::packageVersion("future")
[11:02:48.817]                         }
[11:02:48.817]                         else {
[11:02:48.817]                           version <- NULL
[11:02:48.817]                         }
[11:02:48.817]                         if (!has_future || version < "1.8.0") {
[11:02:48.817]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:48.817]                             "", base::R.version$version.string), 
[11:02:48.817]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:48.817]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:48.817]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:48.817]                               "release", "version")], collapse = " "), 
[11:02:48.817]                             hostname = base::Sys.info()[["nodename"]])
[11:02:48.817]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:48.817]                             info)
[11:02:48.817]                           info <- base::paste(info, collapse = "; ")
[11:02:48.817]                           if (!has_future) {
[11:02:48.817]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:48.817]                               info)
[11:02:48.817]                           }
[11:02:48.817]                           else {
[11:02:48.817]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:48.817]                               info, version)
[11:02:48.817]                           }
[11:02:48.817]                           base::stop(msg)
[11:02:48.817]                         }
[11:02:48.817]                       })
[11:02:48.817]                     }
[11:02:48.817]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:48.817]                     base::options(mc.cores = 1L)
[11:02:48.817]                   }
[11:02:48.817]                   ...future.strategy.old <- future::plan("list")
[11:02:48.817]                   options(future.plan = NULL)
[11:02:48.817]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:48.817]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:48.817]                 }
[11:02:48.817]                 ...future.workdir <- getwd()
[11:02:48.817]             }
[11:02:48.817]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:48.817]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:48.817]         }
[11:02:48.817]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:48.817]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:48.817]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:48.817]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:48.817]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:48.817]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:48.817]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:48.817]             base::names(...future.oldOptions))
[11:02:48.817]     }
[11:02:48.817]     if (FALSE) {
[11:02:48.817]     }
[11:02:48.817]     else {
[11:02:48.817]         if (TRUE) {
[11:02:48.817]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:48.817]                 open = "w")
[11:02:48.817]         }
[11:02:48.817]         else {
[11:02:48.817]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:48.817]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:48.817]         }
[11:02:48.817]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:48.817]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:48.817]             base::sink(type = "output", split = FALSE)
[11:02:48.817]             base::close(...future.stdout)
[11:02:48.817]         }, add = TRUE)
[11:02:48.817]     }
[11:02:48.817]     ...future.frame <- base::sys.nframe()
[11:02:48.817]     ...future.conditions <- base::list()
[11:02:48.817]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:48.817]     if (FALSE) {
[11:02:48.817]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:48.817]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:48.817]     }
[11:02:48.817]     ...future.result <- base::tryCatch({
[11:02:48.817]         base::withCallingHandlers({
[11:02:48.817]             ...future.value <- base::withVisible(base::local({
[11:02:48.817]                 ...future.makeSendCondition <- base::local({
[11:02:48.817]                   sendCondition <- NULL
[11:02:48.817]                   function(frame = 1L) {
[11:02:48.817]                     if (is.function(sendCondition)) 
[11:02:48.817]                       return(sendCondition)
[11:02:48.817]                     ns <- getNamespace("parallel")
[11:02:48.817]                     if (exists("sendData", mode = "function", 
[11:02:48.817]                       envir = ns)) {
[11:02:48.817]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:48.817]                         envir = ns)
[11:02:48.817]                       envir <- sys.frame(frame)
[11:02:48.817]                       master <- NULL
[11:02:48.817]                       while (!identical(envir, .GlobalEnv) && 
[11:02:48.817]                         !identical(envir, emptyenv())) {
[11:02:48.817]                         if (exists("master", mode = "list", envir = envir, 
[11:02:48.817]                           inherits = FALSE)) {
[11:02:48.817]                           master <- get("master", mode = "list", 
[11:02:48.817]                             envir = envir, inherits = FALSE)
[11:02:48.817]                           if (inherits(master, c("SOCKnode", 
[11:02:48.817]                             "SOCK0node"))) {
[11:02:48.817]                             sendCondition <<- function(cond) {
[11:02:48.817]                               data <- list(type = "VALUE", value = cond, 
[11:02:48.817]                                 success = TRUE)
[11:02:48.817]                               parallel_sendData(master, data)
[11:02:48.817]                             }
[11:02:48.817]                             return(sendCondition)
[11:02:48.817]                           }
[11:02:48.817]                         }
[11:02:48.817]                         frame <- frame + 1L
[11:02:48.817]                         envir <- sys.frame(frame)
[11:02:48.817]                       }
[11:02:48.817]                     }
[11:02:48.817]                     sendCondition <<- function(cond) NULL
[11:02:48.817]                   }
[11:02:48.817]                 })
[11:02:48.817]                 withCallingHandlers({
[11:02:48.817]                   {
[11:02:48.817]                     Sys.sleep(0.5)
[11:02:48.817]                     list(a = 1, b = 42L)
[11:02:48.817]                   }
[11:02:48.817]                 }, immediateCondition = function(cond) {
[11:02:48.817]                   sendCondition <- ...future.makeSendCondition()
[11:02:48.817]                   sendCondition(cond)
[11:02:48.817]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:48.817]                   {
[11:02:48.817]                     inherits <- base::inherits
[11:02:48.817]                     invokeRestart <- base::invokeRestart
[11:02:48.817]                     is.null <- base::is.null
[11:02:48.817]                     muffled <- FALSE
[11:02:48.817]                     if (inherits(cond, "message")) {
[11:02:48.817]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:48.817]                       if (muffled) 
[11:02:48.817]                         invokeRestart("muffleMessage")
[11:02:48.817]                     }
[11:02:48.817]                     else if (inherits(cond, "warning")) {
[11:02:48.817]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:48.817]                       if (muffled) 
[11:02:48.817]                         invokeRestart("muffleWarning")
[11:02:48.817]                     }
[11:02:48.817]                     else if (inherits(cond, "condition")) {
[11:02:48.817]                       if (!is.null(pattern)) {
[11:02:48.817]                         computeRestarts <- base::computeRestarts
[11:02:48.817]                         grepl <- base::grepl
[11:02:48.817]                         restarts <- computeRestarts(cond)
[11:02:48.817]                         for (restart in restarts) {
[11:02:48.817]                           name <- restart$name
[11:02:48.817]                           if (is.null(name)) 
[11:02:48.817]                             next
[11:02:48.817]                           if (!grepl(pattern, name)) 
[11:02:48.817]                             next
[11:02:48.817]                           invokeRestart(restart)
[11:02:48.817]                           muffled <- TRUE
[11:02:48.817]                           break
[11:02:48.817]                         }
[11:02:48.817]                       }
[11:02:48.817]                     }
[11:02:48.817]                     invisible(muffled)
[11:02:48.817]                   }
[11:02:48.817]                   muffleCondition(cond)
[11:02:48.817]                 })
[11:02:48.817]             }))
[11:02:48.817]             future::FutureResult(value = ...future.value$value, 
[11:02:48.817]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:48.817]                   ...future.rng), globalenv = if (FALSE) 
[11:02:48.817]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:48.817]                     ...future.globalenv.names))
[11:02:48.817]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:48.817]         }, condition = base::local({
[11:02:48.817]             c <- base::c
[11:02:48.817]             inherits <- base::inherits
[11:02:48.817]             invokeRestart <- base::invokeRestart
[11:02:48.817]             length <- base::length
[11:02:48.817]             list <- base::list
[11:02:48.817]             seq.int <- base::seq.int
[11:02:48.817]             signalCondition <- base::signalCondition
[11:02:48.817]             sys.calls <- base::sys.calls
[11:02:48.817]             `[[` <- base::`[[`
[11:02:48.817]             `+` <- base::`+`
[11:02:48.817]             `<<-` <- base::`<<-`
[11:02:48.817]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:48.817]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:48.817]                   3L)]
[11:02:48.817]             }
[11:02:48.817]             function(cond) {
[11:02:48.817]                 is_error <- inherits(cond, "error")
[11:02:48.817]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:48.817]                   NULL)
[11:02:48.817]                 if (is_error) {
[11:02:48.817]                   sessionInformation <- function() {
[11:02:48.817]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:48.817]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:48.817]                       search = base::search(), system = base::Sys.info())
[11:02:48.817]                   }
[11:02:48.817]                   ...future.conditions[[length(...future.conditions) + 
[11:02:48.817]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:48.817]                     cond$call), session = sessionInformation(), 
[11:02:48.817]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:48.817]                   signalCondition(cond)
[11:02:48.817]                 }
[11:02:48.817]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:48.817]                 "immediateCondition"))) {
[11:02:48.817]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:48.817]                   ...future.conditions[[length(...future.conditions) + 
[11:02:48.817]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:48.817]                   if (TRUE && !signal) {
[11:02:48.817]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:48.817]                     {
[11:02:48.817]                       inherits <- base::inherits
[11:02:48.817]                       invokeRestart <- base::invokeRestart
[11:02:48.817]                       is.null <- base::is.null
[11:02:48.817]                       muffled <- FALSE
[11:02:48.817]                       if (inherits(cond, "message")) {
[11:02:48.817]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:48.817]                         if (muffled) 
[11:02:48.817]                           invokeRestart("muffleMessage")
[11:02:48.817]                       }
[11:02:48.817]                       else if (inherits(cond, "warning")) {
[11:02:48.817]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:48.817]                         if (muffled) 
[11:02:48.817]                           invokeRestart("muffleWarning")
[11:02:48.817]                       }
[11:02:48.817]                       else if (inherits(cond, "condition")) {
[11:02:48.817]                         if (!is.null(pattern)) {
[11:02:48.817]                           computeRestarts <- base::computeRestarts
[11:02:48.817]                           grepl <- base::grepl
[11:02:48.817]                           restarts <- computeRestarts(cond)
[11:02:48.817]                           for (restart in restarts) {
[11:02:48.817]                             name <- restart$name
[11:02:48.817]                             if (is.null(name)) 
[11:02:48.817]                               next
[11:02:48.817]                             if (!grepl(pattern, name)) 
[11:02:48.817]                               next
[11:02:48.817]                             invokeRestart(restart)
[11:02:48.817]                             muffled <- TRUE
[11:02:48.817]                             break
[11:02:48.817]                           }
[11:02:48.817]                         }
[11:02:48.817]                       }
[11:02:48.817]                       invisible(muffled)
[11:02:48.817]                     }
[11:02:48.817]                     muffleCondition(cond, pattern = "^muffle")
[11:02:48.817]                   }
[11:02:48.817]                 }
[11:02:48.817]                 else {
[11:02:48.817]                   if (TRUE) {
[11:02:48.817]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:48.817]                     {
[11:02:48.817]                       inherits <- base::inherits
[11:02:48.817]                       invokeRestart <- base::invokeRestart
[11:02:48.817]                       is.null <- base::is.null
[11:02:48.817]                       muffled <- FALSE
[11:02:48.817]                       if (inherits(cond, "message")) {
[11:02:48.817]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:48.817]                         if (muffled) 
[11:02:48.817]                           invokeRestart("muffleMessage")
[11:02:48.817]                       }
[11:02:48.817]                       else if (inherits(cond, "warning")) {
[11:02:48.817]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:48.817]                         if (muffled) 
[11:02:48.817]                           invokeRestart("muffleWarning")
[11:02:48.817]                       }
[11:02:48.817]                       else if (inherits(cond, "condition")) {
[11:02:48.817]                         if (!is.null(pattern)) {
[11:02:48.817]                           computeRestarts <- base::computeRestarts
[11:02:48.817]                           grepl <- base::grepl
[11:02:48.817]                           restarts <- computeRestarts(cond)
[11:02:48.817]                           for (restart in restarts) {
[11:02:48.817]                             name <- restart$name
[11:02:48.817]                             if (is.null(name)) 
[11:02:48.817]                               next
[11:02:48.817]                             if (!grepl(pattern, name)) 
[11:02:48.817]                               next
[11:02:48.817]                             invokeRestart(restart)
[11:02:48.817]                             muffled <- TRUE
[11:02:48.817]                             break
[11:02:48.817]                           }
[11:02:48.817]                         }
[11:02:48.817]                       }
[11:02:48.817]                       invisible(muffled)
[11:02:48.817]                     }
[11:02:48.817]                     muffleCondition(cond, pattern = "^muffle")
[11:02:48.817]                   }
[11:02:48.817]                 }
[11:02:48.817]             }
[11:02:48.817]         }))
[11:02:48.817]     }, error = function(ex) {
[11:02:48.817]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:48.817]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:48.817]                 ...future.rng), started = ...future.startTime, 
[11:02:48.817]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:48.817]             version = "1.8"), class = "FutureResult")
[11:02:48.817]     }, finally = {
[11:02:48.817]         if (!identical(...future.workdir, getwd())) 
[11:02:48.817]             setwd(...future.workdir)
[11:02:48.817]         {
[11:02:48.817]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:48.817]                 ...future.oldOptions$nwarnings <- NULL
[11:02:48.817]             }
[11:02:48.817]             base::options(...future.oldOptions)
[11:02:48.817]             if (.Platform$OS.type == "windows") {
[11:02:48.817]                 old_names <- names(...future.oldEnvVars)
[11:02:48.817]                 envs <- base::Sys.getenv()
[11:02:48.817]                 names <- names(envs)
[11:02:48.817]                 common <- intersect(names, old_names)
[11:02:48.817]                 added <- setdiff(names, old_names)
[11:02:48.817]                 removed <- setdiff(old_names, names)
[11:02:48.817]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:48.817]                   envs[common]]
[11:02:48.817]                 NAMES <- toupper(changed)
[11:02:48.817]                 args <- list()
[11:02:48.817]                 for (kk in seq_along(NAMES)) {
[11:02:48.817]                   name <- changed[[kk]]
[11:02:48.817]                   NAME <- NAMES[[kk]]
[11:02:48.817]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:48.817]                     next
[11:02:48.817]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:48.817]                 }
[11:02:48.817]                 NAMES <- toupper(added)
[11:02:48.817]                 for (kk in seq_along(NAMES)) {
[11:02:48.817]                   name <- added[[kk]]
[11:02:48.817]                   NAME <- NAMES[[kk]]
[11:02:48.817]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:48.817]                     next
[11:02:48.817]                   args[[name]] <- ""
[11:02:48.817]                 }
[11:02:48.817]                 NAMES <- toupper(removed)
[11:02:48.817]                 for (kk in seq_along(NAMES)) {
[11:02:48.817]                   name <- removed[[kk]]
[11:02:48.817]                   NAME <- NAMES[[kk]]
[11:02:48.817]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:48.817]                     next
[11:02:48.817]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:48.817]                 }
[11:02:48.817]                 if (length(args) > 0) 
[11:02:48.817]                   base::do.call(base::Sys.setenv, args = args)
[11:02:48.817]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:48.817]             }
[11:02:48.817]             else {
[11:02:48.817]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:48.817]             }
[11:02:48.817]             {
[11:02:48.817]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:48.817]                   0L) {
[11:02:48.817]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:48.817]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:48.817]                   base::options(opts)
[11:02:48.817]                 }
[11:02:48.817]                 {
[11:02:48.817]                   {
[11:02:48.817]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:48.817]                     NULL
[11:02:48.817]                   }
[11:02:48.817]                   options(future.plan = NULL)
[11:02:48.817]                   if (is.na(NA_character_)) 
[11:02:48.817]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:48.817]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:48.817]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:48.817]                     .init = FALSE)
[11:02:48.817]                 }
[11:02:48.817]             }
[11:02:48.817]         }
[11:02:48.817]     })
[11:02:48.817]     if (TRUE) {
[11:02:48.817]         base::sink(type = "output", split = FALSE)
[11:02:48.817]         if (TRUE) {
[11:02:48.817]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:48.817]         }
[11:02:48.817]         else {
[11:02:48.817]             ...future.result["stdout"] <- base::list(NULL)
[11:02:48.817]         }
[11:02:48.817]         base::close(...future.stdout)
[11:02:48.817]         ...future.stdout <- NULL
[11:02:48.817]     }
[11:02:48.817]     ...future.result$conditions <- ...future.conditions
[11:02:48.817]     ...future.result$finished <- base::Sys.time()
[11:02:48.817]     ...future.result
[11:02:48.817] }
[11:02:48.820] MultisessionFuture started
[11:02:48.820] - Launch lazy future ... done
[11:02:48.820] run() for ‘MultisessionFuture’ ... done
[11:02:49.363] receiveMessageFromWorker() for ClusterFuture ...
[11:02:49.363] - Validating connection of MultisessionFuture
[11:02:49.363] - received message: FutureResult
[11:02:49.363] - Received FutureResult
[11:02:49.364] - Erased future from FutureRegistry
[11:02:49.364] result() for ClusterFuture ...
[11:02:49.364] - result already collected: FutureResult
[11:02:49.364] result() for ClusterFuture ... done
[11:02:49.364] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:49.364] A MultisessionFuture was resolved
[11:02:49.364] getGlobalsAndPackages() ...
[11:02:49.364] Searching for globals...
[11:02:49.365] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[11:02:49.365] Searching for globals ... DONE
[11:02:49.365] Resolving globals: FALSE
[11:02:49.366] 
[11:02:49.366] 
[11:02:49.366] getGlobalsAndPackages() ... DONE
[11:02:49.366] run() for ‘Future’ ...
[11:02:49.366] - state: ‘created’
[11:02:49.366] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:49.380] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:49.380] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:49.380]   - Field: ‘node’
[11:02:49.380]   - Field: ‘label’
[11:02:49.381]   - Field: ‘local’
[11:02:49.381]   - Field: ‘owner’
[11:02:49.381]   - Field: ‘envir’
[11:02:49.381]   - Field: ‘workers’
[11:02:49.381]   - Field: ‘packages’
[11:02:49.381]   - Field: ‘gc’
[11:02:49.381]   - Field: ‘conditions’
[11:02:49.381]   - Field: ‘persistent’
[11:02:49.381]   - Field: ‘expr’
[11:02:49.381]   - Field: ‘uuid’
[11:02:49.381]   - Field: ‘seed’
[11:02:49.381]   - Field: ‘version’
[11:02:49.382]   - Field: ‘result’
[11:02:49.382]   - Field: ‘asynchronous’
[11:02:49.382]   - Field: ‘calls’
[11:02:49.382]   - Field: ‘globals’
[11:02:49.382]   - Field: ‘stdout’
[11:02:49.382]   - Field: ‘earlySignal’
[11:02:49.382]   - Field: ‘lazy’
[11:02:49.382]   - Field: ‘state’
[11:02:49.382] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:49.382] - Launch lazy future ...
[11:02:49.383] Packages needed by the future expression (n = 0): <none>
[11:02:49.383] Packages needed by future strategies (n = 0): <none>
[11:02:49.383] {
[11:02:49.383]     {
[11:02:49.383]         {
[11:02:49.383]             ...future.startTime <- base::Sys.time()
[11:02:49.383]             {
[11:02:49.383]                 {
[11:02:49.383]                   {
[11:02:49.383]                     {
[11:02:49.383]                       base::local({
[11:02:49.383]                         has_future <- base::requireNamespace("future", 
[11:02:49.383]                           quietly = TRUE)
[11:02:49.383]                         if (has_future) {
[11:02:49.383]                           ns <- base::getNamespace("future")
[11:02:49.383]                           version <- ns[[".package"]][["version"]]
[11:02:49.383]                           if (is.null(version)) 
[11:02:49.383]                             version <- utils::packageVersion("future")
[11:02:49.383]                         }
[11:02:49.383]                         else {
[11:02:49.383]                           version <- NULL
[11:02:49.383]                         }
[11:02:49.383]                         if (!has_future || version < "1.8.0") {
[11:02:49.383]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:49.383]                             "", base::R.version$version.string), 
[11:02:49.383]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:49.383]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:49.383]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:49.383]                               "release", "version")], collapse = " "), 
[11:02:49.383]                             hostname = base::Sys.info()[["nodename"]])
[11:02:49.383]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:49.383]                             info)
[11:02:49.383]                           info <- base::paste(info, collapse = "; ")
[11:02:49.383]                           if (!has_future) {
[11:02:49.383]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:49.383]                               info)
[11:02:49.383]                           }
[11:02:49.383]                           else {
[11:02:49.383]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:49.383]                               info, version)
[11:02:49.383]                           }
[11:02:49.383]                           base::stop(msg)
[11:02:49.383]                         }
[11:02:49.383]                       })
[11:02:49.383]                     }
[11:02:49.383]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:49.383]                     base::options(mc.cores = 1L)
[11:02:49.383]                   }
[11:02:49.383]                   ...future.strategy.old <- future::plan("list")
[11:02:49.383]                   options(future.plan = NULL)
[11:02:49.383]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:49.383]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:49.383]                 }
[11:02:49.383]                 ...future.workdir <- getwd()
[11:02:49.383]             }
[11:02:49.383]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:49.383]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:49.383]         }
[11:02:49.383]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:49.383]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:49.383]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:49.383]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:49.383]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:49.383]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:49.383]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:49.383]             base::names(...future.oldOptions))
[11:02:49.383]     }
[11:02:49.383]     if (FALSE) {
[11:02:49.383]     }
[11:02:49.383]     else {
[11:02:49.383]         if (TRUE) {
[11:02:49.383]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:49.383]                 open = "w")
[11:02:49.383]         }
[11:02:49.383]         else {
[11:02:49.383]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:49.383]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:49.383]         }
[11:02:49.383]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:49.383]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:49.383]             base::sink(type = "output", split = FALSE)
[11:02:49.383]             base::close(...future.stdout)
[11:02:49.383]         }, add = TRUE)
[11:02:49.383]     }
[11:02:49.383]     ...future.frame <- base::sys.nframe()
[11:02:49.383]     ...future.conditions <- base::list()
[11:02:49.383]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:49.383]     if (FALSE) {
[11:02:49.383]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:49.383]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:49.383]     }
[11:02:49.383]     ...future.result <- base::tryCatch({
[11:02:49.383]         base::withCallingHandlers({
[11:02:49.383]             ...future.value <- base::withVisible(base::local({
[11:02:49.383]                 ...future.makeSendCondition <- base::local({
[11:02:49.383]                   sendCondition <- NULL
[11:02:49.383]                   function(frame = 1L) {
[11:02:49.383]                     if (is.function(sendCondition)) 
[11:02:49.383]                       return(sendCondition)
[11:02:49.383]                     ns <- getNamespace("parallel")
[11:02:49.383]                     if (exists("sendData", mode = "function", 
[11:02:49.383]                       envir = ns)) {
[11:02:49.383]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:49.383]                         envir = ns)
[11:02:49.383]                       envir <- sys.frame(frame)
[11:02:49.383]                       master <- NULL
[11:02:49.383]                       while (!identical(envir, .GlobalEnv) && 
[11:02:49.383]                         !identical(envir, emptyenv())) {
[11:02:49.383]                         if (exists("master", mode = "list", envir = envir, 
[11:02:49.383]                           inherits = FALSE)) {
[11:02:49.383]                           master <- get("master", mode = "list", 
[11:02:49.383]                             envir = envir, inherits = FALSE)
[11:02:49.383]                           if (inherits(master, c("SOCKnode", 
[11:02:49.383]                             "SOCK0node"))) {
[11:02:49.383]                             sendCondition <<- function(cond) {
[11:02:49.383]                               data <- list(type = "VALUE", value = cond, 
[11:02:49.383]                                 success = TRUE)
[11:02:49.383]                               parallel_sendData(master, data)
[11:02:49.383]                             }
[11:02:49.383]                             return(sendCondition)
[11:02:49.383]                           }
[11:02:49.383]                         }
[11:02:49.383]                         frame <- frame + 1L
[11:02:49.383]                         envir <- sys.frame(frame)
[11:02:49.383]                       }
[11:02:49.383]                     }
[11:02:49.383]                     sendCondition <<- function(cond) NULL
[11:02:49.383]                   }
[11:02:49.383]                 })
[11:02:49.383]                 withCallingHandlers({
[11:02:49.383]                   {
[11:02:49.383]                     Sys.sleep(0.5)
[11:02:49.383]                     list(a = 1, b = 42L)
[11:02:49.383]                   }
[11:02:49.383]                 }, immediateCondition = function(cond) {
[11:02:49.383]                   sendCondition <- ...future.makeSendCondition()
[11:02:49.383]                   sendCondition(cond)
[11:02:49.383]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:49.383]                   {
[11:02:49.383]                     inherits <- base::inherits
[11:02:49.383]                     invokeRestart <- base::invokeRestart
[11:02:49.383]                     is.null <- base::is.null
[11:02:49.383]                     muffled <- FALSE
[11:02:49.383]                     if (inherits(cond, "message")) {
[11:02:49.383]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:49.383]                       if (muffled) 
[11:02:49.383]                         invokeRestart("muffleMessage")
[11:02:49.383]                     }
[11:02:49.383]                     else if (inherits(cond, "warning")) {
[11:02:49.383]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:49.383]                       if (muffled) 
[11:02:49.383]                         invokeRestart("muffleWarning")
[11:02:49.383]                     }
[11:02:49.383]                     else if (inherits(cond, "condition")) {
[11:02:49.383]                       if (!is.null(pattern)) {
[11:02:49.383]                         computeRestarts <- base::computeRestarts
[11:02:49.383]                         grepl <- base::grepl
[11:02:49.383]                         restarts <- computeRestarts(cond)
[11:02:49.383]                         for (restart in restarts) {
[11:02:49.383]                           name <- restart$name
[11:02:49.383]                           if (is.null(name)) 
[11:02:49.383]                             next
[11:02:49.383]                           if (!grepl(pattern, name)) 
[11:02:49.383]                             next
[11:02:49.383]                           invokeRestart(restart)
[11:02:49.383]                           muffled <- TRUE
[11:02:49.383]                           break
[11:02:49.383]                         }
[11:02:49.383]                       }
[11:02:49.383]                     }
[11:02:49.383]                     invisible(muffled)
[11:02:49.383]                   }
[11:02:49.383]                   muffleCondition(cond)
[11:02:49.383]                 })
[11:02:49.383]             }))
[11:02:49.383]             future::FutureResult(value = ...future.value$value, 
[11:02:49.383]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:49.383]                   ...future.rng), globalenv = if (FALSE) 
[11:02:49.383]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:49.383]                     ...future.globalenv.names))
[11:02:49.383]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:49.383]         }, condition = base::local({
[11:02:49.383]             c <- base::c
[11:02:49.383]             inherits <- base::inherits
[11:02:49.383]             invokeRestart <- base::invokeRestart
[11:02:49.383]             length <- base::length
[11:02:49.383]             list <- base::list
[11:02:49.383]             seq.int <- base::seq.int
[11:02:49.383]             signalCondition <- base::signalCondition
[11:02:49.383]             sys.calls <- base::sys.calls
[11:02:49.383]             `[[` <- base::`[[`
[11:02:49.383]             `+` <- base::`+`
[11:02:49.383]             `<<-` <- base::`<<-`
[11:02:49.383]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:49.383]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:49.383]                   3L)]
[11:02:49.383]             }
[11:02:49.383]             function(cond) {
[11:02:49.383]                 is_error <- inherits(cond, "error")
[11:02:49.383]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:49.383]                   NULL)
[11:02:49.383]                 if (is_error) {
[11:02:49.383]                   sessionInformation <- function() {
[11:02:49.383]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:49.383]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:49.383]                       search = base::search(), system = base::Sys.info())
[11:02:49.383]                   }
[11:02:49.383]                   ...future.conditions[[length(...future.conditions) + 
[11:02:49.383]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:49.383]                     cond$call), session = sessionInformation(), 
[11:02:49.383]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:49.383]                   signalCondition(cond)
[11:02:49.383]                 }
[11:02:49.383]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:49.383]                 "immediateCondition"))) {
[11:02:49.383]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:49.383]                   ...future.conditions[[length(...future.conditions) + 
[11:02:49.383]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:49.383]                   if (TRUE && !signal) {
[11:02:49.383]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:49.383]                     {
[11:02:49.383]                       inherits <- base::inherits
[11:02:49.383]                       invokeRestart <- base::invokeRestart
[11:02:49.383]                       is.null <- base::is.null
[11:02:49.383]                       muffled <- FALSE
[11:02:49.383]                       if (inherits(cond, "message")) {
[11:02:49.383]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:49.383]                         if (muffled) 
[11:02:49.383]                           invokeRestart("muffleMessage")
[11:02:49.383]                       }
[11:02:49.383]                       else if (inherits(cond, "warning")) {
[11:02:49.383]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:49.383]                         if (muffled) 
[11:02:49.383]                           invokeRestart("muffleWarning")
[11:02:49.383]                       }
[11:02:49.383]                       else if (inherits(cond, "condition")) {
[11:02:49.383]                         if (!is.null(pattern)) {
[11:02:49.383]                           computeRestarts <- base::computeRestarts
[11:02:49.383]                           grepl <- base::grepl
[11:02:49.383]                           restarts <- computeRestarts(cond)
[11:02:49.383]                           for (restart in restarts) {
[11:02:49.383]                             name <- restart$name
[11:02:49.383]                             if (is.null(name)) 
[11:02:49.383]                               next
[11:02:49.383]                             if (!grepl(pattern, name)) 
[11:02:49.383]                               next
[11:02:49.383]                             invokeRestart(restart)
[11:02:49.383]                             muffled <- TRUE
[11:02:49.383]                             break
[11:02:49.383]                           }
[11:02:49.383]                         }
[11:02:49.383]                       }
[11:02:49.383]                       invisible(muffled)
[11:02:49.383]                     }
[11:02:49.383]                     muffleCondition(cond, pattern = "^muffle")
[11:02:49.383]                   }
[11:02:49.383]                 }
[11:02:49.383]                 else {
[11:02:49.383]                   if (TRUE) {
[11:02:49.383]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:49.383]                     {
[11:02:49.383]                       inherits <- base::inherits
[11:02:49.383]                       invokeRestart <- base::invokeRestart
[11:02:49.383]                       is.null <- base::is.null
[11:02:49.383]                       muffled <- FALSE
[11:02:49.383]                       if (inherits(cond, "message")) {
[11:02:49.383]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:49.383]                         if (muffled) 
[11:02:49.383]                           invokeRestart("muffleMessage")
[11:02:49.383]                       }
[11:02:49.383]                       else if (inherits(cond, "warning")) {
[11:02:49.383]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:49.383]                         if (muffled) 
[11:02:49.383]                           invokeRestart("muffleWarning")
[11:02:49.383]                       }
[11:02:49.383]                       else if (inherits(cond, "condition")) {
[11:02:49.383]                         if (!is.null(pattern)) {
[11:02:49.383]                           computeRestarts <- base::computeRestarts
[11:02:49.383]                           grepl <- base::grepl
[11:02:49.383]                           restarts <- computeRestarts(cond)
[11:02:49.383]                           for (restart in restarts) {
[11:02:49.383]                             name <- restart$name
[11:02:49.383]                             if (is.null(name)) 
[11:02:49.383]                               next
[11:02:49.383]                             if (!grepl(pattern, name)) 
[11:02:49.383]                               next
[11:02:49.383]                             invokeRestart(restart)
[11:02:49.383]                             muffled <- TRUE
[11:02:49.383]                             break
[11:02:49.383]                           }
[11:02:49.383]                         }
[11:02:49.383]                       }
[11:02:49.383]                       invisible(muffled)
[11:02:49.383]                     }
[11:02:49.383]                     muffleCondition(cond, pattern = "^muffle")
[11:02:49.383]                   }
[11:02:49.383]                 }
[11:02:49.383]             }
[11:02:49.383]         }))
[11:02:49.383]     }, error = function(ex) {
[11:02:49.383]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:49.383]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:49.383]                 ...future.rng), started = ...future.startTime, 
[11:02:49.383]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:49.383]             version = "1.8"), class = "FutureResult")
[11:02:49.383]     }, finally = {
[11:02:49.383]         if (!identical(...future.workdir, getwd())) 
[11:02:49.383]             setwd(...future.workdir)
[11:02:49.383]         {
[11:02:49.383]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:49.383]                 ...future.oldOptions$nwarnings <- NULL
[11:02:49.383]             }
[11:02:49.383]             base::options(...future.oldOptions)
[11:02:49.383]             if (.Platform$OS.type == "windows") {
[11:02:49.383]                 old_names <- names(...future.oldEnvVars)
[11:02:49.383]                 envs <- base::Sys.getenv()
[11:02:49.383]                 names <- names(envs)
[11:02:49.383]                 common <- intersect(names, old_names)
[11:02:49.383]                 added <- setdiff(names, old_names)
[11:02:49.383]                 removed <- setdiff(old_names, names)
[11:02:49.383]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:49.383]                   envs[common]]
[11:02:49.383]                 NAMES <- toupper(changed)
[11:02:49.383]                 args <- list()
[11:02:49.383]                 for (kk in seq_along(NAMES)) {
[11:02:49.383]                   name <- changed[[kk]]
[11:02:49.383]                   NAME <- NAMES[[kk]]
[11:02:49.383]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:49.383]                     next
[11:02:49.383]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:49.383]                 }
[11:02:49.383]                 NAMES <- toupper(added)
[11:02:49.383]                 for (kk in seq_along(NAMES)) {
[11:02:49.383]                   name <- added[[kk]]
[11:02:49.383]                   NAME <- NAMES[[kk]]
[11:02:49.383]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:49.383]                     next
[11:02:49.383]                   args[[name]] <- ""
[11:02:49.383]                 }
[11:02:49.383]                 NAMES <- toupper(removed)
[11:02:49.383]                 for (kk in seq_along(NAMES)) {
[11:02:49.383]                   name <- removed[[kk]]
[11:02:49.383]                   NAME <- NAMES[[kk]]
[11:02:49.383]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:49.383]                     next
[11:02:49.383]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:49.383]                 }
[11:02:49.383]                 if (length(args) > 0) 
[11:02:49.383]                   base::do.call(base::Sys.setenv, args = args)
[11:02:49.383]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:49.383]             }
[11:02:49.383]             else {
[11:02:49.383]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:49.383]             }
[11:02:49.383]             {
[11:02:49.383]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:49.383]                   0L) {
[11:02:49.383]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:49.383]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:49.383]                   base::options(opts)
[11:02:49.383]                 }
[11:02:49.383]                 {
[11:02:49.383]                   {
[11:02:49.383]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:49.383]                     NULL
[11:02:49.383]                   }
[11:02:49.383]                   options(future.plan = NULL)
[11:02:49.383]                   if (is.na(NA_character_)) 
[11:02:49.383]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:49.383]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:49.383]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:49.383]                     .init = FALSE)
[11:02:49.383]                 }
[11:02:49.383]             }
[11:02:49.383]         }
[11:02:49.383]     })
[11:02:49.383]     if (TRUE) {
[11:02:49.383]         base::sink(type = "output", split = FALSE)
[11:02:49.383]         if (TRUE) {
[11:02:49.383]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:49.383]         }
[11:02:49.383]         else {
[11:02:49.383]             ...future.result["stdout"] <- base::list(NULL)
[11:02:49.383]         }
[11:02:49.383]         base::close(...future.stdout)
[11:02:49.383]         ...future.stdout <- NULL
[11:02:49.383]     }
[11:02:49.383]     ...future.result$conditions <- ...future.conditions
[11:02:49.383]     ...future.result$finished <- base::Sys.time()
[11:02:49.383]     ...future.result
[11:02:49.383] }
[11:02:49.386] MultisessionFuture started
[11:02:49.386] - Launch lazy future ... done
[11:02:49.386] run() for ‘MultisessionFuture’ ... done
[11:02:49.929] receiveMessageFromWorker() for ClusterFuture ...
[11:02:49.929] - Validating connection of MultisessionFuture
[11:02:49.929] - received message: FutureResult
[11:02:49.929] - Received FutureResult
[11:02:49.929] - Erased future from FutureRegistry
[11:02:49.929] result() for ClusterFuture ...
[11:02:49.929] - result already collected: FutureResult
[11:02:49.929] result() for ClusterFuture ... done
[11:02:49.930] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:49.930] A MultisessionFuture was resolved
- w/ exception ...
[11:02:49.930] getGlobalsAndPackages() ...
[11:02:49.930] Searching for globals...
[11:02:49.931] - globals found: [2] ‘list’, ‘stop’
[11:02:49.931] Searching for globals ... DONE
[11:02:49.931] Resolving globals: FALSE
[11:02:49.931] 
[11:02:49.931] 
[11:02:49.931] getGlobalsAndPackages() ... DONE
[11:02:49.932] run() for ‘Future’ ...
[11:02:49.932] - state: ‘created’
[11:02:49.932] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:49.945] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:49.946] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:49.946]   - Field: ‘node’
[11:02:49.946]   - Field: ‘label’
[11:02:49.946]   - Field: ‘local’
[11:02:49.946]   - Field: ‘owner’
[11:02:49.946]   - Field: ‘envir’
[11:02:49.946]   - Field: ‘workers’
[11:02:49.946]   - Field: ‘packages’
[11:02:49.946]   - Field: ‘gc’
[11:02:49.946]   - Field: ‘conditions’
[11:02:49.946]   - Field: ‘persistent’
[11:02:49.946]   - Field: ‘expr’
[11:02:49.947]   - Field: ‘uuid’
[11:02:49.947]   - Field: ‘seed’
[11:02:49.947]   - Field: ‘version’
[11:02:49.947]   - Field: ‘result’
[11:02:49.947]   - Field: ‘asynchronous’
[11:02:49.947]   - Field: ‘calls’
[11:02:49.947]   - Field: ‘globals’
[11:02:49.947]   - Field: ‘stdout’
[11:02:49.947]   - Field: ‘earlySignal’
[11:02:49.947]   - Field: ‘lazy’
[11:02:49.947]   - Field: ‘state’
[11:02:49.947] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:49.948] - Launch lazy future ...
[11:02:49.948] Packages needed by the future expression (n = 0): <none>
[11:02:49.948] Packages needed by future strategies (n = 0): <none>
[11:02:49.948] {
[11:02:49.948]     {
[11:02:49.948]         {
[11:02:49.948]             ...future.startTime <- base::Sys.time()
[11:02:49.948]             {
[11:02:49.948]                 {
[11:02:49.948]                   {
[11:02:49.948]                     {
[11:02:49.948]                       base::local({
[11:02:49.948]                         has_future <- base::requireNamespace("future", 
[11:02:49.948]                           quietly = TRUE)
[11:02:49.948]                         if (has_future) {
[11:02:49.948]                           ns <- base::getNamespace("future")
[11:02:49.948]                           version <- ns[[".package"]][["version"]]
[11:02:49.948]                           if (is.null(version)) 
[11:02:49.948]                             version <- utils::packageVersion("future")
[11:02:49.948]                         }
[11:02:49.948]                         else {
[11:02:49.948]                           version <- NULL
[11:02:49.948]                         }
[11:02:49.948]                         if (!has_future || version < "1.8.0") {
[11:02:49.948]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:49.948]                             "", base::R.version$version.string), 
[11:02:49.948]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:49.948]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:49.948]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:49.948]                               "release", "version")], collapse = " "), 
[11:02:49.948]                             hostname = base::Sys.info()[["nodename"]])
[11:02:49.948]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:49.948]                             info)
[11:02:49.948]                           info <- base::paste(info, collapse = "; ")
[11:02:49.948]                           if (!has_future) {
[11:02:49.948]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:49.948]                               info)
[11:02:49.948]                           }
[11:02:49.948]                           else {
[11:02:49.948]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:49.948]                               info, version)
[11:02:49.948]                           }
[11:02:49.948]                           base::stop(msg)
[11:02:49.948]                         }
[11:02:49.948]                       })
[11:02:49.948]                     }
[11:02:49.948]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:49.948]                     base::options(mc.cores = 1L)
[11:02:49.948]                   }
[11:02:49.948]                   ...future.strategy.old <- future::plan("list")
[11:02:49.948]                   options(future.plan = NULL)
[11:02:49.948]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:49.948]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:49.948]                 }
[11:02:49.948]                 ...future.workdir <- getwd()
[11:02:49.948]             }
[11:02:49.948]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:49.948]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:49.948]         }
[11:02:49.948]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:49.948]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:49.948]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:49.948]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:49.948]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:49.948]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:49.948]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:49.948]             base::names(...future.oldOptions))
[11:02:49.948]     }
[11:02:49.948]     if (FALSE) {
[11:02:49.948]     }
[11:02:49.948]     else {
[11:02:49.948]         if (TRUE) {
[11:02:49.948]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:49.948]                 open = "w")
[11:02:49.948]         }
[11:02:49.948]         else {
[11:02:49.948]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:49.948]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:49.948]         }
[11:02:49.948]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:49.948]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:49.948]             base::sink(type = "output", split = FALSE)
[11:02:49.948]             base::close(...future.stdout)
[11:02:49.948]         }, add = TRUE)
[11:02:49.948]     }
[11:02:49.948]     ...future.frame <- base::sys.nframe()
[11:02:49.948]     ...future.conditions <- base::list()
[11:02:49.948]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:49.948]     if (FALSE) {
[11:02:49.948]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:49.948]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:49.948]     }
[11:02:49.948]     ...future.result <- base::tryCatch({
[11:02:49.948]         base::withCallingHandlers({
[11:02:49.948]             ...future.value <- base::withVisible(base::local({
[11:02:49.948]                 ...future.makeSendCondition <- base::local({
[11:02:49.948]                   sendCondition <- NULL
[11:02:49.948]                   function(frame = 1L) {
[11:02:49.948]                     if (is.function(sendCondition)) 
[11:02:49.948]                       return(sendCondition)
[11:02:49.948]                     ns <- getNamespace("parallel")
[11:02:49.948]                     if (exists("sendData", mode = "function", 
[11:02:49.948]                       envir = ns)) {
[11:02:49.948]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:49.948]                         envir = ns)
[11:02:49.948]                       envir <- sys.frame(frame)
[11:02:49.948]                       master <- NULL
[11:02:49.948]                       while (!identical(envir, .GlobalEnv) && 
[11:02:49.948]                         !identical(envir, emptyenv())) {
[11:02:49.948]                         if (exists("master", mode = "list", envir = envir, 
[11:02:49.948]                           inherits = FALSE)) {
[11:02:49.948]                           master <- get("master", mode = "list", 
[11:02:49.948]                             envir = envir, inherits = FALSE)
[11:02:49.948]                           if (inherits(master, c("SOCKnode", 
[11:02:49.948]                             "SOCK0node"))) {
[11:02:49.948]                             sendCondition <<- function(cond) {
[11:02:49.948]                               data <- list(type = "VALUE", value = cond, 
[11:02:49.948]                                 success = TRUE)
[11:02:49.948]                               parallel_sendData(master, data)
[11:02:49.948]                             }
[11:02:49.948]                             return(sendCondition)
[11:02:49.948]                           }
[11:02:49.948]                         }
[11:02:49.948]                         frame <- frame + 1L
[11:02:49.948]                         envir <- sys.frame(frame)
[11:02:49.948]                       }
[11:02:49.948]                     }
[11:02:49.948]                     sendCondition <<- function(cond) NULL
[11:02:49.948]                   }
[11:02:49.948]                 })
[11:02:49.948]                 withCallingHandlers({
[11:02:49.948]                   list(a = 1, b = 42L, c = stop("Nah!"))
[11:02:49.948]                 }, immediateCondition = function(cond) {
[11:02:49.948]                   sendCondition <- ...future.makeSendCondition()
[11:02:49.948]                   sendCondition(cond)
[11:02:49.948]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:49.948]                   {
[11:02:49.948]                     inherits <- base::inherits
[11:02:49.948]                     invokeRestart <- base::invokeRestart
[11:02:49.948]                     is.null <- base::is.null
[11:02:49.948]                     muffled <- FALSE
[11:02:49.948]                     if (inherits(cond, "message")) {
[11:02:49.948]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:49.948]                       if (muffled) 
[11:02:49.948]                         invokeRestart("muffleMessage")
[11:02:49.948]                     }
[11:02:49.948]                     else if (inherits(cond, "warning")) {
[11:02:49.948]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:49.948]                       if (muffled) 
[11:02:49.948]                         invokeRestart("muffleWarning")
[11:02:49.948]                     }
[11:02:49.948]                     else if (inherits(cond, "condition")) {
[11:02:49.948]                       if (!is.null(pattern)) {
[11:02:49.948]                         computeRestarts <- base::computeRestarts
[11:02:49.948]                         grepl <- base::grepl
[11:02:49.948]                         restarts <- computeRestarts(cond)
[11:02:49.948]                         for (restart in restarts) {
[11:02:49.948]                           name <- restart$name
[11:02:49.948]                           if (is.null(name)) 
[11:02:49.948]                             next
[11:02:49.948]                           if (!grepl(pattern, name)) 
[11:02:49.948]                             next
[11:02:49.948]                           invokeRestart(restart)
[11:02:49.948]                           muffled <- TRUE
[11:02:49.948]                           break
[11:02:49.948]                         }
[11:02:49.948]                       }
[11:02:49.948]                     }
[11:02:49.948]                     invisible(muffled)
[11:02:49.948]                   }
[11:02:49.948]                   muffleCondition(cond)
[11:02:49.948]                 })
[11:02:49.948]             }))
[11:02:49.948]             future::FutureResult(value = ...future.value$value, 
[11:02:49.948]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:49.948]                   ...future.rng), globalenv = if (FALSE) 
[11:02:49.948]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:49.948]                     ...future.globalenv.names))
[11:02:49.948]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:49.948]         }, condition = base::local({
[11:02:49.948]             c <- base::c
[11:02:49.948]             inherits <- base::inherits
[11:02:49.948]             invokeRestart <- base::invokeRestart
[11:02:49.948]             length <- base::length
[11:02:49.948]             list <- base::list
[11:02:49.948]             seq.int <- base::seq.int
[11:02:49.948]             signalCondition <- base::signalCondition
[11:02:49.948]             sys.calls <- base::sys.calls
[11:02:49.948]             `[[` <- base::`[[`
[11:02:49.948]             `+` <- base::`+`
[11:02:49.948]             `<<-` <- base::`<<-`
[11:02:49.948]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:49.948]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:49.948]                   3L)]
[11:02:49.948]             }
[11:02:49.948]             function(cond) {
[11:02:49.948]                 is_error <- inherits(cond, "error")
[11:02:49.948]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:49.948]                   NULL)
[11:02:49.948]                 if (is_error) {
[11:02:49.948]                   sessionInformation <- function() {
[11:02:49.948]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:49.948]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:49.948]                       search = base::search(), system = base::Sys.info())
[11:02:49.948]                   }
[11:02:49.948]                   ...future.conditions[[length(...future.conditions) + 
[11:02:49.948]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:49.948]                     cond$call), session = sessionInformation(), 
[11:02:49.948]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:49.948]                   signalCondition(cond)
[11:02:49.948]                 }
[11:02:49.948]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:49.948]                 "immediateCondition"))) {
[11:02:49.948]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:49.948]                   ...future.conditions[[length(...future.conditions) + 
[11:02:49.948]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:49.948]                   if (TRUE && !signal) {
[11:02:49.948]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:49.948]                     {
[11:02:49.948]                       inherits <- base::inherits
[11:02:49.948]                       invokeRestart <- base::invokeRestart
[11:02:49.948]                       is.null <- base::is.null
[11:02:49.948]                       muffled <- FALSE
[11:02:49.948]                       if (inherits(cond, "message")) {
[11:02:49.948]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:49.948]                         if (muffled) 
[11:02:49.948]                           invokeRestart("muffleMessage")
[11:02:49.948]                       }
[11:02:49.948]                       else if (inherits(cond, "warning")) {
[11:02:49.948]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:49.948]                         if (muffled) 
[11:02:49.948]                           invokeRestart("muffleWarning")
[11:02:49.948]                       }
[11:02:49.948]                       else if (inherits(cond, "condition")) {
[11:02:49.948]                         if (!is.null(pattern)) {
[11:02:49.948]                           computeRestarts <- base::computeRestarts
[11:02:49.948]                           grepl <- base::grepl
[11:02:49.948]                           restarts <- computeRestarts(cond)
[11:02:49.948]                           for (restart in restarts) {
[11:02:49.948]                             name <- restart$name
[11:02:49.948]                             if (is.null(name)) 
[11:02:49.948]                               next
[11:02:49.948]                             if (!grepl(pattern, name)) 
[11:02:49.948]                               next
[11:02:49.948]                             invokeRestart(restart)
[11:02:49.948]                             muffled <- TRUE
[11:02:49.948]                             break
[11:02:49.948]                           }
[11:02:49.948]                         }
[11:02:49.948]                       }
[11:02:49.948]                       invisible(muffled)
[11:02:49.948]                     }
[11:02:49.948]                     muffleCondition(cond, pattern = "^muffle")
[11:02:49.948]                   }
[11:02:49.948]                 }
[11:02:49.948]                 else {
[11:02:49.948]                   if (TRUE) {
[11:02:49.948]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:49.948]                     {
[11:02:49.948]                       inherits <- base::inherits
[11:02:49.948]                       invokeRestart <- base::invokeRestart
[11:02:49.948]                       is.null <- base::is.null
[11:02:49.948]                       muffled <- FALSE
[11:02:49.948]                       if (inherits(cond, "message")) {
[11:02:49.948]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:49.948]                         if (muffled) 
[11:02:49.948]                           invokeRestart("muffleMessage")
[11:02:49.948]                       }
[11:02:49.948]                       else if (inherits(cond, "warning")) {
[11:02:49.948]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:49.948]                         if (muffled) 
[11:02:49.948]                           invokeRestart("muffleWarning")
[11:02:49.948]                       }
[11:02:49.948]                       else if (inherits(cond, "condition")) {
[11:02:49.948]                         if (!is.null(pattern)) {
[11:02:49.948]                           computeRestarts <- base::computeRestarts
[11:02:49.948]                           grepl <- base::grepl
[11:02:49.948]                           restarts <- computeRestarts(cond)
[11:02:49.948]                           for (restart in restarts) {
[11:02:49.948]                             name <- restart$name
[11:02:49.948]                             if (is.null(name)) 
[11:02:49.948]                               next
[11:02:49.948]                             if (!grepl(pattern, name)) 
[11:02:49.948]                               next
[11:02:49.948]                             invokeRestart(restart)
[11:02:49.948]                             muffled <- TRUE
[11:02:49.948]                             break
[11:02:49.948]                           }
[11:02:49.948]                         }
[11:02:49.948]                       }
[11:02:49.948]                       invisible(muffled)
[11:02:49.948]                     }
[11:02:49.948]                     muffleCondition(cond, pattern = "^muffle")
[11:02:49.948]                   }
[11:02:49.948]                 }
[11:02:49.948]             }
[11:02:49.948]         }))
[11:02:49.948]     }, error = function(ex) {
[11:02:49.948]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:49.948]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:49.948]                 ...future.rng), started = ...future.startTime, 
[11:02:49.948]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:49.948]             version = "1.8"), class = "FutureResult")
[11:02:49.948]     }, finally = {
[11:02:49.948]         if (!identical(...future.workdir, getwd())) 
[11:02:49.948]             setwd(...future.workdir)
[11:02:49.948]         {
[11:02:49.948]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:49.948]                 ...future.oldOptions$nwarnings <- NULL
[11:02:49.948]             }
[11:02:49.948]             base::options(...future.oldOptions)
[11:02:49.948]             if (.Platform$OS.type == "windows") {
[11:02:49.948]                 old_names <- names(...future.oldEnvVars)
[11:02:49.948]                 envs <- base::Sys.getenv()
[11:02:49.948]                 names <- names(envs)
[11:02:49.948]                 common <- intersect(names, old_names)
[11:02:49.948]                 added <- setdiff(names, old_names)
[11:02:49.948]                 removed <- setdiff(old_names, names)
[11:02:49.948]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:49.948]                   envs[common]]
[11:02:49.948]                 NAMES <- toupper(changed)
[11:02:49.948]                 args <- list()
[11:02:49.948]                 for (kk in seq_along(NAMES)) {
[11:02:49.948]                   name <- changed[[kk]]
[11:02:49.948]                   NAME <- NAMES[[kk]]
[11:02:49.948]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:49.948]                     next
[11:02:49.948]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:49.948]                 }
[11:02:49.948]                 NAMES <- toupper(added)
[11:02:49.948]                 for (kk in seq_along(NAMES)) {
[11:02:49.948]                   name <- added[[kk]]
[11:02:49.948]                   NAME <- NAMES[[kk]]
[11:02:49.948]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:49.948]                     next
[11:02:49.948]                   args[[name]] <- ""
[11:02:49.948]                 }
[11:02:49.948]                 NAMES <- toupper(removed)
[11:02:49.948]                 for (kk in seq_along(NAMES)) {
[11:02:49.948]                   name <- removed[[kk]]
[11:02:49.948]                   NAME <- NAMES[[kk]]
[11:02:49.948]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:49.948]                     next
[11:02:49.948]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:49.948]                 }
[11:02:49.948]                 if (length(args) > 0) 
[11:02:49.948]                   base::do.call(base::Sys.setenv, args = args)
[11:02:49.948]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:49.948]             }
[11:02:49.948]             else {
[11:02:49.948]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:49.948]             }
[11:02:49.948]             {
[11:02:49.948]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:49.948]                   0L) {
[11:02:49.948]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:49.948]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:49.948]                   base::options(opts)
[11:02:49.948]                 }
[11:02:49.948]                 {
[11:02:49.948]                   {
[11:02:49.948]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:49.948]                     NULL
[11:02:49.948]                   }
[11:02:49.948]                   options(future.plan = NULL)
[11:02:49.948]                   if (is.na(NA_character_)) 
[11:02:49.948]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:49.948]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:49.948]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:49.948]                     .init = FALSE)
[11:02:49.948]                 }
[11:02:49.948]             }
[11:02:49.948]         }
[11:02:49.948]     })
[11:02:49.948]     if (TRUE) {
[11:02:49.948]         base::sink(type = "output", split = FALSE)
[11:02:49.948]         if (TRUE) {
[11:02:49.948]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:49.948]         }
[11:02:49.948]         else {
[11:02:49.948]             ...future.result["stdout"] <- base::list(NULL)
[11:02:49.948]         }
[11:02:49.948]         base::close(...future.stdout)
[11:02:49.948]         ...future.stdout <- NULL
[11:02:49.948]     }
[11:02:49.948]     ...future.result$conditions <- ...future.conditions
[11:02:49.948]     ...future.result$finished <- base::Sys.time()
[11:02:49.948]     ...future.result
[11:02:49.948] }
[11:02:49.951] MultisessionFuture started
[11:02:49.951] - Launch lazy future ... done
[11:02:49.952] run() for ‘MultisessionFuture’ ... done
[11:02:49.993] receiveMessageFromWorker() for ClusterFuture ...
[11:02:49.994] - Validating connection of MultisessionFuture
[11:02:49.994] - received message: FutureResult
[11:02:49.994] - Received FutureResult
[11:02:49.994] - Erased future from FutureRegistry
[11:02:49.995] result() for ClusterFuture ...
[11:02:49.995] - result already collected: FutureResult
[11:02:49.995] result() for ClusterFuture ... done
[11:02:49.995] signalConditions() ...
[11:02:49.995]  - include = ‘immediateCondition’
[11:02:49.995]  - exclude = 
[11:02:49.995]  - resignal = FALSE
[11:02:49.995]  - Number of conditions: 1
[11:02:49.995] signalConditions() ... done
[11:02:49.995] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:49.995] A MultisessionFuture was resolved
[11:02:49.995] getGlobalsAndPackages() ...
[11:02:49.996] Searching for globals...
[11:02:49.996] - globals found: [2] ‘list’, ‘stop’
[11:02:49.996] Searching for globals ... DONE
[11:02:49.996] Resolving globals: FALSE
[11:02:49.997] 
[11:02:49.997] 
[11:02:49.997] getGlobalsAndPackages() ... DONE
[11:02:49.997] run() for ‘Future’ ...
[11:02:49.997] - state: ‘created’
[11:02:49.997] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:50.011] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:50.011] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:50.011]   - Field: ‘node’
[11:02:50.011]   - Field: ‘label’
[11:02:50.012]   - Field: ‘local’
[11:02:50.012]   - Field: ‘owner’
[11:02:50.012]   - Field: ‘envir’
[11:02:50.012]   - Field: ‘workers’
[11:02:50.012]   - Field: ‘packages’
[11:02:50.012]   - Field: ‘gc’
[11:02:50.012]   - Field: ‘conditions’
[11:02:50.012]   - Field: ‘persistent’
[11:02:50.012]   - Field: ‘expr’
[11:02:50.012]   - Field: ‘uuid’
[11:02:50.012]   - Field: ‘seed’
[11:02:50.012]   - Field: ‘version’
[11:02:50.013]   - Field: ‘result’
[11:02:50.013]   - Field: ‘asynchronous’
[11:02:50.013]   - Field: ‘calls’
[11:02:50.013]   - Field: ‘globals’
[11:02:50.013]   - Field: ‘stdout’
[11:02:50.013]   - Field: ‘earlySignal’
[11:02:50.013]   - Field: ‘lazy’
[11:02:50.013]   - Field: ‘state’
[11:02:50.013] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:50.013] - Launch lazy future ...
[11:02:50.014] Packages needed by the future expression (n = 0): <none>
[11:02:50.014] Packages needed by future strategies (n = 0): <none>
[11:02:50.014] {
[11:02:50.014]     {
[11:02:50.014]         {
[11:02:50.014]             ...future.startTime <- base::Sys.time()
[11:02:50.014]             {
[11:02:50.014]                 {
[11:02:50.014]                   {
[11:02:50.014]                     {
[11:02:50.014]                       base::local({
[11:02:50.014]                         has_future <- base::requireNamespace("future", 
[11:02:50.014]                           quietly = TRUE)
[11:02:50.014]                         if (has_future) {
[11:02:50.014]                           ns <- base::getNamespace("future")
[11:02:50.014]                           version <- ns[[".package"]][["version"]]
[11:02:50.014]                           if (is.null(version)) 
[11:02:50.014]                             version <- utils::packageVersion("future")
[11:02:50.014]                         }
[11:02:50.014]                         else {
[11:02:50.014]                           version <- NULL
[11:02:50.014]                         }
[11:02:50.014]                         if (!has_future || version < "1.8.0") {
[11:02:50.014]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:50.014]                             "", base::R.version$version.string), 
[11:02:50.014]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:50.014]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:50.014]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:50.014]                               "release", "version")], collapse = " "), 
[11:02:50.014]                             hostname = base::Sys.info()[["nodename"]])
[11:02:50.014]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:50.014]                             info)
[11:02:50.014]                           info <- base::paste(info, collapse = "; ")
[11:02:50.014]                           if (!has_future) {
[11:02:50.014]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:50.014]                               info)
[11:02:50.014]                           }
[11:02:50.014]                           else {
[11:02:50.014]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:50.014]                               info, version)
[11:02:50.014]                           }
[11:02:50.014]                           base::stop(msg)
[11:02:50.014]                         }
[11:02:50.014]                       })
[11:02:50.014]                     }
[11:02:50.014]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:50.014]                     base::options(mc.cores = 1L)
[11:02:50.014]                   }
[11:02:50.014]                   ...future.strategy.old <- future::plan("list")
[11:02:50.014]                   options(future.plan = NULL)
[11:02:50.014]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:50.014]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:50.014]                 }
[11:02:50.014]                 ...future.workdir <- getwd()
[11:02:50.014]             }
[11:02:50.014]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:50.014]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:50.014]         }
[11:02:50.014]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:50.014]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:50.014]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:50.014]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:50.014]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:50.014]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:50.014]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:50.014]             base::names(...future.oldOptions))
[11:02:50.014]     }
[11:02:50.014]     if (FALSE) {
[11:02:50.014]     }
[11:02:50.014]     else {
[11:02:50.014]         if (TRUE) {
[11:02:50.014]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:50.014]                 open = "w")
[11:02:50.014]         }
[11:02:50.014]         else {
[11:02:50.014]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:50.014]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:50.014]         }
[11:02:50.014]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:50.014]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:50.014]             base::sink(type = "output", split = FALSE)
[11:02:50.014]             base::close(...future.stdout)
[11:02:50.014]         }, add = TRUE)
[11:02:50.014]     }
[11:02:50.014]     ...future.frame <- base::sys.nframe()
[11:02:50.014]     ...future.conditions <- base::list()
[11:02:50.014]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:50.014]     if (FALSE) {
[11:02:50.014]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:50.014]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:50.014]     }
[11:02:50.014]     ...future.result <- base::tryCatch({
[11:02:50.014]         base::withCallingHandlers({
[11:02:50.014]             ...future.value <- base::withVisible(base::local({
[11:02:50.014]                 ...future.makeSendCondition <- base::local({
[11:02:50.014]                   sendCondition <- NULL
[11:02:50.014]                   function(frame = 1L) {
[11:02:50.014]                     if (is.function(sendCondition)) 
[11:02:50.014]                       return(sendCondition)
[11:02:50.014]                     ns <- getNamespace("parallel")
[11:02:50.014]                     if (exists("sendData", mode = "function", 
[11:02:50.014]                       envir = ns)) {
[11:02:50.014]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:50.014]                         envir = ns)
[11:02:50.014]                       envir <- sys.frame(frame)
[11:02:50.014]                       master <- NULL
[11:02:50.014]                       while (!identical(envir, .GlobalEnv) && 
[11:02:50.014]                         !identical(envir, emptyenv())) {
[11:02:50.014]                         if (exists("master", mode = "list", envir = envir, 
[11:02:50.014]                           inherits = FALSE)) {
[11:02:50.014]                           master <- get("master", mode = "list", 
[11:02:50.014]                             envir = envir, inherits = FALSE)
[11:02:50.014]                           if (inherits(master, c("SOCKnode", 
[11:02:50.014]                             "SOCK0node"))) {
[11:02:50.014]                             sendCondition <<- function(cond) {
[11:02:50.014]                               data <- list(type = "VALUE", value = cond, 
[11:02:50.014]                                 success = TRUE)
[11:02:50.014]                               parallel_sendData(master, data)
[11:02:50.014]                             }
[11:02:50.014]                             return(sendCondition)
[11:02:50.014]                           }
[11:02:50.014]                         }
[11:02:50.014]                         frame <- frame + 1L
[11:02:50.014]                         envir <- sys.frame(frame)
[11:02:50.014]                       }
[11:02:50.014]                     }
[11:02:50.014]                     sendCondition <<- function(cond) NULL
[11:02:50.014]                   }
[11:02:50.014]                 })
[11:02:50.014]                 withCallingHandlers({
[11:02:50.014]                   list(a = 1, b = 42L, c = stop("Nah!"))
[11:02:50.014]                 }, immediateCondition = function(cond) {
[11:02:50.014]                   sendCondition <- ...future.makeSendCondition()
[11:02:50.014]                   sendCondition(cond)
[11:02:50.014]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:50.014]                   {
[11:02:50.014]                     inherits <- base::inherits
[11:02:50.014]                     invokeRestart <- base::invokeRestart
[11:02:50.014]                     is.null <- base::is.null
[11:02:50.014]                     muffled <- FALSE
[11:02:50.014]                     if (inherits(cond, "message")) {
[11:02:50.014]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:50.014]                       if (muffled) 
[11:02:50.014]                         invokeRestart("muffleMessage")
[11:02:50.014]                     }
[11:02:50.014]                     else if (inherits(cond, "warning")) {
[11:02:50.014]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:50.014]                       if (muffled) 
[11:02:50.014]                         invokeRestart("muffleWarning")
[11:02:50.014]                     }
[11:02:50.014]                     else if (inherits(cond, "condition")) {
[11:02:50.014]                       if (!is.null(pattern)) {
[11:02:50.014]                         computeRestarts <- base::computeRestarts
[11:02:50.014]                         grepl <- base::grepl
[11:02:50.014]                         restarts <- computeRestarts(cond)
[11:02:50.014]                         for (restart in restarts) {
[11:02:50.014]                           name <- restart$name
[11:02:50.014]                           if (is.null(name)) 
[11:02:50.014]                             next
[11:02:50.014]                           if (!grepl(pattern, name)) 
[11:02:50.014]                             next
[11:02:50.014]                           invokeRestart(restart)
[11:02:50.014]                           muffled <- TRUE
[11:02:50.014]                           break
[11:02:50.014]                         }
[11:02:50.014]                       }
[11:02:50.014]                     }
[11:02:50.014]                     invisible(muffled)
[11:02:50.014]                   }
[11:02:50.014]                   muffleCondition(cond)
[11:02:50.014]                 })
[11:02:50.014]             }))
[11:02:50.014]             future::FutureResult(value = ...future.value$value, 
[11:02:50.014]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:50.014]                   ...future.rng), globalenv = if (FALSE) 
[11:02:50.014]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:50.014]                     ...future.globalenv.names))
[11:02:50.014]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:50.014]         }, condition = base::local({
[11:02:50.014]             c <- base::c
[11:02:50.014]             inherits <- base::inherits
[11:02:50.014]             invokeRestart <- base::invokeRestart
[11:02:50.014]             length <- base::length
[11:02:50.014]             list <- base::list
[11:02:50.014]             seq.int <- base::seq.int
[11:02:50.014]             signalCondition <- base::signalCondition
[11:02:50.014]             sys.calls <- base::sys.calls
[11:02:50.014]             `[[` <- base::`[[`
[11:02:50.014]             `+` <- base::`+`
[11:02:50.014]             `<<-` <- base::`<<-`
[11:02:50.014]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:50.014]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:50.014]                   3L)]
[11:02:50.014]             }
[11:02:50.014]             function(cond) {
[11:02:50.014]                 is_error <- inherits(cond, "error")
[11:02:50.014]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:50.014]                   NULL)
[11:02:50.014]                 if (is_error) {
[11:02:50.014]                   sessionInformation <- function() {
[11:02:50.014]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:50.014]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:50.014]                       search = base::search(), system = base::Sys.info())
[11:02:50.014]                   }
[11:02:50.014]                   ...future.conditions[[length(...future.conditions) + 
[11:02:50.014]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:50.014]                     cond$call), session = sessionInformation(), 
[11:02:50.014]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:50.014]                   signalCondition(cond)
[11:02:50.014]                 }
[11:02:50.014]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:50.014]                 "immediateCondition"))) {
[11:02:50.014]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:50.014]                   ...future.conditions[[length(...future.conditions) + 
[11:02:50.014]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:50.014]                   if (TRUE && !signal) {
[11:02:50.014]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:50.014]                     {
[11:02:50.014]                       inherits <- base::inherits
[11:02:50.014]                       invokeRestart <- base::invokeRestart
[11:02:50.014]                       is.null <- base::is.null
[11:02:50.014]                       muffled <- FALSE
[11:02:50.014]                       if (inherits(cond, "message")) {
[11:02:50.014]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:50.014]                         if (muffled) 
[11:02:50.014]                           invokeRestart("muffleMessage")
[11:02:50.014]                       }
[11:02:50.014]                       else if (inherits(cond, "warning")) {
[11:02:50.014]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:50.014]                         if (muffled) 
[11:02:50.014]                           invokeRestart("muffleWarning")
[11:02:50.014]                       }
[11:02:50.014]                       else if (inherits(cond, "condition")) {
[11:02:50.014]                         if (!is.null(pattern)) {
[11:02:50.014]                           computeRestarts <- base::computeRestarts
[11:02:50.014]                           grepl <- base::grepl
[11:02:50.014]                           restarts <- computeRestarts(cond)
[11:02:50.014]                           for (restart in restarts) {
[11:02:50.014]                             name <- restart$name
[11:02:50.014]                             if (is.null(name)) 
[11:02:50.014]                               next
[11:02:50.014]                             if (!grepl(pattern, name)) 
[11:02:50.014]                               next
[11:02:50.014]                             invokeRestart(restart)
[11:02:50.014]                             muffled <- TRUE
[11:02:50.014]                             break
[11:02:50.014]                           }
[11:02:50.014]                         }
[11:02:50.014]                       }
[11:02:50.014]                       invisible(muffled)
[11:02:50.014]                     }
[11:02:50.014]                     muffleCondition(cond, pattern = "^muffle")
[11:02:50.014]                   }
[11:02:50.014]                 }
[11:02:50.014]                 else {
[11:02:50.014]                   if (TRUE) {
[11:02:50.014]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:50.014]                     {
[11:02:50.014]                       inherits <- base::inherits
[11:02:50.014]                       invokeRestart <- base::invokeRestart
[11:02:50.014]                       is.null <- base::is.null
[11:02:50.014]                       muffled <- FALSE
[11:02:50.014]                       if (inherits(cond, "message")) {
[11:02:50.014]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:50.014]                         if (muffled) 
[11:02:50.014]                           invokeRestart("muffleMessage")
[11:02:50.014]                       }
[11:02:50.014]                       else if (inherits(cond, "warning")) {
[11:02:50.014]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:50.014]                         if (muffled) 
[11:02:50.014]                           invokeRestart("muffleWarning")
[11:02:50.014]                       }
[11:02:50.014]                       else if (inherits(cond, "condition")) {
[11:02:50.014]                         if (!is.null(pattern)) {
[11:02:50.014]                           computeRestarts <- base::computeRestarts
[11:02:50.014]                           grepl <- base::grepl
[11:02:50.014]                           restarts <- computeRestarts(cond)
[11:02:50.014]                           for (restart in restarts) {
[11:02:50.014]                             name <- restart$name
[11:02:50.014]                             if (is.null(name)) 
[11:02:50.014]                               next
[11:02:50.014]                             if (!grepl(pattern, name)) 
[11:02:50.014]                               next
[11:02:50.014]                             invokeRestart(restart)
[11:02:50.014]                             muffled <- TRUE
[11:02:50.014]                             break
[11:02:50.014]                           }
[11:02:50.014]                         }
[11:02:50.014]                       }
[11:02:50.014]                       invisible(muffled)
[11:02:50.014]                     }
[11:02:50.014]                     muffleCondition(cond, pattern = "^muffle")
[11:02:50.014]                   }
[11:02:50.014]                 }
[11:02:50.014]             }
[11:02:50.014]         }))
[11:02:50.014]     }, error = function(ex) {
[11:02:50.014]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:50.014]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:50.014]                 ...future.rng), started = ...future.startTime, 
[11:02:50.014]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:50.014]             version = "1.8"), class = "FutureResult")
[11:02:50.014]     }, finally = {
[11:02:50.014]         if (!identical(...future.workdir, getwd())) 
[11:02:50.014]             setwd(...future.workdir)
[11:02:50.014]         {
[11:02:50.014]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:50.014]                 ...future.oldOptions$nwarnings <- NULL
[11:02:50.014]             }
[11:02:50.014]             base::options(...future.oldOptions)
[11:02:50.014]             if (.Platform$OS.type == "windows") {
[11:02:50.014]                 old_names <- names(...future.oldEnvVars)
[11:02:50.014]                 envs <- base::Sys.getenv()
[11:02:50.014]                 names <- names(envs)
[11:02:50.014]                 common <- intersect(names, old_names)
[11:02:50.014]                 added <- setdiff(names, old_names)
[11:02:50.014]                 removed <- setdiff(old_names, names)
[11:02:50.014]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:50.014]                   envs[common]]
[11:02:50.014]                 NAMES <- toupper(changed)
[11:02:50.014]                 args <- list()
[11:02:50.014]                 for (kk in seq_along(NAMES)) {
[11:02:50.014]                   name <- changed[[kk]]
[11:02:50.014]                   NAME <- NAMES[[kk]]
[11:02:50.014]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:50.014]                     next
[11:02:50.014]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:50.014]                 }
[11:02:50.014]                 NAMES <- toupper(added)
[11:02:50.014]                 for (kk in seq_along(NAMES)) {
[11:02:50.014]                   name <- added[[kk]]
[11:02:50.014]                   NAME <- NAMES[[kk]]
[11:02:50.014]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:50.014]                     next
[11:02:50.014]                   args[[name]] <- ""
[11:02:50.014]                 }
[11:02:50.014]                 NAMES <- toupper(removed)
[11:02:50.014]                 for (kk in seq_along(NAMES)) {
[11:02:50.014]                   name <- removed[[kk]]
[11:02:50.014]                   NAME <- NAMES[[kk]]
[11:02:50.014]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:50.014]                     next
[11:02:50.014]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:50.014]                 }
[11:02:50.014]                 if (length(args) > 0) 
[11:02:50.014]                   base::do.call(base::Sys.setenv, args = args)
[11:02:50.014]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:50.014]             }
[11:02:50.014]             else {
[11:02:50.014]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:50.014]             }
[11:02:50.014]             {
[11:02:50.014]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:50.014]                   0L) {
[11:02:50.014]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:50.014]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:50.014]                   base::options(opts)
[11:02:50.014]                 }
[11:02:50.014]                 {
[11:02:50.014]                   {
[11:02:50.014]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:50.014]                     NULL
[11:02:50.014]                   }
[11:02:50.014]                   options(future.plan = NULL)
[11:02:50.014]                   if (is.na(NA_character_)) 
[11:02:50.014]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:50.014]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:50.014]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:50.014]                     .init = FALSE)
[11:02:50.014]                 }
[11:02:50.014]             }
[11:02:50.014]         }
[11:02:50.014]     })
[11:02:50.014]     if (TRUE) {
[11:02:50.014]         base::sink(type = "output", split = FALSE)
[11:02:50.014]         if (TRUE) {
[11:02:50.014]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:50.014]         }
[11:02:50.014]         else {
[11:02:50.014]             ...future.result["stdout"] <- base::list(NULL)
[11:02:50.014]         }
[11:02:50.014]         base::close(...future.stdout)
[11:02:50.014]         ...future.stdout <- NULL
[11:02:50.014]     }
[11:02:50.014]     ...future.result$conditions <- ...future.conditions
[11:02:50.014]     ...future.result$finished <- base::Sys.time()
[11:02:50.014]     ...future.result
[11:02:50.014] }
[11:02:50.017] MultisessionFuture started
[11:02:50.017] - Launch lazy future ... done
[11:02:50.017] run() for ‘MultisessionFuture’ ... done
[11:02:50.061] receiveMessageFromWorker() for ClusterFuture ...
[11:02:50.061] - Validating connection of MultisessionFuture
[11:02:50.061] - received message: FutureResult
[11:02:50.062] - Received FutureResult
[11:02:50.062] - Erased future from FutureRegistry
[11:02:50.062] result() for ClusterFuture ...
[11:02:50.062] - result already collected: FutureResult
[11:02:50.062] result() for ClusterFuture ... done
[11:02:50.062] signalConditions() ...
[11:02:50.062]  - include = ‘immediateCondition’
[11:02:50.062]  - exclude = 
[11:02:50.062]  - resignal = FALSE
[11:02:50.062]  - Number of conditions: 1
[11:02:50.062] signalConditions() ... done
[11:02:50.062] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:50.063] A MultisessionFuture was resolved
- result = TRUE, recursive = FALSE ... DONE
- result = TRUE, recursive = TRUE ...
[11:02:50.063] getGlobalsAndPackages() ...
[11:02:50.063] Searching for globals...
[11:02:50.064] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[11:02:50.064] Searching for globals ... DONE
[11:02:50.064] Resolving globals: FALSE
[11:02:50.064] 
[11:02:50.065] 
[11:02:50.065] getGlobalsAndPackages() ... DONE
[11:02:50.065] run() for ‘Future’ ...
[11:02:50.065] - state: ‘created’
[11:02:50.065] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:50.079] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:50.079] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:50.079]   - Field: ‘node’
[11:02:50.079]   - Field: ‘label’
[11:02:50.079]   - Field: ‘local’
[11:02:50.079]   - Field: ‘owner’
[11:02:50.079]   - Field: ‘envir’
[11:02:50.079]   - Field: ‘workers’
[11:02:50.080]   - Field: ‘packages’
[11:02:50.080]   - Field: ‘gc’
[11:02:50.080]   - Field: ‘conditions’
[11:02:50.080]   - Field: ‘persistent’
[11:02:50.080]   - Field: ‘expr’
[11:02:50.080]   - Field: ‘uuid’
[11:02:50.080]   - Field: ‘seed’
[11:02:50.080]   - Field: ‘version’
[11:02:50.080]   - Field: ‘result’
[11:02:50.080]   - Field: ‘asynchronous’
[11:02:50.080]   - Field: ‘calls’
[11:02:50.080]   - Field: ‘globals’
[11:02:50.080]   - Field: ‘stdout’
[11:02:50.081]   - Field: ‘earlySignal’
[11:02:50.081]   - Field: ‘lazy’
[11:02:50.081]   - Field: ‘state’
[11:02:50.081] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:50.081] - Launch lazy future ...
[11:02:50.081] Packages needed by the future expression (n = 0): <none>
[11:02:50.081] Packages needed by future strategies (n = 0): <none>
[11:02:50.082] {
[11:02:50.082]     {
[11:02:50.082]         {
[11:02:50.082]             ...future.startTime <- base::Sys.time()
[11:02:50.082]             {
[11:02:50.082]                 {
[11:02:50.082]                   {
[11:02:50.082]                     {
[11:02:50.082]                       base::local({
[11:02:50.082]                         has_future <- base::requireNamespace("future", 
[11:02:50.082]                           quietly = TRUE)
[11:02:50.082]                         if (has_future) {
[11:02:50.082]                           ns <- base::getNamespace("future")
[11:02:50.082]                           version <- ns[[".package"]][["version"]]
[11:02:50.082]                           if (is.null(version)) 
[11:02:50.082]                             version <- utils::packageVersion("future")
[11:02:50.082]                         }
[11:02:50.082]                         else {
[11:02:50.082]                           version <- NULL
[11:02:50.082]                         }
[11:02:50.082]                         if (!has_future || version < "1.8.0") {
[11:02:50.082]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:50.082]                             "", base::R.version$version.string), 
[11:02:50.082]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:50.082]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:50.082]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:50.082]                               "release", "version")], collapse = " "), 
[11:02:50.082]                             hostname = base::Sys.info()[["nodename"]])
[11:02:50.082]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:50.082]                             info)
[11:02:50.082]                           info <- base::paste(info, collapse = "; ")
[11:02:50.082]                           if (!has_future) {
[11:02:50.082]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:50.082]                               info)
[11:02:50.082]                           }
[11:02:50.082]                           else {
[11:02:50.082]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:50.082]                               info, version)
[11:02:50.082]                           }
[11:02:50.082]                           base::stop(msg)
[11:02:50.082]                         }
[11:02:50.082]                       })
[11:02:50.082]                     }
[11:02:50.082]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:50.082]                     base::options(mc.cores = 1L)
[11:02:50.082]                   }
[11:02:50.082]                   ...future.strategy.old <- future::plan("list")
[11:02:50.082]                   options(future.plan = NULL)
[11:02:50.082]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:50.082]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:50.082]                 }
[11:02:50.082]                 ...future.workdir <- getwd()
[11:02:50.082]             }
[11:02:50.082]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:50.082]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:50.082]         }
[11:02:50.082]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:50.082]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:50.082]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:50.082]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:50.082]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:50.082]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:50.082]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:50.082]             base::names(...future.oldOptions))
[11:02:50.082]     }
[11:02:50.082]     if (FALSE) {
[11:02:50.082]     }
[11:02:50.082]     else {
[11:02:50.082]         if (TRUE) {
[11:02:50.082]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:50.082]                 open = "w")
[11:02:50.082]         }
[11:02:50.082]         else {
[11:02:50.082]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:50.082]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:50.082]         }
[11:02:50.082]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:50.082]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:50.082]             base::sink(type = "output", split = FALSE)
[11:02:50.082]             base::close(...future.stdout)
[11:02:50.082]         }, add = TRUE)
[11:02:50.082]     }
[11:02:50.082]     ...future.frame <- base::sys.nframe()
[11:02:50.082]     ...future.conditions <- base::list()
[11:02:50.082]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:50.082]     if (FALSE) {
[11:02:50.082]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:50.082]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:50.082]     }
[11:02:50.082]     ...future.result <- base::tryCatch({
[11:02:50.082]         base::withCallingHandlers({
[11:02:50.082]             ...future.value <- base::withVisible(base::local({
[11:02:50.082]                 ...future.makeSendCondition <- base::local({
[11:02:50.082]                   sendCondition <- NULL
[11:02:50.082]                   function(frame = 1L) {
[11:02:50.082]                     if (is.function(sendCondition)) 
[11:02:50.082]                       return(sendCondition)
[11:02:50.082]                     ns <- getNamespace("parallel")
[11:02:50.082]                     if (exists("sendData", mode = "function", 
[11:02:50.082]                       envir = ns)) {
[11:02:50.082]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:50.082]                         envir = ns)
[11:02:50.082]                       envir <- sys.frame(frame)
[11:02:50.082]                       master <- NULL
[11:02:50.082]                       while (!identical(envir, .GlobalEnv) && 
[11:02:50.082]                         !identical(envir, emptyenv())) {
[11:02:50.082]                         if (exists("master", mode = "list", envir = envir, 
[11:02:50.082]                           inherits = FALSE)) {
[11:02:50.082]                           master <- get("master", mode = "list", 
[11:02:50.082]                             envir = envir, inherits = FALSE)
[11:02:50.082]                           if (inherits(master, c("SOCKnode", 
[11:02:50.082]                             "SOCK0node"))) {
[11:02:50.082]                             sendCondition <<- function(cond) {
[11:02:50.082]                               data <- list(type = "VALUE", value = cond, 
[11:02:50.082]                                 success = TRUE)
[11:02:50.082]                               parallel_sendData(master, data)
[11:02:50.082]                             }
[11:02:50.082]                             return(sendCondition)
[11:02:50.082]                           }
[11:02:50.082]                         }
[11:02:50.082]                         frame <- frame + 1L
[11:02:50.082]                         envir <- sys.frame(frame)
[11:02:50.082]                       }
[11:02:50.082]                     }
[11:02:50.082]                     sendCondition <<- function(cond) NULL
[11:02:50.082]                   }
[11:02:50.082]                 })
[11:02:50.082]                 withCallingHandlers({
[11:02:50.082]                   {
[11:02:50.082]                     Sys.sleep(0.5)
[11:02:50.082]                     list(a = 1, b = 42L)
[11:02:50.082]                   }
[11:02:50.082]                 }, immediateCondition = function(cond) {
[11:02:50.082]                   sendCondition <- ...future.makeSendCondition()
[11:02:50.082]                   sendCondition(cond)
[11:02:50.082]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:50.082]                   {
[11:02:50.082]                     inherits <- base::inherits
[11:02:50.082]                     invokeRestart <- base::invokeRestart
[11:02:50.082]                     is.null <- base::is.null
[11:02:50.082]                     muffled <- FALSE
[11:02:50.082]                     if (inherits(cond, "message")) {
[11:02:50.082]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:50.082]                       if (muffled) 
[11:02:50.082]                         invokeRestart("muffleMessage")
[11:02:50.082]                     }
[11:02:50.082]                     else if (inherits(cond, "warning")) {
[11:02:50.082]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:50.082]                       if (muffled) 
[11:02:50.082]                         invokeRestart("muffleWarning")
[11:02:50.082]                     }
[11:02:50.082]                     else if (inherits(cond, "condition")) {
[11:02:50.082]                       if (!is.null(pattern)) {
[11:02:50.082]                         computeRestarts <- base::computeRestarts
[11:02:50.082]                         grepl <- base::grepl
[11:02:50.082]                         restarts <- computeRestarts(cond)
[11:02:50.082]                         for (restart in restarts) {
[11:02:50.082]                           name <- restart$name
[11:02:50.082]                           if (is.null(name)) 
[11:02:50.082]                             next
[11:02:50.082]                           if (!grepl(pattern, name)) 
[11:02:50.082]                             next
[11:02:50.082]                           invokeRestart(restart)
[11:02:50.082]                           muffled <- TRUE
[11:02:50.082]                           break
[11:02:50.082]                         }
[11:02:50.082]                       }
[11:02:50.082]                     }
[11:02:50.082]                     invisible(muffled)
[11:02:50.082]                   }
[11:02:50.082]                   muffleCondition(cond)
[11:02:50.082]                 })
[11:02:50.082]             }))
[11:02:50.082]             future::FutureResult(value = ...future.value$value, 
[11:02:50.082]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:50.082]                   ...future.rng), globalenv = if (FALSE) 
[11:02:50.082]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:50.082]                     ...future.globalenv.names))
[11:02:50.082]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:50.082]         }, condition = base::local({
[11:02:50.082]             c <- base::c
[11:02:50.082]             inherits <- base::inherits
[11:02:50.082]             invokeRestart <- base::invokeRestart
[11:02:50.082]             length <- base::length
[11:02:50.082]             list <- base::list
[11:02:50.082]             seq.int <- base::seq.int
[11:02:50.082]             signalCondition <- base::signalCondition
[11:02:50.082]             sys.calls <- base::sys.calls
[11:02:50.082]             `[[` <- base::`[[`
[11:02:50.082]             `+` <- base::`+`
[11:02:50.082]             `<<-` <- base::`<<-`
[11:02:50.082]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:50.082]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:50.082]                   3L)]
[11:02:50.082]             }
[11:02:50.082]             function(cond) {
[11:02:50.082]                 is_error <- inherits(cond, "error")
[11:02:50.082]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:50.082]                   NULL)
[11:02:50.082]                 if (is_error) {
[11:02:50.082]                   sessionInformation <- function() {
[11:02:50.082]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:50.082]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:50.082]                       search = base::search(), system = base::Sys.info())
[11:02:50.082]                   }
[11:02:50.082]                   ...future.conditions[[length(...future.conditions) + 
[11:02:50.082]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:50.082]                     cond$call), session = sessionInformation(), 
[11:02:50.082]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:50.082]                   signalCondition(cond)
[11:02:50.082]                 }
[11:02:50.082]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:50.082]                 "immediateCondition"))) {
[11:02:50.082]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:50.082]                   ...future.conditions[[length(...future.conditions) + 
[11:02:50.082]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:50.082]                   if (TRUE && !signal) {
[11:02:50.082]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:50.082]                     {
[11:02:50.082]                       inherits <- base::inherits
[11:02:50.082]                       invokeRestart <- base::invokeRestart
[11:02:50.082]                       is.null <- base::is.null
[11:02:50.082]                       muffled <- FALSE
[11:02:50.082]                       if (inherits(cond, "message")) {
[11:02:50.082]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:50.082]                         if (muffled) 
[11:02:50.082]                           invokeRestart("muffleMessage")
[11:02:50.082]                       }
[11:02:50.082]                       else if (inherits(cond, "warning")) {
[11:02:50.082]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:50.082]                         if (muffled) 
[11:02:50.082]                           invokeRestart("muffleWarning")
[11:02:50.082]                       }
[11:02:50.082]                       else if (inherits(cond, "condition")) {
[11:02:50.082]                         if (!is.null(pattern)) {
[11:02:50.082]                           computeRestarts <- base::computeRestarts
[11:02:50.082]                           grepl <- base::grepl
[11:02:50.082]                           restarts <- computeRestarts(cond)
[11:02:50.082]                           for (restart in restarts) {
[11:02:50.082]                             name <- restart$name
[11:02:50.082]                             if (is.null(name)) 
[11:02:50.082]                               next
[11:02:50.082]                             if (!grepl(pattern, name)) 
[11:02:50.082]                               next
[11:02:50.082]                             invokeRestart(restart)
[11:02:50.082]                             muffled <- TRUE
[11:02:50.082]                             break
[11:02:50.082]                           }
[11:02:50.082]                         }
[11:02:50.082]                       }
[11:02:50.082]                       invisible(muffled)
[11:02:50.082]                     }
[11:02:50.082]                     muffleCondition(cond, pattern = "^muffle")
[11:02:50.082]                   }
[11:02:50.082]                 }
[11:02:50.082]                 else {
[11:02:50.082]                   if (TRUE) {
[11:02:50.082]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:50.082]                     {
[11:02:50.082]                       inherits <- base::inherits
[11:02:50.082]                       invokeRestart <- base::invokeRestart
[11:02:50.082]                       is.null <- base::is.null
[11:02:50.082]                       muffled <- FALSE
[11:02:50.082]                       if (inherits(cond, "message")) {
[11:02:50.082]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:50.082]                         if (muffled) 
[11:02:50.082]                           invokeRestart("muffleMessage")
[11:02:50.082]                       }
[11:02:50.082]                       else if (inherits(cond, "warning")) {
[11:02:50.082]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:50.082]                         if (muffled) 
[11:02:50.082]                           invokeRestart("muffleWarning")
[11:02:50.082]                       }
[11:02:50.082]                       else if (inherits(cond, "condition")) {
[11:02:50.082]                         if (!is.null(pattern)) {
[11:02:50.082]                           computeRestarts <- base::computeRestarts
[11:02:50.082]                           grepl <- base::grepl
[11:02:50.082]                           restarts <- computeRestarts(cond)
[11:02:50.082]                           for (restart in restarts) {
[11:02:50.082]                             name <- restart$name
[11:02:50.082]                             if (is.null(name)) 
[11:02:50.082]                               next
[11:02:50.082]                             if (!grepl(pattern, name)) 
[11:02:50.082]                               next
[11:02:50.082]                             invokeRestart(restart)
[11:02:50.082]                             muffled <- TRUE
[11:02:50.082]                             break
[11:02:50.082]                           }
[11:02:50.082]                         }
[11:02:50.082]                       }
[11:02:50.082]                       invisible(muffled)
[11:02:50.082]                     }
[11:02:50.082]                     muffleCondition(cond, pattern = "^muffle")
[11:02:50.082]                   }
[11:02:50.082]                 }
[11:02:50.082]             }
[11:02:50.082]         }))
[11:02:50.082]     }, error = function(ex) {
[11:02:50.082]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:50.082]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:50.082]                 ...future.rng), started = ...future.startTime, 
[11:02:50.082]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:50.082]             version = "1.8"), class = "FutureResult")
[11:02:50.082]     }, finally = {
[11:02:50.082]         if (!identical(...future.workdir, getwd())) 
[11:02:50.082]             setwd(...future.workdir)
[11:02:50.082]         {
[11:02:50.082]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:50.082]                 ...future.oldOptions$nwarnings <- NULL
[11:02:50.082]             }
[11:02:50.082]             base::options(...future.oldOptions)
[11:02:50.082]             if (.Platform$OS.type == "windows") {
[11:02:50.082]                 old_names <- names(...future.oldEnvVars)
[11:02:50.082]                 envs <- base::Sys.getenv()
[11:02:50.082]                 names <- names(envs)
[11:02:50.082]                 common <- intersect(names, old_names)
[11:02:50.082]                 added <- setdiff(names, old_names)
[11:02:50.082]                 removed <- setdiff(old_names, names)
[11:02:50.082]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:50.082]                   envs[common]]
[11:02:50.082]                 NAMES <- toupper(changed)
[11:02:50.082]                 args <- list()
[11:02:50.082]                 for (kk in seq_along(NAMES)) {
[11:02:50.082]                   name <- changed[[kk]]
[11:02:50.082]                   NAME <- NAMES[[kk]]
[11:02:50.082]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:50.082]                     next
[11:02:50.082]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:50.082]                 }
[11:02:50.082]                 NAMES <- toupper(added)
[11:02:50.082]                 for (kk in seq_along(NAMES)) {
[11:02:50.082]                   name <- added[[kk]]
[11:02:50.082]                   NAME <- NAMES[[kk]]
[11:02:50.082]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:50.082]                     next
[11:02:50.082]                   args[[name]] <- ""
[11:02:50.082]                 }
[11:02:50.082]                 NAMES <- toupper(removed)
[11:02:50.082]                 for (kk in seq_along(NAMES)) {
[11:02:50.082]                   name <- removed[[kk]]
[11:02:50.082]                   NAME <- NAMES[[kk]]
[11:02:50.082]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:50.082]                     next
[11:02:50.082]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:50.082]                 }
[11:02:50.082]                 if (length(args) > 0) 
[11:02:50.082]                   base::do.call(base::Sys.setenv, args = args)
[11:02:50.082]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:50.082]             }
[11:02:50.082]             else {
[11:02:50.082]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:50.082]             }
[11:02:50.082]             {
[11:02:50.082]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:50.082]                   0L) {
[11:02:50.082]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:50.082]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:50.082]                   base::options(opts)
[11:02:50.082]                 }
[11:02:50.082]                 {
[11:02:50.082]                   {
[11:02:50.082]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:50.082]                     NULL
[11:02:50.082]                   }
[11:02:50.082]                   options(future.plan = NULL)
[11:02:50.082]                   if (is.na(NA_character_)) 
[11:02:50.082]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:50.082]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:50.082]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:50.082]                     .init = FALSE)
[11:02:50.082]                 }
[11:02:50.082]             }
[11:02:50.082]         }
[11:02:50.082]     })
[11:02:50.082]     if (TRUE) {
[11:02:50.082]         base::sink(type = "output", split = FALSE)
[11:02:50.082]         if (TRUE) {
[11:02:50.082]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:50.082]         }
[11:02:50.082]         else {
[11:02:50.082]             ...future.result["stdout"] <- base::list(NULL)
[11:02:50.082]         }
[11:02:50.082]         base::close(...future.stdout)
[11:02:50.082]         ...future.stdout <- NULL
[11:02:50.082]     }
[11:02:50.082]     ...future.result$conditions <- ...future.conditions
[11:02:50.082]     ...future.result$finished <- base::Sys.time()
[11:02:50.082]     ...future.result
[11:02:50.082] }
[11:02:50.085] MultisessionFuture started
[11:02:50.085] - Launch lazy future ... done
[11:02:50.085] run() for ‘MultisessionFuture’ ... done
[11:02:50.627] receiveMessageFromWorker() for ClusterFuture ...
[11:02:50.627] - Validating connection of MultisessionFuture
[11:02:50.627] - received message: FutureResult
[11:02:50.627] - Received FutureResult
[11:02:50.628] - Erased future from FutureRegistry
[11:02:50.628] result() for ClusterFuture ...
[11:02:50.628] - result already collected: FutureResult
[11:02:50.628] result() for ClusterFuture ... done
[11:02:50.628] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:50.628] resolve() on list ...
[11:02:50.628]  recursive: 98
[11:02:50.628]  length: 2
[11:02:50.628]  elements: ‘a’, ‘b’
[11:02:50.628]  length: 1 (resolved future 1)
[11:02:50.628]  length: 0 (resolved future 2)
[11:02:50.629] resolve() on list ... DONE
[11:02:50.629] A MultisessionFuture was resolved (and resolved itself)
[11:02:50.629] getGlobalsAndPackages() ...
[11:02:50.629] Searching for globals...
[11:02:50.630] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[11:02:50.630] Searching for globals ... DONE
[11:02:50.630] Resolving globals: FALSE
[11:02:50.631] 
[11:02:50.631] 
[11:02:50.631] getGlobalsAndPackages() ... DONE
[11:02:50.631] run() for ‘Future’ ...
[11:02:50.631] - state: ‘created’
[11:02:50.631] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:50.646] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:50.646] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:50.646]   - Field: ‘node’
[11:02:50.646]   - Field: ‘label’
[11:02:50.646]   - Field: ‘local’
[11:02:50.646]   - Field: ‘owner’
[11:02:50.646]   - Field: ‘envir’
[11:02:50.646]   - Field: ‘workers’
[11:02:50.646]   - Field: ‘packages’
[11:02:50.647]   - Field: ‘gc’
[11:02:50.647]   - Field: ‘conditions’
[11:02:50.647]   - Field: ‘persistent’
[11:02:50.647]   - Field: ‘expr’
[11:02:50.647]   - Field: ‘uuid’
[11:02:50.647]   - Field: ‘seed’
[11:02:50.647]   - Field: ‘version’
[11:02:50.647]   - Field: ‘result’
[11:02:50.647]   - Field: ‘asynchronous’
[11:02:50.647]   - Field: ‘calls’
[11:02:50.647]   - Field: ‘globals’
[11:02:50.648]   - Field: ‘stdout’
[11:02:50.648]   - Field: ‘earlySignal’
[11:02:50.648]   - Field: ‘lazy’
[11:02:50.648]   - Field: ‘state’
[11:02:50.648] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:50.648] - Launch lazy future ...
[11:02:50.648] Packages needed by the future expression (n = 0): <none>
[11:02:50.648] Packages needed by future strategies (n = 0): <none>
[11:02:50.649] {
[11:02:50.649]     {
[11:02:50.649]         {
[11:02:50.649]             ...future.startTime <- base::Sys.time()
[11:02:50.649]             {
[11:02:50.649]                 {
[11:02:50.649]                   {
[11:02:50.649]                     {
[11:02:50.649]                       base::local({
[11:02:50.649]                         has_future <- base::requireNamespace("future", 
[11:02:50.649]                           quietly = TRUE)
[11:02:50.649]                         if (has_future) {
[11:02:50.649]                           ns <- base::getNamespace("future")
[11:02:50.649]                           version <- ns[[".package"]][["version"]]
[11:02:50.649]                           if (is.null(version)) 
[11:02:50.649]                             version <- utils::packageVersion("future")
[11:02:50.649]                         }
[11:02:50.649]                         else {
[11:02:50.649]                           version <- NULL
[11:02:50.649]                         }
[11:02:50.649]                         if (!has_future || version < "1.8.0") {
[11:02:50.649]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:50.649]                             "", base::R.version$version.string), 
[11:02:50.649]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:50.649]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:50.649]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:50.649]                               "release", "version")], collapse = " "), 
[11:02:50.649]                             hostname = base::Sys.info()[["nodename"]])
[11:02:50.649]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:50.649]                             info)
[11:02:50.649]                           info <- base::paste(info, collapse = "; ")
[11:02:50.649]                           if (!has_future) {
[11:02:50.649]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:50.649]                               info)
[11:02:50.649]                           }
[11:02:50.649]                           else {
[11:02:50.649]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:50.649]                               info, version)
[11:02:50.649]                           }
[11:02:50.649]                           base::stop(msg)
[11:02:50.649]                         }
[11:02:50.649]                       })
[11:02:50.649]                     }
[11:02:50.649]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:50.649]                     base::options(mc.cores = 1L)
[11:02:50.649]                   }
[11:02:50.649]                   ...future.strategy.old <- future::plan("list")
[11:02:50.649]                   options(future.plan = NULL)
[11:02:50.649]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:50.649]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:50.649]                 }
[11:02:50.649]                 ...future.workdir <- getwd()
[11:02:50.649]             }
[11:02:50.649]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:50.649]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:50.649]         }
[11:02:50.649]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:50.649]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:50.649]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:50.649]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:50.649]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:50.649]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:50.649]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:50.649]             base::names(...future.oldOptions))
[11:02:50.649]     }
[11:02:50.649]     if (FALSE) {
[11:02:50.649]     }
[11:02:50.649]     else {
[11:02:50.649]         if (TRUE) {
[11:02:50.649]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:50.649]                 open = "w")
[11:02:50.649]         }
[11:02:50.649]         else {
[11:02:50.649]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:50.649]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:50.649]         }
[11:02:50.649]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:50.649]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:50.649]             base::sink(type = "output", split = FALSE)
[11:02:50.649]             base::close(...future.stdout)
[11:02:50.649]         }, add = TRUE)
[11:02:50.649]     }
[11:02:50.649]     ...future.frame <- base::sys.nframe()
[11:02:50.649]     ...future.conditions <- base::list()
[11:02:50.649]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:50.649]     if (FALSE) {
[11:02:50.649]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:50.649]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:50.649]     }
[11:02:50.649]     ...future.result <- base::tryCatch({
[11:02:50.649]         base::withCallingHandlers({
[11:02:50.649]             ...future.value <- base::withVisible(base::local({
[11:02:50.649]                 ...future.makeSendCondition <- base::local({
[11:02:50.649]                   sendCondition <- NULL
[11:02:50.649]                   function(frame = 1L) {
[11:02:50.649]                     if (is.function(sendCondition)) 
[11:02:50.649]                       return(sendCondition)
[11:02:50.649]                     ns <- getNamespace("parallel")
[11:02:50.649]                     if (exists("sendData", mode = "function", 
[11:02:50.649]                       envir = ns)) {
[11:02:50.649]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:50.649]                         envir = ns)
[11:02:50.649]                       envir <- sys.frame(frame)
[11:02:50.649]                       master <- NULL
[11:02:50.649]                       while (!identical(envir, .GlobalEnv) && 
[11:02:50.649]                         !identical(envir, emptyenv())) {
[11:02:50.649]                         if (exists("master", mode = "list", envir = envir, 
[11:02:50.649]                           inherits = FALSE)) {
[11:02:50.649]                           master <- get("master", mode = "list", 
[11:02:50.649]                             envir = envir, inherits = FALSE)
[11:02:50.649]                           if (inherits(master, c("SOCKnode", 
[11:02:50.649]                             "SOCK0node"))) {
[11:02:50.649]                             sendCondition <<- function(cond) {
[11:02:50.649]                               data <- list(type = "VALUE", value = cond, 
[11:02:50.649]                                 success = TRUE)
[11:02:50.649]                               parallel_sendData(master, data)
[11:02:50.649]                             }
[11:02:50.649]                             return(sendCondition)
[11:02:50.649]                           }
[11:02:50.649]                         }
[11:02:50.649]                         frame <- frame + 1L
[11:02:50.649]                         envir <- sys.frame(frame)
[11:02:50.649]                       }
[11:02:50.649]                     }
[11:02:50.649]                     sendCondition <<- function(cond) NULL
[11:02:50.649]                   }
[11:02:50.649]                 })
[11:02:50.649]                 withCallingHandlers({
[11:02:50.649]                   {
[11:02:50.649]                     Sys.sleep(0.5)
[11:02:50.649]                     list(a = 1, b = 42L)
[11:02:50.649]                   }
[11:02:50.649]                 }, immediateCondition = function(cond) {
[11:02:50.649]                   sendCondition <- ...future.makeSendCondition()
[11:02:50.649]                   sendCondition(cond)
[11:02:50.649]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:50.649]                   {
[11:02:50.649]                     inherits <- base::inherits
[11:02:50.649]                     invokeRestart <- base::invokeRestart
[11:02:50.649]                     is.null <- base::is.null
[11:02:50.649]                     muffled <- FALSE
[11:02:50.649]                     if (inherits(cond, "message")) {
[11:02:50.649]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:50.649]                       if (muffled) 
[11:02:50.649]                         invokeRestart("muffleMessage")
[11:02:50.649]                     }
[11:02:50.649]                     else if (inherits(cond, "warning")) {
[11:02:50.649]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:50.649]                       if (muffled) 
[11:02:50.649]                         invokeRestart("muffleWarning")
[11:02:50.649]                     }
[11:02:50.649]                     else if (inherits(cond, "condition")) {
[11:02:50.649]                       if (!is.null(pattern)) {
[11:02:50.649]                         computeRestarts <- base::computeRestarts
[11:02:50.649]                         grepl <- base::grepl
[11:02:50.649]                         restarts <- computeRestarts(cond)
[11:02:50.649]                         for (restart in restarts) {
[11:02:50.649]                           name <- restart$name
[11:02:50.649]                           if (is.null(name)) 
[11:02:50.649]                             next
[11:02:50.649]                           if (!grepl(pattern, name)) 
[11:02:50.649]                             next
[11:02:50.649]                           invokeRestart(restart)
[11:02:50.649]                           muffled <- TRUE
[11:02:50.649]                           break
[11:02:50.649]                         }
[11:02:50.649]                       }
[11:02:50.649]                     }
[11:02:50.649]                     invisible(muffled)
[11:02:50.649]                   }
[11:02:50.649]                   muffleCondition(cond)
[11:02:50.649]                 })
[11:02:50.649]             }))
[11:02:50.649]             future::FutureResult(value = ...future.value$value, 
[11:02:50.649]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:50.649]                   ...future.rng), globalenv = if (FALSE) 
[11:02:50.649]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:50.649]                     ...future.globalenv.names))
[11:02:50.649]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:50.649]         }, condition = base::local({
[11:02:50.649]             c <- base::c
[11:02:50.649]             inherits <- base::inherits
[11:02:50.649]             invokeRestart <- base::invokeRestart
[11:02:50.649]             length <- base::length
[11:02:50.649]             list <- base::list
[11:02:50.649]             seq.int <- base::seq.int
[11:02:50.649]             signalCondition <- base::signalCondition
[11:02:50.649]             sys.calls <- base::sys.calls
[11:02:50.649]             `[[` <- base::`[[`
[11:02:50.649]             `+` <- base::`+`
[11:02:50.649]             `<<-` <- base::`<<-`
[11:02:50.649]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:50.649]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:50.649]                   3L)]
[11:02:50.649]             }
[11:02:50.649]             function(cond) {
[11:02:50.649]                 is_error <- inherits(cond, "error")
[11:02:50.649]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:50.649]                   NULL)
[11:02:50.649]                 if (is_error) {
[11:02:50.649]                   sessionInformation <- function() {
[11:02:50.649]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:50.649]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:50.649]                       search = base::search(), system = base::Sys.info())
[11:02:50.649]                   }
[11:02:50.649]                   ...future.conditions[[length(...future.conditions) + 
[11:02:50.649]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:50.649]                     cond$call), session = sessionInformation(), 
[11:02:50.649]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:50.649]                   signalCondition(cond)
[11:02:50.649]                 }
[11:02:50.649]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:50.649]                 "immediateCondition"))) {
[11:02:50.649]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:50.649]                   ...future.conditions[[length(...future.conditions) + 
[11:02:50.649]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:50.649]                   if (TRUE && !signal) {
[11:02:50.649]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:50.649]                     {
[11:02:50.649]                       inherits <- base::inherits
[11:02:50.649]                       invokeRestart <- base::invokeRestart
[11:02:50.649]                       is.null <- base::is.null
[11:02:50.649]                       muffled <- FALSE
[11:02:50.649]                       if (inherits(cond, "message")) {
[11:02:50.649]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:50.649]                         if (muffled) 
[11:02:50.649]                           invokeRestart("muffleMessage")
[11:02:50.649]                       }
[11:02:50.649]                       else if (inherits(cond, "warning")) {
[11:02:50.649]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:50.649]                         if (muffled) 
[11:02:50.649]                           invokeRestart("muffleWarning")
[11:02:50.649]                       }
[11:02:50.649]                       else if (inherits(cond, "condition")) {
[11:02:50.649]                         if (!is.null(pattern)) {
[11:02:50.649]                           computeRestarts <- base::computeRestarts
[11:02:50.649]                           grepl <- base::grepl
[11:02:50.649]                           restarts <- computeRestarts(cond)
[11:02:50.649]                           for (restart in restarts) {
[11:02:50.649]                             name <- restart$name
[11:02:50.649]                             if (is.null(name)) 
[11:02:50.649]                               next
[11:02:50.649]                             if (!grepl(pattern, name)) 
[11:02:50.649]                               next
[11:02:50.649]                             invokeRestart(restart)
[11:02:50.649]                             muffled <- TRUE
[11:02:50.649]                             break
[11:02:50.649]                           }
[11:02:50.649]                         }
[11:02:50.649]                       }
[11:02:50.649]                       invisible(muffled)
[11:02:50.649]                     }
[11:02:50.649]                     muffleCondition(cond, pattern = "^muffle")
[11:02:50.649]                   }
[11:02:50.649]                 }
[11:02:50.649]                 else {
[11:02:50.649]                   if (TRUE) {
[11:02:50.649]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:50.649]                     {
[11:02:50.649]                       inherits <- base::inherits
[11:02:50.649]                       invokeRestart <- base::invokeRestart
[11:02:50.649]                       is.null <- base::is.null
[11:02:50.649]                       muffled <- FALSE
[11:02:50.649]                       if (inherits(cond, "message")) {
[11:02:50.649]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:50.649]                         if (muffled) 
[11:02:50.649]                           invokeRestart("muffleMessage")
[11:02:50.649]                       }
[11:02:50.649]                       else if (inherits(cond, "warning")) {
[11:02:50.649]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:50.649]                         if (muffled) 
[11:02:50.649]                           invokeRestart("muffleWarning")
[11:02:50.649]                       }
[11:02:50.649]                       else if (inherits(cond, "condition")) {
[11:02:50.649]                         if (!is.null(pattern)) {
[11:02:50.649]                           computeRestarts <- base::computeRestarts
[11:02:50.649]                           grepl <- base::grepl
[11:02:50.649]                           restarts <- computeRestarts(cond)
[11:02:50.649]                           for (restart in restarts) {
[11:02:50.649]                             name <- restart$name
[11:02:50.649]                             if (is.null(name)) 
[11:02:50.649]                               next
[11:02:50.649]                             if (!grepl(pattern, name)) 
[11:02:50.649]                               next
[11:02:50.649]                             invokeRestart(restart)
[11:02:50.649]                             muffled <- TRUE
[11:02:50.649]                             break
[11:02:50.649]                           }
[11:02:50.649]                         }
[11:02:50.649]                       }
[11:02:50.649]                       invisible(muffled)
[11:02:50.649]                     }
[11:02:50.649]                     muffleCondition(cond, pattern = "^muffle")
[11:02:50.649]                   }
[11:02:50.649]                 }
[11:02:50.649]             }
[11:02:50.649]         }))
[11:02:50.649]     }, error = function(ex) {
[11:02:50.649]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:50.649]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:50.649]                 ...future.rng), started = ...future.startTime, 
[11:02:50.649]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:50.649]             version = "1.8"), class = "FutureResult")
[11:02:50.649]     }, finally = {
[11:02:50.649]         if (!identical(...future.workdir, getwd())) 
[11:02:50.649]             setwd(...future.workdir)
[11:02:50.649]         {
[11:02:50.649]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:50.649]                 ...future.oldOptions$nwarnings <- NULL
[11:02:50.649]             }
[11:02:50.649]             base::options(...future.oldOptions)
[11:02:50.649]             if (.Platform$OS.type == "windows") {
[11:02:50.649]                 old_names <- names(...future.oldEnvVars)
[11:02:50.649]                 envs <- base::Sys.getenv()
[11:02:50.649]                 names <- names(envs)
[11:02:50.649]                 common <- intersect(names, old_names)
[11:02:50.649]                 added <- setdiff(names, old_names)
[11:02:50.649]                 removed <- setdiff(old_names, names)
[11:02:50.649]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:50.649]                   envs[common]]
[11:02:50.649]                 NAMES <- toupper(changed)
[11:02:50.649]                 args <- list()
[11:02:50.649]                 for (kk in seq_along(NAMES)) {
[11:02:50.649]                   name <- changed[[kk]]
[11:02:50.649]                   NAME <- NAMES[[kk]]
[11:02:50.649]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:50.649]                     next
[11:02:50.649]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:50.649]                 }
[11:02:50.649]                 NAMES <- toupper(added)
[11:02:50.649]                 for (kk in seq_along(NAMES)) {
[11:02:50.649]                   name <- added[[kk]]
[11:02:50.649]                   NAME <- NAMES[[kk]]
[11:02:50.649]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:50.649]                     next
[11:02:50.649]                   args[[name]] <- ""
[11:02:50.649]                 }
[11:02:50.649]                 NAMES <- toupper(removed)
[11:02:50.649]                 for (kk in seq_along(NAMES)) {
[11:02:50.649]                   name <- removed[[kk]]
[11:02:50.649]                   NAME <- NAMES[[kk]]
[11:02:50.649]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:50.649]                     next
[11:02:50.649]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:50.649]                 }
[11:02:50.649]                 if (length(args) > 0) 
[11:02:50.649]                   base::do.call(base::Sys.setenv, args = args)
[11:02:50.649]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:50.649]             }
[11:02:50.649]             else {
[11:02:50.649]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:50.649]             }
[11:02:50.649]             {
[11:02:50.649]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:50.649]                   0L) {
[11:02:50.649]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:50.649]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:50.649]                   base::options(opts)
[11:02:50.649]                 }
[11:02:50.649]                 {
[11:02:50.649]                   {
[11:02:50.649]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:50.649]                     NULL
[11:02:50.649]                   }
[11:02:50.649]                   options(future.plan = NULL)
[11:02:50.649]                   if (is.na(NA_character_)) 
[11:02:50.649]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:50.649]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:50.649]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:50.649]                     .init = FALSE)
[11:02:50.649]                 }
[11:02:50.649]             }
[11:02:50.649]         }
[11:02:50.649]     })
[11:02:50.649]     if (TRUE) {
[11:02:50.649]         base::sink(type = "output", split = FALSE)
[11:02:50.649]         if (TRUE) {
[11:02:50.649]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:50.649]         }
[11:02:50.649]         else {
[11:02:50.649]             ...future.result["stdout"] <- base::list(NULL)
[11:02:50.649]         }
[11:02:50.649]         base::close(...future.stdout)
[11:02:50.649]         ...future.stdout <- NULL
[11:02:50.649]     }
[11:02:50.649]     ...future.result$conditions <- ...future.conditions
[11:02:50.649]     ...future.result$finished <- base::Sys.time()
[11:02:50.649]     ...future.result
[11:02:50.649] }
[11:02:50.652] MultisessionFuture started
[11:02:50.652] - Launch lazy future ... done
[11:02:50.652] run() for ‘MultisessionFuture’ ... done
[11:02:51.195] receiveMessageFromWorker() for ClusterFuture ...
[11:02:51.195] - Validating connection of MultisessionFuture
[11:02:51.195] - received message: FutureResult
[11:02:51.195] - Received FutureResult
[11:02:51.196] - Erased future from FutureRegistry
[11:02:51.196] result() for ClusterFuture ...
[11:02:51.196] - result already collected: FutureResult
[11:02:51.196] result() for ClusterFuture ... done
[11:02:51.196] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:51.196] resolve() on list ...
[11:02:51.196]  recursive: 98
[11:02:51.196]  length: 2
[11:02:51.196]  elements: ‘a’, ‘b’
[11:02:51.196]  length: 1 (resolved future 1)
[11:02:51.197]  length: 0 (resolved future 2)
[11:02:51.197] resolve() on list ... DONE
[11:02:51.197] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[11:02:51.197] getGlobalsAndPackages() ...
[11:02:51.197] Searching for globals...
[11:02:51.198] - globals found: [2] ‘list’, ‘stop’
[11:02:51.198] Searching for globals ... DONE
[11:02:51.198] Resolving globals: FALSE
[11:02:51.198] 
[11:02:51.198] 
[11:02:51.198] getGlobalsAndPackages() ... DONE
[11:02:51.199] run() for ‘Future’ ...
[11:02:51.199] - state: ‘created’
[11:02:51.199] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:51.212] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:51.213] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:51.213]   - Field: ‘node’
[11:02:51.213]   - Field: ‘label’
[11:02:51.213]   - Field: ‘local’
[11:02:51.213]   - Field: ‘owner’
[11:02:51.213]   - Field: ‘envir’
[11:02:51.213]   - Field: ‘workers’
[11:02:51.213]   - Field: ‘packages’
[11:02:51.213]   - Field: ‘gc’
[11:02:51.213]   - Field: ‘conditions’
[11:02:51.213]   - Field: ‘persistent’
[11:02:51.214]   - Field: ‘expr’
[11:02:51.214]   - Field: ‘uuid’
[11:02:51.214]   - Field: ‘seed’
[11:02:51.214]   - Field: ‘version’
[11:02:51.214]   - Field: ‘result’
[11:02:51.214]   - Field: ‘asynchronous’
[11:02:51.214]   - Field: ‘calls’
[11:02:51.214]   - Field: ‘globals’
[11:02:51.214]   - Field: ‘stdout’
[11:02:51.214]   - Field: ‘earlySignal’
[11:02:51.214]   - Field: ‘lazy’
[11:02:51.214]   - Field: ‘state’
[11:02:51.214] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:51.215] - Launch lazy future ...
[11:02:51.215] Packages needed by the future expression (n = 0): <none>
[11:02:51.215] Packages needed by future strategies (n = 0): <none>
[11:02:51.215] {
[11:02:51.215]     {
[11:02:51.215]         {
[11:02:51.215]             ...future.startTime <- base::Sys.time()
[11:02:51.215]             {
[11:02:51.215]                 {
[11:02:51.215]                   {
[11:02:51.215]                     {
[11:02:51.215]                       base::local({
[11:02:51.215]                         has_future <- base::requireNamespace("future", 
[11:02:51.215]                           quietly = TRUE)
[11:02:51.215]                         if (has_future) {
[11:02:51.215]                           ns <- base::getNamespace("future")
[11:02:51.215]                           version <- ns[[".package"]][["version"]]
[11:02:51.215]                           if (is.null(version)) 
[11:02:51.215]                             version <- utils::packageVersion("future")
[11:02:51.215]                         }
[11:02:51.215]                         else {
[11:02:51.215]                           version <- NULL
[11:02:51.215]                         }
[11:02:51.215]                         if (!has_future || version < "1.8.0") {
[11:02:51.215]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:51.215]                             "", base::R.version$version.string), 
[11:02:51.215]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:51.215]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:51.215]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:51.215]                               "release", "version")], collapse = " "), 
[11:02:51.215]                             hostname = base::Sys.info()[["nodename"]])
[11:02:51.215]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:51.215]                             info)
[11:02:51.215]                           info <- base::paste(info, collapse = "; ")
[11:02:51.215]                           if (!has_future) {
[11:02:51.215]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:51.215]                               info)
[11:02:51.215]                           }
[11:02:51.215]                           else {
[11:02:51.215]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:51.215]                               info, version)
[11:02:51.215]                           }
[11:02:51.215]                           base::stop(msg)
[11:02:51.215]                         }
[11:02:51.215]                       })
[11:02:51.215]                     }
[11:02:51.215]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:51.215]                     base::options(mc.cores = 1L)
[11:02:51.215]                   }
[11:02:51.215]                   ...future.strategy.old <- future::plan("list")
[11:02:51.215]                   options(future.plan = NULL)
[11:02:51.215]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:51.215]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:51.215]                 }
[11:02:51.215]                 ...future.workdir <- getwd()
[11:02:51.215]             }
[11:02:51.215]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:51.215]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:51.215]         }
[11:02:51.215]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:51.215]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:51.215]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:51.215]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:51.215]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:51.215]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:51.215]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:51.215]             base::names(...future.oldOptions))
[11:02:51.215]     }
[11:02:51.215]     if (FALSE) {
[11:02:51.215]     }
[11:02:51.215]     else {
[11:02:51.215]         if (TRUE) {
[11:02:51.215]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:51.215]                 open = "w")
[11:02:51.215]         }
[11:02:51.215]         else {
[11:02:51.215]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:51.215]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:51.215]         }
[11:02:51.215]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:51.215]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:51.215]             base::sink(type = "output", split = FALSE)
[11:02:51.215]             base::close(...future.stdout)
[11:02:51.215]         }, add = TRUE)
[11:02:51.215]     }
[11:02:51.215]     ...future.frame <- base::sys.nframe()
[11:02:51.215]     ...future.conditions <- base::list()
[11:02:51.215]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:51.215]     if (FALSE) {
[11:02:51.215]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:51.215]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:51.215]     }
[11:02:51.215]     ...future.result <- base::tryCatch({
[11:02:51.215]         base::withCallingHandlers({
[11:02:51.215]             ...future.value <- base::withVisible(base::local({
[11:02:51.215]                 ...future.makeSendCondition <- base::local({
[11:02:51.215]                   sendCondition <- NULL
[11:02:51.215]                   function(frame = 1L) {
[11:02:51.215]                     if (is.function(sendCondition)) 
[11:02:51.215]                       return(sendCondition)
[11:02:51.215]                     ns <- getNamespace("parallel")
[11:02:51.215]                     if (exists("sendData", mode = "function", 
[11:02:51.215]                       envir = ns)) {
[11:02:51.215]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:51.215]                         envir = ns)
[11:02:51.215]                       envir <- sys.frame(frame)
[11:02:51.215]                       master <- NULL
[11:02:51.215]                       while (!identical(envir, .GlobalEnv) && 
[11:02:51.215]                         !identical(envir, emptyenv())) {
[11:02:51.215]                         if (exists("master", mode = "list", envir = envir, 
[11:02:51.215]                           inherits = FALSE)) {
[11:02:51.215]                           master <- get("master", mode = "list", 
[11:02:51.215]                             envir = envir, inherits = FALSE)
[11:02:51.215]                           if (inherits(master, c("SOCKnode", 
[11:02:51.215]                             "SOCK0node"))) {
[11:02:51.215]                             sendCondition <<- function(cond) {
[11:02:51.215]                               data <- list(type = "VALUE", value = cond, 
[11:02:51.215]                                 success = TRUE)
[11:02:51.215]                               parallel_sendData(master, data)
[11:02:51.215]                             }
[11:02:51.215]                             return(sendCondition)
[11:02:51.215]                           }
[11:02:51.215]                         }
[11:02:51.215]                         frame <- frame + 1L
[11:02:51.215]                         envir <- sys.frame(frame)
[11:02:51.215]                       }
[11:02:51.215]                     }
[11:02:51.215]                     sendCondition <<- function(cond) NULL
[11:02:51.215]                   }
[11:02:51.215]                 })
[11:02:51.215]                 withCallingHandlers({
[11:02:51.215]                   list(a = 1, b = 42L, c = stop("Nah!"))
[11:02:51.215]                 }, immediateCondition = function(cond) {
[11:02:51.215]                   sendCondition <- ...future.makeSendCondition()
[11:02:51.215]                   sendCondition(cond)
[11:02:51.215]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:51.215]                   {
[11:02:51.215]                     inherits <- base::inherits
[11:02:51.215]                     invokeRestart <- base::invokeRestart
[11:02:51.215]                     is.null <- base::is.null
[11:02:51.215]                     muffled <- FALSE
[11:02:51.215]                     if (inherits(cond, "message")) {
[11:02:51.215]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:51.215]                       if (muffled) 
[11:02:51.215]                         invokeRestart("muffleMessage")
[11:02:51.215]                     }
[11:02:51.215]                     else if (inherits(cond, "warning")) {
[11:02:51.215]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:51.215]                       if (muffled) 
[11:02:51.215]                         invokeRestart("muffleWarning")
[11:02:51.215]                     }
[11:02:51.215]                     else if (inherits(cond, "condition")) {
[11:02:51.215]                       if (!is.null(pattern)) {
[11:02:51.215]                         computeRestarts <- base::computeRestarts
[11:02:51.215]                         grepl <- base::grepl
[11:02:51.215]                         restarts <- computeRestarts(cond)
[11:02:51.215]                         for (restart in restarts) {
[11:02:51.215]                           name <- restart$name
[11:02:51.215]                           if (is.null(name)) 
[11:02:51.215]                             next
[11:02:51.215]                           if (!grepl(pattern, name)) 
[11:02:51.215]                             next
[11:02:51.215]                           invokeRestart(restart)
[11:02:51.215]                           muffled <- TRUE
[11:02:51.215]                           break
[11:02:51.215]                         }
[11:02:51.215]                       }
[11:02:51.215]                     }
[11:02:51.215]                     invisible(muffled)
[11:02:51.215]                   }
[11:02:51.215]                   muffleCondition(cond)
[11:02:51.215]                 })
[11:02:51.215]             }))
[11:02:51.215]             future::FutureResult(value = ...future.value$value, 
[11:02:51.215]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:51.215]                   ...future.rng), globalenv = if (FALSE) 
[11:02:51.215]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:51.215]                     ...future.globalenv.names))
[11:02:51.215]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:51.215]         }, condition = base::local({
[11:02:51.215]             c <- base::c
[11:02:51.215]             inherits <- base::inherits
[11:02:51.215]             invokeRestart <- base::invokeRestart
[11:02:51.215]             length <- base::length
[11:02:51.215]             list <- base::list
[11:02:51.215]             seq.int <- base::seq.int
[11:02:51.215]             signalCondition <- base::signalCondition
[11:02:51.215]             sys.calls <- base::sys.calls
[11:02:51.215]             `[[` <- base::`[[`
[11:02:51.215]             `+` <- base::`+`
[11:02:51.215]             `<<-` <- base::`<<-`
[11:02:51.215]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:51.215]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:51.215]                   3L)]
[11:02:51.215]             }
[11:02:51.215]             function(cond) {
[11:02:51.215]                 is_error <- inherits(cond, "error")
[11:02:51.215]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:51.215]                   NULL)
[11:02:51.215]                 if (is_error) {
[11:02:51.215]                   sessionInformation <- function() {
[11:02:51.215]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:51.215]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:51.215]                       search = base::search(), system = base::Sys.info())
[11:02:51.215]                   }
[11:02:51.215]                   ...future.conditions[[length(...future.conditions) + 
[11:02:51.215]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:51.215]                     cond$call), session = sessionInformation(), 
[11:02:51.215]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:51.215]                   signalCondition(cond)
[11:02:51.215]                 }
[11:02:51.215]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:51.215]                 "immediateCondition"))) {
[11:02:51.215]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:51.215]                   ...future.conditions[[length(...future.conditions) + 
[11:02:51.215]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:51.215]                   if (TRUE && !signal) {
[11:02:51.215]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:51.215]                     {
[11:02:51.215]                       inherits <- base::inherits
[11:02:51.215]                       invokeRestart <- base::invokeRestart
[11:02:51.215]                       is.null <- base::is.null
[11:02:51.215]                       muffled <- FALSE
[11:02:51.215]                       if (inherits(cond, "message")) {
[11:02:51.215]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:51.215]                         if (muffled) 
[11:02:51.215]                           invokeRestart("muffleMessage")
[11:02:51.215]                       }
[11:02:51.215]                       else if (inherits(cond, "warning")) {
[11:02:51.215]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:51.215]                         if (muffled) 
[11:02:51.215]                           invokeRestart("muffleWarning")
[11:02:51.215]                       }
[11:02:51.215]                       else if (inherits(cond, "condition")) {
[11:02:51.215]                         if (!is.null(pattern)) {
[11:02:51.215]                           computeRestarts <- base::computeRestarts
[11:02:51.215]                           grepl <- base::grepl
[11:02:51.215]                           restarts <- computeRestarts(cond)
[11:02:51.215]                           for (restart in restarts) {
[11:02:51.215]                             name <- restart$name
[11:02:51.215]                             if (is.null(name)) 
[11:02:51.215]                               next
[11:02:51.215]                             if (!grepl(pattern, name)) 
[11:02:51.215]                               next
[11:02:51.215]                             invokeRestart(restart)
[11:02:51.215]                             muffled <- TRUE
[11:02:51.215]                             break
[11:02:51.215]                           }
[11:02:51.215]                         }
[11:02:51.215]                       }
[11:02:51.215]                       invisible(muffled)
[11:02:51.215]                     }
[11:02:51.215]                     muffleCondition(cond, pattern = "^muffle")
[11:02:51.215]                   }
[11:02:51.215]                 }
[11:02:51.215]                 else {
[11:02:51.215]                   if (TRUE) {
[11:02:51.215]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:51.215]                     {
[11:02:51.215]                       inherits <- base::inherits
[11:02:51.215]                       invokeRestart <- base::invokeRestart
[11:02:51.215]                       is.null <- base::is.null
[11:02:51.215]                       muffled <- FALSE
[11:02:51.215]                       if (inherits(cond, "message")) {
[11:02:51.215]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:51.215]                         if (muffled) 
[11:02:51.215]                           invokeRestart("muffleMessage")
[11:02:51.215]                       }
[11:02:51.215]                       else if (inherits(cond, "warning")) {
[11:02:51.215]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:51.215]                         if (muffled) 
[11:02:51.215]                           invokeRestart("muffleWarning")
[11:02:51.215]                       }
[11:02:51.215]                       else if (inherits(cond, "condition")) {
[11:02:51.215]                         if (!is.null(pattern)) {
[11:02:51.215]                           computeRestarts <- base::computeRestarts
[11:02:51.215]                           grepl <- base::grepl
[11:02:51.215]                           restarts <- computeRestarts(cond)
[11:02:51.215]                           for (restart in restarts) {
[11:02:51.215]                             name <- restart$name
[11:02:51.215]                             if (is.null(name)) 
[11:02:51.215]                               next
[11:02:51.215]                             if (!grepl(pattern, name)) 
[11:02:51.215]                               next
[11:02:51.215]                             invokeRestart(restart)
[11:02:51.215]                             muffled <- TRUE
[11:02:51.215]                             break
[11:02:51.215]                           }
[11:02:51.215]                         }
[11:02:51.215]                       }
[11:02:51.215]                       invisible(muffled)
[11:02:51.215]                     }
[11:02:51.215]                     muffleCondition(cond, pattern = "^muffle")
[11:02:51.215]                   }
[11:02:51.215]                 }
[11:02:51.215]             }
[11:02:51.215]         }))
[11:02:51.215]     }, error = function(ex) {
[11:02:51.215]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:51.215]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:51.215]                 ...future.rng), started = ...future.startTime, 
[11:02:51.215]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:51.215]             version = "1.8"), class = "FutureResult")
[11:02:51.215]     }, finally = {
[11:02:51.215]         if (!identical(...future.workdir, getwd())) 
[11:02:51.215]             setwd(...future.workdir)
[11:02:51.215]         {
[11:02:51.215]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:51.215]                 ...future.oldOptions$nwarnings <- NULL
[11:02:51.215]             }
[11:02:51.215]             base::options(...future.oldOptions)
[11:02:51.215]             if (.Platform$OS.type == "windows") {
[11:02:51.215]                 old_names <- names(...future.oldEnvVars)
[11:02:51.215]                 envs <- base::Sys.getenv()
[11:02:51.215]                 names <- names(envs)
[11:02:51.215]                 common <- intersect(names, old_names)
[11:02:51.215]                 added <- setdiff(names, old_names)
[11:02:51.215]                 removed <- setdiff(old_names, names)
[11:02:51.215]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:51.215]                   envs[common]]
[11:02:51.215]                 NAMES <- toupper(changed)
[11:02:51.215]                 args <- list()
[11:02:51.215]                 for (kk in seq_along(NAMES)) {
[11:02:51.215]                   name <- changed[[kk]]
[11:02:51.215]                   NAME <- NAMES[[kk]]
[11:02:51.215]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:51.215]                     next
[11:02:51.215]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:51.215]                 }
[11:02:51.215]                 NAMES <- toupper(added)
[11:02:51.215]                 for (kk in seq_along(NAMES)) {
[11:02:51.215]                   name <- added[[kk]]
[11:02:51.215]                   NAME <- NAMES[[kk]]
[11:02:51.215]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:51.215]                     next
[11:02:51.215]                   args[[name]] <- ""
[11:02:51.215]                 }
[11:02:51.215]                 NAMES <- toupper(removed)
[11:02:51.215]                 for (kk in seq_along(NAMES)) {
[11:02:51.215]                   name <- removed[[kk]]
[11:02:51.215]                   NAME <- NAMES[[kk]]
[11:02:51.215]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:51.215]                     next
[11:02:51.215]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:51.215]                 }
[11:02:51.215]                 if (length(args) > 0) 
[11:02:51.215]                   base::do.call(base::Sys.setenv, args = args)
[11:02:51.215]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:51.215]             }
[11:02:51.215]             else {
[11:02:51.215]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:51.215]             }
[11:02:51.215]             {
[11:02:51.215]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:51.215]                   0L) {
[11:02:51.215]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:51.215]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:51.215]                   base::options(opts)
[11:02:51.215]                 }
[11:02:51.215]                 {
[11:02:51.215]                   {
[11:02:51.215]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:51.215]                     NULL
[11:02:51.215]                   }
[11:02:51.215]                   options(future.plan = NULL)
[11:02:51.215]                   if (is.na(NA_character_)) 
[11:02:51.215]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:51.215]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:51.215]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:51.215]                     .init = FALSE)
[11:02:51.215]                 }
[11:02:51.215]             }
[11:02:51.215]         }
[11:02:51.215]     })
[11:02:51.215]     if (TRUE) {
[11:02:51.215]         base::sink(type = "output", split = FALSE)
[11:02:51.215]         if (TRUE) {
[11:02:51.215]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:51.215]         }
[11:02:51.215]         else {
[11:02:51.215]             ...future.result["stdout"] <- base::list(NULL)
[11:02:51.215]         }
[11:02:51.215]         base::close(...future.stdout)
[11:02:51.215]         ...future.stdout <- NULL
[11:02:51.215]     }
[11:02:51.215]     ...future.result$conditions <- ...future.conditions
[11:02:51.215]     ...future.result$finished <- base::Sys.time()
[11:02:51.215]     ...future.result
[11:02:51.215] }
[11:02:51.218] MultisessionFuture started
[11:02:51.218] - Launch lazy future ... done
[11:02:51.219] run() for ‘MultisessionFuture’ ... done
[11:02:51.260] receiveMessageFromWorker() for ClusterFuture ...
[11:02:51.261] - Validating connection of MultisessionFuture
[11:02:51.261] - received message: FutureResult
[11:02:51.261] - Received FutureResult
[11:02:51.261] - Erased future from FutureRegistry
[11:02:51.261] result() for ClusterFuture ...
[11:02:51.261] - result already collected: FutureResult
[11:02:51.262] result() for ClusterFuture ... done
[11:02:51.262] signalConditions() ...
[11:02:51.262]  - include = ‘immediateCondition’
[11:02:51.262]  - exclude = 
[11:02:51.262]  - resignal = FALSE
[11:02:51.262]  - Number of conditions: 1
[11:02:51.262] signalConditions() ... done
[11:02:51.262] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:51.262] A MultisessionFuture was resolved (and resolved itself)
[11:02:51.262] getGlobalsAndPackages() ...
[11:02:51.262] Searching for globals...
[11:02:51.263] - globals found: [2] ‘list’, ‘stop’
[11:02:51.263] Searching for globals ... DONE
[11:02:51.263] Resolving globals: FALSE
[11:02:51.263] 
[11:02:51.264] 
[11:02:51.264] getGlobalsAndPackages() ... DONE
[11:02:51.264] run() for ‘Future’ ...
[11:02:51.264] - state: ‘created’
[11:02:51.264] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:51.278] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:51.278] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:51.278]   - Field: ‘node’
[11:02:51.278]   - Field: ‘label’
[11:02:51.278]   - Field: ‘local’
[11:02:51.278]   - Field: ‘owner’
[11:02:51.278]   - Field: ‘envir’
[11:02:51.278]   - Field: ‘workers’
[11:02:51.279]   - Field: ‘packages’
[11:02:51.279]   - Field: ‘gc’
[11:02:51.279]   - Field: ‘conditions’
[11:02:51.279]   - Field: ‘persistent’
[11:02:51.279]   - Field: ‘expr’
[11:02:51.279]   - Field: ‘uuid’
[11:02:51.279]   - Field: ‘seed’
[11:02:51.279]   - Field: ‘version’
[11:02:51.279]   - Field: ‘result’
[11:02:51.279]   - Field: ‘asynchronous’
[11:02:51.279]   - Field: ‘calls’
[11:02:51.279]   - Field: ‘globals’
[11:02:51.280]   - Field: ‘stdout’
[11:02:51.280]   - Field: ‘earlySignal’
[11:02:51.280]   - Field: ‘lazy’
[11:02:51.280]   - Field: ‘state’
[11:02:51.280] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:51.280] - Launch lazy future ...
[11:02:51.280] Packages needed by the future expression (n = 0): <none>
[11:02:51.280] Packages needed by future strategies (n = 0): <none>
[11:02:51.281] {
[11:02:51.281]     {
[11:02:51.281]         {
[11:02:51.281]             ...future.startTime <- base::Sys.time()
[11:02:51.281]             {
[11:02:51.281]                 {
[11:02:51.281]                   {
[11:02:51.281]                     {
[11:02:51.281]                       base::local({
[11:02:51.281]                         has_future <- base::requireNamespace("future", 
[11:02:51.281]                           quietly = TRUE)
[11:02:51.281]                         if (has_future) {
[11:02:51.281]                           ns <- base::getNamespace("future")
[11:02:51.281]                           version <- ns[[".package"]][["version"]]
[11:02:51.281]                           if (is.null(version)) 
[11:02:51.281]                             version <- utils::packageVersion("future")
[11:02:51.281]                         }
[11:02:51.281]                         else {
[11:02:51.281]                           version <- NULL
[11:02:51.281]                         }
[11:02:51.281]                         if (!has_future || version < "1.8.0") {
[11:02:51.281]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:51.281]                             "", base::R.version$version.string), 
[11:02:51.281]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:51.281]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:51.281]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:51.281]                               "release", "version")], collapse = " "), 
[11:02:51.281]                             hostname = base::Sys.info()[["nodename"]])
[11:02:51.281]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:51.281]                             info)
[11:02:51.281]                           info <- base::paste(info, collapse = "; ")
[11:02:51.281]                           if (!has_future) {
[11:02:51.281]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:51.281]                               info)
[11:02:51.281]                           }
[11:02:51.281]                           else {
[11:02:51.281]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:51.281]                               info, version)
[11:02:51.281]                           }
[11:02:51.281]                           base::stop(msg)
[11:02:51.281]                         }
[11:02:51.281]                       })
[11:02:51.281]                     }
[11:02:51.281]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:51.281]                     base::options(mc.cores = 1L)
[11:02:51.281]                   }
[11:02:51.281]                   ...future.strategy.old <- future::plan("list")
[11:02:51.281]                   options(future.plan = NULL)
[11:02:51.281]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:51.281]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:51.281]                 }
[11:02:51.281]                 ...future.workdir <- getwd()
[11:02:51.281]             }
[11:02:51.281]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:51.281]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:51.281]         }
[11:02:51.281]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:51.281]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:51.281]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:51.281]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:51.281]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:51.281]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:51.281]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:51.281]             base::names(...future.oldOptions))
[11:02:51.281]     }
[11:02:51.281]     if (FALSE) {
[11:02:51.281]     }
[11:02:51.281]     else {
[11:02:51.281]         if (TRUE) {
[11:02:51.281]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:51.281]                 open = "w")
[11:02:51.281]         }
[11:02:51.281]         else {
[11:02:51.281]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:51.281]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:51.281]         }
[11:02:51.281]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:51.281]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:51.281]             base::sink(type = "output", split = FALSE)
[11:02:51.281]             base::close(...future.stdout)
[11:02:51.281]         }, add = TRUE)
[11:02:51.281]     }
[11:02:51.281]     ...future.frame <- base::sys.nframe()
[11:02:51.281]     ...future.conditions <- base::list()
[11:02:51.281]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:51.281]     if (FALSE) {
[11:02:51.281]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:51.281]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:51.281]     }
[11:02:51.281]     ...future.result <- base::tryCatch({
[11:02:51.281]         base::withCallingHandlers({
[11:02:51.281]             ...future.value <- base::withVisible(base::local({
[11:02:51.281]                 ...future.makeSendCondition <- base::local({
[11:02:51.281]                   sendCondition <- NULL
[11:02:51.281]                   function(frame = 1L) {
[11:02:51.281]                     if (is.function(sendCondition)) 
[11:02:51.281]                       return(sendCondition)
[11:02:51.281]                     ns <- getNamespace("parallel")
[11:02:51.281]                     if (exists("sendData", mode = "function", 
[11:02:51.281]                       envir = ns)) {
[11:02:51.281]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:51.281]                         envir = ns)
[11:02:51.281]                       envir <- sys.frame(frame)
[11:02:51.281]                       master <- NULL
[11:02:51.281]                       while (!identical(envir, .GlobalEnv) && 
[11:02:51.281]                         !identical(envir, emptyenv())) {
[11:02:51.281]                         if (exists("master", mode = "list", envir = envir, 
[11:02:51.281]                           inherits = FALSE)) {
[11:02:51.281]                           master <- get("master", mode = "list", 
[11:02:51.281]                             envir = envir, inherits = FALSE)
[11:02:51.281]                           if (inherits(master, c("SOCKnode", 
[11:02:51.281]                             "SOCK0node"))) {
[11:02:51.281]                             sendCondition <<- function(cond) {
[11:02:51.281]                               data <- list(type = "VALUE", value = cond, 
[11:02:51.281]                                 success = TRUE)
[11:02:51.281]                               parallel_sendData(master, data)
[11:02:51.281]                             }
[11:02:51.281]                             return(sendCondition)
[11:02:51.281]                           }
[11:02:51.281]                         }
[11:02:51.281]                         frame <- frame + 1L
[11:02:51.281]                         envir <- sys.frame(frame)
[11:02:51.281]                       }
[11:02:51.281]                     }
[11:02:51.281]                     sendCondition <<- function(cond) NULL
[11:02:51.281]                   }
[11:02:51.281]                 })
[11:02:51.281]                 withCallingHandlers({
[11:02:51.281]                   list(a = 1, b = 42L, c = stop("Nah!"))
[11:02:51.281]                 }, immediateCondition = function(cond) {
[11:02:51.281]                   sendCondition <- ...future.makeSendCondition()
[11:02:51.281]                   sendCondition(cond)
[11:02:51.281]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:51.281]                   {
[11:02:51.281]                     inherits <- base::inherits
[11:02:51.281]                     invokeRestart <- base::invokeRestart
[11:02:51.281]                     is.null <- base::is.null
[11:02:51.281]                     muffled <- FALSE
[11:02:51.281]                     if (inherits(cond, "message")) {
[11:02:51.281]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:51.281]                       if (muffled) 
[11:02:51.281]                         invokeRestart("muffleMessage")
[11:02:51.281]                     }
[11:02:51.281]                     else if (inherits(cond, "warning")) {
[11:02:51.281]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:51.281]                       if (muffled) 
[11:02:51.281]                         invokeRestart("muffleWarning")
[11:02:51.281]                     }
[11:02:51.281]                     else if (inherits(cond, "condition")) {
[11:02:51.281]                       if (!is.null(pattern)) {
[11:02:51.281]                         computeRestarts <- base::computeRestarts
[11:02:51.281]                         grepl <- base::grepl
[11:02:51.281]                         restarts <- computeRestarts(cond)
[11:02:51.281]                         for (restart in restarts) {
[11:02:51.281]                           name <- restart$name
[11:02:51.281]                           if (is.null(name)) 
[11:02:51.281]                             next
[11:02:51.281]                           if (!grepl(pattern, name)) 
[11:02:51.281]                             next
[11:02:51.281]                           invokeRestart(restart)
[11:02:51.281]                           muffled <- TRUE
[11:02:51.281]                           break
[11:02:51.281]                         }
[11:02:51.281]                       }
[11:02:51.281]                     }
[11:02:51.281]                     invisible(muffled)
[11:02:51.281]                   }
[11:02:51.281]                   muffleCondition(cond)
[11:02:51.281]                 })
[11:02:51.281]             }))
[11:02:51.281]             future::FutureResult(value = ...future.value$value, 
[11:02:51.281]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:51.281]                   ...future.rng), globalenv = if (FALSE) 
[11:02:51.281]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:51.281]                     ...future.globalenv.names))
[11:02:51.281]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:51.281]         }, condition = base::local({
[11:02:51.281]             c <- base::c
[11:02:51.281]             inherits <- base::inherits
[11:02:51.281]             invokeRestart <- base::invokeRestart
[11:02:51.281]             length <- base::length
[11:02:51.281]             list <- base::list
[11:02:51.281]             seq.int <- base::seq.int
[11:02:51.281]             signalCondition <- base::signalCondition
[11:02:51.281]             sys.calls <- base::sys.calls
[11:02:51.281]             `[[` <- base::`[[`
[11:02:51.281]             `+` <- base::`+`
[11:02:51.281]             `<<-` <- base::`<<-`
[11:02:51.281]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:51.281]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:51.281]                   3L)]
[11:02:51.281]             }
[11:02:51.281]             function(cond) {
[11:02:51.281]                 is_error <- inherits(cond, "error")
[11:02:51.281]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:51.281]                   NULL)
[11:02:51.281]                 if (is_error) {
[11:02:51.281]                   sessionInformation <- function() {
[11:02:51.281]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:51.281]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:51.281]                       search = base::search(), system = base::Sys.info())
[11:02:51.281]                   }
[11:02:51.281]                   ...future.conditions[[length(...future.conditions) + 
[11:02:51.281]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:51.281]                     cond$call), session = sessionInformation(), 
[11:02:51.281]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:51.281]                   signalCondition(cond)
[11:02:51.281]                 }
[11:02:51.281]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:51.281]                 "immediateCondition"))) {
[11:02:51.281]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:51.281]                   ...future.conditions[[length(...future.conditions) + 
[11:02:51.281]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:51.281]                   if (TRUE && !signal) {
[11:02:51.281]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:51.281]                     {
[11:02:51.281]                       inherits <- base::inherits
[11:02:51.281]                       invokeRestart <- base::invokeRestart
[11:02:51.281]                       is.null <- base::is.null
[11:02:51.281]                       muffled <- FALSE
[11:02:51.281]                       if (inherits(cond, "message")) {
[11:02:51.281]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:51.281]                         if (muffled) 
[11:02:51.281]                           invokeRestart("muffleMessage")
[11:02:51.281]                       }
[11:02:51.281]                       else if (inherits(cond, "warning")) {
[11:02:51.281]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:51.281]                         if (muffled) 
[11:02:51.281]                           invokeRestart("muffleWarning")
[11:02:51.281]                       }
[11:02:51.281]                       else if (inherits(cond, "condition")) {
[11:02:51.281]                         if (!is.null(pattern)) {
[11:02:51.281]                           computeRestarts <- base::computeRestarts
[11:02:51.281]                           grepl <- base::grepl
[11:02:51.281]                           restarts <- computeRestarts(cond)
[11:02:51.281]                           for (restart in restarts) {
[11:02:51.281]                             name <- restart$name
[11:02:51.281]                             if (is.null(name)) 
[11:02:51.281]                               next
[11:02:51.281]                             if (!grepl(pattern, name)) 
[11:02:51.281]                               next
[11:02:51.281]                             invokeRestart(restart)
[11:02:51.281]                             muffled <- TRUE
[11:02:51.281]                             break
[11:02:51.281]                           }
[11:02:51.281]                         }
[11:02:51.281]                       }
[11:02:51.281]                       invisible(muffled)
[11:02:51.281]                     }
[11:02:51.281]                     muffleCondition(cond, pattern = "^muffle")
[11:02:51.281]                   }
[11:02:51.281]                 }
[11:02:51.281]                 else {
[11:02:51.281]                   if (TRUE) {
[11:02:51.281]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:51.281]                     {
[11:02:51.281]                       inherits <- base::inherits
[11:02:51.281]                       invokeRestart <- base::invokeRestart
[11:02:51.281]                       is.null <- base::is.null
[11:02:51.281]                       muffled <- FALSE
[11:02:51.281]                       if (inherits(cond, "message")) {
[11:02:51.281]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:51.281]                         if (muffled) 
[11:02:51.281]                           invokeRestart("muffleMessage")
[11:02:51.281]                       }
[11:02:51.281]                       else if (inherits(cond, "warning")) {
[11:02:51.281]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:51.281]                         if (muffled) 
[11:02:51.281]                           invokeRestart("muffleWarning")
[11:02:51.281]                       }
[11:02:51.281]                       else if (inherits(cond, "condition")) {
[11:02:51.281]                         if (!is.null(pattern)) {
[11:02:51.281]                           computeRestarts <- base::computeRestarts
[11:02:51.281]                           grepl <- base::grepl
[11:02:51.281]                           restarts <- computeRestarts(cond)
[11:02:51.281]                           for (restart in restarts) {
[11:02:51.281]                             name <- restart$name
[11:02:51.281]                             if (is.null(name)) 
[11:02:51.281]                               next
[11:02:51.281]                             if (!grepl(pattern, name)) 
[11:02:51.281]                               next
[11:02:51.281]                             invokeRestart(restart)
[11:02:51.281]                             muffled <- TRUE
[11:02:51.281]                             break
[11:02:51.281]                           }
[11:02:51.281]                         }
[11:02:51.281]                       }
[11:02:51.281]                       invisible(muffled)
[11:02:51.281]                     }
[11:02:51.281]                     muffleCondition(cond, pattern = "^muffle")
[11:02:51.281]                   }
[11:02:51.281]                 }
[11:02:51.281]             }
[11:02:51.281]         }))
[11:02:51.281]     }, error = function(ex) {
[11:02:51.281]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:51.281]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:51.281]                 ...future.rng), started = ...future.startTime, 
[11:02:51.281]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:51.281]             version = "1.8"), class = "FutureResult")
[11:02:51.281]     }, finally = {
[11:02:51.281]         if (!identical(...future.workdir, getwd())) 
[11:02:51.281]             setwd(...future.workdir)
[11:02:51.281]         {
[11:02:51.281]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:51.281]                 ...future.oldOptions$nwarnings <- NULL
[11:02:51.281]             }
[11:02:51.281]             base::options(...future.oldOptions)
[11:02:51.281]             if (.Platform$OS.type == "windows") {
[11:02:51.281]                 old_names <- names(...future.oldEnvVars)
[11:02:51.281]                 envs <- base::Sys.getenv()
[11:02:51.281]                 names <- names(envs)
[11:02:51.281]                 common <- intersect(names, old_names)
[11:02:51.281]                 added <- setdiff(names, old_names)
[11:02:51.281]                 removed <- setdiff(old_names, names)
[11:02:51.281]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:51.281]                   envs[common]]
[11:02:51.281]                 NAMES <- toupper(changed)
[11:02:51.281]                 args <- list()
[11:02:51.281]                 for (kk in seq_along(NAMES)) {
[11:02:51.281]                   name <- changed[[kk]]
[11:02:51.281]                   NAME <- NAMES[[kk]]
[11:02:51.281]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:51.281]                     next
[11:02:51.281]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:51.281]                 }
[11:02:51.281]                 NAMES <- toupper(added)
[11:02:51.281]                 for (kk in seq_along(NAMES)) {
[11:02:51.281]                   name <- added[[kk]]
[11:02:51.281]                   NAME <- NAMES[[kk]]
[11:02:51.281]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:51.281]                     next
[11:02:51.281]                   args[[name]] <- ""
[11:02:51.281]                 }
[11:02:51.281]                 NAMES <- toupper(removed)
[11:02:51.281]                 for (kk in seq_along(NAMES)) {
[11:02:51.281]                   name <- removed[[kk]]
[11:02:51.281]                   NAME <- NAMES[[kk]]
[11:02:51.281]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:51.281]                     next
[11:02:51.281]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:51.281]                 }
[11:02:51.281]                 if (length(args) > 0) 
[11:02:51.281]                   base::do.call(base::Sys.setenv, args = args)
[11:02:51.281]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:51.281]             }
[11:02:51.281]             else {
[11:02:51.281]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:51.281]             }
[11:02:51.281]             {
[11:02:51.281]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:51.281]                   0L) {
[11:02:51.281]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:51.281]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:51.281]                   base::options(opts)
[11:02:51.281]                 }
[11:02:51.281]                 {
[11:02:51.281]                   {
[11:02:51.281]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:51.281]                     NULL
[11:02:51.281]                   }
[11:02:51.281]                   options(future.plan = NULL)
[11:02:51.281]                   if (is.na(NA_character_)) 
[11:02:51.281]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:51.281]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:51.281]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:51.281]                     .init = FALSE)
[11:02:51.281]                 }
[11:02:51.281]             }
[11:02:51.281]         }
[11:02:51.281]     })
[11:02:51.281]     if (TRUE) {
[11:02:51.281]         base::sink(type = "output", split = FALSE)
[11:02:51.281]         if (TRUE) {
[11:02:51.281]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:51.281]         }
[11:02:51.281]         else {
[11:02:51.281]             ...future.result["stdout"] <- base::list(NULL)
[11:02:51.281]         }
[11:02:51.281]         base::close(...future.stdout)
[11:02:51.281]         ...future.stdout <- NULL
[11:02:51.281]     }
[11:02:51.281]     ...future.result$conditions <- ...future.conditions
[11:02:51.281]     ...future.result$finished <- base::Sys.time()
[11:02:51.281]     ...future.result
[11:02:51.281] }
[11:02:51.284] MultisessionFuture started
[11:02:51.284] - Launch lazy future ... done
[11:02:51.284] run() for ‘MultisessionFuture’ ... done
[11:02:51.326] receiveMessageFromWorker() for ClusterFuture ...
[11:02:51.326] - Validating connection of MultisessionFuture
[11:02:51.327] - received message: FutureResult
[11:02:51.327] - Received FutureResult
[11:02:51.327] - Erased future from FutureRegistry
[11:02:51.327] result() for ClusterFuture ...
[11:02:51.327] - result already collected: FutureResult
[11:02:51.327] result() for ClusterFuture ... done
[11:02:51.327] signalConditions() ...
[11:02:51.327]  - include = ‘immediateCondition’
[11:02:51.328]  - exclude = 
[11:02:51.328]  - resignal = FALSE
[11:02:51.328]  - Number of conditions: 1
[11:02:51.328] signalConditions() ... done
[11:02:51.328] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:51.328] A MultisessionFuture was resolved (and resolved itself)
- result = TRUE, recursive = TRUE ... DONE
- result = TRUE, recursive = -1 ...
[11:02:51.328] getGlobalsAndPackages() ...
[11:02:51.328] Searching for globals...
[11:02:51.329] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[11:02:51.329] Searching for globals ... DONE
[11:02:51.330] Resolving globals: FALSE
[11:02:51.330] 
[11:02:51.330] 
[11:02:51.330] getGlobalsAndPackages() ... DONE
[11:02:51.330] run() for ‘Future’ ...
[11:02:51.330] - state: ‘created’
[11:02:51.330] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:51.344] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:51.344] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:51.344]   - Field: ‘node’
[11:02:51.344]   - Field: ‘label’
[11:02:51.344]   - Field: ‘local’
[11:02:51.344]   - Field: ‘owner’
[11:02:51.344]   - Field: ‘envir’
[11:02:51.344]   - Field: ‘workers’
[11:02:51.345]   - Field: ‘packages’
[11:02:51.345]   - Field: ‘gc’
[11:02:51.345]   - Field: ‘conditions’
[11:02:51.345]   - Field: ‘persistent’
[11:02:51.345]   - Field: ‘expr’
[11:02:51.345]   - Field: ‘uuid’
[11:02:51.345]   - Field: ‘seed’
[11:02:51.345]   - Field: ‘version’
[11:02:51.345]   - Field: ‘result’
[11:02:51.345]   - Field: ‘asynchronous’
[11:02:51.345]   - Field: ‘calls’
[11:02:51.345]   - Field: ‘globals’
[11:02:51.346]   - Field: ‘stdout’
[11:02:51.346]   - Field: ‘earlySignal’
[11:02:51.346]   - Field: ‘lazy’
[11:02:51.346]   - Field: ‘state’
[11:02:51.346] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:51.346] - Launch lazy future ...
[11:02:51.346] Packages needed by the future expression (n = 0): <none>
[11:02:51.346] Packages needed by future strategies (n = 0): <none>
[11:02:51.347] {
[11:02:51.347]     {
[11:02:51.347]         {
[11:02:51.347]             ...future.startTime <- base::Sys.time()
[11:02:51.347]             {
[11:02:51.347]                 {
[11:02:51.347]                   {
[11:02:51.347]                     {
[11:02:51.347]                       base::local({
[11:02:51.347]                         has_future <- base::requireNamespace("future", 
[11:02:51.347]                           quietly = TRUE)
[11:02:51.347]                         if (has_future) {
[11:02:51.347]                           ns <- base::getNamespace("future")
[11:02:51.347]                           version <- ns[[".package"]][["version"]]
[11:02:51.347]                           if (is.null(version)) 
[11:02:51.347]                             version <- utils::packageVersion("future")
[11:02:51.347]                         }
[11:02:51.347]                         else {
[11:02:51.347]                           version <- NULL
[11:02:51.347]                         }
[11:02:51.347]                         if (!has_future || version < "1.8.0") {
[11:02:51.347]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:51.347]                             "", base::R.version$version.string), 
[11:02:51.347]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:51.347]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:51.347]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:51.347]                               "release", "version")], collapse = " "), 
[11:02:51.347]                             hostname = base::Sys.info()[["nodename"]])
[11:02:51.347]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:51.347]                             info)
[11:02:51.347]                           info <- base::paste(info, collapse = "; ")
[11:02:51.347]                           if (!has_future) {
[11:02:51.347]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:51.347]                               info)
[11:02:51.347]                           }
[11:02:51.347]                           else {
[11:02:51.347]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:51.347]                               info, version)
[11:02:51.347]                           }
[11:02:51.347]                           base::stop(msg)
[11:02:51.347]                         }
[11:02:51.347]                       })
[11:02:51.347]                     }
[11:02:51.347]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:51.347]                     base::options(mc.cores = 1L)
[11:02:51.347]                   }
[11:02:51.347]                   ...future.strategy.old <- future::plan("list")
[11:02:51.347]                   options(future.plan = NULL)
[11:02:51.347]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:51.347]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:51.347]                 }
[11:02:51.347]                 ...future.workdir <- getwd()
[11:02:51.347]             }
[11:02:51.347]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:51.347]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:51.347]         }
[11:02:51.347]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:51.347]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:51.347]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:51.347]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:51.347]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:51.347]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:51.347]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:51.347]             base::names(...future.oldOptions))
[11:02:51.347]     }
[11:02:51.347]     if (FALSE) {
[11:02:51.347]     }
[11:02:51.347]     else {
[11:02:51.347]         if (TRUE) {
[11:02:51.347]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:51.347]                 open = "w")
[11:02:51.347]         }
[11:02:51.347]         else {
[11:02:51.347]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:51.347]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:51.347]         }
[11:02:51.347]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:51.347]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:51.347]             base::sink(type = "output", split = FALSE)
[11:02:51.347]             base::close(...future.stdout)
[11:02:51.347]         }, add = TRUE)
[11:02:51.347]     }
[11:02:51.347]     ...future.frame <- base::sys.nframe()
[11:02:51.347]     ...future.conditions <- base::list()
[11:02:51.347]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:51.347]     if (FALSE) {
[11:02:51.347]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:51.347]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:51.347]     }
[11:02:51.347]     ...future.result <- base::tryCatch({
[11:02:51.347]         base::withCallingHandlers({
[11:02:51.347]             ...future.value <- base::withVisible(base::local({
[11:02:51.347]                 ...future.makeSendCondition <- base::local({
[11:02:51.347]                   sendCondition <- NULL
[11:02:51.347]                   function(frame = 1L) {
[11:02:51.347]                     if (is.function(sendCondition)) 
[11:02:51.347]                       return(sendCondition)
[11:02:51.347]                     ns <- getNamespace("parallel")
[11:02:51.347]                     if (exists("sendData", mode = "function", 
[11:02:51.347]                       envir = ns)) {
[11:02:51.347]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:51.347]                         envir = ns)
[11:02:51.347]                       envir <- sys.frame(frame)
[11:02:51.347]                       master <- NULL
[11:02:51.347]                       while (!identical(envir, .GlobalEnv) && 
[11:02:51.347]                         !identical(envir, emptyenv())) {
[11:02:51.347]                         if (exists("master", mode = "list", envir = envir, 
[11:02:51.347]                           inherits = FALSE)) {
[11:02:51.347]                           master <- get("master", mode = "list", 
[11:02:51.347]                             envir = envir, inherits = FALSE)
[11:02:51.347]                           if (inherits(master, c("SOCKnode", 
[11:02:51.347]                             "SOCK0node"))) {
[11:02:51.347]                             sendCondition <<- function(cond) {
[11:02:51.347]                               data <- list(type = "VALUE", value = cond, 
[11:02:51.347]                                 success = TRUE)
[11:02:51.347]                               parallel_sendData(master, data)
[11:02:51.347]                             }
[11:02:51.347]                             return(sendCondition)
[11:02:51.347]                           }
[11:02:51.347]                         }
[11:02:51.347]                         frame <- frame + 1L
[11:02:51.347]                         envir <- sys.frame(frame)
[11:02:51.347]                       }
[11:02:51.347]                     }
[11:02:51.347]                     sendCondition <<- function(cond) NULL
[11:02:51.347]                   }
[11:02:51.347]                 })
[11:02:51.347]                 withCallingHandlers({
[11:02:51.347]                   {
[11:02:51.347]                     Sys.sleep(0.5)
[11:02:51.347]                     list(a = 1, b = 42L)
[11:02:51.347]                   }
[11:02:51.347]                 }, immediateCondition = function(cond) {
[11:02:51.347]                   sendCondition <- ...future.makeSendCondition()
[11:02:51.347]                   sendCondition(cond)
[11:02:51.347]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:51.347]                   {
[11:02:51.347]                     inherits <- base::inherits
[11:02:51.347]                     invokeRestart <- base::invokeRestart
[11:02:51.347]                     is.null <- base::is.null
[11:02:51.347]                     muffled <- FALSE
[11:02:51.347]                     if (inherits(cond, "message")) {
[11:02:51.347]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:51.347]                       if (muffled) 
[11:02:51.347]                         invokeRestart("muffleMessage")
[11:02:51.347]                     }
[11:02:51.347]                     else if (inherits(cond, "warning")) {
[11:02:51.347]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:51.347]                       if (muffled) 
[11:02:51.347]                         invokeRestart("muffleWarning")
[11:02:51.347]                     }
[11:02:51.347]                     else if (inherits(cond, "condition")) {
[11:02:51.347]                       if (!is.null(pattern)) {
[11:02:51.347]                         computeRestarts <- base::computeRestarts
[11:02:51.347]                         grepl <- base::grepl
[11:02:51.347]                         restarts <- computeRestarts(cond)
[11:02:51.347]                         for (restart in restarts) {
[11:02:51.347]                           name <- restart$name
[11:02:51.347]                           if (is.null(name)) 
[11:02:51.347]                             next
[11:02:51.347]                           if (!grepl(pattern, name)) 
[11:02:51.347]                             next
[11:02:51.347]                           invokeRestart(restart)
[11:02:51.347]                           muffled <- TRUE
[11:02:51.347]                           break
[11:02:51.347]                         }
[11:02:51.347]                       }
[11:02:51.347]                     }
[11:02:51.347]                     invisible(muffled)
[11:02:51.347]                   }
[11:02:51.347]                   muffleCondition(cond)
[11:02:51.347]                 })
[11:02:51.347]             }))
[11:02:51.347]             future::FutureResult(value = ...future.value$value, 
[11:02:51.347]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:51.347]                   ...future.rng), globalenv = if (FALSE) 
[11:02:51.347]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:51.347]                     ...future.globalenv.names))
[11:02:51.347]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:51.347]         }, condition = base::local({
[11:02:51.347]             c <- base::c
[11:02:51.347]             inherits <- base::inherits
[11:02:51.347]             invokeRestart <- base::invokeRestart
[11:02:51.347]             length <- base::length
[11:02:51.347]             list <- base::list
[11:02:51.347]             seq.int <- base::seq.int
[11:02:51.347]             signalCondition <- base::signalCondition
[11:02:51.347]             sys.calls <- base::sys.calls
[11:02:51.347]             `[[` <- base::`[[`
[11:02:51.347]             `+` <- base::`+`
[11:02:51.347]             `<<-` <- base::`<<-`
[11:02:51.347]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:51.347]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:51.347]                   3L)]
[11:02:51.347]             }
[11:02:51.347]             function(cond) {
[11:02:51.347]                 is_error <- inherits(cond, "error")
[11:02:51.347]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:51.347]                   NULL)
[11:02:51.347]                 if (is_error) {
[11:02:51.347]                   sessionInformation <- function() {
[11:02:51.347]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:51.347]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:51.347]                       search = base::search(), system = base::Sys.info())
[11:02:51.347]                   }
[11:02:51.347]                   ...future.conditions[[length(...future.conditions) + 
[11:02:51.347]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:51.347]                     cond$call), session = sessionInformation(), 
[11:02:51.347]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:51.347]                   signalCondition(cond)
[11:02:51.347]                 }
[11:02:51.347]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:51.347]                 "immediateCondition"))) {
[11:02:51.347]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:51.347]                   ...future.conditions[[length(...future.conditions) + 
[11:02:51.347]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:51.347]                   if (TRUE && !signal) {
[11:02:51.347]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:51.347]                     {
[11:02:51.347]                       inherits <- base::inherits
[11:02:51.347]                       invokeRestart <- base::invokeRestart
[11:02:51.347]                       is.null <- base::is.null
[11:02:51.347]                       muffled <- FALSE
[11:02:51.347]                       if (inherits(cond, "message")) {
[11:02:51.347]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:51.347]                         if (muffled) 
[11:02:51.347]                           invokeRestart("muffleMessage")
[11:02:51.347]                       }
[11:02:51.347]                       else if (inherits(cond, "warning")) {
[11:02:51.347]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:51.347]                         if (muffled) 
[11:02:51.347]                           invokeRestart("muffleWarning")
[11:02:51.347]                       }
[11:02:51.347]                       else if (inherits(cond, "condition")) {
[11:02:51.347]                         if (!is.null(pattern)) {
[11:02:51.347]                           computeRestarts <- base::computeRestarts
[11:02:51.347]                           grepl <- base::grepl
[11:02:51.347]                           restarts <- computeRestarts(cond)
[11:02:51.347]                           for (restart in restarts) {
[11:02:51.347]                             name <- restart$name
[11:02:51.347]                             if (is.null(name)) 
[11:02:51.347]                               next
[11:02:51.347]                             if (!grepl(pattern, name)) 
[11:02:51.347]                               next
[11:02:51.347]                             invokeRestart(restart)
[11:02:51.347]                             muffled <- TRUE
[11:02:51.347]                             break
[11:02:51.347]                           }
[11:02:51.347]                         }
[11:02:51.347]                       }
[11:02:51.347]                       invisible(muffled)
[11:02:51.347]                     }
[11:02:51.347]                     muffleCondition(cond, pattern = "^muffle")
[11:02:51.347]                   }
[11:02:51.347]                 }
[11:02:51.347]                 else {
[11:02:51.347]                   if (TRUE) {
[11:02:51.347]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:51.347]                     {
[11:02:51.347]                       inherits <- base::inherits
[11:02:51.347]                       invokeRestart <- base::invokeRestart
[11:02:51.347]                       is.null <- base::is.null
[11:02:51.347]                       muffled <- FALSE
[11:02:51.347]                       if (inherits(cond, "message")) {
[11:02:51.347]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:51.347]                         if (muffled) 
[11:02:51.347]                           invokeRestart("muffleMessage")
[11:02:51.347]                       }
[11:02:51.347]                       else if (inherits(cond, "warning")) {
[11:02:51.347]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:51.347]                         if (muffled) 
[11:02:51.347]                           invokeRestart("muffleWarning")
[11:02:51.347]                       }
[11:02:51.347]                       else if (inherits(cond, "condition")) {
[11:02:51.347]                         if (!is.null(pattern)) {
[11:02:51.347]                           computeRestarts <- base::computeRestarts
[11:02:51.347]                           grepl <- base::grepl
[11:02:51.347]                           restarts <- computeRestarts(cond)
[11:02:51.347]                           for (restart in restarts) {
[11:02:51.347]                             name <- restart$name
[11:02:51.347]                             if (is.null(name)) 
[11:02:51.347]                               next
[11:02:51.347]                             if (!grepl(pattern, name)) 
[11:02:51.347]                               next
[11:02:51.347]                             invokeRestart(restart)
[11:02:51.347]                             muffled <- TRUE
[11:02:51.347]                             break
[11:02:51.347]                           }
[11:02:51.347]                         }
[11:02:51.347]                       }
[11:02:51.347]                       invisible(muffled)
[11:02:51.347]                     }
[11:02:51.347]                     muffleCondition(cond, pattern = "^muffle")
[11:02:51.347]                   }
[11:02:51.347]                 }
[11:02:51.347]             }
[11:02:51.347]         }))
[11:02:51.347]     }, error = function(ex) {
[11:02:51.347]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:51.347]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:51.347]                 ...future.rng), started = ...future.startTime, 
[11:02:51.347]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:51.347]             version = "1.8"), class = "FutureResult")
[11:02:51.347]     }, finally = {
[11:02:51.347]         if (!identical(...future.workdir, getwd())) 
[11:02:51.347]             setwd(...future.workdir)
[11:02:51.347]         {
[11:02:51.347]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:51.347]                 ...future.oldOptions$nwarnings <- NULL
[11:02:51.347]             }
[11:02:51.347]             base::options(...future.oldOptions)
[11:02:51.347]             if (.Platform$OS.type == "windows") {
[11:02:51.347]                 old_names <- names(...future.oldEnvVars)
[11:02:51.347]                 envs <- base::Sys.getenv()
[11:02:51.347]                 names <- names(envs)
[11:02:51.347]                 common <- intersect(names, old_names)
[11:02:51.347]                 added <- setdiff(names, old_names)
[11:02:51.347]                 removed <- setdiff(old_names, names)
[11:02:51.347]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:51.347]                   envs[common]]
[11:02:51.347]                 NAMES <- toupper(changed)
[11:02:51.347]                 args <- list()
[11:02:51.347]                 for (kk in seq_along(NAMES)) {
[11:02:51.347]                   name <- changed[[kk]]
[11:02:51.347]                   NAME <- NAMES[[kk]]
[11:02:51.347]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:51.347]                     next
[11:02:51.347]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:51.347]                 }
[11:02:51.347]                 NAMES <- toupper(added)
[11:02:51.347]                 for (kk in seq_along(NAMES)) {
[11:02:51.347]                   name <- added[[kk]]
[11:02:51.347]                   NAME <- NAMES[[kk]]
[11:02:51.347]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:51.347]                     next
[11:02:51.347]                   args[[name]] <- ""
[11:02:51.347]                 }
[11:02:51.347]                 NAMES <- toupper(removed)
[11:02:51.347]                 for (kk in seq_along(NAMES)) {
[11:02:51.347]                   name <- removed[[kk]]
[11:02:51.347]                   NAME <- NAMES[[kk]]
[11:02:51.347]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:51.347]                     next
[11:02:51.347]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:51.347]                 }
[11:02:51.347]                 if (length(args) > 0) 
[11:02:51.347]                   base::do.call(base::Sys.setenv, args = args)
[11:02:51.347]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:51.347]             }
[11:02:51.347]             else {
[11:02:51.347]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:51.347]             }
[11:02:51.347]             {
[11:02:51.347]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:51.347]                   0L) {
[11:02:51.347]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:51.347]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:51.347]                   base::options(opts)
[11:02:51.347]                 }
[11:02:51.347]                 {
[11:02:51.347]                   {
[11:02:51.347]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:51.347]                     NULL
[11:02:51.347]                   }
[11:02:51.347]                   options(future.plan = NULL)
[11:02:51.347]                   if (is.na(NA_character_)) 
[11:02:51.347]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:51.347]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:51.347]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:51.347]                     .init = FALSE)
[11:02:51.347]                 }
[11:02:51.347]             }
[11:02:51.347]         }
[11:02:51.347]     })
[11:02:51.347]     if (TRUE) {
[11:02:51.347]         base::sink(type = "output", split = FALSE)
[11:02:51.347]         if (TRUE) {
[11:02:51.347]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:51.347]         }
[11:02:51.347]         else {
[11:02:51.347]             ...future.result["stdout"] <- base::list(NULL)
[11:02:51.347]         }
[11:02:51.347]         base::close(...future.stdout)
[11:02:51.347]         ...future.stdout <- NULL
[11:02:51.347]     }
[11:02:51.347]     ...future.result$conditions <- ...future.conditions
[11:02:51.347]     ...future.result$finished <- base::Sys.time()
[11:02:51.347]     ...future.result
[11:02:51.347] }
[11:02:51.349] MultisessionFuture started
[11:02:51.350] - Launch lazy future ... done
[11:02:51.350] run() for ‘MultisessionFuture’ ... done
[11:02:51.350] getGlobalsAndPackages() ...
[11:02:51.350] Searching for globals...
[11:02:51.355] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[11:02:51.355] Searching for globals ... DONE
[11:02:51.355] Resolving globals: FALSE
[11:02:51.356] 
[11:02:51.356] 
[11:02:51.356] getGlobalsAndPackages() ... DONE
- w/ exception ...
[11:02:51.356] getGlobalsAndPackages() ...
[11:02:51.356] Searching for globals...
[11:02:51.357] - globals found: [2] ‘list’, ‘stop’
[11:02:51.357] Searching for globals ... DONE
[11:02:51.357] Resolving globals: FALSE
[11:02:51.357] 
[11:02:51.357] 
[11:02:51.357] getGlobalsAndPackages() ... DONE
[11:02:51.357] run() for ‘Future’ ...
[11:02:51.358] - state: ‘created’
[11:02:51.358] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:51.371] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:51.371] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:51.371]   - Field: ‘node’
[11:02:51.372]   - Field: ‘label’
[11:02:51.372]   - Field: ‘local’
[11:02:51.372]   - Field: ‘owner’
[11:02:51.372]   - Field: ‘envir’
[11:02:51.372]   - Field: ‘workers’
[11:02:51.372]   - Field: ‘packages’
[11:02:51.372]   - Field: ‘gc’
[11:02:51.372]   - Field: ‘conditions’
[11:02:51.372]   - Field: ‘persistent’
[11:02:51.372]   - Field: ‘expr’
[11:02:51.372]   - Field: ‘uuid’
[11:02:51.372]   - Field: ‘seed’
[11:02:51.372]   - Field: ‘version’
[11:02:51.373]   - Field: ‘result’
[11:02:51.373]   - Field: ‘asynchronous’
[11:02:51.373]   - Field: ‘calls’
[11:02:51.373]   - Field: ‘globals’
[11:02:51.373]   - Field: ‘stdout’
[11:02:51.373]   - Field: ‘earlySignal’
[11:02:51.373]   - Field: ‘lazy’
[11:02:51.373]   - Field: ‘state’
[11:02:51.373] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:51.373] - Launch lazy future ...
[11:02:51.374] Packages needed by the future expression (n = 0): <none>
[11:02:51.374] Packages needed by future strategies (n = 0): <none>
[11:02:51.374] {
[11:02:51.374]     {
[11:02:51.374]         {
[11:02:51.374]             ...future.startTime <- base::Sys.time()
[11:02:51.374]             {
[11:02:51.374]                 {
[11:02:51.374]                   {
[11:02:51.374]                     {
[11:02:51.374]                       base::local({
[11:02:51.374]                         has_future <- base::requireNamespace("future", 
[11:02:51.374]                           quietly = TRUE)
[11:02:51.374]                         if (has_future) {
[11:02:51.374]                           ns <- base::getNamespace("future")
[11:02:51.374]                           version <- ns[[".package"]][["version"]]
[11:02:51.374]                           if (is.null(version)) 
[11:02:51.374]                             version <- utils::packageVersion("future")
[11:02:51.374]                         }
[11:02:51.374]                         else {
[11:02:51.374]                           version <- NULL
[11:02:51.374]                         }
[11:02:51.374]                         if (!has_future || version < "1.8.0") {
[11:02:51.374]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:51.374]                             "", base::R.version$version.string), 
[11:02:51.374]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:51.374]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:51.374]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:51.374]                               "release", "version")], collapse = " "), 
[11:02:51.374]                             hostname = base::Sys.info()[["nodename"]])
[11:02:51.374]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:51.374]                             info)
[11:02:51.374]                           info <- base::paste(info, collapse = "; ")
[11:02:51.374]                           if (!has_future) {
[11:02:51.374]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:51.374]                               info)
[11:02:51.374]                           }
[11:02:51.374]                           else {
[11:02:51.374]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:51.374]                               info, version)
[11:02:51.374]                           }
[11:02:51.374]                           base::stop(msg)
[11:02:51.374]                         }
[11:02:51.374]                       })
[11:02:51.374]                     }
[11:02:51.374]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:51.374]                     base::options(mc.cores = 1L)
[11:02:51.374]                   }
[11:02:51.374]                   ...future.strategy.old <- future::plan("list")
[11:02:51.374]                   options(future.plan = NULL)
[11:02:51.374]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:51.374]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:51.374]                 }
[11:02:51.374]                 ...future.workdir <- getwd()
[11:02:51.374]             }
[11:02:51.374]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:51.374]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:51.374]         }
[11:02:51.374]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:51.374]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:51.374]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:51.374]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:51.374]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:51.374]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:51.374]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:51.374]             base::names(...future.oldOptions))
[11:02:51.374]     }
[11:02:51.374]     if (FALSE) {
[11:02:51.374]     }
[11:02:51.374]     else {
[11:02:51.374]         if (TRUE) {
[11:02:51.374]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:51.374]                 open = "w")
[11:02:51.374]         }
[11:02:51.374]         else {
[11:02:51.374]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:51.374]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:51.374]         }
[11:02:51.374]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:51.374]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:51.374]             base::sink(type = "output", split = FALSE)
[11:02:51.374]             base::close(...future.stdout)
[11:02:51.374]         }, add = TRUE)
[11:02:51.374]     }
[11:02:51.374]     ...future.frame <- base::sys.nframe()
[11:02:51.374]     ...future.conditions <- base::list()
[11:02:51.374]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:51.374]     if (FALSE) {
[11:02:51.374]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:51.374]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:51.374]     }
[11:02:51.374]     ...future.result <- base::tryCatch({
[11:02:51.374]         base::withCallingHandlers({
[11:02:51.374]             ...future.value <- base::withVisible(base::local({
[11:02:51.374]                 ...future.makeSendCondition <- base::local({
[11:02:51.374]                   sendCondition <- NULL
[11:02:51.374]                   function(frame = 1L) {
[11:02:51.374]                     if (is.function(sendCondition)) 
[11:02:51.374]                       return(sendCondition)
[11:02:51.374]                     ns <- getNamespace("parallel")
[11:02:51.374]                     if (exists("sendData", mode = "function", 
[11:02:51.374]                       envir = ns)) {
[11:02:51.374]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:51.374]                         envir = ns)
[11:02:51.374]                       envir <- sys.frame(frame)
[11:02:51.374]                       master <- NULL
[11:02:51.374]                       while (!identical(envir, .GlobalEnv) && 
[11:02:51.374]                         !identical(envir, emptyenv())) {
[11:02:51.374]                         if (exists("master", mode = "list", envir = envir, 
[11:02:51.374]                           inherits = FALSE)) {
[11:02:51.374]                           master <- get("master", mode = "list", 
[11:02:51.374]                             envir = envir, inherits = FALSE)
[11:02:51.374]                           if (inherits(master, c("SOCKnode", 
[11:02:51.374]                             "SOCK0node"))) {
[11:02:51.374]                             sendCondition <<- function(cond) {
[11:02:51.374]                               data <- list(type = "VALUE", value = cond, 
[11:02:51.374]                                 success = TRUE)
[11:02:51.374]                               parallel_sendData(master, data)
[11:02:51.374]                             }
[11:02:51.374]                             return(sendCondition)
[11:02:51.374]                           }
[11:02:51.374]                         }
[11:02:51.374]                         frame <- frame + 1L
[11:02:51.374]                         envir <- sys.frame(frame)
[11:02:51.374]                       }
[11:02:51.374]                     }
[11:02:51.374]                     sendCondition <<- function(cond) NULL
[11:02:51.374]                   }
[11:02:51.374]                 })
[11:02:51.374]                 withCallingHandlers({
[11:02:51.374]                   list(a = 1, b = 42L, c = stop("Nah!"))
[11:02:51.374]                 }, immediateCondition = function(cond) {
[11:02:51.374]                   sendCondition <- ...future.makeSendCondition()
[11:02:51.374]                   sendCondition(cond)
[11:02:51.374]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:51.374]                   {
[11:02:51.374]                     inherits <- base::inherits
[11:02:51.374]                     invokeRestart <- base::invokeRestart
[11:02:51.374]                     is.null <- base::is.null
[11:02:51.374]                     muffled <- FALSE
[11:02:51.374]                     if (inherits(cond, "message")) {
[11:02:51.374]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:51.374]                       if (muffled) 
[11:02:51.374]                         invokeRestart("muffleMessage")
[11:02:51.374]                     }
[11:02:51.374]                     else if (inherits(cond, "warning")) {
[11:02:51.374]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:51.374]                       if (muffled) 
[11:02:51.374]                         invokeRestart("muffleWarning")
[11:02:51.374]                     }
[11:02:51.374]                     else if (inherits(cond, "condition")) {
[11:02:51.374]                       if (!is.null(pattern)) {
[11:02:51.374]                         computeRestarts <- base::computeRestarts
[11:02:51.374]                         grepl <- base::grepl
[11:02:51.374]                         restarts <- computeRestarts(cond)
[11:02:51.374]                         for (restart in restarts) {
[11:02:51.374]                           name <- restart$name
[11:02:51.374]                           if (is.null(name)) 
[11:02:51.374]                             next
[11:02:51.374]                           if (!grepl(pattern, name)) 
[11:02:51.374]                             next
[11:02:51.374]                           invokeRestart(restart)
[11:02:51.374]                           muffled <- TRUE
[11:02:51.374]                           break
[11:02:51.374]                         }
[11:02:51.374]                       }
[11:02:51.374]                     }
[11:02:51.374]                     invisible(muffled)
[11:02:51.374]                   }
[11:02:51.374]                   muffleCondition(cond)
[11:02:51.374]                 })
[11:02:51.374]             }))
[11:02:51.374]             future::FutureResult(value = ...future.value$value, 
[11:02:51.374]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:51.374]                   ...future.rng), globalenv = if (FALSE) 
[11:02:51.374]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:51.374]                     ...future.globalenv.names))
[11:02:51.374]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:51.374]         }, condition = base::local({
[11:02:51.374]             c <- base::c
[11:02:51.374]             inherits <- base::inherits
[11:02:51.374]             invokeRestart <- base::invokeRestart
[11:02:51.374]             length <- base::length
[11:02:51.374]             list <- base::list
[11:02:51.374]             seq.int <- base::seq.int
[11:02:51.374]             signalCondition <- base::signalCondition
[11:02:51.374]             sys.calls <- base::sys.calls
[11:02:51.374]             `[[` <- base::`[[`
[11:02:51.374]             `+` <- base::`+`
[11:02:51.374]             `<<-` <- base::`<<-`
[11:02:51.374]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:51.374]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:51.374]                   3L)]
[11:02:51.374]             }
[11:02:51.374]             function(cond) {
[11:02:51.374]                 is_error <- inherits(cond, "error")
[11:02:51.374]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:51.374]                   NULL)
[11:02:51.374]                 if (is_error) {
[11:02:51.374]                   sessionInformation <- function() {
[11:02:51.374]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:51.374]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:51.374]                       search = base::search(), system = base::Sys.info())
[11:02:51.374]                   }
[11:02:51.374]                   ...future.conditions[[length(...future.conditions) + 
[11:02:51.374]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:51.374]                     cond$call), session = sessionInformation(), 
[11:02:51.374]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:51.374]                   signalCondition(cond)
[11:02:51.374]                 }
[11:02:51.374]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:51.374]                 "immediateCondition"))) {
[11:02:51.374]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:51.374]                   ...future.conditions[[length(...future.conditions) + 
[11:02:51.374]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:51.374]                   if (TRUE && !signal) {
[11:02:51.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:51.374]                     {
[11:02:51.374]                       inherits <- base::inherits
[11:02:51.374]                       invokeRestart <- base::invokeRestart
[11:02:51.374]                       is.null <- base::is.null
[11:02:51.374]                       muffled <- FALSE
[11:02:51.374]                       if (inherits(cond, "message")) {
[11:02:51.374]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:51.374]                         if (muffled) 
[11:02:51.374]                           invokeRestart("muffleMessage")
[11:02:51.374]                       }
[11:02:51.374]                       else if (inherits(cond, "warning")) {
[11:02:51.374]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:51.374]                         if (muffled) 
[11:02:51.374]                           invokeRestart("muffleWarning")
[11:02:51.374]                       }
[11:02:51.374]                       else if (inherits(cond, "condition")) {
[11:02:51.374]                         if (!is.null(pattern)) {
[11:02:51.374]                           computeRestarts <- base::computeRestarts
[11:02:51.374]                           grepl <- base::grepl
[11:02:51.374]                           restarts <- computeRestarts(cond)
[11:02:51.374]                           for (restart in restarts) {
[11:02:51.374]                             name <- restart$name
[11:02:51.374]                             if (is.null(name)) 
[11:02:51.374]                               next
[11:02:51.374]                             if (!grepl(pattern, name)) 
[11:02:51.374]                               next
[11:02:51.374]                             invokeRestart(restart)
[11:02:51.374]                             muffled <- TRUE
[11:02:51.374]                             break
[11:02:51.374]                           }
[11:02:51.374]                         }
[11:02:51.374]                       }
[11:02:51.374]                       invisible(muffled)
[11:02:51.374]                     }
[11:02:51.374]                     muffleCondition(cond, pattern = "^muffle")
[11:02:51.374]                   }
[11:02:51.374]                 }
[11:02:51.374]                 else {
[11:02:51.374]                   if (TRUE) {
[11:02:51.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:51.374]                     {
[11:02:51.374]                       inherits <- base::inherits
[11:02:51.374]                       invokeRestart <- base::invokeRestart
[11:02:51.374]                       is.null <- base::is.null
[11:02:51.374]                       muffled <- FALSE
[11:02:51.374]                       if (inherits(cond, "message")) {
[11:02:51.374]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:51.374]                         if (muffled) 
[11:02:51.374]                           invokeRestart("muffleMessage")
[11:02:51.374]                       }
[11:02:51.374]                       else if (inherits(cond, "warning")) {
[11:02:51.374]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:51.374]                         if (muffled) 
[11:02:51.374]                           invokeRestart("muffleWarning")
[11:02:51.374]                       }
[11:02:51.374]                       else if (inherits(cond, "condition")) {
[11:02:51.374]                         if (!is.null(pattern)) {
[11:02:51.374]                           computeRestarts <- base::computeRestarts
[11:02:51.374]                           grepl <- base::grepl
[11:02:51.374]                           restarts <- computeRestarts(cond)
[11:02:51.374]                           for (restart in restarts) {
[11:02:51.374]                             name <- restart$name
[11:02:51.374]                             if (is.null(name)) 
[11:02:51.374]                               next
[11:02:51.374]                             if (!grepl(pattern, name)) 
[11:02:51.374]                               next
[11:02:51.374]                             invokeRestart(restart)
[11:02:51.374]                             muffled <- TRUE
[11:02:51.374]                             break
[11:02:51.374]                           }
[11:02:51.374]                         }
[11:02:51.374]                       }
[11:02:51.374]                       invisible(muffled)
[11:02:51.374]                     }
[11:02:51.374]                     muffleCondition(cond, pattern = "^muffle")
[11:02:51.374]                   }
[11:02:51.374]                 }
[11:02:51.374]             }
[11:02:51.374]         }))
[11:02:51.374]     }, error = function(ex) {
[11:02:51.374]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:51.374]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:51.374]                 ...future.rng), started = ...future.startTime, 
[11:02:51.374]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:51.374]             version = "1.8"), class = "FutureResult")
[11:02:51.374]     }, finally = {
[11:02:51.374]         if (!identical(...future.workdir, getwd())) 
[11:02:51.374]             setwd(...future.workdir)
[11:02:51.374]         {
[11:02:51.374]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:51.374]                 ...future.oldOptions$nwarnings <- NULL
[11:02:51.374]             }
[11:02:51.374]             base::options(...future.oldOptions)
[11:02:51.374]             if (.Platform$OS.type == "windows") {
[11:02:51.374]                 old_names <- names(...future.oldEnvVars)
[11:02:51.374]                 envs <- base::Sys.getenv()
[11:02:51.374]                 names <- names(envs)
[11:02:51.374]                 common <- intersect(names, old_names)
[11:02:51.374]                 added <- setdiff(names, old_names)
[11:02:51.374]                 removed <- setdiff(old_names, names)
[11:02:51.374]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:51.374]                   envs[common]]
[11:02:51.374]                 NAMES <- toupper(changed)
[11:02:51.374]                 args <- list()
[11:02:51.374]                 for (kk in seq_along(NAMES)) {
[11:02:51.374]                   name <- changed[[kk]]
[11:02:51.374]                   NAME <- NAMES[[kk]]
[11:02:51.374]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:51.374]                     next
[11:02:51.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:51.374]                 }
[11:02:51.374]                 NAMES <- toupper(added)
[11:02:51.374]                 for (kk in seq_along(NAMES)) {
[11:02:51.374]                   name <- added[[kk]]
[11:02:51.374]                   NAME <- NAMES[[kk]]
[11:02:51.374]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:51.374]                     next
[11:02:51.374]                   args[[name]] <- ""
[11:02:51.374]                 }
[11:02:51.374]                 NAMES <- toupper(removed)
[11:02:51.374]                 for (kk in seq_along(NAMES)) {
[11:02:51.374]                   name <- removed[[kk]]
[11:02:51.374]                   NAME <- NAMES[[kk]]
[11:02:51.374]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:51.374]                     next
[11:02:51.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:51.374]                 }
[11:02:51.374]                 if (length(args) > 0) 
[11:02:51.374]                   base::do.call(base::Sys.setenv, args = args)
[11:02:51.374]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:51.374]             }
[11:02:51.374]             else {
[11:02:51.374]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:51.374]             }
[11:02:51.374]             {
[11:02:51.374]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:51.374]                   0L) {
[11:02:51.374]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:51.374]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:51.374]                   base::options(opts)
[11:02:51.374]                 }
[11:02:51.374]                 {
[11:02:51.374]                   {
[11:02:51.374]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:51.374]                     NULL
[11:02:51.374]                   }
[11:02:51.374]                   options(future.plan = NULL)
[11:02:51.374]                   if (is.na(NA_character_)) 
[11:02:51.374]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:51.374]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:51.374]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:51.374]                     .init = FALSE)
[11:02:51.374]                 }
[11:02:51.374]             }
[11:02:51.374]         }
[11:02:51.374]     })
[11:02:51.374]     if (TRUE) {
[11:02:51.374]         base::sink(type = "output", split = FALSE)
[11:02:51.374]         if (TRUE) {
[11:02:51.374]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:51.374]         }
[11:02:51.374]         else {
[11:02:51.374]             ...future.result["stdout"] <- base::list(NULL)
[11:02:51.374]         }
[11:02:51.374]         base::close(...future.stdout)
[11:02:51.374]         ...future.stdout <- NULL
[11:02:51.374]     }
[11:02:51.374]     ...future.result$conditions <- ...future.conditions
[11:02:51.374]     ...future.result$finished <- base::Sys.time()
[11:02:51.374]     ...future.result
[11:02:51.374] }
[11:02:51.376] Poll #1 (0): usedNodes() = 2, workers = 2
[11:02:51.387] receiveMessageFromWorker() for ClusterFuture ...
[11:02:51.387] - Validating connection of MultisessionFuture
[11:02:51.387] - received message: FutureResult
[11:02:51.387] - Received FutureResult
[11:02:51.387] - Erased future from FutureRegistry
[11:02:51.388] result() for ClusterFuture ...
[11:02:51.388] - result already collected: FutureResult
[11:02:51.388] result() for ClusterFuture ... done
[11:02:51.388] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:51.388] result() for ClusterFuture ...
[11:02:51.388] - result already collected: FutureResult
[11:02:51.388] result() for ClusterFuture ... done
[11:02:51.388] result() for ClusterFuture ...
[11:02:51.388] - result already collected: FutureResult
[11:02:51.388] result() for ClusterFuture ... done
[11:02:51.389] MultisessionFuture started
[11:02:51.389] - Launch lazy future ... done
[11:02:51.390] run() for ‘MultisessionFuture’ ... done
[11:02:51.390] getGlobalsAndPackages() ...
[11:02:51.390] Searching for globals...
[11:02:51.391] - globals found: [2] ‘list’, ‘stop’
[11:02:51.391] Searching for globals ... DONE
[11:02:51.391] Resolving globals: FALSE
[11:02:51.391] 
[11:02:51.391] 
[11:02:51.391] getGlobalsAndPackages() ... DONE
- result = TRUE, recursive = -1 ... DONE
- result = TRUE, recursive = 0 ...
[11:02:51.392] getGlobalsAndPackages() ...
[11:02:51.392] Searching for globals...
[11:02:51.393] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[11:02:51.393] Searching for globals ... DONE
[11:02:51.393] Resolving globals: FALSE
[11:02:51.393] 
[11:02:51.393] 
[11:02:51.394] getGlobalsAndPackages() ... DONE
[11:02:51.394] run() for ‘Future’ ...
[11:02:51.394] - state: ‘created’
[11:02:51.394] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:51.407] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:51.407] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:51.408]   - Field: ‘node’
[11:02:51.408]   - Field: ‘label’
[11:02:51.408]   - Field: ‘local’
[11:02:51.408]   - Field: ‘owner’
[11:02:51.408]   - Field: ‘envir’
[11:02:51.408]   - Field: ‘workers’
[11:02:51.408]   - Field: ‘packages’
[11:02:51.408]   - Field: ‘gc’
[11:02:51.408]   - Field: ‘conditions’
[11:02:51.408]   - Field: ‘persistent’
[11:02:51.408]   - Field: ‘expr’
[11:02:51.408]   - Field: ‘uuid’
[11:02:51.409]   - Field: ‘seed’
[11:02:51.409]   - Field: ‘version’
[11:02:51.409]   - Field: ‘result’
[11:02:51.409]   - Field: ‘asynchronous’
[11:02:51.409]   - Field: ‘calls’
[11:02:51.409]   - Field: ‘globals’
[11:02:51.409]   - Field: ‘stdout’
[11:02:51.409]   - Field: ‘earlySignal’
[11:02:51.409]   - Field: ‘lazy’
[11:02:51.409]   - Field: ‘state’
[11:02:51.409] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:51.409] - Launch lazy future ...
[11:02:51.410] Packages needed by the future expression (n = 0): <none>
[11:02:51.410] Packages needed by future strategies (n = 0): <none>
[11:02:51.410] {
[11:02:51.410]     {
[11:02:51.410]         {
[11:02:51.410]             ...future.startTime <- base::Sys.time()
[11:02:51.410]             {
[11:02:51.410]                 {
[11:02:51.410]                   {
[11:02:51.410]                     {
[11:02:51.410]                       base::local({
[11:02:51.410]                         has_future <- base::requireNamespace("future", 
[11:02:51.410]                           quietly = TRUE)
[11:02:51.410]                         if (has_future) {
[11:02:51.410]                           ns <- base::getNamespace("future")
[11:02:51.410]                           version <- ns[[".package"]][["version"]]
[11:02:51.410]                           if (is.null(version)) 
[11:02:51.410]                             version <- utils::packageVersion("future")
[11:02:51.410]                         }
[11:02:51.410]                         else {
[11:02:51.410]                           version <- NULL
[11:02:51.410]                         }
[11:02:51.410]                         if (!has_future || version < "1.8.0") {
[11:02:51.410]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:51.410]                             "", base::R.version$version.string), 
[11:02:51.410]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:51.410]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:51.410]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:51.410]                               "release", "version")], collapse = " "), 
[11:02:51.410]                             hostname = base::Sys.info()[["nodename"]])
[11:02:51.410]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:51.410]                             info)
[11:02:51.410]                           info <- base::paste(info, collapse = "; ")
[11:02:51.410]                           if (!has_future) {
[11:02:51.410]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:51.410]                               info)
[11:02:51.410]                           }
[11:02:51.410]                           else {
[11:02:51.410]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:51.410]                               info, version)
[11:02:51.410]                           }
[11:02:51.410]                           base::stop(msg)
[11:02:51.410]                         }
[11:02:51.410]                       })
[11:02:51.410]                     }
[11:02:51.410]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:51.410]                     base::options(mc.cores = 1L)
[11:02:51.410]                   }
[11:02:51.410]                   ...future.strategy.old <- future::plan("list")
[11:02:51.410]                   options(future.plan = NULL)
[11:02:51.410]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:51.410]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:51.410]                 }
[11:02:51.410]                 ...future.workdir <- getwd()
[11:02:51.410]             }
[11:02:51.410]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:51.410]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:51.410]         }
[11:02:51.410]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:51.410]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:51.410]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:51.410]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:51.410]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:51.410]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:51.410]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:51.410]             base::names(...future.oldOptions))
[11:02:51.410]     }
[11:02:51.410]     if (FALSE) {
[11:02:51.410]     }
[11:02:51.410]     else {
[11:02:51.410]         if (TRUE) {
[11:02:51.410]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:51.410]                 open = "w")
[11:02:51.410]         }
[11:02:51.410]         else {
[11:02:51.410]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:51.410]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:51.410]         }
[11:02:51.410]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:51.410]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:51.410]             base::sink(type = "output", split = FALSE)
[11:02:51.410]             base::close(...future.stdout)
[11:02:51.410]         }, add = TRUE)
[11:02:51.410]     }
[11:02:51.410]     ...future.frame <- base::sys.nframe()
[11:02:51.410]     ...future.conditions <- base::list()
[11:02:51.410]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:51.410]     if (FALSE) {
[11:02:51.410]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:51.410]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:51.410]     }
[11:02:51.410]     ...future.result <- base::tryCatch({
[11:02:51.410]         base::withCallingHandlers({
[11:02:51.410]             ...future.value <- base::withVisible(base::local({
[11:02:51.410]                 ...future.makeSendCondition <- base::local({
[11:02:51.410]                   sendCondition <- NULL
[11:02:51.410]                   function(frame = 1L) {
[11:02:51.410]                     if (is.function(sendCondition)) 
[11:02:51.410]                       return(sendCondition)
[11:02:51.410]                     ns <- getNamespace("parallel")
[11:02:51.410]                     if (exists("sendData", mode = "function", 
[11:02:51.410]                       envir = ns)) {
[11:02:51.410]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:51.410]                         envir = ns)
[11:02:51.410]                       envir <- sys.frame(frame)
[11:02:51.410]                       master <- NULL
[11:02:51.410]                       while (!identical(envir, .GlobalEnv) && 
[11:02:51.410]                         !identical(envir, emptyenv())) {
[11:02:51.410]                         if (exists("master", mode = "list", envir = envir, 
[11:02:51.410]                           inherits = FALSE)) {
[11:02:51.410]                           master <- get("master", mode = "list", 
[11:02:51.410]                             envir = envir, inherits = FALSE)
[11:02:51.410]                           if (inherits(master, c("SOCKnode", 
[11:02:51.410]                             "SOCK0node"))) {
[11:02:51.410]                             sendCondition <<- function(cond) {
[11:02:51.410]                               data <- list(type = "VALUE", value = cond, 
[11:02:51.410]                                 success = TRUE)
[11:02:51.410]                               parallel_sendData(master, data)
[11:02:51.410]                             }
[11:02:51.410]                             return(sendCondition)
[11:02:51.410]                           }
[11:02:51.410]                         }
[11:02:51.410]                         frame <- frame + 1L
[11:02:51.410]                         envir <- sys.frame(frame)
[11:02:51.410]                       }
[11:02:51.410]                     }
[11:02:51.410]                     sendCondition <<- function(cond) NULL
[11:02:51.410]                   }
[11:02:51.410]                 })
[11:02:51.410]                 withCallingHandlers({
[11:02:51.410]                   {
[11:02:51.410]                     Sys.sleep(0.5)
[11:02:51.410]                     list(a = 1, b = 42L)
[11:02:51.410]                   }
[11:02:51.410]                 }, immediateCondition = function(cond) {
[11:02:51.410]                   sendCondition <- ...future.makeSendCondition()
[11:02:51.410]                   sendCondition(cond)
[11:02:51.410]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:51.410]                   {
[11:02:51.410]                     inherits <- base::inherits
[11:02:51.410]                     invokeRestart <- base::invokeRestart
[11:02:51.410]                     is.null <- base::is.null
[11:02:51.410]                     muffled <- FALSE
[11:02:51.410]                     if (inherits(cond, "message")) {
[11:02:51.410]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:51.410]                       if (muffled) 
[11:02:51.410]                         invokeRestart("muffleMessage")
[11:02:51.410]                     }
[11:02:51.410]                     else if (inherits(cond, "warning")) {
[11:02:51.410]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:51.410]                       if (muffled) 
[11:02:51.410]                         invokeRestart("muffleWarning")
[11:02:51.410]                     }
[11:02:51.410]                     else if (inherits(cond, "condition")) {
[11:02:51.410]                       if (!is.null(pattern)) {
[11:02:51.410]                         computeRestarts <- base::computeRestarts
[11:02:51.410]                         grepl <- base::grepl
[11:02:51.410]                         restarts <- computeRestarts(cond)
[11:02:51.410]                         for (restart in restarts) {
[11:02:51.410]                           name <- restart$name
[11:02:51.410]                           if (is.null(name)) 
[11:02:51.410]                             next
[11:02:51.410]                           if (!grepl(pattern, name)) 
[11:02:51.410]                             next
[11:02:51.410]                           invokeRestart(restart)
[11:02:51.410]                           muffled <- TRUE
[11:02:51.410]                           break
[11:02:51.410]                         }
[11:02:51.410]                       }
[11:02:51.410]                     }
[11:02:51.410]                     invisible(muffled)
[11:02:51.410]                   }
[11:02:51.410]                   muffleCondition(cond)
[11:02:51.410]                 })
[11:02:51.410]             }))
[11:02:51.410]             future::FutureResult(value = ...future.value$value, 
[11:02:51.410]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:51.410]                   ...future.rng), globalenv = if (FALSE) 
[11:02:51.410]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:51.410]                     ...future.globalenv.names))
[11:02:51.410]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:51.410]         }, condition = base::local({
[11:02:51.410]             c <- base::c
[11:02:51.410]             inherits <- base::inherits
[11:02:51.410]             invokeRestart <- base::invokeRestart
[11:02:51.410]             length <- base::length
[11:02:51.410]             list <- base::list
[11:02:51.410]             seq.int <- base::seq.int
[11:02:51.410]             signalCondition <- base::signalCondition
[11:02:51.410]             sys.calls <- base::sys.calls
[11:02:51.410]             `[[` <- base::`[[`
[11:02:51.410]             `+` <- base::`+`
[11:02:51.410]             `<<-` <- base::`<<-`
[11:02:51.410]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:51.410]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:51.410]                   3L)]
[11:02:51.410]             }
[11:02:51.410]             function(cond) {
[11:02:51.410]                 is_error <- inherits(cond, "error")
[11:02:51.410]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:51.410]                   NULL)
[11:02:51.410]                 if (is_error) {
[11:02:51.410]                   sessionInformation <- function() {
[11:02:51.410]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:51.410]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:51.410]                       search = base::search(), system = base::Sys.info())
[11:02:51.410]                   }
[11:02:51.410]                   ...future.conditions[[length(...future.conditions) + 
[11:02:51.410]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:51.410]                     cond$call), session = sessionInformation(), 
[11:02:51.410]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:51.410]                   signalCondition(cond)
[11:02:51.410]                 }
[11:02:51.410]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:51.410]                 "immediateCondition"))) {
[11:02:51.410]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:51.410]                   ...future.conditions[[length(...future.conditions) + 
[11:02:51.410]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:51.410]                   if (TRUE && !signal) {
[11:02:51.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:51.410]                     {
[11:02:51.410]                       inherits <- base::inherits
[11:02:51.410]                       invokeRestart <- base::invokeRestart
[11:02:51.410]                       is.null <- base::is.null
[11:02:51.410]                       muffled <- FALSE
[11:02:51.410]                       if (inherits(cond, "message")) {
[11:02:51.410]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:51.410]                         if (muffled) 
[11:02:51.410]                           invokeRestart("muffleMessage")
[11:02:51.410]                       }
[11:02:51.410]                       else if (inherits(cond, "warning")) {
[11:02:51.410]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:51.410]                         if (muffled) 
[11:02:51.410]                           invokeRestart("muffleWarning")
[11:02:51.410]                       }
[11:02:51.410]                       else if (inherits(cond, "condition")) {
[11:02:51.410]                         if (!is.null(pattern)) {
[11:02:51.410]                           computeRestarts <- base::computeRestarts
[11:02:51.410]                           grepl <- base::grepl
[11:02:51.410]                           restarts <- computeRestarts(cond)
[11:02:51.410]                           for (restart in restarts) {
[11:02:51.410]                             name <- restart$name
[11:02:51.410]                             if (is.null(name)) 
[11:02:51.410]                               next
[11:02:51.410]                             if (!grepl(pattern, name)) 
[11:02:51.410]                               next
[11:02:51.410]                             invokeRestart(restart)
[11:02:51.410]                             muffled <- TRUE
[11:02:51.410]                             break
[11:02:51.410]                           }
[11:02:51.410]                         }
[11:02:51.410]                       }
[11:02:51.410]                       invisible(muffled)
[11:02:51.410]                     }
[11:02:51.410]                     muffleCondition(cond, pattern = "^muffle")
[11:02:51.410]                   }
[11:02:51.410]                 }
[11:02:51.410]                 else {
[11:02:51.410]                   if (TRUE) {
[11:02:51.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:51.410]                     {
[11:02:51.410]                       inherits <- base::inherits
[11:02:51.410]                       invokeRestart <- base::invokeRestart
[11:02:51.410]                       is.null <- base::is.null
[11:02:51.410]                       muffled <- FALSE
[11:02:51.410]                       if (inherits(cond, "message")) {
[11:02:51.410]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:51.410]                         if (muffled) 
[11:02:51.410]                           invokeRestart("muffleMessage")
[11:02:51.410]                       }
[11:02:51.410]                       else if (inherits(cond, "warning")) {
[11:02:51.410]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:51.410]                         if (muffled) 
[11:02:51.410]                           invokeRestart("muffleWarning")
[11:02:51.410]                       }
[11:02:51.410]                       else if (inherits(cond, "condition")) {
[11:02:51.410]                         if (!is.null(pattern)) {
[11:02:51.410]                           computeRestarts <- base::computeRestarts
[11:02:51.410]                           grepl <- base::grepl
[11:02:51.410]                           restarts <- computeRestarts(cond)
[11:02:51.410]                           for (restart in restarts) {
[11:02:51.410]                             name <- restart$name
[11:02:51.410]                             if (is.null(name)) 
[11:02:51.410]                               next
[11:02:51.410]                             if (!grepl(pattern, name)) 
[11:02:51.410]                               next
[11:02:51.410]                             invokeRestart(restart)
[11:02:51.410]                             muffled <- TRUE
[11:02:51.410]                             break
[11:02:51.410]                           }
[11:02:51.410]                         }
[11:02:51.410]                       }
[11:02:51.410]                       invisible(muffled)
[11:02:51.410]                     }
[11:02:51.410]                     muffleCondition(cond, pattern = "^muffle")
[11:02:51.410]                   }
[11:02:51.410]                 }
[11:02:51.410]             }
[11:02:51.410]         }))
[11:02:51.410]     }, error = function(ex) {
[11:02:51.410]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:51.410]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:51.410]                 ...future.rng), started = ...future.startTime, 
[11:02:51.410]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:51.410]             version = "1.8"), class = "FutureResult")
[11:02:51.410]     }, finally = {
[11:02:51.410]         if (!identical(...future.workdir, getwd())) 
[11:02:51.410]             setwd(...future.workdir)
[11:02:51.410]         {
[11:02:51.410]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:51.410]                 ...future.oldOptions$nwarnings <- NULL
[11:02:51.410]             }
[11:02:51.410]             base::options(...future.oldOptions)
[11:02:51.410]             if (.Platform$OS.type == "windows") {
[11:02:51.410]                 old_names <- names(...future.oldEnvVars)
[11:02:51.410]                 envs <- base::Sys.getenv()
[11:02:51.410]                 names <- names(envs)
[11:02:51.410]                 common <- intersect(names, old_names)
[11:02:51.410]                 added <- setdiff(names, old_names)
[11:02:51.410]                 removed <- setdiff(old_names, names)
[11:02:51.410]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:51.410]                   envs[common]]
[11:02:51.410]                 NAMES <- toupper(changed)
[11:02:51.410]                 args <- list()
[11:02:51.410]                 for (kk in seq_along(NAMES)) {
[11:02:51.410]                   name <- changed[[kk]]
[11:02:51.410]                   NAME <- NAMES[[kk]]
[11:02:51.410]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:51.410]                     next
[11:02:51.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:51.410]                 }
[11:02:51.410]                 NAMES <- toupper(added)
[11:02:51.410]                 for (kk in seq_along(NAMES)) {
[11:02:51.410]                   name <- added[[kk]]
[11:02:51.410]                   NAME <- NAMES[[kk]]
[11:02:51.410]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:51.410]                     next
[11:02:51.410]                   args[[name]] <- ""
[11:02:51.410]                 }
[11:02:51.410]                 NAMES <- toupper(removed)
[11:02:51.410]                 for (kk in seq_along(NAMES)) {
[11:02:51.410]                   name <- removed[[kk]]
[11:02:51.410]                   NAME <- NAMES[[kk]]
[11:02:51.410]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:51.410]                     next
[11:02:51.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:51.410]                 }
[11:02:51.410]                 if (length(args) > 0) 
[11:02:51.410]                   base::do.call(base::Sys.setenv, args = args)
[11:02:51.410]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:51.410]             }
[11:02:51.410]             else {
[11:02:51.410]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:51.410]             }
[11:02:51.410]             {
[11:02:51.410]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:51.410]                   0L) {
[11:02:51.410]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:51.410]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:51.410]                   base::options(opts)
[11:02:51.410]                 }
[11:02:51.410]                 {
[11:02:51.410]                   {
[11:02:51.410]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:51.410]                     NULL
[11:02:51.410]                   }
[11:02:51.410]                   options(future.plan = NULL)
[11:02:51.410]                   if (is.na(NA_character_)) 
[11:02:51.410]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:51.410]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:51.410]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:51.410]                     .init = FALSE)
[11:02:51.410]                 }
[11:02:51.410]             }
[11:02:51.410]         }
[11:02:51.410]     })
[11:02:51.410]     if (TRUE) {
[11:02:51.410]         base::sink(type = "output", split = FALSE)
[11:02:51.410]         if (TRUE) {
[11:02:51.410]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:51.410]         }
[11:02:51.410]         else {
[11:02:51.410]             ...future.result["stdout"] <- base::list(NULL)
[11:02:51.410]         }
[11:02:51.410]         base::close(...future.stdout)
[11:02:51.410]         ...future.stdout <- NULL
[11:02:51.410]     }
[11:02:51.410]     ...future.result$conditions <- ...future.conditions
[11:02:51.410]     ...future.result$finished <- base::Sys.time()
[11:02:51.410]     ...future.result
[11:02:51.410] }
[11:02:51.412] Poll #1 (0): usedNodes() = 2, workers = 2
[11:02:51.434] receiveMessageFromWorker() for ClusterFuture ...
[11:02:51.434] - Validating connection of MultisessionFuture
[11:02:51.434] - received message: FutureResult
[11:02:51.434] - Received FutureResult
[11:02:51.434] - Erased future from FutureRegistry
[11:02:51.435] result() for ClusterFuture ...
[11:02:51.435] - result already collected: FutureResult
[11:02:51.435] result() for ClusterFuture ... done
[11:02:51.435] signalConditions() ...
[11:02:51.435]  - include = ‘immediateCondition’
[11:02:51.435]  - exclude = 
[11:02:51.435]  - resignal = FALSE
[11:02:51.435]  - Number of conditions: 1
[11:02:51.435] signalConditions() ... done
[11:02:51.435] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:51.435] result() for ClusterFuture ...
[11:02:51.435] - result already collected: FutureResult
[11:02:51.436] result() for ClusterFuture ... done
[11:02:51.436] result() for ClusterFuture ...
[11:02:51.436] - result already collected: FutureResult
[11:02:51.436] result() for ClusterFuture ... done
[11:02:51.436] signalConditions() ...
[11:02:51.436]  - include = ‘immediateCondition’
[11:02:51.436]  - exclude = 
[11:02:51.436]  - resignal = FALSE
[11:02:51.436]  - Number of conditions: 1
[11:02:51.436] signalConditions() ... done
[11:02:51.437] MultisessionFuture started
[11:02:51.437] - Launch lazy future ... done
[11:02:51.437] run() for ‘MultisessionFuture’ ... done
[11:02:51.980] receiveMessageFromWorker() for ClusterFuture ...
[11:02:51.980] - Validating connection of MultisessionFuture
[11:02:51.980] - received message: FutureResult
[11:02:51.980] - Received FutureResult
[11:02:51.981] - Erased future from FutureRegistry
[11:02:51.981] result() for ClusterFuture ...
[11:02:51.981] - result already collected: FutureResult
[11:02:51.981] result() for ClusterFuture ... done
[11:02:51.981] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:51.981] A MultisessionFuture was resolved
[11:02:51.981] getGlobalsAndPackages() ...
[11:02:51.981] Searching for globals...
[11:02:51.982] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[11:02:51.982] Searching for globals ... DONE
[11:02:51.983] Resolving globals: FALSE
[11:02:51.983] 
[11:02:51.983] 
[11:02:51.983] getGlobalsAndPackages() ... DONE
[11:02:51.983] run() for ‘Future’ ...
[11:02:51.983] - state: ‘created’
[11:02:51.984] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:51.997] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:51.997] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:51.997]   - Field: ‘node’
[11:02:51.998]   - Field: ‘label’
[11:02:51.998]   - Field: ‘local’
[11:02:51.998]   - Field: ‘owner’
[11:02:51.998]   - Field: ‘envir’
[11:02:51.998]   - Field: ‘workers’
[11:02:51.998]   - Field: ‘packages’
[11:02:51.998]   - Field: ‘gc’
[11:02:51.998]   - Field: ‘conditions’
[11:02:51.998]   - Field: ‘persistent’
[11:02:51.998]   - Field: ‘expr’
[11:02:51.998]   - Field: ‘uuid’
[11:02:51.998]   - Field: ‘seed’
[11:02:51.999]   - Field: ‘version’
[11:02:51.999]   - Field: ‘result’
[11:02:51.999]   - Field: ‘asynchronous’
[11:02:51.999]   - Field: ‘calls’
[11:02:51.999]   - Field: ‘globals’
[11:02:51.999]   - Field: ‘stdout’
[11:02:51.999]   - Field: ‘earlySignal’
[11:02:51.999]   - Field: ‘lazy’
[11:02:51.999]   - Field: ‘state’
[11:02:51.999] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:51.999] - Launch lazy future ...
[11:02:52.000] Packages needed by the future expression (n = 0): <none>
[11:02:52.000] Packages needed by future strategies (n = 0): <none>
[11:02:52.000] {
[11:02:52.000]     {
[11:02:52.000]         {
[11:02:52.000]             ...future.startTime <- base::Sys.time()
[11:02:52.000]             {
[11:02:52.000]                 {
[11:02:52.000]                   {
[11:02:52.000]                     {
[11:02:52.000]                       base::local({
[11:02:52.000]                         has_future <- base::requireNamespace("future", 
[11:02:52.000]                           quietly = TRUE)
[11:02:52.000]                         if (has_future) {
[11:02:52.000]                           ns <- base::getNamespace("future")
[11:02:52.000]                           version <- ns[[".package"]][["version"]]
[11:02:52.000]                           if (is.null(version)) 
[11:02:52.000]                             version <- utils::packageVersion("future")
[11:02:52.000]                         }
[11:02:52.000]                         else {
[11:02:52.000]                           version <- NULL
[11:02:52.000]                         }
[11:02:52.000]                         if (!has_future || version < "1.8.0") {
[11:02:52.000]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:52.000]                             "", base::R.version$version.string), 
[11:02:52.000]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:52.000]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:52.000]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:52.000]                               "release", "version")], collapse = " "), 
[11:02:52.000]                             hostname = base::Sys.info()[["nodename"]])
[11:02:52.000]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:52.000]                             info)
[11:02:52.000]                           info <- base::paste(info, collapse = "; ")
[11:02:52.000]                           if (!has_future) {
[11:02:52.000]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:52.000]                               info)
[11:02:52.000]                           }
[11:02:52.000]                           else {
[11:02:52.000]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:52.000]                               info, version)
[11:02:52.000]                           }
[11:02:52.000]                           base::stop(msg)
[11:02:52.000]                         }
[11:02:52.000]                       })
[11:02:52.000]                     }
[11:02:52.000]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:52.000]                     base::options(mc.cores = 1L)
[11:02:52.000]                   }
[11:02:52.000]                   ...future.strategy.old <- future::plan("list")
[11:02:52.000]                   options(future.plan = NULL)
[11:02:52.000]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:52.000]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:52.000]                 }
[11:02:52.000]                 ...future.workdir <- getwd()
[11:02:52.000]             }
[11:02:52.000]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:52.000]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:52.000]         }
[11:02:52.000]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:52.000]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:52.000]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:52.000]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:52.000]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:52.000]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:52.000]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:52.000]             base::names(...future.oldOptions))
[11:02:52.000]     }
[11:02:52.000]     if (FALSE) {
[11:02:52.000]     }
[11:02:52.000]     else {
[11:02:52.000]         if (TRUE) {
[11:02:52.000]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:52.000]                 open = "w")
[11:02:52.000]         }
[11:02:52.000]         else {
[11:02:52.000]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:52.000]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:52.000]         }
[11:02:52.000]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:52.000]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:52.000]             base::sink(type = "output", split = FALSE)
[11:02:52.000]             base::close(...future.stdout)
[11:02:52.000]         }, add = TRUE)
[11:02:52.000]     }
[11:02:52.000]     ...future.frame <- base::sys.nframe()
[11:02:52.000]     ...future.conditions <- base::list()
[11:02:52.000]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:52.000]     if (FALSE) {
[11:02:52.000]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:52.000]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:52.000]     }
[11:02:52.000]     ...future.result <- base::tryCatch({
[11:02:52.000]         base::withCallingHandlers({
[11:02:52.000]             ...future.value <- base::withVisible(base::local({
[11:02:52.000]                 ...future.makeSendCondition <- base::local({
[11:02:52.000]                   sendCondition <- NULL
[11:02:52.000]                   function(frame = 1L) {
[11:02:52.000]                     if (is.function(sendCondition)) 
[11:02:52.000]                       return(sendCondition)
[11:02:52.000]                     ns <- getNamespace("parallel")
[11:02:52.000]                     if (exists("sendData", mode = "function", 
[11:02:52.000]                       envir = ns)) {
[11:02:52.000]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:52.000]                         envir = ns)
[11:02:52.000]                       envir <- sys.frame(frame)
[11:02:52.000]                       master <- NULL
[11:02:52.000]                       while (!identical(envir, .GlobalEnv) && 
[11:02:52.000]                         !identical(envir, emptyenv())) {
[11:02:52.000]                         if (exists("master", mode = "list", envir = envir, 
[11:02:52.000]                           inherits = FALSE)) {
[11:02:52.000]                           master <- get("master", mode = "list", 
[11:02:52.000]                             envir = envir, inherits = FALSE)
[11:02:52.000]                           if (inherits(master, c("SOCKnode", 
[11:02:52.000]                             "SOCK0node"))) {
[11:02:52.000]                             sendCondition <<- function(cond) {
[11:02:52.000]                               data <- list(type = "VALUE", value = cond, 
[11:02:52.000]                                 success = TRUE)
[11:02:52.000]                               parallel_sendData(master, data)
[11:02:52.000]                             }
[11:02:52.000]                             return(sendCondition)
[11:02:52.000]                           }
[11:02:52.000]                         }
[11:02:52.000]                         frame <- frame + 1L
[11:02:52.000]                         envir <- sys.frame(frame)
[11:02:52.000]                       }
[11:02:52.000]                     }
[11:02:52.000]                     sendCondition <<- function(cond) NULL
[11:02:52.000]                   }
[11:02:52.000]                 })
[11:02:52.000]                 withCallingHandlers({
[11:02:52.000]                   {
[11:02:52.000]                     Sys.sleep(0.5)
[11:02:52.000]                     list(a = 1, b = 42L)
[11:02:52.000]                   }
[11:02:52.000]                 }, immediateCondition = function(cond) {
[11:02:52.000]                   sendCondition <- ...future.makeSendCondition()
[11:02:52.000]                   sendCondition(cond)
[11:02:52.000]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:52.000]                   {
[11:02:52.000]                     inherits <- base::inherits
[11:02:52.000]                     invokeRestart <- base::invokeRestart
[11:02:52.000]                     is.null <- base::is.null
[11:02:52.000]                     muffled <- FALSE
[11:02:52.000]                     if (inherits(cond, "message")) {
[11:02:52.000]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:52.000]                       if (muffled) 
[11:02:52.000]                         invokeRestart("muffleMessage")
[11:02:52.000]                     }
[11:02:52.000]                     else if (inherits(cond, "warning")) {
[11:02:52.000]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:52.000]                       if (muffled) 
[11:02:52.000]                         invokeRestart("muffleWarning")
[11:02:52.000]                     }
[11:02:52.000]                     else if (inherits(cond, "condition")) {
[11:02:52.000]                       if (!is.null(pattern)) {
[11:02:52.000]                         computeRestarts <- base::computeRestarts
[11:02:52.000]                         grepl <- base::grepl
[11:02:52.000]                         restarts <- computeRestarts(cond)
[11:02:52.000]                         for (restart in restarts) {
[11:02:52.000]                           name <- restart$name
[11:02:52.000]                           if (is.null(name)) 
[11:02:52.000]                             next
[11:02:52.000]                           if (!grepl(pattern, name)) 
[11:02:52.000]                             next
[11:02:52.000]                           invokeRestart(restart)
[11:02:52.000]                           muffled <- TRUE
[11:02:52.000]                           break
[11:02:52.000]                         }
[11:02:52.000]                       }
[11:02:52.000]                     }
[11:02:52.000]                     invisible(muffled)
[11:02:52.000]                   }
[11:02:52.000]                   muffleCondition(cond)
[11:02:52.000]                 })
[11:02:52.000]             }))
[11:02:52.000]             future::FutureResult(value = ...future.value$value, 
[11:02:52.000]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:52.000]                   ...future.rng), globalenv = if (FALSE) 
[11:02:52.000]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:52.000]                     ...future.globalenv.names))
[11:02:52.000]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:52.000]         }, condition = base::local({
[11:02:52.000]             c <- base::c
[11:02:52.000]             inherits <- base::inherits
[11:02:52.000]             invokeRestart <- base::invokeRestart
[11:02:52.000]             length <- base::length
[11:02:52.000]             list <- base::list
[11:02:52.000]             seq.int <- base::seq.int
[11:02:52.000]             signalCondition <- base::signalCondition
[11:02:52.000]             sys.calls <- base::sys.calls
[11:02:52.000]             `[[` <- base::`[[`
[11:02:52.000]             `+` <- base::`+`
[11:02:52.000]             `<<-` <- base::`<<-`
[11:02:52.000]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:52.000]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:52.000]                   3L)]
[11:02:52.000]             }
[11:02:52.000]             function(cond) {
[11:02:52.000]                 is_error <- inherits(cond, "error")
[11:02:52.000]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:52.000]                   NULL)
[11:02:52.000]                 if (is_error) {
[11:02:52.000]                   sessionInformation <- function() {
[11:02:52.000]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:52.000]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:52.000]                       search = base::search(), system = base::Sys.info())
[11:02:52.000]                   }
[11:02:52.000]                   ...future.conditions[[length(...future.conditions) + 
[11:02:52.000]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:52.000]                     cond$call), session = sessionInformation(), 
[11:02:52.000]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:52.000]                   signalCondition(cond)
[11:02:52.000]                 }
[11:02:52.000]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:52.000]                 "immediateCondition"))) {
[11:02:52.000]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:52.000]                   ...future.conditions[[length(...future.conditions) + 
[11:02:52.000]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:52.000]                   if (TRUE && !signal) {
[11:02:52.000]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:52.000]                     {
[11:02:52.000]                       inherits <- base::inherits
[11:02:52.000]                       invokeRestart <- base::invokeRestart
[11:02:52.000]                       is.null <- base::is.null
[11:02:52.000]                       muffled <- FALSE
[11:02:52.000]                       if (inherits(cond, "message")) {
[11:02:52.000]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:52.000]                         if (muffled) 
[11:02:52.000]                           invokeRestart("muffleMessage")
[11:02:52.000]                       }
[11:02:52.000]                       else if (inherits(cond, "warning")) {
[11:02:52.000]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:52.000]                         if (muffled) 
[11:02:52.000]                           invokeRestart("muffleWarning")
[11:02:52.000]                       }
[11:02:52.000]                       else if (inherits(cond, "condition")) {
[11:02:52.000]                         if (!is.null(pattern)) {
[11:02:52.000]                           computeRestarts <- base::computeRestarts
[11:02:52.000]                           grepl <- base::grepl
[11:02:52.000]                           restarts <- computeRestarts(cond)
[11:02:52.000]                           for (restart in restarts) {
[11:02:52.000]                             name <- restart$name
[11:02:52.000]                             if (is.null(name)) 
[11:02:52.000]                               next
[11:02:52.000]                             if (!grepl(pattern, name)) 
[11:02:52.000]                               next
[11:02:52.000]                             invokeRestart(restart)
[11:02:52.000]                             muffled <- TRUE
[11:02:52.000]                             break
[11:02:52.000]                           }
[11:02:52.000]                         }
[11:02:52.000]                       }
[11:02:52.000]                       invisible(muffled)
[11:02:52.000]                     }
[11:02:52.000]                     muffleCondition(cond, pattern = "^muffle")
[11:02:52.000]                   }
[11:02:52.000]                 }
[11:02:52.000]                 else {
[11:02:52.000]                   if (TRUE) {
[11:02:52.000]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:52.000]                     {
[11:02:52.000]                       inherits <- base::inherits
[11:02:52.000]                       invokeRestart <- base::invokeRestart
[11:02:52.000]                       is.null <- base::is.null
[11:02:52.000]                       muffled <- FALSE
[11:02:52.000]                       if (inherits(cond, "message")) {
[11:02:52.000]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:52.000]                         if (muffled) 
[11:02:52.000]                           invokeRestart("muffleMessage")
[11:02:52.000]                       }
[11:02:52.000]                       else if (inherits(cond, "warning")) {
[11:02:52.000]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:52.000]                         if (muffled) 
[11:02:52.000]                           invokeRestart("muffleWarning")
[11:02:52.000]                       }
[11:02:52.000]                       else if (inherits(cond, "condition")) {
[11:02:52.000]                         if (!is.null(pattern)) {
[11:02:52.000]                           computeRestarts <- base::computeRestarts
[11:02:52.000]                           grepl <- base::grepl
[11:02:52.000]                           restarts <- computeRestarts(cond)
[11:02:52.000]                           for (restart in restarts) {
[11:02:52.000]                             name <- restart$name
[11:02:52.000]                             if (is.null(name)) 
[11:02:52.000]                               next
[11:02:52.000]                             if (!grepl(pattern, name)) 
[11:02:52.000]                               next
[11:02:52.000]                             invokeRestart(restart)
[11:02:52.000]                             muffled <- TRUE
[11:02:52.000]                             break
[11:02:52.000]                           }
[11:02:52.000]                         }
[11:02:52.000]                       }
[11:02:52.000]                       invisible(muffled)
[11:02:52.000]                     }
[11:02:52.000]                     muffleCondition(cond, pattern = "^muffle")
[11:02:52.000]                   }
[11:02:52.000]                 }
[11:02:52.000]             }
[11:02:52.000]         }))
[11:02:52.000]     }, error = function(ex) {
[11:02:52.000]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:52.000]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:52.000]                 ...future.rng), started = ...future.startTime, 
[11:02:52.000]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:52.000]             version = "1.8"), class = "FutureResult")
[11:02:52.000]     }, finally = {
[11:02:52.000]         if (!identical(...future.workdir, getwd())) 
[11:02:52.000]             setwd(...future.workdir)
[11:02:52.000]         {
[11:02:52.000]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:52.000]                 ...future.oldOptions$nwarnings <- NULL
[11:02:52.000]             }
[11:02:52.000]             base::options(...future.oldOptions)
[11:02:52.000]             if (.Platform$OS.type == "windows") {
[11:02:52.000]                 old_names <- names(...future.oldEnvVars)
[11:02:52.000]                 envs <- base::Sys.getenv()
[11:02:52.000]                 names <- names(envs)
[11:02:52.000]                 common <- intersect(names, old_names)
[11:02:52.000]                 added <- setdiff(names, old_names)
[11:02:52.000]                 removed <- setdiff(old_names, names)
[11:02:52.000]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:52.000]                   envs[common]]
[11:02:52.000]                 NAMES <- toupper(changed)
[11:02:52.000]                 args <- list()
[11:02:52.000]                 for (kk in seq_along(NAMES)) {
[11:02:52.000]                   name <- changed[[kk]]
[11:02:52.000]                   NAME <- NAMES[[kk]]
[11:02:52.000]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:52.000]                     next
[11:02:52.000]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:52.000]                 }
[11:02:52.000]                 NAMES <- toupper(added)
[11:02:52.000]                 for (kk in seq_along(NAMES)) {
[11:02:52.000]                   name <- added[[kk]]
[11:02:52.000]                   NAME <- NAMES[[kk]]
[11:02:52.000]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:52.000]                     next
[11:02:52.000]                   args[[name]] <- ""
[11:02:52.000]                 }
[11:02:52.000]                 NAMES <- toupper(removed)
[11:02:52.000]                 for (kk in seq_along(NAMES)) {
[11:02:52.000]                   name <- removed[[kk]]
[11:02:52.000]                   NAME <- NAMES[[kk]]
[11:02:52.000]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:52.000]                     next
[11:02:52.000]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:52.000]                 }
[11:02:52.000]                 if (length(args) > 0) 
[11:02:52.000]                   base::do.call(base::Sys.setenv, args = args)
[11:02:52.000]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:52.000]             }
[11:02:52.000]             else {
[11:02:52.000]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:52.000]             }
[11:02:52.000]             {
[11:02:52.000]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:52.000]                   0L) {
[11:02:52.000]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:52.000]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:52.000]                   base::options(opts)
[11:02:52.000]                 }
[11:02:52.000]                 {
[11:02:52.000]                   {
[11:02:52.000]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:52.000]                     NULL
[11:02:52.000]                   }
[11:02:52.000]                   options(future.plan = NULL)
[11:02:52.000]                   if (is.na(NA_character_)) 
[11:02:52.000]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:52.000]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:52.000]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:52.000]                     .init = FALSE)
[11:02:52.000]                 }
[11:02:52.000]             }
[11:02:52.000]         }
[11:02:52.000]     })
[11:02:52.000]     if (TRUE) {
[11:02:52.000]         base::sink(type = "output", split = FALSE)
[11:02:52.000]         if (TRUE) {
[11:02:52.000]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:52.000]         }
[11:02:52.000]         else {
[11:02:52.000]             ...future.result["stdout"] <- base::list(NULL)
[11:02:52.000]         }
[11:02:52.000]         base::close(...future.stdout)
[11:02:52.000]         ...future.stdout <- NULL
[11:02:52.000]     }
[11:02:52.000]     ...future.result$conditions <- ...future.conditions
[11:02:52.000]     ...future.result$finished <- base::Sys.time()
[11:02:52.000]     ...future.result
[11:02:52.000] }
[11:02:52.003] MultisessionFuture started
[11:02:52.003] - Launch lazy future ... done
[11:02:52.003] run() for ‘MultisessionFuture’ ... done
[11:02:52.546] receiveMessageFromWorker() for ClusterFuture ...
[11:02:52.546] - Validating connection of MultisessionFuture
[11:02:52.546] - received message: FutureResult
[11:02:52.546] - Received FutureResult
[11:02:52.547] - Erased future from FutureRegistry
[11:02:52.547] result() for ClusterFuture ...
[11:02:52.547] - result already collected: FutureResult
[11:02:52.547] result() for ClusterFuture ... done
[11:02:52.547] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:52.547] A MultisessionFuture was resolved
- w/ exception ...
[11:02:52.547] getGlobalsAndPackages() ...
[11:02:52.547] Searching for globals...
[11:02:52.548] - globals found: [2] ‘list’, ‘stop’
[11:02:52.548] Searching for globals ... DONE
[11:02:52.548] Resolving globals: FALSE
[11:02:52.548] 
[11:02:52.548] 
[11:02:52.549] getGlobalsAndPackages() ... DONE
[11:02:52.549] run() for ‘Future’ ...
[11:02:52.549] - state: ‘created’
[11:02:52.549] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:52.563] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:52.563] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:52.563]   - Field: ‘node’
[11:02:52.563]   - Field: ‘label’
[11:02:52.563]   - Field: ‘local’
[11:02:52.563]   - Field: ‘owner’
[11:02:52.563]   - Field: ‘envir’
[11:02:52.563]   - Field: ‘workers’
[11:02:52.563]   - Field: ‘packages’
[11:02:52.564]   - Field: ‘gc’
[11:02:52.564]   - Field: ‘conditions’
[11:02:52.564]   - Field: ‘persistent’
[11:02:52.564]   - Field: ‘expr’
[11:02:52.564]   - Field: ‘uuid’
[11:02:52.564]   - Field: ‘seed’
[11:02:52.564]   - Field: ‘version’
[11:02:52.564]   - Field: ‘result’
[11:02:52.564]   - Field: ‘asynchronous’
[11:02:52.564]   - Field: ‘calls’
[11:02:52.564]   - Field: ‘globals’
[11:02:52.564]   - Field: ‘stdout’
[11:02:52.565]   - Field: ‘earlySignal’
[11:02:52.565]   - Field: ‘lazy’
[11:02:52.565]   - Field: ‘state’
[11:02:52.565] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:52.565] - Launch lazy future ...
[11:02:52.565] Packages needed by the future expression (n = 0): <none>
[11:02:52.565] Packages needed by future strategies (n = 0): <none>
[11:02:52.566] {
[11:02:52.566]     {
[11:02:52.566]         {
[11:02:52.566]             ...future.startTime <- base::Sys.time()
[11:02:52.566]             {
[11:02:52.566]                 {
[11:02:52.566]                   {
[11:02:52.566]                     {
[11:02:52.566]                       base::local({
[11:02:52.566]                         has_future <- base::requireNamespace("future", 
[11:02:52.566]                           quietly = TRUE)
[11:02:52.566]                         if (has_future) {
[11:02:52.566]                           ns <- base::getNamespace("future")
[11:02:52.566]                           version <- ns[[".package"]][["version"]]
[11:02:52.566]                           if (is.null(version)) 
[11:02:52.566]                             version <- utils::packageVersion("future")
[11:02:52.566]                         }
[11:02:52.566]                         else {
[11:02:52.566]                           version <- NULL
[11:02:52.566]                         }
[11:02:52.566]                         if (!has_future || version < "1.8.0") {
[11:02:52.566]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:52.566]                             "", base::R.version$version.string), 
[11:02:52.566]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:52.566]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:52.566]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:52.566]                               "release", "version")], collapse = " "), 
[11:02:52.566]                             hostname = base::Sys.info()[["nodename"]])
[11:02:52.566]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:52.566]                             info)
[11:02:52.566]                           info <- base::paste(info, collapse = "; ")
[11:02:52.566]                           if (!has_future) {
[11:02:52.566]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:52.566]                               info)
[11:02:52.566]                           }
[11:02:52.566]                           else {
[11:02:52.566]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:52.566]                               info, version)
[11:02:52.566]                           }
[11:02:52.566]                           base::stop(msg)
[11:02:52.566]                         }
[11:02:52.566]                       })
[11:02:52.566]                     }
[11:02:52.566]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:52.566]                     base::options(mc.cores = 1L)
[11:02:52.566]                   }
[11:02:52.566]                   ...future.strategy.old <- future::plan("list")
[11:02:52.566]                   options(future.plan = NULL)
[11:02:52.566]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:52.566]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:52.566]                 }
[11:02:52.566]                 ...future.workdir <- getwd()
[11:02:52.566]             }
[11:02:52.566]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:52.566]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:52.566]         }
[11:02:52.566]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:52.566]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:52.566]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:52.566]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:52.566]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:52.566]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:52.566]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:52.566]             base::names(...future.oldOptions))
[11:02:52.566]     }
[11:02:52.566]     if (FALSE) {
[11:02:52.566]     }
[11:02:52.566]     else {
[11:02:52.566]         if (TRUE) {
[11:02:52.566]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:52.566]                 open = "w")
[11:02:52.566]         }
[11:02:52.566]         else {
[11:02:52.566]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:52.566]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:52.566]         }
[11:02:52.566]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:52.566]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:52.566]             base::sink(type = "output", split = FALSE)
[11:02:52.566]             base::close(...future.stdout)
[11:02:52.566]         }, add = TRUE)
[11:02:52.566]     }
[11:02:52.566]     ...future.frame <- base::sys.nframe()
[11:02:52.566]     ...future.conditions <- base::list()
[11:02:52.566]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:52.566]     if (FALSE) {
[11:02:52.566]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:52.566]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:52.566]     }
[11:02:52.566]     ...future.result <- base::tryCatch({
[11:02:52.566]         base::withCallingHandlers({
[11:02:52.566]             ...future.value <- base::withVisible(base::local({
[11:02:52.566]                 ...future.makeSendCondition <- base::local({
[11:02:52.566]                   sendCondition <- NULL
[11:02:52.566]                   function(frame = 1L) {
[11:02:52.566]                     if (is.function(sendCondition)) 
[11:02:52.566]                       return(sendCondition)
[11:02:52.566]                     ns <- getNamespace("parallel")
[11:02:52.566]                     if (exists("sendData", mode = "function", 
[11:02:52.566]                       envir = ns)) {
[11:02:52.566]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:52.566]                         envir = ns)
[11:02:52.566]                       envir <- sys.frame(frame)
[11:02:52.566]                       master <- NULL
[11:02:52.566]                       while (!identical(envir, .GlobalEnv) && 
[11:02:52.566]                         !identical(envir, emptyenv())) {
[11:02:52.566]                         if (exists("master", mode = "list", envir = envir, 
[11:02:52.566]                           inherits = FALSE)) {
[11:02:52.566]                           master <- get("master", mode = "list", 
[11:02:52.566]                             envir = envir, inherits = FALSE)
[11:02:52.566]                           if (inherits(master, c("SOCKnode", 
[11:02:52.566]                             "SOCK0node"))) {
[11:02:52.566]                             sendCondition <<- function(cond) {
[11:02:52.566]                               data <- list(type = "VALUE", value = cond, 
[11:02:52.566]                                 success = TRUE)
[11:02:52.566]                               parallel_sendData(master, data)
[11:02:52.566]                             }
[11:02:52.566]                             return(sendCondition)
[11:02:52.566]                           }
[11:02:52.566]                         }
[11:02:52.566]                         frame <- frame + 1L
[11:02:52.566]                         envir <- sys.frame(frame)
[11:02:52.566]                       }
[11:02:52.566]                     }
[11:02:52.566]                     sendCondition <<- function(cond) NULL
[11:02:52.566]                   }
[11:02:52.566]                 })
[11:02:52.566]                 withCallingHandlers({
[11:02:52.566]                   list(a = 1, b = 42L, c = stop("Nah!"))
[11:02:52.566]                 }, immediateCondition = function(cond) {
[11:02:52.566]                   sendCondition <- ...future.makeSendCondition()
[11:02:52.566]                   sendCondition(cond)
[11:02:52.566]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:52.566]                   {
[11:02:52.566]                     inherits <- base::inherits
[11:02:52.566]                     invokeRestart <- base::invokeRestart
[11:02:52.566]                     is.null <- base::is.null
[11:02:52.566]                     muffled <- FALSE
[11:02:52.566]                     if (inherits(cond, "message")) {
[11:02:52.566]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:52.566]                       if (muffled) 
[11:02:52.566]                         invokeRestart("muffleMessage")
[11:02:52.566]                     }
[11:02:52.566]                     else if (inherits(cond, "warning")) {
[11:02:52.566]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:52.566]                       if (muffled) 
[11:02:52.566]                         invokeRestart("muffleWarning")
[11:02:52.566]                     }
[11:02:52.566]                     else if (inherits(cond, "condition")) {
[11:02:52.566]                       if (!is.null(pattern)) {
[11:02:52.566]                         computeRestarts <- base::computeRestarts
[11:02:52.566]                         grepl <- base::grepl
[11:02:52.566]                         restarts <- computeRestarts(cond)
[11:02:52.566]                         for (restart in restarts) {
[11:02:52.566]                           name <- restart$name
[11:02:52.566]                           if (is.null(name)) 
[11:02:52.566]                             next
[11:02:52.566]                           if (!grepl(pattern, name)) 
[11:02:52.566]                             next
[11:02:52.566]                           invokeRestart(restart)
[11:02:52.566]                           muffled <- TRUE
[11:02:52.566]                           break
[11:02:52.566]                         }
[11:02:52.566]                       }
[11:02:52.566]                     }
[11:02:52.566]                     invisible(muffled)
[11:02:52.566]                   }
[11:02:52.566]                   muffleCondition(cond)
[11:02:52.566]                 })
[11:02:52.566]             }))
[11:02:52.566]             future::FutureResult(value = ...future.value$value, 
[11:02:52.566]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:52.566]                   ...future.rng), globalenv = if (FALSE) 
[11:02:52.566]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:52.566]                     ...future.globalenv.names))
[11:02:52.566]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:52.566]         }, condition = base::local({
[11:02:52.566]             c <- base::c
[11:02:52.566]             inherits <- base::inherits
[11:02:52.566]             invokeRestart <- base::invokeRestart
[11:02:52.566]             length <- base::length
[11:02:52.566]             list <- base::list
[11:02:52.566]             seq.int <- base::seq.int
[11:02:52.566]             signalCondition <- base::signalCondition
[11:02:52.566]             sys.calls <- base::sys.calls
[11:02:52.566]             `[[` <- base::`[[`
[11:02:52.566]             `+` <- base::`+`
[11:02:52.566]             `<<-` <- base::`<<-`
[11:02:52.566]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:52.566]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:52.566]                   3L)]
[11:02:52.566]             }
[11:02:52.566]             function(cond) {
[11:02:52.566]                 is_error <- inherits(cond, "error")
[11:02:52.566]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:52.566]                   NULL)
[11:02:52.566]                 if (is_error) {
[11:02:52.566]                   sessionInformation <- function() {
[11:02:52.566]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:52.566]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:52.566]                       search = base::search(), system = base::Sys.info())
[11:02:52.566]                   }
[11:02:52.566]                   ...future.conditions[[length(...future.conditions) + 
[11:02:52.566]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:52.566]                     cond$call), session = sessionInformation(), 
[11:02:52.566]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:52.566]                   signalCondition(cond)
[11:02:52.566]                 }
[11:02:52.566]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:52.566]                 "immediateCondition"))) {
[11:02:52.566]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:52.566]                   ...future.conditions[[length(...future.conditions) + 
[11:02:52.566]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:52.566]                   if (TRUE && !signal) {
[11:02:52.566]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:52.566]                     {
[11:02:52.566]                       inherits <- base::inherits
[11:02:52.566]                       invokeRestart <- base::invokeRestart
[11:02:52.566]                       is.null <- base::is.null
[11:02:52.566]                       muffled <- FALSE
[11:02:52.566]                       if (inherits(cond, "message")) {
[11:02:52.566]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:52.566]                         if (muffled) 
[11:02:52.566]                           invokeRestart("muffleMessage")
[11:02:52.566]                       }
[11:02:52.566]                       else if (inherits(cond, "warning")) {
[11:02:52.566]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:52.566]                         if (muffled) 
[11:02:52.566]                           invokeRestart("muffleWarning")
[11:02:52.566]                       }
[11:02:52.566]                       else if (inherits(cond, "condition")) {
[11:02:52.566]                         if (!is.null(pattern)) {
[11:02:52.566]                           computeRestarts <- base::computeRestarts
[11:02:52.566]                           grepl <- base::grepl
[11:02:52.566]                           restarts <- computeRestarts(cond)
[11:02:52.566]                           for (restart in restarts) {
[11:02:52.566]                             name <- restart$name
[11:02:52.566]                             if (is.null(name)) 
[11:02:52.566]                               next
[11:02:52.566]                             if (!grepl(pattern, name)) 
[11:02:52.566]                               next
[11:02:52.566]                             invokeRestart(restart)
[11:02:52.566]                             muffled <- TRUE
[11:02:52.566]                             break
[11:02:52.566]                           }
[11:02:52.566]                         }
[11:02:52.566]                       }
[11:02:52.566]                       invisible(muffled)
[11:02:52.566]                     }
[11:02:52.566]                     muffleCondition(cond, pattern = "^muffle")
[11:02:52.566]                   }
[11:02:52.566]                 }
[11:02:52.566]                 else {
[11:02:52.566]                   if (TRUE) {
[11:02:52.566]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:52.566]                     {
[11:02:52.566]                       inherits <- base::inherits
[11:02:52.566]                       invokeRestart <- base::invokeRestart
[11:02:52.566]                       is.null <- base::is.null
[11:02:52.566]                       muffled <- FALSE
[11:02:52.566]                       if (inherits(cond, "message")) {
[11:02:52.566]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:52.566]                         if (muffled) 
[11:02:52.566]                           invokeRestart("muffleMessage")
[11:02:52.566]                       }
[11:02:52.566]                       else if (inherits(cond, "warning")) {
[11:02:52.566]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:52.566]                         if (muffled) 
[11:02:52.566]                           invokeRestart("muffleWarning")
[11:02:52.566]                       }
[11:02:52.566]                       else if (inherits(cond, "condition")) {
[11:02:52.566]                         if (!is.null(pattern)) {
[11:02:52.566]                           computeRestarts <- base::computeRestarts
[11:02:52.566]                           grepl <- base::grepl
[11:02:52.566]                           restarts <- computeRestarts(cond)
[11:02:52.566]                           for (restart in restarts) {
[11:02:52.566]                             name <- restart$name
[11:02:52.566]                             if (is.null(name)) 
[11:02:52.566]                               next
[11:02:52.566]                             if (!grepl(pattern, name)) 
[11:02:52.566]                               next
[11:02:52.566]                             invokeRestart(restart)
[11:02:52.566]                             muffled <- TRUE
[11:02:52.566]                             break
[11:02:52.566]                           }
[11:02:52.566]                         }
[11:02:52.566]                       }
[11:02:52.566]                       invisible(muffled)
[11:02:52.566]                     }
[11:02:52.566]                     muffleCondition(cond, pattern = "^muffle")
[11:02:52.566]                   }
[11:02:52.566]                 }
[11:02:52.566]             }
[11:02:52.566]         }))
[11:02:52.566]     }, error = function(ex) {
[11:02:52.566]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:52.566]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:52.566]                 ...future.rng), started = ...future.startTime, 
[11:02:52.566]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:52.566]             version = "1.8"), class = "FutureResult")
[11:02:52.566]     }, finally = {
[11:02:52.566]         if (!identical(...future.workdir, getwd())) 
[11:02:52.566]             setwd(...future.workdir)
[11:02:52.566]         {
[11:02:52.566]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:52.566]                 ...future.oldOptions$nwarnings <- NULL
[11:02:52.566]             }
[11:02:52.566]             base::options(...future.oldOptions)
[11:02:52.566]             if (.Platform$OS.type == "windows") {
[11:02:52.566]                 old_names <- names(...future.oldEnvVars)
[11:02:52.566]                 envs <- base::Sys.getenv()
[11:02:52.566]                 names <- names(envs)
[11:02:52.566]                 common <- intersect(names, old_names)
[11:02:52.566]                 added <- setdiff(names, old_names)
[11:02:52.566]                 removed <- setdiff(old_names, names)
[11:02:52.566]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:52.566]                   envs[common]]
[11:02:52.566]                 NAMES <- toupper(changed)
[11:02:52.566]                 args <- list()
[11:02:52.566]                 for (kk in seq_along(NAMES)) {
[11:02:52.566]                   name <- changed[[kk]]
[11:02:52.566]                   NAME <- NAMES[[kk]]
[11:02:52.566]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:52.566]                     next
[11:02:52.566]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:52.566]                 }
[11:02:52.566]                 NAMES <- toupper(added)
[11:02:52.566]                 for (kk in seq_along(NAMES)) {
[11:02:52.566]                   name <- added[[kk]]
[11:02:52.566]                   NAME <- NAMES[[kk]]
[11:02:52.566]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:52.566]                     next
[11:02:52.566]                   args[[name]] <- ""
[11:02:52.566]                 }
[11:02:52.566]                 NAMES <- toupper(removed)
[11:02:52.566]                 for (kk in seq_along(NAMES)) {
[11:02:52.566]                   name <- removed[[kk]]
[11:02:52.566]                   NAME <- NAMES[[kk]]
[11:02:52.566]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:52.566]                     next
[11:02:52.566]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:52.566]                 }
[11:02:52.566]                 if (length(args) > 0) 
[11:02:52.566]                   base::do.call(base::Sys.setenv, args = args)
[11:02:52.566]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:52.566]             }
[11:02:52.566]             else {
[11:02:52.566]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:52.566]             }
[11:02:52.566]             {
[11:02:52.566]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:52.566]                   0L) {
[11:02:52.566]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:52.566]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:52.566]                   base::options(opts)
[11:02:52.566]                 }
[11:02:52.566]                 {
[11:02:52.566]                   {
[11:02:52.566]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:52.566]                     NULL
[11:02:52.566]                   }
[11:02:52.566]                   options(future.plan = NULL)
[11:02:52.566]                   if (is.na(NA_character_)) 
[11:02:52.566]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:52.566]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:52.566]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:52.566]                     .init = FALSE)
[11:02:52.566]                 }
[11:02:52.566]             }
[11:02:52.566]         }
[11:02:52.566]     })
[11:02:52.566]     if (TRUE) {
[11:02:52.566]         base::sink(type = "output", split = FALSE)
[11:02:52.566]         if (TRUE) {
[11:02:52.566]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:52.566]         }
[11:02:52.566]         else {
[11:02:52.566]             ...future.result["stdout"] <- base::list(NULL)
[11:02:52.566]         }
[11:02:52.566]         base::close(...future.stdout)
[11:02:52.566]         ...future.stdout <- NULL
[11:02:52.566]     }
[11:02:52.566]     ...future.result$conditions <- ...future.conditions
[11:02:52.566]     ...future.result$finished <- base::Sys.time()
[11:02:52.566]     ...future.result
[11:02:52.566] }
[11:02:52.569] MultisessionFuture started
[11:02:52.569] - Launch lazy future ... done
[11:02:52.569] run() for ‘MultisessionFuture’ ... done
[11:02:52.612] receiveMessageFromWorker() for ClusterFuture ...
[11:02:52.612] - Validating connection of MultisessionFuture
[11:02:52.613] - received message: FutureResult
[11:02:52.613] - Received FutureResult
[11:02:52.613] - Erased future from FutureRegistry
[11:02:52.613] result() for ClusterFuture ...
[11:02:52.613] - result already collected: FutureResult
[11:02:52.614] result() for ClusterFuture ... done
[11:02:52.614] signalConditions() ...
[11:02:52.614]  - include = ‘immediateCondition’
[11:02:52.614]  - exclude = 
[11:02:52.614]  - resignal = FALSE
[11:02:52.614]  - Number of conditions: 1
[11:02:52.614] signalConditions() ... done
[11:02:52.614] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:52.615] A MultisessionFuture was resolved
[11:02:52.615] getGlobalsAndPackages() ...
[11:02:52.615] Searching for globals...
[11:02:52.616] - globals found: [2] ‘list’, ‘stop’
[11:02:52.616] Searching for globals ... DONE
[11:02:52.616] Resolving globals: FALSE
[11:02:52.616] 
[11:02:52.617] 
[11:02:52.617] getGlobalsAndPackages() ... DONE
[11:02:52.617] run() for ‘Future’ ...
[11:02:52.617] - state: ‘created’
[11:02:52.617] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:52.632] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:52.632] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:52.632]   - Field: ‘node’
[11:02:52.632]   - Field: ‘label’
[11:02:52.632]   - Field: ‘local’
[11:02:52.633]   - Field: ‘owner’
[11:02:52.633]   - Field: ‘envir’
[11:02:52.633]   - Field: ‘workers’
[11:02:52.633]   - Field: ‘packages’
[11:02:52.633]   - Field: ‘gc’
[11:02:52.633]   - Field: ‘conditions’
[11:02:52.633]   - Field: ‘persistent’
[11:02:52.633]   - Field: ‘expr’
[11:02:52.633]   - Field: ‘uuid’
[11:02:52.633]   - Field: ‘seed’
[11:02:52.633]   - Field: ‘version’
[11:02:52.634]   - Field: ‘result’
[11:02:52.634]   - Field: ‘asynchronous’
[11:02:52.634]   - Field: ‘calls’
[11:02:52.634]   - Field: ‘globals’
[11:02:52.634]   - Field: ‘stdout’
[11:02:52.634]   - Field: ‘earlySignal’
[11:02:52.634]   - Field: ‘lazy’
[11:02:52.634]   - Field: ‘state’
[11:02:52.634] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:52.634] - Launch lazy future ...
[11:02:52.635] Packages needed by the future expression (n = 0): <none>
[11:02:52.635] Packages needed by future strategies (n = 0): <none>
[11:02:52.635] {
[11:02:52.635]     {
[11:02:52.635]         {
[11:02:52.635]             ...future.startTime <- base::Sys.time()
[11:02:52.635]             {
[11:02:52.635]                 {
[11:02:52.635]                   {
[11:02:52.635]                     {
[11:02:52.635]                       base::local({
[11:02:52.635]                         has_future <- base::requireNamespace("future", 
[11:02:52.635]                           quietly = TRUE)
[11:02:52.635]                         if (has_future) {
[11:02:52.635]                           ns <- base::getNamespace("future")
[11:02:52.635]                           version <- ns[[".package"]][["version"]]
[11:02:52.635]                           if (is.null(version)) 
[11:02:52.635]                             version <- utils::packageVersion("future")
[11:02:52.635]                         }
[11:02:52.635]                         else {
[11:02:52.635]                           version <- NULL
[11:02:52.635]                         }
[11:02:52.635]                         if (!has_future || version < "1.8.0") {
[11:02:52.635]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:52.635]                             "", base::R.version$version.string), 
[11:02:52.635]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:52.635]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:52.635]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:52.635]                               "release", "version")], collapse = " "), 
[11:02:52.635]                             hostname = base::Sys.info()[["nodename"]])
[11:02:52.635]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:52.635]                             info)
[11:02:52.635]                           info <- base::paste(info, collapse = "; ")
[11:02:52.635]                           if (!has_future) {
[11:02:52.635]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:52.635]                               info)
[11:02:52.635]                           }
[11:02:52.635]                           else {
[11:02:52.635]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:52.635]                               info, version)
[11:02:52.635]                           }
[11:02:52.635]                           base::stop(msg)
[11:02:52.635]                         }
[11:02:52.635]                       })
[11:02:52.635]                     }
[11:02:52.635]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:52.635]                     base::options(mc.cores = 1L)
[11:02:52.635]                   }
[11:02:52.635]                   ...future.strategy.old <- future::plan("list")
[11:02:52.635]                   options(future.plan = NULL)
[11:02:52.635]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:52.635]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:52.635]                 }
[11:02:52.635]                 ...future.workdir <- getwd()
[11:02:52.635]             }
[11:02:52.635]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:52.635]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:52.635]         }
[11:02:52.635]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:52.635]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:52.635]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:52.635]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:52.635]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:52.635]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:52.635]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:52.635]             base::names(...future.oldOptions))
[11:02:52.635]     }
[11:02:52.635]     if (FALSE) {
[11:02:52.635]     }
[11:02:52.635]     else {
[11:02:52.635]         if (TRUE) {
[11:02:52.635]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:52.635]                 open = "w")
[11:02:52.635]         }
[11:02:52.635]         else {
[11:02:52.635]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:52.635]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:52.635]         }
[11:02:52.635]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:52.635]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:52.635]             base::sink(type = "output", split = FALSE)
[11:02:52.635]             base::close(...future.stdout)
[11:02:52.635]         }, add = TRUE)
[11:02:52.635]     }
[11:02:52.635]     ...future.frame <- base::sys.nframe()
[11:02:52.635]     ...future.conditions <- base::list()
[11:02:52.635]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:52.635]     if (FALSE) {
[11:02:52.635]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:52.635]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:52.635]     }
[11:02:52.635]     ...future.result <- base::tryCatch({
[11:02:52.635]         base::withCallingHandlers({
[11:02:52.635]             ...future.value <- base::withVisible(base::local({
[11:02:52.635]                 ...future.makeSendCondition <- base::local({
[11:02:52.635]                   sendCondition <- NULL
[11:02:52.635]                   function(frame = 1L) {
[11:02:52.635]                     if (is.function(sendCondition)) 
[11:02:52.635]                       return(sendCondition)
[11:02:52.635]                     ns <- getNamespace("parallel")
[11:02:52.635]                     if (exists("sendData", mode = "function", 
[11:02:52.635]                       envir = ns)) {
[11:02:52.635]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:52.635]                         envir = ns)
[11:02:52.635]                       envir <- sys.frame(frame)
[11:02:52.635]                       master <- NULL
[11:02:52.635]                       while (!identical(envir, .GlobalEnv) && 
[11:02:52.635]                         !identical(envir, emptyenv())) {
[11:02:52.635]                         if (exists("master", mode = "list", envir = envir, 
[11:02:52.635]                           inherits = FALSE)) {
[11:02:52.635]                           master <- get("master", mode = "list", 
[11:02:52.635]                             envir = envir, inherits = FALSE)
[11:02:52.635]                           if (inherits(master, c("SOCKnode", 
[11:02:52.635]                             "SOCK0node"))) {
[11:02:52.635]                             sendCondition <<- function(cond) {
[11:02:52.635]                               data <- list(type = "VALUE", value = cond, 
[11:02:52.635]                                 success = TRUE)
[11:02:52.635]                               parallel_sendData(master, data)
[11:02:52.635]                             }
[11:02:52.635]                             return(sendCondition)
[11:02:52.635]                           }
[11:02:52.635]                         }
[11:02:52.635]                         frame <- frame + 1L
[11:02:52.635]                         envir <- sys.frame(frame)
[11:02:52.635]                       }
[11:02:52.635]                     }
[11:02:52.635]                     sendCondition <<- function(cond) NULL
[11:02:52.635]                   }
[11:02:52.635]                 })
[11:02:52.635]                 withCallingHandlers({
[11:02:52.635]                   list(a = 1, b = 42L, c = stop("Nah!"))
[11:02:52.635]                 }, immediateCondition = function(cond) {
[11:02:52.635]                   sendCondition <- ...future.makeSendCondition()
[11:02:52.635]                   sendCondition(cond)
[11:02:52.635]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:52.635]                   {
[11:02:52.635]                     inherits <- base::inherits
[11:02:52.635]                     invokeRestart <- base::invokeRestart
[11:02:52.635]                     is.null <- base::is.null
[11:02:52.635]                     muffled <- FALSE
[11:02:52.635]                     if (inherits(cond, "message")) {
[11:02:52.635]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:52.635]                       if (muffled) 
[11:02:52.635]                         invokeRestart("muffleMessage")
[11:02:52.635]                     }
[11:02:52.635]                     else if (inherits(cond, "warning")) {
[11:02:52.635]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:52.635]                       if (muffled) 
[11:02:52.635]                         invokeRestart("muffleWarning")
[11:02:52.635]                     }
[11:02:52.635]                     else if (inherits(cond, "condition")) {
[11:02:52.635]                       if (!is.null(pattern)) {
[11:02:52.635]                         computeRestarts <- base::computeRestarts
[11:02:52.635]                         grepl <- base::grepl
[11:02:52.635]                         restarts <- computeRestarts(cond)
[11:02:52.635]                         for (restart in restarts) {
[11:02:52.635]                           name <- restart$name
[11:02:52.635]                           if (is.null(name)) 
[11:02:52.635]                             next
[11:02:52.635]                           if (!grepl(pattern, name)) 
[11:02:52.635]                             next
[11:02:52.635]                           invokeRestart(restart)
[11:02:52.635]                           muffled <- TRUE
[11:02:52.635]                           break
[11:02:52.635]                         }
[11:02:52.635]                       }
[11:02:52.635]                     }
[11:02:52.635]                     invisible(muffled)
[11:02:52.635]                   }
[11:02:52.635]                   muffleCondition(cond)
[11:02:52.635]                 })
[11:02:52.635]             }))
[11:02:52.635]             future::FutureResult(value = ...future.value$value, 
[11:02:52.635]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:52.635]                   ...future.rng), globalenv = if (FALSE) 
[11:02:52.635]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:52.635]                     ...future.globalenv.names))
[11:02:52.635]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:52.635]         }, condition = base::local({
[11:02:52.635]             c <- base::c
[11:02:52.635]             inherits <- base::inherits
[11:02:52.635]             invokeRestart <- base::invokeRestart
[11:02:52.635]             length <- base::length
[11:02:52.635]             list <- base::list
[11:02:52.635]             seq.int <- base::seq.int
[11:02:52.635]             signalCondition <- base::signalCondition
[11:02:52.635]             sys.calls <- base::sys.calls
[11:02:52.635]             `[[` <- base::`[[`
[11:02:52.635]             `+` <- base::`+`
[11:02:52.635]             `<<-` <- base::`<<-`
[11:02:52.635]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:52.635]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:52.635]                   3L)]
[11:02:52.635]             }
[11:02:52.635]             function(cond) {
[11:02:52.635]                 is_error <- inherits(cond, "error")
[11:02:52.635]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:52.635]                   NULL)
[11:02:52.635]                 if (is_error) {
[11:02:52.635]                   sessionInformation <- function() {
[11:02:52.635]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:52.635]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:52.635]                       search = base::search(), system = base::Sys.info())
[11:02:52.635]                   }
[11:02:52.635]                   ...future.conditions[[length(...future.conditions) + 
[11:02:52.635]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:52.635]                     cond$call), session = sessionInformation(), 
[11:02:52.635]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:52.635]                   signalCondition(cond)
[11:02:52.635]                 }
[11:02:52.635]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:52.635]                 "immediateCondition"))) {
[11:02:52.635]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:52.635]                   ...future.conditions[[length(...future.conditions) + 
[11:02:52.635]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:52.635]                   if (TRUE && !signal) {
[11:02:52.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:52.635]                     {
[11:02:52.635]                       inherits <- base::inherits
[11:02:52.635]                       invokeRestart <- base::invokeRestart
[11:02:52.635]                       is.null <- base::is.null
[11:02:52.635]                       muffled <- FALSE
[11:02:52.635]                       if (inherits(cond, "message")) {
[11:02:52.635]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:52.635]                         if (muffled) 
[11:02:52.635]                           invokeRestart("muffleMessage")
[11:02:52.635]                       }
[11:02:52.635]                       else if (inherits(cond, "warning")) {
[11:02:52.635]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:52.635]                         if (muffled) 
[11:02:52.635]                           invokeRestart("muffleWarning")
[11:02:52.635]                       }
[11:02:52.635]                       else if (inherits(cond, "condition")) {
[11:02:52.635]                         if (!is.null(pattern)) {
[11:02:52.635]                           computeRestarts <- base::computeRestarts
[11:02:52.635]                           grepl <- base::grepl
[11:02:52.635]                           restarts <- computeRestarts(cond)
[11:02:52.635]                           for (restart in restarts) {
[11:02:52.635]                             name <- restart$name
[11:02:52.635]                             if (is.null(name)) 
[11:02:52.635]                               next
[11:02:52.635]                             if (!grepl(pattern, name)) 
[11:02:52.635]                               next
[11:02:52.635]                             invokeRestart(restart)
[11:02:52.635]                             muffled <- TRUE
[11:02:52.635]                             break
[11:02:52.635]                           }
[11:02:52.635]                         }
[11:02:52.635]                       }
[11:02:52.635]                       invisible(muffled)
[11:02:52.635]                     }
[11:02:52.635]                     muffleCondition(cond, pattern = "^muffle")
[11:02:52.635]                   }
[11:02:52.635]                 }
[11:02:52.635]                 else {
[11:02:52.635]                   if (TRUE) {
[11:02:52.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:52.635]                     {
[11:02:52.635]                       inherits <- base::inherits
[11:02:52.635]                       invokeRestart <- base::invokeRestart
[11:02:52.635]                       is.null <- base::is.null
[11:02:52.635]                       muffled <- FALSE
[11:02:52.635]                       if (inherits(cond, "message")) {
[11:02:52.635]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:52.635]                         if (muffled) 
[11:02:52.635]                           invokeRestart("muffleMessage")
[11:02:52.635]                       }
[11:02:52.635]                       else if (inherits(cond, "warning")) {
[11:02:52.635]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:52.635]                         if (muffled) 
[11:02:52.635]                           invokeRestart("muffleWarning")
[11:02:52.635]                       }
[11:02:52.635]                       else if (inherits(cond, "condition")) {
[11:02:52.635]                         if (!is.null(pattern)) {
[11:02:52.635]                           computeRestarts <- base::computeRestarts
[11:02:52.635]                           grepl <- base::grepl
[11:02:52.635]                           restarts <- computeRestarts(cond)
[11:02:52.635]                           for (restart in restarts) {
[11:02:52.635]                             name <- restart$name
[11:02:52.635]                             if (is.null(name)) 
[11:02:52.635]                               next
[11:02:52.635]                             if (!grepl(pattern, name)) 
[11:02:52.635]                               next
[11:02:52.635]                             invokeRestart(restart)
[11:02:52.635]                             muffled <- TRUE
[11:02:52.635]                             break
[11:02:52.635]                           }
[11:02:52.635]                         }
[11:02:52.635]                       }
[11:02:52.635]                       invisible(muffled)
[11:02:52.635]                     }
[11:02:52.635]                     muffleCondition(cond, pattern = "^muffle")
[11:02:52.635]                   }
[11:02:52.635]                 }
[11:02:52.635]             }
[11:02:52.635]         }))
[11:02:52.635]     }, error = function(ex) {
[11:02:52.635]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:52.635]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:52.635]                 ...future.rng), started = ...future.startTime, 
[11:02:52.635]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:52.635]             version = "1.8"), class = "FutureResult")
[11:02:52.635]     }, finally = {
[11:02:52.635]         if (!identical(...future.workdir, getwd())) 
[11:02:52.635]             setwd(...future.workdir)
[11:02:52.635]         {
[11:02:52.635]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:52.635]                 ...future.oldOptions$nwarnings <- NULL
[11:02:52.635]             }
[11:02:52.635]             base::options(...future.oldOptions)
[11:02:52.635]             if (.Platform$OS.type == "windows") {
[11:02:52.635]                 old_names <- names(...future.oldEnvVars)
[11:02:52.635]                 envs <- base::Sys.getenv()
[11:02:52.635]                 names <- names(envs)
[11:02:52.635]                 common <- intersect(names, old_names)
[11:02:52.635]                 added <- setdiff(names, old_names)
[11:02:52.635]                 removed <- setdiff(old_names, names)
[11:02:52.635]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:52.635]                   envs[common]]
[11:02:52.635]                 NAMES <- toupper(changed)
[11:02:52.635]                 args <- list()
[11:02:52.635]                 for (kk in seq_along(NAMES)) {
[11:02:52.635]                   name <- changed[[kk]]
[11:02:52.635]                   NAME <- NAMES[[kk]]
[11:02:52.635]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:52.635]                     next
[11:02:52.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:52.635]                 }
[11:02:52.635]                 NAMES <- toupper(added)
[11:02:52.635]                 for (kk in seq_along(NAMES)) {
[11:02:52.635]                   name <- added[[kk]]
[11:02:52.635]                   NAME <- NAMES[[kk]]
[11:02:52.635]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:52.635]                     next
[11:02:52.635]                   args[[name]] <- ""
[11:02:52.635]                 }
[11:02:52.635]                 NAMES <- toupper(removed)
[11:02:52.635]                 for (kk in seq_along(NAMES)) {
[11:02:52.635]                   name <- removed[[kk]]
[11:02:52.635]                   NAME <- NAMES[[kk]]
[11:02:52.635]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:52.635]                     next
[11:02:52.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:52.635]                 }
[11:02:52.635]                 if (length(args) > 0) 
[11:02:52.635]                   base::do.call(base::Sys.setenv, args = args)
[11:02:52.635]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:52.635]             }
[11:02:52.635]             else {
[11:02:52.635]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:52.635]             }
[11:02:52.635]             {
[11:02:52.635]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:52.635]                   0L) {
[11:02:52.635]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:52.635]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:52.635]                   base::options(opts)
[11:02:52.635]                 }
[11:02:52.635]                 {
[11:02:52.635]                   {
[11:02:52.635]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:52.635]                     NULL
[11:02:52.635]                   }
[11:02:52.635]                   options(future.plan = NULL)
[11:02:52.635]                   if (is.na(NA_character_)) 
[11:02:52.635]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:52.635]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:52.635]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:52.635]                     .init = FALSE)
[11:02:52.635]                 }
[11:02:52.635]             }
[11:02:52.635]         }
[11:02:52.635]     })
[11:02:52.635]     if (TRUE) {
[11:02:52.635]         base::sink(type = "output", split = FALSE)
[11:02:52.635]         if (TRUE) {
[11:02:52.635]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:52.635]         }
[11:02:52.635]         else {
[11:02:52.635]             ...future.result["stdout"] <- base::list(NULL)
[11:02:52.635]         }
[11:02:52.635]         base::close(...future.stdout)
[11:02:52.635]         ...future.stdout <- NULL
[11:02:52.635]     }
[11:02:52.635]     ...future.result$conditions <- ...future.conditions
[11:02:52.635]     ...future.result$finished <- base::Sys.time()
[11:02:52.635]     ...future.result
[11:02:52.635] }
[11:02:52.640] MultisessionFuture started
[11:02:52.640] - Launch lazy future ... done
[11:02:52.640] run() for ‘MultisessionFuture’ ... done
[11:02:52.682] receiveMessageFromWorker() for ClusterFuture ...
[11:02:52.682] - Validating connection of MultisessionFuture
[11:02:52.683] - received message: FutureResult
[11:02:52.683] - Received FutureResult
[11:02:52.683] - Erased future from FutureRegistry
[11:02:52.683] result() for ClusterFuture ...
[11:02:52.683] - result already collected: FutureResult
[11:02:52.683] result() for ClusterFuture ... done
[11:02:52.683] signalConditions() ...
[11:02:52.683]  - include = ‘immediateCondition’
[11:02:52.684]  - exclude = 
[11:02:52.684]  - resignal = FALSE
[11:02:52.684]  - Number of conditions: 1
[11:02:52.684] signalConditions() ... done
[11:02:52.684] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:52.684] A MultisessionFuture was resolved
- result = TRUE, recursive = 0 ... DONE
- result = TRUE, recursive = 1 ...
[11:02:52.684] getGlobalsAndPackages() ...
[11:02:52.684] Searching for globals...
[11:02:52.685] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[11:02:52.685] Searching for globals ... DONE
[11:02:52.686] Resolving globals: FALSE
[11:02:52.686] 
[11:02:52.686] 
[11:02:52.686] getGlobalsAndPackages() ... DONE
[11:02:52.686] run() for ‘Future’ ...
[11:02:52.686] - state: ‘created’
[11:02:52.686] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:52.700] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:52.700] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:52.700]   - Field: ‘node’
[11:02:52.700]   - Field: ‘label’
[11:02:52.700]   - Field: ‘local’
[11:02:52.701]   - Field: ‘owner’
[11:02:52.701]   - Field: ‘envir’
[11:02:52.701]   - Field: ‘workers’
[11:02:52.701]   - Field: ‘packages’
[11:02:52.701]   - Field: ‘gc’
[11:02:52.701]   - Field: ‘conditions’
[11:02:52.701]   - Field: ‘persistent’
[11:02:52.701]   - Field: ‘expr’
[11:02:52.701]   - Field: ‘uuid’
[11:02:52.701]   - Field: ‘seed’
[11:02:52.701]   - Field: ‘version’
[11:02:52.701]   - Field: ‘result’
[11:02:52.702]   - Field: ‘asynchronous’
[11:02:52.702]   - Field: ‘calls’
[11:02:52.702]   - Field: ‘globals’
[11:02:52.702]   - Field: ‘stdout’
[11:02:52.702]   - Field: ‘earlySignal’
[11:02:52.702]   - Field: ‘lazy’
[11:02:52.702]   - Field: ‘state’
[11:02:52.702] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:52.702] - Launch lazy future ...
[11:02:52.702] Packages needed by the future expression (n = 0): <none>
[11:02:52.703] Packages needed by future strategies (n = 0): <none>
[11:02:52.703] {
[11:02:52.703]     {
[11:02:52.703]         {
[11:02:52.703]             ...future.startTime <- base::Sys.time()
[11:02:52.703]             {
[11:02:52.703]                 {
[11:02:52.703]                   {
[11:02:52.703]                     {
[11:02:52.703]                       base::local({
[11:02:52.703]                         has_future <- base::requireNamespace("future", 
[11:02:52.703]                           quietly = TRUE)
[11:02:52.703]                         if (has_future) {
[11:02:52.703]                           ns <- base::getNamespace("future")
[11:02:52.703]                           version <- ns[[".package"]][["version"]]
[11:02:52.703]                           if (is.null(version)) 
[11:02:52.703]                             version <- utils::packageVersion("future")
[11:02:52.703]                         }
[11:02:52.703]                         else {
[11:02:52.703]                           version <- NULL
[11:02:52.703]                         }
[11:02:52.703]                         if (!has_future || version < "1.8.0") {
[11:02:52.703]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:52.703]                             "", base::R.version$version.string), 
[11:02:52.703]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:52.703]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:52.703]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:52.703]                               "release", "version")], collapse = " "), 
[11:02:52.703]                             hostname = base::Sys.info()[["nodename"]])
[11:02:52.703]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:52.703]                             info)
[11:02:52.703]                           info <- base::paste(info, collapse = "; ")
[11:02:52.703]                           if (!has_future) {
[11:02:52.703]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:52.703]                               info)
[11:02:52.703]                           }
[11:02:52.703]                           else {
[11:02:52.703]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:52.703]                               info, version)
[11:02:52.703]                           }
[11:02:52.703]                           base::stop(msg)
[11:02:52.703]                         }
[11:02:52.703]                       })
[11:02:52.703]                     }
[11:02:52.703]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:52.703]                     base::options(mc.cores = 1L)
[11:02:52.703]                   }
[11:02:52.703]                   ...future.strategy.old <- future::plan("list")
[11:02:52.703]                   options(future.plan = NULL)
[11:02:52.703]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:52.703]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:52.703]                 }
[11:02:52.703]                 ...future.workdir <- getwd()
[11:02:52.703]             }
[11:02:52.703]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:52.703]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:52.703]         }
[11:02:52.703]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:52.703]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:52.703]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:52.703]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:52.703]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:52.703]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:52.703]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:52.703]             base::names(...future.oldOptions))
[11:02:52.703]     }
[11:02:52.703]     if (FALSE) {
[11:02:52.703]     }
[11:02:52.703]     else {
[11:02:52.703]         if (TRUE) {
[11:02:52.703]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:52.703]                 open = "w")
[11:02:52.703]         }
[11:02:52.703]         else {
[11:02:52.703]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:52.703]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:52.703]         }
[11:02:52.703]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:52.703]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:52.703]             base::sink(type = "output", split = FALSE)
[11:02:52.703]             base::close(...future.stdout)
[11:02:52.703]         }, add = TRUE)
[11:02:52.703]     }
[11:02:52.703]     ...future.frame <- base::sys.nframe()
[11:02:52.703]     ...future.conditions <- base::list()
[11:02:52.703]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:52.703]     if (FALSE) {
[11:02:52.703]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:52.703]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:52.703]     }
[11:02:52.703]     ...future.result <- base::tryCatch({
[11:02:52.703]         base::withCallingHandlers({
[11:02:52.703]             ...future.value <- base::withVisible(base::local({
[11:02:52.703]                 ...future.makeSendCondition <- base::local({
[11:02:52.703]                   sendCondition <- NULL
[11:02:52.703]                   function(frame = 1L) {
[11:02:52.703]                     if (is.function(sendCondition)) 
[11:02:52.703]                       return(sendCondition)
[11:02:52.703]                     ns <- getNamespace("parallel")
[11:02:52.703]                     if (exists("sendData", mode = "function", 
[11:02:52.703]                       envir = ns)) {
[11:02:52.703]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:52.703]                         envir = ns)
[11:02:52.703]                       envir <- sys.frame(frame)
[11:02:52.703]                       master <- NULL
[11:02:52.703]                       while (!identical(envir, .GlobalEnv) && 
[11:02:52.703]                         !identical(envir, emptyenv())) {
[11:02:52.703]                         if (exists("master", mode = "list", envir = envir, 
[11:02:52.703]                           inherits = FALSE)) {
[11:02:52.703]                           master <- get("master", mode = "list", 
[11:02:52.703]                             envir = envir, inherits = FALSE)
[11:02:52.703]                           if (inherits(master, c("SOCKnode", 
[11:02:52.703]                             "SOCK0node"))) {
[11:02:52.703]                             sendCondition <<- function(cond) {
[11:02:52.703]                               data <- list(type = "VALUE", value = cond, 
[11:02:52.703]                                 success = TRUE)
[11:02:52.703]                               parallel_sendData(master, data)
[11:02:52.703]                             }
[11:02:52.703]                             return(sendCondition)
[11:02:52.703]                           }
[11:02:52.703]                         }
[11:02:52.703]                         frame <- frame + 1L
[11:02:52.703]                         envir <- sys.frame(frame)
[11:02:52.703]                       }
[11:02:52.703]                     }
[11:02:52.703]                     sendCondition <<- function(cond) NULL
[11:02:52.703]                   }
[11:02:52.703]                 })
[11:02:52.703]                 withCallingHandlers({
[11:02:52.703]                   {
[11:02:52.703]                     Sys.sleep(0.5)
[11:02:52.703]                     list(a = 1, b = 42L)
[11:02:52.703]                   }
[11:02:52.703]                 }, immediateCondition = function(cond) {
[11:02:52.703]                   sendCondition <- ...future.makeSendCondition()
[11:02:52.703]                   sendCondition(cond)
[11:02:52.703]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:52.703]                   {
[11:02:52.703]                     inherits <- base::inherits
[11:02:52.703]                     invokeRestart <- base::invokeRestart
[11:02:52.703]                     is.null <- base::is.null
[11:02:52.703]                     muffled <- FALSE
[11:02:52.703]                     if (inherits(cond, "message")) {
[11:02:52.703]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:52.703]                       if (muffled) 
[11:02:52.703]                         invokeRestart("muffleMessage")
[11:02:52.703]                     }
[11:02:52.703]                     else if (inherits(cond, "warning")) {
[11:02:52.703]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:52.703]                       if (muffled) 
[11:02:52.703]                         invokeRestart("muffleWarning")
[11:02:52.703]                     }
[11:02:52.703]                     else if (inherits(cond, "condition")) {
[11:02:52.703]                       if (!is.null(pattern)) {
[11:02:52.703]                         computeRestarts <- base::computeRestarts
[11:02:52.703]                         grepl <- base::grepl
[11:02:52.703]                         restarts <- computeRestarts(cond)
[11:02:52.703]                         for (restart in restarts) {
[11:02:52.703]                           name <- restart$name
[11:02:52.703]                           if (is.null(name)) 
[11:02:52.703]                             next
[11:02:52.703]                           if (!grepl(pattern, name)) 
[11:02:52.703]                             next
[11:02:52.703]                           invokeRestart(restart)
[11:02:52.703]                           muffled <- TRUE
[11:02:52.703]                           break
[11:02:52.703]                         }
[11:02:52.703]                       }
[11:02:52.703]                     }
[11:02:52.703]                     invisible(muffled)
[11:02:52.703]                   }
[11:02:52.703]                   muffleCondition(cond)
[11:02:52.703]                 })
[11:02:52.703]             }))
[11:02:52.703]             future::FutureResult(value = ...future.value$value, 
[11:02:52.703]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:52.703]                   ...future.rng), globalenv = if (FALSE) 
[11:02:52.703]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:52.703]                     ...future.globalenv.names))
[11:02:52.703]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:52.703]         }, condition = base::local({
[11:02:52.703]             c <- base::c
[11:02:52.703]             inherits <- base::inherits
[11:02:52.703]             invokeRestart <- base::invokeRestart
[11:02:52.703]             length <- base::length
[11:02:52.703]             list <- base::list
[11:02:52.703]             seq.int <- base::seq.int
[11:02:52.703]             signalCondition <- base::signalCondition
[11:02:52.703]             sys.calls <- base::sys.calls
[11:02:52.703]             `[[` <- base::`[[`
[11:02:52.703]             `+` <- base::`+`
[11:02:52.703]             `<<-` <- base::`<<-`
[11:02:52.703]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:52.703]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:52.703]                   3L)]
[11:02:52.703]             }
[11:02:52.703]             function(cond) {
[11:02:52.703]                 is_error <- inherits(cond, "error")
[11:02:52.703]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:52.703]                   NULL)
[11:02:52.703]                 if (is_error) {
[11:02:52.703]                   sessionInformation <- function() {
[11:02:52.703]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:52.703]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:52.703]                       search = base::search(), system = base::Sys.info())
[11:02:52.703]                   }
[11:02:52.703]                   ...future.conditions[[length(...future.conditions) + 
[11:02:52.703]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:52.703]                     cond$call), session = sessionInformation(), 
[11:02:52.703]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:52.703]                   signalCondition(cond)
[11:02:52.703]                 }
[11:02:52.703]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:52.703]                 "immediateCondition"))) {
[11:02:52.703]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:52.703]                   ...future.conditions[[length(...future.conditions) + 
[11:02:52.703]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:52.703]                   if (TRUE && !signal) {
[11:02:52.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:52.703]                     {
[11:02:52.703]                       inherits <- base::inherits
[11:02:52.703]                       invokeRestart <- base::invokeRestart
[11:02:52.703]                       is.null <- base::is.null
[11:02:52.703]                       muffled <- FALSE
[11:02:52.703]                       if (inherits(cond, "message")) {
[11:02:52.703]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:52.703]                         if (muffled) 
[11:02:52.703]                           invokeRestart("muffleMessage")
[11:02:52.703]                       }
[11:02:52.703]                       else if (inherits(cond, "warning")) {
[11:02:52.703]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:52.703]                         if (muffled) 
[11:02:52.703]                           invokeRestart("muffleWarning")
[11:02:52.703]                       }
[11:02:52.703]                       else if (inherits(cond, "condition")) {
[11:02:52.703]                         if (!is.null(pattern)) {
[11:02:52.703]                           computeRestarts <- base::computeRestarts
[11:02:52.703]                           grepl <- base::grepl
[11:02:52.703]                           restarts <- computeRestarts(cond)
[11:02:52.703]                           for (restart in restarts) {
[11:02:52.703]                             name <- restart$name
[11:02:52.703]                             if (is.null(name)) 
[11:02:52.703]                               next
[11:02:52.703]                             if (!grepl(pattern, name)) 
[11:02:52.703]                               next
[11:02:52.703]                             invokeRestart(restart)
[11:02:52.703]                             muffled <- TRUE
[11:02:52.703]                             break
[11:02:52.703]                           }
[11:02:52.703]                         }
[11:02:52.703]                       }
[11:02:52.703]                       invisible(muffled)
[11:02:52.703]                     }
[11:02:52.703]                     muffleCondition(cond, pattern = "^muffle")
[11:02:52.703]                   }
[11:02:52.703]                 }
[11:02:52.703]                 else {
[11:02:52.703]                   if (TRUE) {
[11:02:52.703]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:52.703]                     {
[11:02:52.703]                       inherits <- base::inherits
[11:02:52.703]                       invokeRestart <- base::invokeRestart
[11:02:52.703]                       is.null <- base::is.null
[11:02:52.703]                       muffled <- FALSE
[11:02:52.703]                       if (inherits(cond, "message")) {
[11:02:52.703]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:52.703]                         if (muffled) 
[11:02:52.703]                           invokeRestart("muffleMessage")
[11:02:52.703]                       }
[11:02:52.703]                       else if (inherits(cond, "warning")) {
[11:02:52.703]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:52.703]                         if (muffled) 
[11:02:52.703]                           invokeRestart("muffleWarning")
[11:02:52.703]                       }
[11:02:52.703]                       else if (inherits(cond, "condition")) {
[11:02:52.703]                         if (!is.null(pattern)) {
[11:02:52.703]                           computeRestarts <- base::computeRestarts
[11:02:52.703]                           grepl <- base::grepl
[11:02:52.703]                           restarts <- computeRestarts(cond)
[11:02:52.703]                           for (restart in restarts) {
[11:02:52.703]                             name <- restart$name
[11:02:52.703]                             if (is.null(name)) 
[11:02:52.703]                               next
[11:02:52.703]                             if (!grepl(pattern, name)) 
[11:02:52.703]                               next
[11:02:52.703]                             invokeRestart(restart)
[11:02:52.703]                             muffled <- TRUE
[11:02:52.703]                             break
[11:02:52.703]                           }
[11:02:52.703]                         }
[11:02:52.703]                       }
[11:02:52.703]                       invisible(muffled)
[11:02:52.703]                     }
[11:02:52.703]                     muffleCondition(cond, pattern = "^muffle")
[11:02:52.703]                   }
[11:02:52.703]                 }
[11:02:52.703]             }
[11:02:52.703]         }))
[11:02:52.703]     }, error = function(ex) {
[11:02:52.703]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:52.703]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:52.703]                 ...future.rng), started = ...future.startTime, 
[11:02:52.703]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:52.703]             version = "1.8"), class = "FutureResult")
[11:02:52.703]     }, finally = {
[11:02:52.703]         if (!identical(...future.workdir, getwd())) 
[11:02:52.703]             setwd(...future.workdir)
[11:02:52.703]         {
[11:02:52.703]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:52.703]                 ...future.oldOptions$nwarnings <- NULL
[11:02:52.703]             }
[11:02:52.703]             base::options(...future.oldOptions)
[11:02:52.703]             if (.Platform$OS.type == "windows") {
[11:02:52.703]                 old_names <- names(...future.oldEnvVars)
[11:02:52.703]                 envs <- base::Sys.getenv()
[11:02:52.703]                 names <- names(envs)
[11:02:52.703]                 common <- intersect(names, old_names)
[11:02:52.703]                 added <- setdiff(names, old_names)
[11:02:52.703]                 removed <- setdiff(old_names, names)
[11:02:52.703]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:52.703]                   envs[common]]
[11:02:52.703]                 NAMES <- toupper(changed)
[11:02:52.703]                 args <- list()
[11:02:52.703]                 for (kk in seq_along(NAMES)) {
[11:02:52.703]                   name <- changed[[kk]]
[11:02:52.703]                   NAME <- NAMES[[kk]]
[11:02:52.703]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:52.703]                     next
[11:02:52.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:52.703]                 }
[11:02:52.703]                 NAMES <- toupper(added)
[11:02:52.703]                 for (kk in seq_along(NAMES)) {
[11:02:52.703]                   name <- added[[kk]]
[11:02:52.703]                   NAME <- NAMES[[kk]]
[11:02:52.703]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:52.703]                     next
[11:02:52.703]                   args[[name]] <- ""
[11:02:52.703]                 }
[11:02:52.703]                 NAMES <- toupper(removed)
[11:02:52.703]                 for (kk in seq_along(NAMES)) {
[11:02:52.703]                   name <- removed[[kk]]
[11:02:52.703]                   NAME <- NAMES[[kk]]
[11:02:52.703]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:52.703]                     next
[11:02:52.703]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:52.703]                 }
[11:02:52.703]                 if (length(args) > 0) 
[11:02:52.703]                   base::do.call(base::Sys.setenv, args = args)
[11:02:52.703]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:52.703]             }
[11:02:52.703]             else {
[11:02:52.703]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:52.703]             }
[11:02:52.703]             {
[11:02:52.703]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:52.703]                   0L) {
[11:02:52.703]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:52.703]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:52.703]                   base::options(opts)
[11:02:52.703]                 }
[11:02:52.703]                 {
[11:02:52.703]                   {
[11:02:52.703]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:52.703]                     NULL
[11:02:52.703]                   }
[11:02:52.703]                   options(future.plan = NULL)
[11:02:52.703]                   if (is.na(NA_character_)) 
[11:02:52.703]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:52.703]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:52.703]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:52.703]                     .init = FALSE)
[11:02:52.703]                 }
[11:02:52.703]             }
[11:02:52.703]         }
[11:02:52.703]     })
[11:02:52.703]     if (TRUE) {
[11:02:52.703]         base::sink(type = "output", split = FALSE)
[11:02:52.703]         if (TRUE) {
[11:02:52.703]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:52.703]         }
[11:02:52.703]         else {
[11:02:52.703]             ...future.result["stdout"] <- base::list(NULL)
[11:02:52.703]         }
[11:02:52.703]         base::close(...future.stdout)
[11:02:52.703]         ...future.stdout <- NULL
[11:02:52.703]     }
[11:02:52.703]     ...future.result$conditions <- ...future.conditions
[11:02:52.703]     ...future.result$finished <- base::Sys.time()
[11:02:52.703]     ...future.result
[11:02:52.703] }
[11:02:52.706] MultisessionFuture started
[11:02:52.706] - Launch lazy future ... done
[11:02:52.706] run() for ‘MultisessionFuture’ ... done
[11:02:53.249] receiveMessageFromWorker() for ClusterFuture ...
[11:02:53.249] - Validating connection of MultisessionFuture
[11:02:53.249] - received message: FutureResult
[11:02:53.249] - Received FutureResult
[11:02:53.249] - Erased future from FutureRegistry
[11:02:53.250] result() for ClusterFuture ...
[11:02:53.250] - result already collected: FutureResult
[11:02:53.250] result() for ClusterFuture ... done
[11:02:53.250] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:53.250] resolve() on list ...
[11:02:53.250]  recursive: 0
[11:02:53.250]  length: 2
[11:02:53.250]  elements: ‘a’, ‘b’
[11:02:53.250]  length: 1 (resolved future 1)
[11:02:53.250]  length: 0 (resolved future 2)
[11:02:53.251] resolve() on list ... DONE
[11:02:53.251] A MultisessionFuture was resolved (and resolved itself)
[11:02:53.251] getGlobalsAndPackages() ...
[11:02:53.251] Searching for globals...
[11:02:53.252] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[11:02:53.252] Searching for globals ... DONE
[11:02:53.252] Resolving globals: FALSE
[11:02:53.252] 
[11:02:53.253] 
[11:02:53.253] getGlobalsAndPackages() ... DONE
[11:02:53.253] run() for ‘Future’ ...
[11:02:53.253] - state: ‘created’
[11:02:53.253] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:53.272] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:53.272] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:53.272]   - Field: ‘node’
[11:02:53.272]   - Field: ‘label’
[11:02:53.272]   - Field: ‘local’
[11:02:53.272]   - Field: ‘owner’
[11:02:53.272]   - Field: ‘envir’
[11:02:53.272]   - Field: ‘workers’
[11:02:53.272]   - Field: ‘packages’
[11:02:53.272]   - Field: ‘gc’
[11:02:53.273]   - Field: ‘conditions’
[11:02:53.273]   - Field: ‘persistent’
[11:02:53.273]   - Field: ‘expr’
[11:02:53.273]   - Field: ‘uuid’
[11:02:53.273]   - Field: ‘seed’
[11:02:53.273]   - Field: ‘version’
[11:02:53.273]   - Field: ‘result’
[11:02:53.273]   - Field: ‘asynchronous’
[11:02:53.273]   - Field: ‘calls’
[11:02:53.273]   - Field: ‘globals’
[11:02:53.273]   - Field: ‘stdout’
[11:02:53.273]   - Field: ‘earlySignal’
[11:02:53.274]   - Field: ‘lazy’
[11:02:53.274]   - Field: ‘state’
[11:02:53.274] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:53.274] - Launch lazy future ...
[11:02:53.274] Packages needed by the future expression (n = 0): <none>
[11:02:53.274] Packages needed by future strategies (n = 0): <none>
[11:02:53.275] {
[11:02:53.275]     {
[11:02:53.275]         {
[11:02:53.275]             ...future.startTime <- base::Sys.time()
[11:02:53.275]             {
[11:02:53.275]                 {
[11:02:53.275]                   {
[11:02:53.275]                     {
[11:02:53.275]                       base::local({
[11:02:53.275]                         has_future <- base::requireNamespace("future", 
[11:02:53.275]                           quietly = TRUE)
[11:02:53.275]                         if (has_future) {
[11:02:53.275]                           ns <- base::getNamespace("future")
[11:02:53.275]                           version <- ns[[".package"]][["version"]]
[11:02:53.275]                           if (is.null(version)) 
[11:02:53.275]                             version <- utils::packageVersion("future")
[11:02:53.275]                         }
[11:02:53.275]                         else {
[11:02:53.275]                           version <- NULL
[11:02:53.275]                         }
[11:02:53.275]                         if (!has_future || version < "1.8.0") {
[11:02:53.275]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:53.275]                             "", base::R.version$version.string), 
[11:02:53.275]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:53.275]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:53.275]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:53.275]                               "release", "version")], collapse = " "), 
[11:02:53.275]                             hostname = base::Sys.info()[["nodename"]])
[11:02:53.275]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:53.275]                             info)
[11:02:53.275]                           info <- base::paste(info, collapse = "; ")
[11:02:53.275]                           if (!has_future) {
[11:02:53.275]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:53.275]                               info)
[11:02:53.275]                           }
[11:02:53.275]                           else {
[11:02:53.275]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:53.275]                               info, version)
[11:02:53.275]                           }
[11:02:53.275]                           base::stop(msg)
[11:02:53.275]                         }
[11:02:53.275]                       })
[11:02:53.275]                     }
[11:02:53.275]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:53.275]                     base::options(mc.cores = 1L)
[11:02:53.275]                   }
[11:02:53.275]                   ...future.strategy.old <- future::plan("list")
[11:02:53.275]                   options(future.plan = NULL)
[11:02:53.275]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:53.275]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:53.275]                 }
[11:02:53.275]                 ...future.workdir <- getwd()
[11:02:53.275]             }
[11:02:53.275]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:53.275]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:53.275]         }
[11:02:53.275]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:53.275]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:53.275]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:53.275]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:53.275]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:53.275]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:53.275]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:53.275]             base::names(...future.oldOptions))
[11:02:53.275]     }
[11:02:53.275]     if (FALSE) {
[11:02:53.275]     }
[11:02:53.275]     else {
[11:02:53.275]         if (TRUE) {
[11:02:53.275]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:53.275]                 open = "w")
[11:02:53.275]         }
[11:02:53.275]         else {
[11:02:53.275]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:53.275]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:53.275]         }
[11:02:53.275]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:53.275]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:53.275]             base::sink(type = "output", split = FALSE)
[11:02:53.275]             base::close(...future.stdout)
[11:02:53.275]         }, add = TRUE)
[11:02:53.275]     }
[11:02:53.275]     ...future.frame <- base::sys.nframe()
[11:02:53.275]     ...future.conditions <- base::list()
[11:02:53.275]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:53.275]     if (FALSE) {
[11:02:53.275]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:53.275]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:53.275]     }
[11:02:53.275]     ...future.result <- base::tryCatch({
[11:02:53.275]         base::withCallingHandlers({
[11:02:53.275]             ...future.value <- base::withVisible(base::local({
[11:02:53.275]                 ...future.makeSendCondition <- base::local({
[11:02:53.275]                   sendCondition <- NULL
[11:02:53.275]                   function(frame = 1L) {
[11:02:53.275]                     if (is.function(sendCondition)) 
[11:02:53.275]                       return(sendCondition)
[11:02:53.275]                     ns <- getNamespace("parallel")
[11:02:53.275]                     if (exists("sendData", mode = "function", 
[11:02:53.275]                       envir = ns)) {
[11:02:53.275]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:53.275]                         envir = ns)
[11:02:53.275]                       envir <- sys.frame(frame)
[11:02:53.275]                       master <- NULL
[11:02:53.275]                       while (!identical(envir, .GlobalEnv) && 
[11:02:53.275]                         !identical(envir, emptyenv())) {
[11:02:53.275]                         if (exists("master", mode = "list", envir = envir, 
[11:02:53.275]                           inherits = FALSE)) {
[11:02:53.275]                           master <- get("master", mode = "list", 
[11:02:53.275]                             envir = envir, inherits = FALSE)
[11:02:53.275]                           if (inherits(master, c("SOCKnode", 
[11:02:53.275]                             "SOCK0node"))) {
[11:02:53.275]                             sendCondition <<- function(cond) {
[11:02:53.275]                               data <- list(type = "VALUE", value = cond, 
[11:02:53.275]                                 success = TRUE)
[11:02:53.275]                               parallel_sendData(master, data)
[11:02:53.275]                             }
[11:02:53.275]                             return(sendCondition)
[11:02:53.275]                           }
[11:02:53.275]                         }
[11:02:53.275]                         frame <- frame + 1L
[11:02:53.275]                         envir <- sys.frame(frame)
[11:02:53.275]                       }
[11:02:53.275]                     }
[11:02:53.275]                     sendCondition <<- function(cond) NULL
[11:02:53.275]                   }
[11:02:53.275]                 })
[11:02:53.275]                 withCallingHandlers({
[11:02:53.275]                   {
[11:02:53.275]                     Sys.sleep(0.5)
[11:02:53.275]                     list(a = 1, b = 42L)
[11:02:53.275]                   }
[11:02:53.275]                 }, immediateCondition = function(cond) {
[11:02:53.275]                   sendCondition <- ...future.makeSendCondition()
[11:02:53.275]                   sendCondition(cond)
[11:02:53.275]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:53.275]                   {
[11:02:53.275]                     inherits <- base::inherits
[11:02:53.275]                     invokeRestart <- base::invokeRestart
[11:02:53.275]                     is.null <- base::is.null
[11:02:53.275]                     muffled <- FALSE
[11:02:53.275]                     if (inherits(cond, "message")) {
[11:02:53.275]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:53.275]                       if (muffled) 
[11:02:53.275]                         invokeRestart("muffleMessage")
[11:02:53.275]                     }
[11:02:53.275]                     else if (inherits(cond, "warning")) {
[11:02:53.275]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:53.275]                       if (muffled) 
[11:02:53.275]                         invokeRestart("muffleWarning")
[11:02:53.275]                     }
[11:02:53.275]                     else if (inherits(cond, "condition")) {
[11:02:53.275]                       if (!is.null(pattern)) {
[11:02:53.275]                         computeRestarts <- base::computeRestarts
[11:02:53.275]                         grepl <- base::grepl
[11:02:53.275]                         restarts <- computeRestarts(cond)
[11:02:53.275]                         for (restart in restarts) {
[11:02:53.275]                           name <- restart$name
[11:02:53.275]                           if (is.null(name)) 
[11:02:53.275]                             next
[11:02:53.275]                           if (!grepl(pattern, name)) 
[11:02:53.275]                             next
[11:02:53.275]                           invokeRestart(restart)
[11:02:53.275]                           muffled <- TRUE
[11:02:53.275]                           break
[11:02:53.275]                         }
[11:02:53.275]                       }
[11:02:53.275]                     }
[11:02:53.275]                     invisible(muffled)
[11:02:53.275]                   }
[11:02:53.275]                   muffleCondition(cond)
[11:02:53.275]                 })
[11:02:53.275]             }))
[11:02:53.275]             future::FutureResult(value = ...future.value$value, 
[11:02:53.275]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:53.275]                   ...future.rng), globalenv = if (FALSE) 
[11:02:53.275]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:53.275]                     ...future.globalenv.names))
[11:02:53.275]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:53.275]         }, condition = base::local({
[11:02:53.275]             c <- base::c
[11:02:53.275]             inherits <- base::inherits
[11:02:53.275]             invokeRestart <- base::invokeRestart
[11:02:53.275]             length <- base::length
[11:02:53.275]             list <- base::list
[11:02:53.275]             seq.int <- base::seq.int
[11:02:53.275]             signalCondition <- base::signalCondition
[11:02:53.275]             sys.calls <- base::sys.calls
[11:02:53.275]             `[[` <- base::`[[`
[11:02:53.275]             `+` <- base::`+`
[11:02:53.275]             `<<-` <- base::`<<-`
[11:02:53.275]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:53.275]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:53.275]                   3L)]
[11:02:53.275]             }
[11:02:53.275]             function(cond) {
[11:02:53.275]                 is_error <- inherits(cond, "error")
[11:02:53.275]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:53.275]                   NULL)
[11:02:53.275]                 if (is_error) {
[11:02:53.275]                   sessionInformation <- function() {
[11:02:53.275]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:53.275]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:53.275]                       search = base::search(), system = base::Sys.info())
[11:02:53.275]                   }
[11:02:53.275]                   ...future.conditions[[length(...future.conditions) + 
[11:02:53.275]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:53.275]                     cond$call), session = sessionInformation(), 
[11:02:53.275]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:53.275]                   signalCondition(cond)
[11:02:53.275]                 }
[11:02:53.275]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:53.275]                 "immediateCondition"))) {
[11:02:53.275]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:53.275]                   ...future.conditions[[length(...future.conditions) + 
[11:02:53.275]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:53.275]                   if (TRUE && !signal) {
[11:02:53.275]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:53.275]                     {
[11:02:53.275]                       inherits <- base::inherits
[11:02:53.275]                       invokeRestart <- base::invokeRestart
[11:02:53.275]                       is.null <- base::is.null
[11:02:53.275]                       muffled <- FALSE
[11:02:53.275]                       if (inherits(cond, "message")) {
[11:02:53.275]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:53.275]                         if (muffled) 
[11:02:53.275]                           invokeRestart("muffleMessage")
[11:02:53.275]                       }
[11:02:53.275]                       else if (inherits(cond, "warning")) {
[11:02:53.275]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:53.275]                         if (muffled) 
[11:02:53.275]                           invokeRestart("muffleWarning")
[11:02:53.275]                       }
[11:02:53.275]                       else if (inherits(cond, "condition")) {
[11:02:53.275]                         if (!is.null(pattern)) {
[11:02:53.275]                           computeRestarts <- base::computeRestarts
[11:02:53.275]                           grepl <- base::grepl
[11:02:53.275]                           restarts <- computeRestarts(cond)
[11:02:53.275]                           for (restart in restarts) {
[11:02:53.275]                             name <- restart$name
[11:02:53.275]                             if (is.null(name)) 
[11:02:53.275]                               next
[11:02:53.275]                             if (!grepl(pattern, name)) 
[11:02:53.275]                               next
[11:02:53.275]                             invokeRestart(restart)
[11:02:53.275]                             muffled <- TRUE
[11:02:53.275]                             break
[11:02:53.275]                           }
[11:02:53.275]                         }
[11:02:53.275]                       }
[11:02:53.275]                       invisible(muffled)
[11:02:53.275]                     }
[11:02:53.275]                     muffleCondition(cond, pattern = "^muffle")
[11:02:53.275]                   }
[11:02:53.275]                 }
[11:02:53.275]                 else {
[11:02:53.275]                   if (TRUE) {
[11:02:53.275]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:53.275]                     {
[11:02:53.275]                       inherits <- base::inherits
[11:02:53.275]                       invokeRestart <- base::invokeRestart
[11:02:53.275]                       is.null <- base::is.null
[11:02:53.275]                       muffled <- FALSE
[11:02:53.275]                       if (inherits(cond, "message")) {
[11:02:53.275]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:53.275]                         if (muffled) 
[11:02:53.275]                           invokeRestart("muffleMessage")
[11:02:53.275]                       }
[11:02:53.275]                       else if (inherits(cond, "warning")) {
[11:02:53.275]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:53.275]                         if (muffled) 
[11:02:53.275]                           invokeRestart("muffleWarning")
[11:02:53.275]                       }
[11:02:53.275]                       else if (inherits(cond, "condition")) {
[11:02:53.275]                         if (!is.null(pattern)) {
[11:02:53.275]                           computeRestarts <- base::computeRestarts
[11:02:53.275]                           grepl <- base::grepl
[11:02:53.275]                           restarts <- computeRestarts(cond)
[11:02:53.275]                           for (restart in restarts) {
[11:02:53.275]                             name <- restart$name
[11:02:53.275]                             if (is.null(name)) 
[11:02:53.275]                               next
[11:02:53.275]                             if (!grepl(pattern, name)) 
[11:02:53.275]                               next
[11:02:53.275]                             invokeRestart(restart)
[11:02:53.275]                             muffled <- TRUE
[11:02:53.275]                             break
[11:02:53.275]                           }
[11:02:53.275]                         }
[11:02:53.275]                       }
[11:02:53.275]                       invisible(muffled)
[11:02:53.275]                     }
[11:02:53.275]                     muffleCondition(cond, pattern = "^muffle")
[11:02:53.275]                   }
[11:02:53.275]                 }
[11:02:53.275]             }
[11:02:53.275]         }))
[11:02:53.275]     }, error = function(ex) {
[11:02:53.275]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:53.275]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:53.275]                 ...future.rng), started = ...future.startTime, 
[11:02:53.275]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:53.275]             version = "1.8"), class = "FutureResult")
[11:02:53.275]     }, finally = {
[11:02:53.275]         if (!identical(...future.workdir, getwd())) 
[11:02:53.275]             setwd(...future.workdir)
[11:02:53.275]         {
[11:02:53.275]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:53.275]                 ...future.oldOptions$nwarnings <- NULL
[11:02:53.275]             }
[11:02:53.275]             base::options(...future.oldOptions)
[11:02:53.275]             if (.Platform$OS.type == "windows") {
[11:02:53.275]                 old_names <- names(...future.oldEnvVars)
[11:02:53.275]                 envs <- base::Sys.getenv()
[11:02:53.275]                 names <- names(envs)
[11:02:53.275]                 common <- intersect(names, old_names)
[11:02:53.275]                 added <- setdiff(names, old_names)
[11:02:53.275]                 removed <- setdiff(old_names, names)
[11:02:53.275]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:53.275]                   envs[common]]
[11:02:53.275]                 NAMES <- toupper(changed)
[11:02:53.275]                 args <- list()
[11:02:53.275]                 for (kk in seq_along(NAMES)) {
[11:02:53.275]                   name <- changed[[kk]]
[11:02:53.275]                   NAME <- NAMES[[kk]]
[11:02:53.275]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:53.275]                     next
[11:02:53.275]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:53.275]                 }
[11:02:53.275]                 NAMES <- toupper(added)
[11:02:53.275]                 for (kk in seq_along(NAMES)) {
[11:02:53.275]                   name <- added[[kk]]
[11:02:53.275]                   NAME <- NAMES[[kk]]
[11:02:53.275]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:53.275]                     next
[11:02:53.275]                   args[[name]] <- ""
[11:02:53.275]                 }
[11:02:53.275]                 NAMES <- toupper(removed)
[11:02:53.275]                 for (kk in seq_along(NAMES)) {
[11:02:53.275]                   name <- removed[[kk]]
[11:02:53.275]                   NAME <- NAMES[[kk]]
[11:02:53.275]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:53.275]                     next
[11:02:53.275]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:53.275]                 }
[11:02:53.275]                 if (length(args) > 0) 
[11:02:53.275]                   base::do.call(base::Sys.setenv, args = args)
[11:02:53.275]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:53.275]             }
[11:02:53.275]             else {
[11:02:53.275]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:53.275]             }
[11:02:53.275]             {
[11:02:53.275]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:53.275]                   0L) {
[11:02:53.275]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:53.275]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:53.275]                   base::options(opts)
[11:02:53.275]                 }
[11:02:53.275]                 {
[11:02:53.275]                   {
[11:02:53.275]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:53.275]                     NULL
[11:02:53.275]                   }
[11:02:53.275]                   options(future.plan = NULL)
[11:02:53.275]                   if (is.na(NA_character_)) 
[11:02:53.275]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:53.275]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:53.275]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:53.275]                     .init = FALSE)
[11:02:53.275]                 }
[11:02:53.275]             }
[11:02:53.275]         }
[11:02:53.275]     })
[11:02:53.275]     if (TRUE) {
[11:02:53.275]         base::sink(type = "output", split = FALSE)
[11:02:53.275]         if (TRUE) {
[11:02:53.275]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:53.275]         }
[11:02:53.275]         else {
[11:02:53.275]             ...future.result["stdout"] <- base::list(NULL)
[11:02:53.275]         }
[11:02:53.275]         base::close(...future.stdout)
[11:02:53.275]         ...future.stdout <- NULL
[11:02:53.275]     }
[11:02:53.275]     ...future.result$conditions <- ...future.conditions
[11:02:53.275]     ...future.result$finished <- base::Sys.time()
[11:02:53.275]     ...future.result
[11:02:53.275] }
[11:02:53.278] MultisessionFuture started
[11:02:53.278] - Launch lazy future ... done
[11:02:53.278] run() for ‘MultisessionFuture’ ... done
[11:02:53.821] receiveMessageFromWorker() for ClusterFuture ...
[11:02:53.821] - Validating connection of MultisessionFuture
[11:02:53.821] - received message: FutureResult
[11:02:53.821] - Received FutureResult
[11:02:53.821] - Erased future from FutureRegistry
[11:02:53.822] result() for ClusterFuture ...
[11:02:53.822] - result already collected: FutureResult
[11:02:53.822] result() for ClusterFuture ... done
[11:02:53.822] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:53.822] resolve() on list ...
[11:02:53.822]  recursive: 0
[11:02:53.822]  length: 2
[11:02:53.822]  elements: ‘a’, ‘b’
[11:02:53.822]  length: 1 (resolved future 1)
[11:02:53.822]  length: 0 (resolved future 2)
[11:02:53.823] resolve() on list ... DONE
[11:02:53.823] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[11:02:53.823] getGlobalsAndPackages() ...
[11:02:53.823] Searching for globals...
[11:02:53.823] - globals found: [2] ‘list’, ‘stop’
[11:02:53.824] Searching for globals ... DONE
[11:02:53.824] Resolving globals: FALSE
[11:02:53.824] 
[11:02:53.824] 
[11:02:53.824] getGlobalsAndPackages() ... DONE
[11:02:53.824] run() for ‘Future’ ...
[11:02:53.824] - state: ‘created’
[11:02:53.825] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:53.838] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:53.838] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:53.838]   - Field: ‘node’
[11:02:53.839]   - Field: ‘label’
[11:02:53.839]   - Field: ‘local’
[11:02:53.839]   - Field: ‘owner’
[11:02:53.839]   - Field: ‘envir’
[11:02:53.839]   - Field: ‘workers’
[11:02:53.839]   - Field: ‘packages’
[11:02:53.839]   - Field: ‘gc’
[11:02:53.839]   - Field: ‘conditions’
[11:02:53.839]   - Field: ‘persistent’
[11:02:53.839]   - Field: ‘expr’
[11:02:53.839]   - Field: ‘uuid’
[11:02:53.839]   - Field: ‘seed’
[11:02:53.840]   - Field: ‘version’
[11:02:53.840]   - Field: ‘result’
[11:02:53.840]   - Field: ‘asynchronous’
[11:02:53.840]   - Field: ‘calls’
[11:02:53.840]   - Field: ‘globals’
[11:02:53.840]   - Field: ‘stdout’
[11:02:53.840]   - Field: ‘earlySignal’
[11:02:53.840]   - Field: ‘lazy’
[11:02:53.840]   - Field: ‘state’
[11:02:53.840] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:53.840] - Launch lazy future ...
[11:02:53.841] Packages needed by the future expression (n = 0): <none>
[11:02:53.841] Packages needed by future strategies (n = 0): <none>
[11:02:53.841] {
[11:02:53.841]     {
[11:02:53.841]         {
[11:02:53.841]             ...future.startTime <- base::Sys.time()
[11:02:53.841]             {
[11:02:53.841]                 {
[11:02:53.841]                   {
[11:02:53.841]                     {
[11:02:53.841]                       base::local({
[11:02:53.841]                         has_future <- base::requireNamespace("future", 
[11:02:53.841]                           quietly = TRUE)
[11:02:53.841]                         if (has_future) {
[11:02:53.841]                           ns <- base::getNamespace("future")
[11:02:53.841]                           version <- ns[[".package"]][["version"]]
[11:02:53.841]                           if (is.null(version)) 
[11:02:53.841]                             version <- utils::packageVersion("future")
[11:02:53.841]                         }
[11:02:53.841]                         else {
[11:02:53.841]                           version <- NULL
[11:02:53.841]                         }
[11:02:53.841]                         if (!has_future || version < "1.8.0") {
[11:02:53.841]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:53.841]                             "", base::R.version$version.string), 
[11:02:53.841]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:53.841]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:53.841]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:53.841]                               "release", "version")], collapse = " "), 
[11:02:53.841]                             hostname = base::Sys.info()[["nodename"]])
[11:02:53.841]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:53.841]                             info)
[11:02:53.841]                           info <- base::paste(info, collapse = "; ")
[11:02:53.841]                           if (!has_future) {
[11:02:53.841]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:53.841]                               info)
[11:02:53.841]                           }
[11:02:53.841]                           else {
[11:02:53.841]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:53.841]                               info, version)
[11:02:53.841]                           }
[11:02:53.841]                           base::stop(msg)
[11:02:53.841]                         }
[11:02:53.841]                       })
[11:02:53.841]                     }
[11:02:53.841]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:53.841]                     base::options(mc.cores = 1L)
[11:02:53.841]                   }
[11:02:53.841]                   ...future.strategy.old <- future::plan("list")
[11:02:53.841]                   options(future.plan = NULL)
[11:02:53.841]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:53.841]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:53.841]                 }
[11:02:53.841]                 ...future.workdir <- getwd()
[11:02:53.841]             }
[11:02:53.841]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:53.841]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:53.841]         }
[11:02:53.841]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:53.841]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:53.841]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:53.841]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:53.841]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:53.841]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:53.841]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:53.841]             base::names(...future.oldOptions))
[11:02:53.841]     }
[11:02:53.841]     if (FALSE) {
[11:02:53.841]     }
[11:02:53.841]     else {
[11:02:53.841]         if (TRUE) {
[11:02:53.841]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:53.841]                 open = "w")
[11:02:53.841]         }
[11:02:53.841]         else {
[11:02:53.841]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:53.841]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:53.841]         }
[11:02:53.841]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:53.841]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:53.841]             base::sink(type = "output", split = FALSE)
[11:02:53.841]             base::close(...future.stdout)
[11:02:53.841]         }, add = TRUE)
[11:02:53.841]     }
[11:02:53.841]     ...future.frame <- base::sys.nframe()
[11:02:53.841]     ...future.conditions <- base::list()
[11:02:53.841]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:53.841]     if (FALSE) {
[11:02:53.841]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:53.841]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:53.841]     }
[11:02:53.841]     ...future.result <- base::tryCatch({
[11:02:53.841]         base::withCallingHandlers({
[11:02:53.841]             ...future.value <- base::withVisible(base::local({
[11:02:53.841]                 ...future.makeSendCondition <- base::local({
[11:02:53.841]                   sendCondition <- NULL
[11:02:53.841]                   function(frame = 1L) {
[11:02:53.841]                     if (is.function(sendCondition)) 
[11:02:53.841]                       return(sendCondition)
[11:02:53.841]                     ns <- getNamespace("parallel")
[11:02:53.841]                     if (exists("sendData", mode = "function", 
[11:02:53.841]                       envir = ns)) {
[11:02:53.841]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:53.841]                         envir = ns)
[11:02:53.841]                       envir <- sys.frame(frame)
[11:02:53.841]                       master <- NULL
[11:02:53.841]                       while (!identical(envir, .GlobalEnv) && 
[11:02:53.841]                         !identical(envir, emptyenv())) {
[11:02:53.841]                         if (exists("master", mode = "list", envir = envir, 
[11:02:53.841]                           inherits = FALSE)) {
[11:02:53.841]                           master <- get("master", mode = "list", 
[11:02:53.841]                             envir = envir, inherits = FALSE)
[11:02:53.841]                           if (inherits(master, c("SOCKnode", 
[11:02:53.841]                             "SOCK0node"))) {
[11:02:53.841]                             sendCondition <<- function(cond) {
[11:02:53.841]                               data <- list(type = "VALUE", value = cond, 
[11:02:53.841]                                 success = TRUE)
[11:02:53.841]                               parallel_sendData(master, data)
[11:02:53.841]                             }
[11:02:53.841]                             return(sendCondition)
[11:02:53.841]                           }
[11:02:53.841]                         }
[11:02:53.841]                         frame <- frame + 1L
[11:02:53.841]                         envir <- sys.frame(frame)
[11:02:53.841]                       }
[11:02:53.841]                     }
[11:02:53.841]                     sendCondition <<- function(cond) NULL
[11:02:53.841]                   }
[11:02:53.841]                 })
[11:02:53.841]                 withCallingHandlers({
[11:02:53.841]                   list(a = 1, b = 42L, c = stop("Nah!"))
[11:02:53.841]                 }, immediateCondition = function(cond) {
[11:02:53.841]                   sendCondition <- ...future.makeSendCondition()
[11:02:53.841]                   sendCondition(cond)
[11:02:53.841]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:53.841]                   {
[11:02:53.841]                     inherits <- base::inherits
[11:02:53.841]                     invokeRestart <- base::invokeRestart
[11:02:53.841]                     is.null <- base::is.null
[11:02:53.841]                     muffled <- FALSE
[11:02:53.841]                     if (inherits(cond, "message")) {
[11:02:53.841]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:53.841]                       if (muffled) 
[11:02:53.841]                         invokeRestart("muffleMessage")
[11:02:53.841]                     }
[11:02:53.841]                     else if (inherits(cond, "warning")) {
[11:02:53.841]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:53.841]                       if (muffled) 
[11:02:53.841]                         invokeRestart("muffleWarning")
[11:02:53.841]                     }
[11:02:53.841]                     else if (inherits(cond, "condition")) {
[11:02:53.841]                       if (!is.null(pattern)) {
[11:02:53.841]                         computeRestarts <- base::computeRestarts
[11:02:53.841]                         grepl <- base::grepl
[11:02:53.841]                         restarts <- computeRestarts(cond)
[11:02:53.841]                         for (restart in restarts) {
[11:02:53.841]                           name <- restart$name
[11:02:53.841]                           if (is.null(name)) 
[11:02:53.841]                             next
[11:02:53.841]                           if (!grepl(pattern, name)) 
[11:02:53.841]                             next
[11:02:53.841]                           invokeRestart(restart)
[11:02:53.841]                           muffled <- TRUE
[11:02:53.841]                           break
[11:02:53.841]                         }
[11:02:53.841]                       }
[11:02:53.841]                     }
[11:02:53.841]                     invisible(muffled)
[11:02:53.841]                   }
[11:02:53.841]                   muffleCondition(cond)
[11:02:53.841]                 })
[11:02:53.841]             }))
[11:02:53.841]             future::FutureResult(value = ...future.value$value, 
[11:02:53.841]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:53.841]                   ...future.rng), globalenv = if (FALSE) 
[11:02:53.841]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:53.841]                     ...future.globalenv.names))
[11:02:53.841]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:53.841]         }, condition = base::local({
[11:02:53.841]             c <- base::c
[11:02:53.841]             inherits <- base::inherits
[11:02:53.841]             invokeRestart <- base::invokeRestart
[11:02:53.841]             length <- base::length
[11:02:53.841]             list <- base::list
[11:02:53.841]             seq.int <- base::seq.int
[11:02:53.841]             signalCondition <- base::signalCondition
[11:02:53.841]             sys.calls <- base::sys.calls
[11:02:53.841]             `[[` <- base::`[[`
[11:02:53.841]             `+` <- base::`+`
[11:02:53.841]             `<<-` <- base::`<<-`
[11:02:53.841]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:53.841]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:53.841]                   3L)]
[11:02:53.841]             }
[11:02:53.841]             function(cond) {
[11:02:53.841]                 is_error <- inherits(cond, "error")
[11:02:53.841]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:53.841]                   NULL)
[11:02:53.841]                 if (is_error) {
[11:02:53.841]                   sessionInformation <- function() {
[11:02:53.841]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:53.841]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:53.841]                       search = base::search(), system = base::Sys.info())
[11:02:53.841]                   }
[11:02:53.841]                   ...future.conditions[[length(...future.conditions) + 
[11:02:53.841]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:53.841]                     cond$call), session = sessionInformation(), 
[11:02:53.841]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:53.841]                   signalCondition(cond)
[11:02:53.841]                 }
[11:02:53.841]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:53.841]                 "immediateCondition"))) {
[11:02:53.841]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:53.841]                   ...future.conditions[[length(...future.conditions) + 
[11:02:53.841]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:53.841]                   if (TRUE && !signal) {
[11:02:53.841]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:53.841]                     {
[11:02:53.841]                       inherits <- base::inherits
[11:02:53.841]                       invokeRestart <- base::invokeRestart
[11:02:53.841]                       is.null <- base::is.null
[11:02:53.841]                       muffled <- FALSE
[11:02:53.841]                       if (inherits(cond, "message")) {
[11:02:53.841]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:53.841]                         if (muffled) 
[11:02:53.841]                           invokeRestart("muffleMessage")
[11:02:53.841]                       }
[11:02:53.841]                       else if (inherits(cond, "warning")) {
[11:02:53.841]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:53.841]                         if (muffled) 
[11:02:53.841]                           invokeRestart("muffleWarning")
[11:02:53.841]                       }
[11:02:53.841]                       else if (inherits(cond, "condition")) {
[11:02:53.841]                         if (!is.null(pattern)) {
[11:02:53.841]                           computeRestarts <- base::computeRestarts
[11:02:53.841]                           grepl <- base::grepl
[11:02:53.841]                           restarts <- computeRestarts(cond)
[11:02:53.841]                           for (restart in restarts) {
[11:02:53.841]                             name <- restart$name
[11:02:53.841]                             if (is.null(name)) 
[11:02:53.841]                               next
[11:02:53.841]                             if (!grepl(pattern, name)) 
[11:02:53.841]                               next
[11:02:53.841]                             invokeRestart(restart)
[11:02:53.841]                             muffled <- TRUE
[11:02:53.841]                             break
[11:02:53.841]                           }
[11:02:53.841]                         }
[11:02:53.841]                       }
[11:02:53.841]                       invisible(muffled)
[11:02:53.841]                     }
[11:02:53.841]                     muffleCondition(cond, pattern = "^muffle")
[11:02:53.841]                   }
[11:02:53.841]                 }
[11:02:53.841]                 else {
[11:02:53.841]                   if (TRUE) {
[11:02:53.841]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:53.841]                     {
[11:02:53.841]                       inherits <- base::inherits
[11:02:53.841]                       invokeRestart <- base::invokeRestart
[11:02:53.841]                       is.null <- base::is.null
[11:02:53.841]                       muffled <- FALSE
[11:02:53.841]                       if (inherits(cond, "message")) {
[11:02:53.841]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:53.841]                         if (muffled) 
[11:02:53.841]                           invokeRestart("muffleMessage")
[11:02:53.841]                       }
[11:02:53.841]                       else if (inherits(cond, "warning")) {
[11:02:53.841]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:53.841]                         if (muffled) 
[11:02:53.841]                           invokeRestart("muffleWarning")
[11:02:53.841]                       }
[11:02:53.841]                       else if (inherits(cond, "condition")) {
[11:02:53.841]                         if (!is.null(pattern)) {
[11:02:53.841]                           computeRestarts <- base::computeRestarts
[11:02:53.841]                           grepl <- base::grepl
[11:02:53.841]                           restarts <- computeRestarts(cond)
[11:02:53.841]                           for (restart in restarts) {
[11:02:53.841]                             name <- restart$name
[11:02:53.841]                             if (is.null(name)) 
[11:02:53.841]                               next
[11:02:53.841]                             if (!grepl(pattern, name)) 
[11:02:53.841]                               next
[11:02:53.841]                             invokeRestart(restart)
[11:02:53.841]                             muffled <- TRUE
[11:02:53.841]                             break
[11:02:53.841]                           }
[11:02:53.841]                         }
[11:02:53.841]                       }
[11:02:53.841]                       invisible(muffled)
[11:02:53.841]                     }
[11:02:53.841]                     muffleCondition(cond, pattern = "^muffle")
[11:02:53.841]                   }
[11:02:53.841]                 }
[11:02:53.841]             }
[11:02:53.841]         }))
[11:02:53.841]     }, error = function(ex) {
[11:02:53.841]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:53.841]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:53.841]                 ...future.rng), started = ...future.startTime, 
[11:02:53.841]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:53.841]             version = "1.8"), class = "FutureResult")
[11:02:53.841]     }, finally = {
[11:02:53.841]         if (!identical(...future.workdir, getwd())) 
[11:02:53.841]             setwd(...future.workdir)
[11:02:53.841]         {
[11:02:53.841]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:53.841]                 ...future.oldOptions$nwarnings <- NULL
[11:02:53.841]             }
[11:02:53.841]             base::options(...future.oldOptions)
[11:02:53.841]             if (.Platform$OS.type == "windows") {
[11:02:53.841]                 old_names <- names(...future.oldEnvVars)
[11:02:53.841]                 envs <- base::Sys.getenv()
[11:02:53.841]                 names <- names(envs)
[11:02:53.841]                 common <- intersect(names, old_names)
[11:02:53.841]                 added <- setdiff(names, old_names)
[11:02:53.841]                 removed <- setdiff(old_names, names)
[11:02:53.841]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:53.841]                   envs[common]]
[11:02:53.841]                 NAMES <- toupper(changed)
[11:02:53.841]                 args <- list()
[11:02:53.841]                 for (kk in seq_along(NAMES)) {
[11:02:53.841]                   name <- changed[[kk]]
[11:02:53.841]                   NAME <- NAMES[[kk]]
[11:02:53.841]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:53.841]                     next
[11:02:53.841]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:53.841]                 }
[11:02:53.841]                 NAMES <- toupper(added)
[11:02:53.841]                 for (kk in seq_along(NAMES)) {
[11:02:53.841]                   name <- added[[kk]]
[11:02:53.841]                   NAME <- NAMES[[kk]]
[11:02:53.841]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:53.841]                     next
[11:02:53.841]                   args[[name]] <- ""
[11:02:53.841]                 }
[11:02:53.841]                 NAMES <- toupper(removed)
[11:02:53.841]                 for (kk in seq_along(NAMES)) {
[11:02:53.841]                   name <- removed[[kk]]
[11:02:53.841]                   NAME <- NAMES[[kk]]
[11:02:53.841]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:53.841]                     next
[11:02:53.841]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:53.841]                 }
[11:02:53.841]                 if (length(args) > 0) 
[11:02:53.841]                   base::do.call(base::Sys.setenv, args = args)
[11:02:53.841]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:53.841]             }
[11:02:53.841]             else {
[11:02:53.841]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:53.841]             }
[11:02:53.841]             {
[11:02:53.841]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:53.841]                   0L) {
[11:02:53.841]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:53.841]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:53.841]                   base::options(opts)
[11:02:53.841]                 }
[11:02:53.841]                 {
[11:02:53.841]                   {
[11:02:53.841]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:53.841]                     NULL
[11:02:53.841]                   }
[11:02:53.841]                   options(future.plan = NULL)
[11:02:53.841]                   if (is.na(NA_character_)) 
[11:02:53.841]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:53.841]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:53.841]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:53.841]                     .init = FALSE)
[11:02:53.841]                 }
[11:02:53.841]             }
[11:02:53.841]         }
[11:02:53.841]     })
[11:02:53.841]     if (TRUE) {
[11:02:53.841]         base::sink(type = "output", split = FALSE)
[11:02:53.841]         if (TRUE) {
[11:02:53.841]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:53.841]         }
[11:02:53.841]         else {
[11:02:53.841]             ...future.result["stdout"] <- base::list(NULL)
[11:02:53.841]         }
[11:02:53.841]         base::close(...future.stdout)
[11:02:53.841]         ...future.stdout <- NULL
[11:02:53.841]     }
[11:02:53.841]     ...future.result$conditions <- ...future.conditions
[11:02:53.841]     ...future.result$finished <- base::Sys.time()
[11:02:53.841]     ...future.result
[11:02:53.841] }
[11:02:53.844] MultisessionFuture started
[11:02:53.844] - Launch lazy future ... done
[11:02:53.844] run() for ‘MultisessionFuture’ ... done
[11:02:53.886] receiveMessageFromWorker() for ClusterFuture ...
[11:02:53.886] - Validating connection of MultisessionFuture
[11:02:53.887] - received message: FutureResult
[11:02:53.887] - Received FutureResult
[11:02:53.887] - Erased future from FutureRegistry
[11:02:53.887] result() for ClusterFuture ...
[11:02:53.887] - result already collected: FutureResult
[11:02:53.887] result() for ClusterFuture ... done
[11:02:53.887] signalConditions() ...
[11:02:53.887]  - include = ‘immediateCondition’
[11:02:53.887]  - exclude = 
[11:02:53.888]  - resignal = FALSE
[11:02:53.888]  - Number of conditions: 1
[11:02:53.888] signalConditions() ... done
[11:02:53.888] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:53.888] A MultisessionFuture was resolved (and resolved itself)
[11:02:53.888] getGlobalsAndPackages() ...
[11:02:53.888] Searching for globals...
[11:02:53.889] - globals found: [2] ‘list’, ‘stop’
[11:02:53.889] Searching for globals ... DONE
[11:02:53.889] Resolving globals: FALSE
[11:02:53.889] 
[11:02:53.889] 
[11:02:53.889] getGlobalsAndPackages() ... DONE
[11:02:53.889] run() for ‘Future’ ...
[11:02:53.890] - state: ‘created’
[11:02:53.890] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:53.903] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:53.903] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:53.904]   - Field: ‘node’
[11:02:53.904]   - Field: ‘label’
[11:02:53.904]   - Field: ‘local’
[11:02:53.904]   - Field: ‘owner’
[11:02:53.904]   - Field: ‘envir’
[11:02:53.904]   - Field: ‘workers’
[11:02:53.904]   - Field: ‘packages’
[11:02:53.904]   - Field: ‘gc’
[11:02:53.904]   - Field: ‘conditions’
[11:02:53.904]   - Field: ‘persistent’
[11:02:53.904]   - Field: ‘expr’
[11:02:53.904]   - Field: ‘uuid’
[11:02:53.905]   - Field: ‘seed’
[11:02:53.905]   - Field: ‘version’
[11:02:53.905]   - Field: ‘result’
[11:02:53.905]   - Field: ‘asynchronous’
[11:02:53.905]   - Field: ‘calls’
[11:02:53.905]   - Field: ‘globals’
[11:02:53.905]   - Field: ‘stdout’
[11:02:53.905]   - Field: ‘earlySignal’
[11:02:53.905]   - Field: ‘lazy’
[11:02:53.905]   - Field: ‘state’
[11:02:53.905] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:53.905] - Launch lazy future ...
[11:02:53.906] Packages needed by the future expression (n = 0): <none>
[11:02:53.906] Packages needed by future strategies (n = 0): <none>
[11:02:53.906] {
[11:02:53.906]     {
[11:02:53.906]         {
[11:02:53.906]             ...future.startTime <- base::Sys.time()
[11:02:53.906]             {
[11:02:53.906]                 {
[11:02:53.906]                   {
[11:02:53.906]                     {
[11:02:53.906]                       base::local({
[11:02:53.906]                         has_future <- base::requireNamespace("future", 
[11:02:53.906]                           quietly = TRUE)
[11:02:53.906]                         if (has_future) {
[11:02:53.906]                           ns <- base::getNamespace("future")
[11:02:53.906]                           version <- ns[[".package"]][["version"]]
[11:02:53.906]                           if (is.null(version)) 
[11:02:53.906]                             version <- utils::packageVersion("future")
[11:02:53.906]                         }
[11:02:53.906]                         else {
[11:02:53.906]                           version <- NULL
[11:02:53.906]                         }
[11:02:53.906]                         if (!has_future || version < "1.8.0") {
[11:02:53.906]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:53.906]                             "", base::R.version$version.string), 
[11:02:53.906]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:53.906]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:53.906]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:53.906]                               "release", "version")], collapse = " "), 
[11:02:53.906]                             hostname = base::Sys.info()[["nodename"]])
[11:02:53.906]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:53.906]                             info)
[11:02:53.906]                           info <- base::paste(info, collapse = "; ")
[11:02:53.906]                           if (!has_future) {
[11:02:53.906]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:53.906]                               info)
[11:02:53.906]                           }
[11:02:53.906]                           else {
[11:02:53.906]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:53.906]                               info, version)
[11:02:53.906]                           }
[11:02:53.906]                           base::stop(msg)
[11:02:53.906]                         }
[11:02:53.906]                       })
[11:02:53.906]                     }
[11:02:53.906]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:53.906]                     base::options(mc.cores = 1L)
[11:02:53.906]                   }
[11:02:53.906]                   ...future.strategy.old <- future::plan("list")
[11:02:53.906]                   options(future.plan = NULL)
[11:02:53.906]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:53.906]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:53.906]                 }
[11:02:53.906]                 ...future.workdir <- getwd()
[11:02:53.906]             }
[11:02:53.906]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:53.906]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:53.906]         }
[11:02:53.906]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:53.906]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:53.906]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:53.906]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:53.906]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:53.906]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:53.906]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:53.906]             base::names(...future.oldOptions))
[11:02:53.906]     }
[11:02:53.906]     if (FALSE) {
[11:02:53.906]     }
[11:02:53.906]     else {
[11:02:53.906]         if (TRUE) {
[11:02:53.906]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:53.906]                 open = "w")
[11:02:53.906]         }
[11:02:53.906]         else {
[11:02:53.906]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:53.906]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:53.906]         }
[11:02:53.906]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:53.906]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:53.906]             base::sink(type = "output", split = FALSE)
[11:02:53.906]             base::close(...future.stdout)
[11:02:53.906]         }, add = TRUE)
[11:02:53.906]     }
[11:02:53.906]     ...future.frame <- base::sys.nframe()
[11:02:53.906]     ...future.conditions <- base::list()
[11:02:53.906]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:53.906]     if (FALSE) {
[11:02:53.906]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:53.906]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:53.906]     }
[11:02:53.906]     ...future.result <- base::tryCatch({
[11:02:53.906]         base::withCallingHandlers({
[11:02:53.906]             ...future.value <- base::withVisible(base::local({
[11:02:53.906]                 ...future.makeSendCondition <- base::local({
[11:02:53.906]                   sendCondition <- NULL
[11:02:53.906]                   function(frame = 1L) {
[11:02:53.906]                     if (is.function(sendCondition)) 
[11:02:53.906]                       return(sendCondition)
[11:02:53.906]                     ns <- getNamespace("parallel")
[11:02:53.906]                     if (exists("sendData", mode = "function", 
[11:02:53.906]                       envir = ns)) {
[11:02:53.906]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:53.906]                         envir = ns)
[11:02:53.906]                       envir <- sys.frame(frame)
[11:02:53.906]                       master <- NULL
[11:02:53.906]                       while (!identical(envir, .GlobalEnv) && 
[11:02:53.906]                         !identical(envir, emptyenv())) {
[11:02:53.906]                         if (exists("master", mode = "list", envir = envir, 
[11:02:53.906]                           inherits = FALSE)) {
[11:02:53.906]                           master <- get("master", mode = "list", 
[11:02:53.906]                             envir = envir, inherits = FALSE)
[11:02:53.906]                           if (inherits(master, c("SOCKnode", 
[11:02:53.906]                             "SOCK0node"))) {
[11:02:53.906]                             sendCondition <<- function(cond) {
[11:02:53.906]                               data <- list(type = "VALUE", value = cond, 
[11:02:53.906]                                 success = TRUE)
[11:02:53.906]                               parallel_sendData(master, data)
[11:02:53.906]                             }
[11:02:53.906]                             return(sendCondition)
[11:02:53.906]                           }
[11:02:53.906]                         }
[11:02:53.906]                         frame <- frame + 1L
[11:02:53.906]                         envir <- sys.frame(frame)
[11:02:53.906]                       }
[11:02:53.906]                     }
[11:02:53.906]                     sendCondition <<- function(cond) NULL
[11:02:53.906]                   }
[11:02:53.906]                 })
[11:02:53.906]                 withCallingHandlers({
[11:02:53.906]                   list(a = 1, b = 42L, c = stop("Nah!"))
[11:02:53.906]                 }, immediateCondition = function(cond) {
[11:02:53.906]                   sendCondition <- ...future.makeSendCondition()
[11:02:53.906]                   sendCondition(cond)
[11:02:53.906]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:53.906]                   {
[11:02:53.906]                     inherits <- base::inherits
[11:02:53.906]                     invokeRestart <- base::invokeRestart
[11:02:53.906]                     is.null <- base::is.null
[11:02:53.906]                     muffled <- FALSE
[11:02:53.906]                     if (inherits(cond, "message")) {
[11:02:53.906]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:53.906]                       if (muffled) 
[11:02:53.906]                         invokeRestart("muffleMessage")
[11:02:53.906]                     }
[11:02:53.906]                     else if (inherits(cond, "warning")) {
[11:02:53.906]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:53.906]                       if (muffled) 
[11:02:53.906]                         invokeRestart("muffleWarning")
[11:02:53.906]                     }
[11:02:53.906]                     else if (inherits(cond, "condition")) {
[11:02:53.906]                       if (!is.null(pattern)) {
[11:02:53.906]                         computeRestarts <- base::computeRestarts
[11:02:53.906]                         grepl <- base::grepl
[11:02:53.906]                         restarts <- computeRestarts(cond)
[11:02:53.906]                         for (restart in restarts) {
[11:02:53.906]                           name <- restart$name
[11:02:53.906]                           if (is.null(name)) 
[11:02:53.906]                             next
[11:02:53.906]                           if (!grepl(pattern, name)) 
[11:02:53.906]                             next
[11:02:53.906]                           invokeRestart(restart)
[11:02:53.906]                           muffled <- TRUE
[11:02:53.906]                           break
[11:02:53.906]                         }
[11:02:53.906]                       }
[11:02:53.906]                     }
[11:02:53.906]                     invisible(muffled)
[11:02:53.906]                   }
[11:02:53.906]                   muffleCondition(cond)
[11:02:53.906]                 })
[11:02:53.906]             }))
[11:02:53.906]             future::FutureResult(value = ...future.value$value, 
[11:02:53.906]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:53.906]                   ...future.rng), globalenv = if (FALSE) 
[11:02:53.906]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:53.906]                     ...future.globalenv.names))
[11:02:53.906]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:53.906]         }, condition = base::local({
[11:02:53.906]             c <- base::c
[11:02:53.906]             inherits <- base::inherits
[11:02:53.906]             invokeRestart <- base::invokeRestart
[11:02:53.906]             length <- base::length
[11:02:53.906]             list <- base::list
[11:02:53.906]             seq.int <- base::seq.int
[11:02:53.906]             signalCondition <- base::signalCondition
[11:02:53.906]             sys.calls <- base::sys.calls
[11:02:53.906]             `[[` <- base::`[[`
[11:02:53.906]             `+` <- base::`+`
[11:02:53.906]             `<<-` <- base::`<<-`
[11:02:53.906]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:53.906]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:53.906]                   3L)]
[11:02:53.906]             }
[11:02:53.906]             function(cond) {
[11:02:53.906]                 is_error <- inherits(cond, "error")
[11:02:53.906]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:53.906]                   NULL)
[11:02:53.906]                 if (is_error) {
[11:02:53.906]                   sessionInformation <- function() {
[11:02:53.906]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:53.906]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:53.906]                       search = base::search(), system = base::Sys.info())
[11:02:53.906]                   }
[11:02:53.906]                   ...future.conditions[[length(...future.conditions) + 
[11:02:53.906]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:53.906]                     cond$call), session = sessionInformation(), 
[11:02:53.906]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:53.906]                   signalCondition(cond)
[11:02:53.906]                 }
[11:02:53.906]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:53.906]                 "immediateCondition"))) {
[11:02:53.906]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:53.906]                   ...future.conditions[[length(...future.conditions) + 
[11:02:53.906]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:53.906]                   if (TRUE && !signal) {
[11:02:53.906]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:53.906]                     {
[11:02:53.906]                       inherits <- base::inherits
[11:02:53.906]                       invokeRestart <- base::invokeRestart
[11:02:53.906]                       is.null <- base::is.null
[11:02:53.906]                       muffled <- FALSE
[11:02:53.906]                       if (inherits(cond, "message")) {
[11:02:53.906]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:53.906]                         if (muffled) 
[11:02:53.906]                           invokeRestart("muffleMessage")
[11:02:53.906]                       }
[11:02:53.906]                       else if (inherits(cond, "warning")) {
[11:02:53.906]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:53.906]                         if (muffled) 
[11:02:53.906]                           invokeRestart("muffleWarning")
[11:02:53.906]                       }
[11:02:53.906]                       else if (inherits(cond, "condition")) {
[11:02:53.906]                         if (!is.null(pattern)) {
[11:02:53.906]                           computeRestarts <- base::computeRestarts
[11:02:53.906]                           grepl <- base::grepl
[11:02:53.906]                           restarts <- computeRestarts(cond)
[11:02:53.906]                           for (restart in restarts) {
[11:02:53.906]                             name <- restart$name
[11:02:53.906]                             if (is.null(name)) 
[11:02:53.906]                               next
[11:02:53.906]                             if (!grepl(pattern, name)) 
[11:02:53.906]                               next
[11:02:53.906]                             invokeRestart(restart)
[11:02:53.906]                             muffled <- TRUE
[11:02:53.906]                             break
[11:02:53.906]                           }
[11:02:53.906]                         }
[11:02:53.906]                       }
[11:02:53.906]                       invisible(muffled)
[11:02:53.906]                     }
[11:02:53.906]                     muffleCondition(cond, pattern = "^muffle")
[11:02:53.906]                   }
[11:02:53.906]                 }
[11:02:53.906]                 else {
[11:02:53.906]                   if (TRUE) {
[11:02:53.906]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:53.906]                     {
[11:02:53.906]                       inherits <- base::inherits
[11:02:53.906]                       invokeRestart <- base::invokeRestart
[11:02:53.906]                       is.null <- base::is.null
[11:02:53.906]                       muffled <- FALSE
[11:02:53.906]                       if (inherits(cond, "message")) {
[11:02:53.906]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:53.906]                         if (muffled) 
[11:02:53.906]                           invokeRestart("muffleMessage")
[11:02:53.906]                       }
[11:02:53.906]                       else if (inherits(cond, "warning")) {
[11:02:53.906]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:53.906]                         if (muffled) 
[11:02:53.906]                           invokeRestart("muffleWarning")
[11:02:53.906]                       }
[11:02:53.906]                       else if (inherits(cond, "condition")) {
[11:02:53.906]                         if (!is.null(pattern)) {
[11:02:53.906]                           computeRestarts <- base::computeRestarts
[11:02:53.906]                           grepl <- base::grepl
[11:02:53.906]                           restarts <- computeRestarts(cond)
[11:02:53.906]                           for (restart in restarts) {
[11:02:53.906]                             name <- restart$name
[11:02:53.906]                             if (is.null(name)) 
[11:02:53.906]                               next
[11:02:53.906]                             if (!grepl(pattern, name)) 
[11:02:53.906]                               next
[11:02:53.906]                             invokeRestart(restart)
[11:02:53.906]                             muffled <- TRUE
[11:02:53.906]                             break
[11:02:53.906]                           }
[11:02:53.906]                         }
[11:02:53.906]                       }
[11:02:53.906]                       invisible(muffled)
[11:02:53.906]                     }
[11:02:53.906]                     muffleCondition(cond, pattern = "^muffle")
[11:02:53.906]                   }
[11:02:53.906]                 }
[11:02:53.906]             }
[11:02:53.906]         }))
[11:02:53.906]     }, error = function(ex) {
[11:02:53.906]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:53.906]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:53.906]                 ...future.rng), started = ...future.startTime, 
[11:02:53.906]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:53.906]             version = "1.8"), class = "FutureResult")
[11:02:53.906]     }, finally = {
[11:02:53.906]         if (!identical(...future.workdir, getwd())) 
[11:02:53.906]             setwd(...future.workdir)
[11:02:53.906]         {
[11:02:53.906]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:53.906]                 ...future.oldOptions$nwarnings <- NULL
[11:02:53.906]             }
[11:02:53.906]             base::options(...future.oldOptions)
[11:02:53.906]             if (.Platform$OS.type == "windows") {
[11:02:53.906]                 old_names <- names(...future.oldEnvVars)
[11:02:53.906]                 envs <- base::Sys.getenv()
[11:02:53.906]                 names <- names(envs)
[11:02:53.906]                 common <- intersect(names, old_names)
[11:02:53.906]                 added <- setdiff(names, old_names)
[11:02:53.906]                 removed <- setdiff(old_names, names)
[11:02:53.906]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:53.906]                   envs[common]]
[11:02:53.906]                 NAMES <- toupper(changed)
[11:02:53.906]                 args <- list()
[11:02:53.906]                 for (kk in seq_along(NAMES)) {
[11:02:53.906]                   name <- changed[[kk]]
[11:02:53.906]                   NAME <- NAMES[[kk]]
[11:02:53.906]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:53.906]                     next
[11:02:53.906]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:53.906]                 }
[11:02:53.906]                 NAMES <- toupper(added)
[11:02:53.906]                 for (kk in seq_along(NAMES)) {
[11:02:53.906]                   name <- added[[kk]]
[11:02:53.906]                   NAME <- NAMES[[kk]]
[11:02:53.906]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:53.906]                     next
[11:02:53.906]                   args[[name]] <- ""
[11:02:53.906]                 }
[11:02:53.906]                 NAMES <- toupper(removed)
[11:02:53.906]                 for (kk in seq_along(NAMES)) {
[11:02:53.906]                   name <- removed[[kk]]
[11:02:53.906]                   NAME <- NAMES[[kk]]
[11:02:53.906]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:53.906]                     next
[11:02:53.906]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:53.906]                 }
[11:02:53.906]                 if (length(args) > 0) 
[11:02:53.906]                   base::do.call(base::Sys.setenv, args = args)
[11:02:53.906]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:53.906]             }
[11:02:53.906]             else {
[11:02:53.906]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:53.906]             }
[11:02:53.906]             {
[11:02:53.906]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:53.906]                   0L) {
[11:02:53.906]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:53.906]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:53.906]                   base::options(opts)
[11:02:53.906]                 }
[11:02:53.906]                 {
[11:02:53.906]                   {
[11:02:53.906]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:53.906]                     NULL
[11:02:53.906]                   }
[11:02:53.906]                   options(future.plan = NULL)
[11:02:53.906]                   if (is.na(NA_character_)) 
[11:02:53.906]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:53.906]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:53.906]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:53.906]                     .init = FALSE)
[11:02:53.906]                 }
[11:02:53.906]             }
[11:02:53.906]         }
[11:02:53.906]     })
[11:02:53.906]     if (TRUE) {
[11:02:53.906]         base::sink(type = "output", split = FALSE)
[11:02:53.906]         if (TRUE) {
[11:02:53.906]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:53.906]         }
[11:02:53.906]         else {
[11:02:53.906]             ...future.result["stdout"] <- base::list(NULL)
[11:02:53.906]         }
[11:02:53.906]         base::close(...future.stdout)
[11:02:53.906]         ...future.stdout <- NULL
[11:02:53.906]     }
[11:02:53.906]     ...future.result$conditions <- ...future.conditions
[11:02:53.906]     ...future.result$finished <- base::Sys.time()
[11:02:53.906]     ...future.result
[11:02:53.906] }
[11:02:53.909] MultisessionFuture started
[11:02:53.909] - Launch lazy future ... done
[11:02:53.909] run() for ‘MultisessionFuture’ ... done
[11:02:53.951] receiveMessageFromWorker() for ClusterFuture ...
[11:02:53.951] - Validating connection of MultisessionFuture
[11:02:53.952] - received message: FutureResult
[11:02:53.952] - Received FutureResult
[11:02:53.952] - Erased future from FutureRegistry
[11:02:53.952] result() for ClusterFuture ...
[11:02:53.952] - result already collected: FutureResult
[11:02:53.952] result() for ClusterFuture ... done
[11:02:53.952] signalConditions() ...
[11:02:53.952]  - include = ‘immediateCondition’
[11:02:53.952]  - exclude = 
[11:02:53.952]  - resignal = FALSE
[11:02:53.952]  - Number of conditions: 1
[11:02:53.953] signalConditions() ... done
[11:02:53.953] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:53.953] A MultisessionFuture was resolved (and resolved itself)
- result = TRUE, recursive = 1 ... DONE
- result = TRUE, recursive = 2 ...
[11:02:53.953] getGlobalsAndPackages() ...
[11:02:53.953] Searching for globals...
[11:02:53.954] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[11:02:53.954] Searching for globals ... DONE
[11:02:53.954] Resolving globals: FALSE
[11:02:53.955] 
[11:02:53.955] 
[11:02:53.955] getGlobalsAndPackages() ... DONE
[11:02:53.955] run() for ‘Future’ ...
[11:02:53.955] - state: ‘created’
[11:02:53.955] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:53.969] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:53.969] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:53.969]   - Field: ‘node’
[11:02:53.969]   - Field: ‘label’
[11:02:53.969]   - Field: ‘local’
[11:02:53.969]   - Field: ‘owner’
[11:02:53.969]   - Field: ‘envir’
[11:02:53.969]   - Field: ‘workers’
[11:02:53.970]   - Field: ‘packages’
[11:02:53.970]   - Field: ‘gc’
[11:02:53.970]   - Field: ‘conditions’
[11:02:53.970]   - Field: ‘persistent’
[11:02:53.970]   - Field: ‘expr’
[11:02:53.970]   - Field: ‘uuid’
[11:02:53.970]   - Field: ‘seed’
[11:02:53.970]   - Field: ‘version’
[11:02:53.970]   - Field: ‘result’
[11:02:53.970]   - Field: ‘asynchronous’
[11:02:53.970]   - Field: ‘calls’
[11:02:53.970]   - Field: ‘globals’
[11:02:53.971]   - Field: ‘stdout’
[11:02:53.971]   - Field: ‘earlySignal’
[11:02:53.971]   - Field: ‘lazy’
[11:02:53.971]   - Field: ‘state’
[11:02:53.971] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:53.971] - Launch lazy future ...
[11:02:53.971] Packages needed by the future expression (n = 0): <none>
[11:02:53.971] Packages needed by future strategies (n = 0): <none>
[11:02:53.972] {
[11:02:53.972]     {
[11:02:53.972]         {
[11:02:53.972]             ...future.startTime <- base::Sys.time()
[11:02:53.972]             {
[11:02:53.972]                 {
[11:02:53.972]                   {
[11:02:53.972]                     {
[11:02:53.972]                       base::local({
[11:02:53.972]                         has_future <- base::requireNamespace("future", 
[11:02:53.972]                           quietly = TRUE)
[11:02:53.972]                         if (has_future) {
[11:02:53.972]                           ns <- base::getNamespace("future")
[11:02:53.972]                           version <- ns[[".package"]][["version"]]
[11:02:53.972]                           if (is.null(version)) 
[11:02:53.972]                             version <- utils::packageVersion("future")
[11:02:53.972]                         }
[11:02:53.972]                         else {
[11:02:53.972]                           version <- NULL
[11:02:53.972]                         }
[11:02:53.972]                         if (!has_future || version < "1.8.0") {
[11:02:53.972]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:53.972]                             "", base::R.version$version.string), 
[11:02:53.972]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:53.972]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:53.972]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:53.972]                               "release", "version")], collapse = " "), 
[11:02:53.972]                             hostname = base::Sys.info()[["nodename"]])
[11:02:53.972]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:53.972]                             info)
[11:02:53.972]                           info <- base::paste(info, collapse = "; ")
[11:02:53.972]                           if (!has_future) {
[11:02:53.972]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:53.972]                               info)
[11:02:53.972]                           }
[11:02:53.972]                           else {
[11:02:53.972]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:53.972]                               info, version)
[11:02:53.972]                           }
[11:02:53.972]                           base::stop(msg)
[11:02:53.972]                         }
[11:02:53.972]                       })
[11:02:53.972]                     }
[11:02:53.972]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:53.972]                     base::options(mc.cores = 1L)
[11:02:53.972]                   }
[11:02:53.972]                   ...future.strategy.old <- future::plan("list")
[11:02:53.972]                   options(future.plan = NULL)
[11:02:53.972]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:53.972]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:53.972]                 }
[11:02:53.972]                 ...future.workdir <- getwd()
[11:02:53.972]             }
[11:02:53.972]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:53.972]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:53.972]         }
[11:02:53.972]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:53.972]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:53.972]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:53.972]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:53.972]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:53.972]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:53.972]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:53.972]             base::names(...future.oldOptions))
[11:02:53.972]     }
[11:02:53.972]     if (FALSE) {
[11:02:53.972]     }
[11:02:53.972]     else {
[11:02:53.972]         if (TRUE) {
[11:02:53.972]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:53.972]                 open = "w")
[11:02:53.972]         }
[11:02:53.972]         else {
[11:02:53.972]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:53.972]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:53.972]         }
[11:02:53.972]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:53.972]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:53.972]             base::sink(type = "output", split = FALSE)
[11:02:53.972]             base::close(...future.stdout)
[11:02:53.972]         }, add = TRUE)
[11:02:53.972]     }
[11:02:53.972]     ...future.frame <- base::sys.nframe()
[11:02:53.972]     ...future.conditions <- base::list()
[11:02:53.972]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:53.972]     if (FALSE) {
[11:02:53.972]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:53.972]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:53.972]     }
[11:02:53.972]     ...future.result <- base::tryCatch({
[11:02:53.972]         base::withCallingHandlers({
[11:02:53.972]             ...future.value <- base::withVisible(base::local({
[11:02:53.972]                 ...future.makeSendCondition <- base::local({
[11:02:53.972]                   sendCondition <- NULL
[11:02:53.972]                   function(frame = 1L) {
[11:02:53.972]                     if (is.function(sendCondition)) 
[11:02:53.972]                       return(sendCondition)
[11:02:53.972]                     ns <- getNamespace("parallel")
[11:02:53.972]                     if (exists("sendData", mode = "function", 
[11:02:53.972]                       envir = ns)) {
[11:02:53.972]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:53.972]                         envir = ns)
[11:02:53.972]                       envir <- sys.frame(frame)
[11:02:53.972]                       master <- NULL
[11:02:53.972]                       while (!identical(envir, .GlobalEnv) && 
[11:02:53.972]                         !identical(envir, emptyenv())) {
[11:02:53.972]                         if (exists("master", mode = "list", envir = envir, 
[11:02:53.972]                           inherits = FALSE)) {
[11:02:53.972]                           master <- get("master", mode = "list", 
[11:02:53.972]                             envir = envir, inherits = FALSE)
[11:02:53.972]                           if (inherits(master, c("SOCKnode", 
[11:02:53.972]                             "SOCK0node"))) {
[11:02:53.972]                             sendCondition <<- function(cond) {
[11:02:53.972]                               data <- list(type = "VALUE", value = cond, 
[11:02:53.972]                                 success = TRUE)
[11:02:53.972]                               parallel_sendData(master, data)
[11:02:53.972]                             }
[11:02:53.972]                             return(sendCondition)
[11:02:53.972]                           }
[11:02:53.972]                         }
[11:02:53.972]                         frame <- frame + 1L
[11:02:53.972]                         envir <- sys.frame(frame)
[11:02:53.972]                       }
[11:02:53.972]                     }
[11:02:53.972]                     sendCondition <<- function(cond) NULL
[11:02:53.972]                   }
[11:02:53.972]                 })
[11:02:53.972]                 withCallingHandlers({
[11:02:53.972]                   {
[11:02:53.972]                     Sys.sleep(0.5)
[11:02:53.972]                     list(a = 1, b = 42L)
[11:02:53.972]                   }
[11:02:53.972]                 }, immediateCondition = function(cond) {
[11:02:53.972]                   sendCondition <- ...future.makeSendCondition()
[11:02:53.972]                   sendCondition(cond)
[11:02:53.972]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:53.972]                   {
[11:02:53.972]                     inherits <- base::inherits
[11:02:53.972]                     invokeRestart <- base::invokeRestart
[11:02:53.972]                     is.null <- base::is.null
[11:02:53.972]                     muffled <- FALSE
[11:02:53.972]                     if (inherits(cond, "message")) {
[11:02:53.972]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:53.972]                       if (muffled) 
[11:02:53.972]                         invokeRestart("muffleMessage")
[11:02:53.972]                     }
[11:02:53.972]                     else if (inherits(cond, "warning")) {
[11:02:53.972]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:53.972]                       if (muffled) 
[11:02:53.972]                         invokeRestart("muffleWarning")
[11:02:53.972]                     }
[11:02:53.972]                     else if (inherits(cond, "condition")) {
[11:02:53.972]                       if (!is.null(pattern)) {
[11:02:53.972]                         computeRestarts <- base::computeRestarts
[11:02:53.972]                         grepl <- base::grepl
[11:02:53.972]                         restarts <- computeRestarts(cond)
[11:02:53.972]                         for (restart in restarts) {
[11:02:53.972]                           name <- restart$name
[11:02:53.972]                           if (is.null(name)) 
[11:02:53.972]                             next
[11:02:53.972]                           if (!grepl(pattern, name)) 
[11:02:53.972]                             next
[11:02:53.972]                           invokeRestart(restart)
[11:02:53.972]                           muffled <- TRUE
[11:02:53.972]                           break
[11:02:53.972]                         }
[11:02:53.972]                       }
[11:02:53.972]                     }
[11:02:53.972]                     invisible(muffled)
[11:02:53.972]                   }
[11:02:53.972]                   muffleCondition(cond)
[11:02:53.972]                 })
[11:02:53.972]             }))
[11:02:53.972]             future::FutureResult(value = ...future.value$value, 
[11:02:53.972]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:53.972]                   ...future.rng), globalenv = if (FALSE) 
[11:02:53.972]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:53.972]                     ...future.globalenv.names))
[11:02:53.972]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:53.972]         }, condition = base::local({
[11:02:53.972]             c <- base::c
[11:02:53.972]             inherits <- base::inherits
[11:02:53.972]             invokeRestart <- base::invokeRestart
[11:02:53.972]             length <- base::length
[11:02:53.972]             list <- base::list
[11:02:53.972]             seq.int <- base::seq.int
[11:02:53.972]             signalCondition <- base::signalCondition
[11:02:53.972]             sys.calls <- base::sys.calls
[11:02:53.972]             `[[` <- base::`[[`
[11:02:53.972]             `+` <- base::`+`
[11:02:53.972]             `<<-` <- base::`<<-`
[11:02:53.972]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:53.972]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:53.972]                   3L)]
[11:02:53.972]             }
[11:02:53.972]             function(cond) {
[11:02:53.972]                 is_error <- inherits(cond, "error")
[11:02:53.972]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:53.972]                   NULL)
[11:02:53.972]                 if (is_error) {
[11:02:53.972]                   sessionInformation <- function() {
[11:02:53.972]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:53.972]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:53.972]                       search = base::search(), system = base::Sys.info())
[11:02:53.972]                   }
[11:02:53.972]                   ...future.conditions[[length(...future.conditions) + 
[11:02:53.972]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:53.972]                     cond$call), session = sessionInformation(), 
[11:02:53.972]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:53.972]                   signalCondition(cond)
[11:02:53.972]                 }
[11:02:53.972]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:53.972]                 "immediateCondition"))) {
[11:02:53.972]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:53.972]                   ...future.conditions[[length(...future.conditions) + 
[11:02:53.972]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:53.972]                   if (TRUE && !signal) {
[11:02:53.972]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:53.972]                     {
[11:02:53.972]                       inherits <- base::inherits
[11:02:53.972]                       invokeRestart <- base::invokeRestart
[11:02:53.972]                       is.null <- base::is.null
[11:02:53.972]                       muffled <- FALSE
[11:02:53.972]                       if (inherits(cond, "message")) {
[11:02:53.972]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:53.972]                         if (muffled) 
[11:02:53.972]                           invokeRestart("muffleMessage")
[11:02:53.972]                       }
[11:02:53.972]                       else if (inherits(cond, "warning")) {
[11:02:53.972]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:53.972]                         if (muffled) 
[11:02:53.972]                           invokeRestart("muffleWarning")
[11:02:53.972]                       }
[11:02:53.972]                       else if (inherits(cond, "condition")) {
[11:02:53.972]                         if (!is.null(pattern)) {
[11:02:53.972]                           computeRestarts <- base::computeRestarts
[11:02:53.972]                           grepl <- base::grepl
[11:02:53.972]                           restarts <- computeRestarts(cond)
[11:02:53.972]                           for (restart in restarts) {
[11:02:53.972]                             name <- restart$name
[11:02:53.972]                             if (is.null(name)) 
[11:02:53.972]                               next
[11:02:53.972]                             if (!grepl(pattern, name)) 
[11:02:53.972]                               next
[11:02:53.972]                             invokeRestart(restart)
[11:02:53.972]                             muffled <- TRUE
[11:02:53.972]                             break
[11:02:53.972]                           }
[11:02:53.972]                         }
[11:02:53.972]                       }
[11:02:53.972]                       invisible(muffled)
[11:02:53.972]                     }
[11:02:53.972]                     muffleCondition(cond, pattern = "^muffle")
[11:02:53.972]                   }
[11:02:53.972]                 }
[11:02:53.972]                 else {
[11:02:53.972]                   if (TRUE) {
[11:02:53.972]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:53.972]                     {
[11:02:53.972]                       inherits <- base::inherits
[11:02:53.972]                       invokeRestart <- base::invokeRestart
[11:02:53.972]                       is.null <- base::is.null
[11:02:53.972]                       muffled <- FALSE
[11:02:53.972]                       if (inherits(cond, "message")) {
[11:02:53.972]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:53.972]                         if (muffled) 
[11:02:53.972]                           invokeRestart("muffleMessage")
[11:02:53.972]                       }
[11:02:53.972]                       else if (inherits(cond, "warning")) {
[11:02:53.972]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:53.972]                         if (muffled) 
[11:02:53.972]                           invokeRestart("muffleWarning")
[11:02:53.972]                       }
[11:02:53.972]                       else if (inherits(cond, "condition")) {
[11:02:53.972]                         if (!is.null(pattern)) {
[11:02:53.972]                           computeRestarts <- base::computeRestarts
[11:02:53.972]                           grepl <- base::grepl
[11:02:53.972]                           restarts <- computeRestarts(cond)
[11:02:53.972]                           for (restart in restarts) {
[11:02:53.972]                             name <- restart$name
[11:02:53.972]                             if (is.null(name)) 
[11:02:53.972]                               next
[11:02:53.972]                             if (!grepl(pattern, name)) 
[11:02:53.972]                               next
[11:02:53.972]                             invokeRestart(restart)
[11:02:53.972]                             muffled <- TRUE
[11:02:53.972]                             break
[11:02:53.972]                           }
[11:02:53.972]                         }
[11:02:53.972]                       }
[11:02:53.972]                       invisible(muffled)
[11:02:53.972]                     }
[11:02:53.972]                     muffleCondition(cond, pattern = "^muffle")
[11:02:53.972]                   }
[11:02:53.972]                 }
[11:02:53.972]             }
[11:02:53.972]         }))
[11:02:53.972]     }, error = function(ex) {
[11:02:53.972]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:53.972]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:53.972]                 ...future.rng), started = ...future.startTime, 
[11:02:53.972]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:53.972]             version = "1.8"), class = "FutureResult")
[11:02:53.972]     }, finally = {
[11:02:53.972]         if (!identical(...future.workdir, getwd())) 
[11:02:53.972]             setwd(...future.workdir)
[11:02:53.972]         {
[11:02:53.972]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:53.972]                 ...future.oldOptions$nwarnings <- NULL
[11:02:53.972]             }
[11:02:53.972]             base::options(...future.oldOptions)
[11:02:53.972]             if (.Platform$OS.type == "windows") {
[11:02:53.972]                 old_names <- names(...future.oldEnvVars)
[11:02:53.972]                 envs <- base::Sys.getenv()
[11:02:53.972]                 names <- names(envs)
[11:02:53.972]                 common <- intersect(names, old_names)
[11:02:53.972]                 added <- setdiff(names, old_names)
[11:02:53.972]                 removed <- setdiff(old_names, names)
[11:02:53.972]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:53.972]                   envs[common]]
[11:02:53.972]                 NAMES <- toupper(changed)
[11:02:53.972]                 args <- list()
[11:02:53.972]                 for (kk in seq_along(NAMES)) {
[11:02:53.972]                   name <- changed[[kk]]
[11:02:53.972]                   NAME <- NAMES[[kk]]
[11:02:53.972]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:53.972]                     next
[11:02:53.972]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:53.972]                 }
[11:02:53.972]                 NAMES <- toupper(added)
[11:02:53.972]                 for (kk in seq_along(NAMES)) {
[11:02:53.972]                   name <- added[[kk]]
[11:02:53.972]                   NAME <- NAMES[[kk]]
[11:02:53.972]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:53.972]                     next
[11:02:53.972]                   args[[name]] <- ""
[11:02:53.972]                 }
[11:02:53.972]                 NAMES <- toupper(removed)
[11:02:53.972]                 for (kk in seq_along(NAMES)) {
[11:02:53.972]                   name <- removed[[kk]]
[11:02:53.972]                   NAME <- NAMES[[kk]]
[11:02:53.972]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:53.972]                     next
[11:02:53.972]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:53.972]                 }
[11:02:53.972]                 if (length(args) > 0) 
[11:02:53.972]                   base::do.call(base::Sys.setenv, args = args)
[11:02:53.972]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:53.972]             }
[11:02:53.972]             else {
[11:02:53.972]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:53.972]             }
[11:02:53.972]             {
[11:02:53.972]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:53.972]                   0L) {
[11:02:53.972]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:53.972]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:53.972]                   base::options(opts)
[11:02:53.972]                 }
[11:02:53.972]                 {
[11:02:53.972]                   {
[11:02:53.972]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:53.972]                     NULL
[11:02:53.972]                   }
[11:02:53.972]                   options(future.plan = NULL)
[11:02:53.972]                   if (is.na(NA_character_)) 
[11:02:53.972]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:53.972]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:53.972]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:53.972]                     .init = FALSE)
[11:02:53.972]                 }
[11:02:53.972]             }
[11:02:53.972]         }
[11:02:53.972]     })
[11:02:53.972]     if (TRUE) {
[11:02:53.972]         base::sink(type = "output", split = FALSE)
[11:02:53.972]         if (TRUE) {
[11:02:53.972]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:53.972]         }
[11:02:53.972]         else {
[11:02:53.972]             ...future.result["stdout"] <- base::list(NULL)
[11:02:53.972]         }
[11:02:53.972]         base::close(...future.stdout)
[11:02:53.972]         ...future.stdout <- NULL
[11:02:53.972]     }
[11:02:53.972]     ...future.result$conditions <- ...future.conditions
[11:02:53.972]     ...future.result$finished <- base::Sys.time()
[11:02:53.972]     ...future.result
[11:02:53.972] }
[11:02:53.975] MultisessionFuture started
[11:02:53.975] - Launch lazy future ... done
[11:02:53.975] run() for ‘MultisessionFuture’ ... done
[11:02:54.518] receiveMessageFromWorker() for ClusterFuture ...
[11:02:54.518] - Validating connection of MultisessionFuture
[11:02:54.518] - received message: FutureResult
[11:02:54.518] - Received FutureResult
[11:02:54.518] - Erased future from FutureRegistry
[11:02:54.518] result() for ClusterFuture ...
[11:02:54.519] - result already collected: FutureResult
[11:02:54.519] result() for ClusterFuture ... done
[11:02:54.519] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:54.519] resolve() on list ...
[11:02:54.519]  recursive: 1
[11:02:54.519]  length: 2
[11:02:54.519]  elements: ‘a’, ‘b’
[11:02:54.519]  length: 1 (resolved future 1)
[11:02:54.519]  length: 0 (resolved future 2)
[11:02:54.519] resolve() on list ... DONE
[11:02:54.519] A MultisessionFuture was resolved (and resolved itself)
[11:02:54.520] getGlobalsAndPackages() ...
[11:02:54.520] Searching for globals...
[11:02:54.521] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[11:02:54.521] Searching for globals ... DONE
[11:02:54.521] Resolving globals: FALSE
[11:02:54.521] 
[11:02:54.521] 
[11:02:54.521] getGlobalsAndPackages() ... DONE
[11:02:54.522] run() for ‘Future’ ...
[11:02:54.522] - state: ‘created’
[11:02:54.522] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:54.536] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:54.536] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:54.536]   - Field: ‘node’
[11:02:54.536]   - Field: ‘label’
[11:02:54.536]   - Field: ‘local’
[11:02:54.536]   - Field: ‘owner’
[11:02:54.536]   - Field: ‘envir’
[11:02:54.536]   - Field: ‘workers’
[11:02:54.536]   - Field: ‘packages’
[11:02:54.536]   - Field: ‘gc’
[11:02:54.537]   - Field: ‘conditions’
[11:02:54.537]   - Field: ‘persistent’
[11:02:54.537]   - Field: ‘expr’
[11:02:54.537]   - Field: ‘uuid’
[11:02:54.537]   - Field: ‘seed’
[11:02:54.537]   - Field: ‘version’
[11:02:54.537]   - Field: ‘result’
[11:02:54.537]   - Field: ‘asynchronous’
[11:02:54.537]   - Field: ‘calls’
[11:02:54.537]   - Field: ‘globals’
[11:02:54.537]   - Field: ‘stdout’
[11:02:54.537]   - Field: ‘earlySignal’
[11:02:54.538]   - Field: ‘lazy’
[11:02:54.538]   - Field: ‘state’
[11:02:54.538] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:54.538] - Launch lazy future ...
[11:02:54.538] Packages needed by the future expression (n = 0): <none>
[11:02:54.538] Packages needed by future strategies (n = 0): <none>
[11:02:54.539] {
[11:02:54.539]     {
[11:02:54.539]         {
[11:02:54.539]             ...future.startTime <- base::Sys.time()
[11:02:54.539]             {
[11:02:54.539]                 {
[11:02:54.539]                   {
[11:02:54.539]                     {
[11:02:54.539]                       base::local({
[11:02:54.539]                         has_future <- base::requireNamespace("future", 
[11:02:54.539]                           quietly = TRUE)
[11:02:54.539]                         if (has_future) {
[11:02:54.539]                           ns <- base::getNamespace("future")
[11:02:54.539]                           version <- ns[[".package"]][["version"]]
[11:02:54.539]                           if (is.null(version)) 
[11:02:54.539]                             version <- utils::packageVersion("future")
[11:02:54.539]                         }
[11:02:54.539]                         else {
[11:02:54.539]                           version <- NULL
[11:02:54.539]                         }
[11:02:54.539]                         if (!has_future || version < "1.8.0") {
[11:02:54.539]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:54.539]                             "", base::R.version$version.string), 
[11:02:54.539]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:54.539]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:54.539]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:54.539]                               "release", "version")], collapse = " "), 
[11:02:54.539]                             hostname = base::Sys.info()[["nodename"]])
[11:02:54.539]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:54.539]                             info)
[11:02:54.539]                           info <- base::paste(info, collapse = "; ")
[11:02:54.539]                           if (!has_future) {
[11:02:54.539]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:54.539]                               info)
[11:02:54.539]                           }
[11:02:54.539]                           else {
[11:02:54.539]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:54.539]                               info, version)
[11:02:54.539]                           }
[11:02:54.539]                           base::stop(msg)
[11:02:54.539]                         }
[11:02:54.539]                       })
[11:02:54.539]                     }
[11:02:54.539]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:54.539]                     base::options(mc.cores = 1L)
[11:02:54.539]                   }
[11:02:54.539]                   ...future.strategy.old <- future::plan("list")
[11:02:54.539]                   options(future.plan = NULL)
[11:02:54.539]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:54.539]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:54.539]                 }
[11:02:54.539]                 ...future.workdir <- getwd()
[11:02:54.539]             }
[11:02:54.539]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:54.539]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:54.539]         }
[11:02:54.539]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:54.539]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:54.539]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:54.539]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:54.539]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:54.539]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:54.539]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:54.539]             base::names(...future.oldOptions))
[11:02:54.539]     }
[11:02:54.539]     if (FALSE) {
[11:02:54.539]     }
[11:02:54.539]     else {
[11:02:54.539]         if (TRUE) {
[11:02:54.539]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:54.539]                 open = "w")
[11:02:54.539]         }
[11:02:54.539]         else {
[11:02:54.539]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:54.539]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:54.539]         }
[11:02:54.539]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:54.539]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:54.539]             base::sink(type = "output", split = FALSE)
[11:02:54.539]             base::close(...future.stdout)
[11:02:54.539]         }, add = TRUE)
[11:02:54.539]     }
[11:02:54.539]     ...future.frame <- base::sys.nframe()
[11:02:54.539]     ...future.conditions <- base::list()
[11:02:54.539]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:54.539]     if (FALSE) {
[11:02:54.539]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:54.539]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:54.539]     }
[11:02:54.539]     ...future.result <- base::tryCatch({
[11:02:54.539]         base::withCallingHandlers({
[11:02:54.539]             ...future.value <- base::withVisible(base::local({
[11:02:54.539]                 ...future.makeSendCondition <- base::local({
[11:02:54.539]                   sendCondition <- NULL
[11:02:54.539]                   function(frame = 1L) {
[11:02:54.539]                     if (is.function(sendCondition)) 
[11:02:54.539]                       return(sendCondition)
[11:02:54.539]                     ns <- getNamespace("parallel")
[11:02:54.539]                     if (exists("sendData", mode = "function", 
[11:02:54.539]                       envir = ns)) {
[11:02:54.539]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:54.539]                         envir = ns)
[11:02:54.539]                       envir <- sys.frame(frame)
[11:02:54.539]                       master <- NULL
[11:02:54.539]                       while (!identical(envir, .GlobalEnv) && 
[11:02:54.539]                         !identical(envir, emptyenv())) {
[11:02:54.539]                         if (exists("master", mode = "list", envir = envir, 
[11:02:54.539]                           inherits = FALSE)) {
[11:02:54.539]                           master <- get("master", mode = "list", 
[11:02:54.539]                             envir = envir, inherits = FALSE)
[11:02:54.539]                           if (inherits(master, c("SOCKnode", 
[11:02:54.539]                             "SOCK0node"))) {
[11:02:54.539]                             sendCondition <<- function(cond) {
[11:02:54.539]                               data <- list(type = "VALUE", value = cond, 
[11:02:54.539]                                 success = TRUE)
[11:02:54.539]                               parallel_sendData(master, data)
[11:02:54.539]                             }
[11:02:54.539]                             return(sendCondition)
[11:02:54.539]                           }
[11:02:54.539]                         }
[11:02:54.539]                         frame <- frame + 1L
[11:02:54.539]                         envir <- sys.frame(frame)
[11:02:54.539]                       }
[11:02:54.539]                     }
[11:02:54.539]                     sendCondition <<- function(cond) NULL
[11:02:54.539]                   }
[11:02:54.539]                 })
[11:02:54.539]                 withCallingHandlers({
[11:02:54.539]                   {
[11:02:54.539]                     Sys.sleep(0.5)
[11:02:54.539]                     list(a = 1, b = 42L)
[11:02:54.539]                   }
[11:02:54.539]                 }, immediateCondition = function(cond) {
[11:02:54.539]                   sendCondition <- ...future.makeSendCondition()
[11:02:54.539]                   sendCondition(cond)
[11:02:54.539]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:54.539]                   {
[11:02:54.539]                     inherits <- base::inherits
[11:02:54.539]                     invokeRestart <- base::invokeRestart
[11:02:54.539]                     is.null <- base::is.null
[11:02:54.539]                     muffled <- FALSE
[11:02:54.539]                     if (inherits(cond, "message")) {
[11:02:54.539]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:54.539]                       if (muffled) 
[11:02:54.539]                         invokeRestart("muffleMessage")
[11:02:54.539]                     }
[11:02:54.539]                     else if (inherits(cond, "warning")) {
[11:02:54.539]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:54.539]                       if (muffled) 
[11:02:54.539]                         invokeRestart("muffleWarning")
[11:02:54.539]                     }
[11:02:54.539]                     else if (inherits(cond, "condition")) {
[11:02:54.539]                       if (!is.null(pattern)) {
[11:02:54.539]                         computeRestarts <- base::computeRestarts
[11:02:54.539]                         grepl <- base::grepl
[11:02:54.539]                         restarts <- computeRestarts(cond)
[11:02:54.539]                         for (restart in restarts) {
[11:02:54.539]                           name <- restart$name
[11:02:54.539]                           if (is.null(name)) 
[11:02:54.539]                             next
[11:02:54.539]                           if (!grepl(pattern, name)) 
[11:02:54.539]                             next
[11:02:54.539]                           invokeRestart(restart)
[11:02:54.539]                           muffled <- TRUE
[11:02:54.539]                           break
[11:02:54.539]                         }
[11:02:54.539]                       }
[11:02:54.539]                     }
[11:02:54.539]                     invisible(muffled)
[11:02:54.539]                   }
[11:02:54.539]                   muffleCondition(cond)
[11:02:54.539]                 })
[11:02:54.539]             }))
[11:02:54.539]             future::FutureResult(value = ...future.value$value, 
[11:02:54.539]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:54.539]                   ...future.rng), globalenv = if (FALSE) 
[11:02:54.539]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:54.539]                     ...future.globalenv.names))
[11:02:54.539]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:54.539]         }, condition = base::local({
[11:02:54.539]             c <- base::c
[11:02:54.539]             inherits <- base::inherits
[11:02:54.539]             invokeRestart <- base::invokeRestart
[11:02:54.539]             length <- base::length
[11:02:54.539]             list <- base::list
[11:02:54.539]             seq.int <- base::seq.int
[11:02:54.539]             signalCondition <- base::signalCondition
[11:02:54.539]             sys.calls <- base::sys.calls
[11:02:54.539]             `[[` <- base::`[[`
[11:02:54.539]             `+` <- base::`+`
[11:02:54.539]             `<<-` <- base::`<<-`
[11:02:54.539]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:54.539]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:54.539]                   3L)]
[11:02:54.539]             }
[11:02:54.539]             function(cond) {
[11:02:54.539]                 is_error <- inherits(cond, "error")
[11:02:54.539]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:54.539]                   NULL)
[11:02:54.539]                 if (is_error) {
[11:02:54.539]                   sessionInformation <- function() {
[11:02:54.539]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:54.539]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:54.539]                       search = base::search(), system = base::Sys.info())
[11:02:54.539]                   }
[11:02:54.539]                   ...future.conditions[[length(...future.conditions) + 
[11:02:54.539]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:54.539]                     cond$call), session = sessionInformation(), 
[11:02:54.539]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:54.539]                   signalCondition(cond)
[11:02:54.539]                 }
[11:02:54.539]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:54.539]                 "immediateCondition"))) {
[11:02:54.539]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:54.539]                   ...future.conditions[[length(...future.conditions) + 
[11:02:54.539]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:54.539]                   if (TRUE && !signal) {
[11:02:54.539]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:54.539]                     {
[11:02:54.539]                       inherits <- base::inherits
[11:02:54.539]                       invokeRestart <- base::invokeRestart
[11:02:54.539]                       is.null <- base::is.null
[11:02:54.539]                       muffled <- FALSE
[11:02:54.539]                       if (inherits(cond, "message")) {
[11:02:54.539]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:54.539]                         if (muffled) 
[11:02:54.539]                           invokeRestart("muffleMessage")
[11:02:54.539]                       }
[11:02:54.539]                       else if (inherits(cond, "warning")) {
[11:02:54.539]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:54.539]                         if (muffled) 
[11:02:54.539]                           invokeRestart("muffleWarning")
[11:02:54.539]                       }
[11:02:54.539]                       else if (inherits(cond, "condition")) {
[11:02:54.539]                         if (!is.null(pattern)) {
[11:02:54.539]                           computeRestarts <- base::computeRestarts
[11:02:54.539]                           grepl <- base::grepl
[11:02:54.539]                           restarts <- computeRestarts(cond)
[11:02:54.539]                           for (restart in restarts) {
[11:02:54.539]                             name <- restart$name
[11:02:54.539]                             if (is.null(name)) 
[11:02:54.539]                               next
[11:02:54.539]                             if (!grepl(pattern, name)) 
[11:02:54.539]                               next
[11:02:54.539]                             invokeRestart(restart)
[11:02:54.539]                             muffled <- TRUE
[11:02:54.539]                             break
[11:02:54.539]                           }
[11:02:54.539]                         }
[11:02:54.539]                       }
[11:02:54.539]                       invisible(muffled)
[11:02:54.539]                     }
[11:02:54.539]                     muffleCondition(cond, pattern = "^muffle")
[11:02:54.539]                   }
[11:02:54.539]                 }
[11:02:54.539]                 else {
[11:02:54.539]                   if (TRUE) {
[11:02:54.539]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:54.539]                     {
[11:02:54.539]                       inherits <- base::inherits
[11:02:54.539]                       invokeRestart <- base::invokeRestart
[11:02:54.539]                       is.null <- base::is.null
[11:02:54.539]                       muffled <- FALSE
[11:02:54.539]                       if (inherits(cond, "message")) {
[11:02:54.539]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:54.539]                         if (muffled) 
[11:02:54.539]                           invokeRestart("muffleMessage")
[11:02:54.539]                       }
[11:02:54.539]                       else if (inherits(cond, "warning")) {
[11:02:54.539]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:54.539]                         if (muffled) 
[11:02:54.539]                           invokeRestart("muffleWarning")
[11:02:54.539]                       }
[11:02:54.539]                       else if (inherits(cond, "condition")) {
[11:02:54.539]                         if (!is.null(pattern)) {
[11:02:54.539]                           computeRestarts <- base::computeRestarts
[11:02:54.539]                           grepl <- base::grepl
[11:02:54.539]                           restarts <- computeRestarts(cond)
[11:02:54.539]                           for (restart in restarts) {
[11:02:54.539]                             name <- restart$name
[11:02:54.539]                             if (is.null(name)) 
[11:02:54.539]                               next
[11:02:54.539]                             if (!grepl(pattern, name)) 
[11:02:54.539]                               next
[11:02:54.539]                             invokeRestart(restart)
[11:02:54.539]                             muffled <- TRUE
[11:02:54.539]                             break
[11:02:54.539]                           }
[11:02:54.539]                         }
[11:02:54.539]                       }
[11:02:54.539]                       invisible(muffled)
[11:02:54.539]                     }
[11:02:54.539]                     muffleCondition(cond, pattern = "^muffle")
[11:02:54.539]                   }
[11:02:54.539]                 }
[11:02:54.539]             }
[11:02:54.539]         }))
[11:02:54.539]     }, error = function(ex) {
[11:02:54.539]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:54.539]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:54.539]                 ...future.rng), started = ...future.startTime, 
[11:02:54.539]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:54.539]             version = "1.8"), class = "FutureResult")
[11:02:54.539]     }, finally = {
[11:02:54.539]         if (!identical(...future.workdir, getwd())) 
[11:02:54.539]             setwd(...future.workdir)
[11:02:54.539]         {
[11:02:54.539]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:54.539]                 ...future.oldOptions$nwarnings <- NULL
[11:02:54.539]             }
[11:02:54.539]             base::options(...future.oldOptions)
[11:02:54.539]             if (.Platform$OS.type == "windows") {
[11:02:54.539]                 old_names <- names(...future.oldEnvVars)
[11:02:54.539]                 envs <- base::Sys.getenv()
[11:02:54.539]                 names <- names(envs)
[11:02:54.539]                 common <- intersect(names, old_names)
[11:02:54.539]                 added <- setdiff(names, old_names)
[11:02:54.539]                 removed <- setdiff(old_names, names)
[11:02:54.539]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:54.539]                   envs[common]]
[11:02:54.539]                 NAMES <- toupper(changed)
[11:02:54.539]                 args <- list()
[11:02:54.539]                 for (kk in seq_along(NAMES)) {
[11:02:54.539]                   name <- changed[[kk]]
[11:02:54.539]                   NAME <- NAMES[[kk]]
[11:02:54.539]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:54.539]                     next
[11:02:54.539]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:54.539]                 }
[11:02:54.539]                 NAMES <- toupper(added)
[11:02:54.539]                 for (kk in seq_along(NAMES)) {
[11:02:54.539]                   name <- added[[kk]]
[11:02:54.539]                   NAME <- NAMES[[kk]]
[11:02:54.539]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:54.539]                     next
[11:02:54.539]                   args[[name]] <- ""
[11:02:54.539]                 }
[11:02:54.539]                 NAMES <- toupper(removed)
[11:02:54.539]                 for (kk in seq_along(NAMES)) {
[11:02:54.539]                   name <- removed[[kk]]
[11:02:54.539]                   NAME <- NAMES[[kk]]
[11:02:54.539]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:54.539]                     next
[11:02:54.539]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:54.539]                 }
[11:02:54.539]                 if (length(args) > 0) 
[11:02:54.539]                   base::do.call(base::Sys.setenv, args = args)
[11:02:54.539]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:54.539]             }
[11:02:54.539]             else {
[11:02:54.539]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:54.539]             }
[11:02:54.539]             {
[11:02:54.539]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:54.539]                   0L) {
[11:02:54.539]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:54.539]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:54.539]                   base::options(opts)
[11:02:54.539]                 }
[11:02:54.539]                 {
[11:02:54.539]                   {
[11:02:54.539]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:54.539]                     NULL
[11:02:54.539]                   }
[11:02:54.539]                   options(future.plan = NULL)
[11:02:54.539]                   if (is.na(NA_character_)) 
[11:02:54.539]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:54.539]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:54.539]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:54.539]                     .init = FALSE)
[11:02:54.539]                 }
[11:02:54.539]             }
[11:02:54.539]         }
[11:02:54.539]     })
[11:02:54.539]     if (TRUE) {
[11:02:54.539]         base::sink(type = "output", split = FALSE)
[11:02:54.539]         if (TRUE) {
[11:02:54.539]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:54.539]         }
[11:02:54.539]         else {
[11:02:54.539]             ...future.result["stdout"] <- base::list(NULL)
[11:02:54.539]         }
[11:02:54.539]         base::close(...future.stdout)
[11:02:54.539]         ...future.stdout <- NULL
[11:02:54.539]     }
[11:02:54.539]     ...future.result$conditions <- ...future.conditions
[11:02:54.539]     ...future.result$finished <- base::Sys.time()
[11:02:54.539]     ...future.result
[11:02:54.539] }
[11:02:54.542] MultisessionFuture started
[11:02:54.542] - Launch lazy future ... done
[11:02:54.542] run() for ‘MultisessionFuture’ ... done
[11:02:55.085] receiveMessageFromWorker() for ClusterFuture ...
[11:02:55.085] - Validating connection of MultisessionFuture
[11:02:55.085] - received message: FutureResult
[11:02:55.086] - Received FutureResult
[11:02:55.086] - Erased future from FutureRegistry
[11:02:55.086] result() for ClusterFuture ...
[11:02:55.086] - result already collected: FutureResult
[11:02:55.086] result() for ClusterFuture ... done
[11:02:55.086] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:55.086] resolve() on list ...
[11:02:55.086]  recursive: 1
[11:02:55.086]  length: 2
[11:02:55.087]  elements: ‘a’, ‘b’
[11:02:55.087]  length: 1 (resolved future 1)
[11:02:55.087]  length: 0 (resolved future 2)
[11:02:55.087] resolve() on list ... DONE
[11:02:55.087] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[11:02:55.087] getGlobalsAndPackages() ...
[11:02:55.087] Searching for globals...
[11:02:55.088] - globals found: [2] ‘list’, ‘stop’
[11:02:55.088] Searching for globals ... DONE
[11:02:55.088] Resolving globals: FALSE
[11:02:55.088] 
[11:02:55.088] 
[11:02:55.088] getGlobalsAndPackages() ... DONE
[11:02:55.089] run() for ‘Future’ ...
[11:02:55.089] - state: ‘created’
[11:02:55.089] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:55.103] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:55.103] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:55.103]   - Field: ‘node’
[11:02:55.103]   - Field: ‘label’
[11:02:55.103]   - Field: ‘local’
[11:02:55.103]   - Field: ‘owner’
[11:02:55.103]   - Field: ‘envir’
[11:02:55.103]   - Field: ‘workers’
[11:02:55.103]   - Field: ‘packages’
[11:02:55.103]   - Field: ‘gc’
[11:02:55.103]   - Field: ‘conditions’
[11:02:55.104]   - Field: ‘persistent’
[11:02:55.104]   - Field: ‘expr’
[11:02:55.104]   - Field: ‘uuid’
[11:02:55.104]   - Field: ‘seed’
[11:02:55.104]   - Field: ‘version’
[11:02:55.104]   - Field: ‘result’
[11:02:55.104]   - Field: ‘asynchronous’
[11:02:55.104]   - Field: ‘calls’
[11:02:55.104]   - Field: ‘globals’
[11:02:55.104]   - Field: ‘stdout’
[11:02:55.104]   - Field: ‘earlySignal’
[11:02:55.104]   - Field: ‘lazy’
[11:02:55.105]   - Field: ‘state’
[11:02:55.105] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:55.105] - Launch lazy future ...
[11:02:55.105] Packages needed by the future expression (n = 0): <none>
[11:02:55.105] Packages needed by future strategies (n = 0): <none>
[11:02:55.105] {
[11:02:55.105]     {
[11:02:55.105]         {
[11:02:55.105]             ...future.startTime <- base::Sys.time()
[11:02:55.105]             {
[11:02:55.105]                 {
[11:02:55.105]                   {
[11:02:55.105]                     {
[11:02:55.105]                       base::local({
[11:02:55.105]                         has_future <- base::requireNamespace("future", 
[11:02:55.105]                           quietly = TRUE)
[11:02:55.105]                         if (has_future) {
[11:02:55.105]                           ns <- base::getNamespace("future")
[11:02:55.105]                           version <- ns[[".package"]][["version"]]
[11:02:55.105]                           if (is.null(version)) 
[11:02:55.105]                             version <- utils::packageVersion("future")
[11:02:55.105]                         }
[11:02:55.105]                         else {
[11:02:55.105]                           version <- NULL
[11:02:55.105]                         }
[11:02:55.105]                         if (!has_future || version < "1.8.0") {
[11:02:55.105]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:55.105]                             "", base::R.version$version.string), 
[11:02:55.105]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:55.105]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:55.105]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:55.105]                               "release", "version")], collapse = " "), 
[11:02:55.105]                             hostname = base::Sys.info()[["nodename"]])
[11:02:55.105]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:55.105]                             info)
[11:02:55.105]                           info <- base::paste(info, collapse = "; ")
[11:02:55.105]                           if (!has_future) {
[11:02:55.105]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:55.105]                               info)
[11:02:55.105]                           }
[11:02:55.105]                           else {
[11:02:55.105]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:55.105]                               info, version)
[11:02:55.105]                           }
[11:02:55.105]                           base::stop(msg)
[11:02:55.105]                         }
[11:02:55.105]                       })
[11:02:55.105]                     }
[11:02:55.105]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:55.105]                     base::options(mc.cores = 1L)
[11:02:55.105]                   }
[11:02:55.105]                   ...future.strategy.old <- future::plan("list")
[11:02:55.105]                   options(future.plan = NULL)
[11:02:55.105]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:55.105]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:55.105]                 }
[11:02:55.105]                 ...future.workdir <- getwd()
[11:02:55.105]             }
[11:02:55.105]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:55.105]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:55.105]         }
[11:02:55.105]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:55.105]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:55.105]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:55.105]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:55.105]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:55.105]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:55.105]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:55.105]             base::names(...future.oldOptions))
[11:02:55.105]     }
[11:02:55.105]     if (FALSE) {
[11:02:55.105]     }
[11:02:55.105]     else {
[11:02:55.105]         if (TRUE) {
[11:02:55.105]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:55.105]                 open = "w")
[11:02:55.105]         }
[11:02:55.105]         else {
[11:02:55.105]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:55.105]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:55.105]         }
[11:02:55.105]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:55.105]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:55.105]             base::sink(type = "output", split = FALSE)
[11:02:55.105]             base::close(...future.stdout)
[11:02:55.105]         }, add = TRUE)
[11:02:55.105]     }
[11:02:55.105]     ...future.frame <- base::sys.nframe()
[11:02:55.105]     ...future.conditions <- base::list()
[11:02:55.105]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:55.105]     if (FALSE) {
[11:02:55.105]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:55.105]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:55.105]     }
[11:02:55.105]     ...future.result <- base::tryCatch({
[11:02:55.105]         base::withCallingHandlers({
[11:02:55.105]             ...future.value <- base::withVisible(base::local({
[11:02:55.105]                 ...future.makeSendCondition <- base::local({
[11:02:55.105]                   sendCondition <- NULL
[11:02:55.105]                   function(frame = 1L) {
[11:02:55.105]                     if (is.function(sendCondition)) 
[11:02:55.105]                       return(sendCondition)
[11:02:55.105]                     ns <- getNamespace("parallel")
[11:02:55.105]                     if (exists("sendData", mode = "function", 
[11:02:55.105]                       envir = ns)) {
[11:02:55.105]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:55.105]                         envir = ns)
[11:02:55.105]                       envir <- sys.frame(frame)
[11:02:55.105]                       master <- NULL
[11:02:55.105]                       while (!identical(envir, .GlobalEnv) && 
[11:02:55.105]                         !identical(envir, emptyenv())) {
[11:02:55.105]                         if (exists("master", mode = "list", envir = envir, 
[11:02:55.105]                           inherits = FALSE)) {
[11:02:55.105]                           master <- get("master", mode = "list", 
[11:02:55.105]                             envir = envir, inherits = FALSE)
[11:02:55.105]                           if (inherits(master, c("SOCKnode", 
[11:02:55.105]                             "SOCK0node"))) {
[11:02:55.105]                             sendCondition <<- function(cond) {
[11:02:55.105]                               data <- list(type = "VALUE", value = cond, 
[11:02:55.105]                                 success = TRUE)
[11:02:55.105]                               parallel_sendData(master, data)
[11:02:55.105]                             }
[11:02:55.105]                             return(sendCondition)
[11:02:55.105]                           }
[11:02:55.105]                         }
[11:02:55.105]                         frame <- frame + 1L
[11:02:55.105]                         envir <- sys.frame(frame)
[11:02:55.105]                       }
[11:02:55.105]                     }
[11:02:55.105]                     sendCondition <<- function(cond) NULL
[11:02:55.105]                   }
[11:02:55.105]                 })
[11:02:55.105]                 withCallingHandlers({
[11:02:55.105]                   list(a = 1, b = 42L, c = stop("Nah!"))
[11:02:55.105]                 }, immediateCondition = function(cond) {
[11:02:55.105]                   sendCondition <- ...future.makeSendCondition()
[11:02:55.105]                   sendCondition(cond)
[11:02:55.105]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:55.105]                   {
[11:02:55.105]                     inherits <- base::inherits
[11:02:55.105]                     invokeRestart <- base::invokeRestart
[11:02:55.105]                     is.null <- base::is.null
[11:02:55.105]                     muffled <- FALSE
[11:02:55.105]                     if (inherits(cond, "message")) {
[11:02:55.105]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:55.105]                       if (muffled) 
[11:02:55.105]                         invokeRestart("muffleMessage")
[11:02:55.105]                     }
[11:02:55.105]                     else if (inherits(cond, "warning")) {
[11:02:55.105]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:55.105]                       if (muffled) 
[11:02:55.105]                         invokeRestart("muffleWarning")
[11:02:55.105]                     }
[11:02:55.105]                     else if (inherits(cond, "condition")) {
[11:02:55.105]                       if (!is.null(pattern)) {
[11:02:55.105]                         computeRestarts <- base::computeRestarts
[11:02:55.105]                         grepl <- base::grepl
[11:02:55.105]                         restarts <- computeRestarts(cond)
[11:02:55.105]                         for (restart in restarts) {
[11:02:55.105]                           name <- restart$name
[11:02:55.105]                           if (is.null(name)) 
[11:02:55.105]                             next
[11:02:55.105]                           if (!grepl(pattern, name)) 
[11:02:55.105]                             next
[11:02:55.105]                           invokeRestart(restart)
[11:02:55.105]                           muffled <- TRUE
[11:02:55.105]                           break
[11:02:55.105]                         }
[11:02:55.105]                       }
[11:02:55.105]                     }
[11:02:55.105]                     invisible(muffled)
[11:02:55.105]                   }
[11:02:55.105]                   muffleCondition(cond)
[11:02:55.105]                 })
[11:02:55.105]             }))
[11:02:55.105]             future::FutureResult(value = ...future.value$value, 
[11:02:55.105]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:55.105]                   ...future.rng), globalenv = if (FALSE) 
[11:02:55.105]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:55.105]                     ...future.globalenv.names))
[11:02:55.105]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:55.105]         }, condition = base::local({
[11:02:55.105]             c <- base::c
[11:02:55.105]             inherits <- base::inherits
[11:02:55.105]             invokeRestart <- base::invokeRestart
[11:02:55.105]             length <- base::length
[11:02:55.105]             list <- base::list
[11:02:55.105]             seq.int <- base::seq.int
[11:02:55.105]             signalCondition <- base::signalCondition
[11:02:55.105]             sys.calls <- base::sys.calls
[11:02:55.105]             `[[` <- base::`[[`
[11:02:55.105]             `+` <- base::`+`
[11:02:55.105]             `<<-` <- base::`<<-`
[11:02:55.105]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:55.105]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:55.105]                   3L)]
[11:02:55.105]             }
[11:02:55.105]             function(cond) {
[11:02:55.105]                 is_error <- inherits(cond, "error")
[11:02:55.105]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:55.105]                   NULL)
[11:02:55.105]                 if (is_error) {
[11:02:55.105]                   sessionInformation <- function() {
[11:02:55.105]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:55.105]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:55.105]                       search = base::search(), system = base::Sys.info())
[11:02:55.105]                   }
[11:02:55.105]                   ...future.conditions[[length(...future.conditions) + 
[11:02:55.105]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:55.105]                     cond$call), session = sessionInformation(), 
[11:02:55.105]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:55.105]                   signalCondition(cond)
[11:02:55.105]                 }
[11:02:55.105]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:55.105]                 "immediateCondition"))) {
[11:02:55.105]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:55.105]                   ...future.conditions[[length(...future.conditions) + 
[11:02:55.105]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:55.105]                   if (TRUE && !signal) {
[11:02:55.105]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:55.105]                     {
[11:02:55.105]                       inherits <- base::inherits
[11:02:55.105]                       invokeRestart <- base::invokeRestart
[11:02:55.105]                       is.null <- base::is.null
[11:02:55.105]                       muffled <- FALSE
[11:02:55.105]                       if (inherits(cond, "message")) {
[11:02:55.105]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:55.105]                         if (muffled) 
[11:02:55.105]                           invokeRestart("muffleMessage")
[11:02:55.105]                       }
[11:02:55.105]                       else if (inherits(cond, "warning")) {
[11:02:55.105]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:55.105]                         if (muffled) 
[11:02:55.105]                           invokeRestart("muffleWarning")
[11:02:55.105]                       }
[11:02:55.105]                       else if (inherits(cond, "condition")) {
[11:02:55.105]                         if (!is.null(pattern)) {
[11:02:55.105]                           computeRestarts <- base::computeRestarts
[11:02:55.105]                           grepl <- base::grepl
[11:02:55.105]                           restarts <- computeRestarts(cond)
[11:02:55.105]                           for (restart in restarts) {
[11:02:55.105]                             name <- restart$name
[11:02:55.105]                             if (is.null(name)) 
[11:02:55.105]                               next
[11:02:55.105]                             if (!grepl(pattern, name)) 
[11:02:55.105]                               next
[11:02:55.105]                             invokeRestart(restart)
[11:02:55.105]                             muffled <- TRUE
[11:02:55.105]                             break
[11:02:55.105]                           }
[11:02:55.105]                         }
[11:02:55.105]                       }
[11:02:55.105]                       invisible(muffled)
[11:02:55.105]                     }
[11:02:55.105]                     muffleCondition(cond, pattern = "^muffle")
[11:02:55.105]                   }
[11:02:55.105]                 }
[11:02:55.105]                 else {
[11:02:55.105]                   if (TRUE) {
[11:02:55.105]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:55.105]                     {
[11:02:55.105]                       inherits <- base::inherits
[11:02:55.105]                       invokeRestart <- base::invokeRestart
[11:02:55.105]                       is.null <- base::is.null
[11:02:55.105]                       muffled <- FALSE
[11:02:55.105]                       if (inherits(cond, "message")) {
[11:02:55.105]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:55.105]                         if (muffled) 
[11:02:55.105]                           invokeRestart("muffleMessage")
[11:02:55.105]                       }
[11:02:55.105]                       else if (inherits(cond, "warning")) {
[11:02:55.105]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:55.105]                         if (muffled) 
[11:02:55.105]                           invokeRestart("muffleWarning")
[11:02:55.105]                       }
[11:02:55.105]                       else if (inherits(cond, "condition")) {
[11:02:55.105]                         if (!is.null(pattern)) {
[11:02:55.105]                           computeRestarts <- base::computeRestarts
[11:02:55.105]                           grepl <- base::grepl
[11:02:55.105]                           restarts <- computeRestarts(cond)
[11:02:55.105]                           for (restart in restarts) {
[11:02:55.105]                             name <- restart$name
[11:02:55.105]                             if (is.null(name)) 
[11:02:55.105]                               next
[11:02:55.105]                             if (!grepl(pattern, name)) 
[11:02:55.105]                               next
[11:02:55.105]                             invokeRestart(restart)
[11:02:55.105]                             muffled <- TRUE
[11:02:55.105]                             break
[11:02:55.105]                           }
[11:02:55.105]                         }
[11:02:55.105]                       }
[11:02:55.105]                       invisible(muffled)
[11:02:55.105]                     }
[11:02:55.105]                     muffleCondition(cond, pattern = "^muffle")
[11:02:55.105]                   }
[11:02:55.105]                 }
[11:02:55.105]             }
[11:02:55.105]         }))
[11:02:55.105]     }, error = function(ex) {
[11:02:55.105]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:55.105]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:55.105]                 ...future.rng), started = ...future.startTime, 
[11:02:55.105]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:55.105]             version = "1.8"), class = "FutureResult")
[11:02:55.105]     }, finally = {
[11:02:55.105]         if (!identical(...future.workdir, getwd())) 
[11:02:55.105]             setwd(...future.workdir)
[11:02:55.105]         {
[11:02:55.105]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:55.105]                 ...future.oldOptions$nwarnings <- NULL
[11:02:55.105]             }
[11:02:55.105]             base::options(...future.oldOptions)
[11:02:55.105]             if (.Platform$OS.type == "windows") {
[11:02:55.105]                 old_names <- names(...future.oldEnvVars)
[11:02:55.105]                 envs <- base::Sys.getenv()
[11:02:55.105]                 names <- names(envs)
[11:02:55.105]                 common <- intersect(names, old_names)
[11:02:55.105]                 added <- setdiff(names, old_names)
[11:02:55.105]                 removed <- setdiff(old_names, names)
[11:02:55.105]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:55.105]                   envs[common]]
[11:02:55.105]                 NAMES <- toupper(changed)
[11:02:55.105]                 args <- list()
[11:02:55.105]                 for (kk in seq_along(NAMES)) {
[11:02:55.105]                   name <- changed[[kk]]
[11:02:55.105]                   NAME <- NAMES[[kk]]
[11:02:55.105]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:55.105]                     next
[11:02:55.105]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:55.105]                 }
[11:02:55.105]                 NAMES <- toupper(added)
[11:02:55.105]                 for (kk in seq_along(NAMES)) {
[11:02:55.105]                   name <- added[[kk]]
[11:02:55.105]                   NAME <- NAMES[[kk]]
[11:02:55.105]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:55.105]                     next
[11:02:55.105]                   args[[name]] <- ""
[11:02:55.105]                 }
[11:02:55.105]                 NAMES <- toupper(removed)
[11:02:55.105]                 for (kk in seq_along(NAMES)) {
[11:02:55.105]                   name <- removed[[kk]]
[11:02:55.105]                   NAME <- NAMES[[kk]]
[11:02:55.105]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:55.105]                     next
[11:02:55.105]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:55.105]                 }
[11:02:55.105]                 if (length(args) > 0) 
[11:02:55.105]                   base::do.call(base::Sys.setenv, args = args)
[11:02:55.105]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:55.105]             }
[11:02:55.105]             else {
[11:02:55.105]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:55.105]             }
[11:02:55.105]             {
[11:02:55.105]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:55.105]                   0L) {
[11:02:55.105]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:55.105]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:55.105]                   base::options(opts)
[11:02:55.105]                 }
[11:02:55.105]                 {
[11:02:55.105]                   {
[11:02:55.105]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:55.105]                     NULL
[11:02:55.105]                   }
[11:02:55.105]                   options(future.plan = NULL)
[11:02:55.105]                   if (is.na(NA_character_)) 
[11:02:55.105]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:55.105]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:55.105]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:55.105]                     .init = FALSE)
[11:02:55.105]                 }
[11:02:55.105]             }
[11:02:55.105]         }
[11:02:55.105]     })
[11:02:55.105]     if (TRUE) {
[11:02:55.105]         base::sink(type = "output", split = FALSE)
[11:02:55.105]         if (TRUE) {
[11:02:55.105]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:55.105]         }
[11:02:55.105]         else {
[11:02:55.105]             ...future.result["stdout"] <- base::list(NULL)
[11:02:55.105]         }
[11:02:55.105]         base::close(...future.stdout)
[11:02:55.105]         ...future.stdout <- NULL
[11:02:55.105]     }
[11:02:55.105]     ...future.result$conditions <- ...future.conditions
[11:02:55.105]     ...future.result$finished <- base::Sys.time()
[11:02:55.105]     ...future.result
[11:02:55.105] }
[11:02:55.108] MultisessionFuture started
[11:02:55.109] - Launch lazy future ... done
[11:02:55.109] run() for ‘MultisessionFuture’ ... done
[11:02:55.150] receiveMessageFromWorker() for ClusterFuture ...
[11:02:55.150] - Validating connection of MultisessionFuture
[11:02:55.151] - received message: FutureResult
[11:02:55.151] - Received FutureResult
[11:02:55.151] - Erased future from FutureRegistry
[11:02:55.151] result() for ClusterFuture ...
[11:02:55.151] - result already collected: FutureResult
[11:02:55.151] result() for ClusterFuture ... done
[11:02:55.151] signalConditions() ...
[11:02:55.151]  - include = ‘immediateCondition’
[11:02:55.151]  - exclude = 
[11:02:55.152]  - resignal = FALSE
[11:02:55.152]  - Number of conditions: 1
[11:02:55.152] signalConditions() ... done
[11:02:55.152] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:55.152] A MultisessionFuture was resolved (and resolved itself)
[11:02:55.152] getGlobalsAndPackages() ...
[11:02:55.152] Searching for globals...
[11:02:55.153] - globals found: [2] ‘list’, ‘stop’
[11:02:55.153] Searching for globals ... DONE
[11:02:55.153] Resolving globals: FALSE
[11:02:55.153] 
[11:02:55.153] 
[11:02:55.153] getGlobalsAndPackages() ... DONE
[11:02:55.154] run() for ‘Future’ ...
[11:02:55.154] - state: ‘created’
[11:02:55.154] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:55.167] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:55.167] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:55.167]   - Field: ‘node’
[11:02:55.168]   - Field: ‘label’
[11:02:55.168]   - Field: ‘local’
[11:02:55.168]   - Field: ‘owner’
[11:02:55.168]   - Field: ‘envir’
[11:02:55.168]   - Field: ‘workers’
[11:02:55.168]   - Field: ‘packages’
[11:02:55.168]   - Field: ‘gc’
[11:02:55.168]   - Field: ‘conditions’
[11:02:55.168]   - Field: ‘persistent’
[11:02:55.168]   - Field: ‘expr’
[11:02:55.168]   - Field: ‘uuid’
[11:02:55.168]   - Field: ‘seed’
[11:02:55.169]   - Field: ‘version’
[11:02:55.169]   - Field: ‘result’
[11:02:55.169]   - Field: ‘asynchronous’
[11:02:55.169]   - Field: ‘calls’
[11:02:55.169]   - Field: ‘globals’
[11:02:55.169]   - Field: ‘stdout’
[11:02:55.169]   - Field: ‘earlySignal’
[11:02:55.169]   - Field: ‘lazy’
[11:02:55.169]   - Field: ‘state’
[11:02:55.169] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:55.169] - Launch lazy future ...
[11:02:55.170] Packages needed by the future expression (n = 0): <none>
[11:02:55.170] Packages needed by future strategies (n = 0): <none>
[11:02:55.170] {
[11:02:55.170]     {
[11:02:55.170]         {
[11:02:55.170]             ...future.startTime <- base::Sys.time()
[11:02:55.170]             {
[11:02:55.170]                 {
[11:02:55.170]                   {
[11:02:55.170]                     {
[11:02:55.170]                       base::local({
[11:02:55.170]                         has_future <- base::requireNamespace("future", 
[11:02:55.170]                           quietly = TRUE)
[11:02:55.170]                         if (has_future) {
[11:02:55.170]                           ns <- base::getNamespace("future")
[11:02:55.170]                           version <- ns[[".package"]][["version"]]
[11:02:55.170]                           if (is.null(version)) 
[11:02:55.170]                             version <- utils::packageVersion("future")
[11:02:55.170]                         }
[11:02:55.170]                         else {
[11:02:55.170]                           version <- NULL
[11:02:55.170]                         }
[11:02:55.170]                         if (!has_future || version < "1.8.0") {
[11:02:55.170]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:55.170]                             "", base::R.version$version.string), 
[11:02:55.170]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:55.170]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:55.170]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:55.170]                               "release", "version")], collapse = " "), 
[11:02:55.170]                             hostname = base::Sys.info()[["nodename"]])
[11:02:55.170]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:55.170]                             info)
[11:02:55.170]                           info <- base::paste(info, collapse = "; ")
[11:02:55.170]                           if (!has_future) {
[11:02:55.170]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:55.170]                               info)
[11:02:55.170]                           }
[11:02:55.170]                           else {
[11:02:55.170]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:55.170]                               info, version)
[11:02:55.170]                           }
[11:02:55.170]                           base::stop(msg)
[11:02:55.170]                         }
[11:02:55.170]                       })
[11:02:55.170]                     }
[11:02:55.170]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:55.170]                     base::options(mc.cores = 1L)
[11:02:55.170]                   }
[11:02:55.170]                   ...future.strategy.old <- future::plan("list")
[11:02:55.170]                   options(future.plan = NULL)
[11:02:55.170]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:55.170]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:55.170]                 }
[11:02:55.170]                 ...future.workdir <- getwd()
[11:02:55.170]             }
[11:02:55.170]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:55.170]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:55.170]         }
[11:02:55.170]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:55.170]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:55.170]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:55.170]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:55.170]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:55.170]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:55.170]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:55.170]             base::names(...future.oldOptions))
[11:02:55.170]     }
[11:02:55.170]     if (FALSE) {
[11:02:55.170]     }
[11:02:55.170]     else {
[11:02:55.170]         if (TRUE) {
[11:02:55.170]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:55.170]                 open = "w")
[11:02:55.170]         }
[11:02:55.170]         else {
[11:02:55.170]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:55.170]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:55.170]         }
[11:02:55.170]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:55.170]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:55.170]             base::sink(type = "output", split = FALSE)
[11:02:55.170]             base::close(...future.stdout)
[11:02:55.170]         }, add = TRUE)
[11:02:55.170]     }
[11:02:55.170]     ...future.frame <- base::sys.nframe()
[11:02:55.170]     ...future.conditions <- base::list()
[11:02:55.170]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:55.170]     if (FALSE) {
[11:02:55.170]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:55.170]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:55.170]     }
[11:02:55.170]     ...future.result <- base::tryCatch({
[11:02:55.170]         base::withCallingHandlers({
[11:02:55.170]             ...future.value <- base::withVisible(base::local({
[11:02:55.170]                 ...future.makeSendCondition <- base::local({
[11:02:55.170]                   sendCondition <- NULL
[11:02:55.170]                   function(frame = 1L) {
[11:02:55.170]                     if (is.function(sendCondition)) 
[11:02:55.170]                       return(sendCondition)
[11:02:55.170]                     ns <- getNamespace("parallel")
[11:02:55.170]                     if (exists("sendData", mode = "function", 
[11:02:55.170]                       envir = ns)) {
[11:02:55.170]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:55.170]                         envir = ns)
[11:02:55.170]                       envir <- sys.frame(frame)
[11:02:55.170]                       master <- NULL
[11:02:55.170]                       while (!identical(envir, .GlobalEnv) && 
[11:02:55.170]                         !identical(envir, emptyenv())) {
[11:02:55.170]                         if (exists("master", mode = "list", envir = envir, 
[11:02:55.170]                           inherits = FALSE)) {
[11:02:55.170]                           master <- get("master", mode = "list", 
[11:02:55.170]                             envir = envir, inherits = FALSE)
[11:02:55.170]                           if (inherits(master, c("SOCKnode", 
[11:02:55.170]                             "SOCK0node"))) {
[11:02:55.170]                             sendCondition <<- function(cond) {
[11:02:55.170]                               data <- list(type = "VALUE", value = cond, 
[11:02:55.170]                                 success = TRUE)
[11:02:55.170]                               parallel_sendData(master, data)
[11:02:55.170]                             }
[11:02:55.170]                             return(sendCondition)
[11:02:55.170]                           }
[11:02:55.170]                         }
[11:02:55.170]                         frame <- frame + 1L
[11:02:55.170]                         envir <- sys.frame(frame)
[11:02:55.170]                       }
[11:02:55.170]                     }
[11:02:55.170]                     sendCondition <<- function(cond) NULL
[11:02:55.170]                   }
[11:02:55.170]                 })
[11:02:55.170]                 withCallingHandlers({
[11:02:55.170]                   list(a = 1, b = 42L, c = stop("Nah!"))
[11:02:55.170]                 }, immediateCondition = function(cond) {
[11:02:55.170]                   sendCondition <- ...future.makeSendCondition()
[11:02:55.170]                   sendCondition(cond)
[11:02:55.170]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:55.170]                   {
[11:02:55.170]                     inherits <- base::inherits
[11:02:55.170]                     invokeRestart <- base::invokeRestart
[11:02:55.170]                     is.null <- base::is.null
[11:02:55.170]                     muffled <- FALSE
[11:02:55.170]                     if (inherits(cond, "message")) {
[11:02:55.170]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:55.170]                       if (muffled) 
[11:02:55.170]                         invokeRestart("muffleMessage")
[11:02:55.170]                     }
[11:02:55.170]                     else if (inherits(cond, "warning")) {
[11:02:55.170]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:55.170]                       if (muffled) 
[11:02:55.170]                         invokeRestart("muffleWarning")
[11:02:55.170]                     }
[11:02:55.170]                     else if (inherits(cond, "condition")) {
[11:02:55.170]                       if (!is.null(pattern)) {
[11:02:55.170]                         computeRestarts <- base::computeRestarts
[11:02:55.170]                         grepl <- base::grepl
[11:02:55.170]                         restarts <- computeRestarts(cond)
[11:02:55.170]                         for (restart in restarts) {
[11:02:55.170]                           name <- restart$name
[11:02:55.170]                           if (is.null(name)) 
[11:02:55.170]                             next
[11:02:55.170]                           if (!grepl(pattern, name)) 
[11:02:55.170]                             next
[11:02:55.170]                           invokeRestart(restart)
[11:02:55.170]                           muffled <- TRUE
[11:02:55.170]                           break
[11:02:55.170]                         }
[11:02:55.170]                       }
[11:02:55.170]                     }
[11:02:55.170]                     invisible(muffled)
[11:02:55.170]                   }
[11:02:55.170]                   muffleCondition(cond)
[11:02:55.170]                 })
[11:02:55.170]             }))
[11:02:55.170]             future::FutureResult(value = ...future.value$value, 
[11:02:55.170]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:55.170]                   ...future.rng), globalenv = if (FALSE) 
[11:02:55.170]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:55.170]                     ...future.globalenv.names))
[11:02:55.170]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:55.170]         }, condition = base::local({
[11:02:55.170]             c <- base::c
[11:02:55.170]             inherits <- base::inherits
[11:02:55.170]             invokeRestart <- base::invokeRestart
[11:02:55.170]             length <- base::length
[11:02:55.170]             list <- base::list
[11:02:55.170]             seq.int <- base::seq.int
[11:02:55.170]             signalCondition <- base::signalCondition
[11:02:55.170]             sys.calls <- base::sys.calls
[11:02:55.170]             `[[` <- base::`[[`
[11:02:55.170]             `+` <- base::`+`
[11:02:55.170]             `<<-` <- base::`<<-`
[11:02:55.170]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:55.170]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:55.170]                   3L)]
[11:02:55.170]             }
[11:02:55.170]             function(cond) {
[11:02:55.170]                 is_error <- inherits(cond, "error")
[11:02:55.170]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:55.170]                   NULL)
[11:02:55.170]                 if (is_error) {
[11:02:55.170]                   sessionInformation <- function() {
[11:02:55.170]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:55.170]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:55.170]                       search = base::search(), system = base::Sys.info())
[11:02:55.170]                   }
[11:02:55.170]                   ...future.conditions[[length(...future.conditions) + 
[11:02:55.170]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:55.170]                     cond$call), session = sessionInformation(), 
[11:02:55.170]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:55.170]                   signalCondition(cond)
[11:02:55.170]                 }
[11:02:55.170]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:55.170]                 "immediateCondition"))) {
[11:02:55.170]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:55.170]                   ...future.conditions[[length(...future.conditions) + 
[11:02:55.170]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:55.170]                   if (TRUE && !signal) {
[11:02:55.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:55.170]                     {
[11:02:55.170]                       inherits <- base::inherits
[11:02:55.170]                       invokeRestart <- base::invokeRestart
[11:02:55.170]                       is.null <- base::is.null
[11:02:55.170]                       muffled <- FALSE
[11:02:55.170]                       if (inherits(cond, "message")) {
[11:02:55.170]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:55.170]                         if (muffled) 
[11:02:55.170]                           invokeRestart("muffleMessage")
[11:02:55.170]                       }
[11:02:55.170]                       else if (inherits(cond, "warning")) {
[11:02:55.170]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:55.170]                         if (muffled) 
[11:02:55.170]                           invokeRestart("muffleWarning")
[11:02:55.170]                       }
[11:02:55.170]                       else if (inherits(cond, "condition")) {
[11:02:55.170]                         if (!is.null(pattern)) {
[11:02:55.170]                           computeRestarts <- base::computeRestarts
[11:02:55.170]                           grepl <- base::grepl
[11:02:55.170]                           restarts <- computeRestarts(cond)
[11:02:55.170]                           for (restart in restarts) {
[11:02:55.170]                             name <- restart$name
[11:02:55.170]                             if (is.null(name)) 
[11:02:55.170]                               next
[11:02:55.170]                             if (!grepl(pattern, name)) 
[11:02:55.170]                               next
[11:02:55.170]                             invokeRestart(restart)
[11:02:55.170]                             muffled <- TRUE
[11:02:55.170]                             break
[11:02:55.170]                           }
[11:02:55.170]                         }
[11:02:55.170]                       }
[11:02:55.170]                       invisible(muffled)
[11:02:55.170]                     }
[11:02:55.170]                     muffleCondition(cond, pattern = "^muffle")
[11:02:55.170]                   }
[11:02:55.170]                 }
[11:02:55.170]                 else {
[11:02:55.170]                   if (TRUE) {
[11:02:55.170]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:55.170]                     {
[11:02:55.170]                       inherits <- base::inherits
[11:02:55.170]                       invokeRestart <- base::invokeRestart
[11:02:55.170]                       is.null <- base::is.null
[11:02:55.170]                       muffled <- FALSE
[11:02:55.170]                       if (inherits(cond, "message")) {
[11:02:55.170]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:55.170]                         if (muffled) 
[11:02:55.170]                           invokeRestart("muffleMessage")
[11:02:55.170]                       }
[11:02:55.170]                       else if (inherits(cond, "warning")) {
[11:02:55.170]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:55.170]                         if (muffled) 
[11:02:55.170]                           invokeRestart("muffleWarning")
[11:02:55.170]                       }
[11:02:55.170]                       else if (inherits(cond, "condition")) {
[11:02:55.170]                         if (!is.null(pattern)) {
[11:02:55.170]                           computeRestarts <- base::computeRestarts
[11:02:55.170]                           grepl <- base::grepl
[11:02:55.170]                           restarts <- computeRestarts(cond)
[11:02:55.170]                           for (restart in restarts) {
[11:02:55.170]                             name <- restart$name
[11:02:55.170]                             if (is.null(name)) 
[11:02:55.170]                               next
[11:02:55.170]                             if (!grepl(pattern, name)) 
[11:02:55.170]                               next
[11:02:55.170]                             invokeRestart(restart)
[11:02:55.170]                             muffled <- TRUE
[11:02:55.170]                             break
[11:02:55.170]                           }
[11:02:55.170]                         }
[11:02:55.170]                       }
[11:02:55.170]                       invisible(muffled)
[11:02:55.170]                     }
[11:02:55.170]                     muffleCondition(cond, pattern = "^muffle")
[11:02:55.170]                   }
[11:02:55.170]                 }
[11:02:55.170]             }
[11:02:55.170]         }))
[11:02:55.170]     }, error = function(ex) {
[11:02:55.170]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:55.170]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:55.170]                 ...future.rng), started = ...future.startTime, 
[11:02:55.170]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:55.170]             version = "1.8"), class = "FutureResult")
[11:02:55.170]     }, finally = {
[11:02:55.170]         if (!identical(...future.workdir, getwd())) 
[11:02:55.170]             setwd(...future.workdir)
[11:02:55.170]         {
[11:02:55.170]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:55.170]                 ...future.oldOptions$nwarnings <- NULL
[11:02:55.170]             }
[11:02:55.170]             base::options(...future.oldOptions)
[11:02:55.170]             if (.Platform$OS.type == "windows") {
[11:02:55.170]                 old_names <- names(...future.oldEnvVars)
[11:02:55.170]                 envs <- base::Sys.getenv()
[11:02:55.170]                 names <- names(envs)
[11:02:55.170]                 common <- intersect(names, old_names)
[11:02:55.170]                 added <- setdiff(names, old_names)
[11:02:55.170]                 removed <- setdiff(old_names, names)
[11:02:55.170]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:55.170]                   envs[common]]
[11:02:55.170]                 NAMES <- toupper(changed)
[11:02:55.170]                 args <- list()
[11:02:55.170]                 for (kk in seq_along(NAMES)) {
[11:02:55.170]                   name <- changed[[kk]]
[11:02:55.170]                   NAME <- NAMES[[kk]]
[11:02:55.170]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:55.170]                     next
[11:02:55.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:55.170]                 }
[11:02:55.170]                 NAMES <- toupper(added)
[11:02:55.170]                 for (kk in seq_along(NAMES)) {
[11:02:55.170]                   name <- added[[kk]]
[11:02:55.170]                   NAME <- NAMES[[kk]]
[11:02:55.170]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:55.170]                     next
[11:02:55.170]                   args[[name]] <- ""
[11:02:55.170]                 }
[11:02:55.170]                 NAMES <- toupper(removed)
[11:02:55.170]                 for (kk in seq_along(NAMES)) {
[11:02:55.170]                   name <- removed[[kk]]
[11:02:55.170]                   NAME <- NAMES[[kk]]
[11:02:55.170]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:55.170]                     next
[11:02:55.170]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:55.170]                 }
[11:02:55.170]                 if (length(args) > 0) 
[11:02:55.170]                   base::do.call(base::Sys.setenv, args = args)
[11:02:55.170]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:55.170]             }
[11:02:55.170]             else {
[11:02:55.170]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:55.170]             }
[11:02:55.170]             {
[11:02:55.170]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:55.170]                   0L) {
[11:02:55.170]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:55.170]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:55.170]                   base::options(opts)
[11:02:55.170]                 }
[11:02:55.170]                 {
[11:02:55.170]                   {
[11:02:55.170]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:55.170]                     NULL
[11:02:55.170]                   }
[11:02:55.170]                   options(future.plan = NULL)
[11:02:55.170]                   if (is.na(NA_character_)) 
[11:02:55.170]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:55.170]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:55.170]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:55.170]                     .init = FALSE)
[11:02:55.170]                 }
[11:02:55.170]             }
[11:02:55.170]         }
[11:02:55.170]     })
[11:02:55.170]     if (TRUE) {
[11:02:55.170]         base::sink(type = "output", split = FALSE)
[11:02:55.170]         if (TRUE) {
[11:02:55.170]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:55.170]         }
[11:02:55.170]         else {
[11:02:55.170]             ...future.result["stdout"] <- base::list(NULL)
[11:02:55.170]         }
[11:02:55.170]         base::close(...future.stdout)
[11:02:55.170]         ...future.stdout <- NULL
[11:02:55.170]     }
[11:02:55.170]     ...future.result$conditions <- ...future.conditions
[11:02:55.170]     ...future.result$finished <- base::Sys.time()
[11:02:55.170]     ...future.result
[11:02:55.170] }
[11:02:55.173] MultisessionFuture started
[11:02:55.173] - Launch lazy future ... done
[11:02:55.173] run() for ‘MultisessionFuture’ ... done
[11:02:55.215] receiveMessageFromWorker() for ClusterFuture ...
[11:02:55.215] - Validating connection of MultisessionFuture
[11:02:55.216] - received message: FutureResult
[11:02:55.216] - Received FutureResult
[11:02:55.216] - Erased future from FutureRegistry
[11:02:55.216] result() for ClusterFuture ...
[11:02:55.216] - result already collected: FutureResult
[11:02:55.216] result() for ClusterFuture ... done
[11:02:55.216] signalConditions() ...
[11:02:55.216]  - include = ‘immediateCondition’
[11:02:55.216]  - exclude = 
[11:02:55.216]  - resignal = FALSE
[11:02:55.217]  - Number of conditions: 1
[11:02:55.217] signalConditions() ... done
[11:02:55.217] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:55.217] A MultisessionFuture was resolved (and resolved itself)
- result = TRUE, recursive = 2 ... DONE
- result = TRUE, recursive = Inf ...
[11:02:55.217] getGlobalsAndPackages() ...
[11:02:55.217] Searching for globals...
[11:02:55.218] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[11:02:55.218] Searching for globals ... DONE
[11:02:55.218] Resolving globals: FALSE
[11:02:55.219] 
[11:02:55.219] 
[11:02:55.219] getGlobalsAndPackages() ... DONE
[11:02:55.219] run() for ‘Future’ ...
[11:02:55.219] - state: ‘created’
[11:02:55.219] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:55.233] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:55.233] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:55.233]   - Field: ‘node’
[11:02:55.233]   - Field: ‘label’
[11:02:55.233]   - Field: ‘local’
[11:02:55.233]   - Field: ‘owner’
[11:02:55.233]   - Field: ‘envir’
[11:02:55.233]   - Field: ‘workers’
[11:02:55.234]   - Field: ‘packages’
[11:02:55.234]   - Field: ‘gc’
[11:02:55.234]   - Field: ‘conditions’
[11:02:55.234]   - Field: ‘persistent’
[11:02:55.234]   - Field: ‘expr’
[11:02:55.234]   - Field: ‘uuid’
[11:02:55.234]   - Field: ‘seed’
[11:02:55.234]   - Field: ‘version’
[11:02:55.234]   - Field: ‘result’
[11:02:55.234]   - Field: ‘asynchronous’
[11:02:55.234]   - Field: ‘calls’
[11:02:55.234]   - Field: ‘globals’
[11:02:55.235]   - Field: ‘stdout’
[11:02:55.235]   - Field: ‘earlySignal’
[11:02:55.235]   - Field: ‘lazy’
[11:02:55.235]   - Field: ‘state’
[11:02:55.235] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:55.235] - Launch lazy future ...
[11:02:55.235] Packages needed by the future expression (n = 0): <none>
[11:02:55.235] Packages needed by future strategies (n = 0): <none>
[11:02:55.236] {
[11:02:55.236]     {
[11:02:55.236]         {
[11:02:55.236]             ...future.startTime <- base::Sys.time()
[11:02:55.236]             {
[11:02:55.236]                 {
[11:02:55.236]                   {
[11:02:55.236]                     {
[11:02:55.236]                       base::local({
[11:02:55.236]                         has_future <- base::requireNamespace("future", 
[11:02:55.236]                           quietly = TRUE)
[11:02:55.236]                         if (has_future) {
[11:02:55.236]                           ns <- base::getNamespace("future")
[11:02:55.236]                           version <- ns[[".package"]][["version"]]
[11:02:55.236]                           if (is.null(version)) 
[11:02:55.236]                             version <- utils::packageVersion("future")
[11:02:55.236]                         }
[11:02:55.236]                         else {
[11:02:55.236]                           version <- NULL
[11:02:55.236]                         }
[11:02:55.236]                         if (!has_future || version < "1.8.0") {
[11:02:55.236]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:55.236]                             "", base::R.version$version.string), 
[11:02:55.236]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:55.236]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:55.236]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:55.236]                               "release", "version")], collapse = " "), 
[11:02:55.236]                             hostname = base::Sys.info()[["nodename"]])
[11:02:55.236]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:55.236]                             info)
[11:02:55.236]                           info <- base::paste(info, collapse = "; ")
[11:02:55.236]                           if (!has_future) {
[11:02:55.236]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:55.236]                               info)
[11:02:55.236]                           }
[11:02:55.236]                           else {
[11:02:55.236]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:55.236]                               info, version)
[11:02:55.236]                           }
[11:02:55.236]                           base::stop(msg)
[11:02:55.236]                         }
[11:02:55.236]                       })
[11:02:55.236]                     }
[11:02:55.236]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:55.236]                     base::options(mc.cores = 1L)
[11:02:55.236]                   }
[11:02:55.236]                   ...future.strategy.old <- future::plan("list")
[11:02:55.236]                   options(future.plan = NULL)
[11:02:55.236]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:55.236]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:55.236]                 }
[11:02:55.236]                 ...future.workdir <- getwd()
[11:02:55.236]             }
[11:02:55.236]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:55.236]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:55.236]         }
[11:02:55.236]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:55.236]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:55.236]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:55.236]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:55.236]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:55.236]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:55.236]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:55.236]             base::names(...future.oldOptions))
[11:02:55.236]     }
[11:02:55.236]     if (FALSE) {
[11:02:55.236]     }
[11:02:55.236]     else {
[11:02:55.236]         if (TRUE) {
[11:02:55.236]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:55.236]                 open = "w")
[11:02:55.236]         }
[11:02:55.236]         else {
[11:02:55.236]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:55.236]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:55.236]         }
[11:02:55.236]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:55.236]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:55.236]             base::sink(type = "output", split = FALSE)
[11:02:55.236]             base::close(...future.stdout)
[11:02:55.236]         }, add = TRUE)
[11:02:55.236]     }
[11:02:55.236]     ...future.frame <- base::sys.nframe()
[11:02:55.236]     ...future.conditions <- base::list()
[11:02:55.236]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:55.236]     if (FALSE) {
[11:02:55.236]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:55.236]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:55.236]     }
[11:02:55.236]     ...future.result <- base::tryCatch({
[11:02:55.236]         base::withCallingHandlers({
[11:02:55.236]             ...future.value <- base::withVisible(base::local({
[11:02:55.236]                 ...future.makeSendCondition <- base::local({
[11:02:55.236]                   sendCondition <- NULL
[11:02:55.236]                   function(frame = 1L) {
[11:02:55.236]                     if (is.function(sendCondition)) 
[11:02:55.236]                       return(sendCondition)
[11:02:55.236]                     ns <- getNamespace("parallel")
[11:02:55.236]                     if (exists("sendData", mode = "function", 
[11:02:55.236]                       envir = ns)) {
[11:02:55.236]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:55.236]                         envir = ns)
[11:02:55.236]                       envir <- sys.frame(frame)
[11:02:55.236]                       master <- NULL
[11:02:55.236]                       while (!identical(envir, .GlobalEnv) && 
[11:02:55.236]                         !identical(envir, emptyenv())) {
[11:02:55.236]                         if (exists("master", mode = "list", envir = envir, 
[11:02:55.236]                           inherits = FALSE)) {
[11:02:55.236]                           master <- get("master", mode = "list", 
[11:02:55.236]                             envir = envir, inherits = FALSE)
[11:02:55.236]                           if (inherits(master, c("SOCKnode", 
[11:02:55.236]                             "SOCK0node"))) {
[11:02:55.236]                             sendCondition <<- function(cond) {
[11:02:55.236]                               data <- list(type = "VALUE", value = cond, 
[11:02:55.236]                                 success = TRUE)
[11:02:55.236]                               parallel_sendData(master, data)
[11:02:55.236]                             }
[11:02:55.236]                             return(sendCondition)
[11:02:55.236]                           }
[11:02:55.236]                         }
[11:02:55.236]                         frame <- frame + 1L
[11:02:55.236]                         envir <- sys.frame(frame)
[11:02:55.236]                       }
[11:02:55.236]                     }
[11:02:55.236]                     sendCondition <<- function(cond) NULL
[11:02:55.236]                   }
[11:02:55.236]                 })
[11:02:55.236]                 withCallingHandlers({
[11:02:55.236]                   {
[11:02:55.236]                     Sys.sleep(0.5)
[11:02:55.236]                     list(a = 1, b = 42L)
[11:02:55.236]                   }
[11:02:55.236]                 }, immediateCondition = function(cond) {
[11:02:55.236]                   sendCondition <- ...future.makeSendCondition()
[11:02:55.236]                   sendCondition(cond)
[11:02:55.236]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:55.236]                   {
[11:02:55.236]                     inherits <- base::inherits
[11:02:55.236]                     invokeRestart <- base::invokeRestart
[11:02:55.236]                     is.null <- base::is.null
[11:02:55.236]                     muffled <- FALSE
[11:02:55.236]                     if (inherits(cond, "message")) {
[11:02:55.236]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:55.236]                       if (muffled) 
[11:02:55.236]                         invokeRestart("muffleMessage")
[11:02:55.236]                     }
[11:02:55.236]                     else if (inherits(cond, "warning")) {
[11:02:55.236]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:55.236]                       if (muffled) 
[11:02:55.236]                         invokeRestart("muffleWarning")
[11:02:55.236]                     }
[11:02:55.236]                     else if (inherits(cond, "condition")) {
[11:02:55.236]                       if (!is.null(pattern)) {
[11:02:55.236]                         computeRestarts <- base::computeRestarts
[11:02:55.236]                         grepl <- base::grepl
[11:02:55.236]                         restarts <- computeRestarts(cond)
[11:02:55.236]                         for (restart in restarts) {
[11:02:55.236]                           name <- restart$name
[11:02:55.236]                           if (is.null(name)) 
[11:02:55.236]                             next
[11:02:55.236]                           if (!grepl(pattern, name)) 
[11:02:55.236]                             next
[11:02:55.236]                           invokeRestart(restart)
[11:02:55.236]                           muffled <- TRUE
[11:02:55.236]                           break
[11:02:55.236]                         }
[11:02:55.236]                       }
[11:02:55.236]                     }
[11:02:55.236]                     invisible(muffled)
[11:02:55.236]                   }
[11:02:55.236]                   muffleCondition(cond)
[11:02:55.236]                 })
[11:02:55.236]             }))
[11:02:55.236]             future::FutureResult(value = ...future.value$value, 
[11:02:55.236]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:55.236]                   ...future.rng), globalenv = if (FALSE) 
[11:02:55.236]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:55.236]                     ...future.globalenv.names))
[11:02:55.236]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:55.236]         }, condition = base::local({
[11:02:55.236]             c <- base::c
[11:02:55.236]             inherits <- base::inherits
[11:02:55.236]             invokeRestart <- base::invokeRestart
[11:02:55.236]             length <- base::length
[11:02:55.236]             list <- base::list
[11:02:55.236]             seq.int <- base::seq.int
[11:02:55.236]             signalCondition <- base::signalCondition
[11:02:55.236]             sys.calls <- base::sys.calls
[11:02:55.236]             `[[` <- base::`[[`
[11:02:55.236]             `+` <- base::`+`
[11:02:55.236]             `<<-` <- base::`<<-`
[11:02:55.236]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:55.236]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:55.236]                   3L)]
[11:02:55.236]             }
[11:02:55.236]             function(cond) {
[11:02:55.236]                 is_error <- inherits(cond, "error")
[11:02:55.236]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:55.236]                   NULL)
[11:02:55.236]                 if (is_error) {
[11:02:55.236]                   sessionInformation <- function() {
[11:02:55.236]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:55.236]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:55.236]                       search = base::search(), system = base::Sys.info())
[11:02:55.236]                   }
[11:02:55.236]                   ...future.conditions[[length(...future.conditions) + 
[11:02:55.236]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:55.236]                     cond$call), session = sessionInformation(), 
[11:02:55.236]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:55.236]                   signalCondition(cond)
[11:02:55.236]                 }
[11:02:55.236]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:55.236]                 "immediateCondition"))) {
[11:02:55.236]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:55.236]                   ...future.conditions[[length(...future.conditions) + 
[11:02:55.236]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:55.236]                   if (TRUE && !signal) {
[11:02:55.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:55.236]                     {
[11:02:55.236]                       inherits <- base::inherits
[11:02:55.236]                       invokeRestart <- base::invokeRestart
[11:02:55.236]                       is.null <- base::is.null
[11:02:55.236]                       muffled <- FALSE
[11:02:55.236]                       if (inherits(cond, "message")) {
[11:02:55.236]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:55.236]                         if (muffled) 
[11:02:55.236]                           invokeRestart("muffleMessage")
[11:02:55.236]                       }
[11:02:55.236]                       else if (inherits(cond, "warning")) {
[11:02:55.236]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:55.236]                         if (muffled) 
[11:02:55.236]                           invokeRestart("muffleWarning")
[11:02:55.236]                       }
[11:02:55.236]                       else if (inherits(cond, "condition")) {
[11:02:55.236]                         if (!is.null(pattern)) {
[11:02:55.236]                           computeRestarts <- base::computeRestarts
[11:02:55.236]                           grepl <- base::grepl
[11:02:55.236]                           restarts <- computeRestarts(cond)
[11:02:55.236]                           for (restart in restarts) {
[11:02:55.236]                             name <- restart$name
[11:02:55.236]                             if (is.null(name)) 
[11:02:55.236]                               next
[11:02:55.236]                             if (!grepl(pattern, name)) 
[11:02:55.236]                               next
[11:02:55.236]                             invokeRestart(restart)
[11:02:55.236]                             muffled <- TRUE
[11:02:55.236]                             break
[11:02:55.236]                           }
[11:02:55.236]                         }
[11:02:55.236]                       }
[11:02:55.236]                       invisible(muffled)
[11:02:55.236]                     }
[11:02:55.236]                     muffleCondition(cond, pattern = "^muffle")
[11:02:55.236]                   }
[11:02:55.236]                 }
[11:02:55.236]                 else {
[11:02:55.236]                   if (TRUE) {
[11:02:55.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:55.236]                     {
[11:02:55.236]                       inherits <- base::inherits
[11:02:55.236]                       invokeRestart <- base::invokeRestart
[11:02:55.236]                       is.null <- base::is.null
[11:02:55.236]                       muffled <- FALSE
[11:02:55.236]                       if (inherits(cond, "message")) {
[11:02:55.236]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:55.236]                         if (muffled) 
[11:02:55.236]                           invokeRestart("muffleMessage")
[11:02:55.236]                       }
[11:02:55.236]                       else if (inherits(cond, "warning")) {
[11:02:55.236]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:55.236]                         if (muffled) 
[11:02:55.236]                           invokeRestart("muffleWarning")
[11:02:55.236]                       }
[11:02:55.236]                       else if (inherits(cond, "condition")) {
[11:02:55.236]                         if (!is.null(pattern)) {
[11:02:55.236]                           computeRestarts <- base::computeRestarts
[11:02:55.236]                           grepl <- base::grepl
[11:02:55.236]                           restarts <- computeRestarts(cond)
[11:02:55.236]                           for (restart in restarts) {
[11:02:55.236]                             name <- restart$name
[11:02:55.236]                             if (is.null(name)) 
[11:02:55.236]                               next
[11:02:55.236]                             if (!grepl(pattern, name)) 
[11:02:55.236]                               next
[11:02:55.236]                             invokeRestart(restart)
[11:02:55.236]                             muffled <- TRUE
[11:02:55.236]                             break
[11:02:55.236]                           }
[11:02:55.236]                         }
[11:02:55.236]                       }
[11:02:55.236]                       invisible(muffled)
[11:02:55.236]                     }
[11:02:55.236]                     muffleCondition(cond, pattern = "^muffle")
[11:02:55.236]                   }
[11:02:55.236]                 }
[11:02:55.236]             }
[11:02:55.236]         }))
[11:02:55.236]     }, error = function(ex) {
[11:02:55.236]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:55.236]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:55.236]                 ...future.rng), started = ...future.startTime, 
[11:02:55.236]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:55.236]             version = "1.8"), class = "FutureResult")
[11:02:55.236]     }, finally = {
[11:02:55.236]         if (!identical(...future.workdir, getwd())) 
[11:02:55.236]             setwd(...future.workdir)
[11:02:55.236]         {
[11:02:55.236]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:55.236]                 ...future.oldOptions$nwarnings <- NULL
[11:02:55.236]             }
[11:02:55.236]             base::options(...future.oldOptions)
[11:02:55.236]             if (.Platform$OS.type == "windows") {
[11:02:55.236]                 old_names <- names(...future.oldEnvVars)
[11:02:55.236]                 envs <- base::Sys.getenv()
[11:02:55.236]                 names <- names(envs)
[11:02:55.236]                 common <- intersect(names, old_names)
[11:02:55.236]                 added <- setdiff(names, old_names)
[11:02:55.236]                 removed <- setdiff(old_names, names)
[11:02:55.236]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:55.236]                   envs[common]]
[11:02:55.236]                 NAMES <- toupper(changed)
[11:02:55.236]                 args <- list()
[11:02:55.236]                 for (kk in seq_along(NAMES)) {
[11:02:55.236]                   name <- changed[[kk]]
[11:02:55.236]                   NAME <- NAMES[[kk]]
[11:02:55.236]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:55.236]                     next
[11:02:55.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:55.236]                 }
[11:02:55.236]                 NAMES <- toupper(added)
[11:02:55.236]                 for (kk in seq_along(NAMES)) {
[11:02:55.236]                   name <- added[[kk]]
[11:02:55.236]                   NAME <- NAMES[[kk]]
[11:02:55.236]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:55.236]                     next
[11:02:55.236]                   args[[name]] <- ""
[11:02:55.236]                 }
[11:02:55.236]                 NAMES <- toupper(removed)
[11:02:55.236]                 for (kk in seq_along(NAMES)) {
[11:02:55.236]                   name <- removed[[kk]]
[11:02:55.236]                   NAME <- NAMES[[kk]]
[11:02:55.236]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:55.236]                     next
[11:02:55.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:55.236]                 }
[11:02:55.236]                 if (length(args) > 0) 
[11:02:55.236]                   base::do.call(base::Sys.setenv, args = args)
[11:02:55.236]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:55.236]             }
[11:02:55.236]             else {
[11:02:55.236]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:55.236]             }
[11:02:55.236]             {
[11:02:55.236]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:55.236]                   0L) {
[11:02:55.236]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:55.236]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:55.236]                   base::options(opts)
[11:02:55.236]                 }
[11:02:55.236]                 {
[11:02:55.236]                   {
[11:02:55.236]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:55.236]                     NULL
[11:02:55.236]                   }
[11:02:55.236]                   options(future.plan = NULL)
[11:02:55.236]                   if (is.na(NA_character_)) 
[11:02:55.236]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:55.236]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:55.236]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:55.236]                     .init = FALSE)
[11:02:55.236]                 }
[11:02:55.236]             }
[11:02:55.236]         }
[11:02:55.236]     })
[11:02:55.236]     if (TRUE) {
[11:02:55.236]         base::sink(type = "output", split = FALSE)
[11:02:55.236]         if (TRUE) {
[11:02:55.236]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:55.236]         }
[11:02:55.236]         else {
[11:02:55.236]             ...future.result["stdout"] <- base::list(NULL)
[11:02:55.236]         }
[11:02:55.236]         base::close(...future.stdout)
[11:02:55.236]         ...future.stdout <- NULL
[11:02:55.236]     }
[11:02:55.236]     ...future.result$conditions <- ...future.conditions
[11:02:55.236]     ...future.result$finished <- base::Sys.time()
[11:02:55.236]     ...future.result
[11:02:55.236] }
[11:02:55.239] MultisessionFuture started
[11:02:55.239] - Launch lazy future ... done
[11:02:55.239] run() for ‘MultisessionFuture’ ... done
[11:02:55.782] receiveMessageFromWorker() for ClusterFuture ...
[11:02:55.782] - Validating connection of MultisessionFuture
[11:02:55.782] - received message: FutureResult
[11:02:55.782] - Received FutureResult
[11:02:55.782] - Erased future from FutureRegistry
[11:02:55.782] result() for ClusterFuture ...
[11:02:55.783] - result already collected: FutureResult
[11:02:55.783] result() for ClusterFuture ... done
[11:02:55.783] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:55.783] resolve() on list ...
[11:02:55.783]  recursive: Inf
[11:02:55.783]  length: 2
[11:02:55.783]  elements: ‘a’, ‘b’
[11:02:55.783]  length: 1 (resolved future 1)
[11:02:55.783]  length: 0 (resolved future 2)
[11:02:55.783] resolve() on list ... DONE
[11:02:55.783] A MultisessionFuture was resolved (and resolved itself)
[11:02:55.784] getGlobalsAndPackages() ...
[11:02:55.784] Searching for globals...
[11:02:55.785] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘list’
[11:02:55.785] Searching for globals ... DONE
[11:02:55.785] Resolving globals: FALSE
[11:02:55.785] 
[11:02:55.785] 
[11:02:55.785] getGlobalsAndPackages() ... DONE
[11:02:55.786] run() for ‘Future’ ...
[11:02:55.786] - state: ‘created’
[11:02:55.786] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:55.809] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:55.809] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:55.809]   - Field: ‘node’
[11:02:55.809]   - Field: ‘label’
[11:02:55.809]   - Field: ‘local’
[11:02:55.809]   - Field: ‘owner’
[11:02:55.809]   - Field: ‘envir’
[11:02:55.809]   - Field: ‘workers’
[11:02:55.810]   - Field: ‘packages’
[11:02:55.810]   - Field: ‘gc’
[11:02:55.810]   - Field: ‘conditions’
[11:02:55.810]   - Field: ‘persistent’
[11:02:55.810]   - Field: ‘expr’
[11:02:55.810]   - Field: ‘uuid’
[11:02:55.810]   - Field: ‘seed’
[11:02:55.810]   - Field: ‘version’
[11:02:55.810]   - Field: ‘result’
[11:02:55.810]   - Field: ‘asynchronous’
[11:02:55.810]   - Field: ‘calls’
[11:02:55.810]   - Field: ‘globals’
[11:02:55.811]   - Field: ‘stdout’
[11:02:55.811]   - Field: ‘earlySignal’
[11:02:55.811]   - Field: ‘lazy’
[11:02:55.811]   - Field: ‘state’
[11:02:55.811] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:55.811] - Launch lazy future ...
[11:02:55.811] Packages needed by the future expression (n = 0): <none>
[11:02:55.811] Packages needed by future strategies (n = 0): <none>
[11:02:55.812] {
[11:02:55.812]     {
[11:02:55.812]         {
[11:02:55.812]             ...future.startTime <- base::Sys.time()
[11:02:55.812]             {
[11:02:55.812]                 {
[11:02:55.812]                   {
[11:02:55.812]                     {
[11:02:55.812]                       base::local({
[11:02:55.812]                         has_future <- base::requireNamespace("future", 
[11:02:55.812]                           quietly = TRUE)
[11:02:55.812]                         if (has_future) {
[11:02:55.812]                           ns <- base::getNamespace("future")
[11:02:55.812]                           version <- ns[[".package"]][["version"]]
[11:02:55.812]                           if (is.null(version)) 
[11:02:55.812]                             version <- utils::packageVersion("future")
[11:02:55.812]                         }
[11:02:55.812]                         else {
[11:02:55.812]                           version <- NULL
[11:02:55.812]                         }
[11:02:55.812]                         if (!has_future || version < "1.8.0") {
[11:02:55.812]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:55.812]                             "", base::R.version$version.string), 
[11:02:55.812]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:55.812]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:55.812]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:55.812]                               "release", "version")], collapse = " "), 
[11:02:55.812]                             hostname = base::Sys.info()[["nodename"]])
[11:02:55.812]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:55.812]                             info)
[11:02:55.812]                           info <- base::paste(info, collapse = "; ")
[11:02:55.812]                           if (!has_future) {
[11:02:55.812]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:55.812]                               info)
[11:02:55.812]                           }
[11:02:55.812]                           else {
[11:02:55.812]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:55.812]                               info, version)
[11:02:55.812]                           }
[11:02:55.812]                           base::stop(msg)
[11:02:55.812]                         }
[11:02:55.812]                       })
[11:02:55.812]                     }
[11:02:55.812]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:55.812]                     base::options(mc.cores = 1L)
[11:02:55.812]                   }
[11:02:55.812]                   ...future.strategy.old <- future::plan("list")
[11:02:55.812]                   options(future.plan = NULL)
[11:02:55.812]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:55.812]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:55.812]                 }
[11:02:55.812]                 ...future.workdir <- getwd()
[11:02:55.812]             }
[11:02:55.812]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:55.812]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:55.812]         }
[11:02:55.812]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:55.812]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:55.812]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:55.812]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:55.812]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:55.812]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:55.812]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:55.812]             base::names(...future.oldOptions))
[11:02:55.812]     }
[11:02:55.812]     if (FALSE) {
[11:02:55.812]     }
[11:02:55.812]     else {
[11:02:55.812]         if (TRUE) {
[11:02:55.812]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:55.812]                 open = "w")
[11:02:55.812]         }
[11:02:55.812]         else {
[11:02:55.812]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:55.812]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:55.812]         }
[11:02:55.812]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:55.812]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:55.812]             base::sink(type = "output", split = FALSE)
[11:02:55.812]             base::close(...future.stdout)
[11:02:55.812]         }, add = TRUE)
[11:02:55.812]     }
[11:02:55.812]     ...future.frame <- base::sys.nframe()
[11:02:55.812]     ...future.conditions <- base::list()
[11:02:55.812]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:55.812]     if (FALSE) {
[11:02:55.812]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:55.812]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:55.812]     }
[11:02:55.812]     ...future.result <- base::tryCatch({
[11:02:55.812]         base::withCallingHandlers({
[11:02:55.812]             ...future.value <- base::withVisible(base::local({
[11:02:55.812]                 ...future.makeSendCondition <- base::local({
[11:02:55.812]                   sendCondition <- NULL
[11:02:55.812]                   function(frame = 1L) {
[11:02:55.812]                     if (is.function(sendCondition)) 
[11:02:55.812]                       return(sendCondition)
[11:02:55.812]                     ns <- getNamespace("parallel")
[11:02:55.812]                     if (exists("sendData", mode = "function", 
[11:02:55.812]                       envir = ns)) {
[11:02:55.812]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:55.812]                         envir = ns)
[11:02:55.812]                       envir <- sys.frame(frame)
[11:02:55.812]                       master <- NULL
[11:02:55.812]                       while (!identical(envir, .GlobalEnv) && 
[11:02:55.812]                         !identical(envir, emptyenv())) {
[11:02:55.812]                         if (exists("master", mode = "list", envir = envir, 
[11:02:55.812]                           inherits = FALSE)) {
[11:02:55.812]                           master <- get("master", mode = "list", 
[11:02:55.812]                             envir = envir, inherits = FALSE)
[11:02:55.812]                           if (inherits(master, c("SOCKnode", 
[11:02:55.812]                             "SOCK0node"))) {
[11:02:55.812]                             sendCondition <<- function(cond) {
[11:02:55.812]                               data <- list(type = "VALUE", value = cond, 
[11:02:55.812]                                 success = TRUE)
[11:02:55.812]                               parallel_sendData(master, data)
[11:02:55.812]                             }
[11:02:55.812]                             return(sendCondition)
[11:02:55.812]                           }
[11:02:55.812]                         }
[11:02:55.812]                         frame <- frame + 1L
[11:02:55.812]                         envir <- sys.frame(frame)
[11:02:55.812]                       }
[11:02:55.812]                     }
[11:02:55.812]                     sendCondition <<- function(cond) NULL
[11:02:55.812]                   }
[11:02:55.812]                 })
[11:02:55.812]                 withCallingHandlers({
[11:02:55.812]                   {
[11:02:55.812]                     Sys.sleep(0.5)
[11:02:55.812]                     list(a = 1, b = 42L)
[11:02:55.812]                   }
[11:02:55.812]                 }, immediateCondition = function(cond) {
[11:02:55.812]                   sendCondition <- ...future.makeSendCondition()
[11:02:55.812]                   sendCondition(cond)
[11:02:55.812]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:55.812]                   {
[11:02:55.812]                     inherits <- base::inherits
[11:02:55.812]                     invokeRestart <- base::invokeRestart
[11:02:55.812]                     is.null <- base::is.null
[11:02:55.812]                     muffled <- FALSE
[11:02:55.812]                     if (inherits(cond, "message")) {
[11:02:55.812]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:55.812]                       if (muffled) 
[11:02:55.812]                         invokeRestart("muffleMessage")
[11:02:55.812]                     }
[11:02:55.812]                     else if (inherits(cond, "warning")) {
[11:02:55.812]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:55.812]                       if (muffled) 
[11:02:55.812]                         invokeRestart("muffleWarning")
[11:02:55.812]                     }
[11:02:55.812]                     else if (inherits(cond, "condition")) {
[11:02:55.812]                       if (!is.null(pattern)) {
[11:02:55.812]                         computeRestarts <- base::computeRestarts
[11:02:55.812]                         grepl <- base::grepl
[11:02:55.812]                         restarts <- computeRestarts(cond)
[11:02:55.812]                         for (restart in restarts) {
[11:02:55.812]                           name <- restart$name
[11:02:55.812]                           if (is.null(name)) 
[11:02:55.812]                             next
[11:02:55.812]                           if (!grepl(pattern, name)) 
[11:02:55.812]                             next
[11:02:55.812]                           invokeRestart(restart)
[11:02:55.812]                           muffled <- TRUE
[11:02:55.812]                           break
[11:02:55.812]                         }
[11:02:55.812]                       }
[11:02:55.812]                     }
[11:02:55.812]                     invisible(muffled)
[11:02:55.812]                   }
[11:02:55.812]                   muffleCondition(cond)
[11:02:55.812]                 })
[11:02:55.812]             }))
[11:02:55.812]             future::FutureResult(value = ...future.value$value, 
[11:02:55.812]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:55.812]                   ...future.rng), globalenv = if (FALSE) 
[11:02:55.812]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:55.812]                     ...future.globalenv.names))
[11:02:55.812]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:55.812]         }, condition = base::local({
[11:02:55.812]             c <- base::c
[11:02:55.812]             inherits <- base::inherits
[11:02:55.812]             invokeRestart <- base::invokeRestart
[11:02:55.812]             length <- base::length
[11:02:55.812]             list <- base::list
[11:02:55.812]             seq.int <- base::seq.int
[11:02:55.812]             signalCondition <- base::signalCondition
[11:02:55.812]             sys.calls <- base::sys.calls
[11:02:55.812]             `[[` <- base::`[[`
[11:02:55.812]             `+` <- base::`+`
[11:02:55.812]             `<<-` <- base::`<<-`
[11:02:55.812]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:55.812]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:55.812]                   3L)]
[11:02:55.812]             }
[11:02:55.812]             function(cond) {
[11:02:55.812]                 is_error <- inherits(cond, "error")
[11:02:55.812]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:55.812]                   NULL)
[11:02:55.812]                 if (is_error) {
[11:02:55.812]                   sessionInformation <- function() {
[11:02:55.812]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:55.812]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:55.812]                       search = base::search(), system = base::Sys.info())
[11:02:55.812]                   }
[11:02:55.812]                   ...future.conditions[[length(...future.conditions) + 
[11:02:55.812]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:55.812]                     cond$call), session = sessionInformation(), 
[11:02:55.812]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:55.812]                   signalCondition(cond)
[11:02:55.812]                 }
[11:02:55.812]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:55.812]                 "immediateCondition"))) {
[11:02:55.812]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:55.812]                   ...future.conditions[[length(...future.conditions) + 
[11:02:55.812]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:55.812]                   if (TRUE && !signal) {
[11:02:55.812]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:55.812]                     {
[11:02:55.812]                       inherits <- base::inherits
[11:02:55.812]                       invokeRestart <- base::invokeRestart
[11:02:55.812]                       is.null <- base::is.null
[11:02:55.812]                       muffled <- FALSE
[11:02:55.812]                       if (inherits(cond, "message")) {
[11:02:55.812]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:55.812]                         if (muffled) 
[11:02:55.812]                           invokeRestart("muffleMessage")
[11:02:55.812]                       }
[11:02:55.812]                       else if (inherits(cond, "warning")) {
[11:02:55.812]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:55.812]                         if (muffled) 
[11:02:55.812]                           invokeRestart("muffleWarning")
[11:02:55.812]                       }
[11:02:55.812]                       else if (inherits(cond, "condition")) {
[11:02:55.812]                         if (!is.null(pattern)) {
[11:02:55.812]                           computeRestarts <- base::computeRestarts
[11:02:55.812]                           grepl <- base::grepl
[11:02:55.812]                           restarts <- computeRestarts(cond)
[11:02:55.812]                           for (restart in restarts) {
[11:02:55.812]                             name <- restart$name
[11:02:55.812]                             if (is.null(name)) 
[11:02:55.812]                               next
[11:02:55.812]                             if (!grepl(pattern, name)) 
[11:02:55.812]                               next
[11:02:55.812]                             invokeRestart(restart)
[11:02:55.812]                             muffled <- TRUE
[11:02:55.812]                             break
[11:02:55.812]                           }
[11:02:55.812]                         }
[11:02:55.812]                       }
[11:02:55.812]                       invisible(muffled)
[11:02:55.812]                     }
[11:02:55.812]                     muffleCondition(cond, pattern = "^muffle")
[11:02:55.812]                   }
[11:02:55.812]                 }
[11:02:55.812]                 else {
[11:02:55.812]                   if (TRUE) {
[11:02:55.812]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:55.812]                     {
[11:02:55.812]                       inherits <- base::inherits
[11:02:55.812]                       invokeRestart <- base::invokeRestart
[11:02:55.812]                       is.null <- base::is.null
[11:02:55.812]                       muffled <- FALSE
[11:02:55.812]                       if (inherits(cond, "message")) {
[11:02:55.812]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:55.812]                         if (muffled) 
[11:02:55.812]                           invokeRestart("muffleMessage")
[11:02:55.812]                       }
[11:02:55.812]                       else if (inherits(cond, "warning")) {
[11:02:55.812]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:55.812]                         if (muffled) 
[11:02:55.812]                           invokeRestart("muffleWarning")
[11:02:55.812]                       }
[11:02:55.812]                       else if (inherits(cond, "condition")) {
[11:02:55.812]                         if (!is.null(pattern)) {
[11:02:55.812]                           computeRestarts <- base::computeRestarts
[11:02:55.812]                           grepl <- base::grepl
[11:02:55.812]                           restarts <- computeRestarts(cond)
[11:02:55.812]                           for (restart in restarts) {
[11:02:55.812]                             name <- restart$name
[11:02:55.812]                             if (is.null(name)) 
[11:02:55.812]                               next
[11:02:55.812]                             if (!grepl(pattern, name)) 
[11:02:55.812]                               next
[11:02:55.812]                             invokeRestart(restart)
[11:02:55.812]                             muffled <- TRUE
[11:02:55.812]                             break
[11:02:55.812]                           }
[11:02:55.812]                         }
[11:02:55.812]                       }
[11:02:55.812]                       invisible(muffled)
[11:02:55.812]                     }
[11:02:55.812]                     muffleCondition(cond, pattern = "^muffle")
[11:02:55.812]                   }
[11:02:55.812]                 }
[11:02:55.812]             }
[11:02:55.812]         }))
[11:02:55.812]     }, error = function(ex) {
[11:02:55.812]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:55.812]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:55.812]                 ...future.rng), started = ...future.startTime, 
[11:02:55.812]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:55.812]             version = "1.8"), class = "FutureResult")
[11:02:55.812]     }, finally = {
[11:02:55.812]         if (!identical(...future.workdir, getwd())) 
[11:02:55.812]             setwd(...future.workdir)
[11:02:55.812]         {
[11:02:55.812]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:55.812]                 ...future.oldOptions$nwarnings <- NULL
[11:02:55.812]             }
[11:02:55.812]             base::options(...future.oldOptions)
[11:02:55.812]             if (.Platform$OS.type == "windows") {
[11:02:55.812]                 old_names <- names(...future.oldEnvVars)
[11:02:55.812]                 envs <- base::Sys.getenv()
[11:02:55.812]                 names <- names(envs)
[11:02:55.812]                 common <- intersect(names, old_names)
[11:02:55.812]                 added <- setdiff(names, old_names)
[11:02:55.812]                 removed <- setdiff(old_names, names)
[11:02:55.812]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:55.812]                   envs[common]]
[11:02:55.812]                 NAMES <- toupper(changed)
[11:02:55.812]                 args <- list()
[11:02:55.812]                 for (kk in seq_along(NAMES)) {
[11:02:55.812]                   name <- changed[[kk]]
[11:02:55.812]                   NAME <- NAMES[[kk]]
[11:02:55.812]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:55.812]                     next
[11:02:55.812]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:55.812]                 }
[11:02:55.812]                 NAMES <- toupper(added)
[11:02:55.812]                 for (kk in seq_along(NAMES)) {
[11:02:55.812]                   name <- added[[kk]]
[11:02:55.812]                   NAME <- NAMES[[kk]]
[11:02:55.812]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:55.812]                     next
[11:02:55.812]                   args[[name]] <- ""
[11:02:55.812]                 }
[11:02:55.812]                 NAMES <- toupper(removed)
[11:02:55.812]                 for (kk in seq_along(NAMES)) {
[11:02:55.812]                   name <- removed[[kk]]
[11:02:55.812]                   NAME <- NAMES[[kk]]
[11:02:55.812]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:55.812]                     next
[11:02:55.812]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:55.812]                 }
[11:02:55.812]                 if (length(args) > 0) 
[11:02:55.812]                   base::do.call(base::Sys.setenv, args = args)
[11:02:55.812]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:55.812]             }
[11:02:55.812]             else {
[11:02:55.812]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:55.812]             }
[11:02:55.812]             {
[11:02:55.812]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:55.812]                   0L) {
[11:02:55.812]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:55.812]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:55.812]                   base::options(opts)
[11:02:55.812]                 }
[11:02:55.812]                 {
[11:02:55.812]                   {
[11:02:55.812]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:55.812]                     NULL
[11:02:55.812]                   }
[11:02:55.812]                   options(future.plan = NULL)
[11:02:55.812]                   if (is.na(NA_character_)) 
[11:02:55.812]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:55.812]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:55.812]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:55.812]                     .init = FALSE)
[11:02:55.812]                 }
[11:02:55.812]             }
[11:02:55.812]         }
[11:02:55.812]     })
[11:02:55.812]     if (TRUE) {
[11:02:55.812]         base::sink(type = "output", split = FALSE)
[11:02:55.812]         if (TRUE) {
[11:02:55.812]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:55.812]         }
[11:02:55.812]         else {
[11:02:55.812]             ...future.result["stdout"] <- base::list(NULL)
[11:02:55.812]         }
[11:02:55.812]         base::close(...future.stdout)
[11:02:55.812]         ...future.stdout <- NULL
[11:02:55.812]     }
[11:02:55.812]     ...future.result$conditions <- ...future.conditions
[11:02:55.812]     ...future.result$finished <- base::Sys.time()
[11:02:55.812]     ...future.result
[11:02:55.812] }
[11:02:55.815] MultisessionFuture started
[11:02:55.815] - Launch lazy future ... done
[11:02:55.815] run() for ‘MultisessionFuture’ ... done
[11:02:56.358] receiveMessageFromWorker() for ClusterFuture ...
[11:02:56.358] - Validating connection of MultisessionFuture
[11:02:56.358] - received message: FutureResult
[11:02:56.358] - Received FutureResult
[11:02:56.358] - Erased future from FutureRegistry
[11:02:56.359] result() for ClusterFuture ...
[11:02:56.359] - result already collected: FutureResult
[11:02:56.359] result() for ClusterFuture ... done
[11:02:56.359] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:56.359] resolve() on list ...
[11:02:56.359]  recursive: Inf
[11:02:56.359]  length: 2
[11:02:56.359]  elements: ‘a’, ‘b’
[11:02:56.359]  length: 1 (resolved future 1)
[11:02:56.359]  length: 0 (resolved future 2)
[11:02:56.359] resolve() on list ... DONE
[11:02:56.360] A MultisessionFuture was resolved (and resolved itself)
- w/ exception ...
[11:02:56.360] getGlobalsAndPackages() ...
[11:02:56.360] Searching for globals...
[11:02:56.360] - globals found: [2] ‘list’, ‘stop’
[11:02:56.361] Searching for globals ... DONE
[11:02:56.361] Resolving globals: FALSE
[11:02:56.361] 
[11:02:56.361] 
[11:02:56.361] getGlobalsAndPackages() ... DONE
[11:02:56.361] run() for ‘Future’ ...
[11:02:56.361] - state: ‘created’
[11:02:56.362] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:56.375] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:56.375] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:56.375]   - Field: ‘node’
[11:02:56.375]   - Field: ‘label’
[11:02:56.375]   - Field: ‘local’
[11:02:56.376]   - Field: ‘owner’
[11:02:56.376]   - Field: ‘envir’
[11:02:56.376]   - Field: ‘workers’
[11:02:56.376]   - Field: ‘packages’
[11:02:56.376]   - Field: ‘gc’
[11:02:56.376]   - Field: ‘conditions’
[11:02:56.376]   - Field: ‘persistent’
[11:02:56.376]   - Field: ‘expr’
[11:02:56.376]   - Field: ‘uuid’
[11:02:56.376]   - Field: ‘seed’
[11:02:56.376]   - Field: ‘version’
[11:02:56.376]   - Field: ‘result’
[11:02:56.377]   - Field: ‘asynchronous’
[11:02:56.377]   - Field: ‘calls’
[11:02:56.377]   - Field: ‘globals’
[11:02:56.377]   - Field: ‘stdout’
[11:02:56.377]   - Field: ‘earlySignal’
[11:02:56.377]   - Field: ‘lazy’
[11:02:56.377]   - Field: ‘state’
[11:02:56.377] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:56.377] - Launch lazy future ...
[11:02:56.377] Packages needed by the future expression (n = 0): <none>
[11:02:56.378] Packages needed by future strategies (n = 0): <none>
[11:02:56.378] {
[11:02:56.378]     {
[11:02:56.378]         {
[11:02:56.378]             ...future.startTime <- base::Sys.time()
[11:02:56.378]             {
[11:02:56.378]                 {
[11:02:56.378]                   {
[11:02:56.378]                     {
[11:02:56.378]                       base::local({
[11:02:56.378]                         has_future <- base::requireNamespace("future", 
[11:02:56.378]                           quietly = TRUE)
[11:02:56.378]                         if (has_future) {
[11:02:56.378]                           ns <- base::getNamespace("future")
[11:02:56.378]                           version <- ns[[".package"]][["version"]]
[11:02:56.378]                           if (is.null(version)) 
[11:02:56.378]                             version <- utils::packageVersion("future")
[11:02:56.378]                         }
[11:02:56.378]                         else {
[11:02:56.378]                           version <- NULL
[11:02:56.378]                         }
[11:02:56.378]                         if (!has_future || version < "1.8.0") {
[11:02:56.378]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:56.378]                             "", base::R.version$version.string), 
[11:02:56.378]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:56.378]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:56.378]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:56.378]                               "release", "version")], collapse = " "), 
[11:02:56.378]                             hostname = base::Sys.info()[["nodename"]])
[11:02:56.378]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:56.378]                             info)
[11:02:56.378]                           info <- base::paste(info, collapse = "; ")
[11:02:56.378]                           if (!has_future) {
[11:02:56.378]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:56.378]                               info)
[11:02:56.378]                           }
[11:02:56.378]                           else {
[11:02:56.378]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:56.378]                               info, version)
[11:02:56.378]                           }
[11:02:56.378]                           base::stop(msg)
[11:02:56.378]                         }
[11:02:56.378]                       })
[11:02:56.378]                     }
[11:02:56.378]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:56.378]                     base::options(mc.cores = 1L)
[11:02:56.378]                   }
[11:02:56.378]                   ...future.strategy.old <- future::plan("list")
[11:02:56.378]                   options(future.plan = NULL)
[11:02:56.378]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:56.378]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:56.378]                 }
[11:02:56.378]                 ...future.workdir <- getwd()
[11:02:56.378]             }
[11:02:56.378]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:56.378]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:56.378]         }
[11:02:56.378]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:56.378]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:56.378]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:56.378]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:56.378]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:56.378]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:56.378]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:56.378]             base::names(...future.oldOptions))
[11:02:56.378]     }
[11:02:56.378]     if (FALSE) {
[11:02:56.378]     }
[11:02:56.378]     else {
[11:02:56.378]         if (TRUE) {
[11:02:56.378]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:56.378]                 open = "w")
[11:02:56.378]         }
[11:02:56.378]         else {
[11:02:56.378]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:56.378]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:56.378]         }
[11:02:56.378]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:56.378]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:56.378]             base::sink(type = "output", split = FALSE)
[11:02:56.378]             base::close(...future.stdout)
[11:02:56.378]         }, add = TRUE)
[11:02:56.378]     }
[11:02:56.378]     ...future.frame <- base::sys.nframe()
[11:02:56.378]     ...future.conditions <- base::list()
[11:02:56.378]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:56.378]     if (FALSE) {
[11:02:56.378]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:56.378]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:56.378]     }
[11:02:56.378]     ...future.result <- base::tryCatch({
[11:02:56.378]         base::withCallingHandlers({
[11:02:56.378]             ...future.value <- base::withVisible(base::local({
[11:02:56.378]                 ...future.makeSendCondition <- base::local({
[11:02:56.378]                   sendCondition <- NULL
[11:02:56.378]                   function(frame = 1L) {
[11:02:56.378]                     if (is.function(sendCondition)) 
[11:02:56.378]                       return(sendCondition)
[11:02:56.378]                     ns <- getNamespace("parallel")
[11:02:56.378]                     if (exists("sendData", mode = "function", 
[11:02:56.378]                       envir = ns)) {
[11:02:56.378]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:56.378]                         envir = ns)
[11:02:56.378]                       envir <- sys.frame(frame)
[11:02:56.378]                       master <- NULL
[11:02:56.378]                       while (!identical(envir, .GlobalEnv) && 
[11:02:56.378]                         !identical(envir, emptyenv())) {
[11:02:56.378]                         if (exists("master", mode = "list", envir = envir, 
[11:02:56.378]                           inherits = FALSE)) {
[11:02:56.378]                           master <- get("master", mode = "list", 
[11:02:56.378]                             envir = envir, inherits = FALSE)
[11:02:56.378]                           if (inherits(master, c("SOCKnode", 
[11:02:56.378]                             "SOCK0node"))) {
[11:02:56.378]                             sendCondition <<- function(cond) {
[11:02:56.378]                               data <- list(type = "VALUE", value = cond, 
[11:02:56.378]                                 success = TRUE)
[11:02:56.378]                               parallel_sendData(master, data)
[11:02:56.378]                             }
[11:02:56.378]                             return(sendCondition)
[11:02:56.378]                           }
[11:02:56.378]                         }
[11:02:56.378]                         frame <- frame + 1L
[11:02:56.378]                         envir <- sys.frame(frame)
[11:02:56.378]                       }
[11:02:56.378]                     }
[11:02:56.378]                     sendCondition <<- function(cond) NULL
[11:02:56.378]                   }
[11:02:56.378]                 })
[11:02:56.378]                 withCallingHandlers({
[11:02:56.378]                   list(a = 1, b = 42L, c = stop("Nah!"))
[11:02:56.378]                 }, immediateCondition = function(cond) {
[11:02:56.378]                   sendCondition <- ...future.makeSendCondition()
[11:02:56.378]                   sendCondition(cond)
[11:02:56.378]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:56.378]                   {
[11:02:56.378]                     inherits <- base::inherits
[11:02:56.378]                     invokeRestart <- base::invokeRestart
[11:02:56.378]                     is.null <- base::is.null
[11:02:56.378]                     muffled <- FALSE
[11:02:56.378]                     if (inherits(cond, "message")) {
[11:02:56.378]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:56.378]                       if (muffled) 
[11:02:56.378]                         invokeRestart("muffleMessage")
[11:02:56.378]                     }
[11:02:56.378]                     else if (inherits(cond, "warning")) {
[11:02:56.378]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:56.378]                       if (muffled) 
[11:02:56.378]                         invokeRestart("muffleWarning")
[11:02:56.378]                     }
[11:02:56.378]                     else if (inherits(cond, "condition")) {
[11:02:56.378]                       if (!is.null(pattern)) {
[11:02:56.378]                         computeRestarts <- base::computeRestarts
[11:02:56.378]                         grepl <- base::grepl
[11:02:56.378]                         restarts <- computeRestarts(cond)
[11:02:56.378]                         for (restart in restarts) {
[11:02:56.378]                           name <- restart$name
[11:02:56.378]                           if (is.null(name)) 
[11:02:56.378]                             next
[11:02:56.378]                           if (!grepl(pattern, name)) 
[11:02:56.378]                             next
[11:02:56.378]                           invokeRestart(restart)
[11:02:56.378]                           muffled <- TRUE
[11:02:56.378]                           break
[11:02:56.378]                         }
[11:02:56.378]                       }
[11:02:56.378]                     }
[11:02:56.378]                     invisible(muffled)
[11:02:56.378]                   }
[11:02:56.378]                   muffleCondition(cond)
[11:02:56.378]                 })
[11:02:56.378]             }))
[11:02:56.378]             future::FutureResult(value = ...future.value$value, 
[11:02:56.378]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:56.378]                   ...future.rng), globalenv = if (FALSE) 
[11:02:56.378]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:56.378]                     ...future.globalenv.names))
[11:02:56.378]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:56.378]         }, condition = base::local({
[11:02:56.378]             c <- base::c
[11:02:56.378]             inherits <- base::inherits
[11:02:56.378]             invokeRestart <- base::invokeRestart
[11:02:56.378]             length <- base::length
[11:02:56.378]             list <- base::list
[11:02:56.378]             seq.int <- base::seq.int
[11:02:56.378]             signalCondition <- base::signalCondition
[11:02:56.378]             sys.calls <- base::sys.calls
[11:02:56.378]             `[[` <- base::`[[`
[11:02:56.378]             `+` <- base::`+`
[11:02:56.378]             `<<-` <- base::`<<-`
[11:02:56.378]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:56.378]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:56.378]                   3L)]
[11:02:56.378]             }
[11:02:56.378]             function(cond) {
[11:02:56.378]                 is_error <- inherits(cond, "error")
[11:02:56.378]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:56.378]                   NULL)
[11:02:56.378]                 if (is_error) {
[11:02:56.378]                   sessionInformation <- function() {
[11:02:56.378]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:56.378]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:56.378]                       search = base::search(), system = base::Sys.info())
[11:02:56.378]                   }
[11:02:56.378]                   ...future.conditions[[length(...future.conditions) + 
[11:02:56.378]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:56.378]                     cond$call), session = sessionInformation(), 
[11:02:56.378]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:56.378]                   signalCondition(cond)
[11:02:56.378]                 }
[11:02:56.378]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:56.378]                 "immediateCondition"))) {
[11:02:56.378]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:56.378]                   ...future.conditions[[length(...future.conditions) + 
[11:02:56.378]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:56.378]                   if (TRUE && !signal) {
[11:02:56.378]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:56.378]                     {
[11:02:56.378]                       inherits <- base::inherits
[11:02:56.378]                       invokeRestart <- base::invokeRestart
[11:02:56.378]                       is.null <- base::is.null
[11:02:56.378]                       muffled <- FALSE
[11:02:56.378]                       if (inherits(cond, "message")) {
[11:02:56.378]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:56.378]                         if (muffled) 
[11:02:56.378]                           invokeRestart("muffleMessage")
[11:02:56.378]                       }
[11:02:56.378]                       else if (inherits(cond, "warning")) {
[11:02:56.378]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:56.378]                         if (muffled) 
[11:02:56.378]                           invokeRestart("muffleWarning")
[11:02:56.378]                       }
[11:02:56.378]                       else if (inherits(cond, "condition")) {
[11:02:56.378]                         if (!is.null(pattern)) {
[11:02:56.378]                           computeRestarts <- base::computeRestarts
[11:02:56.378]                           grepl <- base::grepl
[11:02:56.378]                           restarts <- computeRestarts(cond)
[11:02:56.378]                           for (restart in restarts) {
[11:02:56.378]                             name <- restart$name
[11:02:56.378]                             if (is.null(name)) 
[11:02:56.378]                               next
[11:02:56.378]                             if (!grepl(pattern, name)) 
[11:02:56.378]                               next
[11:02:56.378]                             invokeRestart(restart)
[11:02:56.378]                             muffled <- TRUE
[11:02:56.378]                             break
[11:02:56.378]                           }
[11:02:56.378]                         }
[11:02:56.378]                       }
[11:02:56.378]                       invisible(muffled)
[11:02:56.378]                     }
[11:02:56.378]                     muffleCondition(cond, pattern = "^muffle")
[11:02:56.378]                   }
[11:02:56.378]                 }
[11:02:56.378]                 else {
[11:02:56.378]                   if (TRUE) {
[11:02:56.378]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:56.378]                     {
[11:02:56.378]                       inherits <- base::inherits
[11:02:56.378]                       invokeRestart <- base::invokeRestart
[11:02:56.378]                       is.null <- base::is.null
[11:02:56.378]                       muffled <- FALSE
[11:02:56.378]                       if (inherits(cond, "message")) {
[11:02:56.378]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:56.378]                         if (muffled) 
[11:02:56.378]                           invokeRestart("muffleMessage")
[11:02:56.378]                       }
[11:02:56.378]                       else if (inherits(cond, "warning")) {
[11:02:56.378]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:56.378]                         if (muffled) 
[11:02:56.378]                           invokeRestart("muffleWarning")
[11:02:56.378]                       }
[11:02:56.378]                       else if (inherits(cond, "condition")) {
[11:02:56.378]                         if (!is.null(pattern)) {
[11:02:56.378]                           computeRestarts <- base::computeRestarts
[11:02:56.378]                           grepl <- base::grepl
[11:02:56.378]                           restarts <- computeRestarts(cond)
[11:02:56.378]                           for (restart in restarts) {
[11:02:56.378]                             name <- restart$name
[11:02:56.378]                             if (is.null(name)) 
[11:02:56.378]                               next
[11:02:56.378]                             if (!grepl(pattern, name)) 
[11:02:56.378]                               next
[11:02:56.378]                             invokeRestart(restart)
[11:02:56.378]                             muffled <- TRUE
[11:02:56.378]                             break
[11:02:56.378]                           }
[11:02:56.378]                         }
[11:02:56.378]                       }
[11:02:56.378]                       invisible(muffled)
[11:02:56.378]                     }
[11:02:56.378]                     muffleCondition(cond, pattern = "^muffle")
[11:02:56.378]                   }
[11:02:56.378]                 }
[11:02:56.378]             }
[11:02:56.378]         }))
[11:02:56.378]     }, error = function(ex) {
[11:02:56.378]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:56.378]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:56.378]                 ...future.rng), started = ...future.startTime, 
[11:02:56.378]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:56.378]             version = "1.8"), class = "FutureResult")
[11:02:56.378]     }, finally = {
[11:02:56.378]         if (!identical(...future.workdir, getwd())) 
[11:02:56.378]             setwd(...future.workdir)
[11:02:56.378]         {
[11:02:56.378]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:56.378]                 ...future.oldOptions$nwarnings <- NULL
[11:02:56.378]             }
[11:02:56.378]             base::options(...future.oldOptions)
[11:02:56.378]             if (.Platform$OS.type == "windows") {
[11:02:56.378]                 old_names <- names(...future.oldEnvVars)
[11:02:56.378]                 envs <- base::Sys.getenv()
[11:02:56.378]                 names <- names(envs)
[11:02:56.378]                 common <- intersect(names, old_names)
[11:02:56.378]                 added <- setdiff(names, old_names)
[11:02:56.378]                 removed <- setdiff(old_names, names)
[11:02:56.378]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:56.378]                   envs[common]]
[11:02:56.378]                 NAMES <- toupper(changed)
[11:02:56.378]                 args <- list()
[11:02:56.378]                 for (kk in seq_along(NAMES)) {
[11:02:56.378]                   name <- changed[[kk]]
[11:02:56.378]                   NAME <- NAMES[[kk]]
[11:02:56.378]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:56.378]                     next
[11:02:56.378]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:56.378]                 }
[11:02:56.378]                 NAMES <- toupper(added)
[11:02:56.378]                 for (kk in seq_along(NAMES)) {
[11:02:56.378]                   name <- added[[kk]]
[11:02:56.378]                   NAME <- NAMES[[kk]]
[11:02:56.378]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:56.378]                     next
[11:02:56.378]                   args[[name]] <- ""
[11:02:56.378]                 }
[11:02:56.378]                 NAMES <- toupper(removed)
[11:02:56.378]                 for (kk in seq_along(NAMES)) {
[11:02:56.378]                   name <- removed[[kk]]
[11:02:56.378]                   NAME <- NAMES[[kk]]
[11:02:56.378]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:56.378]                     next
[11:02:56.378]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:56.378]                 }
[11:02:56.378]                 if (length(args) > 0) 
[11:02:56.378]                   base::do.call(base::Sys.setenv, args = args)
[11:02:56.378]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:56.378]             }
[11:02:56.378]             else {
[11:02:56.378]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:56.378]             }
[11:02:56.378]             {
[11:02:56.378]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:56.378]                   0L) {
[11:02:56.378]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:56.378]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:56.378]                   base::options(opts)
[11:02:56.378]                 }
[11:02:56.378]                 {
[11:02:56.378]                   {
[11:02:56.378]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:56.378]                     NULL
[11:02:56.378]                   }
[11:02:56.378]                   options(future.plan = NULL)
[11:02:56.378]                   if (is.na(NA_character_)) 
[11:02:56.378]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:56.378]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:56.378]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:56.378]                     .init = FALSE)
[11:02:56.378]                 }
[11:02:56.378]             }
[11:02:56.378]         }
[11:02:56.378]     })
[11:02:56.378]     if (TRUE) {
[11:02:56.378]         base::sink(type = "output", split = FALSE)
[11:02:56.378]         if (TRUE) {
[11:02:56.378]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:56.378]         }
[11:02:56.378]         else {
[11:02:56.378]             ...future.result["stdout"] <- base::list(NULL)
[11:02:56.378]         }
[11:02:56.378]         base::close(...future.stdout)
[11:02:56.378]         ...future.stdout <- NULL
[11:02:56.378]     }
[11:02:56.378]     ...future.result$conditions <- ...future.conditions
[11:02:56.378]     ...future.result$finished <- base::Sys.time()
[11:02:56.378]     ...future.result
[11:02:56.378] }
[11:02:56.381] MultisessionFuture started
[11:02:56.381] - Launch lazy future ... done
[11:02:56.381] run() for ‘MultisessionFuture’ ... done
[11:02:56.423] receiveMessageFromWorker() for ClusterFuture ...
[11:02:56.423] - Validating connection of MultisessionFuture
[11:02:56.424] - received message: FutureResult
[11:02:56.424] - Received FutureResult
[11:02:56.424] - Erased future from FutureRegistry
[11:02:56.424] result() for ClusterFuture ...
[11:02:56.424] - result already collected: FutureResult
[11:02:56.424] result() for ClusterFuture ... done
[11:02:56.424] signalConditions() ...
[11:02:56.424]  - include = ‘immediateCondition’
[11:02:56.424]  - exclude = 
[11:02:56.425]  - resignal = FALSE
[11:02:56.425]  - Number of conditions: 1
[11:02:56.425] signalConditions() ... done
[11:02:56.425] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:56.425] A MultisessionFuture was resolved (and resolved itself)
[11:02:56.425] getGlobalsAndPackages() ...
[11:02:56.425] Searching for globals...
[11:02:56.426] - globals found: [2] ‘list’, ‘stop’
[11:02:56.426] Searching for globals ... DONE
[11:02:56.426] Resolving globals: FALSE
[11:02:56.426] 
[11:02:56.426] 
[11:02:56.426] getGlobalsAndPackages() ... DONE
[11:02:56.427] run() for ‘Future’ ...
[11:02:56.427] - state: ‘created’
[11:02:56.427] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:56.440] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:56.440] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:56.441]   - Field: ‘node’
[11:02:56.441]   - Field: ‘label’
[11:02:56.441]   - Field: ‘local’
[11:02:56.441]   - Field: ‘owner’
[11:02:56.441]   - Field: ‘envir’
[11:02:56.441]   - Field: ‘workers’
[11:02:56.441]   - Field: ‘packages’
[11:02:56.441]   - Field: ‘gc’
[11:02:56.441]   - Field: ‘conditions’
[11:02:56.441]   - Field: ‘persistent’
[11:02:56.441]   - Field: ‘expr’
[11:02:56.442]   - Field: ‘uuid’
[11:02:56.442]   - Field: ‘seed’
[11:02:56.442]   - Field: ‘version’
[11:02:56.442]   - Field: ‘result’
[11:02:56.442]   - Field: ‘asynchronous’
[11:02:56.442]   - Field: ‘calls’
[11:02:56.442]   - Field: ‘globals’
[11:02:56.442]   - Field: ‘stdout’
[11:02:56.442]   - Field: ‘earlySignal’
[11:02:56.442]   - Field: ‘lazy’
[11:02:56.442]   - Field: ‘state’
[11:02:56.442] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:56.443] - Launch lazy future ...
[11:02:56.443] Packages needed by the future expression (n = 0): <none>
[11:02:56.443] Packages needed by future strategies (n = 0): <none>
[11:02:56.443] {
[11:02:56.443]     {
[11:02:56.443]         {
[11:02:56.443]             ...future.startTime <- base::Sys.time()
[11:02:56.443]             {
[11:02:56.443]                 {
[11:02:56.443]                   {
[11:02:56.443]                     {
[11:02:56.443]                       base::local({
[11:02:56.443]                         has_future <- base::requireNamespace("future", 
[11:02:56.443]                           quietly = TRUE)
[11:02:56.443]                         if (has_future) {
[11:02:56.443]                           ns <- base::getNamespace("future")
[11:02:56.443]                           version <- ns[[".package"]][["version"]]
[11:02:56.443]                           if (is.null(version)) 
[11:02:56.443]                             version <- utils::packageVersion("future")
[11:02:56.443]                         }
[11:02:56.443]                         else {
[11:02:56.443]                           version <- NULL
[11:02:56.443]                         }
[11:02:56.443]                         if (!has_future || version < "1.8.0") {
[11:02:56.443]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:56.443]                             "", base::R.version$version.string), 
[11:02:56.443]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:56.443]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:56.443]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:56.443]                               "release", "version")], collapse = " "), 
[11:02:56.443]                             hostname = base::Sys.info()[["nodename"]])
[11:02:56.443]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:56.443]                             info)
[11:02:56.443]                           info <- base::paste(info, collapse = "; ")
[11:02:56.443]                           if (!has_future) {
[11:02:56.443]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:56.443]                               info)
[11:02:56.443]                           }
[11:02:56.443]                           else {
[11:02:56.443]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:56.443]                               info, version)
[11:02:56.443]                           }
[11:02:56.443]                           base::stop(msg)
[11:02:56.443]                         }
[11:02:56.443]                       })
[11:02:56.443]                     }
[11:02:56.443]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:56.443]                     base::options(mc.cores = 1L)
[11:02:56.443]                   }
[11:02:56.443]                   ...future.strategy.old <- future::plan("list")
[11:02:56.443]                   options(future.plan = NULL)
[11:02:56.443]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:56.443]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:56.443]                 }
[11:02:56.443]                 ...future.workdir <- getwd()
[11:02:56.443]             }
[11:02:56.443]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:56.443]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:56.443]         }
[11:02:56.443]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:56.443]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:56.443]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:56.443]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:56.443]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:56.443]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:56.443]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:56.443]             base::names(...future.oldOptions))
[11:02:56.443]     }
[11:02:56.443]     if (FALSE) {
[11:02:56.443]     }
[11:02:56.443]     else {
[11:02:56.443]         if (TRUE) {
[11:02:56.443]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:56.443]                 open = "w")
[11:02:56.443]         }
[11:02:56.443]         else {
[11:02:56.443]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:56.443]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:56.443]         }
[11:02:56.443]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:56.443]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:56.443]             base::sink(type = "output", split = FALSE)
[11:02:56.443]             base::close(...future.stdout)
[11:02:56.443]         }, add = TRUE)
[11:02:56.443]     }
[11:02:56.443]     ...future.frame <- base::sys.nframe()
[11:02:56.443]     ...future.conditions <- base::list()
[11:02:56.443]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:56.443]     if (FALSE) {
[11:02:56.443]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:56.443]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:56.443]     }
[11:02:56.443]     ...future.result <- base::tryCatch({
[11:02:56.443]         base::withCallingHandlers({
[11:02:56.443]             ...future.value <- base::withVisible(base::local({
[11:02:56.443]                 ...future.makeSendCondition <- base::local({
[11:02:56.443]                   sendCondition <- NULL
[11:02:56.443]                   function(frame = 1L) {
[11:02:56.443]                     if (is.function(sendCondition)) 
[11:02:56.443]                       return(sendCondition)
[11:02:56.443]                     ns <- getNamespace("parallel")
[11:02:56.443]                     if (exists("sendData", mode = "function", 
[11:02:56.443]                       envir = ns)) {
[11:02:56.443]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:56.443]                         envir = ns)
[11:02:56.443]                       envir <- sys.frame(frame)
[11:02:56.443]                       master <- NULL
[11:02:56.443]                       while (!identical(envir, .GlobalEnv) && 
[11:02:56.443]                         !identical(envir, emptyenv())) {
[11:02:56.443]                         if (exists("master", mode = "list", envir = envir, 
[11:02:56.443]                           inherits = FALSE)) {
[11:02:56.443]                           master <- get("master", mode = "list", 
[11:02:56.443]                             envir = envir, inherits = FALSE)
[11:02:56.443]                           if (inherits(master, c("SOCKnode", 
[11:02:56.443]                             "SOCK0node"))) {
[11:02:56.443]                             sendCondition <<- function(cond) {
[11:02:56.443]                               data <- list(type = "VALUE", value = cond, 
[11:02:56.443]                                 success = TRUE)
[11:02:56.443]                               parallel_sendData(master, data)
[11:02:56.443]                             }
[11:02:56.443]                             return(sendCondition)
[11:02:56.443]                           }
[11:02:56.443]                         }
[11:02:56.443]                         frame <- frame + 1L
[11:02:56.443]                         envir <- sys.frame(frame)
[11:02:56.443]                       }
[11:02:56.443]                     }
[11:02:56.443]                     sendCondition <<- function(cond) NULL
[11:02:56.443]                   }
[11:02:56.443]                 })
[11:02:56.443]                 withCallingHandlers({
[11:02:56.443]                   list(a = 1, b = 42L, c = stop("Nah!"))
[11:02:56.443]                 }, immediateCondition = function(cond) {
[11:02:56.443]                   sendCondition <- ...future.makeSendCondition()
[11:02:56.443]                   sendCondition(cond)
[11:02:56.443]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:56.443]                   {
[11:02:56.443]                     inherits <- base::inherits
[11:02:56.443]                     invokeRestart <- base::invokeRestart
[11:02:56.443]                     is.null <- base::is.null
[11:02:56.443]                     muffled <- FALSE
[11:02:56.443]                     if (inherits(cond, "message")) {
[11:02:56.443]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:56.443]                       if (muffled) 
[11:02:56.443]                         invokeRestart("muffleMessage")
[11:02:56.443]                     }
[11:02:56.443]                     else if (inherits(cond, "warning")) {
[11:02:56.443]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:56.443]                       if (muffled) 
[11:02:56.443]                         invokeRestart("muffleWarning")
[11:02:56.443]                     }
[11:02:56.443]                     else if (inherits(cond, "condition")) {
[11:02:56.443]                       if (!is.null(pattern)) {
[11:02:56.443]                         computeRestarts <- base::computeRestarts
[11:02:56.443]                         grepl <- base::grepl
[11:02:56.443]                         restarts <- computeRestarts(cond)
[11:02:56.443]                         for (restart in restarts) {
[11:02:56.443]                           name <- restart$name
[11:02:56.443]                           if (is.null(name)) 
[11:02:56.443]                             next
[11:02:56.443]                           if (!grepl(pattern, name)) 
[11:02:56.443]                             next
[11:02:56.443]                           invokeRestart(restart)
[11:02:56.443]                           muffled <- TRUE
[11:02:56.443]                           break
[11:02:56.443]                         }
[11:02:56.443]                       }
[11:02:56.443]                     }
[11:02:56.443]                     invisible(muffled)
[11:02:56.443]                   }
[11:02:56.443]                   muffleCondition(cond)
[11:02:56.443]                 })
[11:02:56.443]             }))
[11:02:56.443]             future::FutureResult(value = ...future.value$value, 
[11:02:56.443]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:56.443]                   ...future.rng), globalenv = if (FALSE) 
[11:02:56.443]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:56.443]                     ...future.globalenv.names))
[11:02:56.443]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:56.443]         }, condition = base::local({
[11:02:56.443]             c <- base::c
[11:02:56.443]             inherits <- base::inherits
[11:02:56.443]             invokeRestart <- base::invokeRestart
[11:02:56.443]             length <- base::length
[11:02:56.443]             list <- base::list
[11:02:56.443]             seq.int <- base::seq.int
[11:02:56.443]             signalCondition <- base::signalCondition
[11:02:56.443]             sys.calls <- base::sys.calls
[11:02:56.443]             `[[` <- base::`[[`
[11:02:56.443]             `+` <- base::`+`
[11:02:56.443]             `<<-` <- base::`<<-`
[11:02:56.443]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:56.443]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:56.443]                   3L)]
[11:02:56.443]             }
[11:02:56.443]             function(cond) {
[11:02:56.443]                 is_error <- inherits(cond, "error")
[11:02:56.443]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:56.443]                   NULL)
[11:02:56.443]                 if (is_error) {
[11:02:56.443]                   sessionInformation <- function() {
[11:02:56.443]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:56.443]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:56.443]                       search = base::search(), system = base::Sys.info())
[11:02:56.443]                   }
[11:02:56.443]                   ...future.conditions[[length(...future.conditions) + 
[11:02:56.443]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:56.443]                     cond$call), session = sessionInformation(), 
[11:02:56.443]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:56.443]                   signalCondition(cond)
[11:02:56.443]                 }
[11:02:56.443]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:56.443]                 "immediateCondition"))) {
[11:02:56.443]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:56.443]                   ...future.conditions[[length(...future.conditions) + 
[11:02:56.443]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:56.443]                   if (TRUE && !signal) {
[11:02:56.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:56.443]                     {
[11:02:56.443]                       inherits <- base::inherits
[11:02:56.443]                       invokeRestart <- base::invokeRestart
[11:02:56.443]                       is.null <- base::is.null
[11:02:56.443]                       muffled <- FALSE
[11:02:56.443]                       if (inherits(cond, "message")) {
[11:02:56.443]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:56.443]                         if (muffled) 
[11:02:56.443]                           invokeRestart("muffleMessage")
[11:02:56.443]                       }
[11:02:56.443]                       else if (inherits(cond, "warning")) {
[11:02:56.443]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:56.443]                         if (muffled) 
[11:02:56.443]                           invokeRestart("muffleWarning")
[11:02:56.443]                       }
[11:02:56.443]                       else if (inherits(cond, "condition")) {
[11:02:56.443]                         if (!is.null(pattern)) {
[11:02:56.443]                           computeRestarts <- base::computeRestarts
[11:02:56.443]                           grepl <- base::grepl
[11:02:56.443]                           restarts <- computeRestarts(cond)
[11:02:56.443]                           for (restart in restarts) {
[11:02:56.443]                             name <- restart$name
[11:02:56.443]                             if (is.null(name)) 
[11:02:56.443]                               next
[11:02:56.443]                             if (!grepl(pattern, name)) 
[11:02:56.443]                               next
[11:02:56.443]                             invokeRestart(restart)
[11:02:56.443]                             muffled <- TRUE
[11:02:56.443]                             break
[11:02:56.443]                           }
[11:02:56.443]                         }
[11:02:56.443]                       }
[11:02:56.443]                       invisible(muffled)
[11:02:56.443]                     }
[11:02:56.443]                     muffleCondition(cond, pattern = "^muffle")
[11:02:56.443]                   }
[11:02:56.443]                 }
[11:02:56.443]                 else {
[11:02:56.443]                   if (TRUE) {
[11:02:56.443]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:56.443]                     {
[11:02:56.443]                       inherits <- base::inherits
[11:02:56.443]                       invokeRestart <- base::invokeRestart
[11:02:56.443]                       is.null <- base::is.null
[11:02:56.443]                       muffled <- FALSE
[11:02:56.443]                       if (inherits(cond, "message")) {
[11:02:56.443]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:56.443]                         if (muffled) 
[11:02:56.443]                           invokeRestart("muffleMessage")
[11:02:56.443]                       }
[11:02:56.443]                       else if (inherits(cond, "warning")) {
[11:02:56.443]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:56.443]                         if (muffled) 
[11:02:56.443]                           invokeRestart("muffleWarning")
[11:02:56.443]                       }
[11:02:56.443]                       else if (inherits(cond, "condition")) {
[11:02:56.443]                         if (!is.null(pattern)) {
[11:02:56.443]                           computeRestarts <- base::computeRestarts
[11:02:56.443]                           grepl <- base::grepl
[11:02:56.443]                           restarts <- computeRestarts(cond)
[11:02:56.443]                           for (restart in restarts) {
[11:02:56.443]                             name <- restart$name
[11:02:56.443]                             if (is.null(name)) 
[11:02:56.443]                               next
[11:02:56.443]                             if (!grepl(pattern, name)) 
[11:02:56.443]                               next
[11:02:56.443]                             invokeRestart(restart)
[11:02:56.443]                             muffled <- TRUE
[11:02:56.443]                             break
[11:02:56.443]                           }
[11:02:56.443]                         }
[11:02:56.443]                       }
[11:02:56.443]                       invisible(muffled)
[11:02:56.443]                     }
[11:02:56.443]                     muffleCondition(cond, pattern = "^muffle")
[11:02:56.443]                   }
[11:02:56.443]                 }
[11:02:56.443]             }
[11:02:56.443]         }))
[11:02:56.443]     }, error = function(ex) {
[11:02:56.443]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:56.443]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:56.443]                 ...future.rng), started = ...future.startTime, 
[11:02:56.443]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:56.443]             version = "1.8"), class = "FutureResult")
[11:02:56.443]     }, finally = {
[11:02:56.443]         if (!identical(...future.workdir, getwd())) 
[11:02:56.443]             setwd(...future.workdir)
[11:02:56.443]         {
[11:02:56.443]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:56.443]                 ...future.oldOptions$nwarnings <- NULL
[11:02:56.443]             }
[11:02:56.443]             base::options(...future.oldOptions)
[11:02:56.443]             if (.Platform$OS.type == "windows") {
[11:02:56.443]                 old_names <- names(...future.oldEnvVars)
[11:02:56.443]                 envs <- base::Sys.getenv()
[11:02:56.443]                 names <- names(envs)
[11:02:56.443]                 common <- intersect(names, old_names)
[11:02:56.443]                 added <- setdiff(names, old_names)
[11:02:56.443]                 removed <- setdiff(old_names, names)
[11:02:56.443]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:56.443]                   envs[common]]
[11:02:56.443]                 NAMES <- toupper(changed)
[11:02:56.443]                 args <- list()
[11:02:56.443]                 for (kk in seq_along(NAMES)) {
[11:02:56.443]                   name <- changed[[kk]]
[11:02:56.443]                   NAME <- NAMES[[kk]]
[11:02:56.443]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:56.443]                     next
[11:02:56.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:56.443]                 }
[11:02:56.443]                 NAMES <- toupper(added)
[11:02:56.443]                 for (kk in seq_along(NAMES)) {
[11:02:56.443]                   name <- added[[kk]]
[11:02:56.443]                   NAME <- NAMES[[kk]]
[11:02:56.443]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:56.443]                     next
[11:02:56.443]                   args[[name]] <- ""
[11:02:56.443]                 }
[11:02:56.443]                 NAMES <- toupper(removed)
[11:02:56.443]                 for (kk in seq_along(NAMES)) {
[11:02:56.443]                   name <- removed[[kk]]
[11:02:56.443]                   NAME <- NAMES[[kk]]
[11:02:56.443]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:56.443]                     next
[11:02:56.443]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:56.443]                 }
[11:02:56.443]                 if (length(args) > 0) 
[11:02:56.443]                   base::do.call(base::Sys.setenv, args = args)
[11:02:56.443]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:56.443]             }
[11:02:56.443]             else {
[11:02:56.443]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:56.443]             }
[11:02:56.443]             {
[11:02:56.443]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:56.443]                   0L) {
[11:02:56.443]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:56.443]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:56.443]                   base::options(opts)
[11:02:56.443]                 }
[11:02:56.443]                 {
[11:02:56.443]                   {
[11:02:56.443]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:56.443]                     NULL
[11:02:56.443]                   }
[11:02:56.443]                   options(future.plan = NULL)
[11:02:56.443]                   if (is.na(NA_character_)) 
[11:02:56.443]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:56.443]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:56.443]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:56.443]                     .init = FALSE)
[11:02:56.443]                 }
[11:02:56.443]             }
[11:02:56.443]         }
[11:02:56.443]     })
[11:02:56.443]     if (TRUE) {
[11:02:56.443]         base::sink(type = "output", split = FALSE)
[11:02:56.443]         if (TRUE) {
[11:02:56.443]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:56.443]         }
[11:02:56.443]         else {
[11:02:56.443]             ...future.result["stdout"] <- base::list(NULL)
[11:02:56.443]         }
[11:02:56.443]         base::close(...future.stdout)
[11:02:56.443]         ...future.stdout <- NULL
[11:02:56.443]     }
[11:02:56.443]     ...future.result$conditions <- ...future.conditions
[11:02:56.443]     ...future.result$finished <- base::Sys.time()
[11:02:56.443]     ...future.result
[11:02:56.443] }
[11:02:56.446] MultisessionFuture started
[11:02:56.446] - Launch lazy future ... done
[11:02:56.446] run() for ‘MultisessionFuture’ ... done
[11:02:56.488] receiveMessageFromWorker() for ClusterFuture ...
[11:02:56.488] - Validating connection of MultisessionFuture
[11:02:56.488] - received message: FutureResult
[11:02:56.489] - Received FutureResult
[11:02:56.489] - Erased future from FutureRegistry
[11:02:56.489] result() for ClusterFuture ...
[11:02:56.489] - result already collected: FutureResult
[11:02:56.489] result() for ClusterFuture ... done
[11:02:56.489] signalConditions() ...
[11:02:56.489]  - include = ‘immediateCondition’
[11:02:56.489]  - exclude = 
[11:02:56.489]  - resignal = FALSE
[11:02:56.489]  - Number of conditions: 1
[11:02:56.489] signalConditions() ... done
[11:02:56.490] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:56.490] A MultisessionFuture was resolved (and resolved itself)
- result = TRUE, recursive = Inf ... DONE
*** resolve() for Future objects ... DONE
*** resolve() for lists ...
[11:02:56.490] resolve() on list ...
[11:02:56.490]  recursive: 0
[11:02:56.490]  length: 2
[11:02:56.490]  elements: ‘a’, ‘b’
[11:02:56.490]  length: 1 (resolved future 1)
[11:02:56.490]  length: 0 (resolved future 2)
[11:02:56.490] resolve() on list ... DONE
[11:02:56.491] getGlobalsAndPackages() ...
[11:02:56.491] Searching for globals...
[11:02:56.491] 
[11:02:56.491] Searching for globals ... DONE
[11:02:56.491] - globals: [0] <none>
[11:02:56.491] getGlobalsAndPackages() ... DONE
[11:02:56.491] run() for ‘Future’ ...
[11:02:56.491] - state: ‘created’
[11:02:56.492] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:56.505] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:56.505] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:56.505]   - Field: ‘node’
[11:02:56.505]   - Field: ‘label’
[11:02:56.505]   - Field: ‘local’
[11:02:56.505]   - Field: ‘owner’
[11:02:56.506]   - Field: ‘envir’
[11:02:56.506]   - Field: ‘workers’
[11:02:56.506]   - Field: ‘packages’
[11:02:56.506]   - Field: ‘gc’
[11:02:56.506]   - Field: ‘conditions’
[11:02:56.506]   - Field: ‘persistent’
[11:02:56.506]   - Field: ‘expr’
[11:02:56.506]   - Field: ‘uuid’
[11:02:56.506]   - Field: ‘seed’
[11:02:56.506]   - Field: ‘version’
[11:02:56.506]   - Field: ‘result’
[11:02:56.506]   - Field: ‘asynchronous’
[11:02:56.507]   - Field: ‘calls’
[11:02:56.507]   - Field: ‘globals’
[11:02:56.507]   - Field: ‘stdout’
[11:02:56.507]   - Field: ‘earlySignal’
[11:02:56.507]   - Field: ‘lazy’
[11:02:56.507]   - Field: ‘state’
[11:02:56.507] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:56.507] - Launch lazy future ...
[11:02:56.507] Packages needed by the future expression (n = 0): <none>
[11:02:56.507] Packages needed by future strategies (n = 0): <none>
[11:02:56.508] {
[11:02:56.508]     {
[11:02:56.508]         {
[11:02:56.508]             ...future.startTime <- base::Sys.time()
[11:02:56.508]             {
[11:02:56.508]                 {
[11:02:56.508]                   {
[11:02:56.508]                     {
[11:02:56.508]                       base::local({
[11:02:56.508]                         has_future <- base::requireNamespace("future", 
[11:02:56.508]                           quietly = TRUE)
[11:02:56.508]                         if (has_future) {
[11:02:56.508]                           ns <- base::getNamespace("future")
[11:02:56.508]                           version <- ns[[".package"]][["version"]]
[11:02:56.508]                           if (is.null(version)) 
[11:02:56.508]                             version <- utils::packageVersion("future")
[11:02:56.508]                         }
[11:02:56.508]                         else {
[11:02:56.508]                           version <- NULL
[11:02:56.508]                         }
[11:02:56.508]                         if (!has_future || version < "1.8.0") {
[11:02:56.508]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:56.508]                             "", base::R.version$version.string), 
[11:02:56.508]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:56.508]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:56.508]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:56.508]                               "release", "version")], collapse = " "), 
[11:02:56.508]                             hostname = base::Sys.info()[["nodename"]])
[11:02:56.508]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:56.508]                             info)
[11:02:56.508]                           info <- base::paste(info, collapse = "; ")
[11:02:56.508]                           if (!has_future) {
[11:02:56.508]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:56.508]                               info)
[11:02:56.508]                           }
[11:02:56.508]                           else {
[11:02:56.508]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:56.508]                               info, version)
[11:02:56.508]                           }
[11:02:56.508]                           base::stop(msg)
[11:02:56.508]                         }
[11:02:56.508]                       })
[11:02:56.508]                     }
[11:02:56.508]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:56.508]                     base::options(mc.cores = 1L)
[11:02:56.508]                   }
[11:02:56.508]                   ...future.strategy.old <- future::plan("list")
[11:02:56.508]                   options(future.plan = NULL)
[11:02:56.508]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:56.508]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:56.508]                 }
[11:02:56.508]                 ...future.workdir <- getwd()
[11:02:56.508]             }
[11:02:56.508]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:56.508]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:56.508]         }
[11:02:56.508]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:56.508]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:56.508]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:56.508]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:56.508]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:56.508]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:56.508]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:56.508]             base::names(...future.oldOptions))
[11:02:56.508]     }
[11:02:56.508]     if (FALSE) {
[11:02:56.508]     }
[11:02:56.508]     else {
[11:02:56.508]         if (TRUE) {
[11:02:56.508]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:56.508]                 open = "w")
[11:02:56.508]         }
[11:02:56.508]         else {
[11:02:56.508]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:56.508]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:56.508]         }
[11:02:56.508]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:56.508]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:56.508]             base::sink(type = "output", split = FALSE)
[11:02:56.508]             base::close(...future.stdout)
[11:02:56.508]         }, add = TRUE)
[11:02:56.508]     }
[11:02:56.508]     ...future.frame <- base::sys.nframe()
[11:02:56.508]     ...future.conditions <- base::list()
[11:02:56.508]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:56.508]     if (FALSE) {
[11:02:56.508]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:56.508]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:56.508]     }
[11:02:56.508]     ...future.result <- base::tryCatch({
[11:02:56.508]         base::withCallingHandlers({
[11:02:56.508]             ...future.value <- base::withVisible(base::local({
[11:02:56.508]                 ...future.makeSendCondition <- base::local({
[11:02:56.508]                   sendCondition <- NULL
[11:02:56.508]                   function(frame = 1L) {
[11:02:56.508]                     if (is.function(sendCondition)) 
[11:02:56.508]                       return(sendCondition)
[11:02:56.508]                     ns <- getNamespace("parallel")
[11:02:56.508]                     if (exists("sendData", mode = "function", 
[11:02:56.508]                       envir = ns)) {
[11:02:56.508]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:56.508]                         envir = ns)
[11:02:56.508]                       envir <- sys.frame(frame)
[11:02:56.508]                       master <- NULL
[11:02:56.508]                       while (!identical(envir, .GlobalEnv) && 
[11:02:56.508]                         !identical(envir, emptyenv())) {
[11:02:56.508]                         if (exists("master", mode = "list", envir = envir, 
[11:02:56.508]                           inherits = FALSE)) {
[11:02:56.508]                           master <- get("master", mode = "list", 
[11:02:56.508]                             envir = envir, inherits = FALSE)
[11:02:56.508]                           if (inherits(master, c("SOCKnode", 
[11:02:56.508]                             "SOCK0node"))) {
[11:02:56.508]                             sendCondition <<- function(cond) {
[11:02:56.508]                               data <- list(type = "VALUE", value = cond, 
[11:02:56.508]                                 success = TRUE)
[11:02:56.508]                               parallel_sendData(master, data)
[11:02:56.508]                             }
[11:02:56.508]                             return(sendCondition)
[11:02:56.508]                           }
[11:02:56.508]                         }
[11:02:56.508]                         frame <- frame + 1L
[11:02:56.508]                         envir <- sys.frame(frame)
[11:02:56.508]                       }
[11:02:56.508]                     }
[11:02:56.508]                     sendCondition <<- function(cond) NULL
[11:02:56.508]                   }
[11:02:56.508]                 })
[11:02:56.508]                 withCallingHandlers({
[11:02:56.508]                   1
[11:02:56.508]                 }, immediateCondition = function(cond) {
[11:02:56.508]                   sendCondition <- ...future.makeSendCondition()
[11:02:56.508]                   sendCondition(cond)
[11:02:56.508]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:56.508]                   {
[11:02:56.508]                     inherits <- base::inherits
[11:02:56.508]                     invokeRestart <- base::invokeRestart
[11:02:56.508]                     is.null <- base::is.null
[11:02:56.508]                     muffled <- FALSE
[11:02:56.508]                     if (inherits(cond, "message")) {
[11:02:56.508]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:56.508]                       if (muffled) 
[11:02:56.508]                         invokeRestart("muffleMessage")
[11:02:56.508]                     }
[11:02:56.508]                     else if (inherits(cond, "warning")) {
[11:02:56.508]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:56.508]                       if (muffled) 
[11:02:56.508]                         invokeRestart("muffleWarning")
[11:02:56.508]                     }
[11:02:56.508]                     else if (inherits(cond, "condition")) {
[11:02:56.508]                       if (!is.null(pattern)) {
[11:02:56.508]                         computeRestarts <- base::computeRestarts
[11:02:56.508]                         grepl <- base::grepl
[11:02:56.508]                         restarts <- computeRestarts(cond)
[11:02:56.508]                         for (restart in restarts) {
[11:02:56.508]                           name <- restart$name
[11:02:56.508]                           if (is.null(name)) 
[11:02:56.508]                             next
[11:02:56.508]                           if (!grepl(pattern, name)) 
[11:02:56.508]                             next
[11:02:56.508]                           invokeRestart(restart)
[11:02:56.508]                           muffled <- TRUE
[11:02:56.508]                           break
[11:02:56.508]                         }
[11:02:56.508]                       }
[11:02:56.508]                     }
[11:02:56.508]                     invisible(muffled)
[11:02:56.508]                   }
[11:02:56.508]                   muffleCondition(cond)
[11:02:56.508]                 })
[11:02:56.508]             }))
[11:02:56.508]             future::FutureResult(value = ...future.value$value, 
[11:02:56.508]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:56.508]                   ...future.rng), globalenv = if (FALSE) 
[11:02:56.508]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:56.508]                     ...future.globalenv.names))
[11:02:56.508]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:56.508]         }, condition = base::local({
[11:02:56.508]             c <- base::c
[11:02:56.508]             inherits <- base::inherits
[11:02:56.508]             invokeRestart <- base::invokeRestart
[11:02:56.508]             length <- base::length
[11:02:56.508]             list <- base::list
[11:02:56.508]             seq.int <- base::seq.int
[11:02:56.508]             signalCondition <- base::signalCondition
[11:02:56.508]             sys.calls <- base::sys.calls
[11:02:56.508]             `[[` <- base::`[[`
[11:02:56.508]             `+` <- base::`+`
[11:02:56.508]             `<<-` <- base::`<<-`
[11:02:56.508]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:56.508]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:56.508]                   3L)]
[11:02:56.508]             }
[11:02:56.508]             function(cond) {
[11:02:56.508]                 is_error <- inherits(cond, "error")
[11:02:56.508]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:56.508]                   NULL)
[11:02:56.508]                 if (is_error) {
[11:02:56.508]                   sessionInformation <- function() {
[11:02:56.508]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:56.508]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:56.508]                       search = base::search(), system = base::Sys.info())
[11:02:56.508]                   }
[11:02:56.508]                   ...future.conditions[[length(...future.conditions) + 
[11:02:56.508]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:56.508]                     cond$call), session = sessionInformation(), 
[11:02:56.508]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:56.508]                   signalCondition(cond)
[11:02:56.508]                 }
[11:02:56.508]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:56.508]                 "immediateCondition"))) {
[11:02:56.508]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:56.508]                   ...future.conditions[[length(...future.conditions) + 
[11:02:56.508]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:56.508]                   if (TRUE && !signal) {
[11:02:56.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:56.508]                     {
[11:02:56.508]                       inherits <- base::inherits
[11:02:56.508]                       invokeRestart <- base::invokeRestart
[11:02:56.508]                       is.null <- base::is.null
[11:02:56.508]                       muffled <- FALSE
[11:02:56.508]                       if (inherits(cond, "message")) {
[11:02:56.508]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:56.508]                         if (muffled) 
[11:02:56.508]                           invokeRestart("muffleMessage")
[11:02:56.508]                       }
[11:02:56.508]                       else if (inherits(cond, "warning")) {
[11:02:56.508]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:56.508]                         if (muffled) 
[11:02:56.508]                           invokeRestart("muffleWarning")
[11:02:56.508]                       }
[11:02:56.508]                       else if (inherits(cond, "condition")) {
[11:02:56.508]                         if (!is.null(pattern)) {
[11:02:56.508]                           computeRestarts <- base::computeRestarts
[11:02:56.508]                           grepl <- base::grepl
[11:02:56.508]                           restarts <- computeRestarts(cond)
[11:02:56.508]                           for (restart in restarts) {
[11:02:56.508]                             name <- restart$name
[11:02:56.508]                             if (is.null(name)) 
[11:02:56.508]                               next
[11:02:56.508]                             if (!grepl(pattern, name)) 
[11:02:56.508]                               next
[11:02:56.508]                             invokeRestart(restart)
[11:02:56.508]                             muffled <- TRUE
[11:02:56.508]                             break
[11:02:56.508]                           }
[11:02:56.508]                         }
[11:02:56.508]                       }
[11:02:56.508]                       invisible(muffled)
[11:02:56.508]                     }
[11:02:56.508]                     muffleCondition(cond, pattern = "^muffle")
[11:02:56.508]                   }
[11:02:56.508]                 }
[11:02:56.508]                 else {
[11:02:56.508]                   if (TRUE) {
[11:02:56.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:56.508]                     {
[11:02:56.508]                       inherits <- base::inherits
[11:02:56.508]                       invokeRestart <- base::invokeRestart
[11:02:56.508]                       is.null <- base::is.null
[11:02:56.508]                       muffled <- FALSE
[11:02:56.508]                       if (inherits(cond, "message")) {
[11:02:56.508]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:56.508]                         if (muffled) 
[11:02:56.508]                           invokeRestart("muffleMessage")
[11:02:56.508]                       }
[11:02:56.508]                       else if (inherits(cond, "warning")) {
[11:02:56.508]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:56.508]                         if (muffled) 
[11:02:56.508]                           invokeRestart("muffleWarning")
[11:02:56.508]                       }
[11:02:56.508]                       else if (inherits(cond, "condition")) {
[11:02:56.508]                         if (!is.null(pattern)) {
[11:02:56.508]                           computeRestarts <- base::computeRestarts
[11:02:56.508]                           grepl <- base::grepl
[11:02:56.508]                           restarts <- computeRestarts(cond)
[11:02:56.508]                           for (restart in restarts) {
[11:02:56.508]                             name <- restart$name
[11:02:56.508]                             if (is.null(name)) 
[11:02:56.508]                               next
[11:02:56.508]                             if (!grepl(pattern, name)) 
[11:02:56.508]                               next
[11:02:56.508]                             invokeRestart(restart)
[11:02:56.508]                             muffled <- TRUE
[11:02:56.508]                             break
[11:02:56.508]                           }
[11:02:56.508]                         }
[11:02:56.508]                       }
[11:02:56.508]                       invisible(muffled)
[11:02:56.508]                     }
[11:02:56.508]                     muffleCondition(cond, pattern = "^muffle")
[11:02:56.508]                   }
[11:02:56.508]                 }
[11:02:56.508]             }
[11:02:56.508]         }))
[11:02:56.508]     }, error = function(ex) {
[11:02:56.508]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:56.508]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:56.508]                 ...future.rng), started = ...future.startTime, 
[11:02:56.508]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:56.508]             version = "1.8"), class = "FutureResult")
[11:02:56.508]     }, finally = {
[11:02:56.508]         if (!identical(...future.workdir, getwd())) 
[11:02:56.508]             setwd(...future.workdir)
[11:02:56.508]         {
[11:02:56.508]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:56.508]                 ...future.oldOptions$nwarnings <- NULL
[11:02:56.508]             }
[11:02:56.508]             base::options(...future.oldOptions)
[11:02:56.508]             if (.Platform$OS.type == "windows") {
[11:02:56.508]                 old_names <- names(...future.oldEnvVars)
[11:02:56.508]                 envs <- base::Sys.getenv()
[11:02:56.508]                 names <- names(envs)
[11:02:56.508]                 common <- intersect(names, old_names)
[11:02:56.508]                 added <- setdiff(names, old_names)
[11:02:56.508]                 removed <- setdiff(old_names, names)
[11:02:56.508]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:56.508]                   envs[common]]
[11:02:56.508]                 NAMES <- toupper(changed)
[11:02:56.508]                 args <- list()
[11:02:56.508]                 for (kk in seq_along(NAMES)) {
[11:02:56.508]                   name <- changed[[kk]]
[11:02:56.508]                   NAME <- NAMES[[kk]]
[11:02:56.508]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:56.508]                     next
[11:02:56.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:56.508]                 }
[11:02:56.508]                 NAMES <- toupper(added)
[11:02:56.508]                 for (kk in seq_along(NAMES)) {
[11:02:56.508]                   name <- added[[kk]]
[11:02:56.508]                   NAME <- NAMES[[kk]]
[11:02:56.508]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:56.508]                     next
[11:02:56.508]                   args[[name]] <- ""
[11:02:56.508]                 }
[11:02:56.508]                 NAMES <- toupper(removed)
[11:02:56.508]                 for (kk in seq_along(NAMES)) {
[11:02:56.508]                   name <- removed[[kk]]
[11:02:56.508]                   NAME <- NAMES[[kk]]
[11:02:56.508]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:56.508]                     next
[11:02:56.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:56.508]                 }
[11:02:56.508]                 if (length(args) > 0) 
[11:02:56.508]                   base::do.call(base::Sys.setenv, args = args)
[11:02:56.508]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:56.508]             }
[11:02:56.508]             else {
[11:02:56.508]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:56.508]             }
[11:02:56.508]             {
[11:02:56.508]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:56.508]                   0L) {
[11:02:56.508]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:56.508]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:56.508]                   base::options(opts)
[11:02:56.508]                 }
[11:02:56.508]                 {
[11:02:56.508]                   {
[11:02:56.508]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:56.508]                     NULL
[11:02:56.508]                   }
[11:02:56.508]                   options(future.plan = NULL)
[11:02:56.508]                   if (is.na(NA_character_)) 
[11:02:56.508]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:56.508]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:56.508]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:56.508]                     .init = FALSE)
[11:02:56.508]                 }
[11:02:56.508]             }
[11:02:56.508]         }
[11:02:56.508]     })
[11:02:56.508]     if (TRUE) {
[11:02:56.508]         base::sink(type = "output", split = FALSE)
[11:02:56.508]         if (TRUE) {
[11:02:56.508]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:56.508]         }
[11:02:56.508]         else {
[11:02:56.508]             ...future.result["stdout"] <- base::list(NULL)
[11:02:56.508]         }
[11:02:56.508]         base::close(...future.stdout)
[11:02:56.508]         ...future.stdout <- NULL
[11:02:56.508]     }
[11:02:56.508]     ...future.result$conditions <- ...future.conditions
[11:02:56.508]     ...future.result$finished <- base::Sys.time()
[11:02:56.508]     ...future.result
[11:02:56.508] }
[11:02:56.511] MultisessionFuture started
[11:02:56.511] - Launch lazy future ... done
[11:02:56.511] run() for ‘MultisessionFuture’ ... done
[11:02:56.511] getGlobalsAndPackages() ...
[11:02:56.511] Searching for globals...
[11:02:56.511] 
[11:02:56.512] Searching for globals ... DONE
[11:02:56.512] - globals: [0] <none>
[11:02:56.512] getGlobalsAndPackages() ... DONE
[11:02:56.512] run() for ‘Future’ ...
[11:02:56.512] - state: ‘created’
[11:02:56.512] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:56.526] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:56.526] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:56.526]   - Field: ‘node’
[11:02:56.526]   - Field: ‘label’
[11:02:56.526]   - Field: ‘local’
[11:02:56.526]   - Field: ‘owner’
[11:02:56.526]   - Field: ‘envir’
[11:02:56.526]   - Field: ‘workers’
[11:02:56.526]   - Field: ‘packages’
[11:02:56.526]   - Field: ‘gc’
[11:02:56.526]   - Field: ‘conditions’
[11:02:56.527]   - Field: ‘persistent’
[11:02:56.527]   - Field: ‘expr’
[11:02:56.527]   - Field: ‘uuid’
[11:02:56.527]   - Field: ‘seed’
[11:02:56.527]   - Field: ‘version’
[11:02:56.527]   - Field: ‘result’
[11:02:56.527]   - Field: ‘asynchronous’
[11:02:56.527]   - Field: ‘calls’
[11:02:56.527]   - Field: ‘globals’
[11:02:56.527]   - Field: ‘stdout’
[11:02:56.527]   - Field: ‘earlySignal’
[11:02:56.527]   - Field: ‘lazy’
[11:02:56.528]   - Field: ‘state’
[11:02:56.528] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:56.528] - Launch lazy future ...
[11:02:56.528] Packages needed by the future expression (n = 0): <none>
[11:02:56.528] Packages needed by future strategies (n = 0): <none>
[11:02:56.528] {
[11:02:56.528]     {
[11:02:56.528]         {
[11:02:56.528]             ...future.startTime <- base::Sys.time()
[11:02:56.528]             {
[11:02:56.528]                 {
[11:02:56.528]                   {
[11:02:56.528]                     {
[11:02:56.528]                       base::local({
[11:02:56.528]                         has_future <- base::requireNamespace("future", 
[11:02:56.528]                           quietly = TRUE)
[11:02:56.528]                         if (has_future) {
[11:02:56.528]                           ns <- base::getNamespace("future")
[11:02:56.528]                           version <- ns[[".package"]][["version"]]
[11:02:56.528]                           if (is.null(version)) 
[11:02:56.528]                             version <- utils::packageVersion("future")
[11:02:56.528]                         }
[11:02:56.528]                         else {
[11:02:56.528]                           version <- NULL
[11:02:56.528]                         }
[11:02:56.528]                         if (!has_future || version < "1.8.0") {
[11:02:56.528]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:56.528]                             "", base::R.version$version.string), 
[11:02:56.528]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:56.528]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:56.528]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:56.528]                               "release", "version")], collapse = " "), 
[11:02:56.528]                             hostname = base::Sys.info()[["nodename"]])
[11:02:56.528]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:56.528]                             info)
[11:02:56.528]                           info <- base::paste(info, collapse = "; ")
[11:02:56.528]                           if (!has_future) {
[11:02:56.528]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:56.528]                               info)
[11:02:56.528]                           }
[11:02:56.528]                           else {
[11:02:56.528]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:56.528]                               info, version)
[11:02:56.528]                           }
[11:02:56.528]                           base::stop(msg)
[11:02:56.528]                         }
[11:02:56.528]                       })
[11:02:56.528]                     }
[11:02:56.528]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:56.528]                     base::options(mc.cores = 1L)
[11:02:56.528]                   }
[11:02:56.528]                   ...future.strategy.old <- future::plan("list")
[11:02:56.528]                   options(future.plan = NULL)
[11:02:56.528]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:56.528]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:56.528]                 }
[11:02:56.528]                 ...future.workdir <- getwd()
[11:02:56.528]             }
[11:02:56.528]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:56.528]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:56.528]         }
[11:02:56.528]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:56.528]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:56.528]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:56.528]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:56.528]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:56.528]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:56.528]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:56.528]             base::names(...future.oldOptions))
[11:02:56.528]     }
[11:02:56.528]     if (FALSE) {
[11:02:56.528]     }
[11:02:56.528]     else {
[11:02:56.528]         if (TRUE) {
[11:02:56.528]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:56.528]                 open = "w")
[11:02:56.528]         }
[11:02:56.528]         else {
[11:02:56.528]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:56.528]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:56.528]         }
[11:02:56.528]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:56.528]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:56.528]             base::sink(type = "output", split = FALSE)
[11:02:56.528]             base::close(...future.stdout)
[11:02:56.528]         }, add = TRUE)
[11:02:56.528]     }
[11:02:56.528]     ...future.frame <- base::sys.nframe()
[11:02:56.528]     ...future.conditions <- base::list()
[11:02:56.528]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:56.528]     if (FALSE) {
[11:02:56.528]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:56.528]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:56.528]     }
[11:02:56.528]     ...future.result <- base::tryCatch({
[11:02:56.528]         base::withCallingHandlers({
[11:02:56.528]             ...future.value <- base::withVisible(base::local({
[11:02:56.528]                 ...future.makeSendCondition <- base::local({
[11:02:56.528]                   sendCondition <- NULL
[11:02:56.528]                   function(frame = 1L) {
[11:02:56.528]                     if (is.function(sendCondition)) 
[11:02:56.528]                       return(sendCondition)
[11:02:56.528]                     ns <- getNamespace("parallel")
[11:02:56.528]                     if (exists("sendData", mode = "function", 
[11:02:56.528]                       envir = ns)) {
[11:02:56.528]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:56.528]                         envir = ns)
[11:02:56.528]                       envir <- sys.frame(frame)
[11:02:56.528]                       master <- NULL
[11:02:56.528]                       while (!identical(envir, .GlobalEnv) && 
[11:02:56.528]                         !identical(envir, emptyenv())) {
[11:02:56.528]                         if (exists("master", mode = "list", envir = envir, 
[11:02:56.528]                           inherits = FALSE)) {
[11:02:56.528]                           master <- get("master", mode = "list", 
[11:02:56.528]                             envir = envir, inherits = FALSE)
[11:02:56.528]                           if (inherits(master, c("SOCKnode", 
[11:02:56.528]                             "SOCK0node"))) {
[11:02:56.528]                             sendCondition <<- function(cond) {
[11:02:56.528]                               data <- list(type = "VALUE", value = cond, 
[11:02:56.528]                                 success = TRUE)
[11:02:56.528]                               parallel_sendData(master, data)
[11:02:56.528]                             }
[11:02:56.528]                             return(sendCondition)
[11:02:56.528]                           }
[11:02:56.528]                         }
[11:02:56.528]                         frame <- frame + 1L
[11:02:56.528]                         envir <- sys.frame(frame)
[11:02:56.528]                       }
[11:02:56.528]                     }
[11:02:56.528]                     sendCondition <<- function(cond) NULL
[11:02:56.528]                   }
[11:02:56.528]                 })
[11:02:56.528]                 withCallingHandlers({
[11:02:56.528]                   2
[11:02:56.528]                 }, immediateCondition = function(cond) {
[11:02:56.528]                   sendCondition <- ...future.makeSendCondition()
[11:02:56.528]                   sendCondition(cond)
[11:02:56.528]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:56.528]                   {
[11:02:56.528]                     inherits <- base::inherits
[11:02:56.528]                     invokeRestart <- base::invokeRestart
[11:02:56.528]                     is.null <- base::is.null
[11:02:56.528]                     muffled <- FALSE
[11:02:56.528]                     if (inherits(cond, "message")) {
[11:02:56.528]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:56.528]                       if (muffled) 
[11:02:56.528]                         invokeRestart("muffleMessage")
[11:02:56.528]                     }
[11:02:56.528]                     else if (inherits(cond, "warning")) {
[11:02:56.528]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:56.528]                       if (muffled) 
[11:02:56.528]                         invokeRestart("muffleWarning")
[11:02:56.528]                     }
[11:02:56.528]                     else if (inherits(cond, "condition")) {
[11:02:56.528]                       if (!is.null(pattern)) {
[11:02:56.528]                         computeRestarts <- base::computeRestarts
[11:02:56.528]                         grepl <- base::grepl
[11:02:56.528]                         restarts <- computeRestarts(cond)
[11:02:56.528]                         for (restart in restarts) {
[11:02:56.528]                           name <- restart$name
[11:02:56.528]                           if (is.null(name)) 
[11:02:56.528]                             next
[11:02:56.528]                           if (!grepl(pattern, name)) 
[11:02:56.528]                             next
[11:02:56.528]                           invokeRestart(restart)
[11:02:56.528]                           muffled <- TRUE
[11:02:56.528]                           break
[11:02:56.528]                         }
[11:02:56.528]                       }
[11:02:56.528]                     }
[11:02:56.528]                     invisible(muffled)
[11:02:56.528]                   }
[11:02:56.528]                   muffleCondition(cond)
[11:02:56.528]                 })
[11:02:56.528]             }))
[11:02:56.528]             future::FutureResult(value = ...future.value$value, 
[11:02:56.528]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:56.528]                   ...future.rng), globalenv = if (FALSE) 
[11:02:56.528]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:56.528]                     ...future.globalenv.names))
[11:02:56.528]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:56.528]         }, condition = base::local({
[11:02:56.528]             c <- base::c
[11:02:56.528]             inherits <- base::inherits
[11:02:56.528]             invokeRestart <- base::invokeRestart
[11:02:56.528]             length <- base::length
[11:02:56.528]             list <- base::list
[11:02:56.528]             seq.int <- base::seq.int
[11:02:56.528]             signalCondition <- base::signalCondition
[11:02:56.528]             sys.calls <- base::sys.calls
[11:02:56.528]             `[[` <- base::`[[`
[11:02:56.528]             `+` <- base::`+`
[11:02:56.528]             `<<-` <- base::`<<-`
[11:02:56.528]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:56.528]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:56.528]                   3L)]
[11:02:56.528]             }
[11:02:56.528]             function(cond) {
[11:02:56.528]                 is_error <- inherits(cond, "error")
[11:02:56.528]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:56.528]                   NULL)
[11:02:56.528]                 if (is_error) {
[11:02:56.528]                   sessionInformation <- function() {
[11:02:56.528]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:56.528]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:56.528]                       search = base::search(), system = base::Sys.info())
[11:02:56.528]                   }
[11:02:56.528]                   ...future.conditions[[length(...future.conditions) + 
[11:02:56.528]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:56.528]                     cond$call), session = sessionInformation(), 
[11:02:56.528]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:56.528]                   signalCondition(cond)
[11:02:56.528]                 }
[11:02:56.528]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:56.528]                 "immediateCondition"))) {
[11:02:56.528]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:56.528]                   ...future.conditions[[length(...future.conditions) + 
[11:02:56.528]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:56.528]                   if (TRUE && !signal) {
[11:02:56.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:56.528]                     {
[11:02:56.528]                       inherits <- base::inherits
[11:02:56.528]                       invokeRestart <- base::invokeRestart
[11:02:56.528]                       is.null <- base::is.null
[11:02:56.528]                       muffled <- FALSE
[11:02:56.528]                       if (inherits(cond, "message")) {
[11:02:56.528]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:56.528]                         if (muffled) 
[11:02:56.528]                           invokeRestart("muffleMessage")
[11:02:56.528]                       }
[11:02:56.528]                       else if (inherits(cond, "warning")) {
[11:02:56.528]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:56.528]                         if (muffled) 
[11:02:56.528]                           invokeRestart("muffleWarning")
[11:02:56.528]                       }
[11:02:56.528]                       else if (inherits(cond, "condition")) {
[11:02:56.528]                         if (!is.null(pattern)) {
[11:02:56.528]                           computeRestarts <- base::computeRestarts
[11:02:56.528]                           grepl <- base::grepl
[11:02:56.528]                           restarts <- computeRestarts(cond)
[11:02:56.528]                           for (restart in restarts) {
[11:02:56.528]                             name <- restart$name
[11:02:56.528]                             if (is.null(name)) 
[11:02:56.528]                               next
[11:02:56.528]                             if (!grepl(pattern, name)) 
[11:02:56.528]                               next
[11:02:56.528]                             invokeRestart(restart)
[11:02:56.528]                             muffled <- TRUE
[11:02:56.528]                             break
[11:02:56.528]                           }
[11:02:56.528]                         }
[11:02:56.528]                       }
[11:02:56.528]                       invisible(muffled)
[11:02:56.528]                     }
[11:02:56.528]                     muffleCondition(cond, pattern = "^muffle")
[11:02:56.528]                   }
[11:02:56.528]                 }
[11:02:56.528]                 else {
[11:02:56.528]                   if (TRUE) {
[11:02:56.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:56.528]                     {
[11:02:56.528]                       inherits <- base::inherits
[11:02:56.528]                       invokeRestart <- base::invokeRestart
[11:02:56.528]                       is.null <- base::is.null
[11:02:56.528]                       muffled <- FALSE
[11:02:56.528]                       if (inherits(cond, "message")) {
[11:02:56.528]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:56.528]                         if (muffled) 
[11:02:56.528]                           invokeRestart("muffleMessage")
[11:02:56.528]                       }
[11:02:56.528]                       else if (inherits(cond, "warning")) {
[11:02:56.528]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:56.528]                         if (muffled) 
[11:02:56.528]                           invokeRestart("muffleWarning")
[11:02:56.528]                       }
[11:02:56.528]                       else if (inherits(cond, "condition")) {
[11:02:56.528]                         if (!is.null(pattern)) {
[11:02:56.528]                           computeRestarts <- base::computeRestarts
[11:02:56.528]                           grepl <- base::grepl
[11:02:56.528]                           restarts <- computeRestarts(cond)
[11:02:56.528]                           for (restart in restarts) {
[11:02:56.528]                             name <- restart$name
[11:02:56.528]                             if (is.null(name)) 
[11:02:56.528]                               next
[11:02:56.528]                             if (!grepl(pattern, name)) 
[11:02:56.528]                               next
[11:02:56.528]                             invokeRestart(restart)
[11:02:56.528]                             muffled <- TRUE
[11:02:56.528]                             break
[11:02:56.528]                           }
[11:02:56.528]                         }
[11:02:56.528]                       }
[11:02:56.528]                       invisible(muffled)
[11:02:56.528]                     }
[11:02:56.528]                     muffleCondition(cond, pattern = "^muffle")
[11:02:56.528]                   }
[11:02:56.528]                 }
[11:02:56.528]             }
[11:02:56.528]         }))
[11:02:56.528]     }, error = function(ex) {
[11:02:56.528]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:56.528]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:56.528]                 ...future.rng), started = ...future.startTime, 
[11:02:56.528]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:56.528]             version = "1.8"), class = "FutureResult")
[11:02:56.528]     }, finally = {
[11:02:56.528]         if (!identical(...future.workdir, getwd())) 
[11:02:56.528]             setwd(...future.workdir)
[11:02:56.528]         {
[11:02:56.528]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:56.528]                 ...future.oldOptions$nwarnings <- NULL
[11:02:56.528]             }
[11:02:56.528]             base::options(...future.oldOptions)
[11:02:56.528]             if (.Platform$OS.type == "windows") {
[11:02:56.528]                 old_names <- names(...future.oldEnvVars)
[11:02:56.528]                 envs <- base::Sys.getenv()
[11:02:56.528]                 names <- names(envs)
[11:02:56.528]                 common <- intersect(names, old_names)
[11:02:56.528]                 added <- setdiff(names, old_names)
[11:02:56.528]                 removed <- setdiff(old_names, names)
[11:02:56.528]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:56.528]                   envs[common]]
[11:02:56.528]                 NAMES <- toupper(changed)
[11:02:56.528]                 args <- list()
[11:02:56.528]                 for (kk in seq_along(NAMES)) {
[11:02:56.528]                   name <- changed[[kk]]
[11:02:56.528]                   NAME <- NAMES[[kk]]
[11:02:56.528]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:56.528]                     next
[11:02:56.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:56.528]                 }
[11:02:56.528]                 NAMES <- toupper(added)
[11:02:56.528]                 for (kk in seq_along(NAMES)) {
[11:02:56.528]                   name <- added[[kk]]
[11:02:56.528]                   NAME <- NAMES[[kk]]
[11:02:56.528]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:56.528]                     next
[11:02:56.528]                   args[[name]] <- ""
[11:02:56.528]                 }
[11:02:56.528]                 NAMES <- toupper(removed)
[11:02:56.528]                 for (kk in seq_along(NAMES)) {
[11:02:56.528]                   name <- removed[[kk]]
[11:02:56.528]                   NAME <- NAMES[[kk]]
[11:02:56.528]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:56.528]                     next
[11:02:56.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:56.528]                 }
[11:02:56.528]                 if (length(args) > 0) 
[11:02:56.528]                   base::do.call(base::Sys.setenv, args = args)
[11:02:56.528]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:56.528]             }
[11:02:56.528]             else {
[11:02:56.528]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:56.528]             }
[11:02:56.528]             {
[11:02:56.528]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:56.528]                   0L) {
[11:02:56.528]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:56.528]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:56.528]                   base::options(opts)
[11:02:56.528]                 }
[11:02:56.528]                 {
[11:02:56.528]                   {
[11:02:56.528]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:56.528]                     NULL
[11:02:56.528]                   }
[11:02:56.528]                   options(future.plan = NULL)
[11:02:56.528]                   if (is.na(NA_character_)) 
[11:02:56.528]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:56.528]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:56.528]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:56.528]                     .init = FALSE)
[11:02:56.528]                 }
[11:02:56.528]             }
[11:02:56.528]         }
[11:02:56.528]     })
[11:02:56.528]     if (TRUE) {
[11:02:56.528]         base::sink(type = "output", split = FALSE)
[11:02:56.528]         if (TRUE) {
[11:02:56.528]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:56.528]         }
[11:02:56.528]         else {
[11:02:56.528]             ...future.result["stdout"] <- base::list(NULL)
[11:02:56.528]         }
[11:02:56.528]         base::close(...future.stdout)
[11:02:56.528]         ...future.stdout <- NULL
[11:02:56.528]     }
[11:02:56.528]     ...future.result$conditions <- ...future.conditions
[11:02:56.528]     ...future.result$finished <- base::Sys.time()
[11:02:56.528]     ...future.result
[11:02:56.528] }
[11:02:56.531] Poll #1 (0): usedNodes() = 2, workers = 2
[11:02:56.541] receiveMessageFromWorker() for ClusterFuture ...
[11:02:56.541] - Validating connection of MultisessionFuture
[11:02:56.542] - received message: FutureResult
[11:02:56.542] - Received FutureResult
[11:02:56.542] - Erased future from FutureRegistry
[11:02:56.542] result() for ClusterFuture ...
[11:02:56.542] - result already collected: FutureResult
[11:02:56.542] result() for ClusterFuture ... done
[11:02:56.542] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:56.542] result() for ClusterFuture ...
[11:02:56.542] - result already collected: FutureResult
[11:02:56.543] result() for ClusterFuture ... done
[11:02:56.543] result() for ClusterFuture ...
[11:02:56.543] - result already collected: FutureResult
[11:02:56.543] result() for ClusterFuture ... done
[11:02:56.544] MultisessionFuture started
[11:02:56.544] - Launch lazy future ... done
[11:02:56.544] run() for ‘MultisessionFuture’ ... done
[11:02:56.544] resolve() on list ...
[11:02:56.544]  recursive: 0
[11:02:56.544]  length: 3
[11:02:56.544]  elements: ‘a’, ‘b’, ‘’
[11:02:56.553] receiveMessageFromWorker() for ClusterFuture ...
[11:02:56.553] - Validating connection of MultisessionFuture
[11:02:56.553] - received message: FutureResult
[11:02:56.553] - Received FutureResult
[11:02:56.553] - Erased future from FutureRegistry
[11:02:56.553] result() for ClusterFuture ...
[11:02:56.553] - result already collected: FutureResult
[11:02:56.554] result() for ClusterFuture ... done
[11:02:56.554] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:56.554] Future #1
[11:02:56.554]  length: 2 (resolved future 1)
[11:02:56.564]  length: 1 (resolved future 3)
[11:02:56.596] receiveMessageFromWorker() for ClusterFuture ...
[11:02:56.596] - Validating connection of MultisessionFuture
[11:02:56.596] - received message: FutureResult
[11:02:56.596] - Received FutureResult
[11:02:56.596] - Erased future from FutureRegistry
[11:02:56.596] result() for ClusterFuture ...
[11:02:56.596] - result already collected: FutureResult
[11:02:56.597] result() for ClusterFuture ... done
[11:02:56.597] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:56.597] Future #2
[11:02:56.597]  length: 0 (resolved future 2)
[11:02:56.597] resolve() on list ... DONE
[11:02:56.597] getGlobalsAndPackages() ...
[11:02:56.597] Searching for globals...
[11:02:56.597] 
[11:02:56.598] Searching for globals ... DONE
[11:02:56.598] - globals: [0] <none>
[11:02:56.598] getGlobalsAndPackages() ... DONE
[11:02:56.598] getGlobalsAndPackages() ...
[11:02:56.598] Searching for globals...
[11:02:56.598] 
[11:02:56.598] Searching for globals ... DONE
[11:02:56.598] - globals: [0] <none>
[11:02:56.599] getGlobalsAndPackages() ... DONE
[11:02:56.599] run() for ‘Future’ ...
[11:02:56.599] - state: ‘created’
[11:02:56.599] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:56.613] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:56.613] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:56.613]   - Field: ‘node’
[11:02:56.613]   - Field: ‘label’
[11:02:56.613]   - Field: ‘local’
[11:02:56.613]   - Field: ‘owner’
[11:02:56.613]   - Field: ‘envir’
[11:02:56.614]   - Field: ‘workers’
[11:02:56.614]   - Field: ‘packages’
[11:02:56.614]   - Field: ‘gc’
[11:02:56.614]   - Field: ‘conditions’
[11:02:56.614]   - Field: ‘persistent’
[11:02:56.614]   - Field: ‘expr’
[11:02:56.614]   - Field: ‘uuid’
[11:02:56.614]   - Field: ‘seed’
[11:02:56.614]   - Field: ‘version’
[11:02:56.614]   - Field: ‘result’
[11:02:56.614]   - Field: ‘asynchronous’
[11:02:56.614]   - Field: ‘calls’
[11:02:56.615]   - Field: ‘globals’
[11:02:56.615]   - Field: ‘stdout’
[11:02:56.615]   - Field: ‘earlySignal’
[11:02:56.615]   - Field: ‘lazy’
[11:02:56.615]   - Field: ‘state’
[11:02:56.615] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:56.615] - Launch lazy future ...
[11:02:56.615] Packages needed by the future expression (n = 0): <none>
[11:02:56.615] Packages needed by future strategies (n = 0): <none>
[11:02:56.616] {
[11:02:56.616]     {
[11:02:56.616]         {
[11:02:56.616]             ...future.startTime <- base::Sys.time()
[11:02:56.616]             {
[11:02:56.616]                 {
[11:02:56.616]                   {
[11:02:56.616]                     {
[11:02:56.616]                       base::local({
[11:02:56.616]                         has_future <- base::requireNamespace("future", 
[11:02:56.616]                           quietly = TRUE)
[11:02:56.616]                         if (has_future) {
[11:02:56.616]                           ns <- base::getNamespace("future")
[11:02:56.616]                           version <- ns[[".package"]][["version"]]
[11:02:56.616]                           if (is.null(version)) 
[11:02:56.616]                             version <- utils::packageVersion("future")
[11:02:56.616]                         }
[11:02:56.616]                         else {
[11:02:56.616]                           version <- NULL
[11:02:56.616]                         }
[11:02:56.616]                         if (!has_future || version < "1.8.0") {
[11:02:56.616]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:56.616]                             "", base::R.version$version.string), 
[11:02:56.616]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:56.616]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:56.616]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:56.616]                               "release", "version")], collapse = " "), 
[11:02:56.616]                             hostname = base::Sys.info()[["nodename"]])
[11:02:56.616]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:56.616]                             info)
[11:02:56.616]                           info <- base::paste(info, collapse = "; ")
[11:02:56.616]                           if (!has_future) {
[11:02:56.616]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:56.616]                               info)
[11:02:56.616]                           }
[11:02:56.616]                           else {
[11:02:56.616]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:56.616]                               info, version)
[11:02:56.616]                           }
[11:02:56.616]                           base::stop(msg)
[11:02:56.616]                         }
[11:02:56.616]                       })
[11:02:56.616]                     }
[11:02:56.616]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:56.616]                     base::options(mc.cores = 1L)
[11:02:56.616]                   }
[11:02:56.616]                   ...future.strategy.old <- future::plan("list")
[11:02:56.616]                   options(future.plan = NULL)
[11:02:56.616]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:56.616]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:56.616]                 }
[11:02:56.616]                 ...future.workdir <- getwd()
[11:02:56.616]             }
[11:02:56.616]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:56.616]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:56.616]         }
[11:02:56.616]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:56.616]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:56.616]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:56.616]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:56.616]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:56.616]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:56.616]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:56.616]             base::names(...future.oldOptions))
[11:02:56.616]     }
[11:02:56.616]     if (FALSE) {
[11:02:56.616]     }
[11:02:56.616]     else {
[11:02:56.616]         if (TRUE) {
[11:02:56.616]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:56.616]                 open = "w")
[11:02:56.616]         }
[11:02:56.616]         else {
[11:02:56.616]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:56.616]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:56.616]         }
[11:02:56.616]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:56.616]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:56.616]             base::sink(type = "output", split = FALSE)
[11:02:56.616]             base::close(...future.stdout)
[11:02:56.616]         }, add = TRUE)
[11:02:56.616]     }
[11:02:56.616]     ...future.frame <- base::sys.nframe()
[11:02:56.616]     ...future.conditions <- base::list()
[11:02:56.616]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:56.616]     if (FALSE) {
[11:02:56.616]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:56.616]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:56.616]     }
[11:02:56.616]     ...future.result <- base::tryCatch({
[11:02:56.616]         base::withCallingHandlers({
[11:02:56.616]             ...future.value <- base::withVisible(base::local({
[11:02:56.616]                 ...future.makeSendCondition <- base::local({
[11:02:56.616]                   sendCondition <- NULL
[11:02:56.616]                   function(frame = 1L) {
[11:02:56.616]                     if (is.function(sendCondition)) 
[11:02:56.616]                       return(sendCondition)
[11:02:56.616]                     ns <- getNamespace("parallel")
[11:02:56.616]                     if (exists("sendData", mode = "function", 
[11:02:56.616]                       envir = ns)) {
[11:02:56.616]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:56.616]                         envir = ns)
[11:02:56.616]                       envir <- sys.frame(frame)
[11:02:56.616]                       master <- NULL
[11:02:56.616]                       while (!identical(envir, .GlobalEnv) && 
[11:02:56.616]                         !identical(envir, emptyenv())) {
[11:02:56.616]                         if (exists("master", mode = "list", envir = envir, 
[11:02:56.616]                           inherits = FALSE)) {
[11:02:56.616]                           master <- get("master", mode = "list", 
[11:02:56.616]                             envir = envir, inherits = FALSE)
[11:02:56.616]                           if (inherits(master, c("SOCKnode", 
[11:02:56.616]                             "SOCK0node"))) {
[11:02:56.616]                             sendCondition <<- function(cond) {
[11:02:56.616]                               data <- list(type = "VALUE", value = cond, 
[11:02:56.616]                                 success = TRUE)
[11:02:56.616]                               parallel_sendData(master, data)
[11:02:56.616]                             }
[11:02:56.616]                             return(sendCondition)
[11:02:56.616]                           }
[11:02:56.616]                         }
[11:02:56.616]                         frame <- frame + 1L
[11:02:56.616]                         envir <- sys.frame(frame)
[11:02:56.616]                       }
[11:02:56.616]                     }
[11:02:56.616]                     sendCondition <<- function(cond) NULL
[11:02:56.616]                   }
[11:02:56.616]                 })
[11:02:56.616]                 withCallingHandlers({
[11:02:56.616]                   2
[11:02:56.616]                 }, immediateCondition = function(cond) {
[11:02:56.616]                   sendCondition <- ...future.makeSendCondition()
[11:02:56.616]                   sendCondition(cond)
[11:02:56.616]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:56.616]                   {
[11:02:56.616]                     inherits <- base::inherits
[11:02:56.616]                     invokeRestart <- base::invokeRestart
[11:02:56.616]                     is.null <- base::is.null
[11:02:56.616]                     muffled <- FALSE
[11:02:56.616]                     if (inherits(cond, "message")) {
[11:02:56.616]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:56.616]                       if (muffled) 
[11:02:56.616]                         invokeRestart("muffleMessage")
[11:02:56.616]                     }
[11:02:56.616]                     else if (inherits(cond, "warning")) {
[11:02:56.616]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:56.616]                       if (muffled) 
[11:02:56.616]                         invokeRestart("muffleWarning")
[11:02:56.616]                     }
[11:02:56.616]                     else if (inherits(cond, "condition")) {
[11:02:56.616]                       if (!is.null(pattern)) {
[11:02:56.616]                         computeRestarts <- base::computeRestarts
[11:02:56.616]                         grepl <- base::grepl
[11:02:56.616]                         restarts <- computeRestarts(cond)
[11:02:56.616]                         for (restart in restarts) {
[11:02:56.616]                           name <- restart$name
[11:02:56.616]                           if (is.null(name)) 
[11:02:56.616]                             next
[11:02:56.616]                           if (!grepl(pattern, name)) 
[11:02:56.616]                             next
[11:02:56.616]                           invokeRestart(restart)
[11:02:56.616]                           muffled <- TRUE
[11:02:56.616]                           break
[11:02:56.616]                         }
[11:02:56.616]                       }
[11:02:56.616]                     }
[11:02:56.616]                     invisible(muffled)
[11:02:56.616]                   }
[11:02:56.616]                   muffleCondition(cond)
[11:02:56.616]                 })
[11:02:56.616]             }))
[11:02:56.616]             future::FutureResult(value = ...future.value$value, 
[11:02:56.616]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:56.616]                   ...future.rng), globalenv = if (FALSE) 
[11:02:56.616]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:56.616]                     ...future.globalenv.names))
[11:02:56.616]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:56.616]         }, condition = base::local({
[11:02:56.616]             c <- base::c
[11:02:56.616]             inherits <- base::inherits
[11:02:56.616]             invokeRestart <- base::invokeRestart
[11:02:56.616]             length <- base::length
[11:02:56.616]             list <- base::list
[11:02:56.616]             seq.int <- base::seq.int
[11:02:56.616]             signalCondition <- base::signalCondition
[11:02:56.616]             sys.calls <- base::sys.calls
[11:02:56.616]             `[[` <- base::`[[`
[11:02:56.616]             `+` <- base::`+`
[11:02:56.616]             `<<-` <- base::`<<-`
[11:02:56.616]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:56.616]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:56.616]                   3L)]
[11:02:56.616]             }
[11:02:56.616]             function(cond) {
[11:02:56.616]                 is_error <- inherits(cond, "error")
[11:02:56.616]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:56.616]                   NULL)
[11:02:56.616]                 if (is_error) {
[11:02:56.616]                   sessionInformation <- function() {
[11:02:56.616]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:56.616]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:56.616]                       search = base::search(), system = base::Sys.info())
[11:02:56.616]                   }
[11:02:56.616]                   ...future.conditions[[length(...future.conditions) + 
[11:02:56.616]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:56.616]                     cond$call), session = sessionInformation(), 
[11:02:56.616]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:56.616]                   signalCondition(cond)
[11:02:56.616]                 }
[11:02:56.616]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:56.616]                 "immediateCondition"))) {
[11:02:56.616]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:56.616]                   ...future.conditions[[length(...future.conditions) + 
[11:02:56.616]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:56.616]                   if (TRUE && !signal) {
[11:02:56.616]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:56.616]                     {
[11:02:56.616]                       inherits <- base::inherits
[11:02:56.616]                       invokeRestart <- base::invokeRestart
[11:02:56.616]                       is.null <- base::is.null
[11:02:56.616]                       muffled <- FALSE
[11:02:56.616]                       if (inherits(cond, "message")) {
[11:02:56.616]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:56.616]                         if (muffled) 
[11:02:56.616]                           invokeRestart("muffleMessage")
[11:02:56.616]                       }
[11:02:56.616]                       else if (inherits(cond, "warning")) {
[11:02:56.616]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:56.616]                         if (muffled) 
[11:02:56.616]                           invokeRestart("muffleWarning")
[11:02:56.616]                       }
[11:02:56.616]                       else if (inherits(cond, "condition")) {
[11:02:56.616]                         if (!is.null(pattern)) {
[11:02:56.616]                           computeRestarts <- base::computeRestarts
[11:02:56.616]                           grepl <- base::grepl
[11:02:56.616]                           restarts <- computeRestarts(cond)
[11:02:56.616]                           for (restart in restarts) {
[11:02:56.616]                             name <- restart$name
[11:02:56.616]                             if (is.null(name)) 
[11:02:56.616]                               next
[11:02:56.616]                             if (!grepl(pattern, name)) 
[11:02:56.616]                               next
[11:02:56.616]                             invokeRestart(restart)
[11:02:56.616]                             muffled <- TRUE
[11:02:56.616]                             break
[11:02:56.616]                           }
[11:02:56.616]                         }
[11:02:56.616]                       }
[11:02:56.616]                       invisible(muffled)
[11:02:56.616]                     }
[11:02:56.616]                     muffleCondition(cond, pattern = "^muffle")
[11:02:56.616]                   }
[11:02:56.616]                 }
[11:02:56.616]                 else {
[11:02:56.616]                   if (TRUE) {
[11:02:56.616]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:56.616]                     {
[11:02:56.616]                       inherits <- base::inherits
[11:02:56.616]                       invokeRestart <- base::invokeRestart
[11:02:56.616]                       is.null <- base::is.null
[11:02:56.616]                       muffled <- FALSE
[11:02:56.616]                       if (inherits(cond, "message")) {
[11:02:56.616]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:56.616]                         if (muffled) 
[11:02:56.616]                           invokeRestart("muffleMessage")
[11:02:56.616]                       }
[11:02:56.616]                       else if (inherits(cond, "warning")) {
[11:02:56.616]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:56.616]                         if (muffled) 
[11:02:56.616]                           invokeRestart("muffleWarning")
[11:02:56.616]                       }
[11:02:56.616]                       else if (inherits(cond, "condition")) {
[11:02:56.616]                         if (!is.null(pattern)) {
[11:02:56.616]                           computeRestarts <- base::computeRestarts
[11:02:56.616]                           grepl <- base::grepl
[11:02:56.616]                           restarts <- computeRestarts(cond)
[11:02:56.616]                           for (restart in restarts) {
[11:02:56.616]                             name <- restart$name
[11:02:56.616]                             if (is.null(name)) 
[11:02:56.616]                               next
[11:02:56.616]                             if (!grepl(pattern, name)) 
[11:02:56.616]                               next
[11:02:56.616]                             invokeRestart(restart)
[11:02:56.616]                             muffled <- TRUE
[11:02:56.616]                             break
[11:02:56.616]                           }
[11:02:56.616]                         }
[11:02:56.616]                       }
[11:02:56.616]                       invisible(muffled)
[11:02:56.616]                     }
[11:02:56.616]                     muffleCondition(cond, pattern = "^muffle")
[11:02:56.616]                   }
[11:02:56.616]                 }
[11:02:56.616]             }
[11:02:56.616]         }))
[11:02:56.616]     }, error = function(ex) {
[11:02:56.616]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:56.616]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:56.616]                 ...future.rng), started = ...future.startTime, 
[11:02:56.616]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:56.616]             version = "1.8"), class = "FutureResult")
[11:02:56.616]     }, finally = {
[11:02:56.616]         if (!identical(...future.workdir, getwd())) 
[11:02:56.616]             setwd(...future.workdir)
[11:02:56.616]         {
[11:02:56.616]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:56.616]                 ...future.oldOptions$nwarnings <- NULL
[11:02:56.616]             }
[11:02:56.616]             base::options(...future.oldOptions)
[11:02:56.616]             if (.Platform$OS.type == "windows") {
[11:02:56.616]                 old_names <- names(...future.oldEnvVars)
[11:02:56.616]                 envs <- base::Sys.getenv()
[11:02:56.616]                 names <- names(envs)
[11:02:56.616]                 common <- intersect(names, old_names)
[11:02:56.616]                 added <- setdiff(names, old_names)
[11:02:56.616]                 removed <- setdiff(old_names, names)
[11:02:56.616]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:56.616]                   envs[common]]
[11:02:56.616]                 NAMES <- toupper(changed)
[11:02:56.616]                 args <- list()
[11:02:56.616]                 for (kk in seq_along(NAMES)) {
[11:02:56.616]                   name <- changed[[kk]]
[11:02:56.616]                   NAME <- NAMES[[kk]]
[11:02:56.616]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:56.616]                     next
[11:02:56.616]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:56.616]                 }
[11:02:56.616]                 NAMES <- toupper(added)
[11:02:56.616]                 for (kk in seq_along(NAMES)) {
[11:02:56.616]                   name <- added[[kk]]
[11:02:56.616]                   NAME <- NAMES[[kk]]
[11:02:56.616]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:56.616]                     next
[11:02:56.616]                   args[[name]] <- ""
[11:02:56.616]                 }
[11:02:56.616]                 NAMES <- toupper(removed)
[11:02:56.616]                 for (kk in seq_along(NAMES)) {
[11:02:56.616]                   name <- removed[[kk]]
[11:02:56.616]                   NAME <- NAMES[[kk]]
[11:02:56.616]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:56.616]                     next
[11:02:56.616]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:56.616]                 }
[11:02:56.616]                 if (length(args) > 0) 
[11:02:56.616]                   base::do.call(base::Sys.setenv, args = args)
[11:02:56.616]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:56.616]             }
[11:02:56.616]             else {
[11:02:56.616]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:56.616]             }
[11:02:56.616]             {
[11:02:56.616]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:56.616]                   0L) {
[11:02:56.616]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:56.616]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:56.616]                   base::options(opts)
[11:02:56.616]                 }
[11:02:56.616]                 {
[11:02:56.616]                   {
[11:02:56.616]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:56.616]                     NULL
[11:02:56.616]                   }
[11:02:56.616]                   options(future.plan = NULL)
[11:02:56.616]                   if (is.na(NA_character_)) 
[11:02:56.616]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:56.616]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:56.616]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:56.616]                     .init = FALSE)
[11:02:56.616]                 }
[11:02:56.616]             }
[11:02:56.616]         }
[11:02:56.616]     })
[11:02:56.616]     if (TRUE) {
[11:02:56.616]         base::sink(type = "output", split = FALSE)
[11:02:56.616]         if (TRUE) {
[11:02:56.616]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:56.616]         }
[11:02:56.616]         else {
[11:02:56.616]             ...future.result["stdout"] <- base::list(NULL)
[11:02:56.616]         }
[11:02:56.616]         base::close(...future.stdout)
[11:02:56.616]         ...future.stdout <- NULL
[11:02:56.616]     }
[11:02:56.616]     ...future.result$conditions <- ...future.conditions
[11:02:56.616]     ...future.result$finished <- base::Sys.time()
[11:02:56.616]     ...future.result
[11:02:56.616] }
[11:02:56.619] MultisessionFuture started
[11:02:56.619] - Launch lazy future ... done
[11:02:56.619] run() for ‘MultisessionFuture’ ... done
[11:02:56.619] resolve() on list ...
[11:02:56.619]  recursive: 0
[11:02:56.619]  length: 3
[11:02:56.619]  elements: ‘a’, ‘b’, ‘’
[11:02:56.620] run() for ‘Future’ ...
[11:02:56.620] - state: ‘created’
[11:02:56.620] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:56.643] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:56.643] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:56.644]   - Field: ‘node’
[11:02:56.644]   - Field: ‘label’
[11:02:56.644]   - Field: ‘local’
[11:02:56.644]   - Field: ‘owner’
[11:02:56.644]   - Field: ‘envir’
[11:02:56.644]   - Field: ‘workers’
[11:02:56.644]   - Field: ‘packages’
[11:02:56.644]   - Field: ‘gc’
[11:02:56.644]   - Field: ‘conditions’
[11:02:56.644]   - Field: ‘persistent’
[11:02:56.644]   - Field: ‘expr’
[11:02:56.644]   - Field: ‘uuid’
[11:02:56.645]   - Field: ‘seed’
[11:02:56.645]   - Field: ‘version’
[11:02:56.645]   - Field: ‘result’
[11:02:56.645]   - Field: ‘asynchronous’
[11:02:56.645]   - Field: ‘calls’
[11:02:56.645]   - Field: ‘globals’
[11:02:56.645]   - Field: ‘stdout’
[11:02:56.645]   - Field: ‘earlySignal’
[11:02:56.645]   - Field: ‘lazy’
[11:02:56.645]   - Field: ‘state’
[11:02:56.645] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:56.645] - Launch lazy future ...
[11:02:56.646] Packages needed by the future expression (n = 0): <none>
[11:02:56.646] Packages needed by future strategies (n = 0): <none>
[11:02:56.646] {
[11:02:56.646]     {
[11:02:56.646]         {
[11:02:56.646]             ...future.startTime <- base::Sys.time()
[11:02:56.646]             {
[11:02:56.646]                 {
[11:02:56.646]                   {
[11:02:56.646]                     {
[11:02:56.646]                       base::local({
[11:02:56.646]                         has_future <- base::requireNamespace("future", 
[11:02:56.646]                           quietly = TRUE)
[11:02:56.646]                         if (has_future) {
[11:02:56.646]                           ns <- base::getNamespace("future")
[11:02:56.646]                           version <- ns[[".package"]][["version"]]
[11:02:56.646]                           if (is.null(version)) 
[11:02:56.646]                             version <- utils::packageVersion("future")
[11:02:56.646]                         }
[11:02:56.646]                         else {
[11:02:56.646]                           version <- NULL
[11:02:56.646]                         }
[11:02:56.646]                         if (!has_future || version < "1.8.0") {
[11:02:56.646]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:56.646]                             "", base::R.version$version.string), 
[11:02:56.646]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:56.646]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:56.646]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:56.646]                               "release", "version")], collapse = " "), 
[11:02:56.646]                             hostname = base::Sys.info()[["nodename"]])
[11:02:56.646]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:56.646]                             info)
[11:02:56.646]                           info <- base::paste(info, collapse = "; ")
[11:02:56.646]                           if (!has_future) {
[11:02:56.646]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:56.646]                               info)
[11:02:56.646]                           }
[11:02:56.646]                           else {
[11:02:56.646]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:56.646]                               info, version)
[11:02:56.646]                           }
[11:02:56.646]                           base::stop(msg)
[11:02:56.646]                         }
[11:02:56.646]                       })
[11:02:56.646]                     }
[11:02:56.646]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:56.646]                     base::options(mc.cores = 1L)
[11:02:56.646]                   }
[11:02:56.646]                   ...future.strategy.old <- future::plan("list")
[11:02:56.646]                   options(future.plan = NULL)
[11:02:56.646]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:56.646]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:56.646]                 }
[11:02:56.646]                 ...future.workdir <- getwd()
[11:02:56.646]             }
[11:02:56.646]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:56.646]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:56.646]         }
[11:02:56.646]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:56.646]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:56.646]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:56.646]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:56.646]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:56.646]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:56.646]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:56.646]             base::names(...future.oldOptions))
[11:02:56.646]     }
[11:02:56.646]     if (FALSE) {
[11:02:56.646]     }
[11:02:56.646]     else {
[11:02:56.646]         if (TRUE) {
[11:02:56.646]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:56.646]                 open = "w")
[11:02:56.646]         }
[11:02:56.646]         else {
[11:02:56.646]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:56.646]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:56.646]         }
[11:02:56.646]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:56.646]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:56.646]             base::sink(type = "output", split = FALSE)
[11:02:56.646]             base::close(...future.stdout)
[11:02:56.646]         }, add = TRUE)
[11:02:56.646]     }
[11:02:56.646]     ...future.frame <- base::sys.nframe()
[11:02:56.646]     ...future.conditions <- base::list()
[11:02:56.646]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:56.646]     if (FALSE) {
[11:02:56.646]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:56.646]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:56.646]     }
[11:02:56.646]     ...future.result <- base::tryCatch({
[11:02:56.646]         base::withCallingHandlers({
[11:02:56.646]             ...future.value <- base::withVisible(base::local({
[11:02:56.646]                 ...future.makeSendCondition <- base::local({
[11:02:56.646]                   sendCondition <- NULL
[11:02:56.646]                   function(frame = 1L) {
[11:02:56.646]                     if (is.function(sendCondition)) 
[11:02:56.646]                       return(sendCondition)
[11:02:56.646]                     ns <- getNamespace("parallel")
[11:02:56.646]                     if (exists("sendData", mode = "function", 
[11:02:56.646]                       envir = ns)) {
[11:02:56.646]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:56.646]                         envir = ns)
[11:02:56.646]                       envir <- sys.frame(frame)
[11:02:56.646]                       master <- NULL
[11:02:56.646]                       while (!identical(envir, .GlobalEnv) && 
[11:02:56.646]                         !identical(envir, emptyenv())) {
[11:02:56.646]                         if (exists("master", mode = "list", envir = envir, 
[11:02:56.646]                           inherits = FALSE)) {
[11:02:56.646]                           master <- get("master", mode = "list", 
[11:02:56.646]                             envir = envir, inherits = FALSE)
[11:02:56.646]                           if (inherits(master, c("SOCKnode", 
[11:02:56.646]                             "SOCK0node"))) {
[11:02:56.646]                             sendCondition <<- function(cond) {
[11:02:56.646]                               data <- list(type = "VALUE", value = cond, 
[11:02:56.646]                                 success = TRUE)
[11:02:56.646]                               parallel_sendData(master, data)
[11:02:56.646]                             }
[11:02:56.646]                             return(sendCondition)
[11:02:56.646]                           }
[11:02:56.646]                         }
[11:02:56.646]                         frame <- frame + 1L
[11:02:56.646]                         envir <- sys.frame(frame)
[11:02:56.646]                       }
[11:02:56.646]                     }
[11:02:56.646]                     sendCondition <<- function(cond) NULL
[11:02:56.646]                   }
[11:02:56.646]                 })
[11:02:56.646]                 withCallingHandlers({
[11:02:56.646]                   1
[11:02:56.646]                 }, immediateCondition = function(cond) {
[11:02:56.646]                   sendCondition <- ...future.makeSendCondition()
[11:02:56.646]                   sendCondition(cond)
[11:02:56.646]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:56.646]                   {
[11:02:56.646]                     inherits <- base::inherits
[11:02:56.646]                     invokeRestart <- base::invokeRestart
[11:02:56.646]                     is.null <- base::is.null
[11:02:56.646]                     muffled <- FALSE
[11:02:56.646]                     if (inherits(cond, "message")) {
[11:02:56.646]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:56.646]                       if (muffled) 
[11:02:56.646]                         invokeRestart("muffleMessage")
[11:02:56.646]                     }
[11:02:56.646]                     else if (inherits(cond, "warning")) {
[11:02:56.646]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:56.646]                       if (muffled) 
[11:02:56.646]                         invokeRestart("muffleWarning")
[11:02:56.646]                     }
[11:02:56.646]                     else if (inherits(cond, "condition")) {
[11:02:56.646]                       if (!is.null(pattern)) {
[11:02:56.646]                         computeRestarts <- base::computeRestarts
[11:02:56.646]                         grepl <- base::grepl
[11:02:56.646]                         restarts <- computeRestarts(cond)
[11:02:56.646]                         for (restart in restarts) {
[11:02:56.646]                           name <- restart$name
[11:02:56.646]                           if (is.null(name)) 
[11:02:56.646]                             next
[11:02:56.646]                           if (!grepl(pattern, name)) 
[11:02:56.646]                             next
[11:02:56.646]                           invokeRestart(restart)
[11:02:56.646]                           muffled <- TRUE
[11:02:56.646]                           break
[11:02:56.646]                         }
[11:02:56.646]                       }
[11:02:56.646]                     }
[11:02:56.646]                     invisible(muffled)
[11:02:56.646]                   }
[11:02:56.646]                   muffleCondition(cond)
[11:02:56.646]                 })
[11:02:56.646]             }))
[11:02:56.646]             future::FutureResult(value = ...future.value$value, 
[11:02:56.646]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:56.646]                   ...future.rng), globalenv = if (FALSE) 
[11:02:56.646]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:56.646]                     ...future.globalenv.names))
[11:02:56.646]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:56.646]         }, condition = base::local({
[11:02:56.646]             c <- base::c
[11:02:56.646]             inherits <- base::inherits
[11:02:56.646]             invokeRestart <- base::invokeRestart
[11:02:56.646]             length <- base::length
[11:02:56.646]             list <- base::list
[11:02:56.646]             seq.int <- base::seq.int
[11:02:56.646]             signalCondition <- base::signalCondition
[11:02:56.646]             sys.calls <- base::sys.calls
[11:02:56.646]             `[[` <- base::`[[`
[11:02:56.646]             `+` <- base::`+`
[11:02:56.646]             `<<-` <- base::`<<-`
[11:02:56.646]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:56.646]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:56.646]                   3L)]
[11:02:56.646]             }
[11:02:56.646]             function(cond) {
[11:02:56.646]                 is_error <- inherits(cond, "error")
[11:02:56.646]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:56.646]                   NULL)
[11:02:56.646]                 if (is_error) {
[11:02:56.646]                   sessionInformation <- function() {
[11:02:56.646]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:56.646]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:56.646]                       search = base::search(), system = base::Sys.info())
[11:02:56.646]                   }
[11:02:56.646]                   ...future.conditions[[length(...future.conditions) + 
[11:02:56.646]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:56.646]                     cond$call), session = sessionInformation(), 
[11:02:56.646]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:56.646]                   signalCondition(cond)
[11:02:56.646]                 }
[11:02:56.646]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:56.646]                 "immediateCondition"))) {
[11:02:56.646]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:56.646]                   ...future.conditions[[length(...future.conditions) + 
[11:02:56.646]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:56.646]                   if (TRUE && !signal) {
[11:02:56.646]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:56.646]                     {
[11:02:56.646]                       inherits <- base::inherits
[11:02:56.646]                       invokeRestart <- base::invokeRestart
[11:02:56.646]                       is.null <- base::is.null
[11:02:56.646]                       muffled <- FALSE
[11:02:56.646]                       if (inherits(cond, "message")) {
[11:02:56.646]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:56.646]                         if (muffled) 
[11:02:56.646]                           invokeRestart("muffleMessage")
[11:02:56.646]                       }
[11:02:56.646]                       else if (inherits(cond, "warning")) {
[11:02:56.646]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:56.646]                         if (muffled) 
[11:02:56.646]                           invokeRestart("muffleWarning")
[11:02:56.646]                       }
[11:02:56.646]                       else if (inherits(cond, "condition")) {
[11:02:56.646]                         if (!is.null(pattern)) {
[11:02:56.646]                           computeRestarts <- base::computeRestarts
[11:02:56.646]                           grepl <- base::grepl
[11:02:56.646]                           restarts <- computeRestarts(cond)
[11:02:56.646]                           for (restart in restarts) {
[11:02:56.646]                             name <- restart$name
[11:02:56.646]                             if (is.null(name)) 
[11:02:56.646]                               next
[11:02:56.646]                             if (!grepl(pattern, name)) 
[11:02:56.646]                               next
[11:02:56.646]                             invokeRestart(restart)
[11:02:56.646]                             muffled <- TRUE
[11:02:56.646]                             break
[11:02:56.646]                           }
[11:02:56.646]                         }
[11:02:56.646]                       }
[11:02:56.646]                       invisible(muffled)
[11:02:56.646]                     }
[11:02:56.646]                     muffleCondition(cond, pattern = "^muffle")
[11:02:56.646]                   }
[11:02:56.646]                 }
[11:02:56.646]                 else {
[11:02:56.646]                   if (TRUE) {
[11:02:56.646]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:56.646]                     {
[11:02:56.646]                       inherits <- base::inherits
[11:02:56.646]                       invokeRestart <- base::invokeRestart
[11:02:56.646]                       is.null <- base::is.null
[11:02:56.646]                       muffled <- FALSE
[11:02:56.646]                       if (inherits(cond, "message")) {
[11:02:56.646]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:56.646]                         if (muffled) 
[11:02:56.646]                           invokeRestart("muffleMessage")
[11:02:56.646]                       }
[11:02:56.646]                       else if (inherits(cond, "warning")) {
[11:02:56.646]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:56.646]                         if (muffled) 
[11:02:56.646]                           invokeRestart("muffleWarning")
[11:02:56.646]                       }
[11:02:56.646]                       else if (inherits(cond, "condition")) {
[11:02:56.646]                         if (!is.null(pattern)) {
[11:02:56.646]                           computeRestarts <- base::computeRestarts
[11:02:56.646]                           grepl <- base::grepl
[11:02:56.646]                           restarts <- computeRestarts(cond)
[11:02:56.646]                           for (restart in restarts) {
[11:02:56.646]                             name <- restart$name
[11:02:56.646]                             if (is.null(name)) 
[11:02:56.646]                               next
[11:02:56.646]                             if (!grepl(pattern, name)) 
[11:02:56.646]                               next
[11:02:56.646]                             invokeRestart(restart)
[11:02:56.646]                             muffled <- TRUE
[11:02:56.646]                             break
[11:02:56.646]                           }
[11:02:56.646]                         }
[11:02:56.646]                       }
[11:02:56.646]                       invisible(muffled)
[11:02:56.646]                     }
[11:02:56.646]                     muffleCondition(cond, pattern = "^muffle")
[11:02:56.646]                   }
[11:02:56.646]                 }
[11:02:56.646]             }
[11:02:56.646]         }))
[11:02:56.646]     }, error = function(ex) {
[11:02:56.646]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:56.646]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:56.646]                 ...future.rng), started = ...future.startTime, 
[11:02:56.646]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:56.646]             version = "1.8"), class = "FutureResult")
[11:02:56.646]     }, finally = {
[11:02:56.646]         if (!identical(...future.workdir, getwd())) 
[11:02:56.646]             setwd(...future.workdir)
[11:02:56.646]         {
[11:02:56.646]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:56.646]                 ...future.oldOptions$nwarnings <- NULL
[11:02:56.646]             }
[11:02:56.646]             base::options(...future.oldOptions)
[11:02:56.646]             if (.Platform$OS.type == "windows") {
[11:02:56.646]                 old_names <- names(...future.oldEnvVars)
[11:02:56.646]                 envs <- base::Sys.getenv()
[11:02:56.646]                 names <- names(envs)
[11:02:56.646]                 common <- intersect(names, old_names)
[11:02:56.646]                 added <- setdiff(names, old_names)
[11:02:56.646]                 removed <- setdiff(old_names, names)
[11:02:56.646]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:56.646]                   envs[common]]
[11:02:56.646]                 NAMES <- toupper(changed)
[11:02:56.646]                 args <- list()
[11:02:56.646]                 for (kk in seq_along(NAMES)) {
[11:02:56.646]                   name <- changed[[kk]]
[11:02:56.646]                   NAME <- NAMES[[kk]]
[11:02:56.646]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:56.646]                     next
[11:02:56.646]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:56.646]                 }
[11:02:56.646]                 NAMES <- toupper(added)
[11:02:56.646]                 for (kk in seq_along(NAMES)) {
[11:02:56.646]                   name <- added[[kk]]
[11:02:56.646]                   NAME <- NAMES[[kk]]
[11:02:56.646]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:56.646]                     next
[11:02:56.646]                   args[[name]] <- ""
[11:02:56.646]                 }
[11:02:56.646]                 NAMES <- toupper(removed)
[11:02:56.646]                 for (kk in seq_along(NAMES)) {
[11:02:56.646]                   name <- removed[[kk]]
[11:02:56.646]                   NAME <- NAMES[[kk]]
[11:02:56.646]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:56.646]                     next
[11:02:56.646]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:56.646]                 }
[11:02:56.646]                 if (length(args) > 0) 
[11:02:56.646]                   base::do.call(base::Sys.setenv, args = args)
[11:02:56.646]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:56.646]             }
[11:02:56.646]             else {
[11:02:56.646]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:56.646]             }
[11:02:56.646]             {
[11:02:56.646]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:56.646]                   0L) {
[11:02:56.646]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:56.646]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:56.646]                   base::options(opts)
[11:02:56.646]                 }
[11:02:56.646]                 {
[11:02:56.646]                   {
[11:02:56.646]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:56.646]                     NULL
[11:02:56.646]                   }
[11:02:56.646]                   options(future.plan = NULL)
[11:02:56.646]                   if (is.na(NA_character_)) 
[11:02:56.646]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:56.646]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:56.646]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:56.646]                     .init = FALSE)
[11:02:56.646]                 }
[11:02:56.646]             }
[11:02:56.646]         }
[11:02:56.646]     })
[11:02:56.646]     if (TRUE) {
[11:02:56.646]         base::sink(type = "output", split = FALSE)
[11:02:56.646]         if (TRUE) {
[11:02:56.646]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:56.646]         }
[11:02:56.646]         else {
[11:02:56.646]             ...future.result["stdout"] <- base::list(NULL)
[11:02:56.646]         }
[11:02:56.646]         base::close(...future.stdout)
[11:02:56.646]         ...future.stdout <- NULL
[11:02:56.646]     }
[11:02:56.646]     ...future.result$conditions <- ...future.conditions
[11:02:56.646]     ...future.result$finished <- base::Sys.time()
[11:02:56.646]     ...future.result
[11:02:56.646] }
[11:02:56.649] MultisessionFuture started
[11:02:56.649] - Launch lazy future ... done
[11:02:56.649] run() for ‘MultisessionFuture’ ... done
[11:02:56.661] receiveMessageFromWorker() for ClusterFuture ...
[11:02:56.661] - Validating connection of MultisessionFuture
[11:02:56.661] - received message: FutureResult
[11:02:56.661] - Received FutureResult
[11:02:56.661] - Erased future from FutureRegistry
[11:02:56.662] result() for ClusterFuture ...
[11:02:56.662] - result already collected: FutureResult
[11:02:56.662] result() for ClusterFuture ... done
[11:02:56.662] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:56.662] Future #2
[11:02:56.662]  length: 2 (resolved future 2)
[11:02:56.662]  length: 1 (resolved future 3)
[11:02:56.693] receiveMessageFromWorker() for ClusterFuture ...
[11:02:56.693] - Validating connection of MultisessionFuture
[11:02:56.694] - received message: FutureResult
[11:02:56.694] - Received FutureResult
[11:02:56.694] - Erased future from FutureRegistry
[11:02:56.694] result() for ClusterFuture ...
[11:02:56.694] - result already collected: FutureResult
[11:02:56.694] result() for ClusterFuture ... done
[11:02:56.694] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:56.694] Future #1
[11:02:56.695]  length: 0 (resolved future 1)
[11:02:56.695] resolve() on list ... DONE
[11:02:56.695] getGlobalsAndPackages() ...
[11:02:56.695] Searching for globals...
[11:02:56.695] 
[11:02:56.695] Searching for globals ... DONE
[11:02:56.695] - globals: [0] <none>
[11:02:56.695] getGlobalsAndPackages() ... DONE
[11:02:56.696] getGlobalsAndPackages() ...
[11:02:56.696] Searching for globals...
[11:02:56.696] 
[11:02:56.696] Searching for globals ... DONE
[11:02:56.696] - globals: [0] <none>
[11:02:56.696] getGlobalsAndPackages() ... DONE
[11:02:56.696] resolve() on list ...
[11:02:56.697]  recursive: 0
[11:02:56.697]  length: 3
[11:02:56.697]  elements: ‘a’, ‘b’, ‘’
[11:02:56.697] run() for ‘Future’ ...
[11:02:56.697] - state: ‘created’
[11:02:56.697] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:56.711] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:56.711] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:56.711]   - Field: ‘node’
[11:02:56.711]   - Field: ‘label’
[11:02:56.711]   - Field: ‘local’
[11:02:56.711]   - Field: ‘owner’
[11:02:56.711]   - Field: ‘envir’
[11:02:56.711]   - Field: ‘workers’
[11:02:56.711]   - Field: ‘packages’
[11:02:56.712]   - Field: ‘gc’
[11:02:56.712]   - Field: ‘conditions’
[11:02:56.712]   - Field: ‘persistent’
[11:02:56.712]   - Field: ‘expr’
[11:02:56.712]   - Field: ‘uuid’
[11:02:56.712]   - Field: ‘seed’
[11:02:56.712]   - Field: ‘version’
[11:02:56.712]   - Field: ‘result’
[11:02:56.712]   - Field: ‘asynchronous’
[11:02:56.712]   - Field: ‘calls’
[11:02:56.712]   - Field: ‘globals’
[11:02:56.712]   - Field: ‘stdout’
[11:02:56.713]   - Field: ‘earlySignal’
[11:02:56.713]   - Field: ‘lazy’
[11:02:56.713]   - Field: ‘state’
[11:02:56.713] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:56.713] - Launch lazy future ...
[11:02:56.713] Packages needed by the future expression (n = 0): <none>
[11:02:56.713] Packages needed by future strategies (n = 0): <none>
[11:02:56.714] {
[11:02:56.714]     {
[11:02:56.714]         {
[11:02:56.714]             ...future.startTime <- base::Sys.time()
[11:02:56.714]             {
[11:02:56.714]                 {
[11:02:56.714]                   {
[11:02:56.714]                     {
[11:02:56.714]                       base::local({
[11:02:56.714]                         has_future <- base::requireNamespace("future", 
[11:02:56.714]                           quietly = TRUE)
[11:02:56.714]                         if (has_future) {
[11:02:56.714]                           ns <- base::getNamespace("future")
[11:02:56.714]                           version <- ns[[".package"]][["version"]]
[11:02:56.714]                           if (is.null(version)) 
[11:02:56.714]                             version <- utils::packageVersion("future")
[11:02:56.714]                         }
[11:02:56.714]                         else {
[11:02:56.714]                           version <- NULL
[11:02:56.714]                         }
[11:02:56.714]                         if (!has_future || version < "1.8.0") {
[11:02:56.714]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:56.714]                             "", base::R.version$version.string), 
[11:02:56.714]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:56.714]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:56.714]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:56.714]                               "release", "version")], collapse = " "), 
[11:02:56.714]                             hostname = base::Sys.info()[["nodename"]])
[11:02:56.714]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:56.714]                             info)
[11:02:56.714]                           info <- base::paste(info, collapse = "; ")
[11:02:56.714]                           if (!has_future) {
[11:02:56.714]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:56.714]                               info)
[11:02:56.714]                           }
[11:02:56.714]                           else {
[11:02:56.714]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:56.714]                               info, version)
[11:02:56.714]                           }
[11:02:56.714]                           base::stop(msg)
[11:02:56.714]                         }
[11:02:56.714]                       })
[11:02:56.714]                     }
[11:02:56.714]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:56.714]                     base::options(mc.cores = 1L)
[11:02:56.714]                   }
[11:02:56.714]                   ...future.strategy.old <- future::plan("list")
[11:02:56.714]                   options(future.plan = NULL)
[11:02:56.714]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:56.714]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:56.714]                 }
[11:02:56.714]                 ...future.workdir <- getwd()
[11:02:56.714]             }
[11:02:56.714]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:56.714]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:56.714]         }
[11:02:56.714]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:56.714]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:56.714]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:56.714]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:56.714]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:56.714]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:56.714]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:56.714]             base::names(...future.oldOptions))
[11:02:56.714]     }
[11:02:56.714]     if (FALSE) {
[11:02:56.714]     }
[11:02:56.714]     else {
[11:02:56.714]         if (TRUE) {
[11:02:56.714]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:56.714]                 open = "w")
[11:02:56.714]         }
[11:02:56.714]         else {
[11:02:56.714]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:56.714]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:56.714]         }
[11:02:56.714]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:56.714]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:56.714]             base::sink(type = "output", split = FALSE)
[11:02:56.714]             base::close(...future.stdout)
[11:02:56.714]         }, add = TRUE)
[11:02:56.714]     }
[11:02:56.714]     ...future.frame <- base::sys.nframe()
[11:02:56.714]     ...future.conditions <- base::list()
[11:02:56.714]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:56.714]     if (FALSE) {
[11:02:56.714]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:56.714]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:56.714]     }
[11:02:56.714]     ...future.result <- base::tryCatch({
[11:02:56.714]         base::withCallingHandlers({
[11:02:56.714]             ...future.value <- base::withVisible(base::local({
[11:02:56.714]                 ...future.makeSendCondition <- base::local({
[11:02:56.714]                   sendCondition <- NULL
[11:02:56.714]                   function(frame = 1L) {
[11:02:56.714]                     if (is.function(sendCondition)) 
[11:02:56.714]                       return(sendCondition)
[11:02:56.714]                     ns <- getNamespace("parallel")
[11:02:56.714]                     if (exists("sendData", mode = "function", 
[11:02:56.714]                       envir = ns)) {
[11:02:56.714]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:56.714]                         envir = ns)
[11:02:56.714]                       envir <- sys.frame(frame)
[11:02:56.714]                       master <- NULL
[11:02:56.714]                       while (!identical(envir, .GlobalEnv) && 
[11:02:56.714]                         !identical(envir, emptyenv())) {
[11:02:56.714]                         if (exists("master", mode = "list", envir = envir, 
[11:02:56.714]                           inherits = FALSE)) {
[11:02:56.714]                           master <- get("master", mode = "list", 
[11:02:56.714]                             envir = envir, inherits = FALSE)
[11:02:56.714]                           if (inherits(master, c("SOCKnode", 
[11:02:56.714]                             "SOCK0node"))) {
[11:02:56.714]                             sendCondition <<- function(cond) {
[11:02:56.714]                               data <- list(type = "VALUE", value = cond, 
[11:02:56.714]                                 success = TRUE)
[11:02:56.714]                               parallel_sendData(master, data)
[11:02:56.714]                             }
[11:02:56.714]                             return(sendCondition)
[11:02:56.714]                           }
[11:02:56.714]                         }
[11:02:56.714]                         frame <- frame + 1L
[11:02:56.714]                         envir <- sys.frame(frame)
[11:02:56.714]                       }
[11:02:56.714]                     }
[11:02:56.714]                     sendCondition <<- function(cond) NULL
[11:02:56.714]                   }
[11:02:56.714]                 })
[11:02:56.714]                 withCallingHandlers({
[11:02:56.714]                   1
[11:02:56.714]                 }, immediateCondition = function(cond) {
[11:02:56.714]                   sendCondition <- ...future.makeSendCondition()
[11:02:56.714]                   sendCondition(cond)
[11:02:56.714]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:56.714]                   {
[11:02:56.714]                     inherits <- base::inherits
[11:02:56.714]                     invokeRestart <- base::invokeRestart
[11:02:56.714]                     is.null <- base::is.null
[11:02:56.714]                     muffled <- FALSE
[11:02:56.714]                     if (inherits(cond, "message")) {
[11:02:56.714]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:56.714]                       if (muffled) 
[11:02:56.714]                         invokeRestart("muffleMessage")
[11:02:56.714]                     }
[11:02:56.714]                     else if (inherits(cond, "warning")) {
[11:02:56.714]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:56.714]                       if (muffled) 
[11:02:56.714]                         invokeRestart("muffleWarning")
[11:02:56.714]                     }
[11:02:56.714]                     else if (inherits(cond, "condition")) {
[11:02:56.714]                       if (!is.null(pattern)) {
[11:02:56.714]                         computeRestarts <- base::computeRestarts
[11:02:56.714]                         grepl <- base::grepl
[11:02:56.714]                         restarts <- computeRestarts(cond)
[11:02:56.714]                         for (restart in restarts) {
[11:02:56.714]                           name <- restart$name
[11:02:56.714]                           if (is.null(name)) 
[11:02:56.714]                             next
[11:02:56.714]                           if (!grepl(pattern, name)) 
[11:02:56.714]                             next
[11:02:56.714]                           invokeRestart(restart)
[11:02:56.714]                           muffled <- TRUE
[11:02:56.714]                           break
[11:02:56.714]                         }
[11:02:56.714]                       }
[11:02:56.714]                     }
[11:02:56.714]                     invisible(muffled)
[11:02:56.714]                   }
[11:02:56.714]                   muffleCondition(cond)
[11:02:56.714]                 })
[11:02:56.714]             }))
[11:02:56.714]             future::FutureResult(value = ...future.value$value, 
[11:02:56.714]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:56.714]                   ...future.rng), globalenv = if (FALSE) 
[11:02:56.714]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:56.714]                     ...future.globalenv.names))
[11:02:56.714]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:56.714]         }, condition = base::local({
[11:02:56.714]             c <- base::c
[11:02:56.714]             inherits <- base::inherits
[11:02:56.714]             invokeRestart <- base::invokeRestart
[11:02:56.714]             length <- base::length
[11:02:56.714]             list <- base::list
[11:02:56.714]             seq.int <- base::seq.int
[11:02:56.714]             signalCondition <- base::signalCondition
[11:02:56.714]             sys.calls <- base::sys.calls
[11:02:56.714]             `[[` <- base::`[[`
[11:02:56.714]             `+` <- base::`+`
[11:02:56.714]             `<<-` <- base::`<<-`
[11:02:56.714]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:56.714]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:56.714]                   3L)]
[11:02:56.714]             }
[11:02:56.714]             function(cond) {
[11:02:56.714]                 is_error <- inherits(cond, "error")
[11:02:56.714]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:56.714]                   NULL)
[11:02:56.714]                 if (is_error) {
[11:02:56.714]                   sessionInformation <- function() {
[11:02:56.714]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:56.714]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:56.714]                       search = base::search(), system = base::Sys.info())
[11:02:56.714]                   }
[11:02:56.714]                   ...future.conditions[[length(...future.conditions) + 
[11:02:56.714]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:56.714]                     cond$call), session = sessionInformation(), 
[11:02:56.714]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:56.714]                   signalCondition(cond)
[11:02:56.714]                 }
[11:02:56.714]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:56.714]                 "immediateCondition"))) {
[11:02:56.714]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:56.714]                   ...future.conditions[[length(...future.conditions) + 
[11:02:56.714]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:56.714]                   if (TRUE && !signal) {
[11:02:56.714]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:56.714]                     {
[11:02:56.714]                       inherits <- base::inherits
[11:02:56.714]                       invokeRestart <- base::invokeRestart
[11:02:56.714]                       is.null <- base::is.null
[11:02:56.714]                       muffled <- FALSE
[11:02:56.714]                       if (inherits(cond, "message")) {
[11:02:56.714]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:56.714]                         if (muffled) 
[11:02:56.714]                           invokeRestart("muffleMessage")
[11:02:56.714]                       }
[11:02:56.714]                       else if (inherits(cond, "warning")) {
[11:02:56.714]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:56.714]                         if (muffled) 
[11:02:56.714]                           invokeRestart("muffleWarning")
[11:02:56.714]                       }
[11:02:56.714]                       else if (inherits(cond, "condition")) {
[11:02:56.714]                         if (!is.null(pattern)) {
[11:02:56.714]                           computeRestarts <- base::computeRestarts
[11:02:56.714]                           grepl <- base::grepl
[11:02:56.714]                           restarts <- computeRestarts(cond)
[11:02:56.714]                           for (restart in restarts) {
[11:02:56.714]                             name <- restart$name
[11:02:56.714]                             if (is.null(name)) 
[11:02:56.714]                               next
[11:02:56.714]                             if (!grepl(pattern, name)) 
[11:02:56.714]                               next
[11:02:56.714]                             invokeRestart(restart)
[11:02:56.714]                             muffled <- TRUE
[11:02:56.714]                             break
[11:02:56.714]                           }
[11:02:56.714]                         }
[11:02:56.714]                       }
[11:02:56.714]                       invisible(muffled)
[11:02:56.714]                     }
[11:02:56.714]                     muffleCondition(cond, pattern = "^muffle")
[11:02:56.714]                   }
[11:02:56.714]                 }
[11:02:56.714]                 else {
[11:02:56.714]                   if (TRUE) {
[11:02:56.714]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:56.714]                     {
[11:02:56.714]                       inherits <- base::inherits
[11:02:56.714]                       invokeRestart <- base::invokeRestart
[11:02:56.714]                       is.null <- base::is.null
[11:02:56.714]                       muffled <- FALSE
[11:02:56.714]                       if (inherits(cond, "message")) {
[11:02:56.714]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:56.714]                         if (muffled) 
[11:02:56.714]                           invokeRestart("muffleMessage")
[11:02:56.714]                       }
[11:02:56.714]                       else if (inherits(cond, "warning")) {
[11:02:56.714]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:56.714]                         if (muffled) 
[11:02:56.714]                           invokeRestart("muffleWarning")
[11:02:56.714]                       }
[11:02:56.714]                       else if (inherits(cond, "condition")) {
[11:02:56.714]                         if (!is.null(pattern)) {
[11:02:56.714]                           computeRestarts <- base::computeRestarts
[11:02:56.714]                           grepl <- base::grepl
[11:02:56.714]                           restarts <- computeRestarts(cond)
[11:02:56.714]                           for (restart in restarts) {
[11:02:56.714]                             name <- restart$name
[11:02:56.714]                             if (is.null(name)) 
[11:02:56.714]                               next
[11:02:56.714]                             if (!grepl(pattern, name)) 
[11:02:56.714]                               next
[11:02:56.714]                             invokeRestart(restart)
[11:02:56.714]                             muffled <- TRUE
[11:02:56.714]                             break
[11:02:56.714]                           }
[11:02:56.714]                         }
[11:02:56.714]                       }
[11:02:56.714]                       invisible(muffled)
[11:02:56.714]                     }
[11:02:56.714]                     muffleCondition(cond, pattern = "^muffle")
[11:02:56.714]                   }
[11:02:56.714]                 }
[11:02:56.714]             }
[11:02:56.714]         }))
[11:02:56.714]     }, error = function(ex) {
[11:02:56.714]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:56.714]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:56.714]                 ...future.rng), started = ...future.startTime, 
[11:02:56.714]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:56.714]             version = "1.8"), class = "FutureResult")
[11:02:56.714]     }, finally = {
[11:02:56.714]         if (!identical(...future.workdir, getwd())) 
[11:02:56.714]             setwd(...future.workdir)
[11:02:56.714]         {
[11:02:56.714]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:56.714]                 ...future.oldOptions$nwarnings <- NULL
[11:02:56.714]             }
[11:02:56.714]             base::options(...future.oldOptions)
[11:02:56.714]             if (.Platform$OS.type == "windows") {
[11:02:56.714]                 old_names <- names(...future.oldEnvVars)
[11:02:56.714]                 envs <- base::Sys.getenv()
[11:02:56.714]                 names <- names(envs)
[11:02:56.714]                 common <- intersect(names, old_names)
[11:02:56.714]                 added <- setdiff(names, old_names)
[11:02:56.714]                 removed <- setdiff(old_names, names)
[11:02:56.714]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:56.714]                   envs[common]]
[11:02:56.714]                 NAMES <- toupper(changed)
[11:02:56.714]                 args <- list()
[11:02:56.714]                 for (kk in seq_along(NAMES)) {
[11:02:56.714]                   name <- changed[[kk]]
[11:02:56.714]                   NAME <- NAMES[[kk]]
[11:02:56.714]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:56.714]                     next
[11:02:56.714]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:56.714]                 }
[11:02:56.714]                 NAMES <- toupper(added)
[11:02:56.714]                 for (kk in seq_along(NAMES)) {
[11:02:56.714]                   name <- added[[kk]]
[11:02:56.714]                   NAME <- NAMES[[kk]]
[11:02:56.714]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:56.714]                     next
[11:02:56.714]                   args[[name]] <- ""
[11:02:56.714]                 }
[11:02:56.714]                 NAMES <- toupper(removed)
[11:02:56.714]                 for (kk in seq_along(NAMES)) {
[11:02:56.714]                   name <- removed[[kk]]
[11:02:56.714]                   NAME <- NAMES[[kk]]
[11:02:56.714]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:56.714]                     next
[11:02:56.714]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:56.714]                 }
[11:02:56.714]                 if (length(args) > 0) 
[11:02:56.714]                   base::do.call(base::Sys.setenv, args = args)
[11:02:56.714]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:56.714]             }
[11:02:56.714]             else {
[11:02:56.714]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:56.714]             }
[11:02:56.714]             {
[11:02:56.714]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:56.714]                   0L) {
[11:02:56.714]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:56.714]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:56.714]                   base::options(opts)
[11:02:56.714]                 }
[11:02:56.714]                 {
[11:02:56.714]                   {
[11:02:56.714]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:56.714]                     NULL
[11:02:56.714]                   }
[11:02:56.714]                   options(future.plan = NULL)
[11:02:56.714]                   if (is.na(NA_character_)) 
[11:02:56.714]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:56.714]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:56.714]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:56.714]                     .init = FALSE)
[11:02:56.714]                 }
[11:02:56.714]             }
[11:02:56.714]         }
[11:02:56.714]     })
[11:02:56.714]     if (TRUE) {
[11:02:56.714]         base::sink(type = "output", split = FALSE)
[11:02:56.714]         if (TRUE) {
[11:02:56.714]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:56.714]         }
[11:02:56.714]         else {
[11:02:56.714]             ...future.result["stdout"] <- base::list(NULL)
[11:02:56.714]         }
[11:02:56.714]         base::close(...future.stdout)
[11:02:56.714]         ...future.stdout <- NULL
[11:02:56.714]     }
[11:02:56.714]     ...future.result$conditions <- ...future.conditions
[11:02:56.714]     ...future.result$finished <- base::Sys.time()
[11:02:56.714]     ...future.result
[11:02:56.714] }
[11:02:56.717] MultisessionFuture started
[11:02:56.717] - Launch lazy future ... done
[11:02:56.717] run() for ‘MultisessionFuture’ ... done
[11:02:56.727] run() for ‘Future’ ...
[11:02:56.727] - state: ‘created’
[11:02:56.728] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:56.742] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:56.742] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:56.742]   - Field: ‘node’
[11:02:56.742]   - Field: ‘label’
[11:02:56.742]   - Field: ‘local’
[11:02:56.742]   - Field: ‘owner’
[11:02:56.742]   - Field: ‘envir’
[11:02:56.742]   - Field: ‘workers’
[11:02:56.742]   - Field: ‘packages’
[11:02:56.742]   - Field: ‘gc’
[11:02:56.743]   - Field: ‘conditions’
[11:02:56.743]   - Field: ‘persistent’
[11:02:56.743]   - Field: ‘expr’
[11:02:56.743]   - Field: ‘uuid’
[11:02:56.743]   - Field: ‘seed’
[11:02:56.743]   - Field: ‘version’
[11:02:56.743]   - Field: ‘result’
[11:02:56.743]   - Field: ‘asynchronous’
[11:02:56.743]   - Field: ‘calls’
[11:02:56.743]   - Field: ‘globals’
[11:02:56.743]   - Field: ‘stdout’
[11:02:56.744]   - Field: ‘earlySignal’
[11:02:56.744]   - Field: ‘lazy’
[11:02:56.744]   - Field: ‘state’
[11:02:56.744] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:56.744] - Launch lazy future ...
[11:02:56.744] Packages needed by the future expression (n = 0): <none>
[11:02:56.744] Packages needed by future strategies (n = 0): <none>
[11:02:56.745] {
[11:02:56.745]     {
[11:02:56.745]         {
[11:02:56.745]             ...future.startTime <- base::Sys.time()
[11:02:56.745]             {
[11:02:56.745]                 {
[11:02:56.745]                   {
[11:02:56.745]                     {
[11:02:56.745]                       base::local({
[11:02:56.745]                         has_future <- base::requireNamespace("future", 
[11:02:56.745]                           quietly = TRUE)
[11:02:56.745]                         if (has_future) {
[11:02:56.745]                           ns <- base::getNamespace("future")
[11:02:56.745]                           version <- ns[[".package"]][["version"]]
[11:02:56.745]                           if (is.null(version)) 
[11:02:56.745]                             version <- utils::packageVersion("future")
[11:02:56.745]                         }
[11:02:56.745]                         else {
[11:02:56.745]                           version <- NULL
[11:02:56.745]                         }
[11:02:56.745]                         if (!has_future || version < "1.8.0") {
[11:02:56.745]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:56.745]                             "", base::R.version$version.string), 
[11:02:56.745]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:56.745]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:56.745]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:56.745]                               "release", "version")], collapse = " "), 
[11:02:56.745]                             hostname = base::Sys.info()[["nodename"]])
[11:02:56.745]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:56.745]                             info)
[11:02:56.745]                           info <- base::paste(info, collapse = "; ")
[11:02:56.745]                           if (!has_future) {
[11:02:56.745]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:56.745]                               info)
[11:02:56.745]                           }
[11:02:56.745]                           else {
[11:02:56.745]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:56.745]                               info, version)
[11:02:56.745]                           }
[11:02:56.745]                           base::stop(msg)
[11:02:56.745]                         }
[11:02:56.745]                       })
[11:02:56.745]                     }
[11:02:56.745]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:56.745]                     base::options(mc.cores = 1L)
[11:02:56.745]                   }
[11:02:56.745]                   ...future.strategy.old <- future::plan("list")
[11:02:56.745]                   options(future.plan = NULL)
[11:02:56.745]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:56.745]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:56.745]                 }
[11:02:56.745]                 ...future.workdir <- getwd()
[11:02:56.745]             }
[11:02:56.745]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:56.745]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:56.745]         }
[11:02:56.745]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:56.745]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:56.745]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:56.745]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:56.745]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:56.745]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:56.745]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:56.745]             base::names(...future.oldOptions))
[11:02:56.745]     }
[11:02:56.745]     if (FALSE) {
[11:02:56.745]     }
[11:02:56.745]     else {
[11:02:56.745]         if (TRUE) {
[11:02:56.745]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:56.745]                 open = "w")
[11:02:56.745]         }
[11:02:56.745]         else {
[11:02:56.745]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:56.745]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:56.745]         }
[11:02:56.745]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:56.745]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:56.745]             base::sink(type = "output", split = FALSE)
[11:02:56.745]             base::close(...future.stdout)
[11:02:56.745]         }, add = TRUE)
[11:02:56.745]     }
[11:02:56.745]     ...future.frame <- base::sys.nframe()
[11:02:56.745]     ...future.conditions <- base::list()
[11:02:56.745]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:56.745]     if (FALSE) {
[11:02:56.745]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:56.745]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:56.745]     }
[11:02:56.745]     ...future.result <- base::tryCatch({
[11:02:56.745]         base::withCallingHandlers({
[11:02:56.745]             ...future.value <- base::withVisible(base::local({
[11:02:56.745]                 ...future.makeSendCondition <- base::local({
[11:02:56.745]                   sendCondition <- NULL
[11:02:56.745]                   function(frame = 1L) {
[11:02:56.745]                     if (is.function(sendCondition)) 
[11:02:56.745]                       return(sendCondition)
[11:02:56.745]                     ns <- getNamespace("parallel")
[11:02:56.745]                     if (exists("sendData", mode = "function", 
[11:02:56.745]                       envir = ns)) {
[11:02:56.745]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:56.745]                         envir = ns)
[11:02:56.745]                       envir <- sys.frame(frame)
[11:02:56.745]                       master <- NULL
[11:02:56.745]                       while (!identical(envir, .GlobalEnv) && 
[11:02:56.745]                         !identical(envir, emptyenv())) {
[11:02:56.745]                         if (exists("master", mode = "list", envir = envir, 
[11:02:56.745]                           inherits = FALSE)) {
[11:02:56.745]                           master <- get("master", mode = "list", 
[11:02:56.745]                             envir = envir, inherits = FALSE)
[11:02:56.745]                           if (inherits(master, c("SOCKnode", 
[11:02:56.745]                             "SOCK0node"))) {
[11:02:56.745]                             sendCondition <<- function(cond) {
[11:02:56.745]                               data <- list(type = "VALUE", value = cond, 
[11:02:56.745]                                 success = TRUE)
[11:02:56.745]                               parallel_sendData(master, data)
[11:02:56.745]                             }
[11:02:56.745]                             return(sendCondition)
[11:02:56.745]                           }
[11:02:56.745]                         }
[11:02:56.745]                         frame <- frame + 1L
[11:02:56.745]                         envir <- sys.frame(frame)
[11:02:56.745]                       }
[11:02:56.745]                     }
[11:02:56.745]                     sendCondition <<- function(cond) NULL
[11:02:56.745]                   }
[11:02:56.745]                 })
[11:02:56.745]                 withCallingHandlers({
[11:02:56.745]                   2
[11:02:56.745]                 }, immediateCondition = function(cond) {
[11:02:56.745]                   sendCondition <- ...future.makeSendCondition()
[11:02:56.745]                   sendCondition(cond)
[11:02:56.745]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:56.745]                   {
[11:02:56.745]                     inherits <- base::inherits
[11:02:56.745]                     invokeRestart <- base::invokeRestart
[11:02:56.745]                     is.null <- base::is.null
[11:02:56.745]                     muffled <- FALSE
[11:02:56.745]                     if (inherits(cond, "message")) {
[11:02:56.745]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:56.745]                       if (muffled) 
[11:02:56.745]                         invokeRestart("muffleMessage")
[11:02:56.745]                     }
[11:02:56.745]                     else if (inherits(cond, "warning")) {
[11:02:56.745]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:56.745]                       if (muffled) 
[11:02:56.745]                         invokeRestart("muffleWarning")
[11:02:56.745]                     }
[11:02:56.745]                     else if (inherits(cond, "condition")) {
[11:02:56.745]                       if (!is.null(pattern)) {
[11:02:56.745]                         computeRestarts <- base::computeRestarts
[11:02:56.745]                         grepl <- base::grepl
[11:02:56.745]                         restarts <- computeRestarts(cond)
[11:02:56.745]                         for (restart in restarts) {
[11:02:56.745]                           name <- restart$name
[11:02:56.745]                           if (is.null(name)) 
[11:02:56.745]                             next
[11:02:56.745]                           if (!grepl(pattern, name)) 
[11:02:56.745]                             next
[11:02:56.745]                           invokeRestart(restart)
[11:02:56.745]                           muffled <- TRUE
[11:02:56.745]                           break
[11:02:56.745]                         }
[11:02:56.745]                       }
[11:02:56.745]                     }
[11:02:56.745]                     invisible(muffled)
[11:02:56.745]                   }
[11:02:56.745]                   muffleCondition(cond)
[11:02:56.745]                 })
[11:02:56.745]             }))
[11:02:56.745]             future::FutureResult(value = ...future.value$value, 
[11:02:56.745]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:56.745]                   ...future.rng), globalenv = if (FALSE) 
[11:02:56.745]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:56.745]                     ...future.globalenv.names))
[11:02:56.745]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:56.745]         }, condition = base::local({
[11:02:56.745]             c <- base::c
[11:02:56.745]             inherits <- base::inherits
[11:02:56.745]             invokeRestart <- base::invokeRestart
[11:02:56.745]             length <- base::length
[11:02:56.745]             list <- base::list
[11:02:56.745]             seq.int <- base::seq.int
[11:02:56.745]             signalCondition <- base::signalCondition
[11:02:56.745]             sys.calls <- base::sys.calls
[11:02:56.745]             `[[` <- base::`[[`
[11:02:56.745]             `+` <- base::`+`
[11:02:56.745]             `<<-` <- base::`<<-`
[11:02:56.745]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:56.745]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:56.745]                   3L)]
[11:02:56.745]             }
[11:02:56.745]             function(cond) {
[11:02:56.745]                 is_error <- inherits(cond, "error")
[11:02:56.745]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:56.745]                   NULL)
[11:02:56.745]                 if (is_error) {
[11:02:56.745]                   sessionInformation <- function() {
[11:02:56.745]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:56.745]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:56.745]                       search = base::search(), system = base::Sys.info())
[11:02:56.745]                   }
[11:02:56.745]                   ...future.conditions[[length(...future.conditions) + 
[11:02:56.745]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:56.745]                     cond$call), session = sessionInformation(), 
[11:02:56.745]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:56.745]                   signalCondition(cond)
[11:02:56.745]                 }
[11:02:56.745]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:56.745]                 "immediateCondition"))) {
[11:02:56.745]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:56.745]                   ...future.conditions[[length(...future.conditions) + 
[11:02:56.745]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:56.745]                   if (TRUE && !signal) {
[11:02:56.745]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:56.745]                     {
[11:02:56.745]                       inherits <- base::inherits
[11:02:56.745]                       invokeRestart <- base::invokeRestart
[11:02:56.745]                       is.null <- base::is.null
[11:02:56.745]                       muffled <- FALSE
[11:02:56.745]                       if (inherits(cond, "message")) {
[11:02:56.745]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:56.745]                         if (muffled) 
[11:02:56.745]                           invokeRestart("muffleMessage")
[11:02:56.745]                       }
[11:02:56.745]                       else if (inherits(cond, "warning")) {
[11:02:56.745]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:56.745]                         if (muffled) 
[11:02:56.745]                           invokeRestart("muffleWarning")
[11:02:56.745]                       }
[11:02:56.745]                       else if (inherits(cond, "condition")) {
[11:02:56.745]                         if (!is.null(pattern)) {
[11:02:56.745]                           computeRestarts <- base::computeRestarts
[11:02:56.745]                           grepl <- base::grepl
[11:02:56.745]                           restarts <- computeRestarts(cond)
[11:02:56.745]                           for (restart in restarts) {
[11:02:56.745]                             name <- restart$name
[11:02:56.745]                             if (is.null(name)) 
[11:02:56.745]                               next
[11:02:56.745]                             if (!grepl(pattern, name)) 
[11:02:56.745]                               next
[11:02:56.745]                             invokeRestart(restart)
[11:02:56.745]                             muffled <- TRUE
[11:02:56.745]                             break
[11:02:56.745]                           }
[11:02:56.745]                         }
[11:02:56.745]                       }
[11:02:56.745]                       invisible(muffled)
[11:02:56.745]                     }
[11:02:56.745]                     muffleCondition(cond, pattern = "^muffle")
[11:02:56.745]                   }
[11:02:56.745]                 }
[11:02:56.745]                 else {
[11:02:56.745]                   if (TRUE) {
[11:02:56.745]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:56.745]                     {
[11:02:56.745]                       inherits <- base::inherits
[11:02:56.745]                       invokeRestart <- base::invokeRestart
[11:02:56.745]                       is.null <- base::is.null
[11:02:56.745]                       muffled <- FALSE
[11:02:56.745]                       if (inherits(cond, "message")) {
[11:02:56.745]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:56.745]                         if (muffled) 
[11:02:56.745]                           invokeRestart("muffleMessage")
[11:02:56.745]                       }
[11:02:56.745]                       else if (inherits(cond, "warning")) {
[11:02:56.745]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:56.745]                         if (muffled) 
[11:02:56.745]                           invokeRestart("muffleWarning")
[11:02:56.745]                       }
[11:02:56.745]                       else if (inherits(cond, "condition")) {
[11:02:56.745]                         if (!is.null(pattern)) {
[11:02:56.745]                           computeRestarts <- base::computeRestarts
[11:02:56.745]                           grepl <- base::grepl
[11:02:56.745]                           restarts <- computeRestarts(cond)
[11:02:56.745]                           for (restart in restarts) {
[11:02:56.745]                             name <- restart$name
[11:02:56.745]                             if (is.null(name)) 
[11:02:56.745]                               next
[11:02:56.745]                             if (!grepl(pattern, name)) 
[11:02:56.745]                               next
[11:02:56.745]                             invokeRestart(restart)
[11:02:56.745]                             muffled <- TRUE
[11:02:56.745]                             break
[11:02:56.745]                           }
[11:02:56.745]                         }
[11:02:56.745]                       }
[11:02:56.745]                       invisible(muffled)
[11:02:56.745]                     }
[11:02:56.745]                     muffleCondition(cond, pattern = "^muffle")
[11:02:56.745]                   }
[11:02:56.745]                 }
[11:02:56.745]             }
[11:02:56.745]         }))
[11:02:56.745]     }, error = function(ex) {
[11:02:56.745]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:56.745]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:56.745]                 ...future.rng), started = ...future.startTime, 
[11:02:56.745]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:56.745]             version = "1.8"), class = "FutureResult")
[11:02:56.745]     }, finally = {
[11:02:56.745]         if (!identical(...future.workdir, getwd())) 
[11:02:56.745]             setwd(...future.workdir)
[11:02:56.745]         {
[11:02:56.745]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:56.745]                 ...future.oldOptions$nwarnings <- NULL
[11:02:56.745]             }
[11:02:56.745]             base::options(...future.oldOptions)
[11:02:56.745]             if (.Platform$OS.type == "windows") {
[11:02:56.745]                 old_names <- names(...future.oldEnvVars)
[11:02:56.745]                 envs <- base::Sys.getenv()
[11:02:56.745]                 names <- names(envs)
[11:02:56.745]                 common <- intersect(names, old_names)
[11:02:56.745]                 added <- setdiff(names, old_names)
[11:02:56.745]                 removed <- setdiff(old_names, names)
[11:02:56.745]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:56.745]                   envs[common]]
[11:02:56.745]                 NAMES <- toupper(changed)
[11:02:56.745]                 args <- list()
[11:02:56.745]                 for (kk in seq_along(NAMES)) {
[11:02:56.745]                   name <- changed[[kk]]
[11:02:56.745]                   NAME <- NAMES[[kk]]
[11:02:56.745]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:56.745]                     next
[11:02:56.745]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:56.745]                 }
[11:02:56.745]                 NAMES <- toupper(added)
[11:02:56.745]                 for (kk in seq_along(NAMES)) {
[11:02:56.745]                   name <- added[[kk]]
[11:02:56.745]                   NAME <- NAMES[[kk]]
[11:02:56.745]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:56.745]                     next
[11:02:56.745]                   args[[name]] <- ""
[11:02:56.745]                 }
[11:02:56.745]                 NAMES <- toupper(removed)
[11:02:56.745]                 for (kk in seq_along(NAMES)) {
[11:02:56.745]                   name <- removed[[kk]]
[11:02:56.745]                   NAME <- NAMES[[kk]]
[11:02:56.745]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:56.745]                     next
[11:02:56.745]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:56.745]                 }
[11:02:56.745]                 if (length(args) > 0) 
[11:02:56.745]                   base::do.call(base::Sys.setenv, args = args)
[11:02:56.745]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:56.745]             }
[11:02:56.745]             else {
[11:02:56.745]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:56.745]             }
[11:02:56.745]             {
[11:02:56.745]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:56.745]                   0L) {
[11:02:56.745]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:56.745]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:56.745]                   base::options(opts)
[11:02:56.745]                 }
[11:02:56.745]                 {
[11:02:56.745]                   {
[11:02:56.745]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:56.745]                     NULL
[11:02:56.745]                   }
[11:02:56.745]                   options(future.plan = NULL)
[11:02:56.745]                   if (is.na(NA_character_)) 
[11:02:56.745]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:56.745]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:56.745]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:56.745]                     .init = FALSE)
[11:02:56.745]                 }
[11:02:56.745]             }
[11:02:56.745]         }
[11:02:56.745]     })
[11:02:56.745]     if (TRUE) {
[11:02:56.745]         base::sink(type = "output", split = FALSE)
[11:02:56.745]         if (TRUE) {
[11:02:56.745]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:56.745]         }
[11:02:56.745]         else {
[11:02:56.745]             ...future.result["stdout"] <- base::list(NULL)
[11:02:56.745]         }
[11:02:56.745]         base::close(...future.stdout)
[11:02:56.745]         ...future.stdout <- NULL
[11:02:56.745]     }
[11:02:56.745]     ...future.result$conditions <- ...future.conditions
[11:02:56.745]     ...future.result$finished <- base::Sys.time()
[11:02:56.745]     ...future.result
[11:02:56.745] }
[11:02:56.748] MultisessionFuture started
[11:02:56.748] - Launch lazy future ... done
[11:02:56.748] run() for ‘MultisessionFuture’ ... done
[11:02:56.758]  length: 2 (resolved future 3)
[11:02:56.769] receiveMessageFromWorker() for ClusterFuture ...
[11:02:56.769] - Validating connection of MultisessionFuture
[11:02:56.769] - received message: FutureResult
[11:02:56.769] - Received FutureResult
[11:02:56.770] - Erased future from FutureRegistry
[11:02:56.770] result() for ClusterFuture ...
[11:02:56.770] - result already collected: FutureResult
[11:02:56.770] result() for ClusterFuture ... done
[11:02:56.770] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:56.770] Future #1
[11:02:56.770]  length: 1 (resolved future 1)
[11:02:56.791] receiveMessageFromWorker() for ClusterFuture ...
[11:02:56.791] - Validating connection of MultisessionFuture
[11:02:56.791] - received message: FutureResult
[11:02:56.791] - Received FutureResult
[11:02:56.792] - Erased future from FutureRegistry
[11:02:56.792] result() for ClusterFuture ...
[11:02:56.792] - result already collected: FutureResult
[11:02:56.792] result() for ClusterFuture ... done
[11:02:56.792] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:56.792] Future #2
[11:02:56.792]  length: 0 (resolved future 2)
[11:02:56.792] resolve() on list ... DONE
[11:02:56.792] getGlobalsAndPackages() ...
[11:02:56.792] Searching for globals...
[11:02:56.793] 
[11:02:56.793] Searching for globals ... DONE
[11:02:56.793] - globals: [0] <none>
[11:02:56.793] getGlobalsAndPackages() ... DONE
[11:02:56.793] run() for ‘Future’ ...
[11:02:56.793] - state: ‘created’
[11:02:56.793] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:56.807] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:56.807] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:56.808]   - Field: ‘node’
[11:02:56.808]   - Field: ‘label’
[11:02:56.808]   - Field: ‘local’
[11:02:56.808]   - Field: ‘owner’
[11:02:56.808]   - Field: ‘envir’
[11:02:56.808]   - Field: ‘workers’
[11:02:56.808]   - Field: ‘packages’
[11:02:56.808]   - Field: ‘gc’
[11:02:56.808]   - Field: ‘conditions’
[11:02:56.808]   - Field: ‘persistent’
[11:02:56.809]   - Field: ‘expr’
[11:02:56.809]   - Field: ‘uuid’
[11:02:56.809]   - Field: ‘seed’
[11:02:56.809]   - Field: ‘version’
[11:02:56.809]   - Field: ‘result’
[11:02:56.809]   - Field: ‘asynchronous’
[11:02:56.809]   - Field: ‘calls’
[11:02:56.809]   - Field: ‘globals’
[11:02:56.809]   - Field: ‘stdout’
[11:02:56.809]   - Field: ‘earlySignal’
[11:02:56.809]   - Field: ‘lazy’
[11:02:56.810]   - Field: ‘state’
[11:02:56.810] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:56.810] - Launch lazy future ...
[11:02:56.810] Packages needed by the future expression (n = 0): <none>
[11:02:56.810] Packages needed by future strategies (n = 0): <none>
[11:02:56.810] {
[11:02:56.810]     {
[11:02:56.810]         {
[11:02:56.810]             ...future.startTime <- base::Sys.time()
[11:02:56.810]             {
[11:02:56.810]                 {
[11:02:56.810]                   {
[11:02:56.810]                     {
[11:02:56.810]                       base::local({
[11:02:56.810]                         has_future <- base::requireNamespace("future", 
[11:02:56.810]                           quietly = TRUE)
[11:02:56.810]                         if (has_future) {
[11:02:56.810]                           ns <- base::getNamespace("future")
[11:02:56.810]                           version <- ns[[".package"]][["version"]]
[11:02:56.810]                           if (is.null(version)) 
[11:02:56.810]                             version <- utils::packageVersion("future")
[11:02:56.810]                         }
[11:02:56.810]                         else {
[11:02:56.810]                           version <- NULL
[11:02:56.810]                         }
[11:02:56.810]                         if (!has_future || version < "1.8.0") {
[11:02:56.810]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:56.810]                             "", base::R.version$version.string), 
[11:02:56.810]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:56.810]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:56.810]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:56.810]                               "release", "version")], collapse = " "), 
[11:02:56.810]                             hostname = base::Sys.info()[["nodename"]])
[11:02:56.810]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:56.810]                             info)
[11:02:56.810]                           info <- base::paste(info, collapse = "; ")
[11:02:56.810]                           if (!has_future) {
[11:02:56.810]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:56.810]                               info)
[11:02:56.810]                           }
[11:02:56.810]                           else {
[11:02:56.810]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:56.810]                               info, version)
[11:02:56.810]                           }
[11:02:56.810]                           base::stop(msg)
[11:02:56.810]                         }
[11:02:56.810]                       })
[11:02:56.810]                     }
[11:02:56.810]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:56.810]                     base::options(mc.cores = 1L)
[11:02:56.810]                   }
[11:02:56.810]                   ...future.strategy.old <- future::plan("list")
[11:02:56.810]                   options(future.plan = NULL)
[11:02:56.810]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:56.810]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:56.810]                 }
[11:02:56.810]                 ...future.workdir <- getwd()
[11:02:56.810]             }
[11:02:56.810]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:56.810]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:56.810]         }
[11:02:56.810]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:56.810]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:56.810]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:56.810]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:56.810]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:56.810]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:56.810]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:56.810]             base::names(...future.oldOptions))
[11:02:56.810]     }
[11:02:56.810]     if (FALSE) {
[11:02:56.810]     }
[11:02:56.810]     else {
[11:02:56.810]         if (TRUE) {
[11:02:56.810]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:56.810]                 open = "w")
[11:02:56.810]         }
[11:02:56.810]         else {
[11:02:56.810]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:56.810]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:56.810]         }
[11:02:56.810]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:56.810]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:56.810]             base::sink(type = "output", split = FALSE)
[11:02:56.810]             base::close(...future.stdout)
[11:02:56.810]         }, add = TRUE)
[11:02:56.810]     }
[11:02:56.810]     ...future.frame <- base::sys.nframe()
[11:02:56.810]     ...future.conditions <- base::list()
[11:02:56.810]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:56.810]     if (FALSE) {
[11:02:56.810]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:56.810]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:56.810]     }
[11:02:56.810]     ...future.result <- base::tryCatch({
[11:02:56.810]         base::withCallingHandlers({
[11:02:56.810]             ...future.value <- base::withVisible(base::local({
[11:02:56.810]                 ...future.makeSendCondition <- base::local({
[11:02:56.810]                   sendCondition <- NULL
[11:02:56.810]                   function(frame = 1L) {
[11:02:56.810]                     if (is.function(sendCondition)) 
[11:02:56.810]                       return(sendCondition)
[11:02:56.810]                     ns <- getNamespace("parallel")
[11:02:56.810]                     if (exists("sendData", mode = "function", 
[11:02:56.810]                       envir = ns)) {
[11:02:56.810]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:56.810]                         envir = ns)
[11:02:56.810]                       envir <- sys.frame(frame)
[11:02:56.810]                       master <- NULL
[11:02:56.810]                       while (!identical(envir, .GlobalEnv) && 
[11:02:56.810]                         !identical(envir, emptyenv())) {
[11:02:56.810]                         if (exists("master", mode = "list", envir = envir, 
[11:02:56.810]                           inherits = FALSE)) {
[11:02:56.810]                           master <- get("master", mode = "list", 
[11:02:56.810]                             envir = envir, inherits = FALSE)
[11:02:56.810]                           if (inherits(master, c("SOCKnode", 
[11:02:56.810]                             "SOCK0node"))) {
[11:02:56.810]                             sendCondition <<- function(cond) {
[11:02:56.810]                               data <- list(type = "VALUE", value = cond, 
[11:02:56.810]                                 success = TRUE)
[11:02:56.810]                               parallel_sendData(master, data)
[11:02:56.810]                             }
[11:02:56.810]                             return(sendCondition)
[11:02:56.810]                           }
[11:02:56.810]                         }
[11:02:56.810]                         frame <- frame + 1L
[11:02:56.810]                         envir <- sys.frame(frame)
[11:02:56.810]                       }
[11:02:56.810]                     }
[11:02:56.810]                     sendCondition <<- function(cond) NULL
[11:02:56.810]                   }
[11:02:56.810]                 })
[11:02:56.810]                 withCallingHandlers({
[11:02:56.810]                   1
[11:02:56.810]                 }, immediateCondition = function(cond) {
[11:02:56.810]                   sendCondition <- ...future.makeSendCondition()
[11:02:56.810]                   sendCondition(cond)
[11:02:56.810]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:56.810]                   {
[11:02:56.810]                     inherits <- base::inherits
[11:02:56.810]                     invokeRestart <- base::invokeRestart
[11:02:56.810]                     is.null <- base::is.null
[11:02:56.810]                     muffled <- FALSE
[11:02:56.810]                     if (inherits(cond, "message")) {
[11:02:56.810]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:56.810]                       if (muffled) 
[11:02:56.810]                         invokeRestart("muffleMessage")
[11:02:56.810]                     }
[11:02:56.810]                     else if (inherits(cond, "warning")) {
[11:02:56.810]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:56.810]                       if (muffled) 
[11:02:56.810]                         invokeRestart("muffleWarning")
[11:02:56.810]                     }
[11:02:56.810]                     else if (inherits(cond, "condition")) {
[11:02:56.810]                       if (!is.null(pattern)) {
[11:02:56.810]                         computeRestarts <- base::computeRestarts
[11:02:56.810]                         grepl <- base::grepl
[11:02:56.810]                         restarts <- computeRestarts(cond)
[11:02:56.810]                         for (restart in restarts) {
[11:02:56.810]                           name <- restart$name
[11:02:56.810]                           if (is.null(name)) 
[11:02:56.810]                             next
[11:02:56.810]                           if (!grepl(pattern, name)) 
[11:02:56.810]                             next
[11:02:56.810]                           invokeRestart(restart)
[11:02:56.810]                           muffled <- TRUE
[11:02:56.810]                           break
[11:02:56.810]                         }
[11:02:56.810]                       }
[11:02:56.810]                     }
[11:02:56.810]                     invisible(muffled)
[11:02:56.810]                   }
[11:02:56.810]                   muffleCondition(cond)
[11:02:56.810]                 })
[11:02:56.810]             }))
[11:02:56.810]             future::FutureResult(value = ...future.value$value, 
[11:02:56.810]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:56.810]                   ...future.rng), globalenv = if (FALSE) 
[11:02:56.810]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:56.810]                     ...future.globalenv.names))
[11:02:56.810]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:56.810]         }, condition = base::local({
[11:02:56.810]             c <- base::c
[11:02:56.810]             inherits <- base::inherits
[11:02:56.810]             invokeRestart <- base::invokeRestart
[11:02:56.810]             length <- base::length
[11:02:56.810]             list <- base::list
[11:02:56.810]             seq.int <- base::seq.int
[11:02:56.810]             signalCondition <- base::signalCondition
[11:02:56.810]             sys.calls <- base::sys.calls
[11:02:56.810]             `[[` <- base::`[[`
[11:02:56.810]             `+` <- base::`+`
[11:02:56.810]             `<<-` <- base::`<<-`
[11:02:56.810]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:56.810]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:56.810]                   3L)]
[11:02:56.810]             }
[11:02:56.810]             function(cond) {
[11:02:56.810]                 is_error <- inherits(cond, "error")
[11:02:56.810]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:56.810]                   NULL)
[11:02:56.810]                 if (is_error) {
[11:02:56.810]                   sessionInformation <- function() {
[11:02:56.810]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:56.810]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:56.810]                       search = base::search(), system = base::Sys.info())
[11:02:56.810]                   }
[11:02:56.810]                   ...future.conditions[[length(...future.conditions) + 
[11:02:56.810]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:56.810]                     cond$call), session = sessionInformation(), 
[11:02:56.810]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:56.810]                   signalCondition(cond)
[11:02:56.810]                 }
[11:02:56.810]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:56.810]                 "immediateCondition"))) {
[11:02:56.810]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:56.810]                   ...future.conditions[[length(...future.conditions) + 
[11:02:56.810]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:56.810]                   if (TRUE && !signal) {
[11:02:56.810]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:56.810]                     {
[11:02:56.810]                       inherits <- base::inherits
[11:02:56.810]                       invokeRestart <- base::invokeRestart
[11:02:56.810]                       is.null <- base::is.null
[11:02:56.810]                       muffled <- FALSE
[11:02:56.810]                       if (inherits(cond, "message")) {
[11:02:56.810]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:56.810]                         if (muffled) 
[11:02:56.810]                           invokeRestart("muffleMessage")
[11:02:56.810]                       }
[11:02:56.810]                       else if (inherits(cond, "warning")) {
[11:02:56.810]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:56.810]                         if (muffled) 
[11:02:56.810]                           invokeRestart("muffleWarning")
[11:02:56.810]                       }
[11:02:56.810]                       else if (inherits(cond, "condition")) {
[11:02:56.810]                         if (!is.null(pattern)) {
[11:02:56.810]                           computeRestarts <- base::computeRestarts
[11:02:56.810]                           grepl <- base::grepl
[11:02:56.810]                           restarts <- computeRestarts(cond)
[11:02:56.810]                           for (restart in restarts) {
[11:02:56.810]                             name <- restart$name
[11:02:56.810]                             if (is.null(name)) 
[11:02:56.810]                               next
[11:02:56.810]                             if (!grepl(pattern, name)) 
[11:02:56.810]                               next
[11:02:56.810]                             invokeRestart(restart)
[11:02:56.810]                             muffled <- TRUE
[11:02:56.810]                             break
[11:02:56.810]                           }
[11:02:56.810]                         }
[11:02:56.810]                       }
[11:02:56.810]                       invisible(muffled)
[11:02:56.810]                     }
[11:02:56.810]                     muffleCondition(cond, pattern = "^muffle")
[11:02:56.810]                   }
[11:02:56.810]                 }
[11:02:56.810]                 else {
[11:02:56.810]                   if (TRUE) {
[11:02:56.810]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:56.810]                     {
[11:02:56.810]                       inherits <- base::inherits
[11:02:56.810]                       invokeRestart <- base::invokeRestart
[11:02:56.810]                       is.null <- base::is.null
[11:02:56.810]                       muffled <- FALSE
[11:02:56.810]                       if (inherits(cond, "message")) {
[11:02:56.810]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:56.810]                         if (muffled) 
[11:02:56.810]                           invokeRestart("muffleMessage")
[11:02:56.810]                       }
[11:02:56.810]                       else if (inherits(cond, "warning")) {
[11:02:56.810]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:56.810]                         if (muffled) 
[11:02:56.810]                           invokeRestart("muffleWarning")
[11:02:56.810]                       }
[11:02:56.810]                       else if (inherits(cond, "condition")) {
[11:02:56.810]                         if (!is.null(pattern)) {
[11:02:56.810]                           computeRestarts <- base::computeRestarts
[11:02:56.810]                           grepl <- base::grepl
[11:02:56.810]                           restarts <- computeRestarts(cond)
[11:02:56.810]                           for (restart in restarts) {
[11:02:56.810]                             name <- restart$name
[11:02:56.810]                             if (is.null(name)) 
[11:02:56.810]                               next
[11:02:56.810]                             if (!grepl(pattern, name)) 
[11:02:56.810]                               next
[11:02:56.810]                             invokeRestart(restart)
[11:02:56.810]                             muffled <- TRUE
[11:02:56.810]                             break
[11:02:56.810]                           }
[11:02:56.810]                         }
[11:02:56.810]                       }
[11:02:56.810]                       invisible(muffled)
[11:02:56.810]                     }
[11:02:56.810]                     muffleCondition(cond, pattern = "^muffle")
[11:02:56.810]                   }
[11:02:56.810]                 }
[11:02:56.810]             }
[11:02:56.810]         }))
[11:02:56.810]     }, error = function(ex) {
[11:02:56.810]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:56.810]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:56.810]                 ...future.rng), started = ...future.startTime, 
[11:02:56.810]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:56.810]             version = "1.8"), class = "FutureResult")
[11:02:56.810]     }, finally = {
[11:02:56.810]         if (!identical(...future.workdir, getwd())) 
[11:02:56.810]             setwd(...future.workdir)
[11:02:56.810]         {
[11:02:56.810]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:56.810]                 ...future.oldOptions$nwarnings <- NULL
[11:02:56.810]             }
[11:02:56.810]             base::options(...future.oldOptions)
[11:02:56.810]             if (.Platform$OS.type == "windows") {
[11:02:56.810]                 old_names <- names(...future.oldEnvVars)
[11:02:56.810]                 envs <- base::Sys.getenv()
[11:02:56.810]                 names <- names(envs)
[11:02:56.810]                 common <- intersect(names, old_names)
[11:02:56.810]                 added <- setdiff(names, old_names)
[11:02:56.810]                 removed <- setdiff(old_names, names)
[11:02:56.810]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:56.810]                   envs[common]]
[11:02:56.810]                 NAMES <- toupper(changed)
[11:02:56.810]                 args <- list()
[11:02:56.810]                 for (kk in seq_along(NAMES)) {
[11:02:56.810]                   name <- changed[[kk]]
[11:02:56.810]                   NAME <- NAMES[[kk]]
[11:02:56.810]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:56.810]                     next
[11:02:56.810]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:56.810]                 }
[11:02:56.810]                 NAMES <- toupper(added)
[11:02:56.810]                 for (kk in seq_along(NAMES)) {
[11:02:56.810]                   name <- added[[kk]]
[11:02:56.810]                   NAME <- NAMES[[kk]]
[11:02:56.810]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:56.810]                     next
[11:02:56.810]                   args[[name]] <- ""
[11:02:56.810]                 }
[11:02:56.810]                 NAMES <- toupper(removed)
[11:02:56.810]                 for (kk in seq_along(NAMES)) {
[11:02:56.810]                   name <- removed[[kk]]
[11:02:56.810]                   NAME <- NAMES[[kk]]
[11:02:56.810]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:56.810]                     next
[11:02:56.810]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:56.810]                 }
[11:02:56.810]                 if (length(args) > 0) 
[11:02:56.810]                   base::do.call(base::Sys.setenv, args = args)
[11:02:56.810]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:56.810]             }
[11:02:56.810]             else {
[11:02:56.810]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:56.810]             }
[11:02:56.810]             {
[11:02:56.810]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:56.810]                   0L) {
[11:02:56.810]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:56.810]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:56.810]                   base::options(opts)
[11:02:56.810]                 }
[11:02:56.810]                 {
[11:02:56.810]                   {
[11:02:56.810]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:56.810]                     NULL
[11:02:56.810]                   }
[11:02:56.810]                   options(future.plan = NULL)
[11:02:56.810]                   if (is.na(NA_character_)) 
[11:02:56.810]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:56.810]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:56.810]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:56.810]                     .init = FALSE)
[11:02:56.810]                 }
[11:02:56.810]             }
[11:02:56.810]         }
[11:02:56.810]     })
[11:02:56.810]     if (TRUE) {
[11:02:56.810]         base::sink(type = "output", split = FALSE)
[11:02:56.810]         if (TRUE) {
[11:02:56.810]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:56.810]         }
[11:02:56.810]         else {
[11:02:56.810]             ...future.result["stdout"] <- base::list(NULL)
[11:02:56.810]         }
[11:02:56.810]         base::close(...future.stdout)
[11:02:56.810]         ...future.stdout <- NULL
[11:02:56.810]     }
[11:02:56.810]     ...future.result$conditions <- ...future.conditions
[11:02:56.810]     ...future.result$finished <- base::Sys.time()
[11:02:56.810]     ...future.result
[11:02:56.810] }
[11:02:56.813] MultisessionFuture started
[11:02:56.813] - Launch lazy future ... done
[11:02:56.814] run() for ‘MultisessionFuture’ ... done
[11:02:56.814] getGlobalsAndPackages() ...
[11:02:56.814] Searching for globals...
[11:02:56.815] - globals found: [2] ‘{’, ‘Sys.sleep’
[11:02:56.815] Searching for globals ... DONE
[11:02:56.815] Resolving globals: FALSE
[11:02:56.815] 
[11:02:56.815] 
[11:02:56.815] getGlobalsAndPackages() ... DONE
[11:02:56.816] run() for ‘Future’ ...
[11:02:56.816] - state: ‘created’
[11:02:56.816] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:56.829] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:56.829] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:56.830]   - Field: ‘node’
[11:02:56.830]   - Field: ‘label’
[11:02:56.830]   - Field: ‘local’
[11:02:56.830]   - Field: ‘owner’
[11:02:56.830]   - Field: ‘envir’
[11:02:56.830]   - Field: ‘workers’
[11:02:56.830]   - Field: ‘packages’
[11:02:56.830]   - Field: ‘gc’
[11:02:56.830]   - Field: ‘conditions’
[11:02:56.830]   - Field: ‘persistent’
[11:02:56.830]   - Field: ‘expr’
[11:02:56.831]   - Field: ‘uuid’
[11:02:56.831]   - Field: ‘seed’
[11:02:56.831]   - Field: ‘version’
[11:02:56.831]   - Field: ‘result’
[11:02:56.831]   - Field: ‘asynchronous’
[11:02:56.831]   - Field: ‘calls’
[11:02:56.831]   - Field: ‘globals’
[11:02:56.831]   - Field: ‘stdout’
[11:02:56.831]   - Field: ‘earlySignal’
[11:02:56.831]   - Field: ‘lazy’
[11:02:56.831]   - Field: ‘state’
[11:02:56.831] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:56.832] - Launch lazy future ...
[11:02:56.832] Packages needed by the future expression (n = 0): <none>
[11:02:56.832] Packages needed by future strategies (n = 0): <none>
[11:02:56.832] {
[11:02:56.832]     {
[11:02:56.832]         {
[11:02:56.832]             ...future.startTime <- base::Sys.time()
[11:02:56.832]             {
[11:02:56.832]                 {
[11:02:56.832]                   {
[11:02:56.832]                     {
[11:02:56.832]                       base::local({
[11:02:56.832]                         has_future <- base::requireNamespace("future", 
[11:02:56.832]                           quietly = TRUE)
[11:02:56.832]                         if (has_future) {
[11:02:56.832]                           ns <- base::getNamespace("future")
[11:02:56.832]                           version <- ns[[".package"]][["version"]]
[11:02:56.832]                           if (is.null(version)) 
[11:02:56.832]                             version <- utils::packageVersion("future")
[11:02:56.832]                         }
[11:02:56.832]                         else {
[11:02:56.832]                           version <- NULL
[11:02:56.832]                         }
[11:02:56.832]                         if (!has_future || version < "1.8.0") {
[11:02:56.832]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:56.832]                             "", base::R.version$version.string), 
[11:02:56.832]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:56.832]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:56.832]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:56.832]                               "release", "version")], collapse = " "), 
[11:02:56.832]                             hostname = base::Sys.info()[["nodename"]])
[11:02:56.832]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:56.832]                             info)
[11:02:56.832]                           info <- base::paste(info, collapse = "; ")
[11:02:56.832]                           if (!has_future) {
[11:02:56.832]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:56.832]                               info)
[11:02:56.832]                           }
[11:02:56.832]                           else {
[11:02:56.832]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:56.832]                               info, version)
[11:02:56.832]                           }
[11:02:56.832]                           base::stop(msg)
[11:02:56.832]                         }
[11:02:56.832]                       })
[11:02:56.832]                     }
[11:02:56.832]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:56.832]                     base::options(mc.cores = 1L)
[11:02:56.832]                   }
[11:02:56.832]                   ...future.strategy.old <- future::plan("list")
[11:02:56.832]                   options(future.plan = NULL)
[11:02:56.832]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:56.832]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:56.832]                 }
[11:02:56.832]                 ...future.workdir <- getwd()
[11:02:56.832]             }
[11:02:56.832]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:56.832]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:56.832]         }
[11:02:56.832]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:56.832]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:56.832]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:56.832]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:56.832]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:56.832]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:56.832]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:56.832]             base::names(...future.oldOptions))
[11:02:56.832]     }
[11:02:56.832]     if (FALSE) {
[11:02:56.832]     }
[11:02:56.832]     else {
[11:02:56.832]         if (TRUE) {
[11:02:56.832]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:56.832]                 open = "w")
[11:02:56.832]         }
[11:02:56.832]         else {
[11:02:56.832]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:56.832]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:56.832]         }
[11:02:56.832]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:56.832]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:56.832]             base::sink(type = "output", split = FALSE)
[11:02:56.832]             base::close(...future.stdout)
[11:02:56.832]         }, add = TRUE)
[11:02:56.832]     }
[11:02:56.832]     ...future.frame <- base::sys.nframe()
[11:02:56.832]     ...future.conditions <- base::list()
[11:02:56.832]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:56.832]     if (FALSE) {
[11:02:56.832]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:56.832]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:56.832]     }
[11:02:56.832]     ...future.result <- base::tryCatch({
[11:02:56.832]         base::withCallingHandlers({
[11:02:56.832]             ...future.value <- base::withVisible(base::local({
[11:02:56.832]                 ...future.makeSendCondition <- base::local({
[11:02:56.832]                   sendCondition <- NULL
[11:02:56.832]                   function(frame = 1L) {
[11:02:56.832]                     if (is.function(sendCondition)) 
[11:02:56.832]                       return(sendCondition)
[11:02:56.832]                     ns <- getNamespace("parallel")
[11:02:56.832]                     if (exists("sendData", mode = "function", 
[11:02:56.832]                       envir = ns)) {
[11:02:56.832]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:56.832]                         envir = ns)
[11:02:56.832]                       envir <- sys.frame(frame)
[11:02:56.832]                       master <- NULL
[11:02:56.832]                       while (!identical(envir, .GlobalEnv) && 
[11:02:56.832]                         !identical(envir, emptyenv())) {
[11:02:56.832]                         if (exists("master", mode = "list", envir = envir, 
[11:02:56.832]                           inherits = FALSE)) {
[11:02:56.832]                           master <- get("master", mode = "list", 
[11:02:56.832]                             envir = envir, inherits = FALSE)
[11:02:56.832]                           if (inherits(master, c("SOCKnode", 
[11:02:56.832]                             "SOCK0node"))) {
[11:02:56.832]                             sendCondition <<- function(cond) {
[11:02:56.832]                               data <- list(type = "VALUE", value = cond, 
[11:02:56.832]                                 success = TRUE)
[11:02:56.832]                               parallel_sendData(master, data)
[11:02:56.832]                             }
[11:02:56.832]                             return(sendCondition)
[11:02:56.832]                           }
[11:02:56.832]                         }
[11:02:56.832]                         frame <- frame + 1L
[11:02:56.832]                         envir <- sys.frame(frame)
[11:02:56.832]                       }
[11:02:56.832]                     }
[11:02:56.832]                     sendCondition <<- function(cond) NULL
[11:02:56.832]                   }
[11:02:56.832]                 })
[11:02:56.832]                 withCallingHandlers({
[11:02:56.832]                   {
[11:02:56.832]                     Sys.sleep(0.5)
[11:02:56.832]                     2
[11:02:56.832]                   }
[11:02:56.832]                 }, immediateCondition = function(cond) {
[11:02:56.832]                   sendCondition <- ...future.makeSendCondition()
[11:02:56.832]                   sendCondition(cond)
[11:02:56.832]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:56.832]                   {
[11:02:56.832]                     inherits <- base::inherits
[11:02:56.832]                     invokeRestart <- base::invokeRestart
[11:02:56.832]                     is.null <- base::is.null
[11:02:56.832]                     muffled <- FALSE
[11:02:56.832]                     if (inherits(cond, "message")) {
[11:02:56.832]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:56.832]                       if (muffled) 
[11:02:56.832]                         invokeRestart("muffleMessage")
[11:02:56.832]                     }
[11:02:56.832]                     else if (inherits(cond, "warning")) {
[11:02:56.832]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:56.832]                       if (muffled) 
[11:02:56.832]                         invokeRestart("muffleWarning")
[11:02:56.832]                     }
[11:02:56.832]                     else if (inherits(cond, "condition")) {
[11:02:56.832]                       if (!is.null(pattern)) {
[11:02:56.832]                         computeRestarts <- base::computeRestarts
[11:02:56.832]                         grepl <- base::grepl
[11:02:56.832]                         restarts <- computeRestarts(cond)
[11:02:56.832]                         for (restart in restarts) {
[11:02:56.832]                           name <- restart$name
[11:02:56.832]                           if (is.null(name)) 
[11:02:56.832]                             next
[11:02:56.832]                           if (!grepl(pattern, name)) 
[11:02:56.832]                             next
[11:02:56.832]                           invokeRestart(restart)
[11:02:56.832]                           muffled <- TRUE
[11:02:56.832]                           break
[11:02:56.832]                         }
[11:02:56.832]                       }
[11:02:56.832]                     }
[11:02:56.832]                     invisible(muffled)
[11:02:56.832]                   }
[11:02:56.832]                   muffleCondition(cond)
[11:02:56.832]                 })
[11:02:56.832]             }))
[11:02:56.832]             future::FutureResult(value = ...future.value$value, 
[11:02:56.832]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:56.832]                   ...future.rng), globalenv = if (FALSE) 
[11:02:56.832]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:56.832]                     ...future.globalenv.names))
[11:02:56.832]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:56.832]         }, condition = base::local({
[11:02:56.832]             c <- base::c
[11:02:56.832]             inherits <- base::inherits
[11:02:56.832]             invokeRestart <- base::invokeRestart
[11:02:56.832]             length <- base::length
[11:02:56.832]             list <- base::list
[11:02:56.832]             seq.int <- base::seq.int
[11:02:56.832]             signalCondition <- base::signalCondition
[11:02:56.832]             sys.calls <- base::sys.calls
[11:02:56.832]             `[[` <- base::`[[`
[11:02:56.832]             `+` <- base::`+`
[11:02:56.832]             `<<-` <- base::`<<-`
[11:02:56.832]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:56.832]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:56.832]                   3L)]
[11:02:56.832]             }
[11:02:56.832]             function(cond) {
[11:02:56.832]                 is_error <- inherits(cond, "error")
[11:02:56.832]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:56.832]                   NULL)
[11:02:56.832]                 if (is_error) {
[11:02:56.832]                   sessionInformation <- function() {
[11:02:56.832]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:56.832]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:56.832]                       search = base::search(), system = base::Sys.info())
[11:02:56.832]                   }
[11:02:56.832]                   ...future.conditions[[length(...future.conditions) + 
[11:02:56.832]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:56.832]                     cond$call), session = sessionInformation(), 
[11:02:56.832]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:56.832]                   signalCondition(cond)
[11:02:56.832]                 }
[11:02:56.832]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:56.832]                 "immediateCondition"))) {
[11:02:56.832]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:56.832]                   ...future.conditions[[length(...future.conditions) + 
[11:02:56.832]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:56.832]                   if (TRUE && !signal) {
[11:02:56.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:56.832]                     {
[11:02:56.832]                       inherits <- base::inherits
[11:02:56.832]                       invokeRestart <- base::invokeRestart
[11:02:56.832]                       is.null <- base::is.null
[11:02:56.832]                       muffled <- FALSE
[11:02:56.832]                       if (inherits(cond, "message")) {
[11:02:56.832]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:56.832]                         if (muffled) 
[11:02:56.832]                           invokeRestart("muffleMessage")
[11:02:56.832]                       }
[11:02:56.832]                       else if (inherits(cond, "warning")) {
[11:02:56.832]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:56.832]                         if (muffled) 
[11:02:56.832]                           invokeRestart("muffleWarning")
[11:02:56.832]                       }
[11:02:56.832]                       else if (inherits(cond, "condition")) {
[11:02:56.832]                         if (!is.null(pattern)) {
[11:02:56.832]                           computeRestarts <- base::computeRestarts
[11:02:56.832]                           grepl <- base::grepl
[11:02:56.832]                           restarts <- computeRestarts(cond)
[11:02:56.832]                           for (restart in restarts) {
[11:02:56.832]                             name <- restart$name
[11:02:56.832]                             if (is.null(name)) 
[11:02:56.832]                               next
[11:02:56.832]                             if (!grepl(pattern, name)) 
[11:02:56.832]                               next
[11:02:56.832]                             invokeRestart(restart)
[11:02:56.832]                             muffled <- TRUE
[11:02:56.832]                             break
[11:02:56.832]                           }
[11:02:56.832]                         }
[11:02:56.832]                       }
[11:02:56.832]                       invisible(muffled)
[11:02:56.832]                     }
[11:02:56.832]                     muffleCondition(cond, pattern = "^muffle")
[11:02:56.832]                   }
[11:02:56.832]                 }
[11:02:56.832]                 else {
[11:02:56.832]                   if (TRUE) {
[11:02:56.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:56.832]                     {
[11:02:56.832]                       inherits <- base::inherits
[11:02:56.832]                       invokeRestart <- base::invokeRestart
[11:02:56.832]                       is.null <- base::is.null
[11:02:56.832]                       muffled <- FALSE
[11:02:56.832]                       if (inherits(cond, "message")) {
[11:02:56.832]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:56.832]                         if (muffled) 
[11:02:56.832]                           invokeRestart("muffleMessage")
[11:02:56.832]                       }
[11:02:56.832]                       else if (inherits(cond, "warning")) {
[11:02:56.832]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:56.832]                         if (muffled) 
[11:02:56.832]                           invokeRestart("muffleWarning")
[11:02:56.832]                       }
[11:02:56.832]                       else if (inherits(cond, "condition")) {
[11:02:56.832]                         if (!is.null(pattern)) {
[11:02:56.832]                           computeRestarts <- base::computeRestarts
[11:02:56.832]                           grepl <- base::grepl
[11:02:56.832]                           restarts <- computeRestarts(cond)
[11:02:56.832]                           for (restart in restarts) {
[11:02:56.832]                             name <- restart$name
[11:02:56.832]                             if (is.null(name)) 
[11:02:56.832]                               next
[11:02:56.832]                             if (!grepl(pattern, name)) 
[11:02:56.832]                               next
[11:02:56.832]                             invokeRestart(restart)
[11:02:56.832]                             muffled <- TRUE
[11:02:56.832]                             break
[11:02:56.832]                           }
[11:02:56.832]                         }
[11:02:56.832]                       }
[11:02:56.832]                       invisible(muffled)
[11:02:56.832]                     }
[11:02:56.832]                     muffleCondition(cond, pattern = "^muffle")
[11:02:56.832]                   }
[11:02:56.832]                 }
[11:02:56.832]             }
[11:02:56.832]         }))
[11:02:56.832]     }, error = function(ex) {
[11:02:56.832]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:56.832]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:56.832]                 ...future.rng), started = ...future.startTime, 
[11:02:56.832]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:56.832]             version = "1.8"), class = "FutureResult")
[11:02:56.832]     }, finally = {
[11:02:56.832]         if (!identical(...future.workdir, getwd())) 
[11:02:56.832]             setwd(...future.workdir)
[11:02:56.832]         {
[11:02:56.832]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:56.832]                 ...future.oldOptions$nwarnings <- NULL
[11:02:56.832]             }
[11:02:56.832]             base::options(...future.oldOptions)
[11:02:56.832]             if (.Platform$OS.type == "windows") {
[11:02:56.832]                 old_names <- names(...future.oldEnvVars)
[11:02:56.832]                 envs <- base::Sys.getenv()
[11:02:56.832]                 names <- names(envs)
[11:02:56.832]                 common <- intersect(names, old_names)
[11:02:56.832]                 added <- setdiff(names, old_names)
[11:02:56.832]                 removed <- setdiff(old_names, names)
[11:02:56.832]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:56.832]                   envs[common]]
[11:02:56.832]                 NAMES <- toupper(changed)
[11:02:56.832]                 args <- list()
[11:02:56.832]                 for (kk in seq_along(NAMES)) {
[11:02:56.832]                   name <- changed[[kk]]
[11:02:56.832]                   NAME <- NAMES[[kk]]
[11:02:56.832]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:56.832]                     next
[11:02:56.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:56.832]                 }
[11:02:56.832]                 NAMES <- toupper(added)
[11:02:56.832]                 for (kk in seq_along(NAMES)) {
[11:02:56.832]                   name <- added[[kk]]
[11:02:56.832]                   NAME <- NAMES[[kk]]
[11:02:56.832]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:56.832]                     next
[11:02:56.832]                   args[[name]] <- ""
[11:02:56.832]                 }
[11:02:56.832]                 NAMES <- toupper(removed)
[11:02:56.832]                 for (kk in seq_along(NAMES)) {
[11:02:56.832]                   name <- removed[[kk]]
[11:02:56.832]                   NAME <- NAMES[[kk]]
[11:02:56.832]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:56.832]                     next
[11:02:56.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:56.832]                 }
[11:02:56.832]                 if (length(args) > 0) 
[11:02:56.832]                   base::do.call(base::Sys.setenv, args = args)
[11:02:56.832]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:56.832]             }
[11:02:56.832]             else {
[11:02:56.832]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:56.832]             }
[11:02:56.832]             {
[11:02:56.832]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:56.832]                   0L) {
[11:02:56.832]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:56.832]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:56.832]                   base::options(opts)
[11:02:56.832]                 }
[11:02:56.832]                 {
[11:02:56.832]                   {
[11:02:56.832]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:56.832]                     NULL
[11:02:56.832]                   }
[11:02:56.832]                   options(future.plan = NULL)
[11:02:56.832]                   if (is.na(NA_character_)) 
[11:02:56.832]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:56.832]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:56.832]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:56.832]                     .init = FALSE)
[11:02:56.832]                 }
[11:02:56.832]             }
[11:02:56.832]         }
[11:02:56.832]     })
[11:02:56.832]     if (TRUE) {
[11:02:56.832]         base::sink(type = "output", split = FALSE)
[11:02:56.832]         if (TRUE) {
[11:02:56.832]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:56.832]         }
[11:02:56.832]         else {
[11:02:56.832]             ...future.result["stdout"] <- base::list(NULL)
[11:02:56.832]         }
[11:02:56.832]         base::close(...future.stdout)
[11:02:56.832]         ...future.stdout <- NULL
[11:02:56.832]     }
[11:02:56.832]     ...future.result$conditions <- ...future.conditions
[11:02:56.832]     ...future.result$finished <- base::Sys.time()
[11:02:56.832]     ...future.result
[11:02:56.832] }
[11:02:56.835] MultisessionFuture started
[11:02:56.835] - Launch lazy future ... done
[11:02:56.835] run() for ‘MultisessionFuture’ ... done
[11:02:56.836] resolve() on list ...
[11:02:56.836]  recursive: 0
[11:02:56.836]  length: 1
[11:02:56.836] 
[11:02:56.857] receiveMessageFromWorker() for ClusterFuture ...
[11:02:56.857] - Validating connection of MultisessionFuture
[11:02:56.857] - received message: FutureResult
[11:02:56.857] - Received FutureResult
[11:02:56.858] - Erased future from FutureRegistry
[11:02:56.858] result() for ClusterFuture ...
[11:02:56.858] - result already collected: FutureResult
[11:02:56.858] result() for ClusterFuture ... done
[11:02:56.858] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:56.858] Future #1
[11:02:56.858]  length: 0 (resolved future 1)
[11:02:56.858] resolve() on list ... DONE
[11:02:56.858] resolve() on list ...
[11:02:56.859]  recursive: 0
[11:02:56.859]  length: 1
[11:02:56.859] 
[11:02:57.378] receiveMessageFromWorker() for ClusterFuture ...
[11:02:57.378] - Validating connection of MultisessionFuture
[11:02:57.379] - received message: FutureResult
[11:02:57.379] - Received FutureResult
[11:02:57.379] - Erased future from FutureRegistry
[11:02:57.379] result() for ClusterFuture ...
[11:02:57.379] - result already collected: FutureResult
[11:02:57.379] result() for ClusterFuture ... done
[11:02:57.379] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:57.379] Future #1
[11:02:57.379]  length: 0 (resolved future 1)
[11:02:57.379] resolve() on list ... DONE
[11:02:57.380] resolve() on list ...
[11:02:57.380]  recursive: 0
[11:02:57.380]  length: 1
[11:02:57.380] 
[11:02:57.380]  length: 0 (resolved future 1)
[11:02:57.380] resolve() on list ... DONE
[11:02:57.380] resolve() on list ...
[11:02:57.380]  recursive: 0
[11:02:57.381]  length: 4
[11:02:57.381] 
[11:02:57.381] Future #1
[11:02:57.381]  length: 3 (resolved future 1)
[11:02:57.381] Future #2
[11:02:57.381]  length: 2 (resolved future 2)
[11:02:57.381]  length: 1 (resolved future 3)
[11:02:57.381]  length: 0 (resolved future 4)
[11:02:57.381] resolve() on list ... DONE
[11:02:57.381] resolve() on list ...
[11:02:57.382]  recursive: 0
[11:02:57.382]  length: 4
[11:02:57.382] 
[11:02:57.382] Future #1
[11:02:57.382]  length: 3 (resolved future 1)
[11:02:57.382] Future #2
[11:02:57.382]  length: 2 (resolved future 2)
[11:02:57.382]  length: 1 (resolved future 3)
[11:02:57.382]  length: 0 (resolved future 4)
[11:02:57.382] resolve() on list ... DONE
[11:02:57.383] resolve() on list ...
[11:02:57.383]  recursive: 0
[11:02:57.383]  length: 1
[11:02:57.383] 
[11:02:57.383]  length: 0 (resolved future 1)
[11:02:57.383] resolve() on list ... DONE
[11:02:57.383] getGlobalsAndPackages() ...
[11:02:57.383] Searching for globals...
[11:02:57.384] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[11:02:57.384] Searching for globals ... DONE
[11:02:57.384] Resolving globals: FALSE
[11:02:57.385] The total size of the 1 globals is 35 bytes (35 bytes)
[11:02:57.385] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[11:02:57.385] - globals: [1] ‘kk’
[11:02:57.385] 
[11:02:57.385] getGlobalsAndPackages() ... DONE
[11:02:57.386] run() for ‘Future’ ...
[11:02:57.386] - state: ‘created’
[11:02:57.386] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:57.400] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:57.400] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:57.400]   - Field: ‘node’
[11:02:57.400]   - Field: ‘label’
[11:02:57.400]   - Field: ‘local’
[11:02:57.400]   - Field: ‘owner’
[11:02:57.400]   - Field: ‘envir’
[11:02:57.400]   - Field: ‘workers’
[11:02:57.400]   - Field: ‘packages’
[11:02:57.401]   - Field: ‘gc’
[11:02:57.401]   - Field: ‘conditions’
[11:02:57.401]   - Field: ‘persistent’
[11:02:57.401]   - Field: ‘expr’
[11:02:57.401]   - Field: ‘uuid’
[11:02:57.401]   - Field: ‘seed’
[11:02:57.401]   - Field: ‘version’
[11:02:57.401]   - Field: ‘result’
[11:02:57.401]   - Field: ‘asynchronous’
[11:02:57.401]   - Field: ‘calls’
[11:02:57.401]   - Field: ‘globals’
[11:02:57.401]   - Field: ‘stdout’
[11:02:57.402]   - Field: ‘earlySignal’
[11:02:57.402]   - Field: ‘lazy’
[11:02:57.402]   - Field: ‘state’
[11:02:57.402] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:57.402] - Launch lazy future ...
[11:02:57.402] Packages needed by the future expression (n = 0): <none>
[11:02:57.402] Packages needed by future strategies (n = 0): <none>
[11:02:57.403] {
[11:02:57.403]     {
[11:02:57.403]         {
[11:02:57.403]             ...future.startTime <- base::Sys.time()
[11:02:57.403]             {
[11:02:57.403]                 {
[11:02:57.403]                   {
[11:02:57.403]                     {
[11:02:57.403]                       base::local({
[11:02:57.403]                         has_future <- base::requireNamespace("future", 
[11:02:57.403]                           quietly = TRUE)
[11:02:57.403]                         if (has_future) {
[11:02:57.403]                           ns <- base::getNamespace("future")
[11:02:57.403]                           version <- ns[[".package"]][["version"]]
[11:02:57.403]                           if (is.null(version)) 
[11:02:57.403]                             version <- utils::packageVersion("future")
[11:02:57.403]                         }
[11:02:57.403]                         else {
[11:02:57.403]                           version <- NULL
[11:02:57.403]                         }
[11:02:57.403]                         if (!has_future || version < "1.8.0") {
[11:02:57.403]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:57.403]                             "", base::R.version$version.string), 
[11:02:57.403]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:57.403]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:57.403]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:57.403]                               "release", "version")], collapse = " "), 
[11:02:57.403]                             hostname = base::Sys.info()[["nodename"]])
[11:02:57.403]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:57.403]                             info)
[11:02:57.403]                           info <- base::paste(info, collapse = "; ")
[11:02:57.403]                           if (!has_future) {
[11:02:57.403]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:57.403]                               info)
[11:02:57.403]                           }
[11:02:57.403]                           else {
[11:02:57.403]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:57.403]                               info, version)
[11:02:57.403]                           }
[11:02:57.403]                           base::stop(msg)
[11:02:57.403]                         }
[11:02:57.403]                       })
[11:02:57.403]                     }
[11:02:57.403]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:57.403]                     base::options(mc.cores = 1L)
[11:02:57.403]                   }
[11:02:57.403]                   ...future.strategy.old <- future::plan("list")
[11:02:57.403]                   options(future.plan = NULL)
[11:02:57.403]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:57.403]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:57.403]                 }
[11:02:57.403]                 ...future.workdir <- getwd()
[11:02:57.403]             }
[11:02:57.403]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:57.403]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:57.403]         }
[11:02:57.403]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:57.403]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:57.403]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:57.403]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:57.403]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:57.403]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:57.403]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:57.403]             base::names(...future.oldOptions))
[11:02:57.403]     }
[11:02:57.403]     if (FALSE) {
[11:02:57.403]     }
[11:02:57.403]     else {
[11:02:57.403]         if (TRUE) {
[11:02:57.403]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:57.403]                 open = "w")
[11:02:57.403]         }
[11:02:57.403]         else {
[11:02:57.403]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:57.403]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:57.403]         }
[11:02:57.403]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:57.403]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:57.403]             base::sink(type = "output", split = FALSE)
[11:02:57.403]             base::close(...future.stdout)
[11:02:57.403]         }, add = TRUE)
[11:02:57.403]     }
[11:02:57.403]     ...future.frame <- base::sys.nframe()
[11:02:57.403]     ...future.conditions <- base::list()
[11:02:57.403]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:57.403]     if (FALSE) {
[11:02:57.403]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:57.403]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:57.403]     }
[11:02:57.403]     ...future.result <- base::tryCatch({
[11:02:57.403]         base::withCallingHandlers({
[11:02:57.403]             ...future.value <- base::withVisible(base::local({
[11:02:57.403]                 ...future.makeSendCondition <- base::local({
[11:02:57.403]                   sendCondition <- NULL
[11:02:57.403]                   function(frame = 1L) {
[11:02:57.403]                     if (is.function(sendCondition)) 
[11:02:57.403]                       return(sendCondition)
[11:02:57.403]                     ns <- getNamespace("parallel")
[11:02:57.403]                     if (exists("sendData", mode = "function", 
[11:02:57.403]                       envir = ns)) {
[11:02:57.403]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:57.403]                         envir = ns)
[11:02:57.403]                       envir <- sys.frame(frame)
[11:02:57.403]                       master <- NULL
[11:02:57.403]                       while (!identical(envir, .GlobalEnv) && 
[11:02:57.403]                         !identical(envir, emptyenv())) {
[11:02:57.403]                         if (exists("master", mode = "list", envir = envir, 
[11:02:57.403]                           inherits = FALSE)) {
[11:02:57.403]                           master <- get("master", mode = "list", 
[11:02:57.403]                             envir = envir, inherits = FALSE)
[11:02:57.403]                           if (inherits(master, c("SOCKnode", 
[11:02:57.403]                             "SOCK0node"))) {
[11:02:57.403]                             sendCondition <<- function(cond) {
[11:02:57.403]                               data <- list(type = "VALUE", value = cond, 
[11:02:57.403]                                 success = TRUE)
[11:02:57.403]                               parallel_sendData(master, data)
[11:02:57.403]                             }
[11:02:57.403]                             return(sendCondition)
[11:02:57.403]                           }
[11:02:57.403]                         }
[11:02:57.403]                         frame <- frame + 1L
[11:02:57.403]                         envir <- sys.frame(frame)
[11:02:57.403]                       }
[11:02:57.403]                     }
[11:02:57.403]                     sendCondition <<- function(cond) NULL
[11:02:57.403]                   }
[11:02:57.403]                 })
[11:02:57.403]                 withCallingHandlers({
[11:02:57.403]                   {
[11:02:57.403]                     Sys.sleep(0.1)
[11:02:57.403]                     kk
[11:02:57.403]                   }
[11:02:57.403]                 }, immediateCondition = function(cond) {
[11:02:57.403]                   sendCondition <- ...future.makeSendCondition()
[11:02:57.403]                   sendCondition(cond)
[11:02:57.403]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:57.403]                   {
[11:02:57.403]                     inherits <- base::inherits
[11:02:57.403]                     invokeRestart <- base::invokeRestart
[11:02:57.403]                     is.null <- base::is.null
[11:02:57.403]                     muffled <- FALSE
[11:02:57.403]                     if (inherits(cond, "message")) {
[11:02:57.403]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:57.403]                       if (muffled) 
[11:02:57.403]                         invokeRestart("muffleMessage")
[11:02:57.403]                     }
[11:02:57.403]                     else if (inherits(cond, "warning")) {
[11:02:57.403]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:57.403]                       if (muffled) 
[11:02:57.403]                         invokeRestart("muffleWarning")
[11:02:57.403]                     }
[11:02:57.403]                     else if (inherits(cond, "condition")) {
[11:02:57.403]                       if (!is.null(pattern)) {
[11:02:57.403]                         computeRestarts <- base::computeRestarts
[11:02:57.403]                         grepl <- base::grepl
[11:02:57.403]                         restarts <- computeRestarts(cond)
[11:02:57.403]                         for (restart in restarts) {
[11:02:57.403]                           name <- restart$name
[11:02:57.403]                           if (is.null(name)) 
[11:02:57.403]                             next
[11:02:57.403]                           if (!grepl(pattern, name)) 
[11:02:57.403]                             next
[11:02:57.403]                           invokeRestart(restart)
[11:02:57.403]                           muffled <- TRUE
[11:02:57.403]                           break
[11:02:57.403]                         }
[11:02:57.403]                       }
[11:02:57.403]                     }
[11:02:57.403]                     invisible(muffled)
[11:02:57.403]                   }
[11:02:57.403]                   muffleCondition(cond)
[11:02:57.403]                 })
[11:02:57.403]             }))
[11:02:57.403]             future::FutureResult(value = ...future.value$value, 
[11:02:57.403]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:57.403]                   ...future.rng), globalenv = if (FALSE) 
[11:02:57.403]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:57.403]                     ...future.globalenv.names))
[11:02:57.403]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:57.403]         }, condition = base::local({
[11:02:57.403]             c <- base::c
[11:02:57.403]             inherits <- base::inherits
[11:02:57.403]             invokeRestart <- base::invokeRestart
[11:02:57.403]             length <- base::length
[11:02:57.403]             list <- base::list
[11:02:57.403]             seq.int <- base::seq.int
[11:02:57.403]             signalCondition <- base::signalCondition
[11:02:57.403]             sys.calls <- base::sys.calls
[11:02:57.403]             `[[` <- base::`[[`
[11:02:57.403]             `+` <- base::`+`
[11:02:57.403]             `<<-` <- base::`<<-`
[11:02:57.403]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:57.403]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:57.403]                   3L)]
[11:02:57.403]             }
[11:02:57.403]             function(cond) {
[11:02:57.403]                 is_error <- inherits(cond, "error")
[11:02:57.403]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:57.403]                   NULL)
[11:02:57.403]                 if (is_error) {
[11:02:57.403]                   sessionInformation <- function() {
[11:02:57.403]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:57.403]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:57.403]                       search = base::search(), system = base::Sys.info())
[11:02:57.403]                   }
[11:02:57.403]                   ...future.conditions[[length(...future.conditions) + 
[11:02:57.403]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:57.403]                     cond$call), session = sessionInformation(), 
[11:02:57.403]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:57.403]                   signalCondition(cond)
[11:02:57.403]                 }
[11:02:57.403]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:57.403]                 "immediateCondition"))) {
[11:02:57.403]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:57.403]                   ...future.conditions[[length(...future.conditions) + 
[11:02:57.403]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:57.403]                   if (TRUE && !signal) {
[11:02:57.403]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:57.403]                     {
[11:02:57.403]                       inherits <- base::inherits
[11:02:57.403]                       invokeRestart <- base::invokeRestart
[11:02:57.403]                       is.null <- base::is.null
[11:02:57.403]                       muffled <- FALSE
[11:02:57.403]                       if (inherits(cond, "message")) {
[11:02:57.403]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:57.403]                         if (muffled) 
[11:02:57.403]                           invokeRestart("muffleMessage")
[11:02:57.403]                       }
[11:02:57.403]                       else if (inherits(cond, "warning")) {
[11:02:57.403]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:57.403]                         if (muffled) 
[11:02:57.403]                           invokeRestart("muffleWarning")
[11:02:57.403]                       }
[11:02:57.403]                       else if (inherits(cond, "condition")) {
[11:02:57.403]                         if (!is.null(pattern)) {
[11:02:57.403]                           computeRestarts <- base::computeRestarts
[11:02:57.403]                           grepl <- base::grepl
[11:02:57.403]                           restarts <- computeRestarts(cond)
[11:02:57.403]                           for (restart in restarts) {
[11:02:57.403]                             name <- restart$name
[11:02:57.403]                             if (is.null(name)) 
[11:02:57.403]                               next
[11:02:57.403]                             if (!grepl(pattern, name)) 
[11:02:57.403]                               next
[11:02:57.403]                             invokeRestart(restart)
[11:02:57.403]                             muffled <- TRUE
[11:02:57.403]                             break
[11:02:57.403]                           }
[11:02:57.403]                         }
[11:02:57.403]                       }
[11:02:57.403]                       invisible(muffled)
[11:02:57.403]                     }
[11:02:57.403]                     muffleCondition(cond, pattern = "^muffle")
[11:02:57.403]                   }
[11:02:57.403]                 }
[11:02:57.403]                 else {
[11:02:57.403]                   if (TRUE) {
[11:02:57.403]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:57.403]                     {
[11:02:57.403]                       inherits <- base::inherits
[11:02:57.403]                       invokeRestart <- base::invokeRestart
[11:02:57.403]                       is.null <- base::is.null
[11:02:57.403]                       muffled <- FALSE
[11:02:57.403]                       if (inherits(cond, "message")) {
[11:02:57.403]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:57.403]                         if (muffled) 
[11:02:57.403]                           invokeRestart("muffleMessage")
[11:02:57.403]                       }
[11:02:57.403]                       else if (inherits(cond, "warning")) {
[11:02:57.403]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:57.403]                         if (muffled) 
[11:02:57.403]                           invokeRestart("muffleWarning")
[11:02:57.403]                       }
[11:02:57.403]                       else if (inherits(cond, "condition")) {
[11:02:57.403]                         if (!is.null(pattern)) {
[11:02:57.403]                           computeRestarts <- base::computeRestarts
[11:02:57.403]                           grepl <- base::grepl
[11:02:57.403]                           restarts <- computeRestarts(cond)
[11:02:57.403]                           for (restart in restarts) {
[11:02:57.403]                             name <- restart$name
[11:02:57.403]                             if (is.null(name)) 
[11:02:57.403]                               next
[11:02:57.403]                             if (!grepl(pattern, name)) 
[11:02:57.403]                               next
[11:02:57.403]                             invokeRestart(restart)
[11:02:57.403]                             muffled <- TRUE
[11:02:57.403]                             break
[11:02:57.403]                           }
[11:02:57.403]                         }
[11:02:57.403]                       }
[11:02:57.403]                       invisible(muffled)
[11:02:57.403]                     }
[11:02:57.403]                     muffleCondition(cond, pattern = "^muffle")
[11:02:57.403]                   }
[11:02:57.403]                 }
[11:02:57.403]             }
[11:02:57.403]         }))
[11:02:57.403]     }, error = function(ex) {
[11:02:57.403]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:57.403]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:57.403]                 ...future.rng), started = ...future.startTime, 
[11:02:57.403]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:57.403]             version = "1.8"), class = "FutureResult")
[11:02:57.403]     }, finally = {
[11:02:57.403]         if (!identical(...future.workdir, getwd())) 
[11:02:57.403]             setwd(...future.workdir)
[11:02:57.403]         {
[11:02:57.403]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:57.403]                 ...future.oldOptions$nwarnings <- NULL
[11:02:57.403]             }
[11:02:57.403]             base::options(...future.oldOptions)
[11:02:57.403]             if (.Platform$OS.type == "windows") {
[11:02:57.403]                 old_names <- names(...future.oldEnvVars)
[11:02:57.403]                 envs <- base::Sys.getenv()
[11:02:57.403]                 names <- names(envs)
[11:02:57.403]                 common <- intersect(names, old_names)
[11:02:57.403]                 added <- setdiff(names, old_names)
[11:02:57.403]                 removed <- setdiff(old_names, names)
[11:02:57.403]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:57.403]                   envs[common]]
[11:02:57.403]                 NAMES <- toupper(changed)
[11:02:57.403]                 args <- list()
[11:02:57.403]                 for (kk in seq_along(NAMES)) {
[11:02:57.403]                   name <- changed[[kk]]
[11:02:57.403]                   NAME <- NAMES[[kk]]
[11:02:57.403]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:57.403]                     next
[11:02:57.403]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:57.403]                 }
[11:02:57.403]                 NAMES <- toupper(added)
[11:02:57.403]                 for (kk in seq_along(NAMES)) {
[11:02:57.403]                   name <- added[[kk]]
[11:02:57.403]                   NAME <- NAMES[[kk]]
[11:02:57.403]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:57.403]                     next
[11:02:57.403]                   args[[name]] <- ""
[11:02:57.403]                 }
[11:02:57.403]                 NAMES <- toupper(removed)
[11:02:57.403]                 for (kk in seq_along(NAMES)) {
[11:02:57.403]                   name <- removed[[kk]]
[11:02:57.403]                   NAME <- NAMES[[kk]]
[11:02:57.403]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:57.403]                     next
[11:02:57.403]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:57.403]                 }
[11:02:57.403]                 if (length(args) > 0) 
[11:02:57.403]                   base::do.call(base::Sys.setenv, args = args)
[11:02:57.403]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:57.403]             }
[11:02:57.403]             else {
[11:02:57.403]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:57.403]             }
[11:02:57.403]             {
[11:02:57.403]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:57.403]                   0L) {
[11:02:57.403]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:57.403]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:57.403]                   base::options(opts)
[11:02:57.403]                 }
[11:02:57.403]                 {
[11:02:57.403]                   {
[11:02:57.403]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:57.403]                     NULL
[11:02:57.403]                   }
[11:02:57.403]                   options(future.plan = NULL)
[11:02:57.403]                   if (is.na(NA_character_)) 
[11:02:57.403]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:57.403]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:57.403]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:57.403]                     .init = FALSE)
[11:02:57.403]                 }
[11:02:57.403]             }
[11:02:57.403]         }
[11:02:57.403]     })
[11:02:57.403]     if (TRUE) {
[11:02:57.403]         base::sink(type = "output", split = FALSE)
[11:02:57.403]         if (TRUE) {
[11:02:57.403]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:57.403]         }
[11:02:57.403]         else {
[11:02:57.403]             ...future.result["stdout"] <- base::list(NULL)
[11:02:57.403]         }
[11:02:57.403]         base::close(...future.stdout)
[11:02:57.403]         ...future.stdout <- NULL
[11:02:57.403]     }
[11:02:57.403]     ...future.result$conditions <- ...future.conditions
[11:02:57.403]     ...future.result$finished <- base::Sys.time()
[11:02:57.403]     ...future.result
[11:02:57.403] }
[11:02:57.408] Exporting 1 global objects (344 bytes) to cluster node #1 ...
[11:02:57.408] Exporting ‘kk’ (35 bytes) to cluster node #1 ...
[11:02:57.409] Exporting ‘kk’ (35 bytes) to cluster node #1 ... DONE
[11:02:57.409] Exporting 1 global objects (344 bytes) to cluster node #1 ... DONE
[11:02:57.409] MultisessionFuture started
[11:02:57.409] - Launch lazy future ... done
[11:02:57.410] run() for ‘MultisessionFuture’ ... done
[11:02:57.410] getGlobalsAndPackages() ...
[11:02:57.410] Searching for globals...
[11:02:57.411] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[11:02:57.411] Searching for globals ... DONE
[11:02:57.411] Resolving globals: FALSE
[11:02:57.411] The total size of the 1 globals is 35 bytes (35 bytes)
[11:02:57.411] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[11:02:57.412] - globals: [1] ‘kk’
[11:02:57.412] 
[11:02:57.412] getGlobalsAndPackages() ... DONE
[11:02:57.412] run() for ‘Future’ ...
[11:02:57.412] - state: ‘created’
[11:02:57.412] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:57.426] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:57.426] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:57.426]   - Field: ‘node’
[11:02:57.426]   - Field: ‘label’
[11:02:57.426]   - Field: ‘local’
[11:02:57.426]   - Field: ‘owner’
[11:02:57.427]   - Field: ‘envir’
[11:02:57.427]   - Field: ‘workers’
[11:02:57.427]   - Field: ‘packages’
[11:02:57.427]   - Field: ‘gc’
[11:02:57.427]   - Field: ‘conditions’
[11:02:57.427]   - Field: ‘persistent’
[11:02:57.427]   - Field: ‘expr’
[11:02:57.427]   - Field: ‘uuid’
[11:02:57.427]   - Field: ‘seed’
[11:02:57.427]   - Field: ‘version’
[11:02:57.427]   - Field: ‘result’
[11:02:57.427]   - Field: ‘asynchronous’
[11:02:57.427]   - Field: ‘calls’
[11:02:57.428]   - Field: ‘globals’
[11:02:57.428]   - Field: ‘stdout’
[11:02:57.428]   - Field: ‘earlySignal’
[11:02:57.428]   - Field: ‘lazy’
[11:02:57.428]   - Field: ‘state’
[11:02:57.428] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:57.428] - Launch lazy future ...
[11:02:57.428] Packages needed by the future expression (n = 0): <none>
[11:02:57.428] Packages needed by future strategies (n = 0): <none>
[11:02:57.429] {
[11:02:57.429]     {
[11:02:57.429]         {
[11:02:57.429]             ...future.startTime <- base::Sys.time()
[11:02:57.429]             {
[11:02:57.429]                 {
[11:02:57.429]                   {
[11:02:57.429]                     {
[11:02:57.429]                       base::local({
[11:02:57.429]                         has_future <- base::requireNamespace("future", 
[11:02:57.429]                           quietly = TRUE)
[11:02:57.429]                         if (has_future) {
[11:02:57.429]                           ns <- base::getNamespace("future")
[11:02:57.429]                           version <- ns[[".package"]][["version"]]
[11:02:57.429]                           if (is.null(version)) 
[11:02:57.429]                             version <- utils::packageVersion("future")
[11:02:57.429]                         }
[11:02:57.429]                         else {
[11:02:57.429]                           version <- NULL
[11:02:57.429]                         }
[11:02:57.429]                         if (!has_future || version < "1.8.0") {
[11:02:57.429]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:57.429]                             "", base::R.version$version.string), 
[11:02:57.429]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:57.429]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:57.429]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:57.429]                               "release", "version")], collapse = " "), 
[11:02:57.429]                             hostname = base::Sys.info()[["nodename"]])
[11:02:57.429]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:57.429]                             info)
[11:02:57.429]                           info <- base::paste(info, collapse = "; ")
[11:02:57.429]                           if (!has_future) {
[11:02:57.429]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:57.429]                               info)
[11:02:57.429]                           }
[11:02:57.429]                           else {
[11:02:57.429]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:57.429]                               info, version)
[11:02:57.429]                           }
[11:02:57.429]                           base::stop(msg)
[11:02:57.429]                         }
[11:02:57.429]                       })
[11:02:57.429]                     }
[11:02:57.429]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:57.429]                     base::options(mc.cores = 1L)
[11:02:57.429]                   }
[11:02:57.429]                   ...future.strategy.old <- future::plan("list")
[11:02:57.429]                   options(future.plan = NULL)
[11:02:57.429]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:57.429]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:57.429]                 }
[11:02:57.429]                 ...future.workdir <- getwd()
[11:02:57.429]             }
[11:02:57.429]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:57.429]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:57.429]         }
[11:02:57.429]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:57.429]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:57.429]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:57.429]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:57.429]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:57.429]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:57.429]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:57.429]             base::names(...future.oldOptions))
[11:02:57.429]     }
[11:02:57.429]     if (FALSE) {
[11:02:57.429]     }
[11:02:57.429]     else {
[11:02:57.429]         if (TRUE) {
[11:02:57.429]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:57.429]                 open = "w")
[11:02:57.429]         }
[11:02:57.429]         else {
[11:02:57.429]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:57.429]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:57.429]         }
[11:02:57.429]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:57.429]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:57.429]             base::sink(type = "output", split = FALSE)
[11:02:57.429]             base::close(...future.stdout)
[11:02:57.429]         }, add = TRUE)
[11:02:57.429]     }
[11:02:57.429]     ...future.frame <- base::sys.nframe()
[11:02:57.429]     ...future.conditions <- base::list()
[11:02:57.429]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:57.429]     if (FALSE) {
[11:02:57.429]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:57.429]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:57.429]     }
[11:02:57.429]     ...future.result <- base::tryCatch({
[11:02:57.429]         base::withCallingHandlers({
[11:02:57.429]             ...future.value <- base::withVisible(base::local({
[11:02:57.429]                 ...future.makeSendCondition <- base::local({
[11:02:57.429]                   sendCondition <- NULL
[11:02:57.429]                   function(frame = 1L) {
[11:02:57.429]                     if (is.function(sendCondition)) 
[11:02:57.429]                       return(sendCondition)
[11:02:57.429]                     ns <- getNamespace("parallel")
[11:02:57.429]                     if (exists("sendData", mode = "function", 
[11:02:57.429]                       envir = ns)) {
[11:02:57.429]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:57.429]                         envir = ns)
[11:02:57.429]                       envir <- sys.frame(frame)
[11:02:57.429]                       master <- NULL
[11:02:57.429]                       while (!identical(envir, .GlobalEnv) && 
[11:02:57.429]                         !identical(envir, emptyenv())) {
[11:02:57.429]                         if (exists("master", mode = "list", envir = envir, 
[11:02:57.429]                           inherits = FALSE)) {
[11:02:57.429]                           master <- get("master", mode = "list", 
[11:02:57.429]                             envir = envir, inherits = FALSE)
[11:02:57.429]                           if (inherits(master, c("SOCKnode", 
[11:02:57.429]                             "SOCK0node"))) {
[11:02:57.429]                             sendCondition <<- function(cond) {
[11:02:57.429]                               data <- list(type = "VALUE", value = cond, 
[11:02:57.429]                                 success = TRUE)
[11:02:57.429]                               parallel_sendData(master, data)
[11:02:57.429]                             }
[11:02:57.429]                             return(sendCondition)
[11:02:57.429]                           }
[11:02:57.429]                         }
[11:02:57.429]                         frame <- frame + 1L
[11:02:57.429]                         envir <- sys.frame(frame)
[11:02:57.429]                       }
[11:02:57.429]                     }
[11:02:57.429]                     sendCondition <<- function(cond) NULL
[11:02:57.429]                   }
[11:02:57.429]                 })
[11:02:57.429]                 withCallingHandlers({
[11:02:57.429]                   {
[11:02:57.429]                     Sys.sleep(0.1)
[11:02:57.429]                     kk
[11:02:57.429]                   }
[11:02:57.429]                 }, immediateCondition = function(cond) {
[11:02:57.429]                   sendCondition <- ...future.makeSendCondition()
[11:02:57.429]                   sendCondition(cond)
[11:02:57.429]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:57.429]                   {
[11:02:57.429]                     inherits <- base::inherits
[11:02:57.429]                     invokeRestart <- base::invokeRestart
[11:02:57.429]                     is.null <- base::is.null
[11:02:57.429]                     muffled <- FALSE
[11:02:57.429]                     if (inherits(cond, "message")) {
[11:02:57.429]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:57.429]                       if (muffled) 
[11:02:57.429]                         invokeRestart("muffleMessage")
[11:02:57.429]                     }
[11:02:57.429]                     else if (inherits(cond, "warning")) {
[11:02:57.429]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:57.429]                       if (muffled) 
[11:02:57.429]                         invokeRestart("muffleWarning")
[11:02:57.429]                     }
[11:02:57.429]                     else if (inherits(cond, "condition")) {
[11:02:57.429]                       if (!is.null(pattern)) {
[11:02:57.429]                         computeRestarts <- base::computeRestarts
[11:02:57.429]                         grepl <- base::grepl
[11:02:57.429]                         restarts <- computeRestarts(cond)
[11:02:57.429]                         for (restart in restarts) {
[11:02:57.429]                           name <- restart$name
[11:02:57.429]                           if (is.null(name)) 
[11:02:57.429]                             next
[11:02:57.429]                           if (!grepl(pattern, name)) 
[11:02:57.429]                             next
[11:02:57.429]                           invokeRestart(restart)
[11:02:57.429]                           muffled <- TRUE
[11:02:57.429]                           break
[11:02:57.429]                         }
[11:02:57.429]                       }
[11:02:57.429]                     }
[11:02:57.429]                     invisible(muffled)
[11:02:57.429]                   }
[11:02:57.429]                   muffleCondition(cond)
[11:02:57.429]                 })
[11:02:57.429]             }))
[11:02:57.429]             future::FutureResult(value = ...future.value$value, 
[11:02:57.429]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:57.429]                   ...future.rng), globalenv = if (FALSE) 
[11:02:57.429]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:57.429]                     ...future.globalenv.names))
[11:02:57.429]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:57.429]         }, condition = base::local({
[11:02:57.429]             c <- base::c
[11:02:57.429]             inherits <- base::inherits
[11:02:57.429]             invokeRestart <- base::invokeRestart
[11:02:57.429]             length <- base::length
[11:02:57.429]             list <- base::list
[11:02:57.429]             seq.int <- base::seq.int
[11:02:57.429]             signalCondition <- base::signalCondition
[11:02:57.429]             sys.calls <- base::sys.calls
[11:02:57.429]             `[[` <- base::`[[`
[11:02:57.429]             `+` <- base::`+`
[11:02:57.429]             `<<-` <- base::`<<-`
[11:02:57.429]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:57.429]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:57.429]                   3L)]
[11:02:57.429]             }
[11:02:57.429]             function(cond) {
[11:02:57.429]                 is_error <- inherits(cond, "error")
[11:02:57.429]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:57.429]                   NULL)
[11:02:57.429]                 if (is_error) {
[11:02:57.429]                   sessionInformation <- function() {
[11:02:57.429]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:57.429]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:57.429]                       search = base::search(), system = base::Sys.info())
[11:02:57.429]                   }
[11:02:57.429]                   ...future.conditions[[length(...future.conditions) + 
[11:02:57.429]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:57.429]                     cond$call), session = sessionInformation(), 
[11:02:57.429]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:57.429]                   signalCondition(cond)
[11:02:57.429]                 }
[11:02:57.429]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:57.429]                 "immediateCondition"))) {
[11:02:57.429]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:57.429]                   ...future.conditions[[length(...future.conditions) + 
[11:02:57.429]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:57.429]                   if (TRUE && !signal) {
[11:02:57.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:57.429]                     {
[11:02:57.429]                       inherits <- base::inherits
[11:02:57.429]                       invokeRestart <- base::invokeRestart
[11:02:57.429]                       is.null <- base::is.null
[11:02:57.429]                       muffled <- FALSE
[11:02:57.429]                       if (inherits(cond, "message")) {
[11:02:57.429]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:57.429]                         if (muffled) 
[11:02:57.429]                           invokeRestart("muffleMessage")
[11:02:57.429]                       }
[11:02:57.429]                       else if (inherits(cond, "warning")) {
[11:02:57.429]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:57.429]                         if (muffled) 
[11:02:57.429]                           invokeRestart("muffleWarning")
[11:02:57.429]                       }
[11:02:57.429]                       else if (inherits(cond, "condition")) {
[11:02:57.429]                         if (!is.null(pattern)) {
[11:02:57.429]                           computeRestarts <- base::computeRestarts
[11:02:57.429]                           grepl <- base::grepl
[11:02:57.429]                           restarts <- computeRestarts(cond)
[11:02:57.429]                           for (restart in restarts) {
[11:02:57.429]                             name <- restart$name
[11:02:57.429]                             if (is.null(name)) 
[11:02:57.429]                               next
[11:02:57.429]                             if (!grepl(pattern, name)) 
[11:02:57.429]                               next
[11:02:57.429]                             invokeRestart(restart)
[11:02:57.429]                             muffled <- TRUE
[11:02:57.429]                             break
[11:02:57.429]                           }
[11:02:57.429]                         }
[11:02:57.429]                       }
[11:02:57.429]                       invisible(muffled)
[11:02:57.429]                     }
[11:02:57.429]                     muffleCondition(cond, pattern = "^muffle")
[11:02:57.429]                   }
[11:02:57.429]                 }
[11:02:57.429]                 else {
[11:02:57.429]                   if (TRUE) {
[11:02:57.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:57.429]                     {
[11:02:57.429]                       inherits <- base::inherits
[11:02:57.429]                       invokeRestart <- base::invokeRestart
[11:02:57.429]                       is.null <- base::is.null
[11:02:57.429]                       muffled <- FALSE
[11:02:57.429]                       if (inherits(cond, "message")) {
[11:02:57.429]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:57.429]                         if (muffled) 
[11:02:57.429]                           invokeRestart("muffleMessage")
[11:02:57.429]                       }
[11:02:57.429]                       else if (inherits(cond, "warning")) {
[11:02:57.429]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:57.429]                         if (muffled) 
[11:02:57.429]                           invokeRestart("muffleWarning")
[11:02:57.429]                       }
[11:02:57.429]                       else if (inherits(cond, "condition")) {
[11:02:57.429]                         if (!is.null(pattern)) {
[11:02:57.429]                           computeRestarts <- base::computeRestarts
[11:02:57.429]                           grepl <- base::grepl
[11:02:57.429]                           restarts <- computeRestarts(cond)
[11:02:57.429]                           for (restart in restarts) {
[11:02:57.429]                             name <- restart$name
[11:02:57.429]                             if (is.null(name)) 
[11:02:57.429]                               next
[11:02:57.429]                             if (!grepl(pattern, name)) 
[11:02:57.429]                               next
[11:02:57.429]                             invokeRestart(restart)
[11:02:57.429]                             muffled <- TRUE
[11:02:57.429]                             break
[11:02:57.429]                           }
[11:02:57.429]                         }
[11:02:57.429]                       }
[11:02:57.429]                       invisible(muffled)
[11:02:57.429]                     }
[11:02:57.429]                     muffleCondition(cond, pattern = "^muffle")
[11:02:57.429]                   }
[11:02:57.429]                 }
[11:02:57.429]             }
[11:02:57.429]         }))
[11:02:57.429]     }, error = function(ex) {
[11:02:57.429]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:57.429]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:57.429]                 ...future.rng), started = ...future.startTime, 
[11:02:57.429]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:57.429]             version = "1.8"), class = "FutureResult")
[11:02:57.429]     }, finally = {
[11:02:57.429]         if (!identical(...future.workdir, getwd())) 
[11:02:57.429]             setwd(...future.workdir)
[11:02:57.429]         {
[11:02:57.429]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:57.429]                 ...future.oldOptions$nwarnings <- NULL
[11:02:57.429]             }
[11:02:57.429]             base::options(...future.oldOptions)
[11:02:57.429]             if (.Platform$OS.type == "windows") {
[11:02:57.429]                 old_names <- names(...future.oldEnvVars)
[11:02:57.429]                 envs <- base::Sys.getenv()
[11:02:57.429]                 names <- names(envs)
[11:02:57.429]                 common <- intersect(names, old_names)
[11:02:57.429]                 added <- setdiff(names, old_names)
[11:02:57.429]                 removed <- setdiff(old_names, names)
[11:02:57.429]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:57.429]                   envs[common]]
[11:02:57.429]                 NAMES <- toupper(changed)
[11:02:57.429]                 args <- list()
[11:02:57.429]                 for (kk in seq_along(NAMES)) {
[11:02:57.429]                   name <- changed[[kk]]
[11:02:57.429]                   NAME <- NAMES[[kk]]
[11:02:57.429]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:57.429]                     next
[11:02:57.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:57.429]                 }
[11:02:57.429]                 NAMES <- toupper(added)
[11:02:57.429]                 for (kk in seq_along(NAMES)) {
[11:02:57.429]                   name <- added[[kk]]
[11:02:57.429]                   NAME <- NAMES[[kk]]
[11:02:57.429]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:57.429]                     next
[11:02:57.429]                   args[[name]] <- ""
[11:02:57.429]                 }
[11:02:57.429]                 NAMES <- toupper(removed)
[11:02:57.429]                 for (kk in seq_along(NAMES)) {
[11:02:57.429]                   name <- removed[[kk]]
[11:02:57.429]                   NAME <- NAMES[[kk]]
[11:02:57.429]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:57.429]                     next
[11:02:57.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:57.429]                 }
[11:02:57.429]                 if (length(args) > 0) 
[11:02:57.429]                   base::do.call(base::Sys.setenv, args = args)
[11:02:57.429]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:57.429]             }
[11:02:57.429]             else {
[11:02:57.429]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:57.429]             }
[11:02:57.429]             {
[11:02:57.429]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:57.429]                   0L) {
[11:02:57.429]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:57.429]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:57.429]                   base::options(opts)
[11:02:57.429]                 }
[11:02:57.429]                 {
[11:02:57.429]                   {
[11:02:57.429]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:57.429]                     NULL
[11:02:57.429]                   }
[11:02:57.429]                   options(future.plan = NULL)
[11:02:57.429]                   if (is.na(NA_character_)) 
[11:02:57.429]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:57.429]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:57.429]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:57.429]                     .init = FALSE)
[11:02:57.429]                 }
[11:02:57.429]             }
[11:02:57.429]         }
[11:02:57.429]     })
[11:02:57.429]     if (TRUE) {
[11:02:57.429]         base::sink(type = "output", split = FALSE)
[11:02:57.429]         if (TRUE) {
[11:02:57.429]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:57.429]         }
[11:02:57.429]         else {
[11:02:57.429]             ...future.result["stdout"] <- base::list(NULL)
[11:02:57.429]         }
[11:02:57.429]         base::close(...future.stdout)
[11:02:57.429]         ...future.stdout <- NULL
[11:02:57.429]     }
[11:02:57.429]     ...future.result$conditions <- ...future.conditions
[11:02:57.429]     ...future.result$finished <- base::Sys.time()
[11:02:57.429]     ...future.result
[11:02:57.429] }
[11:02:57.431] Exporting 1 global objects (344 bytes) to cluster node #2 ...
[11:02:57.432] Exporting ‘kk’ (35 bytes) to cluster node #2 ...
[11:02:57.432] Exporting ‘kk’ (35 bytes) to cluster node #2 ... DONE
[11:02:57.432] Exporting 1 global objects (344 bytes) to cluster node #2 ... DONE
[11:02:57.433] MultisessionFuture started
[11:02:57.433] - Launch lazy future ... done
[11:02:57.433] run() for ‘MultisessionFuture’ ... done
[11:02:57.433] getGlobalsAndPackages() ...
[11:02:57.433] Searching for globals...
[11:02:57.434] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[11:02:57.434] Searching for globals ... DONE
[11:02:57.434] Resolving globals: FALSE
[11:02:57.434] The total size of the 1 globals is 35 bytes (35 bytes)
[11:02:57.435] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[11:02:57.435] - globals: [1] ‘kk’
[11:02:57.435] 
[11:02:57.435] getGlobalsAndPackages() ... DONE
[11:02:57.435] run() for ‘Future’ ...
[11:02:57.435] - state: ‘created’
[11:02:57.435] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:57.449] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:57.449] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:57.450]   - Field: ‘node’
[11:02:57.450]   - Field: ‘label’
[11:02:57.450]   - Field: ‘local’
[11:02:57.450]   - Field: ‘owner’
[11:02:57.450]   - Field: ‘envir’
[11:02:57.450]   - Field: ‘workers’
[11:02:57.450]   - Field: ‘packages’
[11:02:57.450]   - Field: ‘gc’
[11:02:57.450]   - Field: ‘conditions’
[11:02:57.450]   - Field: ‘persistent’
[11:02:57.450]   - Field: ‘expr’
[11:02:57.450]   - Field: ‘uuid’
[11:02:57.451]   - Field: ‘seed’
[11:02:57.451]   - Field: ‘version’
[11:02:57.451]   - Field: ‘result’
[11:02:57.451]   - Field: ‘asynchronous’
[11:02:57.451]   - Field: ‘calls’
[11:02:57.451]   - Field: ‘globals’
[11:02:57.451]   - Field: ‘stdout’
[11:02:57.451]   - Field: ‘earlySignal’
[11:02:57.451]   - Field: ‘lazy’
[11:02:57.451]   - Field: ‘state’
[11:02:57.451] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:57.451] - Launch lazy future ...
[11:02:57.452] Packages needed by the future expression (n = 0): <none>
[11:02:57.452] Packages needed by future strategies (n = 0): <none>
[11:02:57.452] {
[11:02:57.452]     {
[11:02:57.452]         {
[11:02:57.452]             ...future.startTime <- base::Sys.time()
[11:02:57.452]             {
[11:02:57.452]                 {
[11:02:57.452]                   {
[11:02:57.452]                     {
[11:02:57.452]                       base::local({
[11:02:57.452]                         has_future <- base::requireNamespace("future", 
[11:02:57.452]                           quietly = TRUE)
[11:02:57.452]                         if (has_future) {
[11:02:57.452]                           ns <- base::getNamespace("future")
[11:02:57.452]                           version <- ns[[".package"]][["version"]]
[11:02:57.452]                           if (is.null(version)) 
[11:02:57.452]                             version <- utils::packageVersion("future")
[11:02:57.452]                         }
[11:02:57.452]                         else {
[11:02:57.452]                           version <- NULL
[11:02:57.452]                         }
[11:02:57.452]                         if (!has_future || version < "1.8.0") {
[11:02:57.452]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:57.452]                             "", base::R.version$version.string), 
[11:02:57.452]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:57.452]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:57.452]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:57.452]                               "release", "version")], collapse = " "), 
[11:02:57.452]                             hostname = base::Sys.info()[["nodename"]])
[11:02:57.452]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:57.452]                             info)
[11:02:57.452]                           info <- base::paste(info, collapse = "; ")
[11:02:57.452]                           if (!has_future) {
[11:02:57.452]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:57.452]                               info)
[11:02:57.452]                           }
[11:02:57.452]                           else {
[11:02:57.452]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:57.452]                               info, version)
[11:02:57.452]                           }
[11:02:57.452]                           base::stop(msg)
[11:02:57.452]                         }
[11:02:57.452]                       })
[11:02:57.452]                     }
[11:02:57.452]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:57.452]                     base::options(mc.cores = 1L)
[11:02:57.452]                   }
[11:02:57.452]                   ...future.strategy.old <- future::plan("list")
[11:02:57.452]                   options(future.plan = NULL)
[11:02:57.452]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:57.452]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:57.452]                 }
[11:02:57.452]                 ...future.workdir <- getwd()
[11:02:57.452]             }
[11:02:57.452]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:57.452]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:57.452]         }
[11:02:57.452]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:57.452]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:57.452]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:57.452]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:57.452]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:57.452]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:57.452]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:57.452]             base::names(...future.oldOptions))
[11:02:57.452]     }
[11:02:57.452]     if (FALSE) {
[11:02:57.452]     }
[11:02:57.452]     else {
[11:02:57.452]         if (TRUE) {
[11:02:57.452]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:57.452]                 open = "w")
[11:02:57.452]         }
[11:02:57.452]         else {
[11:02:57.452]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:57.452]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:57.452]         }
[11:02:57.452]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:57.452]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:57.452]             base::sink(type = "output", split = FALSE)
[11:02:57.452]             base::close(...future.stdout)
[11:02:57.452]         }, add = TRUE)
[11:02:57.452]     }
[11:02:57.452]     ...future.frame <- base::sys.nframe()
[11:02:57.452]     ...future.conditions <- base::list()
[11:02:57.452]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:57.452]     if (FALSE) {
[11:02:57.452]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:57.452]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:57.452]     }
[11:02:57.452]     ...future.result <- base::tryCatch({
[11:02:57.452]         base::withCallingHandlers({
[11:02:57.452]             ...future.value <- base::withVisible(base::local({
[11:02:57.452]                 ...future.makeSendCondition <- base::local({
[11:02:57.452]                   sendCondition <- NULL
[11:02:57.452]                   function(frame = 1L) {
[11:02:57.452]                     if (is.function(sendCondition)) 
[11:02:57.452]                       return(sendCondition)
[11:02:57.452]                     ns <- getNamespace("parallel")
[11:02:57.452]                     if (exists("sendData", mode = "function", 
[11:02:57.452]                       envir = ns)) {
[11:02:57.452]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:57.452]                         envir = ns)
[11:02:57.452]                       envir <- sys.frame(frame)
[11:02:57.452]                       master <- NULL
[11:02:57.452]                       while (!identical(envir, .GlobalEnv) && 
[11:02:57.452]                         !identical(envir, emptyenv())) {
[11:02:57.452]                         if (exists("master", mode = "list", envir = envir, 
[11:02:57.452]                           inherits = FALSE)) {
[11:02:57.452]                           master <- get("master", mode = "list", 
[11:02:57.452]                             envir = envir, inherits = FALSE)
[11:02:57.452]                           if (inherits(master, c("SOCKnode", 
[11:02:57.452]                             "SOCK0node"))) {
[11:02:57.452]                             sendCondition <<- function(cond) {
[11:02:57.452]                               data <- list(type = "VALUE", value = cond, 
[11:02:57.452]                                 success = TRUE)
[11:02:57.452]                               parallel_sendData(master, data)
[11:02:57.452]                             }
[11:02:57.452]                             return(sendCondition)
[11:02:57.452]                           }
[11:02:57.452]                         }
[11:02:57.452]                         frame <- frame + 1L
[11:02:57.452]                         envir <- sys.frame(frame)
[11:02:57.452]                       }
[11:02:57.452]                     }
[11:02:57.452]                     sendCondition <<- function(cond) NULL
[11:02:57.452]                   }
[11:02:57.452]                 })
[11:02:57.452]                 withCallingHandlers({
[11:02:57.452]                   {
[11:02:57.452]                     Sys.sleep(0.1)
[11:02:57.452]                     kk
[11:02:57.452]                   }
[11:02:57.452]                 }, immediateCondition = function(cond) {
[11:02:57.452]                   sendCondition <- ...future.makeSendCondition()
[11:02:57.452]                   sendCondition(cond)
[11:02:57.452]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:57.452]                   {
[11:02:57.452]                     inherits <- base::inherits
[11:02:57.452]                     invokeRestart <- base::invokeRestart
[11:02:57.452]                     is.null <- base::is.null
[11:02:57.452]                     muffled <- FALSE
[11:02:57.452]                     if (inherits(cond, "message")) {
[11:02:57.452]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:57.452]                       if (muffled) 
[11:02:57.452]                         invokeRestart("muffleMessage")
[11:02:57.452]                     }
[11:02:57.452]                     else if (inherits(cond, "warning")) {
[11:02:57.452]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:57.452]                       if (muffled) 
[11:02:57.452]                         invokeRestart("muffleWarning")
[11:02:57.452]                     }
[11:02:57.452]                     else if (inherits(cond, "condition")) {
[11:02:57.452]                       if (!is.null(pattern)) {
[11:02:57.452]                         computeRestarts <- base::computeRestarts
[11:02:57.452]                         grepl <- base::grepl
[11:02:57.452]                         restarts <- computeRestarts(cond)
[11:02:57.452]                         for (restart in restarts) {
[11:02:57.452]                           name <- restart$name
[11:02:57.452]                           if (is.null(name)) 
[11:02:57.452]                             next
[11:02:57.452]                           if (!grepl(pattern, name)) 
[11:02:57.452]                             next
[11:02:57.452]                           invokeRestart(restart)
[11:02:57.452]                           muffled <- TRUE
[11:02:57.452]                           break
[11:02:57.452]                         }
[11:02:57.452]                       }
[11:02:57.452]                     }
[11:02:57.452]                     invisible(muffled)
[11:02:57.452]                   }
[11:02:57.452]                   muffleCondition(cond)
[11:02:57.452]                 })
[11:02:57.452]             }))
[11:02:57.452]             future::FutureResult(value = ...future.value$value, 
[11:02:57.452]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:57.452]                   ...future.rng), globalenv = if (FALSE) 
[11:02:57.452]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:57.452]                     ...future.globalenv.names))
[11:02:57.452]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:57.452]         }, condition = base::local({
[11:02:57.452]             c <- base::c
[11:02:57.452]             inherits <- base::inherits
[11:02:57.452]             invokeRestart <- base::invokeRestart
[11:02:57.452]             length <- base::length
[11:02:57.452]             list <- base::list
[11:02:57.452]             seq.int <- base::seq.int
[11:02:57.452]             signalCondition <- base::signalCondition
[11:02:57.452]             sys.calls <- base::sys.calls
[11:02:57.452]             `[[` <- base::`[[`
[11:02:57.452]             `+` <- base::`+`
[11:02:57.452]             `<<-` <- base::`<<-`
[11:02:57.452]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:57.452]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:57.452]                   3L)]
[11:02:57.452]             }
[11:02:57.452]             function(cond) {
[11:02:57.452]                 is_error <- inherits(cond, "error")
[11:02:57.452]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:57.452]                   NULL)
[11:02:57.452]                 if (is_error) {
[11:02:57.452]                   sessionInformation <- function() {
[11:02:57.452]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:57.452]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:57.452]                       search = base::search(), system = base::Sys.info())
[11:02:57.452]                   }
[11:02:57.452]                   ...future.conditions[[length(...future.conditions) + 
[11:02:57.452]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:57.452]                     cond$call), session = sessionInformation(), 
[11:02:57.452]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:57.452]                   signalCondition(cond)
[11:02:57.452]                 }
[11:02:57.452]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:57.452]                 "immediateCondition"))) {
[11:02:57.452]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:57.452]                   ...future.conditions[[length(...future.conditions) + 
[11:02:57.452]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:57.452]                   if (TRUE && !signal) {
[11:02:57.452]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:57.452]                     {
[11:02:57.452]                       inherits <- base::inherits
[11:02:57.452]                       invokeRestart <- base::invokeRestart
[11:02:57.452]                       is.null <- base::is.null
[11:02:57.452]                       muffled <- FALSE
[11:02:57.452]                       if (inherits(cond, "message")) {
[11:02:57.452]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:57.452]                         if (muffled) 
[11:02:57.452]                           invokeRestart("muffleMessage")
[11:02:57.452]                       }
[11:02:57.452]                       else if (inherits(cond, "warning")) {
[11:02:57.452]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:57.452]                         if (muffled) 
[11:02:57.452]                           invokeRestart("muffleWarning")
[11:02:57.452]                       }
[11:02:57.452]                       else if (inherits(cond, "condition")) {
[11:02:57.452]                         if (!is.null(pattern)) {
[11:02:57.452]                           computeRestarts <- base::computeRestarts
[11:02:57.452]                           grepl <- base::grepl
[11:02:57.452]                           restarts <- computeRestarts(cond)
[11:02:57.452]                           for (restart in restarts) {
[11:02:57.452]                             name <- restart$name
[11:02:57.452]                             if (is.null(name)) 
[11:02:57.452]                               next
[11:02:57.452]                             if (!grepl(pattern, name)) 
[11:02:57.452]                               next
[11:02:57.452]                             invokeRestart(restart)
[11:02:57.452]                             muffled <- TRUE
[11:02:57.452]                             break
[11:02:57.452]                           }
[11:02:57.452]                         }
[11:02:57.452]                       }
[11:02:57.452]                       invisible(muffled)
[11:02:57.452]                     }
[11:02:57.452]                     muffleCondition(cond, pattern = "^muffle")
[11:02:57.452]                   }
[11:02:57.452]                 }
[11:02:57.452]                 else {
[11:02:57.452]                   if (TRUE) {
[11:02:57.452]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:57.452]                     {
[11:02:57.452]                       inherits <- base::inherits
[11:02:57.452]                       invokeRestart <- base::invokeRestart
[11:02:57.452]                       is.null <- base::is.null
[11:02:57.452]                       muffled <- FALSE
[11:02:57.452]                       if (inherits(cond, "message")) {
[11:02:57.452]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:57.452]                         if (muffled) 
[11:02:57.452]                           invokeRestart("muffleMessage")
[11:02:57.452]                       }
[11:02:57.452]                       else if (inherits(cond, "warning")) {
[11:02:57.452]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:57.452]                         if (muffled) 
[11:02:57.452]                           invokeRestart("muffleWarning")
[11:02:57.452]                       }
[11:02:57.452]                       else if (inherits(cond, "condition")) {
[11:02:57.452]                         if (!is.null(pattern)) {
[11:02:57.452]                           computeRestarts <- base::computeRestarts
[11:02:57.452]                           grepl <- base::grepl
[11:02:57.452]                           restarts <- computeRestarts(cond)
[11:02:57.452]                           for (restart in restarts) {
[11:02:57.452]                             name <- restart$name
[11:02:57.452]                             if (is.null(name)) 
[11:02:57.452]                               next
[11:02:57.452]                             if (!grepl(pattern, name)) 
[11:02:57.452]                               next
[11:02:57.452]                             invokeRestart(restart)
[11:02:57.452]                             muffled <- TRUE
[11:02:57.452]                             break
[11:02:57.452]                           }
[11:02:57.452]                         }
[11:02:57.452]                       }
[11:02:57.452]                       invisible(muffled)
[11:02:57.452]                     }
[11:02:57.452]                     muffleCondition(cond, pattern = "^muffle")
[11:02:57.452]                   }
[11:02:57.452]                 }
[11:02:57.452]             }
[11:02:57.452]         }))
[11:02:57.452]     }, error = function(ex) {
[11:02:57.452]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:57.452]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:57.452]                 ...future.rng), started = ...future.startTime, 
[11:02:57.452]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:57.452]             version = "1.8"), class = "FutureResult")
[11:02:57.452]     }, finally = {
[11:02:57.452]         if (!identical(...future.workdir, getwd())) 
[11:02:57.452]             setwd(...future.workdir)
[11:02:57.452]         {
[11:02:57.452]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:57.452]                 ...future.oldOptions$nwarnings <- NULL
[11:02:57.452]             }
[11:02:57.452]             base::options(...future.oldOptions)
[11:02:57.452]             if (.Platform$OS.type == "windows") {
[11:02:57.452]                 old_names <- names(...future.oldEnvVars)
[11:02:57.452]                 envs <- base::Sys.getenv()
[11:02:57.452]                 names <- names(envs)
[11:02:57.452]                 common <- intersect(names, old_names)
[11:02:57.452]                 added <- setdiff(names, old_names)
[11:02:57.452]                 removed <- setdiff(old_names, names)
[11:02:57.452]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:57.452]                   envs[common]]
[11:02:57.452]                 NAMES <- toupper(changed)
[11:02:57.452]                 args <- list()
[11:02:57.452]                 for (kk in seq_along(NAMES)) {
[11:02:57.452]                   name <- changed[[kk]]
[11:02:57.452]                   NAME <- NAMES[[kk]]
[11:02:57.452]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:57.452]                     next
[11:02:57.452]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:57.452]                 }
[11:02:57.452]                 NAMES <- toupper(added)
[11:02:57.452]                 for (kk in seq_along(NAMES)) {
[11:02:57.452]                   name <- added[[kk]]
[11:02:57.452]                   NAME <- NAMES[[kk]]
[11:02:57.452]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:57.452]                     next
[11:02:57.452]                   args[[name]] <- ""
[11:02:57.452]                 }
[11:02:57.452]                 NAMES <- toupper(removed)
[11:02:57.452]                 for (kk in seq_along(NAMES)) {
[11:02:57.452]                   name <- removed[[kk]]
[11:02:57.452]                   NAME <- NAMES[[kk]]
[11:02:57.452]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:57.452]                     next
[11:02:57.452]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:57.452]                 }
[11:02:57.452]                 if (length(args) > 0) 
[11:02:57.452]                   base::do.call(base::Sys.setenv, args = args)
[11:02:57.452]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:57.452]             }
[11:02:57.452]             else {
[11:02:57.452]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:57.452]             }
[11:02:57.452]             {
[11:02:57.452]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:57.452]                   0L) {
[11:02:57.452]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:57.452]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:57.452]                   base::options(opts)
[11:02:57.452]                 }
[11:02:57.452]                 {
[11:02:57.452]                   {
[11:02:57.452]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:57.452]                     NULL
[11:02:57.452]                   }
[11:02:57.452]                   options(future.plan = NULL)
[11:02:57.452]                   if (is.na(NA_character_)) 
[11:02:57.452]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:57.452]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:57.452]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:57.452]                     .init = FALSE)
[11:02:57.452]                 }
[11:02:57.452]             }
[11:02:57.452]         }
[11:02:57.452]     })
[11:02:57.452]     if (TRUE) {
[11:02:57.452]         base::sink(type = "output", split = FALSE)
[11:02:57.452]         if (TRUE) {
[11:02:57.452]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:57.452]         }
[11:02:57.452]         else {
[11:02:57.452]             ...future.result["stdout"] <- base::list(NULL)
[11:02:57.452]         }
[11:02:57.452]         base::close(...future.stdout)
[11:02:57.452]         ...future.stdout <- NULL
[11:02:57.452]     }
[11:02:57.452]     ...future.result$conditions <- ...future.conditions
[11:02:57.452]     ...future.result$finished <- base::Sys.time()
[11:02:57.452]     ...future.result
[11:02:57.452] }
[11:02:57.454] Poll #1 (0): usedNodes() = 2, workers = 2
[11:02:57.486] Poll #2 (0.03 secs): usedNodes() = 2, workers = 2
[11:02:57.517] Poll #3 (0.06 secs): usedNodes() = 2, workers = 2
[11:02:57.549] Poll #4 (0.09 secs): usedNodes() = 2, workers = 2
[11:02:57.560] receiveMessageFromWorker() for ClusterFuture ...
[11:02:57.560] - Validating connection of MultisessionFuture
[11:02:57.560] - received message: FutureResult
[11:02:57.560] - Received FutureResult
[11:02:57.560] - Erased future from FutureRegistry
[11:02:57.560] result() for ClusterFuture ...
[11:02:57.561] - result already collected: FutureResult
[11:02:57.561] result() for ClusterFuture ... done
[11:02:57.561] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:57.561] result() for ClusterFuture ...
[11:02:57.561] - result already collected: FutureResult
[11:02:57.561] result() for ClusterFuture ... done
[11:02:57.561] result() for ClusterFuture ...
[11:02:57.561] - result already collected: FutureResult
[11:02:57.561] result() for ClusterFuture ... done
[11:02:57.562] Exporting 1 global objects (344 bytes) to cluster node #1 ...
[11:02:57.562] Exporting ‘kk’ (35 bytes) to cluster node #1 ...
[11:02:57.562] Exporting ‘kk’ (35 bytes) to cluster node #1 ... DONE
[11:02:57.562] Exporting 1 global objects (344 bytes) to cluster node #1 ... DONE
[11:02:57.563] MultisessionFuture started
[11:02:57.563] - Launch lazy future ... done
[11:02:57.563] run() for ‘MultisessionFuture’ ... done
[11:02:57.563] resolve() on list ...
[11:02:57.563]  recursive: 0
[11:02:57.563]  length: 3
[11:02:57.564] 
[11:02:57.564] Future #1
[11:02:57.564]  length: 2 (resolved future 1)
[11:02:57.595] receiveMessageFromWorker() for ClusterFuture ...
[11:02:57.596] - Validating connection of MultisessionFuture
[11:02:57.596] - received message: FutureResult
[11:02:57.596] - Received FutureResult
[11:02:57.596] - Erased future from FutureRegistry
[11:02:57.596] result() for ClusterFuture ...
[11:02:57.596] - result already collected: FutureResult
[11:02:57.596] result() for ClusterFuture ... done
[11:02:57.596] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:57.596] Future #2
[11:02:57.597]  length: 1 (resolved future 2)
[11:02:57.705] receiveMessageFromWorker() for ClusterFuture ...
[11:02:57.705] - Validating connection of MultisessionFuture
[11:02:57.706] - received message: FutureResult
[11:02:57.706] - Received FutureResult
[11:02:57.706] - Erased future from FutureRegistry
[11:02:57.706] result() for ClusterFuture ...
[11:02:57.706] - result already collected: FutureResult
[11:02:57.706] result() for ClusterFuture ... done
[11:02:57.706] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:57.706] Future #3
[11:02:57.707]  length: 0 (resolved future 3)
[11:02:57.707] resolve() on list ... DONE
[11:02:57.707] getGlobalsAndPackages() ...
[11:02:57.707] Searching for globals...
[11:02:57.708] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[11:02:57.708] Searching for globals ... DONE
[11:02:57.708] Resolving globals: FALSE
[11:02:57.708] The total size of the 1 globals is 35 bytes (35 bytes)
[11:02:57.709] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[11:02:57.709] - globals: [1] ‘kk’
[11:02:57.709] 
[11:02:57.709] getGlobalsAndPackages() ... DONE
[11:02:57.709] getGlobalsAndPackages() ...
[11:02:57.709] Searching for globals...
[11:02:57.710] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[11:02:57.710] Searching for globals ... DONE
[11:02:57.711] Resolving globals: FALSE
[11:02:57.711] The total size of the 1 globals is 35 bytes (35 bytes)
[11:02:57.711] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[11:02:57.711] - globals: [1] ‘kk’
[11:02:57.711] 
[11:02:57.711] getGlobalsAndPackages() ... DONE
[11:02:57.712] getGlobalsAndPackages() ...
[11:02:57.712] Searching for globals...
[11:02:57.713] - globals found: [3] ‘{’, ‘Sys.sleep’, ‘kk’
[11:02:57.713] Searching for globals ... DONE
[11:02:57.713] Resolving globals: FALSE
[11:02:57.713] The total size of the 1 globals is 35 bytes (35 bytes)
[11:02:57.713] The total size of the 1 globals exported for future expression (‘{; Sys.sleep(0.1); kk; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘kk’ (35 bytes of class ‘numeric’)
[11:02:57.714] - globals: [1] ‘kk’
[11:02:57.714] 
[11:02:57.714] getGlobalsAndPackages() ... DONE
[11:02:57.714] resolve() on list ...
[11:02:57.714]  recursive: 0
[11:02:57.714]  length: 3
[11:02:57.714] 
[11:02:57.714] run() for ‘Future’ ...
[11:02:57.714] - state: ‘created’
[11:02:57.715] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:57.728] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:57.728] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:57.728]   - Field: ‘node’
[11:02:57.729]   - Field: ‘label’
[11:02:57.729]   - Field: ‘local’
[11:02:57.729]   - Field: ‘owner’
[11:02:57.729]   - Field: ‘envir’
[11:02:57.729]   - Field: ‘workers’
[11:02:57.729]   - Field: ‘packages’
[11:02:57.729]   - Field: ‘gc’
[11:02:57.729]   - Field: ‘conditions’
[11:02:57.729]   - Field: ‘persistent’
[11:02:57.729]   - Field: ‘expr’
[11:02:57.730]   - Field: ‘uuid’
[11:02:57.730]   - Field: ‘seed’
[11:02:57.730]   - Field: ‘version’
[11:02:57.730]   - Field: ‘result’
[11:02:57.730]   - Field: ‘asynchronous’
[11:02:57.730]   - Field: ‘calls’
[11:02:57.730]   - Field: ‘globals’
[11:02:57.730]   - Field: ‘stdout’
[11:02:57.730]   - Field: ‘earlySignal’
[11:02:57.730]   - Field: ‘lazy’
[11:02:57.730]   - Field: ‘state’
[11:02:57.730] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:57.731] - Launch lazy future ...
[11:02:57.731] Packages needed by the future expression (n = 0): <none>
[11:02:57.731] Packages needed by future strategies (n = 0): <none>
[11:02:57.731] {
[11:02:57.731]     {
[11:02:57.731]         {
[11:02:57.731]             ...future.startTime <- base::Sys.time()
[11:02:57.731]             {
[11:02:57.731]                 {
[11:02:57.731]                   {
[11:02:57.731]                     {
[11:02:57.731]                       base::local({
[11:02:57.731]                         has_future <- base::requireNamespace("future", 
[11:02:57.731]                           quietly = TRUE)
[11:02:57.731]                         if (has_future) {
[11:02:57.731]                           ns <- base::getNamespace("future")
[11:02:57.731]                           version <- ns[[".package"]][["version"]]
[11:02:57.731]                           if (is.null(version)) 
[11:02:57.731]                             version <- utils::packageVersion("future")
[11:02:57.731]                         }
[11:02:57.731]                         else {
[11:02:57.731]                           version <- NULL
[11:02:57.731]                         }
[11:02:57.731]                         if (!has_future || version < "1.8.0") {
[11:02:57.731]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:57.731]                             "", base::R.version$version.string), 
[11:02:57.731]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:57.731]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:57.731]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:57.731]                               "release", "version")], collapse = " "), 
[11:02:57.731]                             hostname = base::Sys.info()[["nodename"]])
[11:02:57.731]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:57.731]                             info)
[11:02:57.731]                           info <- base::paste(info, collapse = "; ")
[11:02:57.731]                           if (!has_future) {
[11:02:57.731]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:57.731]                               info)
[11:02:57.731]                           }
[11:02:57.731]                           else {
[11:02:57.731]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:57.731]                               info, version)
[11:02:57.731]                           }
[11:02:57.731]                           base::stop(msg)
[11:02:57.731]                         }
[11:02:57.731]                       })
[11:02:57.731]                     }
[11:02:57.731]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:57.731]                     base::options(mc.cores = 1L)
[11:02:57.731]                   }
[11:02:57.731]                   ...future.strategy.old <- future::plan("list")
[11:02:57.731]                   options(future.plan = NULL)
[11:02:57.731]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:57.731]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:57.731]                 }
[11:02:57.731]                 ...future.workdir <- getwd()
[11:02:57.731]             }
[11:02:57.731]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:57.731]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:57.731]         }
[11:02:57.731]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:57.731]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:57.731]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:57.731]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:57.731]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:57.731]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:57.731]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:57.731]             base::names(...future.oldOptions))
[11:02:57.731]     }
[11:02:57.731]     if (FALSE) {
[11:02:57.731]     }
[11:02:57.731]     else {
[11:02:57.731]         if (TRUE) {
[11:02:57.731]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:57.731]                 open = "w")
[11:02:57.731]         }
[11:02:57.731]         else {
[11:02:57.731]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:57.731]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:57.731]         }
[11:02:57.731]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:57.731]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:57.731]             base::sink(type = "output", split = FALSE)
[11:02:57.731]             base::close(...future.stdout)
[11:02:57.731]         }, add = TRUE)
[11:02:57.731]     }
[11:02:57.731]     ...future.frame <- base::sys.nframe()
[11:02:57.731]     ...future.conditions <- base::list()
[11:02:57.731]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:57.731]     if (FALSE) {
[11:02:57.731]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:57.731]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:57.731]     }
[11:02:57.731]     ...future.result <- base::tryCatch({
[11:02:57.731]         base::withCallingHandlers({
[11:02:57.731]             ...future.value <- base::withVisible(base::local({
[11:02:57.731]                 ...future.makeSendCondition <- base::local({
[11:02:57.731]                   sendCondition <- NULL
[11:02:57.731]                   function(frame = 1L) {
[11:02:57.731]                     if (is.function(sendCondition)) 
[11:02:57.731]                       return(sendCondition)
[11:02:57.731]                     ns <- getNamespace("parallel")
[11:02:57.731]                     if (exists("sendData", mode = "function", 
[11:02:57.731]                       envir = ns)) {
[11:02:57.731]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:57.731]                         envir = ns)
[11:02:57.731]                       envir <- sys.frame(frame)
[11:02:57.731]                       master <- NULL
[11:02:57.731]                       while (!identical(envir, .GlobalEnv) && 
[11:02:57.731]                         !identical(envir, emptyenv())) {
[11:02:57.731]                         if (exists("master", mode = "list", envir = envir, 
[11:02:57.731]                           inherits = FALSE)) {
[11:02:57.731]                           master <- get("master", mode = "list", 
[11:02:57.731]                             envir = envir, inherits = FALSE)
[11:02:57.731]                           if (inherits(master, c("SOCKnode", 
[11:02:57.731]                             "SOCK0node"))) {
[11:02:57.731]                             sendCondition <<- function(cond) {
[11:02:57.731]                               data <- list(type = "VALUE", value = cond, 
[11:02:57.731]                                 success = TRUE)
[11:02:57.731]                               parallel_sendData(master, data)
[11:02:57.731]                             }
[11:02:57.731]                             return(sendCondition)
[11:02:57.731]                           }
[11:02:57.731]                         }
[11:02:57.731]                         frame <- frame + 1L
[11:02:57.731]                         envir <- sys.frame(frame)
[11:02:57.731]                       }
[11:02:57.731]                     }
[11:02:57.731]                     sendCondition <<- function(cond) NULL
[11:02:57.731]                   }
[11:02:57.731]                 })
[11:02:57.731]                 withCallingHandlers({
[11:02:57.731]                   {
[11:02:57.731]                     Sys.sleep(0.1)
[11:02:57.731]                     kk
[11:02:57.731]                   }
[11:02:57.731]                 }, immediateCondition = function(cond) {
[11:02:57.731]                   sendCondition <- ...future.makeSendCondition()
[11:02:57.731]                   sendCondition(cond)
[11:02:57.731]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:57.731]                   {
[11:02:57.731]                     inherits <- base::inherits
[11:02:57.731]                     invokeRestart <- base::invokeRestart
[11:02:57.731]                     is.null <- base::is.null
[11:02:57.731]                     muffled <- FALSE
[11:02:57.731]                     if (inherits(cond, "message")) {
[11:02:57.731]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:57.731]                       if (muffled) 
[11:02:57.731]                         invokeRestart("muffleMessage")
[11:02:57.731]                     }
[11:02:57.731]                     else if (inherits(cond, "warning")) {
[11:02:57.731]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:57.731]                       if (muffled) 
[11:02:57.731]                         invokeRestart("muffleWarning")
[11:02:57.731]                     }
[11:02:57.731]                     else if (inherits(cond, "condition")) {
[11:02:57.731]                       if (!is.null(pattern)) {
[11:02:57.731]                         computeRestarts <- base::computeRestarts
[11:02:57.731]                         grepl <- base::grepl
[11:02:57.731]                         restarts <- computeRestarts(cond)
[11:02:57.731]                         for (restart in restarts) {
[11:02:57.731]                           name <- restart$name
[11:02:57.731]                           if (is.null(name)) 
[11:02:57.731]                             next
[11:02:57.731]                           if (!grepl(pattern, name)) 
[11:02:57.731]                             next
[11:02:57.731]                           invokeRestart(restart)
[11:02:57.731]                           muffled <- TRUE
[11:02:57.731]                           break
[11:02:57.731]                         }
[11:02:57.731]                       }
[11:02:57.731]                     }
[11:02:57.731]                     invisible(muffled)
[11:02:57.731]                   }
[11:02:57.731]                   muffleCondition(cond)
[11:02:57.731]                 })
[11:02:57.731]             }))
[11:02:57.731]             future::FutureResult(value = ...future.value$value, 
[11:02:57.731]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:57.731]                   ...future.rng), globalenv = if (FALSE) 
[11:02:57.731]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:57.731]                     ...future.globalenv.names))
[11:02:57.731]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:57.731]         }, condition = base::local({
[11:02:57.731]             c <- base::c
[11:02:57.731]             inherits <- base::inherits
[11:02:57.731]             invokeRestart <- base::invokeRestart
[11:02:57.731]             length <- base::length
[11:02:57.731]             list <- base::list
[11:02:57.731]             seq.int <- base::seq.int
[11:02:57.731]             signalCondition <- base::signalCondition
[11:02:57.731]             sys.calls <- base::sys.calls
[11:02:57.731]             `[[` <- base::`[[`
[11:02:57.731]             `+` <- base::`+`
[11:02:57.731]             `<<-` <- base::`<<-`
[11:02:57.731]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:57.731]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:57.731]                   3L)]
[11:02:57.731]             }
[11:02:57.731]             function(cond) {
[11:02:57.731]                 is_error <- inherits(cond, "error")
[11:02:57.731]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:57.731]                   NULL)
[11:02:57.731]                 if (is_error) {
[11:02:57.731]                   sessionInformation <- function() {
[11:02:57.731]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:57.731]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:57.731]                       search = base::search(), system = base::Sys.info())
[11:02:57.731]                   }
[11:02:57.731]                   ...future.conditions[[length(...future.conditions) + 
[11:02:57.731]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:57.731]                     cond$call), session = sessionInformation(), 
[11:02:57.731]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:57.731]                   signalCondition(cond)
[11:02:57.731]                 }
[11:02:57.731]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:57.731]                 "immediateCondition"))) {
[11:02:57.731]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:57.731]                   ...future.conditions[[length(...future.conditions) + 
[11:02:57.731]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:57.731]                   if (TRUE && !signal) {
[11:02:57.731]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:57.731]                     {
[11:02:57.731]                       inherits <- base::inherits
[11:02:57.731]                       invokeRestart <- base::invokeRestart
[11:02:57.731]                       is.null <- base::is.null
[11:02:57.731]                       muffled <- FALSE
[11:02:57.731]                       if (inherits(cond, "message")) {
[11:02:57.731]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:57.731]                         if (muffled) 
[11:02:57.731]                           invokeRestart("muffleMessage")
[11:02:57.731]                       }
[11:02:57.731]                       else if (inherits(cond, "warning")) {
[11:02:57.731]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:57.731]                         if (muffled) 
[11:02:57.731]                           invokeRestart("muffleWarning")
[11:02:57.731]                       }
[11:02:57.731]                       else if (inherits(cond, "condition")) {
[11:02:57.731]                         if (!is.null(pattern)) {
[11:02:57.731]                           computeRestarts <- base::computeRestarts
[11:02:57.731]                           grepl <- base::grepl
[11:02:57.731]                           restarts <- computeRestarts(cond)
[11:02:57.731]                           for (restart in restarts) {
[11:02:57.731]                             name <- restart$name
[11:02:57.731]                             if (is.null(name)) 
[11:02:57.731]                               next
[11:02:57.731]                             if (!grepl(pattern, name)) 
[11:02:57.731]                               next
[11:02:57.731]                             invokeRestart(restart)
[11:02:57.731]                             muffled <- TRUE
[11:02:57.731]                             break
[11:02:57.731]                           }
[11:02:57.731]                         }
[11:02:57.731]                       }
[11:02:57.731]                       invisible(muffled)
[11:02:57.731]                     }
[11:02:57.731]                     muffleCondition(cond, pattern = "^muffle")
[11:02:57.731]                   }
[11:02:57.731]                 }
[11:02:57.731]                 else {
[11:02:57.731]                   if (TRUE) {
[11:02:57.731]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:57.731]                     {
[11:02:57.731]                       inherits <- base::inherits
[11:02:57.731]                       invokeRestart <- base::invokeRestart
[11:02:57.731]                       is.null <- base::is.null
[11:02:57.731]                       muffled <- FALSE
[11:02:57.731]                       if (inherits(cond, "message")) {
[11:02:57.731]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:57.731]                         if (muffled) 
[11:02:57.731]                           invokeRestart("muffleMessage")
[11:02:57.731]                       }
[11:02:57.731]                       else if (inherits(cond, "warning")) {
[11:02:57.731]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:57.731]                         if (muffled) 
[11:02:57.731]                           invokeRestart("muffleWarning")
[11:02:57.731]                       }
[11:02:57.731]                       else if (inherits(cond, "condition")) {
[11:02:57.731]                         if (!is.null(pattern)) {
[11:02:57.731]                           computeRestarts <- base::computeRestarts
[11:02:57.731]                           grepl <- base::grepl
[11:02:57.731]                           restarts <- computeRestarts(cond)
[11:02:57.731]                           for (restart in restarts) {
[11:02:57.731]                             name <- restart$name
[11:02:57.731]                             if (is.null(name)) 
[11:02:57.731]                               next
[11:02:57.731]                             if (!grepl(pattern, name)) 
[11:02:57.731]                               next
[11:02:57.731]                             invokeRestart(restart)
[11:02:57.731]                             muffled <- TRUE
[11:02:57.731]                             break
[11:02:57.731]                           }
[11:02:57.731]                         }
[11:02:57.731]                       }
[11:02:57.731]                       invisible(muffled)
[11:02:57.731]                     }
[11:02:57.731]                     muffleCondition(cond, pattern = "^muffle")
[11:02:57.731]                   }
[11:02:57.731]                 }
[11:02:57.731]             }
[11:02:57.731]         }))
[11:02:57.731]     }, error = function(ex) {
[11:02:57.731]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:57.731]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:57.731]                 ...future.rng), started = ...future.startTime, 
[11:02:57.731]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:57.731]             version = "1.8"), class = "FutureResult")
[11:02:57.731]     }, finally = {
[11:02:57.731]         if (!identical(...future.workdir, getwd())) 
[11:02:57.731]             setwd(...future.workdir)
[11:02:57.731]         {
[11:02:57.731]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:57.731]                 ...future.oldOptions$nwarnings <- NULL
[11:02:57.731]             }
[11:02:57.731]             base::options(...future.oldOptions)
[11:02:57.731]             if (.Platform$OS.type == "windows") {
[11:02:57.731]                 old_names <- names(...future.oldEnvVars)
[11:02:57.731]                 envs <- base::Sys.getenv()
[11:02:57.731]                 names <- names(envs)
[11:02:57.731]                 common <- intersect(names, old_names)
[11:02:57.731]                 added <- setdiff(names, old_names)
[11:02:57.731]                 removed <- setdiff(old_names, names)
[11:02:57.731]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:57.731]                   envs[common]]
[11:02:57.731]                 NAMES <- toupper(changed)
[11:02:57.731]                 args <- list()
[11:02:57.731]                 for (kk in seq_along(NAMES)) {
[11:02:57.731]                   name <- changed[[kk]]
[11:02:57.731]                   NAME <- NAMES[[kk]]
[11:02:57.731]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:57.731]                     next
[11:02:57.731]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:57.731]                 }
[11:02:57.731]                 NAMES <- toupper(added)
[11:02:57.731]                 for (kk in seq_along(NAMES)) {
[11:02:57.731]                   name <- added[[kk]]
[11:02:57.731]                   NAME <- NAMES[[kk]]
[11:02:57.731]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:57.731]                     next
[11:02:57.731]                   args[[name]] <- ""
[11:02:57.731]                 }
[11:02:57.731]                 NAMES <- toupper(removed)
[11:02:57.731]                 for (kk in seq_along(NAMES)) {
[11:02:57.731]                   name <- removed[[kk]]
[11:02:57.731]                   NAME <- NAMES[[kk]]
[11:02:57.731]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:57.731]                     next
[11:02:57.731]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:57.731]                 }
[11:02:57.731]                 if (length(args) > 0) 
[11:02:57.731]                   base::do.call(base::Sys.setenv, args = args)
[11:02:57.731]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:57.731]             }
[11:02:57.731]             else {
[11:02:57.731]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:57.731]             }
[11:02:57.731]             {
[11:02:57.731]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:57.731]                   0L) {
[11:02:57.731]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:57.731]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:57.731]                   base::options(opts)
[11:02:57.731]                 }
[11:02:57.731]                 {
[11:02:57.731]                   {
[11:02:57.731]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:57.731]                     NULL
[11:02:57.731]                   }
[11:02:57.731]                   options(future.plan = NULL)
[11:02:57.731]                   if (is.na(NA_character_)) 
[11:02:57.731]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:57.731]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:57.731]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:57.731]                     .init = FALSE)
[11:02:57.731]                 }
[11:02:57.731]             }
[11:02:57.731]         }
[11:02:57.731]     })
[11:02:57.731]     if (TRUE) {
[11:02:57.731]         base::sink(type = "output", split = FALSE)
[11:02:57.731]         if (TRUE) {
[11:02:57.731]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:57.731]         }
[11:02:57.731]         else {
[11:02:57.731]             ...future.result["stdout"] <- base::list(NULL)
[11:02:57.731]         }
[11:02:57.731]         base::close(...future.stdout)
[11:02:57.731]         ...future.stdout <- NULL
[11:02:57.731]     }
[11:02:57.731]     ...future.result$conditions <- ...future.conditions
[11:02:57.731]     ...future.result$finished <- base::Sys.time()
[11:02:57.731]     ...future.result
[11:02:57.731] }
[11:02:57.734] Exporting 1 global objects (344 bytes) to cluster node #1 ...
[11:02:57.734] Exporting ‘kk’ (35 bytes) to cluster node #1 ...
[11:02:57.735] Exporting ‘kk’ (35 bytes) to cluster node #1 ... DONE
[11:02:57.735] Exporting 1 global objects (344 bytes) to cluster node #1 ... DONE
[11:02:57.735] MultisessionFuture started
[11:02:57.735] - Launch lazy future ... done
[11:02:57.735] run() for ‘MultisessionFuture’ ... done
[11:02:57.746] run() for ‘Future’ ...
[11:02:57.746] - state: ‘created’
[11:02:57.746] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:57.760] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:57.760] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:57.760]   - Field: ‘node’
[11:02:57.760]   - Field: ‘label’
[11:02:57.760]   - Field: ‘local’
[11:02:57.760]   - Field: ‘owner’
[11:02:57.761]   - Field: ‘envir’
[11:02:57.761]   - Field: ‘workers’
[11:02:57.761]   - Field: ‘packages’
[11:02:57.761]   - Field: ‘gc’
[11:02:57.761]   - Field: ‘conditions’
[11:02:57.761]   - Field: ‘persistent’
[11:02:57.761]   - Field: ‘expr’
[11:02:57.761]   - Field: ‘uuid’
[11:02:57.761]   - Field: ‘seed’
[11:02:57.761]   - Field: ‘version’
[11:02:57.761]   - Field: ‘result’
[11:02:57.761]   - Field: ‘asynchronous’
[11:02:57.762]   - Field: ‘calls’
[11:02:57.762]   - Field: ‘globals’
[11:02:57.762]   - Field: ‘stdout’
[11:02:57.762]   - Field: ‘earlySignal’
[11:02:57.762]   - Field: ‘lazy’
[11:02:57.762]   - Field: ‘state’
[11:02:57.762] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:57.762] - Launch lazy future ...
[11:02:57.762] Packages needed by the future expression (n = 0): <none>
[11:02:57.762] Packages needed by future strategies (n = 0): <none>
[11:02:57.763] {
[11:02:57.763]     {
[11:02:57.763]         {
[11:02:57.763]             ...future.startTime <- base::Sys.time()
[11:02:57.763]             {
[11:02:57.763]                 {
[11:02:57.763]                   {
[11:02:57.763]                     {
[11:02:57.763]                       base::local({
[11:02:57.763]                         has_future <- base::requireNamespace("future", 
[11:02:57.763]                           quietly = TRUE)
[11:02:57.763]                         if (has_future) {
[11:02:57.763]                           ns <- base::getNamespace("future")
[11:02:57.763]                           version <- ns[[".package"]][["version"]]
[11:02:57.763]                           if (is.null(version)) 
[11:02:57.763]                             version <- utils::packageVersion("future")
[11:02:57.763]                         }
[11:02:57.763]                         else {
[11:02:57.763]                           version <- NULL
[11:02:57.763]                         }
[11:02:57.763]                         if (!has_future || version < "1.8.0") {
[11:02:57.763]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:57.763]                             "", base::R.version$version.string), 
[11:02:57.763]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:57.763]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:57.763]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:57.763]                               "release", "version")], collapse = " "), 
[11:02:57.763]                             hostname = base::Sys.info()[["nodename"]])
[11:02:57.763]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:57.763]                             info)
[11:02:57.763]                           info <- base::paste(info, collapse = "; ")
[11:02:57.763]                           if (!has_future) {
[11:02:57.763]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:57.763]                               info)
[11:02:57.763]                           }
[11:02:57.763]                           else {
[11:02:57.763]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:57.763]                               info, version)
[11:02:57.763]                           }
[11:02:57.763]                           base::stop(msg)
[11:02:57.763]                         }
[11:02:57.763]                       })
[11:02:57.763]                     }
[11:02:57.763]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:57.763]                     base::options(mc.cores = 1L)
[11:02:57.763]                   }
[11:02:57.763]                   ...future.strategy.old <- future::plan("list")
[11:02:57.763]                   options(future.plan = NULL)
[11:02:57.763]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:57.763]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:57.763]                 }
[11:02:57.763]                 ...future.workdir <- getwd()
[11:02:57.763]             }
[11:02:57.763]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:57.763]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:57.763]         }
[11:02:57.763]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:57.763]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:57.763]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:57.763]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:57.763]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:57.763]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:57.763]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:57.763]             base::names(...future.oldOptions))
[11:02:57.763]     }
[11:02:57.763]     if (FALSE) {
[11:02:57.763]     }
[11:02:57.763]     else {
[11:02:57.763]         if (TRUE) {
[11:02:57.763]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:57.763]                 open = "w")
[11:02:57.763]         }
[11:02:57.763]         else {
[11:02:57.763]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:57.763]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:57.763]         }
[11:02:57.763]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:57.763]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:57.763]             base::sink(type = "output", split = FALSE)
[11:02:57.763]             base::close(...future.stdout)
[11:02:57.763]         }, add = TRUE)
[11:02:57.763]     }
[11:02:57.763]     ...future.frame <- base::sys.nframe()
[11:02:57.763]     ...future.conditions <- base::list()
[11:02:57.763]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:57.763]     if (FALSE) {
[11:02:57.763]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:57.763]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:57.763]     }
[11:02:57.763]     ...future.result <- base::tryCatch({
[11:02:57.763]         base::withCallingHandlers({
[11:02:57.763]             ...future.value <- base::withVisible(base::local({
[11:02:57.763]                 ...future.makeSendCondition <- base::local({
[11:02:57.763]                   sendCondition <- NULL
[11:02:57.763]                   function(frame = 1L) {
[11:02:57.763]                     if (is.function(sendCondition)) 
[11:02:57.763]                       return(sendCondition)
[11:02:57.763]                     ns <- getNamespace("parallel")
[11:02:57.763]                     if (exists("sendData", mode = "function", 
[11:02:57.763]                       envir = ns)) {
[11:02:57.763]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:57.763]                         envir = ns)
[11:02:57.763]                       envir <- sys.frame(frame)
[11:02:57.763]                       master <- NULL
[11:02:57.763]                       while (!identical(envir, .GlobalEnv) && 
[11:02:57.763]                         !identical(envir, emptyenv())) {
[11:02:57.763]                         if (exists("master", mode = "list", envir = envir, 
[11:02:57.763]                           inherits = FALSE)) {
[11:02:57.763]                           master <- get("master", mode = "list", 
[11:02:57.763]                             envir = envir, inherits = FALSE)
[11:02:57.763]                           if (inherits(master, c("SOCKnode", 
[11:02:57.763]                             "SOCK0node"))) {
[11:02:57.763]                             sendCondition <<- function(cond) {
[11:02:57.763]                               data <- list(type = "VALUE", value = cond, 
[11:02:57.763]                                 success = TRUE)
[11:02:57.763]                               parallel_sendData(master, data)
[11:02:57.763]                             }
[11:02:57.763]                             return(sendCondition)
[11:02:57.763]                           }
[11:02:57.763]                         }
[11:02:57.763]                         frame <- frame + 1L
[11:02:57.763]                         envir <- sys.frame(frame)
[11:02:57.763]                       }
[11:02:57.763]                     }
[11:02:57.763]                     sendCondition <<- function(cond) NULL
[11:02:57.763]                   }
[11:02:57.763]                 })
[11:02:57.763]                 withCallingHandlers({
[11:02:57.763]                   {
[11:02:57.763]                     Sys.sleep(0.1)
[11:02:57.763]                     kk
[11:02:57.763]                   }
[11:02:57.763]                 }, immediateCondition = function(cond) {
[11:02:57.763]                   sendCondition <- ...future.makeSendCondition()
[11:02:57.763]                   sendCondition(cond)
[11:02:57.763]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:57.763]                   {
[11:02:57.763]                     inherits <- base::inherits
[11:02:57.763]                     invokeRestart <- base::invokeRestart
[11:02:57.763]                     is.null <- base::is.null
[11:02:57.763]                     muffled <- FALSE
[11:02:57.763]                     if (inherits(cond, "message")) {
[11:02:57.763]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:57.763]                       if (muffled) 
[11:02:57.763]                         invokeRestart("muffleMessage")
[11:02:57.763]                     }
[11:02:57.763]                     else if (inherits(cond, "warning")) {
[11:02:57.763]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:57.763]                       if (muffled) 
[11:02:57.763]                         invokeRestart("muffleWarning")
[11:02:57.763]                     }
[11:02:57.763]                     else if (inherits(cond, "condition")) {
[11:02:57.763]                       if (!is.null(pattern)) {
[11:02:57.763]                         computeRestarts <- base::computeRestarts
[11:02:57.763]                         grepl <- base::grepl
[11:02:57.763]                         restarts <- computeRestarts(cond)
[11:02:57.763]                         for (restart in restarts) {
[11:02:57.763]                           name <- restart$name
[11:02:57.763]                           if (is.null(name)) 
[11:02:57.763]                             next
[11:02:57.763]                           if (!grepl(pattern, name)) 
[11:02:57.763]                             next
[11:02:57.763]                           invokeRestart(restart)
[11:02:57.763]                           muffled <- TRUE
[11:02:57.763]                           break
[11:02:57.763]                         }
[11:02:57.763]                       }
[11:02:57.763]                     }
[11:02:57.763]                     invisible(muffled)
[11:02:57.763]                   }
[11:02:57.763]                   muffleCondition(cond)
[11:02:57.763]                 })
[11:02:57.763]             }))
[11:02:57.763]             future::FutureResult(value = ...future.value$value, 
[11:02:57.763]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:57.763]                   ...future.rng), globalenv = if (FALSE) 
[11:02:57.763]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:57.763]                     ...future.globalenv.names))
[11:02:57.763]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:57.763]         }, condition = base::local({
[11:02:57.763]             c <- base::c
[11:02:57.763]             inherits <- base::inherits
[11:02:57.763]             invokeRestart <- base::invokeRestart
[11:02:57.763]             length <- base::length
[11:02:57.763]             list <- base::list
[11:02:57.763]             seq.int <- base::seq.int
[11:02:57.763]             signalCondition <- base::signalCondition
[11:02:57.763]             sys.calls <- base::sys.calls
[11:02:57.763]             `[[` <- base::`[[`
[11:02:57.763]             `+` <- base::`+`
[11:02:57.763]             `<<-` <- base::`<<-`
[11:02:57.763]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:57.763]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:57.763]                   3L)]
[11:02:57.763]             }
[11:02:57.763]             function(cond) {
[11:02:57.763]                 is_error <- inherits(cond, "error")
[11:02:57.763]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:57.763]                   NULL)
[11:02:57.763]                 if (is_error) {
[11:02:57.763]                   sessionInformation <- function() {
[11:02:57.763]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:57.763]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:57.763]                       search = base::search(), system = base::Sys.info())
[11:02:57.763]                   }
[11:02:57.763]                   ...future.conditions[[length(...future.conditions) + 
[11:02:57.763]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:57.763]                     cond$call), session = sessionInformation(), 
[11:02:57.763]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:57.763]                   signalCondition(cond)
[11:02:57.763]                 }
[11:02:57.763]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:57.763]                 "immediateCondition"))) {
[11:02:57.763]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:57.763]                   ...future.conditions[[length(...future.conditions) + 
[11:02:57.763]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:57.763]                   if (TRUE && !signal) {
[11:02:57.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:57.763]                     {
[11:02:57.763]                       inherits <- base::inherits
[11:02:57.763]                       invokeRestart <- base::invokeRestart
[11:02:57.763]                       is.null <- base::is.null
[11:02:57.763]                       muffled <- FALSE
[11:02:57.763]                       if (inherits(cond, "message")) {
[11:02:57.763]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:57.763]                         if (muffled) 
[11:02:57.763]                           invokeRestart("muffleMessage")
[11:02:57.763]                       }
[11:02:57.763]                       else if (inherits(cond, "warning")) {
[11:02:57.763]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:57.763]                         if (muffled) 
[11:02:57.763]                           invokeRestart("muffleWarning")
[11:02:57.763]                       }
[11:02:57.763]                       else if (inherits(cond, "condition")) {
[11:02:57.763]                         if (!is.null(pattern)) {
[11:02:57.763]                           computeRestarts <- base::computeRestarts
[11:02:57.763]                           grepl <- base::grepl
[11:02:57.763]                           restarts <- computeRestarts(cond)
[11:02:57.763]                           for (restart in restarts) {
[11:02:57.763]                             name <- restart$name
[11:02:57.763]                             if (is.null(name)) 
[11:02:57.763]                               next
[11:02:57.763]                             if (!grepl(pattern, name)) 
[11:02:57.763]                               next
[11:02:57.763]                             invokeRestart(restart)
[11:02:57.763]                             muffled <- TRUE
[11:02:57.763]                             break
[11:02:57.763]                           }
[11:02:57.763]                         }
[11:02:57.763]                       }
[11:02:57.763]                       invisible(muffled)
[11:02:57.763]                     }
[11:02:57.763]                     muffleCondition(cond, pattern = "^muffle")
[11:02:57.763]                   }
[11:02:57.763]                 }
[11:02:57.763]                 else {
[11:02:57.763]                   if (TRUE) {
[11:02:57.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:57.763]                     {
[11:02:57.763]                       inherits <- base::inherits
[11:02:57.763]                       invokeRestart <- base::invokeRestart
[11:02:57.763]                       is.null <- base::is.null
[11:02:57.763]                       muffled <- FALSE
[11:02:57.763]                       if (inherits(cond, "message")) {
[11:02:57.763]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:57.763]                         if (muffled) 
[11:02:57.763]                           invokeRestart("muffleMessage")
[11:02:57.763]                       }
[11:02:57.763]                       else if (inherits(cond, "warning")) {
[11:02:57.763]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:57.763]                         if (muffled) 
[11:02:57.763]                           invokeRestart("muffleWarning")
[11:02:57.763]                       }
[11:02:57.763]                       else if (inherits(cond, "condition")) {
[11:02:57.763]                         if (!is.null(pattern)) {
[11:02:57.763]                           computeRestarts <- base::computeRestarts
[11:02:57.763]                           grepl <- base::grepl
[11:02:57.763]                           restarts <- computeRestarts(cond)
[11:02:57.763]                           for (restart in restarts) {
[11:02:57.763]                             name <- restart$name
[11:02:57.763]                             if (is.null(name)) 
[11:02:57.763]                               next
[11:02:57.763]                             if (!grepl(pattern, name)) 
[11:02:57.763]                               next
[11:02:57.763]                             invokeRestart(restart)
[11:02:57.763]                             muffled <- TRUE
[11:02:57.763]                             break
[11:02:57.763]                           }
[11:02:57.763]                         }
[11:02:57.763]                       }
[11:02:57.763]                       invisible(muffled)
[11:02:57.763]                     }
[11:02:57.763]                     muffleCondition(cond, pattern = "^muffle")
[11:02:57.763]                   }
[11:02:57.763]                 }
[11:02:57.763]             }
[11:02:57.763]         }))
[11:02:57.763]     }, error = function(ex) {
[11:02:57.763]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:57.763]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:57.763]                 ...future.rng), started = ...future.startTime, 
[11:02:57.763]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:57.763]             version = "1.8"), class = "FutureResult")
[11:02:57.763]     }, finally = {
[11:02:57.763]         if (!identical(...future.workdir, getwd())) 
[11:02:57.763]             setwd(...future.workdir)
[11:02:57.763]         {
[11:02:57.763]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:57.763]                 ...future.oldOptions$nwarnings <- NULL
[11:02:57.763]             }
[11:02:57.763]             base::options(...future.oldOptions)
[11:02:57.763]             if (.Platform$OS.type == "windows") {
[11:02:57.763]                 old_names <- names(...future.oldEnvVars)
[11:02:57.763]                 envs <- base::Sys.getenv()
[11:02:57.763]                 names <- names(envs)
[11:02:57.763]                 common <- intersect(names, old_names)
[11:02:57.763]                 added <- setdiff(names, old_names)
[11:02:57.763]                 removed <- setdiff(old_names, names)
[11:02:57.763]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:57.763]                   envs[common]]
[11:02:57.763]                 NAMES <- toupper(changed)
[11:02:57.763]                 args <- list()
[11:02:57.763]                 for (kk in seq_along(NAMES)) {
[11:02:57.763]                   name <- changed[[kk]]
[11:02:57.763]                   NAME <- NAMES[[kk]]
[11:02:57.763]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:57.763]                     next
[11:02:57.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:57.763]                 }
[11:02:57.763]                 NAMES <- toupper(added)
[11:02:57.763]                 for (kk in seq_along(NAMES)) {
[11:02:57.763]                   name <- added[[kk]]
[11:02:57.763]                   NAME <- NAMES[[kk]]
[11:02:57.763]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:57.763]                     next
[11:02:57.763]                   args[[name]] <- ""
[11:02:57.763]                 }
[11:02:57.763]                 NAMES <- toupper(removed)
[11:02:57.763]                 for (kk in seq_along(NAMES)) {
[11:02:57.763]                   name <- removed[[kk]]
[11:02:57.763]                   NAME <- NAMES[[kk]]
[11:02:57.763]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:57.763]                     next
[11:02:57.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:57.763]                 }
[11:02:57.763]                 if (length(args) > 0) 
[11:02:57.763]                   base::do.call(base::Sys.setenv, args = args)
[11:02:57.763]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:57.763]             }
[11:02:57.763]             else {
[11:02:57.763]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:57.763]             }
[11:02:57.763]             {
[11:02:57.763]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:57.763]                   0L) {
[11:02:57.763]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:57.763]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:57.763]                   base::options(opts)
[11:02:57.763]                 }
[11:02:57.763]                 {
[11:02:57.763]                   {
[11:02:57.763]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:57.763]                     NULL
[11:02:57.763]                   }
[11:02:57.763]                   options(future.plan = NULL)
[11:02:57.763]                   if (is.na(NA_character_)) 
[11:02:57.763]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:57.763]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:57.763]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:57.763]                     .init = FALSE)
[11:02:57.763]                 }
[11:02:57.763]             }
[11:02:57.763]         }
[11:02:57.763]     })
[11:02:57.763]     if (TRUE) {
[11:02:57.763]         base::sink(type = "output", split = FALSE)
[11:02:57.763]         if (TRUE) {
[11:02:57.763]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:57.763]         }
[11:02:57.763]         else {
[11:02:57.763]             ...future.result["stdout"] <- base::list(NULL)
[11:02:57.763]         }
[11:02:57.763]         base::close(...future.stdout)
[11:02:57.763]         ...future.stdout <- NULL
[11:02:57.763]     }
[11:02:57.763]     ...future.result$conditions <- ...future.conditions
[11:02:57.763]     ...future.result$finished <- base::Sys.time()
[11:02:57.763]     ...future.result
[11:02:57.763] }
[11:02:57.766] Exporting 1 global objects (344 bytes) to cluster node #2 ...
[11:02:57.766] Exporting ‘kk’ (35 bytes) to cluster node #2 ...
[11:02:57.766] Exporting ‘kk’ (35 bytes) to cluster node #2 ... DONE
[11:02:57.766] Exporting 1 global objects (344 bytes) to cluster node #2 ... DONE
[11:02:57.767] MultisessionFuture started
[11:02:57.767] - Launch lazy future ... done
[11:02:57.767] run() for ‘MultisessionFuture’ ... done
[11:02:57.777] run() for ‘Future’ ...
[11:02:57.778] - state: ‘created’
[11:02:57.778] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:57.791] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:57.791] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:57.791]   - Field: ‘node’
[11:02:57.791]   - Field: ‘label’
[11:02:57.792]   - Field: ‘local’
[11:02:57.792]   - Field: ‘owner’
[11:02:57.792]   - Field: ‘envir’
[11:02:57.792]   - Field: ‘workers’
[11:02:57.792]   - Field: ‘packages’
[11:02:57.792]   - Field: ‘gc’
[11:02:57.792]   - Field: ‘conditions’
[11:02:57.792]   - Field: ‘persistent’
[11:02:57.792]   - Field: ‘expr’
[11:02:57.792]   - Field: ‘uuid’
[11:02:57.792]   - Field: ‘seed’
[11:02:57.793]   - Field: ‘version’
[11:02:57.793]   - Field: ‘result’
[11:02:57.793]   - Field: ‘asynchronous’
[11:02:57.793]   - Field: ‘calls’
[11:02:57.793]   - Field: ‘globals’
[11:02:57.793]   - Field: ‘stdout’
[11:02:57.793]   - Field: ‘earlySignal’
[11:02:57.793]   - Field: ‘lazy’
[11:02:57.793]   - Field: ‘state’
[11:02:57.793] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:57.793] - Launch lazy future ...
[11:02:57.794] Packages needed by the future expression (n = 0): <none>
[11:02:57.794] Packages needed by future strategies (n = 0): <none>
[11:02:57.794] {
[11:02:57.794]     {
[11:02:57.794]         {
[11:02:57.794]             ...future.startTime <- base::Sys.time()
[11:02:57.794]             {
[11:02:57.794]                 {
[11:02:57.794]                   {
[11:02:57.794]                     {
[11:02:57.794]                       base::local({
[11:02:57.794]                         has_future <- base::requireNamespace("future", 
[11:02:57.794]                           quietly = TRUE)
[11:02:57.794]                         if (has_future) {
[11:02:57.794]                           ns <- base::getNamespace("future")
[11:02:57.794]                           version <- ns[[".package"]][["version"]]
[11:02:57.794]                           if (is.null(version)) 
[11:02:57.794]                             version <- utils::packageVersion("future")
[11:02:57.794]                         }
[11:02:57.794]                         else {
[11:02:57.794]                           version <- NULL
[11:02:57.794]                         }
[11:02:57.794]                         if (!has_future || version < "1.8.0") {
[11:02:57.794]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:57.794]                             "", base::R.version$version.string), 
[11:02:57.794]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:57.794]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:57.794]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:57.794]                               "release", "version")], collapse = " "), 
[11:02:57.794]                             hostname = base::Sys.info()[["nodename"]])
[11:02:57.794]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:57.794]                             info)
[11:02:57.794]                           info <- base::paste(info, collapse = "; ")
[11:02:57.794]                           if (!has_future) {
[11:02:57.794]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:57.794]                               info)
[11:02:57.794]                           }
[11:02:57.794]                           else {
[11:02:57.794]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:57.794]                               info, version)
[11:02:57.794]                           }
[11:02:57.794]                           base::stop(msg)
[11:02:57.794]                         }
[11:02:57.794]                       })
[11:02:57.794]                     }
[11:02:57.794]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:57.794]                     base::options(mc.cores = 1L)
[11:02:57.794]                   }
[11:02:57.794]                   ...future.strategy.old <- future::plan("list")
[11:02:57.794]                   options(future.plan = NULL)
[11:02:57.794]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:57.794]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:57.794]                 }
[11:02:57.794]                 ...future.workdir <- getwd()
[11:02:57.794]             }
[11:02:57.794]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:57.794]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:57.794]         }
[11:02:57.794]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:57.794]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:57.794]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:57.794]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:57.794]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:57.794]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:57.794]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:57.794]             base::names(...future.oldOptions))
[11:02:57.794]     }
[11:02:57.794]     if (FALSE) {
[11:02:57.794]     }
[11:02:57.794]     else {
[11:02:57.794]         if (TRUE) {
[11:02:57.794]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:57.794]                 open = "w")
[11:02:57.794]         }
[11:02:57.794]         else {
[11:02:57.794]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:57.794]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:57.794]         }
[11:02:57.794]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:57.794]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:57.794]             base::sink(type = "output", split = FALSE)
[11:02:57.794]             base::close(...future.stdout)
[11:02:57.794]         }, add = TRUE)
[11:02:57.794]     }
[11:02:57.794]     ...future.frame <- base::sys.nframe()
[11:02:57.794]     ...future.conditions <- base::list()
[11:02:57.794]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:57.794]     if (FALSE) {
[11:02:57.794]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:57.794]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:57.794]     }
[11:02:57.794]     ...future.result <- base::tryCatch({
[11:02:57.794]         base::withCallingHandlers({
[11:02:57.794]             ...future.value <- base::withVisible(base::local({
[11:02:57.794]                 ...future.makeSendCondition <- base::local({
[11:02:57.794]                   sendCondition <- NULL
[11:02:57.794]                   function(frame = 1L) {
[11:02:57.794]                     if (is.function(sendCondition)) 
[11:02:57.794]                       return(sendCondition)
[11:02:57.794]                     ns <- getNamespace("parallel")
[11:02:57.794]                     if (exists("sendData", mode = "function", 
[11:02:57.794]                       envir = ns)) {
[11:02:57.794]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:57.794]                         envir = ns)
[11:02:57.794]                       envir <- sys.frame(frame)
[11:02:57.794]                       master <- NULL
[11:02:57.794]                       while (!identical(envir, .GlobalEnv) && 
[11:02:57.794]                         !identical(envir, emptyenv())) {
[11:02:57.794]                         if (exists("master", mode = "list", envir = envir, 
[11:02:57.794]                           inherits = FALSE)) {
[11:02:57.794]                           master <- get("master", mode = "list", 
[11:02:57.794]                             envir = envir, inherits = FALSE)
[11:02:57.794]                           if (inherits(master, c("SOCKnode", 
[11:02:57.794]                             "SOCK0node"))) {
[11:02:57.794]                             sendCondition <<- function(cond) {
[11:02:57.794]                               data <- list(type = "VALUE", value = cond, 
[11:02:57.794]                                 success = TRUE)
[11:02:57.794]                               parallel_sendData(master, data)
[11:02:57.794]                             }
[11:02:57.794]                             return(sendCondition)
[11:02:57.794]                           }
[11:02:57.794]                         }
[11:02:57.794]                         frame <- frame + 1L
[11:02:57.794]                         envir <- sys.frame(frame)
[11:02:57.794]                       }
[11:02:57.794]                     }
[11:02:57.794]                     sendCondition <<- function(cond) NULL
[11:02:57.794]                   }
[11:02:57.794]                 })
[11:02:57.794]                 withCallingHandlers({
[11:02:57.794]                   {
[11:02:57.794]                     Sys.sleep(0.1)
[11:02:57.794]                     kk
[11:02:57.794]                   }
[11:02:57.794]                 }, immediateCondition = function(cond) {
[11:02:57.794]                   sendCondition <- ...future.makeSendCondition()
[11:02:57.794]                   sendCondition(cond)
[11:02:57.794]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:57.794]                   {
[11:02:57.794]                     inherits <- base::inherits
[11:02:57.794]                     invokeRestart <- base::invokeRestart
[11:02:57.794]                     is.null <- base::is.null
[11:02:57.794]                     muffled <- FALSE
[11:02:57.794]                     if (inherits(cond, "message")) {
[11:02:57.794]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:57.794]                       if (muffled) 
[11:02:57.794]                         invokeRestart("muffleMessage")
[11:02:57.794]                     }
[11:02:57.794]                     else if (inherits(cond, "warning")) {
[11:02:57.794]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:57.794]                       if (muffled) 
[11:02:57.794]                         invokeRestart("muffleWarning")
[11:02:57.794]                     }
[11:02:57.794]                     else if (inherits(cond, "condition")) {
[11:02:57.794]                       if (!is.null(pattern)) {
[11:02:57.794]                         computeRestarts <- base::computeRestarts
[11:02:57.794]                         grepl <- base::grepl
[11:02:57.794]                         restarts <- computeRestarts(cond)
[11:02:57.794]                         for (restart in restarts) {
[11:02:57.794]                           name <- restart$name
[11:02:57.794]                           if (is.null(name)) 
[11:02:57.794]                             next
[11:02:57.794]                           if (!grepl(pattern, name)) 
[11:02:57.794]                             next
[11:02:57.794]                           invokeRestart(restart)
[11:02:57.794]                           muffled <- TRUE
[11:02:57.794]                           break
[11:02:57.794]                         }
[11:02:57.794]                       }
[11:02:57.794]                     }
[11:02:57.794]                     invisible(muffled)
[11:02:57.794]                   }
[11:02:57.794]                   muffleCondition(cond)
[11:02:57.794]                 })
[11:02:57.794]             }))
[11:02:57.794]             future::FutureResult(value = ...future.value$value, 
[11:02:57.794]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:57.794]                   ...future.rng), globalenv = if (FALSE) 
[11:02:57.794]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:57.794]                     ...future.globalenv.names))
[11:02:57.794]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:57.794]         }, condition = base::local({
[11:02:57.794]             c <- base::c
[11:02:57.794]             inherits <- base::inherits
[11:02:57.794]             invokeRestart <- base::invokeRestart
[11:02:57.794]             length <- base::length
[11:02:57.794]             list <- base::list
[11:02:57.794]             seq.int <- base::seq.int
[11:02:57.794]             signalCondition <- base::signalCondition
[11:02:57.794]             sys.calls <- base::sys.calls
[11:02:57.794]             `[[` <- base::`[[`
[11:02:57.794]             `+` <- base::`+`
[11:02:57.794]             `<<-` <- base::`<<-`
[11:02:57.794]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:57.794]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:57.794]                   3L)]
[11:02:57.794]             }
[11:02:57.794]             function(cond) {
[11:02:57.794]                 is_error <- inherits(cond, "error")
[11:02:57.794]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:57.794]                   NULL)
[11:02:57.794]                 if (is_error) {
[11:02:57.794]                   sessionInformation <- function() {
[11:02:57.794]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:57.794]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:57.794]                       search = base::search(), system = base::Sys.info())
[11:02:57.794]                   }
[11:02:57.794]                   ...future.conditions[[length(...future.conditions) + 
[11:02:57.794]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:57.794]                     cond$call), session = sessionInformation(), 
[11:02:57.794]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:57.794]                   signalCondition(cond)
[11:02:57.794]                 }
[11:02:57.794]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:57.794]                 "immediateCondition"))) {
[11:02:57.794]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:57.794]                   ...future.conditions[[length(...future.conditions) + 
[11:02:57.794]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:57.794]                   if (TRUE && !signal) {
[11:02:57.794]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:57.794]                     {
[11:02:57.794]                       inherits <- base::inherits
[11:02:57.794]                       invokeRestart <- base::invokeRestart
[11:02:57.794]                       is.null <- base::is.null
[11:02:57.794]                       muffled <- FALSE
[11:02:57.794]                       if (inherits(cond, "message")) {
[11:02:57.794]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:57.794]                         if (muffled) 
[11:02:57.794]                           invokeRestart("muffleMessage")
[11:02:57.794]                       }
[11:02:57.794]                       else if (inherits(cond, "warning")) {
[11:02:57.794]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:57.794]                         if (muffled) 
[11:02:57.794]                           invokeRestart("muffleWarning")
[11:02:57.794]                       }
[11:02:57.794]                       else if (inherits(cond, "condition")) {
[11:02:57.794]                         if (!is.null(pattern)) {
[11:02:57.794]                           computeRestarts <- base::computeRestarts
[11:02:57.794]                           grepl <- base::grepl
[11:02:57.794]                           restarts <- computeRestarts(cond)
[11:02:57.794]                           for (restart in restarts) {
[11:02:57.794]                             name <- restart$name
[11:02:57.794]                             if (is.null(name)) 
[11:02:57.794]                               next
[11:02:57.794]                             if (!grepl(pattern, name)) 
[11:02:57.794]                               next
[11:02:57.794]                             invokeRestart(restart)
[11:02:57.794]                             muffled <- TRUE
[11:02:57.794]                             break
[11:02:57.794]                           }
[11:02:57.794]                         }
[11:02:57.794]                       }
[11:02:57.794]                       invisible(muffled)
[11:02:57.794]                     }
[11:02:57.794]                     muffleCondition(cond, pattern = "^muffle")
[11:02:57.794]                   }
[11:02:57.794]                 }
[11:02:57.794]                 else {
[11:02:57.794]                   if (TRUE) {
[11:02:57.794]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:57.794]                     {
[11:02:57.794]                       inherits <- base::inherits
[11:02:57.794]                       invokeRestart <- base::invokeRestart
[11:02:57.794]                       is.null <- base::is.null
[11:02:57.794]                       muffled <- FALSE
[11:02:57.794]                       if (inherits(cond, "message")) {
[11:02:57.794]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:57.794]                         if (muffled) 
[11:02:57.794]                           invokeRestart("muffleMessage")
[11:02:57.794]                       }
[11:02:57.794]                       else if (inherits(cond, "warning")) {
[11:02:57.794]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:57.794]                         if (muffled) 
[11:02:57.794]                           invokeRestart("muffleWarning")
[11:02:57.794]                       }
[11:02:57.794]                       else if (inherits(cond, "condition")) {
[11:02:57.794]                         if (!is.null(pattern)) {
[11:02:57.794]                           computeRestarts <- base::computeRestarts
[11:02:57.794]                           grepl <- base::grepl
[11:02:57.794]                           restarts <- computeRestarts(cond)
[11:02:57.794]                           for (restart in restarts) {
[11:02:57.794]                             name <- restart$name
[11:02:57.794]                             if (is.null(name)) 
[11:02:57.794]                               next
[11:02:57.794]                             if (!grepl(pattern, name)) 
[11:02:57.794]                               next
[11:02:57.794]                             invokeRestart(restart)
[11:02:57.794]                             muffled <- TRUE
[11:02:57.794]                             break
[11:02:57.794]                           }
[11:02:57.794]                         }
[11:02:57.794]                       }
[11:02:57.794]                       invisible(muffled)
[11:02:57.794]                     }
[11:02:57.794]                     muffleCondition(cond, pattern = "^muffle")
[11:02:57.794]                   }
[11:02:57.794]                 }
[11:02:57.794]             }
[11:02:57.794]         }))
[11:02:57.794]     }, error = function(ex) {
[11:02:57.794]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:57.794]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:57.794]                 ...future.rng), started = ...future.startTime, 
[11:02:57.794]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:57.794]             version = "1.8"), class = "FutureResult")
[11:02:57.794]     }, finally = {
[11:02:57.794]         if (!identical(...future.workdir, getwd())) 
[11:02:57.794]             setwd(...future.workdir)
[11:02:57.794]         {
[11:02:57.794]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:57.794]                 ...future.oldOptions$nwarnings <- NULL
[11:02:57.794]             }
[11:02:57.794]             base::options(...future.oldOptions)
[11:02:57.794]             if (.Platform$OS.type == "windows") {
[11:02:57.794]                 old_names <- names(...future.oldEnvVars)
[11:02:57.794]                 envs <- base::Sys.getenv()
[11:02:57.794]                 names <- names(envs)
[11:02:57.794]                 common <- intersect(names, old_names)
[11:02:57.794]                 added <- setdiff(names, old_names)
[11:02:57.794]                 removed <- setdiff(old_names, names)
[11:02:57.794]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:57.794]                   envs[common]]
[11:02:57.794]                 NAMES <- toupper(changed)
[11:02:57.794]                 args <- list()
[11:02:57.794]                 for (kk in seq_along(NAMES)) {
[11:02:57.794]                   name <- changed[[kk]]
[11:02:57.794]                   NAME <- NAMES[[kk]]
[11:02:57.794]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:57.794]                     next
[11:02:57.794]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:57.794]                 }
[11:02:57.794]                 NAMES <- toupper(added)
[11:02:57.794]                 for (kk in seq_along(NAMES)) {
[11:02:57.794]                   name <- added[[kk]]
[11:02:57.794]                   NAME <- NAMES[[kk]]
[11:02:57.794]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:57.794]                     next
[11:02:57.794]                   args[[name]] <- ""
[11:02:57.794]                 }
[11:02:57.794]                 NAMES <- toupper(removed)
[11:02:57.794]                 for (kk in seq_along(NAMES)) {
[11:02:57.794]                   name <- removed[[kk]]
[11:02:57.794]                   NAME <- NAMES[[kk]]
[11:02:57.794]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:57.794]                     next
[11:02:57.794]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:57.794]                 }
[11:02:57.794]                 if (length(args) > 0) 
[11:02:57.794]                   base::do.call(base::Sys.setenv, args = args)
[11:02:57.794]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:57.794]             }
[11:02:57.794]             else {
[11:02:57.794]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:57.794]             }
[11:02:57.794]             {
[11:02:57.794]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:57.794]                   0L) {
[11:02:57.794]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:57.794]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:57.794]                   base::options(opts)
[11:02:57.794]                 }
[11:02:57.794]                 {
[11:02:57.794]                   {
[11:02:57.794]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:57.794]                     NULL
[11:02:57.794]                   }
[11:02:57.794]                   options(future.plan = NULL)
[11:02:57.794]                   if (is.na(NA_character_)) 
[11:02:57.794]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:57.794]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:57.794]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:57.794]                     .init = FALSE)
[11:02:57.794]                 }
[11:02:57.794]             }
[11:02:57.794]         }
[11:02:57.794]     })
[11:02:57.794]     if (TRUE) {
[11:02:57.794]         base::sink(type = "output", split = FALSE)
[11:02:57.794]         if (TRUE) {
[11:02:57.794]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:57.794]         }
[11:02:57.794]         else {
[11:02:57.794]             ...future.result["stdout"] <- base::list(NULL)
[11:02:57.794]         }
[11:02:57.794]         base::close(...future.stdout)
[11:02:57.794]         ...future.stdout <- NULL
[11:02:57.794]     }
[11:02:57.794]     ...future.result$conditions <- ...future.conditions
[11:02:57.794]     ...future.result$finished <- base::Sys.time()
[11:02:57.794]     ...future.result
[11:02:57.794] }
[11:02:57.796] Poll #1 (0): usedNodes() = 2, workers = 2
[11:02:57.828] Poll #2 (0.03 secs): usedNodes() = 2, workers = 2
[11:02:57.859] Poll #3 (0.06 secs): usedNodes() = 2, workers = 2
[11:02:57.877] receiveMessageFromWorker() for ClusterFuture ...
[11:02:57.878] - Validating connection of MultisessionFuture
[11:02:57.878] - received message: FutureResult
[11:02:57.878] - Received FutureResult
[11:02:57.878] - Erased future from FutureRegistry
[11:02:57.878] result() for ClusterFuture ...
[11:02:57.878] - result already collected: FutureResult
[11:02:57.878] result() for ClusterFuture ... done
[11:02:57.878] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:57.879] result() for ClusterFuture ...
[11:02:57.879] - result already collected: FutureResult
[11:02:57.879] result() for ClusterFuture ... done
[11:02:57.879] result() for ClusterFuture ...
[11:02:57.879] - result already collected: FutureResult
[11:02:57.879] result() for ClusterFuture ... done
[11:02:57.880] Exporting 1 global objects (344 bytes) to cluster node #1 ...
[11:02:57.880] Exporting ‘kk’ (35 bytes) to cluster node #1 ...
[11:02:57.880] Exporting ‘kk’ (35 bytes) to cluster node #1 ... DONE
[11:02:57.880] Exporting 1 global objects (344 bytes) to cluster node #1 ... DONE
[11:02:57.881] MultisessionFuture started
[11:02:57.881] - Launch lazy future ... done
[11:02:57.881] run() for ‘MultisessionFuture’ ... done
[11:02:57.901] Future #1
[11:02:57.902]  length: 2 (resolved future 1)
[11:02:57.909] receiveMessageFromWorker() for ClusterFuture ...
[11:02:57.909] - Validating connection of MultisessionFuture
[11:02:57.910] - received message: FutureResult
[11:02:57.910] - Received FutureResult
[11:02:57.910] - Erased future from FutureRegistry
[11:02:57.910] result() for ClusterFuture ...
[11:02:57.910] - result already collected: FutureResult
[11:02:57.910] result() for ClusterFuture ... done
[11:02:57.910] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:57.910] Future #2
[11:02:57.910]  length: 1 (resolved future 2)
[11:02:58.023] receiveMessageFromWorker() for ClusterFuture ...
[11:02:58.023] - Validating connection of MultisessionFuture
[11:02:58.026] - received message: FutureResult
[11:02:58.026] - Received FutureResult
[11:02:58.026] - Erased future from FutureRegistry
[11:02:58.026] result() for ClusterFuture ...
[11:02:58.026] - result already collected: FutureResult
[11:02:58.027] result() for ClusterFuture ... done
[11:02:58.027] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:58.027] Future #3
[11:02:58.027]  length: 0 (resolved future 3)
[11:02:58.027] resolve() on list ... DONE
*** resolve() for lists ... DONE
*** resolve() for environments ...
[11:02:58.028] resolve() on environment ...
[11:02:58.028]  recursive: 0
[11:02:58.028]  elements: [2] ‘a’, ‘b’
[11:02:58.028]  length: 1 (resolved future 1)
[11:02:58.028]  length: 0 (resolved future 2)
[11:02:58.028] resolve() on environment ... DONE
[11:02:58.029] getGlobalsAndPackages() ...
[11:02:58.029] Searching for globals...
[11:02:58.029] 
[11:02:58.029] Searching for globals ... DONE
[11:02:58.029] - globals: [0] <none>
[11:02:58.029] getGlobalsAndPackages() ... DONE
[11:02:58.030] run() for ‘Future’ ...
[11:02:58.030] - state: ‘created’
[11:02:58.030] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:58.044] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:58.044] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:58.044]   - Field: ‘node’
[11:02:58.044]   - Field: ‘label’
[11:02:58.044]   - Field: ‘local’
[11:02:58.044]   - Field: ‘owner’
[11:02:58.044]   - Field: ‘envir’
[11:02:58.044]   - Field: ‘workers’
[11:02:58.045]   - Field: ‘packages’
[11:02:58.045]   - Field: ‘gc’
[11:02:58.045]   - Field: ‘conditions’
[11:02:58.045]   - Field: ‘persistent’
[11:02:58.045]   - Field: ‘expr’
[11:02:58.045]   - Field: ‘uuid’
[11:02:58.045]   - Field: ‘seed’
[11:02:58.045]   - Field: ‘version’
[11:02:58.045]   - Field: ‘result’
[11:02:58.045]   - Field: ‘asynchronous’
[11:02:58.045]   - Field: ‘calls’
[11:02:58.045]   - Field: ‘globals’
[11:02:58.046]   - Field: ‘stdout’
[11:02:58.046]   - Field: ‘earlySignal’
[11:02:58.046]   - Field: ‘lazy’
[11:02:58.046]   - Field: ‘state’
[11:02:58.046] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:58.046] - Launch lazy future ...
[11:02:58.046] Packages needed by the future expression (n = 0): <none>
[11:02:58.046] Packages needed by future strategies (n = 0): <none>
[11:02:58.047] {
[11:02:58.047]     {
[11:02:58.047]         {
[11:02:58.047]             ...future.startTime <- base::Sys.time()
[11:02:58.047]             {
[11:02:58.047]                 {
[11:02:58.047]                   {
[11:02:58.047]                     {
[11:02:58.047]                       base::local({
[11:02:58.047]                         has_future <- base::requireNamespace("future", 
[11:02:58.047]                           quietly = TRUE)
[11:02:58.047]                         if (has_future) {
[11:02:58.047]                           ns <- base::getNamespace("future")
[11:02:58.047]                           version <- ns[[".package"]][["version"]]
[11:02:58.047]                           if (is.null(version)) 
[11:02:58.047]                             version <- utils::packageVersion("future")
[11:02:58.047]                         }
[11:02:58.047]                         else {
[11:02:58.047]                           version <- NULL
[11:02:58.047]                         }
[11:02:58.047]                         if (!has_future || version < "1.8.0") {
[11:02:58.047]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:58.047]                             "", base::R.version$version.string), 
[11:02:58.047]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:58.047]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:58.047]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:58.047]                               "release", "version")], collapse = " "), 
[11:02:58.047]                             hostname = base::Sys.info()[["nodename"]])
[11:02:58.047]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:58.047]                             info)
[11:02:58.047]                           info <- base::paste(info, collapse = "; ")
[11:02:58.047]                           if (!has_future) {
[11:02:58.047]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:58.047]                               info)
[11:02:58.047]                           }
[11:02:58.047]                           else {
[11:02:58.047]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:58.047]                               info, version)
[11:02:58.047]                           }
[11:02:58.047]                           base::stop(msg)
[11:02:58.047]                         }
[11:02:58.047]                       })
[11:02:58.047]                     }
[11:02:58.047]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:58.047]                     base::options(mc.cores = 1L)
[11:02:58.047]                   }
[11:02:58.047]                   ...future.strategy.old <- future::plan("list")
[11:02:58.047]                   options(future.plan = NULL)
[11:02:58.047]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:58.047]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:58.047]                 }
[11:02:58.047]                 ...future.workdir <- getwd()
[11:02:58.047]             }
[11:02:58.047]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:58.047]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:58.047]         }
[11:02:58.047]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:58.047]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:58.047]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:58.047]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:58.047]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:58.047]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:58.047]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:58.047]             base::names(...future.oldOptions))
[11:02:58.047]     }
[11:02:58.047]     if (FALSE) {
[11:02:58.047]     }
[11:02:58.047]     else {
[11:02:58.047]         if (TRUE) {
[11:02:58.047]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:58.047]                 open = "w")
[11:02:58.047]         }
[11:02:58.047]         else {
[11:02:58.047]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:58.047]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:58.047]         }
[11:02:58.047]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:58.047]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:58.047]             base::sink(type = "output", split = FALSE)
[11:02:58.047]             base::close(...future.stdout)
[11:02:58.047]         }, add = TRUE)
[11:02:58.047]     }
[11:02:58.047]     ...future.frame <- base::sys.nframe()
[11:02:58.047]     ...future.conditions <- base::list()
[11:02:58.047]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:58.047]     if (FALSE) {
[11:02:58.047]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:58.047]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:58.047]     }
[11:02:58.047]     ...future.result <- base::tryCatch({
[11:02:58.047]         base::withCallingHandlers({
[11:02:58.047]             ...future.value <- base::withVisible(base::local({
[11:02:58.047]                 ...future.makeSendCondition <- base::local({
[11:02:58.047]                   sendCondition <- NULL
[11:02:58.047]                   function(frame = 1L) {
[11:02:58.047]                     if (is.function(sendCondition)) 
[11:02:58.047]                       return(sendCondition)
[11:02:58.047]                     ns <- getNamespace("parallel")
[11:02:58.047]                     if (exists("sendData", mode = "function", 
[11:02:58.047]                       envir = ns)) {
[11:02:58.047]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:58.047]                         envir = ns)
[11:02:58.047]                       envir <- sys.frame(frame)
[11:02:58.047]                       master <- NULL
[11:02:58.047]                       while (!identical(envir, .GlobalEnv) && 
[11:02:58.047]                         !identical(envir, emptyenv())) {
[11:02:58.047]                         if (exists("master", mode = "list", envir = envir, 
[11:02:58.047]                           inherits = FALSE)) {
[11:02:58.047]                           master <- get("master", mode = "list", 
[11:02:58.047]                             envir = envir, inherits = FALSE)
[11:02:58.047]                           if (inherits(master, c("SOCKnode", 
[11:02:58.047]                             "SOCK0node"))) {
[11:02:58.047]                             sendCondition <<- function(cond) {
[11:02:58.047]                               data <- list(type = "VALUE", value = cond, 
[11:02:58.047]                                 success = TRUE)
[11:02:58.047]                               parallel_sendData(master, data)
[11:02:58.047]                             }
[11:02:58.047]                             return(sendCondition)
[11:02:58.047]                           }
[11:02:58.047]                         }
[11:02:58.047]                         frame <- frame + 1L
[11:02:58.047]                         envir <- sys.frame(frame)
[11:02:58.047]                       }
[11:02:58.047]                     }
[11:02:58.047]                     sendCondition <<- function(cond) NULL
[11:02:58.047]                   }
[11:02:58.047]                 })
[11:02:58.047]                 withCallingHandlers({
[11:02:58.047]                   1
[11:02:58.047]                 }, immediateCondition = function(cond) {
[11:02:58.047]                   sendCondition <- ...future.makeSendCondition()
[11:02:58.047]                   sendCondition(cond)
[11:02:58.047]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:58.047]                   {
[11:02:58.047]                     inherits <- base::inherits
[11:02:58.047]                     invokeRestart <- base::invokeRestart
[11:02:58.047]                     is.null <- base::is.null
[11:02:58.047]                     muffled <- FALSE
[11:02:58.047]                     if (inherits(cond, "message")) {
[11:02:58.047]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:58.047]                       if (muffled) 
[11:02:58.047]                         invokeRestart("muffleMessage")
[11:02:58.047]                     }
[11:02:58.047]                     else if (inherits(cond, "warning")) {
[11:02:58.047]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:58.047]                       if (muffled) 
[11:02:58.047]                         invokeRestart("muffleWarning")
[11:02:58.047]                     }
[11:02:58.047]                     else if (inherits(cond, "condition")) {
[11:02:58.047]                       if (!is.null(pattern)) {
[11:02:58.047]                         computeRestarts <- base::computeRestarts
[11:02:58.047]                         grepl <- base::grepl
[11:02:58.047]                         restarts <- computeRestarts(cond)
[11:02:58.047]                         for (restart in restarts) {
[11:02:58.047]                           name <- restart$name
[11:02:58.047]                           if (is.null(name)) 
[11:02:58.047]                             next
[11:02:58.047]                           if (!grepl(pattern, name)) 
[11:02:58.047]                             next
[11:02:58.047]                           invokeRestart(restart)
[11:02:58.047]                           muffled <- TRUE
[11:02:58.047]                           break
[11:02:58.047]                         }
[11:02:58.047]                       }
[11:02:58.047]                     }
[11:02:58.047]                     invisible(muffled)
[11:02:58.047]                   }
[11:02:58.047]                   muffleCondition(cond)
[11:02:58.047]                 })
[11:02:58.047]             }))
[11:02:58.047]             future::FutureResult(value = ...future.value$value, 
[11:02:58.047]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:58.047]                   ...future.rng), globalenv = if (FALSE) 
[11:02:58.047]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:58.047]                     ...future.globalenv.names))
[11:02:58.047]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:58.047]         }, condition = base::local({
[11:02:58.047]             c <- base::c
[11:02:58.047]             inherits <- base::inherits
[11:02:58.047]             invokeRestart <- base::invokeRestart
[11:02:58.047]             length <- base::length
[11:02:58.047]             list <- base::list
[11:02:58.047]             seq.int <- base::seq.int
[11:02:58.047]             signalCondition <- base::signalCondition
[11:02:58.047]             sys.calls <- base::sys.calls
[11:02:58.047]             `[[` <- base::`[[`
[11:02:58.047]             `+` <- base::`+`
[11:02:58.047]             `<<-` <- base::`<<-`
[11:02:58.047]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:58.047]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:58.047]                   3L)]
[11:02:58.047]             }
[11:02:58.047]             function(cond) {
[11:02:58.047]                 is_error <- inherits(cond, "error")
[11:02:58.047]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:58.047]                   NULL)
[11:02:58.047]                 if (is_error) {
[11:02:58.047]                   sessionInformation <- function() {
[11:02:58.047]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:58.047]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:58.047]                       search = base::search(), system = base::Sys.info())
[11:02:58.047]                   }
[11:02:58.047]                   ...future.conditions[[length(...future.conditions) + 
[11:02:58.047]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:58.047]                     cond$call), session = sessionInformation(), 
[11:02:58.047]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:58.047]                   signalCondition(cond)
[11:02:58.047]                 }
[11:02:58.047]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:58.047]                 "immediateCondition"))) {
[11:02:58.047]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:58.047]                   ...future.conditions[[length(...future.conditions) + 
[11:02:58.047]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:58.047]                   if (TRUE && !signal) {
[11:02:58.047]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:58.047]                     {
[11:02:58.047]                       inherits <- base::inherits
[11:02:58.047]                       invokeRestart <- base::invokeRestart
[11:02:58.047]                       is.null <- base::is.null
[11:02:58.047]                       muffled <- FALSE
[11:02:58.047]                       if (inherits(cond, "message")) {
[11:02:58.047]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:58.047]                         if (muffled) 
[11:02:58.047]                           invokeRestart("muffleMessage")
[11:02:58.047]                       }
[11:02:58.047]                       else if (inherits(cond, "warning")) {
[11:02:58.047]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:58.047]                         if (muffled) 
[11:02:58.047]                           invokeRestart("muffleWarning")
[11:02:58.047]                       }
[11:02:58.047]                       else if (inherits(cond, "condition")) {
[11:02:58.047]                         if (!is.null(pattern)) {
[11:02:58.047]                           computeRestarts <- base::computeRestarts
[11:02:58.047]                           grepl <- base::grepl
[11:02:58.047]                           restarts <- computeRestarts(cond)
[11:02:58.047]                           for (restart in restarts) {
[11:02:58.047]                             name <- restart$name
[11:02:58.047]                             if (is.null(name)) 
[11:02:58.047]                               next
[11:02:58.047]                             if (!grepl(pattern, name)) 
[11:02:58.047]                               next
[11:02:58.047]                             invokeRestart(restart)
[11:02:58.047]                             muffled <- TRUE
[11:02:58.047]                             break
[11:02:58.047]                           }
[11:02:58.047]                         }
[11:02:58.047]                       }
[11:02:58.047]                       invisible(muffled)
[11:02:58.047]                     }
[11:02:58.047]                     muffleCondition(cond, pattern = "^muffle")
[11:02:58.047]                   }
[11:02:58.047]                 }
[11:02:58.047]                 else {
[11:02:58.047]                   if (TRUE) {
[11:02:58.047]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:58.047]                     {
[11:02:58.047]                       inherits <- base::inherits
[11:02:58.047]                       invokeRestart <- base::invokeRestart
[11:02:58.047]                       is.null <- base::is.null
[11:02:58.047]                       muffled <- FALSE
[11:02:58.047]                       if (inherits(cond, "message")) {
[11:02:58.047]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:58.047]                         if (muffled) 
[11:02:58.047]                           invokeRestart("muffleMessage")
[11:02:58.047]                       }
[11:02:58.047]                       else if (inherits(cond, "warning")) {
[11:02:58.047]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:58.047]                         if (muffled) 
[11:02:58.047]                           invokeRestart("muffleWarning")
[11:02:58.047]                       }
[11:02:58.047]                       else if (inherits(cond, "condition")) {
[11:02:58.047]                         if (!is.null(pattern)) {
[11:02:58.047]                           computeRestarts <- base::computeRestarts
[11:02:58.047]                           grepl <- base::grepl
[11:02:58.047]                           restarts <- computeRestarts(cond)
[11:02:58.047]                           for (restart in restarts) {
[11:02:58.047]                             name <- restart$name
[11:02:58.047]                             if (is.null(name)) 
[11:02:58.047]                               next
[11:02:58.047]                             if (!grepl(pattern, name)) 
[11:02:58.047]                               next
[11:02:58.047]                             invokeRestart(restart)
[11:02:58.047]                             muffled <- TRUE
[11:02:58.047]                             break
[11:02:58.047]                           }
[11:02:58.047]                         }
[11:02:58.047]                       }
[11:02:58.047]                       invisible(muffled)
[11:02:58.047]                     }
[11:02:58.047]                     muffleCondition(cond, pattern = "^muffle")
[11:02:58.047]                   }
[11:02:58.047]                 }
[11:02:58.047]             }
[11:02:58.047]         }))
[11:02:58.047]     }, error = function(ex) {
[11:02:58.047]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:58.047]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:58.047]                 ...future.rng), started = ...future.startTime, 
[11:02:58.047]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:58.047]             version = "1.8"), class = "FutureResult")
[11:02:58.047]     }, finally = {
[11:02:58.047]         if (!identical(...future.workdir, getwd())) 
[11:02:58.047]             setwd(...future.workdir)
[11:02:58.047]         {
[11:02:58.047]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:58.047]                 ...future.oldOptions$nwarnings <- NULL
[11:02:58.047]             }
[11:02:58.047]             base::options(...future.oldOptions)
[11:02:58.047]             if (.Platform$OS.type == "windows") {
[11:02:58.047]                 old_names <- names(...future.oldEnvVars)
[11:02:58.047]                 envs <- base::Sys.getenv()
[11:02:58.047]                 names <- names(envs)
[11:02:58.047]                 common <- intersect(names, old_names)
[11:02:58.047]                 added <- setdiff(names, old_names)
[11:02:58.047]                 removed <- setdiff(old_names, names)
[11:02:58.047]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:58.047]                   envs[common]]
[11:02:58.047]                 NAMES <- toupper(changed)
[11:02:58.047]                 args <- list()
[11:02:58.047]                 for (kk in seq_along(NAMES)) {
[11:02:58.047]                   name <- changed[[kk]]
[11:02:58.047]                   NAME <- NAMES[[kk]]
[11:02:58.047]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:58.047]                     next
[11:02:58.047]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:58.047]                 }
[11:02:58.047]                 NAMES <- toupper(added)
[11:02:58.047]                 for (kk in seq_along(NAMES)) {
[11:02:58.047]                   name <- added[[kk]]
[11:02:58.047]                   NAME <- NAMES[[kk]]
[11:02:58.047]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:58.047]                     next
[11:02:58.047]                   args[[name]] <- ""
[11:02:58.047]                 }
[11:02:58.047]                 NAMES <- toupper(removed)
[11:02:58.047]                 for (kk in seq_along(NAMES)) {
[11:02:58.047]                   name <- removed[[kk]]
[11:02:58.047]                   NAME <- NAMES[[kk]]
[11:02:58.047]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:58.047]                     next
[11:02:58.047]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:58.047]                 }
[11:02:58.047]                 if (length(args) > 0) 
[11:02:58.047]                   base::do.call(base::Sys.setenv, args = args)
[11:02:58.047]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:58.047]             }
[11:02:58.047]             else {
[11:02:58.047]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:58.047]             }
[11:02:58.047]             {
[11:02:58.047]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:58.047]                   0L) {
[11:02:58.047]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:58.047]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:58.047]                   base::options(opts)
[11:02:58.047]                 }
[11:02:58.047]                 {
[11:02:58.047]                   {
[11:02:58.047]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:58.047]                     NULL
[11:02:58.047]                   }
[11:02:58.047]                   options(future.plan = NULL)
[11:02:58.047]                   if (is.na(NA_character_)) 
[11:02:58.047]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:58.047]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:58.047]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:58.047]                     .init = FALSE)
[11:02:58.047]                 }
[11:02:58.047]             }
[11:02:58.047]         }
[11:02:58.047]     })
[11:02:58.047]     if (TRUE) {
[11:02:58.047]         base::sink(type = "output", split = FALSE)
[11:02:58.047]         if (TRUE) {
[11:02:58.047]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:58.047]         }
[11:02:58.047]         else {
[11:02:58.047]             ...future.result["stdout"] <- base::list(NULL)
[11:02:58.047]         }
[11:02:58.047]         base::close(...future.stdout)
[11:02:58.047]         ...future.stdout <- NULL
[11:02:58.047]     }
[11:02:58.047]     ...future.result$conditions <- ...future.conditions
[11:02:58.047]     ...future.result$finished <- base::Sys.time()
[11:02:58.047]     ...future.result
[11:02:58.047] }
[11:02:58.050] MultisessionFuture started
[11:02:58.050] - Launch lazy future ... done
[11:02:58.050] run() for ‘MultisessionFuture’ ... done
[11:02:58.050] getGlobalsAndPackages() ...
[11:02:58.050] Searching for globals...
[11:02:58.050] 
[11:02:58.050] Searching for globals ... DONE
[11:02:58.050] - globals: [0] <none>
[11:02:58.051] getGlobalsAndPackages() ... DONE
[11:02:58.051] run() for ‘Future’ ...
[11:02:58.051] - state: ‘created’
[11:02:58.051] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:58.065] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:58.065] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:58.065]   - Field: ‘node’
[11:02:58.065]   - Field: ‘label’
[11:02:58.065]   - Field: ‘local’
[11:02:58.065]   - Field: ‘owner’
[11:02:58.065]   - Field: ‘envir’
[11:02:58.065]   - Field: ‘workers’
[11:02:58.065]   - Field: ‘packages’
[11:02:58.065]   - Field: ‘gc’
[11:02:58.065]   - Field: ‘conditions’
[11:02:58.066]   - Field: ‘persistent’
[11:02:58.066]   - Field: ‘expr’
[11:02:58.066]   - Field: ‘uuid’
[11:02:58.066]   - Field: ‘seed’
[11:02:58.066]   - Field: ‘version’
[11:02:58.066]   - Field: ‘result’
[11:02:58.066]   - Field: ‘asynchronous’
[11:02:58.066]   - Field: ‘calls’
[11:02:58.066]   - Field: ‘globals’
[11:02:58.066]   - Field: ‘stdout’
[11:02:58.066]   - Field: ‘earlySignal’
[11:02:58.066]   - Field: ‘lazy’
[11:02:58.067]   - Field: ‘state’
[11:02:58.067] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:58.067] - Launch lazy future ...
[11:02:58.067] Packages needed by the future expression (n = 0): <none>
[11:02:58.067] Packages needed by future strategies (n = 0): <none>
[11:02:58.067] {
[11:02:58.067]     {
[11:02:58.067]         {
[11:02:58.067]             ...future.startTime <- base::Sys.time()
[11:02:58.067]             {
[11:02:58.067]                 {
[11:02:58.067]                   {
[11:02:58.067]                     {
[11:02:58.067]                       base::local({
[11:02:58.067]                         has_future <- base::requireNamespace("future", 
[11:02:58.067]                           quietly = TRUE)
[11:02:58.067]                         if (has_future) {
[11:02:58.067]                           ns <- base::getNamespace("future")
[11:02:58.067]                           version <- ns[[".package"]][["version"]]
[11:02:58.067]                           if (is.null(version)) 
[11:02:58.067]                             version <- utils::packageVersion("future")
[11:02:58.067]                         }
[11:02:58.067]                         else {
[11:02:58.067]                           version <- NULL
[11:02:58.067]                         }
[11:02:58.067]                         if (!has_future || version < "1.8.0") {
[11:02:58.067]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:58.067]                             "", base::R.version$version.string), 
[11:02:58.067]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:58.067]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:58.067]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:58.067]                               "release", "version")], collapse = " "), 
[11:02:58.067]                             hostname = base::Sys.info()[["nodename"]])
[11:02:58.067]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:58.067]                             info)
[11:02:58.067]                           info <- base::paste(info, collapse = "; ")
[11:02:58.067]                           if (!has_future) {
[11:02:58.067]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:58.067]                               info)
[11:02:58.067]                           }
[11:02:58.067]                           else {
[11:02:58.067]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:58.067]                               info, version)
[11:02:58.067]                           }
[11:02:58.067]                           base::stop(msg)
[11:02:58.067]                         }
[11:02:58.067]                       })
[11:02:58.067]                     }
[11:02:58.067]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:58.067]                     base::options(mc.cores = 1L)
[11:02:58.067]                   }
[11:02:58.067]                   ...future.strategy.old <- future::plan("list")
[11:02:58.067]                   options(future.plan = NULL)
[11:02:58.067]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:58.067]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:58.067]                 }
[11:02:58.067]                 ...future.workdir <- getwd()
[11:02:58.067]             }
[11:02:58.067]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:58.067]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:58.067]         }
[11:02:58.067]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:58.067]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:58.067]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:58.067]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:58.067]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:58.067]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:58.067]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:58.067]             base::names(...future.oldOptions))
[11:02:58.067]     }
[11:02:58.067]     if (FALSE) {
[11:02:58.067]     }
[11:02:58.067]     else {
[11:02:58.067]         if (TRUE) {
[11:02:58.067]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:58.067]                 open = "w")
[11:02:58.067]         }
[11:02:58.067]         else {
[11:02:58.067]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:58.067]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:58.067]         }
[11:02:58.067]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:58.067]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:58.067]             base::sink(type = "output", split = FALSE)
[11:02:58.067]             base::close(...future.stdout)
[11:02:58.067]         }, add = TRUE)
[11:02:58.067]     }
[11:02:58.067]     ...future.frame <- base::sys.nframe()
[11:02:58.067]     ...future.conditions <- base::list()
[11:02:58.067]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:58.067]     if (FALSE) {
[11:02:58.067]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:58.067]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:58.067]     }
[11:02:58.067]     ...future.result <- base::tryCatch({
[11:02:58.067]         base::withCallingHandlers({
[11:02:58.067]             ...future.value <- base::withVisible(base::local({
[11:02:58.067]                 ...future.makeSendCondition <- base::local({
[11:02:58.067]                   sendCondition <- NULL
[11:02:58.067]                   function(frame = 1L) {
[11:02:58.067]                     if (is.function(sendCondition)) 
[11:02:58.067]                       return(sendCondition)
[11:02:58.067]                     ns <- getNamespace("parallel")
[11:02:58.067]                     if (exists("sendData", mode = "function", 
[11:02:58.067]                       envir = ns)) {
[11:02:58.067]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:58.067]                         envir = ns)
[11:02:58.067]                       envir <- sys.frame(frame)
[11:02:58.067]                       master <- NULL
[11:02:58.067]                       while (!identical(envir, .GlobalEnv) && 
[11:02:58.067]                         !identical(envir, emptyenv())) {
[11:02:58.067]                         if (exists("master", mode = "list", envir = envir, 
[11:02:58.067]                           inherits = FALSE)) {
[11:02:58.067]                           master <- get("master", mode = "list", 
[11:02:58.067]                             envir = envir, inherits = FALSE)
[11:02:58.067]                           if (inherits(master, c("SOCKnode", 
[11:02:58.067]                             "SOCK0node"))) {
[11:02:58.067]                             sendCondition <<- function(cond) {
[11:02:58.067]                               data <- list(type = "VALUE", value = cond, 
[11:02:58.067]                                 success = TRUE)
[11:02:58.067]                               parallel_sendData(master, data)
[11:02:58.067]                             }
[11:02:58.067]                             return(sendCondition)
[11:02:58.067]                           }
[11:02:58.067]                         }
[11:02:58.067]                         frame <- frame + 1L
[11:02:58.067]                         envir <- sys.frame(frame)
[11:02:58.067]                       }
[11:02:58.067]                     }
[11:02:58.067]                     sendCondition <<- function(cond) NULL
[11:02:58.067]                   }
[11:02:58.067]                 })
[11:02:58.067]                 withCallingHandlers({
[11:02:58.067]                   2
[11:02:58.067]                 }, immediateCondition = function(cond) {
[11:02:58.067]                   sendCondition <- ...future.makeSendCondition()
[11:02:58.067]                   sendCondition(cond)
[11:02:58.067]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:58.067]                   {
[11:02:58.067]                     inherits <- base::inherits
[11:02:58.067]                     invokeRestart <- base::invokeRestart
[11:02:58.067]                     is.null <- base::is.null
[11:02:58.067]                     muffled <- FALSE
[11:02:58.067]                     if (inherits(cond, "message")) {
[11:02:58.067]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:58.067]                       if (muffled) 
[11:02:58.067]                         invokeRestart("muffleMessage")
[11:02:58.067]                     }
[11:02:58.067]                     else if (inherits(cond, "warning")) {
[11:02:58.067]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:58.067]                       if (muffled) 
[11:02:58.067]                         invokeRestart("muffleWarning")
[11:02:58.067]                     }
[11:02:58.067]                     else if (inherits(cond, "condition")) {
[11:02:58.067]                       if (!is.null(pattern)) {
[11:02:58.067]                         computeRestarts <- base::computeRestarts
[11:02:58.067]                         grepl <- base::grepl
[11:02:58.067]                         restarts <- computeRestarts(cond)
[11:02:58.067]                         for (restart in restarts) {
[11:02:58.067]                           name <- restart$name
[11:02:58.067]                           if (is.null(name)) 
[11:02:58.067]                             next
[11:02:58.067]                           if (!grepl(pattern, name)) 
[11:02:58.067]                             next
[11:02:58.067]                           invokeRestart(restart)
[11:02:58.067]                           muffled <- TRUE
[11:02:58.067]                           break
[11:02:58.067]                         }
[11:02:58.067]                       }
[11:02:58.067]                     }
[11:02:58.067]                     invisible(muffled)
[11:02:58.067]                   }
[11:02:58.067]                   muffleCondition(cond)
[11:02:58.067]                 })
[11:02:58.067]             }))
[11:02:58.067]             future::FutureResult(value = ...future.value$value, 
[11:02:58.067]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:58.067]                   ...future.rng), globalenv = if (FALSE) 
[11:02:58.067]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:58.067]                     ...future.globalenv.names))
[11:02:58.067]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:58.067]         }, condition = base::local({
[11:02:58.067]             c <- base::c
[11:02:58.067]             inherits <- base::inherits
[11:02:58.067]             invokeRestart <- base::invokeRestart
[11:02:58.067]             length <- base::length
[11:02:58.067]             list <- base::list
[11:02:58.067]             seq.int <- base::seq.int
[11:02:58.067]             signalCondition <- base::signalCondition
[11:02:58.067]             sys.calls <- base::sys.calls
[11:02:58.067]             `[[` <- base::`[[`
[11:02:58.067]             `+` <- base::`+`
[11:02:58.067]             `<<-` <- base::`<<-`
[11:02:58.067]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:58.067]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:58.067]                   3L)]
[11:02:58.067]             }
[11:02:58.067]             function(cond) {
[11:02:58.067]                 is_error <- inherits(cond, "error")
[11:02:58.067]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:58.067]                   NULL)
[11:02:58.067]                 if (is_error) {
[11:02:58.067]                   sessionInformation <- function() {
[11:02:58.067]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:58.067]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:58.067]                       search = base::search(), system = base::Sys.info())
[11:02:58.067]                   }
[11:02:58.067]                   ...future.conditions[[length(...future.conditions) + 
[11:02:58.067]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:58.067]                     cond$call), session = sessionInformation(), 
[11:02:58.067]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:58.067]                   signalCondition(cond)
[11:02:58.067]                 }
[11:02:58.067]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:58.067]                 "immediateCondition"))) {
[11:02:58.067]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:58.067]                   ...future.conditions[[length(...future.conditions) + 
[11:02:58.067]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:58.067]                   if (TRUE && !signal) {
[11:02:58.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:58.067]                     {
[11:02:58.067]                       inherits <- base::inherits
[11:02:58.067]                       invokeRestart <- base::invokeRestart
[11:02:58.067]                       is.null <- base::is.null
[11:02:58.067]                       muffled <- FALSE
[11:02:58.067]                       if (inherits(cond, "message")) {
[11:02:58.067]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:58.067]                         if (muffled) 
[11:02:58.067]                           invokeRestart("muffleMessage")
[11:02:58.067]                       }
[11:02:58.067]                       else if (inherits(cond, "warning")) {
[11:02:58.067]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:58.067]                         if (muffled) 
[11:02:58.067]                           invokeRestart("muffleWarning")
[11:02:58.067]                       }
[11:02:58.067]                       else if (inherits(cond, "condition")) {
[11:02:58.067]                         if (!is.null(pattern)) {
[11:02:58.067]                           computeRestarts <- base::computeRestarts
[11:02:58.067]                           grepl <- base::grepl
[11:02:58.067]                           restarts <- computeRestarts(cond)
[11:02:58.067]                           for (restart in restarts) {
[11:02:58.067]                             name <- restart$name
[11:02:58.067]                             if (is.null(name)) 
[11:02:58.067]                               next
[11:02:58.067]                             if (!grepl(pattern, name)) 
[11:02:58.067]                               next
[11:02:58.067]                             invokeRestart(restart)
[11:02:58.067]                             muffled <- TRUE
[11:02:58.067]                             break
[11:02:58.067]                           }
[11:02:58.067]                         }
[11:02:58.067]                       }
[11:02:58.067]                       invisible(muffled)
[11:02:58.067]                     }
[11:02:58.067]                     muffleCondition(cond, pattern = "^muffle")
[11:02:58.067]                   }
[11:02:58.067]                 }
[11:02:58.067]                 else {
[11:02:58.067]                   if (TRUE) {
[11:02:58.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:58.067]                     {
[11:02:58.067]                       inherits <- base::inherits
[11:02:58.067]                       invokeRestart <- base::invokeRestart
[11:02:58.067]                       is.null <- base::is.null
[11:02:58.067]                       muffled <- FALSE
[11:02:58.067]                       if (inherits(cond, "message")) {
[11:02:58.067]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:58.067]                         if (muffled) 
[11:02:58.067]                           invokeRestart("muffleMessage")
[11:02:58.067]                       }
[11:02:58.067]                       else if (inherits(cond, "warning")) {
[11:02:58.067]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:58.067]                         if (muffled) 
[11:02:58.067]                           invokeRestart("muffleWarning")
[11:02:58.067]                       }
[11:02:58.067]                       else if (inherits(cond, "condition")) {
[11:02:58.067]                         if (!is.null(pattern)) {
[11:02:58.067]                           computeRestarts <- base::computeRestarts
[11:02:58.067]                           grepl <- base::grepl
[11:02:58.067]                           restarts <- computeRestarts(cond)
[11:02:58.067]                           for (restart in restarts) {
[11:02:58.067]                             name <- restart$name
[11:02:58.067]                             if (is.null(name)) 
[11:02:58.067]                               next
[11:02:58.067]                             if (!grepl(pattern, name)) 
[11:02:58.067]                               next
[11:02:58.067]                             invokeRestart(restart)
[11:02:58.067]                             muffled <- TRUE
[11:02:58.067]                             break
[11:02:58.067]                           }
[11:02:58.067]                         }
[11:02:58.067]                       }
[11:02:58.067]                       invisible(muffled)
[11:02:58.067]                     }
[11:02:58.067]                     muffleCondition(cond, pattern = "^muffle")
[11:02:58.067]                   }
[11:02:58.067]                 }
[11:02:58.067]             }
[11:02:58.067]         }))
[11:02:58.067]     }, error = function(ex) {
[11:02:58.067]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:58.067]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:58.067]                 ...future.rng), started = ...future.startTime, 
[11:02:58.067]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:58.067]             version = "1.8"), class = "FutureResult")
[11:02:58.067]     }, finally = {
[11:02:58.067]         if (!identical(...future.workdir, getwd())) 
[11:02:58.067]             setwd(...future.workdir)
[11:02:58.067]         {
[11:02:58.067]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:58.067]                 ...future.oldOptions$nwarnings <- NULL
[11:02:58.067]             }
[11:02:58.067]             base::options(...future.oldOptions)
[11:02:58.067]             if (.Platform$OS.type == "windows") {
[11:02:58.067]                 old_names <- names(...future.oldEnvVars)
[11:02:58.067]                 envs <- base::Sys.getenv()
[11:02:58.067]                 names <- names(envs)
[11:02:58.067]                 common <- intersect(names, old_names)
[11:02:58.067]                 added <- setdiff(names, old_names)
[11:02:58.067]                 removed <- setdiff(old_names, names)
[11:02:58.067]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:58.067]                   envs[common]]
[11:02:58.067]                 NAMES <- toupper(changed)
[11:02:58.067]                 args <- list()
[11:02:58.067]                 for (kk in seq_along(NAMES)) {
[11:02:58.067]                   name <- changed[[kk]]
[11:02:58.067]                   NAME <- NAMES[[kk]]
[11:02:58.067]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:58.067]                     next
[11:02:58.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:58.067]                 }
[11:02:58.067]                 NAMES <- toupper(added)
[11:02:58.067]                 for (kk in seq_along(NAMES)) {
[11:02:58.067]                   name <- added[[kk]]
[11:02:58.067]                   NAME <- NAMES[[kk]]
[11:02:58.067]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:58.067]                     next
[11:02:58.067]                   args[[name]] <- ""
[11:02:58.067]                 }
[11:02:58.067]                 NAMES <- toupper(removed)
[11:02:58.067]                 for (kk in seq_along(NAMES)) {
[11:02:58.067]                   name <- removed[[kk]]
[11:02:58.067]                   NAME <- NAMES[[kk]]
[11:02:58.067]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:58.067]                     next
[11:02:58.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:58.067]                 }
[11:02:58.067]                 if (length(args) > 0) 
[11:02:58.067]                   base::do.call(base::Sys.setenv, args = args)
[11:02:58.067]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:58.067]             }
[11:02:58.067]             else {
[11:02:58.067]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:58.067]             }
[11:02:58.067]             {
[11:02:58.067]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:58.067]                   0L) {
[11:02:58.067]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:58.067]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:58.067]                   base::options(opts)
[11:02:58.067]                 }
[11:02:58.067]                 {
[11:02:58.067]                   {
[11:02:58.067]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:58.067]                     NULL
[11:02:58.067]                   }
[11:02:58.067]                   options(future.plan = NULL)
[11:02:58.067]                   if (is.na(NA_character_)) 
[11:02:58.067]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:58.067]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:58.067]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:58.067]                     .init = FALSE)
[11:02:58.067]                 }
[11:02:58.067]             }
[11:02:58.067]         }
[11:02:58.067]     })
[11:02:58.067]     if (TRUE) {
[11:02:58.067]         base::sink(type = "output", split = FALSE)
[11:02:58.067]         if (TRUE) {
[11:02:58.067]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:58.067]         }
[11:02:58.067]         else {
[11:02:58.067]             ...future.result["stdout"] <- base::list(NULL)
[11:02:58.067]         }
[11:02:58.067]         base::close(...future.stdout)
[11:02:58.067]         ...future.stdout <- NULL
[11:02:58.067]     }
[11:02:58.067]     ...future.result$conditions <- ...future.conditions
[11:02:58.067]     ...future.result$finished <- base::Sys.time()
[11:02:58.067]     ...future.result
[11:02:58.067] }
[11:02:58.070] MultisessionFuture started
[11:02:58.070] - Launch lazy future ... done
[11:02:58.071] run() for ‘MultisessionFuture’ ... done
[11:02:58.071] resolve() on environment ...
[11:02:58.071]  recursive: 0
[11:02:58.072]  elements: [3] ‘a’, ‘b’, ‘c’
[11:02:58.093]  length: 2 (resolved future 3)
[11:02:58.103] receiveMessageFromWorker() for ClusterFuture ...
[11:02:58.103] - Validating connection of MultisessionFuture
[11:02:58.104] - received message: FutureResult
[11:02:58.104] - Received FutureResult
[11:02:58.104] - Erased future from FutureRegistry
[11:02:58.104] result() for ClusterFuture ...
[11:02:58.104] - result already collected: FutureResult
[11:02:58.104] result() for ClusterFuture ... done
[11:02:58.104] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:58.104] Future #1
[11:02:58.105]  length: 1 (resolved future 1)
[11:02:58.112] receiveMessageFromWorker() for ClusterFuture ...
[11:02:58.112] - Validating connection of MultisessionFuture
[11:02:58.113] - received message: FutureResult
[11:02:58.113] - Received FutureResult
[11:02:58.113] - Erased future from FutureRegistry
[11:02:58.113] result() for ClusterFuture ...
[11:02:58.113] - result already collected: FutureResult
[11:02:58.113] result() for ClusterFuture ... done
[11:02:58.113] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:58.113] Future #2
[11:02:58.113]  length: 0 (resolved future 2)
[11:02:58.113] resolve() on environment ... DONE
[11:02:58.114] getGlobalsAndPackages() ...
[11:02:58.114] Searching for globals...
[11:02:58.115] - globals found: [1] ‘{’
[11:02:58.115] Searching for globals ... DONE
[11:02:58.115] Resolving globals: FALSE
[11:02:58.115] 
[11:02:58.115] 
[11:02:58.115] getGlobalsAndPackages() ... DONE
[11:02:58.116] run() for ‘Future’ ...
[11:02:58.116] - state: ‘created’
[11:02:58.116] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:58.129] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:58.130] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:58.130]   - Field: ‘node’
[11:02:58.130]   - Field: ‘label’
[11:02:58.130]   - Field: ‘local’
[11:02:58.130]   - Field: ‘owner’
[11:02:58.130]   - Field: ‘envir’
[11:02:58.130]   - Field: ‘workers’
[11:02:58.130]   - Field: ‘packages’
[11:02:58.130]   - Field: ‘gc’
[11:02:58.130]   - Field: ‘conditions’
[11:02:58.130]   - Field: ‘persistent’
[11:02:58.131]   - Field: ‘expr’
[11:02:58.131]   - Field: ‘uuid’
[11:02:58.131]   - Field: ‘seed’
[11:02:58.131]   - Field: ‘version’
[11:02:58.131]   - Field: ‘result’
[11:02:58.131]   - Field: ‘asynchronous’
[11:02:58.131]   - Field: ‘calls’
[11:02:58.131]   - Field: ‘globals’
[11:02:58.131]   - Field: ‘stdout’
[11:02:58.131]   - Field: ‘earlySignal’
[11:02:58.131]   - Field: ‘lazy’
[11:02:58.131]   - Field: ‘state’
[11:02:58.132] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:58.132] - Launch lazy future ...
[11:02:58.132] Packages needed by the future expression (n = 0): <none>
[11:02:58.132] Packages needed by future strategies (n = 0): <none>
[11:02:58.132] {
[11:02:58.132]     {
[11:02:58.132]         {
[11:02:58.132]             ...future.startTime <- base::Sys.time()
[11:02:58.132]             {
[11:02:58.132]                 {
[11:02:58.132]                   {
[11:02:58.132]                     {
[11:02:58.132]                       base::local({
[11:02:58.132]                         has_future <- base::requireNamespace("future", 
[11:02:58.132]                           quietly = TRUE)
[11:02:58.132]                         if (has_future) {
[11:02:58.132]                           ns <- base::getNamespace("future")
[11:02:58.132]                           version <- ns[[".package"]][["version"]]
[11:02:58.132]                           if (is.null(version)) 
[11:02:58.132]                             version <- utils::packageVersion("future")
[11:02:58.132]                         }
[11:02:58.132]                         else {
[11:02:58.132]                           version <- NULL
[11:02:58.132]                         }
[11:02:58.132]                         if (!has_future || version < "1.8.0") {
[11:02:58.132]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:58.132]                             "", base::R.version$version.string), 
[11:02:58.132]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:58.132]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:58.132]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:58.132]                               "release", "version")], collapse = " "), 
[11:02:58.132]                             hostname = base::Sys.info()[["nodename"]])
[11:02:58.132]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:58.132]                             info)
[11:02:58.132]                           info <- base::paste(info, collapse = "; ")
[11:02:58.132]                           if (!has_future) {
[11:02:58.132]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:58.132]                               info)
[11:02:58.132]                           }
[11:02:58.132]                           else {
[11:02:58.132]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:58.132]                               info, version)
[11:02:58.132]                           }
[11:02:58.132]                           base::stop(msg)
[11:02:58.132]                         }
[11:02:58.132]                       })
[11:02:58.132]                     }
[11:02:58.132]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:58.132]                     base::options(mc.cores = 1L)
[11:02:58.132]                   }
[11:02:58.132]                   ...future.strategy.old <- future::plan("list")
[11:02:58.132]                   options(future.plan = NULL)
[11:02:58.132]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:58.132]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:58.132]                 }
[11:02:58.132]                 ...future.workdir <- getwd()
[11:02:58.132]             }
[11:02:58.132]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:58.132]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:58.132]         }
[11:02:58.132]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:58.132]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:58.132]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:58.132]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:58.132]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:58.132]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:58.132]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:58.132]             base::names(...future.oldOptions))
[11:02:58.132]     }
[11:02:58.132]     if (FALSE) {
[11:02:58.132]     }
[11:02:58.132]     else {
[11:02:58.132]         if (TRUE) {
[11:02:58.132]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:58.132]                 open = "w")
[11:02:58.132]         }
[11:02:58.132]         else {
[11:02:58.132]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:58.132]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:58.132]         }
[11:02:58.132]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:58.132]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:58.132]             base::sink(type = "output", split = FALSE)
[11:02:58.132]             base::close(...future.stdout)
[11:02:58.132]         }, add = TRUE)
[11:02:58.132]     }
[11:02:58.132]     ...future.frame <- base::sys.nframe()
[11:02:58.132]     ...future.conditions <- base::list()
[11:02:58.132]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:58.132]     if (FALSE) {
[11:02:58.132]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:58.132]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:58.132]     }
[11:02:58.132]     ...future.result <- base::tryCatch({
[11:02:58.132]         base::withCallingHandlers({
[11:02:58.132]             ...future.value <- base::withVisible(base::local({
[11:02:58.132]                 ...future.makeSendCondition <- base::local({
[11:02:58.132]                   sendCondition <- NULL
[11:02:58.132]                   function(frame = 1L) {
[11:02:58.132]                     if (is.function(sendCondition)) 
[11:02:58.132]                       return(sendCondition)
[11:02:58.132]                     ns <- getNamespace("parallel")
[11:02:58.132]                     if (exists("sendData", mode = "function", 
[11:02:58.132]                       envir = ns)) {
[11:02:58.132]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:58.132]                         envir = ns)
[11:02:58.132]                       envir <- sys.frame(frame)
[11:02:58.132]                       master <- NULL
[11:02:58.132]                       while (!identical(envir, .GlobalEnv) && 
[11:02:58.132]                         !identical(envir, emptyenv())) {
[11:02:58.132]                         if (exists("master", mode = "list", envir = envir, 
[11:02:58.132]                           inherits = FALSE)) {
[11:02:58.132]                           master <- get("master", mode = "list", 
[11:02:58.132]                             envir = envir, inherits = FALSE)
[11:02:58.132]                           if (inherits(master, c("SOCKnode", 
[11:02:58.132]                             "SOCK0node"))) {
[11:02:58.132]                             sendCondition <<- function(cond) {
[11:02:58.132]                               data <- list(type = "VALUE", value = cond, 
[11:02:58.132]                                 success = TRUE)
[11:02:58.132]                               parallel_sendData(master, data)
[11:02:58.132]                             }
[11:02:58.132]                             return(sendCondition)
[11:02:58.132]                           }
[11:02:58.132]                         }
[11:02:58.132]                         frame <- frame + 1L
[11:02:58.132]                         envir <- sys.frame(frame)
[11:02:58.132]                       }
[11:02:58.132]                     }
[11:02:58.132]                     sendCondition <<- function(cond) NULL
[11:02:58.132]                   }
[11:02:58.132]                 })
[11:02:58.132]                 withCallingHandlers({
[11:02:58.132]                   {
[11:02:58.132]                     1
[11:02:58.132]                   }
[11:02:58.132]                 }, immediateCondition = function(cond) {
[11:02:58.132]                   sendCondition <- ...future.makeSendCondition()
[11:02:58.132]                   sendCondition(cond)
[11:02:58.132]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:58.132]                   {
[11:02:58.132]                     inherits <- base::inherits
[11:02:58.132]                     invokeRestart <- base::invokeRestart
[11:02:58.132]                     is.null <- base::is.null
[11:02:58.132]                     muffled <- FALSE
[11:02:58.132]                     if (inherits(cond, "message")) {
[11:02:58.132]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:58.132]                       if (muffled) 
[11:02:58.132]                         invokeRestart("muffleMessage")
[11:02:58.132]                     }
[11:02:58.132]                     else if (inherits(cond, "warning")) {
[11:02:58.132]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:58.132]                       if (muffled) 
[11:02:58.132]                         invokeRestart("muffleWarning")
[11:02:58.132]                     }
[11:02:58.132]                     else if (inherits(cond, "condition")) {
[11:02:58.132]                       if (!is.null(pattern)) {
[11:02:58.132]                         computeRestarts <- base::computeRestarts
[11:02:58.132]                         grepl <- base::grepl
[11:02:58.132]                         restarts <- computeRestarts(cond)
[11:02:58.132]                         for (restart in restarts) {
[11:02:58.132]                           name <- restart$name
[11:02:58.132]                           if (is.null(name)) 
[11:02:58.132]                             next
[11:02:58.132]                           if (!grepl(pattern, name)) 
[11:02:58.132]                             next
[11:02:58.132]                           invokeRestart(restart)
[11:02:58.132]                           muffled <- TRUE
[11:02:58.132]                           break
[11:02:58.132]                         }
[11:02:58.132]                       }
[11:02:58.132]                     }
[11:02:58.132]                     invisible(muffled)
[11:02:58.132]                   }
[11:02:58.132]                   muffleCondition(cond)
[11:02:58.132]                 })
[11:02:58.132]             }))
[11:02:58.132]             future::FutureResult(value = ...future.value$value, 
[11:02:58.132]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:58.132]                   ...future.rng), globalenv = if (FALSE) 
[11:02:58.132]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:58.132]                     ...future.globalenv.names))
[11:02:58.132]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:58.132]         }, condition = base::local({
[11:02:58.132]             c <- base::c
[11:02:58.132]             inherits <- base::inherits
[11:02:58.132]             invokeRestart <- base::invokeRestart
[11:02:58.132]             length <- base::length
[11:02:58.132]             list <- base::list
[11:02:58.132]             seq.int <- base::seq.int
[11:02:58.132]             signalCondition <- base::signalCondition
[11:02:58.132]             sys.calls <- base::sys.calls
[11:02:58.132]             `[[` <- base::`[[`
[11:02:58.132]             `+` <- base::`+`
[11:02:58.132]             `<<-` <- base::`<<-`
[11:02:58.132]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:58.132]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:58.132]                   3L)]
[11:02:58.132]             }
[11:02:58.132]             function(cond) {
[11:02:58.132]                 is_error <- inherits(cond, "error")
[11:02:58.132]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:58.132]                   NULL)
[11:02:58.132]                 if (is_error) {
[11:02:58.132]                   sessionInformation <- function() {
[11:02:58.132]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:58.132]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:58.132]                       search = base::search(), system = base::Sys.info())
[11:02:58.132]                   }
[11:02:58.132]                   ...future.conditions[[length(...future.conditions) + 
[11:02:58.132]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:58.132]                     cond$call), session = sessionInformation(), 
[11:02:58.132]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:58.132]                   signalCondition(cond)
[11:02:58.132]                 }
[11:02:58.132]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:58.132]                 "immediateCondition"))) {
[11:02:58.132]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:58.132]                   ...future.conditions[[length(...future.conditions) + 
[11:02:58.132]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:58.132]                   if (TRUE && !signal) {
[11:02:58.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:58.132]                     {
[11:02:58.132]                       inherits <- base::inherits
[11:02:58.132]                       invokeRestart <- base::invokeRestart
[11:02:58.132]                       is.null <- base::is.null
[11:02:58.132]                       muffled <- FALSE
[11:02:58.132]                       if (inherits(cond, "message")) {
[11:02:58.132]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:58.132]                         if (muffled) 
[11:02:58.132]                           invokeRestart("muffleMessage")
[11:02:58.132]                       }
[11:02:58.132]                       else if (inherits(cond, "warning")) {
[11:02:58.132]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:58.132]                         if (muffled) 
[11:02:58.132]                           invokeRestart("muffleWarning")
[11:02:58.132]                       }
[11:02:58.132]                       else if (inherits(cond, "condition")) {
[11:02:58.132]                         if (!is.null(pattern)) {
[11:02:58.132]                           computeRestarts <- base::computeRestarts
[11:02:58.132]                           grepl <- base::grepl
[11:02:58.132]                           restarts <- computeRestarts(cond)
[11:02:58.132]                           for (restart in restarts) {
[11:02:58.132]                             name <- restart$name
[11:02:58.132]                             if (is.null(name)) 
[11:02:58.132]                               next
[11:02:58.132]                             if (!grepl(pattern, name)) 
[11:02:58.132]                               next
[11:02:58.132]                             invokeRestart(restart)
[11:02:58.132]                             muffled <- TRUE
[11:02:58.132]                             break
[11:02:58.132]                           }
[11:02:58.132]                         }
[11:02:58.132]                       }
[11:02:58.132]                       invisible(muffled)
[11:02:58.132]                     }
[11:02:58.132]                     muffleCondition(cond, pattern = "^muffle")
[11:02:58.132]                   }
[11:02:58.132]                 }
[11:02:58.132]                 else {
[11:02:58.132]                   if (TRUE) {
[11:02:58.132]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:58.132]                     {
[11:02:58.132]                       inherits <- base::inherits
[11:02:58.132]                       invokeRestart <- base::invokeRestart
[11:02:58.132]                       is.null <- base::is.null
[11:02:58.132]                       muffled <- FALSE
[11:02:58.132]                       if (inherits(cond, "message")) {
[11:02:58.132]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:58.132]                         if (muffled) 
[11:02:58.132]                           invokeRestart("muffleMessage")
[11:02:58.132]                       }
[11:02:58.132]                       else if (inherits(cond, "warning")) {
[11:02:58.132]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:58.132]                         if (muffled) 
[11:02:58.132]                           invokeRestart("muffleWarning")
[11:02:58.132]                       }
[11:02:58.132]                       else if (inherits(cond, "condition")) {
[11:02:58.132]                         if (!is.null(pattern)) {
[11:02:58.132]                           computeRestarts <- base::computeRestarts
[11:02:58.132]                           grepl <- base::grepl
[11:02:58.132]                           restarts <- computeRestarts(cond)
[11:02:58.132]                           for (restart in restarts) {
[11:02:58.132]                             name <- restart$name
[11:02:58.132]                             if (is.null(name)) 
[11:02:58.132]                               next
[11:02:58.132]                             if (!grepl(pattern, name)) 
[11:02:58.132]                               next
[11:02:58.132]                             invokeRestart(restart)
[11:02:58.132]                             muffled <- TRUE
[11:02:58.132]                             break
[11:02:58.132]                           }
[11:02:58.132]                         }
[11:02:58.132]                       }
[11:02:58.132]                       invisible(muffled)
[11:02:58.132]                     }
[11:02:58.132]                     muffleCondition(cond, pattern = "^muffle")
[11:02:58.132]                   }
[11:02:58.132]                 }
[11:02:58.132]             }
[11:02:58.132]         }))
[11:02:58.132]     }, error = function(ex) {
[11:02:58.132]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:58.132]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:58.132]                 ...future.rng), started = ...future.startTime, 
[11:02:58.132]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:58.132]             version = "1.8"), class = "FutureResult")
[11:02:58.132]     }, finally = {
[11:02:58.132]         if (!identical(...future.workdir, getwd())) 
[11:02:58.132]             setwd(...future.workdir)
[11:02:58.132]         {
[11:02:58.132]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:58.132]                 ...future.oldOptions$nwarnings <- NULL
[11:02:58.132]             }
[11:02:58.132]             base::options(...future.oldOptions)
[11:02:58.132]             if (.Platform$OS.type == "windows") {
[11:02:58.132]                 old_names <- names(...future.oldEnvVars)
[11:02:58.132]                 envs <- base::Sys.getenv()
[11:02:58.132]                 names <- names(envs)
[11:02:58.132]                 common <- intersect(names, old_names)
[11:02:58.132]                 added <- setdiff(names, old_names)
[11:02:58.132]                 removed <- setdiff(old_names, names)
[11:02:58.132]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:58.132]                   envs[common]]
[11:02:58.132]                 NAMES <- toupper(changed)
[11:02:58.132]                 args <- list()
[11:02:58.132]                 for (kk in seq_along(NAMES)) {
[11:02:58.132]                   name <- changed[[kk]]
[11:02:58.132]                   NAME <- NAMES[[kk]]
[11:02:58.132]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:58.132]                     next
[11:02:58.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:58.132]                 }
[11:02:58.132]                 NAMES <- toupper(added)
[11:02:58.132]                 for (kk in seq_along(NAMES)) {
[11:02:58.132]                   name <- added[[kk]]
[11:02:58.132]                   NAME <- NAMES[[kk]]
[11:02:58.132]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:58.132]                     next
[11:02:58.132]                   args[[name]] <- ""
[11:02:58.132]                 }
[11:02:58.132]                 NAMES <- toupper(removed)
[11:02:58.132]                 for (kk in seq_along(NAMES)) {
[11:02:58.132]                   name <- removed[[kk]]
[11:02:58.132]                   NAME <- NAMES[[kk]]
[11:02:58.132]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:58.132]                     next
[11:02:58.132]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:58.132]                 }
[11:02:58.132]                 if (length(args) > 0) 
[11:02:58.132]                   base::do.call(base::Sys.setenv, args = args)
[11:02:58.132]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:58.132]             }
[11:02:58.132]             else {
[11:02:58.132]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:58.132]             }
[11:02:58.132]             {
[11:02:58.132]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:58.132]                   0L) {
[11:02:58.132]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:58.132]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:58.132]                   base::options(opts)
[11:02:58.132]                 }
[11:02:58.132]                 {
[11:02:58.132]                   {
[11:02:58.132]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:58.132]                     NULL
[11:02:58.132]                   }
[11:02:58.132]                   options(future.plan = NULL)
[11:02:58.132]                   if (is.na(NA_character_)) 
[11:02:58.132]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:58.132]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:58.132]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:58.132]                     .init = FALSE)
[11:02:58.132]                 }
[11:02:58.132]             }
[11:02:58.132]         }
[11:02:58.132]     })
[11:02:58.132]     if (TRUE) {
[11:02:58.132]         base::sink(type = "output", split = FALSE)
[11:02:58.132]         if (TRUE) {
[11:02:58.132]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:58.132]         }
[11:02:58.132]         else {
[11:02:58.132]             ...future.result["stdout"] <- base::list(NULL)
[11:02:58.132]         }
[11:02:58.132]         base::close(...future.stdout)
[11:02:58.132]         ...future.stdout <- NULL
[11:02:58.132]     }
[11:02:58.132]     ...future.result$conditions <- ...future.conditions
[11:02:58.132]     ...future.result$finished <- base::Sys.time()
[11:02:58.132]     ...future.result
[11:02:58.132] }
[11:02:58.135] MultisessionFuture started
[11:02:58.135] - Launch lazy future ... done
[11:02:58.136] run() for ‘MultisessionFuture’ ... done
[11:02:58.136] getGlobalsAndPackages() ...
[11:02:58.136] Searching for globals...
[11:02:58.136] - globals found: [1] ‘{’
[11:02:58.137] Searching for globals ... DONE
[11:02:58.137] Resolving globals: FALSE
[11:02:58.137] 
[11:02:58.137] 
[11:02:58.137] getGlobalsAndPackages() ... DONE
[11:02:58.137] run() for ‘Future’ ...
[11:02:58.137] - state: ‘created’
[11:02:58.137] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:58.152] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:58.152] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:58.152]   - Field: ‘node’
[11:02:58.152]   - Field: ‘label’
[11:02:58.152]   - Field: ‘local’
[11:02:58.152]   - Field: ‘owner’
[11:02:58.152]   - Field: ‘envir’
[11:02:58.152]   - Field: ‘workers’
[11:02:58.152]   - Field: ‘packages’
[11:02:58.153]   - Field: ‘gc’
[11:02:58.153]   - Field: ‘conditions’
[11:02:58.153]   - Field: ‘persistent’
[11:02:58.153]   - Field: ‘expr’
[11:02:58.153]   - Field: ‘uuid’
[11:02:58.153]   - Field: ‘seed’
[11:02:58.153]   - Field: ‘version’
[11:02:58.153]   - Field: ‘result’
[11:02:58.153]   - Field: ‘asynchronous’
[11:02:58.153]   - Field: ‘calls’
[11:02:58.153]   - Field: ‘globals’
[11:02:58.154]   - Field: ‘stdout’
[11:02:58.154]   - Field: ‘earlySignal’
[11:02:58.154]   - Field: ‘lazy’
[11:02:58.154]   - Field: ‘state’
[11:02:58.154] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:58.154] - Launch lazy future ...
[11:02:58.154] Packages needed by the future expression (n = 0): <none>
[11:02:58.154] Packages needed by future strategies (n = 0): <none>
[11:02:58.155] {
[11:02:58.155]     {
[11:02:58.155]         {
[11:02:58.155]             ...future.startTime <- base::Sys.time()
[11:02:58.155]             {
[11:02:58.155]                 {
[11:02:58.155]                   {
[11:02:58.155]                     {
[11:02:58.155]                       base::local({
[11:02:58.155]                         has_future <- base::requireNamespace("future", 
[11:02:58.155]                           quietly = TRUE)
[11:02:58.155]                         if (has_future) {
[11:02:58.155]                           ns <- base::getNamespace("future")
[11:02:58.155]                           version <- ns[[".package"]][["version"]]
[11:02:58.155]                           if (is.null(version)) 
[11:02:58.155]                             version <- utils::packageVersion("future")
[11:02:58.155]                         }
[11:02:58.155]                         else {
[11:02:58.155]                           version <- NULL
[11:02:58.155]                         }
[11:02:58.155]                         if (!has_future || version < "1.8.0") {
[11:02:58.155]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:58.155]                             "", base::R.version$version.string), 
[11:02:58.155]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:58.155]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:58.155]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:58.155]                               "release", "version")], collapse = " "), 
[11:02:58.155]                             hostname = base::Sys.info()[["nodename"]])
[11:02:58.155]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:58.155]                             info)
[11:02:58.155]                           info <- base::paste(info, collapse = "; ")
[11:02:58.155]                           if (!has_future) {
[11:02:58.155]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:58.155]                               info)
[11:02:58.155]                           }
[11:02:58.155]                           else {
[11:02:58.155]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:58.155]                               info, version)
[11:02:58.155]                           }
[11:02:58.155]                           base::stop(msg)
[11:02:58.155]                         }
[11:02:58.155]                       })
[11:02:58.155]                     }
[11:02:58.155]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:58.155]                     base::options(mc.cores = 1L)
[11:02:58.155]                   }
[11:02:58.155]                   ...future.strategy.old <- future::plan("list")
[11:02:58.155]                   options(future.plan = NULL)
[11:02:58.155]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:58.155]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:58.155]                 }
[11:02:58.155]                 ...future.workdir <- getwd()
[11:02:58.155]             }
[11:02:58.155]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:58.155]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:58.155]         }
[11:02:58.155]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:58.155]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:58.155]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:58.155]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:58.155]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:58.155]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:58.155]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:58.155]             base::names(...future.oldOptions))
[11:02:58.155]     }
[11:02:58.155]     if (FALSE) {
[11:02:58.155]     }
[11:02:58.155]     else {
[11:02:58.155]         if (TRUE) {
[11:02:58.155]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:58.155]                 open = "w")
[11:02:58.155]         }
[11:02:58.155]         else {
[11:02:58.155]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:58.155]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:58.155]         }
[11:02:58.155]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:58.155]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:58.155]             base::sink(type = "output", split = FALSE)
[11:02:58.155]             base::close(...future.stdout)
[11:02:58.155]         }, add = TRUE)
[11:02:58.155]     }
[11:02:58.155]     ...future.frame <- base::sys.nframe()
[11:02:58.155]     ...future.conditions <- base::list()
[11:02:58.155]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:58.155]     if (FALSE) {
[11:02:58.155]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:58.155]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:58.155]     }
[11:02:58.155]     ...future.result <- base::tryCatch({
[11:02:58.155]         base::withCallingHandlers({
[11:02:58.155]             ...future.value <- base::withVisible(base::local({
[11:02:58.155]                 ...future.makeSendCondition <- base::local({
[11:02:58.155]                   sendCondition <- NULL
[11:02:58.155]                   function(frame = 1L) {
[11:02:58.155]                     if (is.function(sendCondition)) 
[11:02:58.155]                       return(sendCondition)
[11:02:58.155]                     ns <- getNamespace("parallel")
[11:02:58.155]                     if (exists("sendData", mode = "function", 
[11:02:58.155]                       envir = ns)) {
[11:02:58.155]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:58.155]                         envir = ns)
[11:02:58.155]                       envir <- sys.frame(frame)
[11:02:58.155]                       master <- NULL
[11:02:58.155]                       while (!identical(envir, .GlobalEnv) && 
[11:02:58.155]                         !identical(envir, emptyenv())) {
[11:02:58.155]                         if (exists("master", mode = "list", envir = envir, 
[11:02:58.155]                           inherits = FALSE)) {
[11:02:58.155]                           master <- get("master", mode = "list", 
[11:02:58.155]                             envir = envir, inherits = FALSE)
[11:02:58.155]                           if (inherits(master, c("SOCKnode", 
[11:02:58.155]                             "SOCK0node"))) {
[11:02:58.155]                             sendCondition <<- function(cond) {
[11:02:58.155]                               data <- list(type = "VALUE", value = cond, 
[11:02:58.155]                                 success = TRUE)
[11:02:58.155]                               parallel_sendData(master, data)
[11:02:58.155]                             }
[11:02:58.155]                             return(sendCondition)
[11:02:58.155]                           }
[11:02:58.155]                         }
[11:02:58.155]                         frame <- frame + 1L
[11:02:58.155]                         envir <- sys.frame(frame)
[11:02:58.155]                       }
[11:02:58.155]                     }
[11:02:58.155]                     sendCondition <<- function(cond) NULL
[11:02:58.155]                   }
[11:02:58.155]                 })
[11:02:58.155]                 withCallingHandlers({
[11:02:58.155]                   {
[11:02:58.155]                     2
[11:02:58.155]                   }
[11:02:58.155]                 }, immediateCondition = function(cond) {
[11:02:58.155]                   sendCondition <- ...future.makeSendCondition()
[11:02:58.155]                   sendCondition(cond)
[11:02:58.155]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:58.155]                   {
[11:02:58.155]                     inherits <- base::inherits
[11:02:58.155]                     invokeRestart <- base::invokeRestart
[11:02:58.155]                     is.null <- base::is.null
[11:02:58.155]                     muffled <- FALSE
[11:02:58.155]                     if (inherits(cond, "message")) {
[11:02:58.155]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:58.155]                       if (muffled) 
[11:02:58.155]                         invokeRestart("muffleMessage")
[11:02:58.155]                     }
[11:02:58.155]                     else if (inherits(cond, "warning")) {
[11:02:58.155]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:58.155]                       if (muffled) 
[11:02:58.155]                         invokeRestart("muffleWarning")
[11:02:58.155]                     }
[11:02:58.155]                     else if (inherits(cond, "condition")) {
[11:02:58.155]                       if (!is.null(pattern)) {
[11:02:58.155]                         computeRestarts <- base::computeRestarts
[11:02:58.155]                         grepl <- base::grepl
[11:02:58.155]                         restarts <- computeRestarts(cond)
[11:02:58.155]                         for (restart in restarts) {
[11:02:58.155]                           name <- restart$name
[11:02:58.155]                           if (is.null(name)) 
[11:02:58.155]                             next
[11:02:58.155]                           if (!grepl(pattern, name)) 
[11:02:58.155]                             next
[11:02:58.155]                           invokeRestart(restart)
[11:02:58.155]                           muffled <- TRUE
[11:02:58.155]                           break
[11:02:58.155]                         }
[11:02:58.155]                       }
[11:02:58.155]                     }
[11:02:58.155]                     invisible(muffled)
[11:02:58.155]                   }
[11:02:58.155]                   muffleCondition(cond)
[11:02:58.155]                 })
[11:02:58.155]             }))
[11:02:58.155]             future::FutureResult(value = ...future.value$value, 
[11:02:58.155]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:58.155]                   ...future.rng), globalenv = if (FALSE) 
[11:02:58.155]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:58.155]                     ...future.globalenv.names))
[11:02:58.155]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:58.155]         }, condition = base::local({
[11:02:58.155]             c <- base::c
[11:02:58.155]             inherits <- base::inherits
[11:02:58.155]             invokeRestart <- base::invokeRestart
[11:02:58.155]             length <- base::length
[11:02:58.155]             list <- base::list
[11:02:58.155]             seq.int <- base::seq.int
[11:02:58.155]             signalCondition <- base::signalCondition
[11:02:58.155]             sys.calls <- base::sys.calls
[11:02:58.155]             `[[` <- base::`[[`
[11:02:58.155]             `+` <- base::`+`
[11:02:58.155]             `<<-` <- base::`<<-`
[11:02:58.155]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:58.155]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:58.155]                   3L)]
[11:02:58.155]             }
[11:02:58.155]             function(cond) {
[11:02:58.155]                 is_error <- inherits(cond, "error")
[11:02:58.155]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:58.155]                   NULL)
[11:02:58.155]                 if (is_error) {
[11:02:58.155]                   sessionInformation <- function() {
[11:02:58.155]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:58.155]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:58.155]                       search = base::search(), system = base::Sys.info())
[11:02:58.155]                   }
[11:02:58.155]                   ...future.conditions[[length(...future.conditions) + 
[11:02:58.155]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:58.155]                     cond$call), session = sessionInformation(), 
[11:02:58.155]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:58.155]                   signalCondition(cond)
[11:02:58.155]                 }
[11:02:58.155]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:58.155]                 "immediateCondition"))) {
[11:02:58.155]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:58.155]                   ...future.conditions[[length(...future.conditions) + 
[11:02:58.155]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:58.155]                   if (TRUE && !signal) {
[11:02:58.155]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:58.155]                     {
[11:02:58.155]                       inherits <- base::inherits
[11:02:58.155]                       invokeRestart <- base::invokeRestart
[11:02:58.155]                       is.null <- base::is.null
[11:02:58.155]                       muffled <- FALSE
[11:02:58.155]                       if (inherits(cond, "message")) {
[11:02:58.155]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:58.155]                         if (muffled) 
[11:02:58.155]                           invokeRestart("muffleMessage")
[11:02:58.155]                       }
[11:02:58.155]                       else if (inherits(cond, "warning")) {
[11:02:58.155]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:58.155]                         if (muffled) 
[11:02:58.155]                           invokeRestart("muffleWarning")
[11:02:58.155]                       }
[11:02:58.155]                       else if (inherits(cond, "condition")) {
[11:02:58.155]                         if (!is.null(pattern)) {
[11:02:58.155]                           computeRestarts <- base::computeRestarts
[11:02:58.155]                           grepl <- base::grepl
[11:02:58.155]                           restarts <- computeRestarts(cond)
[11:02:58.155]                           for (restart in restarts) {
[11:02:58.155]                             name <- restart$name
[11:02:58.155]                             if (is.null(name)) 
[11:02:58.155]                               next
[11:02:58.155]                             if (!grepl(pattern, name)) 
[11:02:58.155]                               next
[11:02:58.155]                             invokeRestart(restart)
[11:02:58.155]                             muffled <- TRUE
[11:02:58.155]                             break
[11:02:58.155]                           }
[11:02:58.155]                         }
[11:02:58.155]                       }
[11:02:58.155]                       invisible(muffled)
[11:02:58.155]                     }
[11:02:58.155]                     muffleCondition(cond, pattern = "^muffle")
[11:02:58.155]                   }
[11:02:58.155]                 }
[11:02:58.155]                 else {
[11:02:58.155]                   if (TRUE) {
[11:02:58.155]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:58.155]                     {
[11:02:58.155]                       inherits <- base::inherits
[11:02:58.155]                       invokeRestart <- base::invokeRestart
[11:02:58.155]                       is.null <- base::is.null
[11:02:58.155]                       muffled <- FALSE
[11:02:58.155]                       if (inherits(cond, "message")) {
[11:02:58.155]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:58.155]                         if (muffled) 
[11:02:58.155]                           invokeRestart("muffleMessage")
[11:02:58.155]                       }
[11:02:58.155]                       else if (inherits(cond, "warning")) {
[11:02:58.155]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:58.155]                         if (muffled) 
[11:02:58.155]                           invokeRestart("muffleWarning")
[11:02:58.155]                       }
[11:02:58.155]                       else if (inherits(cond, "condition")) {
[11:02:58.155]                         if (!is.null(pattern)) {
[11:02:58.155]                           computeRestarts <- base::computeRestarts
[11:02:58.155]                           grepl <- base::grepl
[11:02:58.155]                           restarts <- computeRestarts(cond)
[11:02:58.155]                           for (restart in restarts) {
[11:02:58.155]                             name <- restart$name
[11:02:58.155]                             if (is.null(name)) 
[11:02:58.155]                               next
[11:02:58.155]                             if (!grepl(pattern, name)) 
[11:02:58.155]                               next
[11:02:58.155]                             invokeRestart(restart)
[11:02:58.155]                             muffled <- TRUE
[11:02:58.155]                             break
[11:02:58.155]                           }
[11:02:58.155]                         }
[11:02:58.155]                       }
[11:02:58.155]                       invisible(muffled)
[11:02:58.155]                     }
[11:02:58.155]                     muffleCondition(cond, pattern = "^muffle")
[11:02:58.155]                   }
[11:02:58.155]                 }
[11:02:58.155]             }
[11:02:58.155]         }))
[11:02:58.155]     }, error = function(ex) {
[11:02:58.155]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:58.155]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:58.155]                 ...future.rng), started = ...future.startTime, 
[11:02:58.155]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:58.155]             version = "1.8"), class = "FutureResult")
[11:02:58.155]     }, finally = {
[11:02:58.155]         if (!identical(...future.workdir, getwd())) 
[11:02:58.155]             setwd(...future.workdir)
[11:02:58.155]         {
[11:02:58.155]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:58.155]                 ...future.oldOptions$nwarnings <- NULL
[11:02:58.155]             }
[11:02:58.155]             base::options(...future.oldOptions)
[11:02:58.155]             if (.Platform$OS.type == "windows") {
[11:02:58.155]                 old_names <- names(...future.oldEnvVars)
[11:02:58.155]                 envs <- base::Sys.getenv()
[11:02:58.155]                 names <- names(envs)
[11:02:58.155]                 common <- intersect(names, old_names)
[11:02:58.155]                 added <- setdiff(names, old_names)
[11:02:58.155]                 removed <- setdiff(old_names, names)
[11:02:58.155]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:58.155]                   envs[common]]
[11:02:58.155]                 NAMES <- toupper(changed)
[11:02:58.155]                 args <- list()
[11:02:58.155]                 for (kk in seq_along(NAMES)) {
[11:02:58.155]                   name <- changed[[kk]]
[11:02:58.155]                   NAME <- NAMES[[kk]]
[11:02:58.155]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:58.155]                     next
[11:02:58.155]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:58.155]                 }
[11:02:58.155]                 NAMES <- toupper(added)
[11:02:58.155]                 for (kk in seq_along(NAMES)) {
[11:02:58.155]                   name <- added[[kk]]
[11:02:58.155]                   NAME <- NAMES[[kk]]
[11:02:58.155]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:58.155]                     next
[11:02:58.155]                   args[[name]] <- ""
[11:02:58.155]                 }
[11:02:58.155]                 NAMES <- toupper(removed)
[11:02:58.155]                 for (kk in seq_along(NAMES)) {
[11:02:58.155]                   name <- removed[[kk]]
[11:02:58.155]                   NAME <- NAMES[[kk]]
[11:02:58.155]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:58.155]                     next
[11:02:58.155]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:58.155]                 }
[11:02:58.155]                 if (length(args) > 0) 
[11:02:58.155]                   base::do.call(base::Sys.setenv, args = args)
[11:02:58.155]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:58.155]             }
[11:02:58.155]             else {
[11:02:58.155]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:58.155]             }
[11:02:58.155]             {
[11:02:58.155]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:58.155]                   0L) {
[11:02:58.155]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:58.155]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:58.155]                   base::options(opts)
[11:02:58.155]                 }
[11:02:58.155]                 {
[11:02:58.155]                   {
[11:02:58.155]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:58.155]                     NULL
[11:02:58.155]                   }
[11:02:58.155]                   options(future.plan = NULL)
[11:02:58.155]                   if (is.na(NA_character_)) 
[11:02:58.155]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:58.155]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:58.155]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:58.155]                     .init = FALSE)
[11:02:58.155]                 }
[11:02:58.155]             }
[11:02:58.155]         }
[11:02:58.155]     })
[11:02:58.155]     if (TRUE) {
[11:02:58.155]         base::sink(type = "output", split = FALSE)
[11:02:58.155]         if (TRUE) {
[11:02:58.155]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:58.155]         }
[11:02:58.155]         else {
[11:02:58.155]             ...future.result["stdout"] <- base::list(NULL)
[11:02:58.155]         }
[11:02:58.155]         base::close(...future.stdout)
[11:02:58.155]         ...future.stdout <- NULL
[11:02:58.155]     }
[11:02:58.155]     ...future.result$conditions <- ...future.conditions
[11:02:58.155]     ...future.result$finished <- base::Sys.time()
[11:02:58.155]     ...future.result
[11:02:58.155] }
[11:02:58.158] MultisessionFuture started
[11:02:58.158] - Launch lazy future ... done
[11:02:58.158] run() for ‘MultisessionFuture’ ... done
[11:02:58.158] resolve() on environment ...
[11:02:58.158]  recursive: 0
[11:02:58.159]  elements: [3] ‘.future_a’, ‘.future_b’, ‘a’, ‘b’, ‘c’
[11:02:58.180]  length: 2 (resolved future 3)
[11:02:58.191] receiveMessageFromWorker() for ClusterFuture ...
[11:02:58.191] - Validating connection of MultisessionFuture
[11:02:58.191] - received message: FutureResult
[11:02:58.191] - Received FutureResult
[11:02:58.191] - Erased future from FutureRegistry
[11:02:58.191] result() for ClusterFuture ...
[11:02:58.191] - result already collected: FutureResult
[11:02:58.191] result() for ClusterFuture ... done
[11:02:58.191] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:58.192] Future #1
[11:02:58.192]  length: 1 (resolved future 1)
[11:02:58.199] receiveMessageFromWorker() for ClusterFuture ...
[11:02:58.199] - Validating connection of MultisessionFuture
[11:02:58.199] - received message: FutureResult
[11:02:58.199] - Received FutureResult
[11:02:58.200] - Erased future from FutureRegistry
[11:02:58.200] result() for ClusterFuture ...
[11:02:58.200] - result already collected: FutureResult
[11:02:58.200] result() for ClusterFuture ... done
[11:02:58.200] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:58.200] Future #2
[11:02:58.200]  length: 0 (resolved future 2)
[11:02:58.200] resolve() on environment ... DONE
[11:02:58.201] getGlobalsAndPackages() ...
[11:02:58.201] Searching for globals...
[11:02:58.201] - globals found: [1] ‘{’
[11:02:58.201] Searching for globals ... DONE
[11:02:58.201] Resolving globals: FALSE
[11:02:58.202] 
[11:02:58.202] 
[11:02:58.202] getGlobalsAndPackages() ... DONE
[11:02:58.202] run() for ‘Future’ ...
[11:02:58.202] - state: ‘created’
[11:02:58.202] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:58.216] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:58.216] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:58.216]   - Field: ‘node’
[11:02:58.216]   - Field: ‘label’
[11:02:58.216]   - Field: ‘local’
[11:02:58.216]   - Field: ‘owner’
[11:02:58.216]   - Field: ‘envir’
[11:02:58.216]   - Field: ‘workers’
[11:02:58.216]   - Field: ‘packages’
[11:02:58.217]   - Field: ‘gc’
[11:02:58.217]   - Field: ‘conditions’
[11:02:58.217]   - Field: ‘persistent’
[11:02:58.217]   - Field: ‘expr’
[11:02:58.217]   - Field: ‘uuid’
[11:02:58.217]   - Field: ‘seed’
[11:02:58.217]   - Field: ‘version’
[11:02:58.217]   - Field: ‘result’
[11:02:58.217]   - Field: ‘asynchronous’
[11:02:58.217]   - Field: ‘calls’
[11:02:58.217]   - Field: ‘globals’
[11:02:58.217]   - Field: ‘stdout’
[11:02:58.218]   - Field: ‘earlySignal’
[11:02:58.218]   - Field: ‘lazy’
[11:02:58.218]   - Field: ‘state’
[11:02:58.218] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:58.218] - Launch lazy future ...
[11:02:58.218] Packages needed by the future expression (n = 0): <none>
[11:02:58.218] Packages needed by future strategies (n = 0): <none>
[11:02:58.219] {
[11:02:58.219]     {
[11:02:58.219]         {
[11:02:58.219]             ...future.startTime <- base::Sys.time()
[11:02:58.219]             {
[11:02:58.219]                 {
[11:02:58.219]                   {
[11:02:58.219]                     {
[11:02:58.219]                       base::local({
[11:02:58.219]                         has_future <- base::requireNamespace("future", 
[11:02:58.219]                           quietly = TRUE)
[11:02:58.219]                         if (has_future) {
[11:02:58.219]                           ns <- base::getNamespace("future")
[11:02:58.219]                           version <- ns[[".package"]][["version"]]
[11:02:58.219]                           if (is.null(version)) 
[11:02:58.219]                             version <- utils::packageVersion("future")
[11:02:58.219]                         }
[11:02:58.219]                         else {
[11:02:58.219]                           version <- NULL
[11:02:58.219]                         }
[11:02:58.219]                         if (!has_future || version < "1.8.0") {
[11:02:58.219]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:58.219]                             "", base::R.version$version.string), 
[11:02:58.219]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:58.219]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:58.219]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:58.219]                               "release", "version")], collapse = " "), 
[11:02:58.219]                             hostname = base::Sys.info()[["nodename"]])
[11:02:58.219]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:58.219]                             info)
[11:02:58.219]                           info <- base::paste(info, collapse = "; ")
[11:02:58.219]                           if (!has_future) {
[11:02:58.219]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:58.219]                               info)
[11:02:58.219]                           }
[11:02:58.219]                           else {
[11:02:58.219]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:58.219]                               info, version)
[11:02:58.219]                           }
[11:02:58.219]                           base::stop(msg)
[11:02:58.219]                         }
[11:02:58.219]                       })
[11:02:58.219]                     }
[11:02:58.219]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:58.219]                     base::options(mc.cores = 1L)
[11:02:58.219]                   }
[11:02:58.219]                   ...future.strategy.old <- future::plan("list")
[11:02:58.219]                   options(future.plan = NULL)
[11:02:58.219]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:58.219]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:58.219]                 }
[11:02:58.219]                 ...future.workdir <- getwd()
[11:02:58.219]             }
[11:02:58.219]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:58.219]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:58.219]         }
[11:02:58.219]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:58.219]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:58.219]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:58.219]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:58.219]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:58.219]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:58.219]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:58.219]             base::names(...future.oldOptions))
[11:02:58.219]     }
[11:02:58.219]     if (FALSE) {
[11:02:58.219]     }
[11:02:58.219]     else {
[11:02:58.219]         if (TRUE) {
[11:02:58.219]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:58.219]                 open = "w")
[11:02:58.219]         }
[11:02:58.219]         else {
[11:02:58.219]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:58.219]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:58.219]         }
[11:02:58.219]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:58.219]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:58.219]             base::sink(type = "output", split = FALSE)
[11:02:58.219]             base::close(...future.stdout)
[11:02:58.219]         }, add = TRUE)
[11:02:58.219]     }
[11:02:58.219]     ...future.frame <- base::sys.nframe()
[11:02:58.219]     ...future.conditions <- base::list()
[11:02:58.219]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:58.219]     if (FALSE) {
[11:02:58.219]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:58.219]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:58.219]     }
[11:02:58.219]     ...future.result <- base::tryCatch({
[11:02:58.219]         base::withCallingHandlers({
[11:02:58.219]             ...future.value <- base::withVisible(base::local({
[11:02:58.219]                 ...future.makeSendCondition <- base::local({
[11:02:58.219]                   sendCondition <- NULL
[11:02:58.219]                   function(frame = 1L) {
[11:02:58.219]                     if (is.function(sendCondition)) 
[11:02:58.219]                       return(sendCondition)
[11:02:58.219]                     ns <- getNamespace("parallel")
[11:02:58.219]                     if (exists("sendData", mode = "function", 
[11:02:58.219]                       envir = ns)) {
[11:02:58.219]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:58.219]                         envir = ns)
[11:02:58.219]                       envir <- sys.frame(frame)
[11:02:58.219]                       master <- NULL
[11:02:58.219]                       while (!identical(envir, .GlobalEnv) && 
[11:02:58.219]                         !identical(envir, emptyenv())) {
[11:02:58.219]                         if (exists("master", mode = "list", envir = envir, 
[11:02:58.219]                           inherits = FALSE)) {
[11:02:58.219]                           master <- get("master", mode = "list", 
[11:02:58.219]                             envir = envir, inherits = FALSE)
[11:02:58.219]                           if (inherits(master, c("SOCKnode", 
[11:02:58.219]                             "SOCK0node"))) {
[11:02:58.219]                             sendCondition <<- function(cond) {
[11:02:58.219]                               data <- list(type = "VALUE", value = cond, 
[11:02:58.219]                                 success = TRUE)
[11:02:58.219]                               parallel_sendData(master, data)
[11:02:58.219]                             }
[11:02:58.219]                             return(sendCondition)
[11:02:58.219]                           }
[11:02:58.219]                         }
[11:02:58.219]                         frame <- frame + 1L
[11:02:58.219]                         envir <- sys.frame(frame)
[11:02:58.219]                       }
[11:02:58.219]                     }
[11:02:58.219]                     sendCondition <<- function(cond) NULL
[11:02:58.219]                   }
[11:02:58.219]                 })
[11:02:58.219]                 withCallingHandlers({
[11:02:58.219]                   {
[11:02:58.219]                     1
[11:02:58.219]                   }
[11:02:58.219]                 }, immediateCondition = function(cond) {
[11:02:58.219]                   sendCondition <- ...future.makeSendCondition()
[11:02:58.219]                   sendCondition(cond)
[11:02:58.219]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:58.219]                   {
[11:02:58.219]                     inherits <- base::inherits
[11:02:58.219]                     invokeRestart <- base::invokeRestart
[11:02:58.219]                     is.null <- base::is.null
[11:02:58.219]                     muffled <- FALSE
[11:02:58.219]                     if (inherits(cond, "message")) {
[11:02:58.219]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:58.219]                       if (muffled) 
[11:02:58.219]                         invokeRestart("muffleMessage")
[11:02:58.219]                     }
[11:02:58.219]                     else if (inherits(cond, "warning")) {
[11:02:58.219]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:58.219]                       if (muffled) 
[11:02:58.219]                         invokeRestart("muffleWarning")
[11:02:58.219]                     }
[11:02:58.219]                     else if (inherits(cond, "condition")) {
[11:02:58.219]                       if (!is.null(pattern)) {
[11:02:58.219]                         computeRestarts <- base::computeRestarts
[11:02:58.219]                         grepl <- base::grepl
[11:02:58.219]                         restarts <- computeRestarts(cond)
[11:02:58.219]                         for (restart in restarts) {
[11:02:58.219]                           name <- restart$name
[11:02:58.219]                           if (is.null(name)) 
[11:02:58.219]                             next
[11:02:58.219]                           if (!grepl(pattern, name)) 
[11:02:58.219]                             next
[11:02:58.219]                           invokeRestart(restart)
[11:02:58.219]                           muffled <- TRUE
[11:02:58.219]                           break
[11:02:58.219]                         }
[11:02:58.219]                       }
[11:02:58.219]                     }
[11:02:58.219]                     invisible(muffled)
[11:02:58.219]                   }
[11:02:58.219]                   muffleCondition(cond)
[11:02:58.219]                 })
[11:02:58.219]             }))
[11:02:58.219]             future::FutureResult(value = ...future.value$value, 
[11:02:58.219]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:58.219]                   ...future.rng), globalenv = if (FALSE) 
[11:02:58.219]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:58.219]                     ...future.globalenv.names))
[11:02:58.219]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:58.219]         }, condition = base::local({
[11:02:58.219]             c <- base::c
[11:02:58.219]             inherits <- base::inherits
[11:02:58.219]             invokeRestart <- base::invokeRestart
[11:02:58.219]             length <- base::length
[11:02:58.219]             list <- base::list
[11:02:58.219]             seq.int <- base::seq.int
[11:02:58.219]             signalCondition <- base::signalCondition
[11:02:58.219]             sys.calls <- base::sys.calls
[11:02:58.219]             `[[` <- base::`[[`
[11:02:58.219]             `+` <- base::`+`
[11:02:58.219]             `<<-` <- base::`<<-`
[11:02:58.219]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:58.219]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:58.219]                   3L)]
[11:02:58.219]             }
[11:02:58.219]             function(cond) {
[11:02:58.219]                 is_error <- inherits(cond, "error")
[11:02:58.219]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:58.219]                   NULL)
[11:02:58.219]                 if (is_error) {
[11:02:58.219]                   sessionInformation <- function() {
[11:02:58.219]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:58.219]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:58.219]                       search = base::search(), system = base::Sys.info())
[11:02:58.219]                   }
[11:02:58.219]                   ...future.conditions[[length(...future.conditions) + 
[11:02:58.219]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:58.219]                     cond$call), session = sessionInformation(), 
[11:02:58.219]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:58.219]                   signalCondition(cond)
[11:02:58.219]                 }
[11:02:58.219]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:58.219]                 "immediateCondition"))) {
[11:02:58.219]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:58.219]                   ...future.conditions[[length(...future.conditions) + 
[11:02:58.219]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:58.219]                   if (TRUE && !signal) {
[11:02:58.219]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:58.219]                     {
[11:02:58.219]                       inherits <- base::inherits
[11:02:58.219]                       invokeRestart <- base::invokeRestart
[11:02:58.219]                       is.null <- base::is.null
[11:02:58.219]                       muffled <- FALSE
[11:02:58.219]                       if (inherits(cond, "message")) {
[11:02:58.219]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:58.219]                         if (muffled) 
[11:02:58.219]                           invokeRestart("muffleMessage")
[11:02:58.219]                       }
[11:02:58.219]                       else if (inherits(cond, "warning")) {
[11:02:58.219]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:58.219]                         if (muffled) 
[11:02:58.219]                           invokeRestart("muffleWarning")
[11:02:58.219]                       }
[11:02:58.219]                       else if (inherits(cond, "condition")) {
[11:02:58.219]                         if (!is.null(pattern)) {
[11:02:58.219]                           computeRestarts <- base::computeRestarts
[11:02:58.219]                           grepl <- base::grepl
[11:02:58.219]                           restarts <- computeRestarts(cond)
[11:02:58.219]                           for (restart in restarts) {
[11:02:58.219]                             name <- restart$name
[11:02:58.219]                             if (is.null(name)) 
[11:02:58.219]                               next
[11:02:58.219]                             if (!grepl(pattern, name)) 
[11:02:58.219]                               next
[11:02:58.219]                             invokeRestart(restart)
[11:02:58.219]                             muffled <- TRUE
[11:02:58.219]                             break
[11:02:58.219]                           }
[11:02:58.219]                         }
[11:02:58.219]                       }
[11:02:58.219]                       invisible(muffled)
[11:02:58.219]                     }
[11:02:58.219]                     muffleCondition(cond, pattern = "^muffle")
[11:02:58.219]                   }
[11:02:58.219]                 }
[11:02:58.219]                 else {
[11:02:58.219]                   if (TRUE) {
[11:02:58.219]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:58.219]                     {
[11:02:58.219]                       inherits <- base::inherits
[11:02:58.219]                       invokeRestart <- base::invokeRestart
[11:02:58.219]                       is.null <- base::is.null
[11:02:58.219]                       muffled <- FALSE
[11:02:58.219]                       if (inherits(cond, "message")) {
[11:02:58.219]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:58.219]                         if (muffled) 
[11:02:58.219]                           invokeRestart("muffleMessage")
[11:02:58.219]                       }
[11:02:58.219]                       else if (inherits(cond, "warning")) {
[11:02:58.219]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:58.219]                         if (muffled) 
[11:02:58.219]                           invokeRestart("muffleWarning")
[11:02:58.219]                       }
[11:02:58.219]                       else if (inherits(cond, "condition")) {
[11:02:58.219]                         if (!is.null(pattern)) {
[11:02:58.219]                           computeRestarts <- base::computeRestarts
[11:02:58.219]                           grepl <- base::grepl
[11:02:58.219]                           restarts <- computeRestarts(cond)
[11:02:58.219]                           for (restart in restarts) {
[11:02:58.219]                             name <- restart$name
[11:02:58.219]                             if (is.null(name)) 
[11:02:58.219]                               next
[11:02:58.219]                             if (!grepl(pattern, name)) 
[11:02:58.219]                               next
[11:02:58.219]                             invokeRestart(restart)
[11:02:58.219]                             muffled <- TRUE
[11:02:58.219]                             break
[11:02:58.219]                           }
[11:02:58.219]                         }
[11:02:58.219]                       }
[11:02:58.219]                       invisible(muffled)
[11:02:58.219]                     }
[11:02:58.219]                     muffleCondition(cond, pattern = "^muffle")
[11:02:58.219]                   }
[11:02:58.219]                 }
[11:02:58.219]             }
[11:02:58.219]         }))
[11:02:58.219]     }, error = function(ex) {
[11:02:58.219]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:58.219]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:58.219]                 ...future.rng), started = ...future.startTime, 
[11:02:58.219]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:58.219]             version = "1.8"), class = "FutureResult")
[11:02:58.219]     }, finally = {
[11:02:58.219]         if (!identical(...future.workdir, getwd())) 
[11:02:58.219]             setwd(...future.workdir)
[11:02:58.219]         {
[11:02:58.219]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:58.219]                 ...future.oldOptions$nwarnings <- NULL
[11:02:58.219]             }
[11:02:58.219]             base::options(...future.oldOptions)
[11:02:58.219]             if (.Platform$OS.type == "windows") {
[11:02:58.219]                 old_names <- names(...future.oldEnvVars)
[11:02:58.219]                 envs <- base::Sys.getenv()
[11:02:58.219]                 names <- names(envs)
[11:02:58.219]                 common <- intersect(names, old_names)
[11:02:58.219]                 added <- setdiff(names, old_names)
[11:02:58.219]                 removed <- setdiff(old_names, names)
[11:02:58.219]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:58.219]                   envs[common]]
[11:02:58.219]                 NAMES <- toupper(changed)
[11:02:58.219]                 args <- list()
[11:02:58.219]                 for (kk in seq_along(NAMES)) {
[11:02:58.219]                   name <- changed[[kk]]
[11:02:58.219]                   NAME <- NAMES[[kk]]
[11:02:58.219]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:58.219]                     next
[11:02:58.219]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:58.219]                 }
[11:02:58.219]                 NAMES <- toupper(added)
[11:02:58.219]                 for (kk in seq_along(NAMES)) {
[11:02:58.219]                   name <- added[[kk]]
[11:02:58.219]                   NAME <- NAMES[[kk]]
[11:02:58.219]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:58.219]                     next
[11:02:58.219]                   args[[name]] <- ""
[11:02:58.219]                 }
[11:02:58.219]                 NAMES <- toupper(removed)
[11:02:58.219]                 for (kk in seq_along(NAMES)) {
[11:02:58.219]                   name <- removed[[kk]]
[11:02:58.219]                   NAME <- NAMES[[kk]]
[11:02:58.219]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:58.219]                     next
[11:02:58.219]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:58.219]                 }
[11:02:58.219]                 if (length(args) > 0) 
[11:02:58.219]                   base::do.call(base::Sys.setenv, args = args)
[11:02:58.219]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:58.219]             }
[11:02:58.219]             else {
[11:02:58.219]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:58.219]             }
[11:02:58.219]             {
[11:02:58.219]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:58.219]                   0L) {
[11:02:58.219]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:58.219]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:58.219]                   base::options(opts)
[11:02:58.219]                 }
[11:02:58.219]                 {
[11:02:58.219]                   {
[11:02:58.219]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:58.219]                     NULL
[11:02:58.219]                   }
[11:02:58.219]                   options(future.plan = NULL)
[11:02:58.219]                   if (is.na(NA_character_)) 
[11:02:58.219]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:58.219]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:58.219]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:58.219]                     .init = FALSE)
[11:02:58.219]                 }
[11:02:58.219]             }
[11:02:58.219]         }
[11:02:58.219]     })
[11:02:58.219]     if (TRUE) {
[11:02:58.219]         base::sink(type = "output", split = FALSE)
[11:02:58.219]         if (TRUE) {
[11:02:58.219]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:58.219]         }
[11:02:58.219]         else {
[11:02:58.219]             ...future.result["stdout"] <- base::list(NULL)
[11:02:58.219]         }
[11:02:58.219]         base::close(...future.stdout)
[11:02:58.219]         ...future.stdout <- NULL
[11:02:58.219]     }
[11:02:58.219]     ...future.result$conditions <- ...future.conditions
[11:02:58.219]     ...future.result$finished <- base::Sys.time()
[11:02:58.219]     ...future.result
[11:02:58.219] }
[11:02:58.221] MultisessionFuture started
[11:02:58.222] - Launch lazy future ... done
[11:02:58.222] run() for ‘MultisessionFuture’ ... done
[11:02:58.222] getGlobalsAndPackages() ...
[11:02:58.222] Searching for globals...
[11:02:58.223] - globals found: [1] ‘{’
[11:02:58.223] Searching for globals ... DONE
[11:02:58.223] Resolving globals: FALSE
[11:02:58.223] 
[11:02:58.223] 
[11:02:58.223] getGlobalsAndPackages() ... DONE
[11:02:58.223] run() for ‘Future’ ...
[11:02:58.223] - state: ‘created’
[11:02:58.224] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:58.237] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:58.237] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:58.237]   - Field: ‘node’
[11:02:58.238]   - Field: ‘label’
[11:02:58.238]   - Field: ‘local’
[11:02:58.238]   - Field: ‘owner’
[11:02:58.238]   - Field: ‘envir’
[11:02:58.238]   - Field: ‘workers’
[11:02:58.238]   - Field: ‘packages’
[11:02:58.238]   - Field: ‘gc’
[11:02:58.238]   - Field: ‘conditions’
[11:02:58.238]   - Field: ‘persistent’
[11:02:58.238]   - Field: ‘expr’
[11:02:58.238]   - Field: ‘uuid’
[11:02:58.238]   - Field: ‘seed’
[11:02:58.239]   - Field: ‘version’
[11:02:58.239]   - Field: ‘result’
[11:02:58.239]   - Field: ‘asynchronous’
[11:02:58.239]   - Field: ‘calls’
[11:02:58.239]   - Field: ‘globals’
[11:02:58.239]   - Field: ‘stdout’
[11:02:58.239]   - Field: ‘earlySignal’
[11:02:58.239]   - Field: ‘lazy’
[11:02:58.239]   - Field: ‘state’
[11:02:58.239] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:58.239] - Launch lazy future ...
[11:02:58.240] Packages needed by the future expression (n = 0): <none>
[11:02:58.240] Packages needed by future strategies (n = 0): <none>
[11:02:58.240] {
[11:02:58.240]     {
[11:02:58.240]         {
[11:02:58.240]             ...future.startTime <- base::Sys.time()
[11:02:58.240]             {
[11:02:58.240]                 {
[11:02:58.240]                   {
[11:02:58.240]                     {
[11:02:58.240]                       base::local({
[11:02:58.240]                         has_future <- base::requireNamespace("future", 
[11:02:58.240]                           quietly = TRUE)
[11:02:58.240]                         if (has_future) {
[11:02:58.240]                           ns <- base::getNamespace("future")
[11:02:58.240]                           version <- ns[[".package"]][["version"]]
[11:02:58.240]                           if (is.null(version)) 
[11:02:58.240]                             version <- utils::packageVersion("future")
[11:02:58.240]                         }
[11:02:58.240]                         else {
[11:02:58.240]                           version <- NULL
[11:02:58.240]                         }
[11:02:58.240]                         if (!has_future || version < "1.8.0") {
[11:02:58.240]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:58.240]                             "", base::R.version$version.string), 
[11:02:58.240]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:58.240]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:58.240]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:58.240]                               "release", "version")], collapse = " "), 
[11:02:58.240]                             hostname = base::Sys.info()[["nodename"]])
[11:02:58.240]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:58.240]                             info)
[11:02:58.240]                           info <- base::paste(info, collapse = "; ")
[11:02:58.240]                           if (!has_future) {
[11:02:58.240]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:58.240]                               info)
[11:02:58.240]                           }
[11:02:58.240]                           else {
[11:02:58.240]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:58.240]                               info, version)
[11:02:58.240]                           }
[11:02:58.240]                           base::stop(msg)
[11:02:58.240]                         }
[11:02:58.240]                       })
[11:02:58.240]                     }
[11:02:58.240]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:58.240]                     base::options(mc.cores = 1L)
[11:02:58.240]                   }
[11:02:58.240]                   ...future.strategy.old <- future::plan("list")
[11:02:58.240]                   options(future.plan = NULL)
[11:02:58.240]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:58.240]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:58.240]                 }
[11:02:58.240]                 ...future.workdir <- getwd()
[11:02:58.240]             }
[11:02:58.240]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:58.240]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:58.240]         }
[11:02:58.240]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:58.240]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:58.240]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:58.240]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:58.240]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:58.240]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:58.240]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:58.240]             base::names(...future.oldOptions))
[11:02:58.240]     }
[11:02:58.240]     if (FALSE) {
[11:02:58.240]     }
[11:02:58.240]     else {
[11:02:58.240]         if (TRUE) {
[11:02:58.240]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:58.240]                 open = "w")
[11:02:58.240]         }
[11:02:58.240]         else {
[11:02:58.240]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:58.240]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:58.240]         }
[11:02:58.240]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:58.240]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:58.240]             base::sink(type = "output", split = FALSE)
[11:02:58.240]             base::close(...future.stdout)
[11:02:58.240]         }, add = TRUE)
[11:02:58.240]     }
[11:02:58.240]     ...future.frame <- base::sys.nframe()
[11:02:58.240]     ...future.conditions <- base::list()
[11:02:58.240]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:58.240]     if (FALSE) {
[11:02:58.240]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:58.240]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:58.240]     }
[11:02:58.240]     ...future.result <- base::tryCatch({
[11:02:58.240]         base::withCallingHandlers({
[11:02:58.240]             ...future.value <- base::withVisible(base::local({
[11:02:58.240]                 ...future.makeSendCondition <- base::local({
[11:02:58.240]                   sendCondition <- NULL
[11:02:58.240]                   function(frame = 1L) {
[11:02:58.240]                     if (is.function(sendCondition)) 
[11:02:58.240]                       return(sendCondition)
[11:02:58.240]                     ns <- getNamespace("parallel")
[11:02:58.240]                     if (exists("sendData", mode = "function", 
[11:02:58.240]                       envir = ns)) {
[11:02:58.240]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:58.240]                         envir = ns)
[11:02:58.240]                       envir <- sys.frame(frame)
[11:02:58.240]                       master <- NULL
[11:02:58.240]                       while (!identical(envir, .GlobalEnv) && 
[11:02:58.240]                         !identical(envir, emptyenv())) {
[11:02:58.240]                         if (exists("master", mode = "list", envir = envir, 
[11:02:58.240]                           inherits = FALSE)) {
[11:02:58.240]                           master <- get("master", mode = "list", 
[11:02:58.240]                             envir = envir, inherits = FALSE)
[11:02:58.240]                           if (inherits(master, c("SOCKnode", 
[11:02:58.240]                             "SOCK0node"))) {
[11:02:58.240]                             sendCondition <<- function(cond) {
[11:02:58.240]                               data <- list(type = "VALUE", value = cond, 
[11:02:58.240]                                 success = TRUE)
[11:02:58.240]                               parallel_sendData(master, data)
[11:02:58.240]                             }
[11:02:58.240]                             return(sendCondition)
[11:02:58.240]                           }
[11:02:58.240]                         }
[11:02:58.240]                         frame <- frame + 1L
[11:02:58.240]                         envir <- sys.frame(frame)
[11:02:58.240]                       }
[11:02:58.240]                     }
[11:02:58.240]                     sendCondition <<- function(cond) NULL
[11:02:58.240]                   }
[11:02:58.240]                 })
[11:02:58.240]                 withCallingHandlers({
[11:02:58.240]                   {
[11:02:58.240]                     2
[11:02:58.240]                   }
[11:02:58.240]                 }, immediateCondition = function(cond) {
[11:02:58.240]                   sendCondition <- ...future.makeSendCondition()
[11:02:58.240]                   sendCondition(cond)
[11:02:58.240]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:58.240]                   {
[11:02:58.240]                     inherits <- base::inherits
[11:02:58.240]                     invokeRestart <- base::invokeRestart
[11:02:58.240]                     is.null <- base::is.null
[11:02:58.240]                     muffled <- FALSE
[11:02:58.240]                     if (inherits(cond, "message")) {
[11:02:58.240]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:58.240]                       if (muffled) 
[11:02:58.240]                         invokeRestart("muffleMessage")
[11:02:58.240]                     }
[11:02:58.240]                     else if (inherits(cond, "warning")) {
[11:02:58.240]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:58.240]                       if (muffled) 
[11:02:58.240]                         invokeRestart("muffleWarning")
[11:02:58.240]                     }
[11:02:58.240]                     else if (inherits(cond, "condition")) {
[11:02:58.240]                       if (!is.null(pattern)) {
[11:02:58.240]                         computeRestarts <- base::computeRestarts
[11:02:58.240]                         grepl <- base::grepl
[11:02:58.240]                         restarts <- computeRestarts(cond)
[11:02:58.240]                         for (restart in restarts) {
[11:02:58.240]                           name <- restart$name
[11:02:58.240]                           if (is.null(name)) 
[11:02:58.240]                             next
[11:02:58.240]                           if (!grepl(pattern, name)) 
[11:02:58.240]                             next
[11:02:58.240]                           invokeRestart(restart)
[11:02:58.240]                           muffled <- TRUE
[11:02:58.240]                           break
[11:02:58.240]                         }
[11:02:58.240]                       }
[11:02:58.240]                     }
[11:02:58.240]                     invisible(muffled)
[11:02:58.240]                   }
[11:02:58.240]                   muffleCondition(cond)
[11:02:58.240]                 })
[11:02:58.240]             }))
[11:02:58.240]             future::FutureResult(value = ...future.value$value, 
[11:02:58.240]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:58.240]                   ...future.rng), globalenv = if (FALSE) 
[11:02:58.240]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:58.240]                     ...future.globalenv.names))
[11:02:58.240]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:58.240]         }, condition = base::local({
[11:02:58.240]             c <- base::c
[11:02:58.240]             inherits <- base::inherits
[11:02:58.240]             invokeRestart <- base::invokeRestart
[11:02:58.240]             length <- base::length
[11:02:58.240]             list <- base::list
[11:02:58.240]             seq.int <- base::seq.int
[11:02:58.240]             signalCondition <- base::signalCondition
[11:02:58.240]             sys.calls <- base::sys.calls
[11:02:58.240]             `[[` <- base::`[[`
[11:02:58.240]             `+` <- base::`+`
[11:02:58.240]             `<<-` <- base::`<<-`
[11:02:58.240]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:58.240]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:58.240]                   3L)]
[11:02:58.240]             }
[11:02:58.240]             function(cond) {
[11:02:58.240]                 is_error <- inherits(cond, "error")
[11:02:58.240]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:58.240]                   NULL)
[11:02:58.240]                 if (is_error) {
[11:02:58.240]                   sessionInformation <- function() {
[11:02:58.240]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:58.240]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:58.240]                       search = base::search(), system = base::Sys.info())
[11:02:58.240]                   }
[11:02:58.240]                   ...future.conditions[[length(...future.conditions) + 
[11:02:58.240]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:58.240]                     cond$call), session = sessionInformation(), 
[11:02:58.240]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:58.240]                   signalCondition(cond)
[11:02:58.240]                 }
[11:02:58.240]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:58.240]                 "immediateCondition"))) {
[11:02:58.240]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:58.240]                   ...future.conditions[[length(...future.conditions) + 
[11:02:58.240]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:58.240]                   if (TRUE && !signal) {
[11:02:58.240]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:58.240]                     {
[11:02:58.240]                       inherits <- base::inherits
[11:02:58.240]                       invokeRestart <- base::invokeRestart
[11:02:58.240]                       is.null <- base::is.null
[11:02:58.240]                       muffled <- FALSE
[11:02:58.240]                       if (inherits(cond, "message")) {
[11:02:58.240]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:58.240]                         if (muffled) 
[11:02:58.240]                           invokeRestart("muffleMessage")
[11:02:58.240]                       }
[11:02:58.240]                       else if (inherits(cond, "warning")) {
[11:02:58.240]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:58.240]                         if (muffled) 
[11:02:58.240]                           invokeRestart("muffleWarning")
[11:02:58.240]                       }
[11:02:58.240]                       else if (inherits(cond, "condition")) {
[11:02:58.240]                         if (!is.null(pattern)) {
[11:02:58.240]                           computeRestarts <- base::computeRestarts
[11:02:58.240]                           grepl <- base::grepl
[11:02:58.240]                           restarts <- computeRestarts(cond)
[11:02:58.240]                           for (restart in restarts) {
[11:02:58.240]                             name <- restart$name
[11:02:58.240]                             if (is.null(name)) 
[11:02:58.240]                               next
[11:02:58.240]                             if (!grepl(pattern, name)) 
[11:02:58.240]                               next
[11:02:58.240]                             invokeRestart(restart)
[11:02:58.240]                             muffled <- TRUE
[11:02:58.240]                             break
[11:02:58.240]                           }
[11:02:58.240]                         }
[11:02:58.240]                       }
[11:02:58.240]                       invisible(muffled)
[11:02:58.240]                     }
[11:02:58.240]                     muffleCondition(cond, pattern = "^muffle")
[11:02:58.240]                   }
[11:02:58.240]                 }
[11:02:58.240]                 else {
[11:02:58.240]                   if (TRUE) {
[11:02:58.240]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:58.240]                     {
[11:02:58.240]                       inherits <- base::inherits
[11:02:58.240]                       invokeRestart <- base::invokeRestart
[11:02:58.240]                       is.null <- base::is.null
[11:02:58.240]                       muffled <- FALSE
[11:02:58.240]                       if (inherits(cond, "message")) {
[11:02:58.240]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:58.240]                         if (muffled) 
[11:02:58.240]                           invokeRestart("muffleMessage")
[11:02:58.240]                       }
[11:02:58.240]                       else if (inherits(cond, "warning")) {
[11:02:58.240]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:58.240]                         if (muffled) 
[11:02:58.240]                           invokeRestart("muffleWarning")
[11:02:58.240]                       }
[11:02:58.240]                       else if (inherits(cond, "condition")) {
[11:02:58.240]                         if (!is.null(pattern)) {
[11:02:58.240]                           computeRestarts <- base::computeRestarts
[11:02:58.240]                           grepl <- base::grepl
[11:02:58.240]                           restarts <- computeRestarts(cond)
[11:02:58.240]                           for (restart in restarts) {
[11:02:58.240]                             name <- restart$name
[11:02:58.240]                             if (is.null(name)) 
[11:02:58.240]                               next
[11:02:58.240]                             if (!grepl(pattern, name)) 
[11:02:58.240]                               next
[11:02:58.240]                             invokeRestart(restart)
[11:02:58.240]                             muffled <- TRUE
[11:02:58.240]                             break
[11:02:58.240]                           }
[11:02:58.240]                         }
[11:02:58.240]                       }
[11:02:58.240]                       invisible(muffled)
[11:02:58.240]                     }
[11:02:58.240]                     muffleCondition(cond, pattern = "^muffle")
[11:02:58.240]                   }
[11:02:58.240]                 }
[11:02:58.240]             }
[11:02:58.240]         }))
[11:02:58.240]     }, error = function(ex) {
[11:02:58.240]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:58.240]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:58.240]                 ...future.rng), started = ...future.startTime, 
[11:02:58.240]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:58.240]             version = "1.8"), class = "FutureResult")
[11:02:58.240]     }, finally = {
[11:02:58.240]         if (!identical(...future.workdir, getwd())) 
[11:02:58.240]             setwd(...future.workdir)
[11:02:58.240]         {
[11:02:58.240]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:58.240]                 ...future.oldOptions$nwarnings <- NULL
[11:02:58.240]             }
[11:02:58.240]             base::options(...future.oldOptions)
[11:02:58.240]             if (.Platform$OS.type == "windows") {
[11:02:58.240]                 old_names <- names(...future.oldEnvVars)
[11:02:58.240]                 envs <- base::Sys.getenv()
[11:02:58.240]                 names <- names(envs)
[11:02:58.240]                 common <- intersect(names, old_names)
[11:02:58.240]                 added <- setdiff(names, old_names)
[11:02:58.240]                 removed <- setdiff(old_names, names)
[11:02:58.240]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:58.240]                   envs[common]]
[11:02:58.240]                 NAMES <- toupper(changed)
[11:02:58.240]                 args <- list()
[11:02:58.240]                 for (kk in seq_along(NAMES)) {
[11:02:58.240]                   name <- changed[[kk]]
[11:02:58.240]                   NAME <- NAMES[[kk]]
[11:02:58.240]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:58.240]                     next
[11:02:58.240]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:58.240]                 }
[11:02:58.240]                 NAMES <- toupper(added)
[11:02:58.240]                 for (kk in seq_along(NAMES)) {
[11:02:58.240]                   name <- added[[kk]]
[11:02:58.240]                   NAME <- NAMES[[kk]]
[11:02:58.240]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:58.240]                     next
[11:02:58.240]                   args[[name]] <- ""
[11:02:58.240]                 }
[11:02:58.240]                 NAMES <- toupper(removed)
[11:02:58.240]                 for (kk in seq_along(NAMES)) {
[11:02:58.240]                   name <- removed[[kk]]
[11:02:58.240]                   NAME <- NAMES[[kk]]
[11:02:58.240]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:58.240]                     next
[11:02:58.240]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:58.240]                 }
[11:02:58.240]                 if (length(args) > 0) 
[11:02:58.240]                   base::do.call(base::Sys.setenv, args = args)
[11:02:58.240]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:58.240]             }
[11:02:58.240]             else {
[11:02:58.240]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:58.240]             }
[11:02:58.240]             {
[11:02:58.240]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:58.240]                   0L) {
[11:02:58.240]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:58.240]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:58.240]                   base::options(opts)
[11:02:58.240]                 }
[11:02:58.240]                 {
[11:02:58.240]                   {
[11:02:58.240]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:58.240]                     NULL
[11:02:58.240]                   }
[11:02:58.240]                   options(future.plan = NULL)
[11:02:58.240]                   if (is.na(NA_character_)) 
[11:02:58.240]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:58.240]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:58.240]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:58.240]                     .init = FALSE)
[11:02:58.240]                 }
[11:02:58.240]             }
[11:02:58.240]         }
[11:02:58.240]     })
[11:02:58.240]     if (TRUE) {
[11:02:58.240]         base::sink(type = "output", split = FALSE)
[11:02:58.240]         if (TRUE) {
[11:02:58.240]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:58.240]         }
[11:02:58.240]         else {
[11:02:58.240]             ...future.result["stdout"] <- base::list(NULL)
[11:02:58.240]         }
[11:02:58.240]         base::close(...future.stdout)
[11:02:58.240]         ...future.stdout <- NULL
[11:02:58.240]     }
[11:02:58.240]     ...future.result$conditions <- ...future.conditions
[11:02:58.240]     ...future.result$finished <- base::Sys.time()
[11:02:58.240]     ...future.result
[11:02:58.240] }
[11:02:58.243] MultisessionFuture started
[11:02:58.243] - Launch lazy future ... done
[11:02:58.243] run() for ‘MultisessionFuture’ ... done
[11:02:58.244] resolve() on environment ...
[11:02:58.244]  recursive: 0
[11:02:58.245]  elements: [3] ‘a’
[11:02:58.266]  length: 2 (resolved future 3)
[11:02:58.276] receiveMessageFromWorker() for ClusterFuture ...
[11:02:58.277] - Validating connection of MultisessionFuture
[11:02:58.277] - received message: FutureResult
[11:02:58.277] - Received FutureResult
[11:02:58.277] - Erased future from FutureRegistry
[11:02:58.277] result() for ClusterFuture ...
[11:02:58.277] - result already collected: FutureResult
[11:02:58.277] result() for ClusterFuture ... done
[11:02:58.277] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:58.277] Future #1
[11:02:58.278]  length: 1 (resolved future 1)
[11:02:58.285] receiveMessageFromWorker() for ClusterFuture ...
[11:02:58.285] - Validating connection of MultisessionFuture
[11:02:58.285] - received message: FutureResult
[11:02:58.285] - Received FutureResult
[11:02:58.286] - Erased future from FutureRegistry
[11:02:58.286] result() for ClusterFuture ...
[11:02:58.286] - result already collected: FutureResult
[11:02:58.286] result() for ClusterFuture ... done
[11:02:58.286] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:58.286] Future #2
[11:02:58.286]  length: 0 (resolved future 2)
[11:02:58.286] resolve() on environment ... DONE
[11:02:58.289] resolve() on environment ...
[11:02:58.289]  recursive: 0
[11:02:58.290]  elements: [3] ‘b’
[11:02:58.290] Future #1
[11:02:58.290]  length: 2 (resolved future 1)
[11:02:58.290] Future #2
[11:02:58.290]  length: 1 (resolved future 2)
[11:02:58.290]  length: 0 (resolved future 3)
[11:02:58.290] resolve() on environment ... DONE
[11:02:58.291] resolve() on environment ...
[11:02:58.291]  recursive: 0
[11:02:58.291]  elements: [3] ‘c’
[11:02:58.291] Future #1
[11:02:58.292]  length: 2 (resolved future 1)
[11:02:58.292] Future #2
[11:02:58.292]  length: 1 (resolved future 2)
[11:02:58.292]  length: 0 (resolved future 3)
[11:02:58.292] resolve() on environment ... DONE
[11:02:58.292] resolve() on environment ...
[11:02:58.292]  recursive: 0
[11:02:58.293]  elements: [3] ‘a’, ‘b’, ‘c’, ‘.future_b’
[11:02:58.293] Future #1
[11:02:58.293] result() for ClusterFuture ...
[11:02:58.293] - result already collected: FutureResult
[11:02:58.293] result() for ClusterFuture ... done
[11:02:58.293] result() for ClusterFuture ...
[11:02:58.293] - result already collected: FutureResult
[11:02:58.293] result() for ClusterFuture ... done
[11:02:58.294]  length: 2 (resolved future 1)
[11:02:58.294] Future #2
[11:02:58.294] result() for ClusterFuture ...
[11:02:58.294] - result already collected: FutureResult
[11:02:58.294] result() for ClusterFuture ... done
[11:02:58.294] result() for ClusterFuture ...
[11:02:58.294] - result already collected: FutureResult
[11:02:58.294] result() for ClusterFuture ... done
[11:02:58.294]  length: 1 (resolved future 2)
[11:02:58.294]  length: 0 (resolved future 3)
[11:02:58.294] resolve() on environment ... DONE
[11:02:58.295] resolve() on environment ...
[11:02:58.295]  recursive: 99
[11:02:58.295]  elements: [3] ‘.future_b’, ‘a’, ‘b’, ‘c’
[11:02:58.295] Future #1
[11:02:58.295] result() for ClusterFuture ...
[11:02:58.296] - result already collected: FutureResult
[11:02:58.296] result() for ClusterFuture ... done
[11:02:58.296] result() for ClusterFuture ...
[11:02:58.296] - result already collected: FutureResult
[11:02:58.296] result() for ClusterFuture ... done
[11:02:58.296] A MultisessionFuture was resolved
[11:02:58.296]  length: 2 (resolved future 1)
[11:02:58.296] Future #2
[11:02:58.296] result() for ClusterFuture ...
[11:02:58.296] - result already collected: FutureResult
[11:02:58.296] result() for ClusterFuture ... done
[11:02:58.297] result() for ClusterFuture ...
[11:02:58.297] - result already collected: FutureResult
[11:02:58.297] result() for ClusterFuture ... done
[11:02:58.297] A MultisessionFuture was resolved
[11:02:58.297]  length: 1 (resolved future 2)
[11:02:58.297]  length: 0 (resolved future 3)
[11:02:58.297] resolve() on environment ... DONE
*** resolve() for environments ... DONE
*** resolve() for list environments ...
[11:02:58.298] resolve() on list environment ...
[11:02:58.298]  recursive: 0
[11:02:58.298]  length: 2
[11:02:58.298]  elements: ‘a’, ‘b’
[11:02:58.298]  length: 1 (resolved future 1)
[11:02:58.299]  length: 0 (resolved future 2)
[11:02:58.299] resolve() on list environment ... DONE
[11:02:58.299] getGlobalsAndPackages() ...
[11:02:58.299] Searching for globals...
[11:02:58.299] 
[11:02:58.299] Searching for globals ... DONE
[11:02:58.299] - globals: [0] <none>
[11:02:58.299] getGlobalsAndPackages() ... DONE
[11:02:58.300] run() for ‘Future’ ...
[11:02:58.300] - state: ‘created’
[11:02:58.300] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:58.313] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:58.313] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:58.313]   - Field: ‘node’
[11:02:58.313]   - Field: ‘label’
[11:02:58.314]   - Field: ‘local’
[11:02:58.314]   - Field: ‘owner’
[11:02:58.314]   - Field: ‘envir’
[11:02:58.314]   - Field: ‘workers’
[11:02:58.314]   - Field: ‘packages’
[11:02:58.314]   - Field: ‘gc’
[11:02:58.314]   - Field: ‘conditions’
[11:02:58.314]   - Field: ‘persistent’
[11:02:58.314]   - Field: ‘expr’
[11:02:58.314]   - Field: ‘uuid’
[11:02:58.314]   - Field: ‘seed’
[11:02:58.314]   - Field: ‘version’
[11:02:58.315]   - Field: ‘result’
[11:02:58.315]   - Field: ‘asynchronous’
[11:02:58.315]   - Field: ‘calls’
[11:02:58.315]   - Field: ‘globals’
[11:02:58.315]   - Field: ‘stdout’
[11:02:58.315]   - Field: ‘earlySignal’
[11:02:58.315]   - Field: ‘lazy’
[11:02:58.315]   - Field: ‘state’
[11:02:58.315] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:58.315] - Launch lazy future ...
[11:02:58.316] Packages needed by the future expression (n = 0): <none>
[11:02:58.316] Packages needed by future strategies (n = 0): <none>
[11:02:58.316] {
[11:02:58.316]     {
[11:02:58.316]         {
[11:02:58.316]             ...future.startTime <- base::Sys.time()
[11:02:58.316]             {
[11:02:58.316]                 {
[11:02:58.316]                   {
[11:02:58.316]                     {
[11:02:58.316]                       base::local({
[11:02:58.316]                         has_future <- base::requireNamespace("future", 
[11:02:58.316]                           quietly = TRUE)
[11:02:58.316]                         if (has_future) {
[11:02:58.316]                           ns <- base::getNamespace("future")
[11:02:58.316]                           version <- ns[[".package"]][["version"]]
[11:02:58.316]                           if (is.null(version)) 
[11:02:58.316]                             version <- utils::packageVersion("future")
[11:02:58.316]                         }
[11:02:58.316]                         else {
[11:02:58.316]                           version <- NULL
[11:02:58.316]                         }
[11:02:58.316]                         if (!has_future || version < "1.8.0") {
[11:02:58.316]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:58.316]                             "", base::R.version$version.string), 
[11:02:58.316]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:58.316]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:58.316]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:58.316]                               "release", "version")], collapse = " "), 
[11:02:58.316]                             hostname = base::Sys.info()[["nodename"]])
[11:02:58.316]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:58.316]                             info)
[11:02:58.316]                           info <- base::paste(info, collapse = "; ")
[11:02:58.316]                           if (!has_future) {
[11:02:58.316]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:58.316]                               info)
[11:02:58.316]                           }
[11:02:58.316]                           else {
[11:02:58.316]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:58.316]                               info, version)
[11:02:58.316]                           }
[11:02:58.316]                           base::stop(msg)
[11:02:58.316]                         }
[11:02:58.316]                       })
[11:02:58.316]                     }
[11:02:58.316]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:58.316]                     base::options(mc.cores = 1L)
[11:02:58.316]                   }
[11:02:58.316]                   ...future.strategy.old <- future::plan("list")
[11:02:58.316]                   options(future.plan = NULL)
[11:02:58.316]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:58.316]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:58.316]                 }
[11:02:58.316]                 ...future.workdir <- getwd()
[11:02:58.316]             }
[11:02:58.316]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:58.316]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:58.316]         }
[11:02:58.316]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:58.316]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:58.316]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:58.316]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:58.316]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:58.316]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:58.316]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:58.316]             base::names(...future.oldOptions))
[11:02:58.316]     }
[11:02:58.316]     if (FALSE) {
[11:02:58.316]     }
[11:02:58.316]     else {
[11:02:58.316]         if (TRUE) {
[11:02:58.316]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:58.316]                 open = "w")
[11:02:58.316]         }
[11:02:58.316]         else {
[11:02:58.316]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:58.316]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:58.316]         }
[11:02:58.316]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:58.316]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:58.316]             base::sink(type = "output", split = FALSE)
[11:02:58.316]             base::close(...future.stdout)
[11:02:58.316]         }, add = TRUE)
[11:02:58.316]     }
[11:02:58.316]     ...future.frame <- base::sys.nframe()
[11:02:58.316]     ...future.conditions <- base::list()
[11:02:58.316]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:58.316]     if (FALSE) {
[11:02:58.316]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:58.316]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:58.316]     }
[11:02:58.316]     ...future.result <- base::tryCatch({
[11:02:58.316]         base::withCallingHandlers({
[11:02:58.316]             ...future.value <- base::withVisible(base::local({
[11:02:58.316]                 ...future.makeSendCondition <- base::local({
[11:02:58.316]                   sendCondition <- NULL
[11:02:58.316]                   function(frame = 1L) {
[11:02:58.316]                     if (is.function(sendCondition)) 
[11:02:58.316]                       return(sendCondition)
[11:02:58.316]                     ns <- getNamespace("parallel")
[11:02:58.316]                     if (exists("sendData", mode = "function", 
[11:02:58.316]                       envir = ns)) {
[11:02:58.316]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:58.316]                         envir = ns)
[11:02:58.316]                       envir <- sys.frame(frame)
[11:02:58.316]                       master <- NULL
[11:02:58.316]                       while (!identical(envir, .GlobalEnv) && 
[11:02:58.316]                         !identical(envir, emptyenv())) {
[11:02:58.316]                         if (exists("master", mode = "list", envir = envir, 
[11:02:58.316]                           inherits = FALSE)) {
[11:02:58.316]                           master <- get("master", mode = "list", 
[11:02:58.316]                             envir = envir, inherits = FALSE)
[11:02:58.316]                           if (inherits(master, c("SOCKnode", 
[11:02:58.316]                             "SOCK0node"))) {
[11:02:58.316]                             sendCondition <<- function(cond) {
[11:02:58.316]                               data <- list(type = "VALUE", value = cond, 
[11:02:58.316]                                 success = TRUE)
[11:02:58.316]                               parallel_sendData(master, data)
[11:02:58.316]                             }
[11:02:58.316]                             return(sendCondition)
[11:02:58.316]                           }
[11:02:58.316]                         }
[11:02:58.316]                         frame <- frame + 1L
[11:02:58.316]                         envir <- sys.frame(frame)
[11:02:58.316]                       }
[11:02:58.316]                     }
[11:02:58.316]                     sendCondition <<- function(cond) NULL
[11:02:58.316]                   }
[11:02:58.316]                 })
[11:02:58.316]                 withCallingHandlers({
[11:02:58.316]                   1
[11:02:58.316]                 }, immediateCondition = function(cond) {
[11:02:58.316]                   sendCondition <- ...future.makeSendCondition()
[11:02:58.316]                   sendCondition(cond)
[11:02:58.316]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:58.316]                   {
[11:02:58.316]                     inherits <- base::inherits
[11:02:58.316]                     invokeRestart <- base::invokeRestart
[11:02:58.316]                     is.null <- base::is.null
[11:02:58.316]                     muffled <- FALSE
[11:02:58.316]                     if (inherits(cond, "message")) {
[11:02:58.316]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:58.316]                       if (muffled) 
[11:02:58.316]                         invokeRestart("muffleMessage")
[11:02:58.316]                     }
[11:02:58.316]                     else if (inherits(cond, "warning")) {
[11:02:58.316]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:58.316]                       if (muffled) 
[11:02:58.316]                         invokeRestart("muffleWarning")
[11:02:58.316]                     }
[11:02:58.316]                     else if (inherits(cond, "condition")) {
[11:02:58.316]                       if (!is.null(pattern)) {
[11:02:58.316]                         computeRestarts <- base::computeRestarts
[11:02:58.316]                         grepl <- base::grepl
[11:02:58.316]                         restarts <- computeRestarts(cond)
[11:02:58.316]                         for (restart in restarts) {
[11:02:58.316]                           name <- restart$name
[11:02:58.316]                           if (is.null(name)) 
[11:02:58.316]                             next
[11:02:58.316]                           if (!grepl(pattern, name)) 
[11:02:58.316]                             next
[11:02:58.316]                           invokeRestart(restart)
[11:02:58.316]                           muffled <- TRUE
[11:02:58.316]                           break
[11:02:58.316]                         }
[11:02:58.316]                       }
[11:02:58.316]                     }
[11:02:58.316]                     invisible(muffled)
[11:02:58.316]                   }
[11:02:58.316]                   muffleCondition(cond)
[11:02:58.316]                 })
[11:02:58.316]             }))
[11:02:58.316]             future::FutureResult(value = ...future.value$value, 
[11:02:58.316]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:58.316]                   ...future.rng), globalenv = if (FALSE) 
[11:02:58.316]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:58.316]                     ...future.globalenv.names))
[11:02:58.316]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:58.316]         }, condition = base::local({
[11:02:58.316]             c <- base::c
[11:02:58.316]             inherits <- base::inherits
[11:02:58.316]             invokeRestart <- base::invokeRestart
[11:02:58.316]             length <- base::length
[11:02:58.316]             list <- base::list
[11:02:58.316]             seq.int <- base::seq.int
[11:02:58.316]             signalCondition <- base::signalCondition
[11:02:58.316]             sys.calls <- base::sys.calls
[11:02:58.316]             `[[` <- base::`[[`
[11:02:58.316]             `+` <- base::`+`
[11:02:58.316]             `<<-` <- base::`<<-`
[11:02:58.316]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:58.316]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:58.316]                   3L)]
[11:02:58.316]             }
[11:02:58.316]             function(cond) {
[11:02:58.316]                 is_error <- inherits(cond, "error")
[11:02:58.316]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:58.316]                   NULL)
[11:02:58.316]                 if (is_error) {
[11:02:58.316]                   sessionInformation <- function() {
[11:02:58.316]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:58.316]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:58.316]                       search = base::search(), system = base::Sys.info())
[11:02:58.316]                   }
[11:02:58.316]                   ...future.conditions[[length(...future.conditions) + 
[11:02:58.316]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:58.316]                     cond$call), session = sessionInformation(), 
[11:02:58.316]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:58.316]                   signalCondition(cond)
[11:02:58.316]                 }
[11:02:58.316]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:58.316]                 "immediateCondition"))) {
[11:02:58.316]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:58.316]                   ...future.conditions[[length(...future.conditions) + 
[11:02:58.316]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:58.316]                   if (TRUE && !signal) {
[11:02:58.316]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:58.316]                     {
[11:02:58.316]                       inherits <- base::inherits
[11:02:58.316]                       invokeRestart <- base::invokeRestart
[11:02:58.316]                       is.null <- base::is.null
[11:02:58.316]                       muffled <- FALSE
[11:02:58.316]                       if (inherits(cond, "message")) {
[11:02:58.316]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:58.316]                         if (muffled) 
[11:02:58.316]                           invokeRestart("muffleMessage")
[11:02:58.316]                       }
[11:02:58.316]                       else if (inherits(cond, "warning")) {
[11:02:58.316]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:58.316]                         if (muffled) 
[11:02:58.316]                           invokeRestart("muffleWarning")
[11:02:58.316]                       }
[11:02:58.316]                       else if (inherits(cond, "condition")) {
[11:02:58.316]                         if (!is.null(pattern)) {
[11:02:58.316]                           computeRestarts <- base::computeRestarts
[11:02:58.316]                           grepl <- base::grepl
[11:02:58.316]                           restarts <- computeRestarts(cond)
[11:02:58.316]                           for (restart in restarts) {
[11:02:58.316]                             name <- restart$name
[11:02:58.316]                             if (is.null(name)) 
[11:02:58.316]                               next
[11:02:58.316]                             if (!grepl(pattern, name)) 
[11:02:58.316]                               next
[11:02:58.316]                             invokeRestart(restart)
[11:02:58.316]                             muffled <- TRUE
[11:02:58.316]                             break
[11:02:58.316]                           }
[11:02:58.316]                         }
[11:02:58.316]                       }
[11:02:58.316]                       invisible(muffled)
[11:02:58.316]                     }
[11:02:58.316]                     muffleCondition(cond, pattern = "^muffle")
[11:02:58.316]                   }
[11:02:58.316]                 }
[11:02:58.316]                 else {
[11:02:58.316]                   if (TRUE) {
[11:02:58.316]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:58.316]                     {
[11:02:58.316]                       inherits <- base::inherits
[11:02:58.316]                       invokeRestart <- base::invokeRestart
[11:02:58.316]                       is.null <- base::is.null
[11:02:58.316]                       muffled <- FALSE
[11:02:58.316]                       if (inherits(cond, "message")) {
[11:02:58.316]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:58.316]                         if (muffled) 
[11:02:58.316]                           invokeRestart("muffleMessage")
[11:02:58.316]                       }
[11:02:58.316]                       else if (inherits(cond, "warning")) {
[11:02:58.316]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:58.316]                         if (muffled) 
[11:02:58.316]                           invokeRestart("muffleWarning")
[11:02:58.316]                       }
[11:02:58.316]                       else if (inherits(cond, "condition")) {
[11:02:58.316]                         if (!is.null(pattern)) {
[11:02:58.316]                           computeRestarts <- base::computeRestarts
[11:02:58.316]                           grepl <- base::grepl
[11:02:58.316]                           restarts <- computeRestarts(cond)
[11:02:58.316]                           for (restart in restarts) {
[11:02:58.316]                             name <- restart$name
[11:02:58.316]                             if (is.null(name)) 
[11:02:58.316]                               next
[11:02:58.316]                             if (!grepl(pattern, name)) 
[11:02:58.316]                               next
[11:02:58.316]                             invokeRestart(restart)
[11:02:58.316]                             muffled <- TRUE
[11:02:58.316]                             break
[11:02:58.316]                           }
[11:02:58.316]                         }
[11:02:58.316]                       }
[11:02:58.316]                       invisible(muffled)
[11:02:58.316]                     }
[11:02:58.316]                     muffleCondition(cond, pattern = "^muffle")
[11:02:58.316]                   }
[11:02:58.316]                 }
[11:02:58.316]             }
[11:02:58.316]         }))
[11:02:58.316]     }, error = function(ex) {
[11:02:58.316]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:58.316]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:58.316]                 ...future.rng), started = ...future.startTime, 
[11:02:58.316]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:58.316]             version = "1.8"), class = "FutureResult")
[11:02:58.316]     }, finally = {
[11:02:58.316]         if (!identical(...future.workdir, getwd())) 
[11:02:58.316]             setwd(...future.workdir)
[11:02:58.316]         {
[11:02:58.316]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:58.316]                 ...future.oldOptions$nwarnings <- NULL
[11:02:58.316]             }
[11:02:58.316]             base::options(...future.oldOptions)
[11:02:58.316]             if (.Platform$OS.type == "windows") {
[11:02:58.316]                 old_names <- names(...future.oldEnvVars)
[11:02:58.316]                 envs <- base::Sys.getenv()
[11:02:58.316]                 names <- names(envs)
[11:02:58.316]                 common <- intersect(names, old_names)
[11:02:58.316]                 added <- setdiff(names, old_names)
[11:02:58.316]                 removed <- setdiff(old_names, names)
[11:02:58.316]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:58.316]                   envs[common]]
[11:02:58.316]                 NAMES <- toupper(changed)
[11:02:58.316]                 args <- list()
[11:02:58.316]                 for (kk in seq_along(NAMES)) {
[11:02:58.316]                   name <- changed[[kk]]
[11:02:58.316]                   NAME <- NAMES[[kk]]
[11:02:58.316]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:58.316]                     next
[11:02:58.316]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:58.316]                 }
[11:02:58.316]                 NAMES <- toupper(added)
[11:02:58.316]                 for (kk in seq_along(NAMES)) {
[11:02:58.316]                   name <- added[[kk]]
[11:02:58.316]                   NAME <- NAMES[[kk]]
[11:02:58.316]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:58.316]                     next
[11:02:58.316]                   args[[name]] <- ""
[11:02:58.316]                 }
[11:02:58.316]                 NAMES <- toupper(removed)
[11:02:58.316]                 for (kk in seq_along(NAMES)) {
[11:02:58.316]                   name <- removed[[kk]]
[11:02:58.316]                   NAME <- NAMES[[kk]]
[11:02:58.316]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:58.316]                     next
[11:02:58.316]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:58.316]                 }
[11:02:58.316]                 if (length(args) > 0) 
[11:02:58.316]                   base::do.call(base::Sys.setenv, args = args)
[11:02:58.316]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:58.316]             }
[11:02:58.316]             else {
[11:02:58.316]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:58.316]             }
[11:02:58.316]             {
[11:02:58.316]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:58.316]                   0L) {
[11:02:58.316]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:58.316]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:58.316]                   base::options(opts)
[11:02:58.316]                 }
[11:02:58.316]                 {
[11:02:58.316]                   {
[11:02:58.316]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:58.316]                     NULL
[11:02:58.316]                   }
[11:02:58.316]                   options(future.plan = NULL)
[11:02:58.316]                   if (is.na(NA_character_)) 
[11:02:58.316]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:58.316]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:58.316]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:58.316]                     .init = FALSE)
[11:02:58.316]                 }
[11:02:58.316]             }
[11:02:58.316]         }
[11:02:58.316]     })
[11:02:58.316]     if (TRUE) {
[11:02:58.316]         base::sink(type = "output", split = FALSE)
[11:02:58.316]         if (TRUE) {
[11:02:58.316]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:58.316]         }
[11:02:58.316]         else {
[11:02:58.316]             ...future.result["stdout"] <- base::list(NULL)
[11:02:58.316]         }
[11:02:58.316]         base::close(...future.stdout)
[11:02:58.316]         ...future.stdout <- NULL
[11:02:58.316]     }
[11:02:58.316]     ...future.result$conditions <- ...future.conditions
[11:02:58.316]     ...future.result$finished <- base::Sys.time()
[11:02:58.316]     ...future.result
[11:02:58.316] }
[11:02:58.319] MultisessionFuture started
[11:02:58.319] - Launch lazy future ... done
[11:02:58.319] run() for ‘MultisessionFuture’ ... done
[11:02:58.319] getGlobalsAndPackages() ...
[11:02:58.319] Searching for globals...
[11:02:58.320] 
[11:02:58.320] Searching for globals ... DONE
[11:02:58.320] - globals: [0] <none>
[11:02:58.320] getGlobalsAndPackages() ... DONE
[11:02:58.320] run() for ‘Future’ ...
[11:02:58.320] - state: ‘created’
[11:02:58.320] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:58.336] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:58.336] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:58.336]   - Field: ‘node’
[11:02:58.336]   - Field: ‘label’
[11:02:58.336]   - Field: ‘local’
[11:02:58.336]   - Field: ‘owner’
[11:02:58.337]   - Field: ‘envir’
[11:02:58.337]   - Field: ‘workers’
[11:02:58.337]   - Field: ‘packages’
[11:02:58.337]   - Field: ‘gc’
[11:02:58.337]   - Field: ‘conditions’
[11:02:58.337]   - Field: ‘persistent’
[11:02:58.337]   - Field: ‘expr’
[11:02:58.337]   - Field: ‘uuid’
[11:02:58.337]   - Field: ‘seed’
[11:02:58.337]   - Field: ‘version’
[11:02:58.337]   - Field: ‘result’
[11:02:58.337]   - Field: ‘asynchronous’
[11:02:58.338]   - Field: ‘calls’
[11:02:58.338]   - Field: ‘globals’
[11:02:58.338]   - Field: ‘stdout’
[11:02:58.338]   - Field: ‘earlySignal’
[11:02:58.338]   - Field: ‘lazy’
[11:02:58.338]   - Field: ‘state’
[11:02:58.338] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:58.338] - Launch lazy future ...
[11:02:58.338] Packages needed by the future expression (n = 0): <none>
[11:02:58.339] Packages needed by future strategies (n = 0): <none>
[11:02:58.339] {
[11:02:58.339]     {
[11:02:58.339]         {
[11:02:58.339]             ...future.startTime <- base::Sys.time()
[11:02:58.339]             {
[11:02:58.339]                 {
[11:02:58.339]                   {
[11:02:58.339]                     {
[11:02:58.339]                       base::local({
[11:02:58.339]                         has_future <- base::requireNamespace("future", 
[11:02:58.339]                           quietly = TRUE)
[11:02:58.339]                         if (has_future) {
[11:02:58.339]                           ns <- base::getNamespace("future")
[11:02:58.339]                           version <- ns[[".package"]][["version"]]
[11:02:58.339]                           if (is.null(version)) 
[11:02:58.339]                             version <- utils::packageVersion("future")
[11:02:58.339]                         }
[11:02:58.339]                         else {
[11:02:58.339]                           version <- NULL
[11:02:58.339]                         }
[11:02:58.339]                         if (!has_future || version < "1.8.0") {
[11:02:58.339]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:58.339]                             "", base::R.version$version.string), 
[11:02:58.339]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:58.339]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:58.339]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:58.339]                               "release", "version")], collapse = " "), 
[11:02:58.339]                             hostname = base::Sys.info()[["nodename"]])
[11:02:58.339]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:58.339]                             info)
[11:02:58.339]                           info <- base::paste(info, collapse = "; ")
[11:02:58.339]                           if (!has_future) {
[11:02:58.339]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:58.339]                               info)
[11:02:58.339]                           }
[11:02:58.339]                           else {
[11:02:58.339]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:58.339]                               info, version)
[11:02:58.339]                           }
[11:02:58.339]                           base::stop(msg)
[11:02:58.339]                         }
[11:02:58.339]                       })
[11:02:58.339]                     }
[11:02:58.339]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:58.339]                     base::options(mc.cores = 1L)
[11:02:58.339]                   }
[11:02:58.339]                   ...future.strategy.old <- future::plan("list")
[11:02:58.339]                   options(future.plan = NULL)
[11:02:58.339]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:58.339]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:58.339]                 }
[11:02:58.339]                 ...future.workdir <- getwd()
[11:02:58.339]             }
[11:02:58.339]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:58.339]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:58.339]         }
[11:02:58.339]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:58.339]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:58.339]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:58.339]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:58.339]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:58.339]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:58.339]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:58.339]             base::names(...future.oldOptions))
[11:02:58.339]     }
[11:02:58.339]     if (FALSE) {
[11:02:58.339]     }
[11:02:58.339]     else {
[11:02:58.339]         if (TRUE) {
[11:02:58.339]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:58.339]                 open = "w")
[11:02:58.339]         }
[11:02:58.339]         else {
[11:02:58.339]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:58.339]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:58.339]         }
[11:02:58.339]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:58.339]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:58.339]             base::sink(type = "output", split = FALSE)
[11:02:58.339]             base::close(...future.stdout)
[11:02:58.339]         }, add = TRUE)
[11:02:58.339]     }
[11:02:58.339]     ...future.frame <- base::sys.nframe()
[11:02:58.339]     ...future.conditions <- base::list()
[11:02:58.339]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:58.339]     if (FALSE) {
[11:02:58.339]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:58.339]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:58.339]     }
[11:02:58.339]     ...future.result <- base::tryCatch({
[11:02:58.339]         base::withCallingHandlers({
[11:02:58.339]             ...future.value <- base::withVisible(base::local({
[11:02:58.339]                 ...future.makeSendCondition <- base::local({
[11:02:58.339]                   sendCondition <- NULL
[11:02:58.339]                   function(frame = 1L) {
[11:02:58.339]                     if (is.function(sendCondition)) 
[11:02:58.339]                       return(sendCondition)
[11:02:58.339]                     ns <- getNamespace("parallel")
[11:02:58.339]                     if (exists("sendData", mode = "function", 
[11:02:58.339]                       envir = ns)) {
[11:02:58.339]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:58.339]                         envir = ns)
[11:02:58.339]                       envir <- sys.frame(frame)
[11:02:58.339]                       master <- NULL
[11:02:58.339]                       while (!identical(envir, .GlobalEnv) && 
[11:02:58.339]                         !identical(envir, emptyenv())) {
[11:02:58.339]                         if (exists("master", mode = "list", envir = envir, 
[11:02:58.339]                           inherits = FALSE)) {
[11:02:58.339]                           master <- get("master", mode = "list", 
[11:02:58.339]                             envir = envir, inherits = FALSE)
[11:02:58.339]                           if (inherits(master, c("SOCKnode", 
[11:02:58.339]                             "SOCK0node"))) {
[11:02:58.339]                             sendCondition <<- function(cond) {
[11:02:58.339]                               data <- list(type = "VALUE", value = cond, 
[11:02:58.339]                                 success = TRUE)
[11:02:58.339]                               parallel_sendData(master, data)
[11:02:58.339]                             }
[11:02:58.339]                             return(sendCondition)
[11:02:58.339]                           }
[11:02:58.339]                         }
[11:02:58.339]                         frame <- frame + 1L
[11:02:58.339]                         envir <- sys.frame(frame)
[11:02:58.339]                       }
[11:02:58.339]                     }
[11:02:58.339]                     sendCondition <<- function(cond) NULL
[11:02:58.339]                   }
[11:02:58.339]                 })
[11:02:58.339]                 withCallingHandlers({
[11:02:58.339]                   2
[11:02:58.339]                 }, immediateCondition = function(cond) {
[11:02:58.339]                   sendCondition <- ...future.makeSendCondition()
[11:02:58.339]                   sendCondition(cond)
[11:02:58.339]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:58.339]                   {
[11:02:58.339]                     inherits <- base::inherits
[11:02:58.339]                     invokeRestart <- base::invokeRestart
[11:02:58.339]                     is.null <- base::is.null
[11:02:58.339]                     muffled <- FALSE
[11:02:58.339]                     if (inherits(cond, "message")) {
[11:02:58.339]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:58.339]                       if (muffled) 
[11:02:58.339]                         invokeRestart("muffleMessage")
[11:02:58.339]                     }
[11:02:58.339]                     else if (inherits(cond, "warning")) {
[11:02:58.339]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:58.339]                       if (muffled) 
[11:02:58.339]                         invokeRestart("muffleWarning")
[11:02:58.339]                     }
[11:02:58.339]                     else if (inherits(cond, "condition")) {
[11:02:58.339]                       if (!is.null(pattern)) {
[11:02:58.339]                         computeRestarts <- base::computeRestarts
[11:02:58.339]                         grepl <- base::grepl
[11:02:58.339]                         restarts <- computeRestarts(cond)
[11:02:58.339]                         for (restart in restarts) {
[11:02:58.339]                           name <- restart$name
[11:02:58.339]                           if (is.null(name)) 
[11:02:58.339]                             next
[11:02:58.339]                           if (!grepl(pattern, name)) 
[11:02:58.339]                             next
[11:02:58.339]                           invokeRestart(restart)
[11:02:58.339]                           muffled <- TRUE
[11:02:58.339]                           break
[11:02:58.339]                         }
[11:02:58.339]                       }
[11:02:58.339]                     }
[11:02:58.339]                     invisible(muffled)
[11:02:58.339]                   }
[11:02:58.339]                   muffleCondition(cond)
[11:02:58.339]                 })
[11:02:58.339]             }))
[11:02:58.339]             future::FutureResult(value = ...future.value$value, 
[11:02:58.339]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:58.339]                   ...future.rng), globalenv = if (FALSE) 
[11:02:58.339]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:58.339]                     ...future.globalenv.names))
[11:02:58.339]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:58.339]         }, condition = base::local({
[11:02:58.339]             c <- base::c
[11:02:58.339]             inherits <- base::inherits
[11:02:58.339]             invokeRestart <- base::invokeRestart
[11:02:58.339]             length <- base::length
[11:02:58.339]             list <- base::list
[11:02:58.339]             seq.int <- base::seq.int
[11:02:58.339]             signalCondition <- base::signalCondition
[11:02:58.339]             sys.calls <- base::sys.calls
[11:02:58.339]             `[[` <- base::`[[`
[11:02:58.339]             `+` <- base::`+`
[11:02:58.339]             `<<-` <- base::`<<-`
[11:02:58.339]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:58.339]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:58.339]                   3L)]
[11:02:58.339]             }
[11:02:58.339]             function(cond) {
[11:02:58.339]                 is_error <- inherits(cond, "error")
[11:02:58.339]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:58.339]                   NULL)
[11:02:58.339]                 if (is_error) {
[11:02:58.339]                   sessionInformation <- function() {
[11:02:58.339]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:58.339]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:58.339]                       search = base::search(), system = base::Sys.info())
[11:02:58.339]                   }
[11:02:58.339]                   ...future.conditions[[length(...future.conditions) + 
[11:02:58.339]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:58.339]                     cond$call), session = sessionInformation(), 
[11:02:58.339]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:58.339]                   signalCondition(cond)
[11:02:58.339]                 }
[11:02:58.339]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:58.339]                 "immediateCondition"))) {
[11:02:58.339]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:58.339]                   ...future.conditions[[length(...future.conditions) + 
[11:02:58.339]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:58.339]                   if (TRUE && !signal) {
[11:02:58.339]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:58.339]                     {
[11:02:58.339]                       inherits <- base::inherits
[11:02:58.339]                       invokeRestart <- base::invokeRestart
[11:02:58.339]                       is.null <- base::is.null
[11:02:58.339]                       muffled <- FALSE
[11:02:58.339]                       if (inherits(cond, "message")) {
[11:02:58.339]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:58.339]                         if (muffled) 
[11:02:58.339]                           invokeRestart("muffleMessage")
[11:02:58.339]                       }
[11:02:58.339]                       else if (inherits(cond, "warning")) {
[11:02:58.339]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:58.339]                         if (muffled) 
[11:02:58.339]                           invokeRestart("muffleWarning")
[11:02:58.339]                       }
[11:02:58.339]                       else if (inherits(cond, "condition")) {
[11:02:58.339]                         if (!is.null(pattern)) {
[11:02:58.339]                           computeRestarts <- base::computeRestarts
[11:02:58.339]                           grepl <- base::grepl
[11:02:58.339]                           restarts <- computeRestarts(cond)
[11:02:58.339]                           for (restart in restarts) {
[11:02:58.339]                             name <- restart$name
[11:02:58.339]                             if (is.null(name)) 
[11:02:58.339]                               next
[11:02:58.339]                             if (!grepl(pattern, name)) 
[11:02:58.339]                               next
[11:02:58.339]                             invokeRestart(restart)
[11:02:58.339]                             muffled <- TRUE
[11:02:58.339]                             break
[11:02:58.339]                           }
[11:02:58.339]                         }
[11:02:58.339]                       }
[11:02:58.339]                       invisible(muffled)
[11:02:58.339]                     }
[11:02:58.339]                     muffleCondition(cond, pattern = "^muffle")
[11:02:58.339]                   }
[11:02:58.339]                 }
[11:02:58.339]                 else {
[11:02:58.339]                   if (TRUE) {
[11:02:58.339]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:58.339]                     {
[11:02:58.339]                       inherits <- base::inherits
[11:02:58.339]                       invokeRestart <- base::invokeRestart
[11:02:58.339]                       is.null <- base::is.null
[11:02:58.339]                       muffled <- FALSE
[11:02:58.339]                       if (inherits(cond, "message")) {
[11:02:58.339]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:58.339]                         if (muffled) 
[11:02:58.339]                           invokeRestart("muffleMessage")
[11:02:58.339]                       }
[11:02:58.339]                       else if (inherits(cond, "warning")) {
[11:02:58.339]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:58.339]                         if (muffled) 
[11:02:58.339]                           invokeRestart("muffleWarning")
[11:02:58.339]                       }
[11:02:58.339]                       else if (inherits(cond, "condition")) {
[11:02:58.339]                         if (!is.null(pattern)) {
[11:02:58.339]                           computeRestarts <- base::computeRestarts
[11:02:58.339]                           grepl <- base::grepl
[11:02:58.339]                           restarts <- computeRestarts(cond)
[11:02:58.339]                           for (restart in restarts) {
[11:02:58.339]                             name <- restart$name
[11:02:58.339]                             if (is.null(name)) 
[11:02:58.339]                               next
[11:02:58.339]                             if (!grepl(pattern, name)) 
[11:02:58.339]                               next
[11:02:58.339]                             invokeRestart(restart)
[11:02:58.339]                             muffled <- TRUE
[11:02:58.339]                             break
[11:02:58.339]                           }
[11:02:58.339]                         }
[11:02:58.339]                       }
[11:02:58.339]                       invisible(muffled)
[11:02:58.339]                     }
[11:02:58.339]                     muffleCondition(cond, pattern = "^muffle")
[11:02:58.339]                   }
[11:02:58.339]                 }
[11:02:58.339]             }
[11:02:58.339]         }))
[11:02:58.339]     }, error = function(ex) {
[11:02:58.339]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:58.339]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:58.339]                 ...future.rng), started = ...future.startTime, 
[11:02:58.339]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:58.339]             version = "1.8"), class = "FutureResult")
[11:02:58.339]     }, finally = {
[11:02:58.339]         if (!identical(...future.workdir, getwd())) 
[11:02:58.339]             setwd(...future.workdir)
[11:02:58.339]         {
[11:02:58.339]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:58.339]                 ...future.oldOptions$nwarnings <- NULL
[11:02:58.339]             }
[11:02:58.339]             base::options(...future.oldOptions)
[11:02:58.339]             if (.Platform$OS.type == "windows") {
[11:02:58.339]                 old_names <- names(...future.oldEnvVars)
[11:02:58.339]                 envs <- base::Sys.getenv()
[11:02:58.339]                 names <- names(envs)
[11:02:58.339]                 common <- intersect(names, old_names)
[11:02:58.339]                 added <- setdiff(names, old_names)
[11:02:58.339]                 removed <- setdiff(old_names, names)
[11:02:58.339]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:58.339]                   envs[common]]
[11:02:58.339]                 NAMES <- toupper(changed)
[11:02:58.339]                 args <- list()
[11:02:58.339]                 for (kk in seq_along(NAMES)) {
[11:02:58.339]                   name <- changed[[kk]]
[11:02:58.339]                   NAME <- NAMES[[kk]]
[11:02:58.339]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:58.339]                     next
[11:02:58.339]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:58.339]                 }
[11:02:58.339]                 NAMES <- toupper(added)
[11:02:58.339]                 for (kk in seq_along(NAMES)) {
[11:02:58.339]                   name <- added[[kk]]
[11:02:58.339]                   NAME <- NAMES[[kk]]
[11:02:58.339]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:58.339]                     next
[11:02:58.339]                   args[[name]] <- ""
[11:02:58.339]                 }
[11:02:58.339]                 NAMES <- toupper(removed)
[11:02:58.339]                 for (kk in seq_along(NAMES)) {
[11:02:58.339]                   name <- removed[[kk]]
[11:02:58.339]                   NAME <- NAMES[[kk]]
[11:02:58.339]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:58.339]                     next
[11:02:58.339]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:58.339]                 }
[11:02:58.339]                 if (length(args) > 0) 
[11:02:58.339]                   base::do.call(base::Sys.setenv, args = args)
[11:02:58.339]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:58.339]             }
[11:02:58.339]             else {
[11:02:58.339]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:58.339]             }
[11:02:58.339]             {
[11:02:58.339]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:58.339]                   0L) {
[11:02:58.339]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:58.339]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:58.339]                   base::options(opts)
[11:02:58.339]                 }
[11:02:58.339]                 {
[11:02:58.339]                   {
[11:02:58.339]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:58.339]                     NULL
[11:02:58.339]                   }
[11:02:58.339]                   options(future.plan = NULL)
[11:02:58.339]                   if (is.na(NA_character_)) 
[11:02:58.339]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:58.339]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:58.339]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:58.339]                     .init = FALSE)
[11:02:58.339]                 }
[11:02:58.339]             }
[11:02:58.339]         }
[11:02:58.339]     })
[11:02:58.339]     if (TRUE) {
[11:02:58.339]         base::sink(type = "output", split = FALSE)
[11:02:58.339]         if (TRUE) {
[11:02:58.339]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:58.339]         }
[11:02:58.339]         else {
[11:02:58.339]             ...future.result["stdout"] <- base::list(NULL)
[11:02:58.339]         }
[11:02:58.339]         base::close(...future.stdout)
[11:02:58.339]         ...future.stdout <- NULL
[11:02:58.339]     }
[11:02:58.339]     ...future.result$conditions <- ...future.conditions
[11:02:58.339]     ...future.result$finished <- base::Sys.time()
[11:02:58.339]     ...future.result
[11:02:58.339] }
[11:02:58.342] MultisessionFuture started
[11:02:58.342] - Launch lazy future ... done
[11:02:58.342] run() for ‘MultisessionFuture’ ... done
[11:02:58.343] resolve() on list environment ...
[11:02:58.343]  recursive: 0
[11:02:58.343]  length: 3
[11:02:58.343]  elements: ‘a’, ‘b’, ‘c’
[11:02:58.364]  length: 2 (resolved future 3)
[11:02:58.375] receiveMessageFromWorker() for ClusterFuture ...
[11:02:58.375] - Validating connection of MultisessionFuture
[11:02:58.375] - received message: FutureResult
[11:02:58.376] - Received FutureResult
[11:02:58.376] - Erased future from FutureRegistry
[11:02:58.376] result() for ClusterFuture ...
[11:02:58.376] - result already collected: FutureResult
[11:02:58.376] result() for ClusterFuture ... done
[11:02:58.376] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:58.376] Future #1
[11:02:58.376]  length: 1 (resolved future 1)
[11:02:58.384] receiveMessageFromWorker() for ClusterFuture ...
[11:02:58.384] - Validating connection of MultisessionFuture
[11:02:58.384] - received message: FutureResult
[11:02:58.385] - Received FutureResult
[11:02:58.385] - Erased future from FutureRegistry
[11:02:58.385] result() for ClusterFuture ...
[11:02:58.385] - result already collected: FutureResult
[11:02:58.385] result() for ClusterFuture ... done
[11:02:58.385] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:58.385] Future #2
[11:02:58.385]  length: 0 (resolved future 2)
[11:02:58.385] resolve() on list environment ... DONE
[11:02:58.386] getGlobalsAndPackages() ...
[11:02:58.386] Searching for globals...
[11:02:58.387] - globals found: [1] ‘{’
[11:02:58.387] Searching for globals ... DONE
[11:02:58.387] Resolving globals: FALSE
[11:02:58.387] 
[11:02:58.387] 
[11:02:58.387] getGlobalsAndPackages() ... DONE
[11:02:58.387] run() for ‘Future’ ...
[11:02:58.388] - state: ‘created’
[11:02:58.388] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:58.401] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:58.401] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:58.402]   - Field: ‘node’
[11:02:58.402]   - Field: ‘label’
[11:02:58.402]   - Field: ‘local’
[11:02:58.402]   - Field: ‘owner’
[11:02:58.402]   - Field: ‘envir’
[11:02:58.402]   - Field: ‘workers’
[11:02:58.402]   - Field: ‘packages’
[11:02:58.402]   - Field: ‘gc’
[11:02:58.402]   - Field: ‘conditions’
[11:02:58.402]   - Field: ‘persistent’
[11:02:58.402]   - Field: ‘expr’
[11:02:58.402]   - Field: ‘uuid’
[11:02:58.403]   - Field: ‘seed’
[11:02:58.403]   - Field: ‘version’
[11:02:58.403]   - Field: ‘result’
[11:02:58.403]   - Field: ‘asynchronous’
[11:02:58.403]   - Field: ‘calls’
[11:02:58.403]   - Field: ‘globals’
[11:02:58.403]   - Field: ‘stdout’
[11:02:58.403]   - Field: ‘earlySignal’
[11:02:58.403]   - Field: ‘lazy’
[11:02:58.403]   - Field: ‘state’
[11:02:58.403] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:58.403] - Launch lazy future ...
[11:02:58.404] Packages needed by the future expression (n = 0): <none>
[11:02:58.404] Packages needed by future strategies (n = 0): <none>
[11:02:58.404] {
[11:02:58.404]     {
[11:02:58.404]         {
[11:02:58.404]             ...future.startTime <- base::Sys.time()
[11:02:58.404]             {
[11:02:58.404]                 {
[11:02:58.404]                   {
[11:02:58.404]                     {
[11:02:58.404]                       base::local({
[11:02:58.404]                         has_future <- base::requireNamespace("future", 
[11:02:58.404]                           quietly = TRUE)
[11:02:58.404]                         if (has_future) {
[11:02:58.404]                           ns <- base::getNamespace("future")
[11:02:58.404]                           version <- ns[[".package"]][["version"]]
[11:02:58.404]                           if (is.null(version)) 
[11:02:58.404]                             version <- utils::packageVersion("future")
[11:02:58.404]                         }
[11:02:58.404]                         else {
[11:02:58.404]                           version <- NULL
[11:02:58.404]                         }
[11:02:58.404]                         if (!has_future || version < "1.8.0") {
[11:02:58.404]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:58.404]                             "", base::R.version$version.string), 
[11:02:58.404]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:58.404]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:58.404]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:58.404]                               "release", "version")], collapse = " "), 
[11:02:58.404]                             hostname = base::Sys.info()[["nodename"]])
[11:02:58.404]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:58.404]                             info)
[11:02:58.404]                           info <- base::paste(info, collapse = "; ")
[11:02:58.404]                           if (!has_future) {
[11:02:58.404]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:58.404]                               info)
[11:02:58.404]                           }
[11:02:58.404]                           else {
[11:02:58.404]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:58.404]                               info, version)
[11:02:58.404]                           }
[11:02:58.404]                           base::stop(msg)
[11:02:58.404]                         }
[11:02:58.404]                       })
[11:02:58.404]                     }
[11:02:58.404]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:58.404]                     base::options(mc.cores = 1L)
[11:02:58.404]                   }
[11:02:58.404]                   ...future.strategy.old <- future::plan("list")
[11:02:58.404]                   options(future.plan = NULL)
[11:02:58.404]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:58.404]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:58.404]                 }
[11:02:58.404]                 ...future.workdir <- getwd()
[11:02:58.404]             }
[11:02:58.404]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:58.404]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:58.404]         }
[11:02:58.404]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:58.404]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:58.404]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:58.404]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:58.404]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:58.404]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:58.404]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:58.404]             base::names(...future.oldOptions))
[11:02:58.404]     }
[11:02:58.404]     if (FALSE) {
[11:02:58.404]     }
[11:02:58.404]     else {
[11:02:58.404]         if (TRUE) {
[11:02:58.404]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:58.404]                 open = "w")
[11:02:58.404]         }
[11:02:58.404]         else {
[11:02:58.404]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:58.404]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:58.404]         }
[11:02:58.404]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:58.404]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:58.404]             base::sink(type = "output", split = FALSE)
[11:02:58.404]             base::close(...future.stdout)
[11:02:58.404]         }, add = TRUE)
[11:02:58.404]     }
[11:02:58.404]     ...future.frame <- base::sys.nframe()
[11:02:58.404]     ...future.conditions <- base::list()
[11:02:58.404]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:58.404]     if (FALSE) {
[11:02:58.404]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:58.404]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:58.404]     }
[11:02:58.404]     ...future.result <- base::tryCatch({
[11:02:58.404]         base::withCallingHandlers({
[11:02:58.404]             ...future.value <- base::withVisible(base::local({
[11:02:58.404]                 ...future.makeSendCondition <- base::local({
[11:02:58.404]                   sendCondition <- NULL
[11:02:58.404]                   function(frame = 1L) {
[11:02:58.404]                     if (is.function(sendCondition)) 
[11:02:58.404]                       return(sendCondition)
[11:02:58.404]                     ns <- getNamespace("parallel")
[11:02:58.404]                     if (exists("sendData", mode = "function", 
[11:02:58.404]                       envir = ns)) {
[11:02:58.404]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:58.404]                         envir = ns)
[11:02:58.404]                       envir <- sys.frame(frame)
[11:02:58.404]                       master <- NULL
[11:02:58.404]                       while (!identical(envir, .GlobalEnv) && 
[11:02:58.404]                         !identical(envir, emptyenv())) {
[11:02:58.404]                         if (exists("master", mode = "list", envir = envir, 
[11:02:58.404]                           inherits = FALSE)) {
[11:02:58.404]                           master <- get("master", mode = "list", 
[11:02:58.404]                             envir = envir, inherits = FALSE)
[11:02:58.404]                           if (inherits(master, c("SOCKnode", 
[11:02:58.404]                             "SOCK0node"))) {
[11:02:58.404]                             sendCondition <<- function(cond) {
[11:02:58.404]                               data <- list(type = "VALUE", value = cond, 
[11:02:58.404]                                 success = TRUE)
[11:02:58.404]                               parallel_sendData(master, data)
[11:02:58.404]                             }
[11:02:58.404]                             return(sendCondition)
[11:02:58.404]                           }
[11:02:58.404]                         }
[11:02:58.404]                         frame <- frame + 1L
[11:02:58.404]                         envir <- sys.frame(frame)
[11:02:58.404]                       }
[11:02:58.404]                     }
[11:02:58.404]                     sendCondition <<- function(cond) NULL
[11:02:58.404]                   }
[11:02:58.404]                 })
[11:02:58.404]                 withCallingHandlers({
[11:02:58.404]                   {
[11:02:58.404]                     1
[11:02:58.404]                   }
[11:02:58.404]                 }, immediateCondition = function(cond) {
[11:02:58.404]                   sendCondition <- ...future.makeSendCondition()
[11:02:58.404]                   sendCondition(cond)
[11:02:58.404]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:58.404]                   {
[11:02:58.404]                     inherits <- base::inherits
[11:02:58.404]                     invokeRestart <- base::invokeRestart
[11:02:58.404]                     is.null <- base::is.null
[11:02:58.404]                     muffled <- FALSE
[11:02:58.404]                     if (inherits(cond, "message")) {
[11:02:58.404]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:58.404]                       if (muffled) 
[11:02:58.404]                         invokeRestart("muffleMessage")
[11:02:58.404]                     }
[11:02:58.404]                     else if (inherits(cond, "warning")) {
[11:02:58.404]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:58.404]                       if (muffled) 
[11:02:58.404]                         invokeRestart("muffleWarning")
[11:02:58.404]                     }
[11:02:58.404]                     else if (inherits(cond, "condition")) {
[11:02:58.404]                       if (!is.null(pattern)) {
[11:02:58.404]                         computeRestarts <- base::computeRestarts
[11:02:58.404]                         grepl <- base::grepl
[11:02:58.404]                         restarts <- computeRestarts(cond)
[11:02:58.404]                         for (restart in restarts) {
[11:02:58.404]                           name <- restart$name
[11:02:58.404]                           if (is.null(name)) 
[11:02:58.404]                             next
[11:02:58.404]                           if (!grepl(pattern, name)) 
[11:02:58.404]                             next
[11:02:58.404]                           invokeRestart(restart)
[11:02:58.404]                           muffled <- TRUE
[11:02:58.404]                           break
[11:02:58.404]                         }
[11:02:58.404]                       }
[11:02:58.404]                     }
[11:02:58.404]                     invisible(muffled)
[11:02:58.404]                   }
[11:02:58.404]                   muffleCondition(cond)
[11:02:58.404]                 })
[11:02:58.404]             }))
[11:02:58.404]             future::FutureResult(value = ...future.value$value, 
[11:02:58.404]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:58.404]                   ...future.rng), globalenv = if (FALSE) 
[11:02:58.404]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:58.404]                     ...future.globalenv.names))
[11:02:58.404]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:58.404]         }, condition = base::local({
[11:02:58.404]             c <- base::c
[11:02:58.404]             inherits <- base::inherits
[11:02:58.404]             invokeRestart <- base::invokeRestart
[11:02:58.404]             length <- base::length
[11:02:58.404]             list <- base::list
[11:02:58.404]             seq.int <- base::seq.int
[11:02:58.404]             signalCondition <- base::signalCondition
[11:02:58.404]             sys.calls <- base::sys.calls
[11:02:58.404]             `[[` <- base::`[[`
[11:02:58.404]             `+` <- base::`+`
[11:02:58.404]             `<<-` <- base::`<<-`
[11:02:58.404]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:58.404]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:58.404]                   3L)]
[11:02:58.404]             }
[11:02:58.404]             function(cond) {
[11:02:58.404]                 is_error <- inherits(cond, "error")
[11:02:58.404]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:58.404]                   NULL)
[11:02:58.404]                 if (is_error) {
[11:02:58.404]                   sessionInformation <- function() {
[11:02:58.404]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:58.404]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:58.404]                       search = base::search(), system = base::Sys.info())
[11:02:58.404]                   }
[11:02:58.404]                   ...future.conditions[[length(...future.conditions) + 
[11:02:58.404]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:58.404]                     cond$call), session = sessionInformation(), 
[11:02:58.404]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:58.404]                   signalCondition(cond)
[11:02:58.404]                 }
[11:02:58.404]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:58.404]                 "immediateCondition"))) {
[11:02:58.404]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:58.404]                   ...future.conditions[[length(...future.conditions) + 
[11:02:58.404]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:58.404]                   if (TRUE && !signal) {
[11:02:58.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:58.404]                     {
[11:02:58.404]                       inherits <- base::inherits
[11:02:58.404]                       invokeRestart <- base::invokeRestart
[11:02:58.404]                       is.null <- base::is.null
[11:02:58.404]                       muffled <- FALSE
[11:02:58.404]                       if (inherits(cond, "message")) {
[11:02:58.404]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:58.404]                         if (muffled) 
[11:02:58.404]                           invokeRestart("muffleMessage")
[11:02:58.404]                       }
[11:02:58.404]                       else if (inherits(cond, "warning")) {
[11:02:58.404]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:58.404]                         if (muffled) 
[11:02:58.404]                           invokeRestart("muffleWarning")
[11:02:58.404]                       }
[11:02:58.404]                       else if (inherits(cond, "condition")) {
[11:02:58.404]                         if (!is.null(pattern)) {
[11:02:58.404]                           computeRestarts <- base::computeRestarts
[11:02:58.404]                           grepl <- base::grepl
[11:02:58.404]                           restarts <- computeRestarts(cond)
[11:02:58.404]                           for (restart in restarts) {
[11:02:58.404]                             name <- restart$name
[11:02:58.404]                             if (is.null(name)) 
[11:02:58.404]                               next
[11:02:58.404]                             if (!grepl(pattern, name)) 
[11:02:58.404]                               next
[11:02:58.404]                             invokeRestart(restart)
[11:02:58.404]                             muffled <- TRUE
[11:02:58.404]                             break
[11:02:58.404]                           }
[11:02:58.404]                         }
[11:02:58.404]                       }
[11:02:58.404]                       invisible(muffled)
[11:02:58.404]                     }
[11:02:58.404]                     muffleCondition(cond, pattern = "^muffle")
[11:02:58.404]                   }
[11:02:58.404]                 }
[11:02:58.404]                 else {
[11:02:58.404]                   if (TRUE) {
[11:02:58.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:58.404]                     {
[11:02:58.404]                       inherits <- base::inherits
[11:02:58.404]                       invokeRestart <- base::invokeRestart
[11:02:58.404]                       is.null <- base::is.null
[11:02:58.404]                       muffled <- FALSE
[11:02:58.404]                       if (inherits(cond, "message")) {
[11:02:58.404]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:58.404]                         if (muffled) 
[11:02:58.404]                           invokeRestart("muffleMessage")
[11:02:58.404]                       }
[11:02:58.404]                       else if (inherits(cond, "warning")) {
[11:02:58.404]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:58.404]                         if (muffled) 
[11:02:58.404]                           invokeRestart("muffleWarning")
[11:02:58.404]                       }
[11:02:58.404]                       else if (inherits(cond, "condition")) {
[11:02:58.404]                         if (!is.null(pattern)) {
[11:02:58.404]                           computeRestarts <- base::computeRestarts
[11:02:58.404]                           grepl <- base::grepl
[11:02:58.404]                           restarts <- computeRestarts(cond)
[11:02:58.404]                           for (restart in restarts) {
[11:02:58.404]                             name <- restart$name
[11:02:58.404]                             if (is.null(name)) 
[11:02:58.404]                               next
[11:02:58.404]                             if (!grepl(pattern, name)) 
[11:02:58.404]                               next
[11:02:58.404]                             invokeRestart(restart)
[11:02:58.404]                             muffled <- TRUE
[11:02:58.404]                             break
[11:02:58.404]                           }
[11:02:58.404]                         }
[11:02:58.404]                       }
[11:02:58.404]                       invisible(muffled)
[11:02:58.404]                     }
[11:02:58.404]                     muffleCondition(cond, pattern = "^muffle")
[11:02:58.404]                   }
[11:02:58.404]                 }
[11:02:58.404]             }
[11:02:58.404]         }))
[11:02:58.404]     }, error = function(ex) {
[11:02:58.404]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:58.404]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:58.404]                 ...future.rng), started = ...future.startTime, 
[11:02:58.404]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:58.404]             version = "1.8"), class = "FutureResult")
[11:02:58.404]     }, finally = {
[11:02:58.404]         if (!identical(...future.workdir, getwd())) 
[11:02:58.404]             setwd(...future.workdir)
[11:02:58.404]         {
[11:02:58.404]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:58.404]                 ...future.oldOptions$nwarnings <- NULL
[11:02:58.404]             }
[11:02:58.404]             base::options(...future.oldOptions)
[11:02:58.404]             if (.Platform$OS.type == "windows") {
[11:02:58.404]                 old_names <- names(...future.oldEnvVars)
[11:02:58.404]                 envs <- base::Sys.getenv()
[11:02:58.404]                 names <- names(envs)
[11:02:58.404]                 common <- intersect(names, old_names)
[11:02:58.404]                 added <- setdiff(names, old_names)
[11:02:58.404]                 removed <- setdiff(old_names, names)
[11:02:58.404]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:58.404]                   envs[common]]
[11:02:58.404]                 NAMES <- toupper(changed)
[11:02:58.404]                 args <- list()
[11:02:58.404]                 for (kk in seq_along(NAMES)) {
[11:02:58.404]                   name <- changed[[kk]]
[11:02:58.404]                   NAME <- NAMES[[kk]]
[11:02:58.404]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:58.404]                     next
[11:02:58.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:58.404]                 }
[11:02:58.404]                 NAMES <- toupper(added)
[11:02:58.404]                 for (kk in seq_along(NAMES)) {
[11:02:58.404]                   name <- added[[kk]]
[11:02:58.404]                   NAME <- NAMES[[kk]]
[11:02:58.404]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:58.404]                     next
[11:02:58.404]                   args[[name]] <- ""
[11:02:58.404]                 }
[11:02:58.404]                 NAMES <- toupper(removed)
[11:02:58.404]                 for (kk in seq_along(NAMES)) {
[11:02:58.404]                   name <- removed[[kk]]
[11:02:58.404]                   NAME <- NAMES[[kk]]
[11:02:58.404]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:58.404]                     next
[11:02:58.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:58.404]                 }
[11:02:58.404]                 if (length(args) > 0) 
[11:02:58.404]                   base::do.call(base::Sys.setenv, args = args)
[11:02:58.404]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:58.404]             }
[11:02:58.404]             else {
[11:02:58.404]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:58.404]             }
[11:02:58.404]             {
[11:02:58.404]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:58.404]                   0L) {
[11:02:58.404]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:58.404]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:58.404]                   base::options(opts)
[11:02:58.404]                 }
[11:02:58.404]                 {
[11:02:58.404]                   {
[11:02:58.404]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:58.404]                     NULL
[11:02:58.404]                   }
[11:02:58.404]                   options(future.plan = NULL)
[11:02:58.404]                   if (is.na(NA_character_)) 
[11:02:58.404]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:58.404]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:58.404]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:58.404]                     .init = FALSE)
[11:02:58.404]                 }
[11:02:58.404]             }
[11:02:58.404]         }
[11:02:58.404]     })
[11:02:58.404]     if (TRUE) {
[11:02:58.404]         base::sink(type = "output", split = FALSE)
[11:02:58.404]         if (TRUE) {
[11:02:58.404]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:58.404]         }
[11:02:58.404]         else {
[11:02:58.404]             ...future.result["stdout"] <- base::list(NULL)
[11:02:58.404]         }
[11:02:58.404]         base::close(...future.stdout)
[11:02:58.404]         ...future.stdout <- NULL
[11:02:58.404]     }
[11:02:58.404]     ...future.result$conditions <- ...future.conditions
[11:02:58.404]     ...future.result$finished <- base::Sys.time()
[11:02:58.404]     ...future.result
[11:02:58.404] }
[11:02:58.407] MultisessionFuture started
[11:02:58.407] - Launch lazy future ... done
[11:02:58.407] run() for ‘MultisessionFuture’ ... done
[11:02:58.408] getGlobalsAndPackages() ...
[11:02:58.408] Searching for globals...
[11:02:58.408] - globals found: [1] ‘{’
[11:02:58.408] Searching for globals ... DONE
[11:02:58.408] Resolving globals: FALSE
[11:02:58.409] 
[11:02:58.409] 
[11:02:58.409] getGlobalsAndPackages() ... DONE
[11:02:58.409] run() for ‘Future’ ...
[11:02:58.409] - state: ‘created’
[11:02:58.409] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:58.423] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:58.423] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:58.423]   - Field: ‘node’
[11:02:58.423]   - Field: ‘label’
[11:02:58.423]   - Field: ‘local’
[11:02:58.423]   - Field: ‘owner’
[11:02:58.423]   - Field: ‘envir’
[11:02:58.423]   - Field: ‘workers’
[11:02:58.423]   - Field: ‘packages’
[11:02:58.424]   - Field: ‘gc’
[11:02:58.424]   - Field: ‘conditions’
[11:02:58.424]   - Field: ‘persistent’
[11:02:58.424]   - Field: ‘expr’
[11:02:58.424]   - Field: ‘uuid’
[11:02:58.424]   - Field: ‘seed’
[11:02:58.424]   - Field: ‘version’
[11:02:58.424]   - Field: ‘result’
[11:02:58.424]   - Field: ‘asynchronous’
[11:02:58.424]   - Field: ‘calls’
[11:02:58.424]   - Field: ‘globals’
[11:02:58.425]   - Field: ‘stdout’
[11:02:58.425]   - Field: ‘earlySignal’
[11:02:58.425]   - Field: ‘lazy’
[11:02:58.425]   - Field: ‘state’
[11:02:58.425] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:58.425] - Launch lazy future ...
[11:02:58.425] Packages needed by the future expression (n = 0): <none>
[11:02:58.425] Packages needed by future strategies (n = 0): <none>
[11:02:58.426] {
[11:02:58.426]     {
[11:02:58.426]         {
[11:02:58.426]             ...future.startTime <- base::Sys.time()
[11:02:58.426]             {
[11:02:58.426]                 {
[11:02:58.426]                   {
[11:02:58.426]                     {
[11:02:58.426]                       base::local({
[11:02:58.426]                         has_future <- base::requireNamespace("future", 
[11:02:58.426]                           quietly = TRUE)
[11:02:58.426]                         if (has_future) {
[11:02:58.426]                           ns <- base::getNamespace("future")
[11:02:58.426]                           version <- ns[[".package"]][["version"]]
[11:02:58.426]                           if (is.null(version)) 
[11:02:58.426]                             version <- utils::packageVersion("future")
[11:02:58.426]                         }
[11:02:58.426]                         else {
[11:02:58.426]                           version <- NULL
[11:02:58.426]                         }
[11:02:58.426]                         if (!has_future || version < "1.8.0") {
[11:02:58.426]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:58.426]                             "", base::R.version$version.string), 
[11:02:58.426]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:58.426]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:58.426]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:58.426]                               "release", "version")], collapse = " "), 
[11:02:58.426]                             hostname = base::Sys.info()[["nodename"]])
[11:02:58.426]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:58.426]                             info)
[11:02:58.426]                           info <- base::paste(info, collapse = "; ")
[11:02:58.426]                           if (!has_future) {
[11:02:58.426]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:58.426]                               info)
[11:02:58.426]                           }
[11:02:58.426]                           else {
[11:02:58.426]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:58.426]                               info, version)
[11:02:58.426]                           }
[11:02:58.426]                           base::stop(msg)
[11:02:58.426]                         }
[11:02:58.426]                       })
[11:02:58.426]                     }
[11:02:58.426]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:58.426]                     base::options(mc.cores = 1L)
[11:02:58.426]                   }
[11:02:58.426]                   ...future.strategy.old <- future::plan("list")
[11:02:58.426]                   options(future.plan = NULL)
[11:02:58.426]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:58.426]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:58.426]                 }
[11:02:58.426]                 ...future.workdir <- getwd()
[11:02:58.426]             }
[11:02:58.426]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:58.426]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:58.426]         }
[11:02:58.426]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:58.426]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:58.426]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:58.426]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:58.426]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:58.426]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:58.426]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:58.426]             base::names(...future.oldOptions))
[11:02:58.426]     }
[11:02:58.426]     if (FALSE) {
[11:02:58.426]     }
[11:02:58.426]     else {
[11:02:58.426]         if (TRUE) {
[11:02:58.426]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:58.426]                 open = "w")
[11:02:58.426]         }
[11:02:58.426]         else {
[11:02:58.426]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:58.426]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:58.426]         }
[11:02:58.426]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:58.426]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:58.426]             base::sink(type = "output", split = FALSE)
[11:02:58.426]             base::close(...future.stdout)
[11:02:58.426]         }, add = TRUE)
[11:02:58.426]     }
[11:02:58.426]     ...future.frame <- base::sys.nframe()
[11:02:58.426]     ...future.conditions <- base::list()
[11:02:58.426]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:58.426]     if (FALSE) {
[11:02:58.426]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:58.426]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:58.426]     }
[11:02:58.426]     ...future.result <- base::tryCatch({
[11:02:58.426]         base::withCallingHandlers({
[11:02:58.426]             ...future.value <- base::withVisible(base::local({
[11:02:58.426]                 ...future.makeSendCondition <- base::local({
[11:02:58.426]                   sendCondition <- NULL
[11:02:58.426]                   function(frame = 1L) {
[11:02:58.426]                     if (is.function(sendCondition)) 
[11:02:58.426]                       return(sendCondition)
[11:02:58.426]                     ns <- getNamespace("parallel")
[11:02:58.426]                     if (exists("sendData", mode = "function", 
[11:02:58.426]                       envir = ns)) {
[11:02:58.426]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:58.426]                         envir = ns)
[11:02:58.426]                       envir <- sys.frame(frame)
[11:02:58.426]                       master <- NULL
[11:02:58.426]                       while (!identical(envir, .GlobalEnv) && 
[11:02:58.426]                         !identical(envir, emptyenv())) {
[11:02:58.426]                         if (exists("master", mode = "list", envir = envir, 
[11:02:58.426]                           inherits = FALSE)) {
[11:02:58.426]                           master <- get("master", mode = "list", 
[11:02:58.426]                             envir = envir, inherits = FALSE)
[11:02:58.426]                           if (inherits(master, c("SOCKnode", 
[11:02:58.426]                             "SOCK0node"))) {
[11:02:58.426]                             sendCondition <<- function(cond) {
[11:02:58.426]                               data <- list(type = "VALUE", value = cond, 
[11:02:58.426]                                 success = TRUE)
[11:02:58.426]                               parallel_sendData(master, data)
[11:02:58.426]                             }
[11:02:58.426]                             return(sendCondition)
[11:02:58.426]                           }
[11:02:58.426]                         }
[11:02:58.426]                         frame <- frame + 1L
[11:02:58.426]                         envir <- sys.frame(frame)
[11:02:58.426]                       }
[11:02:58.426]                     }
[11:02:58.426]                     sendCondition <<- function(cond) NULL
[11:02:58.426]                   }
[11:02:58.426]                 })
[11:02:58.426]                 withCallingHandlers({
[11:02:58.426]                   {
[11:02:58.426]                     2
[11:02:58.426]                   }
[11:02:58.426]                 }, immediateCondition = function(cond) {
[11:02:58.426]                   sendCondition <- ...future.makeSendCondition()
[11:02:58.426]                   sendCondition(cond)
[11:02:58.426]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:58.426]                   {
[11:02:58.426]                     inherits <- base::inherits
[11:02:58.426]                     invokeRestart <- base::invokeRestart
[11:02:58.426]                     is.null <- base::is.null
[11:02:58.426]                     muffled <- FALSE
[11:02:58.426]                     if (inherits(cond, "message")) {
[11:02:58.426]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:58.426]                       if (muffled) 
[11:02:58.426]                         invokeRestart("muffleMessage")
[11:02:58.426]                     }
[11:02:58.426]                     else if (inherits(cond, "warning")) {
[11:02:58.426]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:58.426]                       if (muffled) 
[11:02:58.426]                         invokeRestart("muffleWarning")
[11:02:58.426]                     }
[11:02:58.426]                     else if (inherits(cond, "condition")) {
[11:02:58.426]                       if (!is.null(pattern)) {
[11:02:58.426]                         computeRestarts <- base::computeRestarts
[11:02:58.426]                         grepl <- base::grepl
[11:02:58.426]                         restarts <- computeRestarts(cond)
[11:02:58.426]                         for (restart in restarts) {
[11:02:58.426]                           name <- restart$name
[11:02:58.426]                           if (is.null(name)) 
[11:02:58.426]                             next
[11:02:58.426]                           if (!grepl(pattern, name)) 
[11:02:58.426]                             next
[11:02:58.426]                           invokeRestart(restart)
[11:02:58.426]                           muffled <- TRUE
[11:02:58.426]                           break
[11:02:58.426]                         }
[11:02:58.426]                       }
[11:02:58.426]                     }
[11:02:58.426]                     invisible(muffled)
[11:02:58.426]                   }
[11:02:58.426]                   muffleCondition(cond)
[11:02:58.426]                 })
[11:02:58.426]             }))
[11:02:58.426]             future::FutureResult(value = ...future.value$value, 
[11:02:58.426]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:58.426]                   ...future.rng), globalenv = if (FALSE) 
[11:02:58.426]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:58.426]                     ...future.globalenv.names))
[11:02:58.426]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:58.426]         }, condition = base::local({
[11:02:58.426]             c <- base::c
[11:02:58.426]             inherits <- base::inherits
[11:02:58.426]             invokeRestart <- base::invokeRestart
[11:02:58.426]             length <- base::length
[11:02:58.426]             list <- base::list
[11:02:58.426]             seq.int <- base::seq.int
[11:02:58.426]             signalCondition <- base::signalCondition
[11:02:58.426]             sys.calls <- base::sys.calls
[11:02:58.426]             `[[` <- base::`[[`
[11:02:58.426]             `+` <- base::`+`
[11:02:58.426]             `<<-` <- base::`<<-`
[11:02:58.426]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:58.426]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:58.426]                   3L)]
[11:02:58.426]             }
[11:02:58.426]             function(cond) {
[11:02:58.426]                 is_error <- inherits(cond, "error")
[11:02:58.426]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:58.426]                   NULL)
[11:02:58.426]                 if (is_error) {
[11:02:58.426]                   sessionInformation <- function() {
[11:02:58.426]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:58.426]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:58.426]                       search = base::search(), system = base::Sys.info())
[11:02:58.426]                   }
[11:02:58.426]                   ...future.conditions[[length(...future.conditions) + 
[11:02:58.426]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:58.426]                     cond$call), session = sessionInformation(), 
[11:02:58.426]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:58.426]                   signalCondition(cond)
[11:02:58.426]                 }
[11:02:58.426]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:58.426]                 "immediateCondition"))) {
[11:02:58.426]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:58.426]                   ...future.conditions[[length(...future.conditions) + 
[11:02:58.426]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:58.426]                   if (TRUE && !signal) {
[11:02:58.426]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:58.426]                     {
[11:02:58.426]                       inherits <- base::inherits
[11:02:58.426]                       invokeRestart <- base::invokeRestart
[11:02:58.426]                       is.null <- base::is.null
[11:02:58.426]                       muffled <- FALSE
[11:02:58.426]                       if (inherits(cond, "message")) {
[11:02:58.426]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:58.426]                         if (muffled) 
[11:02:58.426]                           invokeRestart("muffleMessage")
[11:02:58.426]                       }
[11:02:58.426]                       else if (inherits(cond, "warning")) {
[11:02:58.426]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:58.426]                         if (muffled) 
[11:02:58.426]                           invokeRestart("muffleWarning")
[11:02:58.426]                       }
[11:02:58.426]                       else if (inherits(cond, "condition")) {
[11:02:58.426]                         if (!is.null(pattern)) {
[11:02:58.426]                           computeRestarts <- base::computeRestarts
[11:02:58.426]                           grepl <- base::grepl
[11:02:58.426]                           restarts <- computeRestarts(cond)
[11:02:58.426]                           for (restart in restarts) {
[11:02:58.426]                             name <- restart$name
[11:02:58.426]                             if (is.null(name)) 
[11:02:58.426]                               next
[11:02:58.426]                             if (!grepl(pattern, name)) 
[11:02:58.426]                               next
[11:02:58.426]                             invokeRestart(restart)
[11:02:58.426]                             muffled <- TRUE
[11:02:58.426]                             break
[11:02:58.426]                           }
[11:02:58.426]                         }
[11:02:58.426]                       }
[11:02:58.426]                       invisible(muffled)
[11:02:58.426]                     }
[11:02:58.426]                     muffleCondition(cond, pattern = "^muffle")
[11:02:58.426]                   }
[11:02:58.426]                 }
[11:02:58.426]                 else {
[11:02:58.426]                   if (TRUE) {
[11:02:58.426]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:58.426]                     {
[11:02:58.426]                       inherits <- base::inherits
[11:02:58.426]                       invokeRestart <- base::invokeRestart
[11:02:58.426]                       is.null <- base::is.null
[11:02:58.426]                       muffled <- FALSE
[11:02:58.426]                       if (inherits(cond, "message")) {
[11:02:58.426]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:58.426]                         if (muffled) 
[11:02:58.426]                           invokeRestart("muffleMessage")
[11:02:58.426]                       }
[11:02:58.426]                       else if (inherits(cond, "warning")) {
[11:02:58.426]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:58.426]                         if (muffled) 
[11:02:58.426]                           invokeRestart("muffleWarning")
[11:02:58.426]                       }
[11:02:58.426]                       else if (inherits(cond, "condition")) {
[11:02:58.426]                         if (!is.null(pattern)) {
[11:02:58.426]                           computeRestarts <- base::computeRestarts
[11:02:58.426]                           grepl <- base::grepl
[11:02:58.426]                           restarts <- computeRestarts(cond)
[11:02:58.426]                           for (restart in restarts) {
[11:02:58.426]                             name <- restart$name
[11:02:58.426]                             if (is.null(name)) 
[11:02:58.426]                               next
[11:02:58.426]                             if (!grepl(pattern, name)) 
[11:02:58.426]                               next
[11:02:58.426]                             invokeRestart(restart)
[11:02:58.426]                             muffled <- TRUE
[11:02:58.426]                             break
[11:02:58.426]                           }
[11:02:58.426]                         }
[11:02:58.426]                       }
[11:02:58.426]                       invisible(muffled)
[11:02:58.426]                     }
[11:02:58.426]                     muffleCondition(cond, pattern = "^muffle")
[11:02:58.426]                   }
[11:02:58.426]                 }
[11:02:58.426]             }
[11:02:58.426]         }))
[11:02:58.426]     }, error = function(ex) {
[11:02:58.426]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:58.426]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:58.426]                 ...future.rng), started = ...future.startTime, 
[11:02:58.426]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:58.426]             version = "1.8"), class = "FutureResult")
[11:02:58.426]     }, finally = {
[11:02:58.426]         if (!identical(...future.workdir, getwd())) 
[11:02:58.426]             setwd(...future.workdir)
[11:02:58.426]         {
[11:02:58.426]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:58.426]                 ...future.oldOptions$nwarnings <- NULL
[11:02:58.426]             }
[11:02:58.426]             base::options(...future.oldOptions)
[11:02:58.426]             if (.Platform$OS.type == "windows") {
[11:02:58.426]                 old_names <- names(...future.oldEnvVars)
[11:02:58.426]                 envs <- base::Sys.getenv()
[11:02:58.426]                 names <- names(envs)
[11:02:58.426]                 common <- intersect(names, old_names)
[11:02:58.426]                 added <- setdiff(names, old_names)
[11:02:58.426]                 removed <- setdiff(old_names, names)
[11:02:58.426]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:58.426]                   envs[common]]
[11:02:58.426]                 NAMES <- toupper(changed)
[11:02:58.426]                 args <- list()
[11:02:58.426]                 for (kk in seq_along(NAMES)) {
[11:02:58.426]                   name <- changed[[kk]]
[11:02:58.426]                   NAME <- NAMES[[kk]]
[11:02:58.426]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:58.426]                     next
[11:02:58.426]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:58.426]                 }
[11:02:58.426]                 NAMES <- toupper(added)
[11:02:58.426]                 for (kk in seq_along(NAMES)) {
[11:02:58.426]                   name <- added[[kk]]
[11:02:58.426]                   NAME <- NAMES[[kk]]
[11:02:58.426]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:58.426]                     next
[11:02:58.426]                   args[[name]] <- ""
[11:02:58.426]                 }
[11:02:58.426]                 NAMES <- toupper(removed)
[11:02:58.426]                 for (kk in seq_along(NAMES)) {
[11:02:58.426]                   name <- removed[[kk]]
[11:02:58.426]                   NAME <- NAMES[[kk]]
[11:02:58.426]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:58.426]                     next
[11:02:58.426]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:58.426]                 }
[11:02:58.426]                 if (length(args) > 0) 
[11:02:58.426]                   base::do.call(base::Sys.setenv, args = args)
[11:02:58.426]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:58.426]             }
[11:02:58.426]             else {
[11:02:58.426]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:58.426]             }
[11:02:58.426]             {
[11:02:58.426]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:58.426]                   0L) {
[11:02:58.426]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:58.426]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:58.426]                   base::options(opts)
[11:02:58.426]                 }
[11:02:58.426]                 {
[11:02:58.426]                   {
[11:02:58.426]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:58.426]                     NULL
[11:02:58.426]                   }
[11:02:58.426]                   options(future.plan = NULL)
[11:02:58.426]                   if (is.na(NA_character_)) 
[11:02:58.426]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:58.426]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:58.426]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:58.426]                     .init = FALSE)
[11:02:58.426]                 }
[11:02:58.426]             }
[11:02:58.426]         }
[11:02:58.426]     })
[11:02:58.426]     if (TRUE) {
[11:02:58.426]         base::sink(type = "output", split = FALSE)
[11:02:58.426]         if (TRUE) {
[11:02:58.426]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:58.426]         }
[11:02:58.426]         else {
[11:02:58.426]             ...future.result["stdout"] <- base::list(NULL)
[11:02:58.426]         }
[11:02:58.426]         base::close(...future.stdout)
[11:02:58.426]         ...future.stdout <- NULL
[11:02:58.426]     }
[11:02:58.426]     ...future.result$conditions <- ...future.conditions
[11:02:58.426]     ...future.result$finished <- base::Sys.time()
[11:02:58.426]     ...future.result
[11:02:58.426] }
[11:02:58.429] MultisessionFuture started
[11:02:58.429] - Launch lazy future ... done
[11:02:58.429] run() for ‘MultisessionFuture’ ... done
[11:02:58.429] resolve() on list environment ...
[11:02:58.429]  recursive: 0
[11:02:58.430]  length: 3
[11:02:58.430]  elements: ‘a’, ‘b’, ‘c’
[11:02:58.451]  length: 2 (resolved future 3)
[11:02:58.462] receiveMessageFromWorker() for ClusterFuture ...
[11:02:58.462] - Validating connection of MultisessionFuture
[11:02:58.462] - received message: FutureResult
[11:02:58.462] - Received FutureResult
[11:02:58.462] - Erased future from FutureRegistry
[11:02:58.462] result() for ClusterFuture ...
[11:02:58.463] - result already collected: FutureResult
[11:02:58.463] result() for ClusterFuture ... done
[11:02:58.463] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:58.463] Future #1
[11:02:58.463]  length: 1 (resolved future 1)
[11:02:58.470] receiveMessageFromWorker() for ClusterFuture ...
[11:02:58.470] - Validating connection of MultisessionFuture
[11:02:58.470] - received message: FutureResult
[11:02:58.470] - Received FutureResult
[11:02:58.471] - Erased future from FutureRegistry
[11:02:58.471] result() for ClusterFuture ...
[11:02:58.471] - result already collected: FutureResult
[11:02:58.471] result() for ClusterFuture ... done
[11:02:58.471] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:58.471] Future #2
[11:02:58.471]  length: 0 (resolved future 2)
[11:02:58.471] resolve() on list environment ... DONE
[11:02:58.472] getGlobalsAndPackages() ...
[11:02:58.472] Searching for globals...
[11:02:58.472] - globals found: [1] ‘{’
[11:02:58.472] Searching for globals ... DONE
[11:02:58.472] Resolving globals: FALSE
[11:02:58.473] 
[11:02:58.473] 
[11:02:58.473] getGlobalsAndPackages() ... DONE
[11:02:58.473] run() for ‘Future’ ...
[11:02:58.473] - state: ‘created’
[11:02:58.473] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:58.487] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:58.487] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:58.487]   - Field: ‘node’
[11:02:58.487]   - Field: ‘label’
[11:02:58.487]   - Field: ‘local’
[11:02:58.487]   - Field: ‘owner’
[11:02:58.487]   - Field: ‘envir’
[11:02:58.487]   - Field: ‘workers’
[11:02:58.488]   - Field: ‘packages’
[11:02:58.488]   - Field: ‘gc’
[11:02:58.488]   - Field: ‘conditions’
[11:02:58.488]   - Field: ‘persistent’
[11:02:58.488]   - Field: ‘expr’
[11:02:58.488]   - Field: ‘uuid’
[11:02:58.488]   - Field: ‘seed’
[11:02:58.488]   - Field: ‘version’
[11:02:58.488]   - Field: ‘result’
[11:02:58.488]   - Field: ‘asynchronous’
[11:02:58.488]   - Field: ‘calls’
[11:02:58.488]   - Field: ‘globals’
[11:02:58.489]   - Field: ‘stdout’
[11:02:58.489]   - Field: ‘earlySignal’
[11:02:58.489]   - Field: ‘lazy’
[11:02:58.489]   - Field: ‘state’
[11:02:58.489] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:58.489] - Launch lazy future ...
[11:02:58.489] Packages needed by the future expression (n = 0): <none>
[11:02:58.489] Packages needed by future strategies (n = 0): <none>
[11:02:58.490] {
[11:02:58.490]     {
[11:02:58.490]         {
[11:02:58.490]             ...future.startTime <- base::Sys.time()
[11:02:58.490]             {
[11:02:58.490]                 {
[11:02:58.490]                   {
[11:02:58.490]                     {
[11:02:58.490]                       base::local({
[11:02:58.490]                         has_future <- base::requireNamespace("future", 
[11:02:58.490]                           quietly = TRUE)
[11:02:58.490]                         if (has_future) {
[11:02:58.490]                           ns <- base::getNamespace("future")
[11:02:58.490]                           version <- ns[[".package"]][["version"]]
[11:02:58.490]                           if (is.null(version)) 
[11:02:58.490]                             version <- utils::packageVersion("future")
[11:02:58.490]                         }
[11:02:58.490]                         else {
[11:02:58.490]                           version <- NULL
[11:02:58.490]                         }
[11:02:58.490]                         if (!has_future || version < "1.8.0") {
[11:02:58.490]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:58.490]                             "", base::R.version$version.string), 
[11:02:58.490]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:58.490]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:58.490]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:58.490]                               "release", "version")], collapse = " "), 
[11:02:58.490]                             hostname = base::Sys.info()[["nodename"]])
[11:02:58.490]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:58.490]                             info)
[11:02:58.490]                           info <- base::paste(info, collapse = "; ")
[11:02:58.490]                           if (!has_future) {
[11:02:58.490]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:58.490]                               info)
[11:02:58.490]                           }
[11:02:58.490]                           else {
[11:02:58.490]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:58.490]                               info, version)
[11:02:58.490]                           }
[11:02:58.490]                           base::stop(msg)
[11:02:58.490]                         }
[11:02:58.490]                       })
[11:02:58.490]                     }
[11:02:58.490]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:58.490]                     base::options(mc.cores = 1L)
[11:02:58.490]                   }
[11:02:58.490]                   ...future.strategy.old <- future::plan("list")
[11:02:58.490]                   options(future.plan = NULL)
[11:02:58.490]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:58.490]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:58.490]                 }
[11:02:58.490]                 ...future.workdir <- getwd()
[11:02:58.490]             }
[11:02:58.490]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:58.490]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:58.490]         }
[11:02:58.490]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:58.490]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:58.490]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:58.490]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:58.490]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:58.490]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:58.490]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:58.490]             base::names(...future.oldOptions))
[11:02:58.490]     }
[11:02:58.490]     if (FALSE) {
[11:02:58.490]     }
[11:02:58.490]     else {
[11:02:58.490]         if (TRUE) {
[11:02:58.490]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:58.490]                 open = "w")
[11:02:58.490]         }
[11:02:58.490]         else {
[11:02:58.490]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:58.490]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:58.490]         }
[11:02:58.490]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:58.490]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:58.490]             base::sink(type = "output", split = FALSE)
[11:02:58.490]             base::close(...future.stdout)
[11:02:58.490]         }, add = TRUE)
[11:02:58.490]     }
[11:02:58.490]     ...future.frame <- base::sys.nframe()
[11:02:58.490]     ...future.conditions <- base::list()
[11:02:58.490]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:58.490]     if (FALSE) {
[11:02:58.490]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:58.490]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:58.490]     }
[11:02:58.490]     ...future.result <- base::tryCatch({
[11:02:58.490]         base::withCallingHandlers({
[11:02:58.490]             ...future.value <- base::withVisible(base::local({
[11:02:58.490]                 ...future.makeSendCondition <- base::local({
[11:02:58.490]                   sendCondition <- NULL
[11:02:58.490]                   function(frame = 1L) {
[11:02:58.490]                     if (is.function(sendCondition)) 
[11:02:58.490]                       return(sendCondition)
[11:02:58.490]                     ns <- getNamespace("parallel")
[11:02:58.490]                     if (exists("sendData", mode = "function", 
[11:02:58.490]                       envir = ns)) {
[11:02:58.490]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:58.490]                         envir = ns)
[11:02:58.490]                       envir <- sys.frame(frame)
[11:02:58.490]                       master <- NULL
[11:02:58.490]                       while (!identical(envir, .GlobalEnv) && 
[11:02:58.490]                         !identical(envir, emptyenv())) {
[11:02:58.490]                         if (exists("master", mode = "list", envir = envir, 
[11:02:58.490]                           inherits = FALSE)) {
[11:02:58.490]                           master <- get("master", mode = "list", 
[11:02:58.490]                             envir = envir, inherits = FALSE)
[11:02:58.490]                           if (inherits(master, c("SOCKnode", 
[11:02:58.490]                             "SOCK0node"))) {
[11:02:58.490]                             sendCondition <<- function(cond) {
[11:02:58.490]                               data <- list(type = "VALUE", value = cond, 
[11:02:58.490]                                 success = TRUE)
[11:02:58.490]                               parallel_sendData(master, data)
[11:02:58.490]                             }
[11:02:58.490]                             return(sendCondition)
[11:02:58.490]                           }
[11:02:58.490]                         }
[11:02:58.490]                         frame <- frame + 1L
[11:02:58.490]                         envir <- sys.frame(frame)
[11:02:58.490]                       }
[11:02:58.490]                     }
[11:02:58.490]                     sendCondition <<- function(cond) NULL
[11:02:58.490]                   }
[11:02:58.490]                 })
[11:02:58.490]                 withCallingHandlers({
[11:02:58.490]                   {
[11:02:58.490]                     1
[11:02:58.490]                   }
[11:02:58.490]                 }, immediateCondition = function(cond) {
[11:02:58.490]                   sendCondition <- ...future.makeSendCondition()
[11:02:58.490]                   sendCondition(cond)
[11:02:58.490]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:58.490]                   {
[11:02:58.490]                     inherits <- base::inherits
[11:02:58.490]                     invokeRestart <- base::invokeRestart
[11:02:58.490]                     is.null <- base::is.null
[11:02:58.490]                     muffled <- FALSE
[11:02:58.490]                     if (inherits(cond, "message")) {
[11:02:58.490]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:58.490]                       if (muffled) 
[11:02:58.490]                         invokeRestart("muffleMessage")
[11:02:58.490]                     }
[11:02:58.490]                     else if (inherits(cond, "warning")) {
[11:02:58.490]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:58.490]                       if (muffled) 
[11:02:58.490]                         invokeRestart("muffleWarning")
[11:02:58.490]                     }
[11:02:58.490]                     else if (inherits(cond, "condition")) {
[11:02:58.490]                       if (!is.null(pattern)) {
[11:02:58.490]                         computeRestarts <- base::computeRestarts
[11:02:58.490]                         grepl <- base::grepl
[11:02:58.490]                         restarts <- computeRestarts(cond)
[11:02:58.490]                         for (restart in restarts) {
[11:02:58.490]                           name <- restart$name
[11:02:58.490]                           if (is.null(name)) 
[11:02:58.490]                             next
[11:02:58.490]                           if (!grepl(pattern, name)) 
[11:02:58.490]                             next
[11:02:58.490]                           invokeRestart(restart)
[11:02:58.490]                           muffled <- TRUE
[11:02:58.490]                           break
[11:02:58.490]                         }
[11:02:58.490]                       }
[11:02:58.490]                     }
[11:02:58.490]                     invisible(muffled)
[11:02:58.490]                   }
[11:02:58.490]                   muffleCondition(cond)
[11:02:58.490]                 })
[11:02:58.490]             }))
[11:02:58.490]             future::FutureResult(value = ...future.value$value, 
[11:02:58.490]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:58.490]                   ...future.rng), globalenv = if (FALSE) 
[11:02:58.490]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:58.490]                     ...future.globalenv.names))
[11:02:58.490]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:58.490]         }, condition = base::local({
[11:02:58.490]             c <- base::c
[11:02:58.490]             inherits <- base::inherits
[11:02:58.490]             invokeRestart <- base::invokeRestart
[11:02:58.490]             length <- base::length
[11:02:58.490]             list <- base::list
[11:02:58.490]             seq.int <- base::seq.int
[11:02:58.490]             signalCondition <- base::signalCondition
[11:02:58.490]             sys.calls <- base::sys.calls
[11:02:58.490]             `[[` <- base::`[[`
[11:02:58.490]             `+` <- base::`+`
[11:02:58.490]             `<<-` <- base::`<<-`
[11:02:58.490]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:58.490]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:58.490]                   3L)]
[11:02:58.490]             }
[11:02:58.490]             function(cond) {
[11:02:58.490]                 is_error <- inherits(cond, "error")
[11:02:58.490]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:58.490]                   NULL)
[11:02:58.490]                 if (is_error) {
[11:02:58.490]                   sessionInformation <- function() {
[11:02:58.490]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:58.490]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:58.490]                       search = base::search(), system = base::Sys.info())
[11:02:58.490]                   }
[11:02:58.490]                   ...future.conditions[[length(...future.conditions) + 
[11:02:58.490]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:58.490]                     cond$call), session = sessionInformation(), 
[11:02:58.490]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:58.490]                   signalCondition(cond)
[11:02:58.490]                 }
[11:02:58.490]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:58.490]                 "immediateCondition"))) {
[11:02:58.490]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:58.490]                   ...future.conditions[[length(...future.conditions) + 
[11:02:58.490]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:58.490]                   if (TRUE && !signal) {
[11:02:58.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:58.490]                     {
[11:02:58.490]                       inherits <- base::inherits
[11:02:58.490]                       invokeRestart <- base::invokeRestart
[11:02:58.490]                       is.null <- base::is.null
[11:02:58.490]                       muffled <- FALSE
[11:02:58.490]                       if (inherits(cond, "message")) {
[11:02:58.490]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:58.490]                         if (muffled) 
[11:02:58.490]                           invokeRestart("muffleMessage")
[11:02:58.490]                       }
[11:02:58.490]                       else if (inherits(cond, "warning")) {
[11:02:58.490]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:58.490]                         if (muffled) 
[11:02:58.490]                           invokeRestart("muffleWarning")
[11:02:58.490]                       }
[11:02:58.490]                       else if (inherits(cond, "condition")) {
[11:02:58.490]                         if (!is.null(pattern)) {
[11:02:58.490]                           computeRestarts <- base::computeRestarts
[11:02:58.490]                           grepl <- base::grepl
[11:02:58.490]                           restarts <- computeRestarts(cond)
[11:02:58.490]                           for (restart in restarts) {
[11:02:58.490]                             name <- restart$name
[11:02:58.490]                             if (is.null(name)) 
[11:02:58.490]                               next
[11:02:58.490]                             if (!grepl(pattern, name)) 
[11:02:58.490]                               next
[11:02:58.490]                             invokeRestart(restart)
[11:02:58.490]                             muffled <- TRUE
[11:02:58.490]                             break
[11:02:58.490]                           }
[11:02:58.490]                         }
[11:02:58.490]                       }
[11:02:58.490]                       invisible(muffled)
[11:02:58.490]                     }
[11:02:58.490]                     muffleCondition(cond, pattern = "^muffle")
[11:02:58.490]                   }
[11:02:58.490]                 }
[11:02:58.490]                 else {
[11:02:58.490]                   if (TRUE) {
[11:02:58.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:58.490]                     {
[11:02:58.490]                       inherits <- base::inherits
[11:02:58.490]                       invokeRestart <- base::invokeRestart
[11:02:58.490]                       is.null <- base::is.null
[11:02:58.490]                       muffled <- FALSE
[11:02:58.490]                       if (inherits(cond, "message")) {
[11:02:58.490]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:58.490]                         if (muffled) 
[11:02:58.490]                           invokeRestart("muffleMessage")
[11:02:58.490]                       }
[11:02:58.490]                       else if (inherits(cond, "warning")) {
[11:02:58.490]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:58.490]                         if (muffled) 
[11:02:58.490]                           invokeRestart("muffleWarning")
[11:02:58.490]                       }
[11:02:58.490]                       else if (inherits(cond, "condition")) {
[11:02:58.490]                         if (!is.null(pattern)) {
[11:02:58.490]                           computeRestarts <- base::computeRestarts
[11:02:58.490]                           grepl <- base::grepl
[11:02:58.490]                           restarts <- computeRestarts(cond)
[11:02:58.490]                           for (restart in restarts) {
[11:02:58.490]                             name <- restart$name
[11:02:58.490]                             if (is.null(name)) 
[11:02:58.490]                               next
[11:02:58.490]                             if (!grepl(pattern, name)) 
[11:02:58.490]                               next
[11:02:58.490]                             invokeRestart(restart)
[11:02:58.490]                             muffled <- TRUE
[11:02:58.490]                             break
[11:02:58.490]                           }
[11:02:58.490]                         }
[11:02:58.490]                       }
[11:02:58.490]                       invisible(muffled)
[11:02:58.490]                     }
[11:02:58.490]                     muffleCondition(cond, pattern = "^muffle")
[11:02:58.490]                   }
[11:02:58.490]                 }
[11:02:58.490]             }
[11:02:58.490]         }))
[11:02:58.490]     }, error = function(ex) {
[11:02:58.490]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:58.490]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:58.490]                 ...future.rng), started = ...future.startTime, 
[11:02:58.490]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:58.490]             version = "1.8"), class = "FutureResult")
[11:02:58.490]     }, finally = {
[11:02:58.490]         if (!identical(...future.workdir, getwd())) 
[11:02:58.490]             setwd(...future.workdir)
[11:02:58.490]         {
[11:02:58.490]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:58.490]                 ...future.oldOptions$nwarnings <- NULL
[11:02:58.490]             }
[11:02:58.490]             base::options(...future.oldOptions)
[11:02:58.490]             if (.Platform$OS.type == "windows") {
[11:02:58.490]                 old_names <- names(...future.oldEnvVars)
[11:02:58.490]                 envs <- base::Sys.getenv()
[11:02:58.490]                 names <- names(envs)
[11:02:58.490]                 common <- intersect(names, old_names)
[11:02:58.490]                 added <- setdiff(names, old_names)
[11:02:58.490]                 removed <- setdiff(old_names, names)
[11:02:58.490]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:58.490]                   envs[common]]
[11:02:58.490]                 NAMES <- toupper(changed)
[11:02:58.490]                 args <- list()
[11:02:58.490]                 for (kk in seq_along(NAMES)) {
[11:02:58.490]                   name <- changed[[kk]]
[11:02:58.490]                   NAME <- NAMES[[kk]]
[11:02:58.490]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:58.490]                     next
[11:02:58.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:58.490]                 }
[11:02:58.490]                 NAMES <- toupper(added)
[11:02:58.490]                 for (kk in seq_along(NAMES)) {
[11:02:58.490]                   name <- added[[kk]]
[11:02:58.490]                   NAME <- NAMES[[kk]]
[11:02:58.490]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:58.490]                     next
[11:02:58.490]                   args[[name]] <- ""
[11:02:58.490]                 }
[11:02:58.490]                 NAMES <- toupper(removed)
[11:02:58.490]                 for (kk in seq_along(NAMES)) {
[11:02:58.490]                   name <- removed[[kk]]
[11:02:58.490]                   NAME <- NAMES[[kk]]
[11:02:58.490]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:58.490]                     next
[11:02:58.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:58.490]                 }
[11:02:58.490]                 if (length(args) > 0) 
[11:02:58.490]                   base::do.call(base::Sys.setenv, args = args)
[11:02:58.490]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:58.490]             }
[11:02:58.490]             else {
[11:02:58.490]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:58.490]             }
[11:02:58.490]             {
[11:02:58.490]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:58.490]                   0L) {
[11:02:58.490]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:58.490]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:58.490]                   base::options(opts)
[11:02:58.490]                 }
[11:02:58.490]                 {
[11:02:58.490]                   {
[11:02:58.490]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:58.490]                     NULL
[11:02:58.490]                   }
[11:02:58.490]                   options(future.plan = NULL)
[11:02:58.490]                   if (is.na(NA_character_)) 
[11:02:58.490]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:58.490]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:58.490]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:58.490]                     .init = FALSE)
[11:02:58.490]                 }
[11:02:58.490]             }
[11:02:58.490]         }
[11:02:58.490]     })
[11:02:58.490]     if (TRUE) {
[11:02:58.490]         base::sink(type = "output", split = FALSE)
[11:02:58.490]         if (TRUE) {
[11:02:58.490]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:58.490]         }
[11:02:58.490]         else {
[11:02:58.490]             ...future.result["stdout"] <- base::list(NULL)
[11:02:58.490]         }
[11:02:58.490]         base::close(...future.stdout)
[11:02:58.490]         ...future.stdout <- NULL
[11:02:58.490]     }
[11:02:58.490]     ...future.result$conditions <- ...future.conditions
[11:02:58.490]     ...future.result$finished <- base::Sys.time()
[11:02:58.490]     ...future.result
[11:02:58.490] }
[11:02:58.493] MultisessionFuture started
[11:02:58.493] - Launch lazy future ... done
[11:02:58.493] run() for ‘MultisessionFuture’ ... done
[11:02:58.493] getGlobalsAndPackages() ...
[11:02:58.493] Searching for globals...
[11:02:58.494] - globals found: [2] ‘{’, ‘Sys.sleep’
[11:02:58.494] Searching for globals ... DONE
[11:02:58.494] Resolving globals: FALSE
[11:02:58.495] 
[11:02:58.495] 
[11:02:58.495] getGlobalsAndPackages() ... DONE
[11:02:58.495] run() for ‘Future’ ...
[11:02:58.495] - state: ‘created’
[11:02:58.495] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:58.516] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:58.516] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:58.516]   - Field: ‘node’
[11:02:58.516]   - Field: ‘label’
[11:02:58.516]   - Field: ‘local’
[11:02:58.516]   - Field: ‘owner’
[11:02:58.516]   - Field: ‘envir’
[11:02:58.517]   - Field: ‘workers’
[11:02:58.517]   - Field: ‘packages’
[11:02:58.517]   - Field: ‘gc’
[11:02:58.517]   - Field: ‘conditions’
[11:02:58.517]   - Field: ‘persistent’
[11:02:58.517]   - Field: ‘expr’
[11:02:58.517]   - Field: ‘uuid’
[11:02:58.517]   - Field: ‘seed’
[11:02:58.517]   - Field: ‘version’
[11:02:58.517]   - Field: ‘result’
[11:02:58.517]   - Field: ‘asynchronous’
[11:02:58.517]   - Field: ‘calls’
[11:02:58.518]   - Field: ‘globals’
[11:02:58.518]   - Field: ‘stdout’
[11:02:58.518]   - Field: ‘earlySignal’
[11:02:58.518]   - Field: ‘lazy’
[11:02:58.518]   - Field: ‘state’
[11:02:58.518] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:58.518] - Launch lazy future ...
[11:02:58.518] Packages needed by the future expression (n = 0): <none>
[11:02:58.518] Packages needed by future strategies (n = 0): <none>
[11:02:58.519] {
[11:02:58.519]     {
[11:02:58.519]         {
[11:02:58.519]             ...future.startTime <- base::Sys.time()
[11:02:58.519]             {
[11:02:58.519]                 {
[11:02:58.519]                   {
[11:02:58.519]                     {
[11:02:58.519]                       base::local({
[11:02:58.519]                         has_future <- base::requireNamespace("future", 
[11:02:58.519]                           quietly = TRUE)
[11:02:58.519]                         if (has_future) {
[11:02:58.519]                           ns <- base::getNamespace("future")
[11:02:58.519]                           version <- ns[[".package"]][["version"]]
[11:02:58.519]                           if (is.null(version)) 
[11:02:58.519]                             version <- utils::packageVersion("future")
[11:02:58.519]                         }
[11:02:58.519]                         else {
[11:02:58.519]                           version <- NULL
[11:02:58.519]                         }
[11:02:58.519]                         if (!has_future || version < "1.8.0") {
[11:02:58.519]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:58.519]                             "", base::R.version$version.string), 
[11:02:58.519]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:58.519]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:58.519]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:58.519]                               "release", "version")], collapse = " "), 
[11:02:58.519]                             hostname = base::Sys.info()[["nodename"]])
[11:02:58.519]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:58.519]                             info)
[11:02:58.519]                           info <- base::paste(info, collapse = "; ")
[11:02:58.519]                           if (!has_future) {
[11:02:58.519]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:58.519]                               info)
[11:02:58.519]                           }
[11:02:58.519]                           else {
[11:02:58.519]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:58.519]                               info, version)
[11:02:58.519]                           }
[11:02:58.519]                           base::stop(msg)
[11:02:58.519]                         }
[11:02:58.519]                       })
[11:02:58.519]                     }
[11:02:58.519]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:58.519]                     base::options(mc.cores = 1L)
[11:02:58.519]                   }
[11:02:58.519]                   ...future.strategy.old <- future::plan("list")
[11:02:58.519]                   options(future.plan = NULL)
[11:02:58.519]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:58.519]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:58.519]                 }
[11:02:58.519]                 ...future.workdir <- getwd()
[11:02:58.519]             }
[11:02:58.519]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:58.519]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:58.519]         }
[11:02:58.519]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:58.519]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:58.519]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:58.519]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:58.519]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:58.519]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:58.519]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:58.519]             base::names(...future.oldOptions))
[11:02:58.519]     }
[11:02:58.519]     if (FALSE) {
[11:02:58.519]     }
[11:02:58.519]     else {
[11:02:58.519]         if (TRUE) {
[11:02:58.519]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:58.519]                 open = "w")
[11:02:58.519]         }
[11:02:58.519]         else {
[11:02:58.519]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:58.519]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:58.519]         }
[11:02:58.519]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:58.519]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:58.519]             base::sink(type = "output", split = FALSE)
[11:02:58.519]             base::close(...future.stdout)
[11:02:58.519]         }, add = TRUE)
[11:02:58.519]     }
[11:02:58.519]     ...future.frame <- base::sys.nframe()
[11:02:58.519]     ...future.conditions <- base::list()
[11:02:58.519]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:58.519]     if (FALSE) {
[11:02:58.519]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:58.519]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:58.519]     }
[11:02:58.519]     ...future.result <- base::tryCatch({
[11:02:58.519]         base::withCallingHandlers({
[11:02:58.519]             ...future.value <- base::withVisible(base::local({
[11:02:58.519]                 ...future.makeSendCondition <- base::local({
[11:02:58.519]                   sendCondition <- NULL
[11:02:58.519]                   function(frame = 1L) {
[11:02:58.519]                     if (is.function(sendCondition)) 
[11:02:58.519]                       return(sendCondition)
[11:02:58.519]                     ns <- getNamespace("parallel")
[11:02:58.519]                     if (exists("sendData", mode = "function", 
[11:02:58.519]                       envir = ns)) {
[11:02:58.519]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:58.519]                         envir = ns)
[11:02:58.519]                       envir <- sys.frame(frame)
[11:02:58.519]                       master <- NULL
[11:02:58.519]                       while (!identical(envir, .GlobalEnv) && 
[11:02:58.519]                         !identical(envir, emptyenv())) {
[11:02:58.519]                         if (exists("master", mode = "list", envir = envir, 
[11:02:58.519]                           inherits = FALSE)) {
[11:02:58.519]                           master <- get("master", mode = "list", 
[11:02:58.519]                             envir = envir, inherits = FALSE)
[11:02:58.519]                           if (inherits(master, c("SOCKnode", 
[11:02:58.519]                             "SOCK0node"))) {
[11:02:58.519]                             sendCondition <<- function(cond) {
[11:02:58.519]                               data <- list(type = "VALUE", value = cond, 
[11:02:58.519]                                 success = TRUE)
[11:02:58.519]                               parallel_sendData(master, data)
[11:02:58.519]                             }
[11:02:58.519]                             return(sendCondition)
[11:02:58.519]                           }
[11:02:58.519]                         }
[11:02:58.519]                         frame <- frame + 1L
[11:02:58.519]                         envir <- sys.frame(frame)
[11:02:58.519]                       }
[11:02:58.519]                     }
[11:02:58.519]                     sendCondition <<- function(cond) NULL
[11:02:58.519]                   }
[11:02:58.519]                 })
[11:02:58.519]                 withCallingHandlers({
[11:02:58.519]                   {
[11:02:58.519]                     Sys.sleep(0.5)
[11:02:58.519]                     2
[11:02:58.519]                   }
[11:02:58.519]                 }, immediateCondition = function(cond) {
[11:02:58.519]                   sendCondition <- ...future.makeSendCondition()
[11:02:58.519]                   sendCondition(cond)
[11:02:58.519]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:58.519]                   {
[11:02:58.519]                     inherits <- base::inherits
[11:02:58.519]                     invokeRestart <- base::invokeRestart
[11:02:58.519]                     is.null <- base::is.null
[11:02:58.519]                     muffled <- FALSE
[11:02:58.519]                     if (inherits(cond, "message")) {
[11:02:58.519]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:58.519]                       if (muffled) 
[11:02:58.519]                         invokeRestart("muffleMessage")
[11:02:58.519]                     }
[11:02:58.519]                     else if (inherits(cond, "warning")) {
[11:02:58.519]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:58.519]                       if (muffled) 
[11:02:58.519]                         invokeRestart("muffleWarning")
[11:02:58.519]                     }
[11:02:58.519]                     else if (inherits(cond, "condition")) {
[11:02:58.519]                       if (!is.null(pattern)) {
[11:02:58.519]                         computeRestarts <- base::computeRestarts
[11:02:58.519]                         grepl <- base::grepl
[11:02:58.519]                         restarts <- computeRestarts(cond)
[11:02:58.519]                         for (restart in restarts) {
[11:02:58.519]                           name <- restart$name
[11:02:58.519]                           if (is.null(name)) 
[11:02:58.519]                             next
[11:02:58.519]                           if (!grepl(pattern, name)) 
[11:02:58.519]                             next
[11:02:58.519]                           invokeRestart(restart)
[11:02:58.519]                           muffled <- TRUE
[11:02:58.519]                           break
[11:02:58.519]                         }
[11:02:58.519]                       }
[11:02:58.519]                     }
[11:02:58.519]                     invisible(muffled)
[11:02:58.519]                   }
[11:02:58.519]                   muffleCondition(cond)
[11:02:58.519]                 })
[11:02:58.519]             }))
[11:02:58.519]             future::FutureResult(value = ...future.value$value, 
[11:02:58.519]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:58.519]                   ...future.rng), globalenv = if (FALSE) 
[11:02:58.519]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:58.519]                     ...future.globalenv.names))
[11:02:58.519]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:58.519]         }, condition = base::local({
[11:02:58.519]             c <- base::c
[11:02:58.519]             inherits <- base::inherits
[11:02:58.519]             invokeRestart <- base::invokeRestart
[11:02:58.519]             length <- base::length
[11:02:58.519]             list <- base::list
[11:02:58.519]             seq.int <- base::seq.int
[11:02:58.519]             signalCondition <- base::signalCondition
[11:02:58.519]             sys.calls <- base::sys.calls
[11:02:58.519]             `[[` <- base::`[[`
[11:02:58.519]             `+` <- base::`+`
[11:02:58.519]             `<<-` <- base::`<<-`
[11:02:58.519]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:58.519]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:58.519]                   3L)]
[11:02:58.519]             }
[11:02:58.519]             function(cond) {
[11:02:58.519]                 is_error <- inherits(cond, "error")
[11:02:58.519]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:58.519]                   NULL)
[11:02:58.519]                 if (is_error) {
[11:02:58.519]                   sessionInformation <- function() {
[11:02:58.519]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:58.519]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:58.519]                       search = base::search(), system = base::Sys.info())
[11:02:58.519]                   }
[11:02:58.519]                   ...future.conditions[[length(...future.conditions) + 
[11:02:58.519]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:58.519]                     cond$call), session = sessionInformation(), 
[11:02:58.519]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:58.519]                   signalCondition(cond)
[11:02:58.519]                 }
[11:02:58.519]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:58.519]                 "immediateCondition"))) {
[11:02:58.519]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:58.519]                   ...future.conditions[[length(...future.conditions) + 
[11:02:58.519]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:58.519]                   if (TRUE && !signal) {
[11:02:58.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:58.519]                     {
[11:02:58.519]                       inherits <- base::inherits
[11:02:58.519]                       invokeRestart <- base::invokeRestart
[11:02:58.519]                       is.null <- base::is.null
[11:02:58.519]                       muffled <- FALSE
[11:02:58.519]                       if (inherits(cond, "message")) {
[11:02:58.519]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:58.519]                         if (muffled) 
[11:02:58.519]                           invokeRestart("muffleMessage")
[11:02:58.519]                       }
[11:02:58.519]                       else if (inherits(cond, "warning")) {
[11:02:58.519]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:58.519]                         if (muffled) 
[11:02:58.519]                           invokeRestart("muffleWarning")
[11:02:58.519]                       }
[11:02:58.519]                       else if (inherits(cond, "condition")) {
[11:02:58.519]                         if (!is.null(pattern)) {
[11:02:58.519]                           computeRestarts <- base::computeRestarts
[11:02:58.519]                           grepl <- base::grepl
[11:02:58.519]                           restarts <- computeRestarts(cond)
[11:02:58.519]                           for (restart in restarts) {
[11:02:58.519]                             name <- restart$name
[11:02:58.519]                             if (is.null(name)) 
[11:02:58.519]                               next
[11:02:58.519]                             if (!grepl(pattern, name)) 
[11:02:58.519]                               next
[11:02:58.519]                             invokeRestart(restart)
[11:02:58.519]                             muffled <- TRUE
[11:02:58.519]                             break
[11:02:58.519]                           }
[11:02:58.519]                         }
[11:02:58.519]                       }
[11:02:58.519]                       invisible(muffled)
[11:02:58.519]                     }
[11:02:58.519]                     muffleCondition(cond, pattern = "^muffle")
[11:02:58.519]                   }
[11:02:58.519]                 }
[11:02:58.519]                 else {
[11:02:58.519]                   if (TRUE) {
[11:02:58.519]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:58.519]                     {
[11:02:58.519]                       inherits <- base::inherits
[11:02:58.519]                       invokeRestart <- base::invokeRestart
[11:02:58.519]                       is.null <- base::is.null
[11:02:58.519]                       muffled <- FALSE
[11:02:58.519]                       if (inherits(cond, "message")) {
[11:02:58.519]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:58.519]                         if (muffled) 
[11:02:58.519]                           invokeRestart("muffleMessage")
[11:02:58.519]                       }
[11:02:58.519]                       else if (inherits(cond, "warning")) {
[11:02:58.519]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:58.519]                         if (muffled) 
[11:02:58.519]                           invokeRestart("muffleWarning")
[11:02:58.519]                       }
[11:02:58.519]                       else if (inherits(cond, "condition")) {
[11:02:58.519]                         if (!is.null(pattern)) {
[11:02:58.519]                           computeRestarts <- base::computeRestarts
[11:02:58.519]                           grepl <- base::grepl
[11:02:58.519]                           restarts <- computeRestarts(cond)
[11:02:58.519]                           for (restart in restarts) {
[11:02:58.519]                             name <- restart$name
[11:02:58.519]                             if (is.null(name)) 
[11:02:58.519]                               next
[11:02:58.519]                             if (!grepl(pattern, name)) 
[11:02:58.519]                               next
[11:02:58.519]                             invokeRestart(restart)
[11:02:58.519]                             muffled <- TRUE
[11:02:58.519]                             break
[11:02:58.519]                           }
[11:02:58.519]                         }
[11:02:58.519]                       }
[11:02:58.519]                       invisible(muffled)
[11:02:58.519]                     }
[11:02:58.519]                     muffleCondition(cond, pattern = "^muffle")
[11:02:58.519]                   }
[11:02:58.519]                 }
[11:02:58.519]             }
[11:02:58.519]         }))
[11:02:58.519]     }, error = function(ex) {
[11:02:58.519]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:58.519]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:58.519]                 ...future.rng), started = ...future.startTime, 
[11:02:58.519]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:58.519]             version = "1.8"), class = "FutureResult")
[11:02:58.519]     }, finally = {
[11:02:58.519]         if (!identical(...future.workdir, getwd())) 
[11:02:58.519]             setwd(...future.workdir)
[11:02:58.519]         {
[11:02:58.519]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:58.519]                 ...future.oldOptions$nwarnings <- NULL
[11:02:58.519]             }
[11:02:58.519]             base::options(...future.oldOptions)
[11:02:58.519]             if (.Platform$OS.type == "windows") {
[11:02:58.519]                 old_names <- names(...future.oldEnvVars)
[11:02:58.519]                 envs <- base::Sys.getenv()
[11:02:58.519]                 names <- names(envs)
[11:02:58.519]                 common <- intersect(names, old_names)
[11:02:58.519]                 added <- setdiff(names, old_names)
[11:02:58.519]                 removed <- setdiff(old_names, names)
[11:02:58.519]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:58.519]                   envs[common]]
[11:02:58.519]                 NAMES <- toupper(changed)
[11:02:58.519]                 args <- list()
[11:02:58.519]                 for (kk in seq_along(NAMES)) {
[11:02:58.519]                   name <- changed[[kk]]
[11:02:58.519]                   NAME <- NAMES[[kk]]
[11:02:58.519]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:58.519]                     next
[11:02:58.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:58.519]                 }
[11:02:58.519]                 NAMES <- toupper(added)
[11:02:58.519]                 for (kk in seq_along(NAMES)) {
[11:02:58.519]                   name <- added[[kk]]
[11:02:58.519]                   NAME <- NAMES[[kk]]
[11:02:58.519]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:58.519]                     next
[11:02:58.519]                   args[[name]] <- ""
[11:02:58.519]                 }
[11:02:58.519]                 NAMES <- toupper(removed)
[11:02:58.519]                 for (kk in seq_along(NAMES)) {
[11:02:58.519]                   name <- removed[[kk]]
[11:02:58.519]                   NAME <- NAMES[[kk]]
[11:02:58.519]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:58.519]                     next
[11:02:58.519]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:58.519]                 }
[11:02:58.519]                 if (length(args) > 0) 
[11:02:58.519]                   base::do.call(base::Sys.setenv, args = args)
[11:02:58.519]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:58.519]             }
[11:02:58.519]             else {
[11:02:58.519]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:58.519]             }
[11:02:58.519]             {
[11:02:58.519]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:58.519]                   0L) {
[11:02:58.519]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:58.519]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:58.519]                   base::options(opts)
[11:02:58.519]                 }
[11:02:58.519]                 {
[11:02:58.519]                   {
[11:02:58.519]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:58.519]                     NULL
[11:02:58.519]                   }
[11:02:58.519]                   options(future.plan = NULL)
[11:02:58.519]                   if (is.na(NA_character_)) 
[11:02:58.519]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:58.519]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:58.519]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:58.519]                     .init = FALSE)
[11:02:58.519]                 }
[11:02:58.519]             }
[11:02:58.519]         }
[11:02:58.519]     })
[11:02:58.519]     if (TRUE) {
[11:02:58.519]         base::sink(type = "output", split = FALSE)
[11:02:58.519]         if (TRUE) {
[11:02:58.519]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:58.519]         }
[11:02:58.519]         else {
[11:02:58.519]             ...future.result["stdout"] <- base::list(NULL)
[11:02:58.519]         }
[11:02:58.519]         base::close(...future.stdout)
[11:02:58.519]         ...future.stdout <- NULL
[11:02:58.519]     }
[11:02:58.519]     ...future.result$conditions <- ...future.conditions
[11:02:58.519]     ...future.result$finished <- base::Sys.time()
[11:02:58.519]     ...future.result
[11:02:58.519] }
[11:02:58.522] MultisessionFuture started
[11:02:58.522] - Launch lazy future ... done
[11:02:58.522] run() for ‘MultisessionFuture’ ... done
[11:02:58.522] getGlobalsAndPackages() ...
[11:02:58.522] Searching for globals...
[11:02:58.523] - globals found: [1] ‘{’
[11:02:58.523] Searching for globals ... DONE
[11:02:58.523] Resolving globals: FALSE
[11:02:58.523] 
[11:02:58.523] 
[11:02:58.523] getGlobalsAndPackages() ... DONE
[11:02:58.524] run() for ‘Future’ ...
[11:02:58.524] - state: ‘created’
[11:02:58.524] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:58.538] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:58.538] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:58.538]   - Field: ‘node’
[11:02:58.538]   - Field: ‘label’
[11:02:58.538]   - Field: ‘local’
[11:02:58.539]   - Field: ‘owner’
[11:02:58.539]   - Field: ‘envir’
[11:02:58.539]   - Field: ‘workers’
[11:02:58.539]   - Field: ‘packages’
[11:02:58.539]   - Field: ‘gc’
[11:02:58.539]   - Field: ‘conditions’
[11:02:58.539]   - Field: ‘persistent’
[11:02:58.539]   - Field: ‘expr’
[11:02:58.539]   - Field: ‘uuid’
[11:02:58.539]   - Field: ‘seed’
[11:02:58.539]   - Field: ‘version’
[11:02:58.539]   - Field: ‘result’
[11:02:58.539]   - Field: ‘asynchronous’
[11:02:58.540]   - Field: ‘calls’
[11:02:58.540]   - Field: ‘globals’
[11:02:58.540]   - Field: ‘stdout’
[11:02:58.540]   - Field: ‘earlySignal’
[11:02:58.540]   - Field: ‘lazy’
[11:02:58.540]   - Field: ‘state’
[11:02:58.540] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:58.540] - Launch lazy future ...
[11:02:58.540] Packages needed by the future expression (n = 0): <none>
[11:02:58.540] Packages needed by future strategies (n = 0): <none>
[11:02:58.541] {
[11:02:58.541]     {
[11:02:58.541]         {
[11:02:58.541]             ...future.startTime <- base::Sys.time()
[11:02:58.541]             {
[11:02:58.541]                 {
[11:02:58.541]                   {
[11:02:58.541]                     {
[11:02:58.541]                       base::local({
[11:02:58.541]                         has_future <- base::requireNamespace("future", 
[11:02:58.541]                           quietly = TRUE)
[11:02:58.541]                         if (has_future) {
[11:02:58.541]                           ns <- base::getNamespace("future")
[11:02:58.541]                           version <- ns[[".package"]][["version"]]
[11:02:58.541]                           if (is.null(version)) 
[11:02:58.541]                             version <- utils::packageVersion("future")
[11:02:58.541]                         }
[11:02:58.541]                         else {
[11:02:58.541]                           version <- NULL
[11:02:58.541]                         }
[11:02:58.541]                         if (!has_future || version < "1.8.0") {
[11:02:58.541]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:58.541]                             "", base::R.version$version.string), 
[11:02:58.541]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:58.541]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:58.541]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:58.541]                               "release", "version")], collapse = " "), 
[11:02:58.541]                             hostname = base::Sys.info()[["nodename"]])
[11:02:58.541]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:58.541]                             info)
[11:02:58.541]                           info <- base::paste(info, collapse = "; ")
[11:02:58.541]                           if (!has_future) {
[11:02:58.541]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:58.541]                               info)
[11:02:58.541]                           }
[11:02:58.541]                           else {
[11:02:58.541]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:58.541]                               info, version)
[11:02:58.541]                           }
[11:02:58.541]                           base::stop(msg)
[11:02:58.541]                         }
[11:02:58.541]                       })
[11:02:58.541]                     }
[11:02:58.541]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:58.541]                     base::options(mc.cores = 1L)
[11:02:58.541]                   }
[11:02:58.541]                   ...future.strategy.old <- future::plan("list")
[11:02:58.541]                   options(future.plan = NULL)
[11:02:58.541]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:58.541]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:58.541]                 }
[11:02:58.541]                 ...future.workdir <- getwd()
[11:02:58.541]             }
[11:02:58.541]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:58.541]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:58.541]         }
[11:02:58.541]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:58.541]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:58.541]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:58.541]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:58.541]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:58.541]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:58.541]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:58.541]             base::names(...future.oldOptions))
[11:02:58.541]     }
[11:02:58.541]     if (FALSE) {
[11:02:58.541]     }
[11:02:58.541]     else {
[11:02:58.541]         if (TRUE) {
[11:02:58.541]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:58.541]                 open = "w")
[11:02:58.541]         }
[11:02:58.541]         else {
[11:02:58.541]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:58.541]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:58.541]         }
[11:02:58.541]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:58.541]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:58.541]             base::sink(type = "output", split = FALSE)
[11:02:58.541]             base::close(...future.stdout)
[11:02:58.541]         }, add = TRUE)
[11:02:58.541]     }
[11:02:58.541]     ...future.frame <- base::sys.nframe()
[11:02:58.541]     ...future.conditions <- base::list()
[11:02:58.541]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:58.541]     if (FALSE) {
[11:02:58.541]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:58.541]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:58.541]     }
[11:02:58.541]     ...future.result <- base::tryCatch({
[11:02:58.541]         base::withCallingHandlers({
[11:02:58.541]             ...future.value <- base::withVisible(base::local({
[11:02:58.541]                 ...future.makeSendCondition <- base::local({
[11:02:58.541]                   sendCondition <- NULL
[11:02:58.541]                   function(frame = 1L) {
[11:02:58.541]                     if (is.function(sendCondition)) 
[11:02:58.541]                       return(sendCondition)
[11:02:58.541]                     ns <- getNamespace("parallel")
[11:02:58.541]                     if (exists("sendData", mode = "function", 
[11:02:58.541]                       envir = ns)) {
[11:02:58.541]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:58.541]                         envir = ns)
[11:02:58.541]                       envir <- sys.frame(frame)
[11:02:58.541]                       master <- NULL
[11:02:58.541]                       while (!identical(envir, .GlobalEnv) && 
[11:02:58.541]                         !identical(envir, emptyenv())) {
[11:02:58.541]                         if (exists("master", mode = "list", envir = envir, 
[11:02:58.541]                           inherits = FALSE)) {
[11:02:58.541]                           master <- get("master", mode = "list", 
[11:02:58.541]                             envir = envir, inherits = FALSE)
[11:02:58.541]                           if (inherits(master, c("SOCKnode", 
[11:02:58.541]                             "SOCK0node"))) {
[11:02:58.541]                             sendCondition <<- function(cond) {
[11:02:58.541]                               data <- list(type = "VALUE", value = cond, 
[11:02:58.541]                                 success = TRUE)
[11:02:58.541]                               parallel_sendData(master, data)
[11:02:58.541]                             }
[11:02:58.541]                             return(sendCondition)
[11:02:58.541]                           }
[11:02:58.541]                         }
[11:02:58.541]                         frame <- frame + 1L
[11:02:58.541]                         envir <- sys.frame(frame)
[11:02:58.541]                       }
[11:02:58.541]                     }
[11:02:58.541]                     sendCondition <<- function(cond) NULL
[11:02:58.541]                   }
[11:02:58.541]                 })
[11:02:58.541]                 withCallingHandlers({
[11:02:58.541]                   {
[11:02:58.541]                     3
[11:02:58.541]                   }
[11:02:58.541]                 }, immediateCondition = function(cond) {
[11:02:58.541]                   sendCondition <- ...future.makeSendCondition()
[11:02:58.541]                   sendCondition(cond)
[11:02:58.541]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:58.541]                   {
[11:02:58.541]                     inherits <- base::inherits
[11:02:58.541]                     invokeRestart <- base::invokeRestart
[11:02:58.541]                     is.null <- base::is.null
[11:02:58.541]                     muffled <- FALSE
[11:02:58.541]                     if (inherits(cond, "message")) {
[11:02:58.541]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:58.541]                       if (muffled) 
[11:02:58.541]                         invokeRestart("muffleMessage")
[11:02:58.541]                     }
[11:02:58.541]                     else if (inherits(cond, "warning")) {
[11:02:58.541]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:58.541]                       if (muffled) 
[11:02:58.541]                         invokeRestart("muffleWarning")
[11:02:58.541]                     }
[11:02:58.541]                     else if (inherits(cond, "condition")) {
[11:02:58.541]                       if (!is.null(pattern)) {
[11:02:58.541]                         computeRestarts <- base::computeRestarts
[11:02:58.541]                         grepl <- base::grepl
[11:02:58.541]                         restarts <- computeRestarts(cond)
[11:02:58.541]                         for (restart in restarts) {
[11:02:58.541]                           name <- restart$name
[11:02:58.541]                           if (is.null(name)) 
[11:02:58.541]                             next
[11:02:58.541]                           if (!grepl(pattern, name)) 
[11:02:58.541]                             next
[11:02:58.541]                           invokeRestart(restart)
[11:02:58.541]                           muffled <- TRUE
[11:02:58.541]                           break
[11:02:58.541]                         }
[11:02:58.541]                       }
[11:02:58.541]                     }
[11:02:58.541]                     invisible(muffled)
[11:02:58.541]                   }
[11:02:58.541]                   muffleCondition(cond)
[11:02:58.541]                 })
[11:02:58.541]             }))
[11:02:58.541]             future::FutureResult(value = ...future.value$value, 
[11:02:58.541]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:58.541]                   ...future.rng), globalenv = if (FALSE) 
[11:02:58.541]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:58.541]                     ...future.globalenv.names))
[11:02:58.541]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:58.541]         }, condition = base::local({
[11:02:58.541]             c <- base::c
[11:02:58.541]             inherits <- base::inherits
[11:02:58.541]             invokeRestart <- base::invokeRestart
[11:02:58.541]             length <- base::length
[11:02:58.541]             list <- base::list
[11:02:58.541]             seq.int <- base::seq.int
[11:02:58.541]             signalCondition <- base::signalCondition
[11:02:58.541]             sys.calls <- base::sys.calls
[11:02:58.541]             `[[` <- base::`[[`
[11:02:58.541]             `+` <- base::`+`
[11:02:58.541]             `<<-` <- base::`<<-`
[11:02:58.541]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:58.541]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:58.541]                   3L)]
[11:02:58.541]             }
[11:02:58.541]             function(cond) {
[11:02:58.541]                 is_error <- inherits(cond, "error")
[11:02:58.541]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:58.541]                   NULL)
[11:02:58.541]                 if (is_error) {
[11:02:58.541]                   sessionInformation <- function() {
[11:02:58.541]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:58.541]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:58.541]                       search = base::search(), system = base::Sys.info())
[11:02:58.541]                   }
[11:02:58.541]                   ...future.conditions[[length(...future.conditions) + 
[11:02:58.541]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:58.541]                     cond$call), session = sessionInformation(), 
[11:02:58.541]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:58.541]                   signalCondition(cond)
[11:02:58.541]                 }
[11:02:58.541]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:58.541]                 "immediateCondition"))) {
[11:02:58.541]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:58.541]                   ...future.conditions[[length(...future.conditions) + 
[11:02:58.541]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:58.541]                   if (TRUE && !signal) {
[11:02:58.541]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:58.541]                     {
[11:02:58.541]                       inherits <- base::inherits
[11:02:58.541]                       invokeRestart <- base::invokeRestart
[11:02:58.541]                       is.null <- base::is.null
[11:02:58.541]                       muffled <- FALSE
[11:02:58.541]                       if (inherits(cond, "message")) {
[11:02:58.541]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:58.541]                         if (muffled) 
[11:02:58.541]                           invokeRestart("muffleMessage")
[11:02:58.541]                       }
[11:02:58.541]                       else if (inherits(cond, "warning")) {
[11:02:58.541]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:58.541]                         if (muffled) 
[11:02:58.541]                           invokeRestart("muffleWarning")
[11:02:58.541]                       }
[11:02:58.541]                       else if (inherits(cond, "condition")) {
[11:02:58.541]                         if (!is.null(pattern)) {
[11:02:58.541]                           computeRestarts <- base::computeRestarts
[11:02:58.541]                           grepl <- base::grepl
[11:02:58.541]                           restarts <- computeRestarts(cond)
[11:02:58.541]                           for (restart in restarts) {
[11:02:58.541]                             name <- restart$name
[11:02:58.541]                             if (is.null(name)) 
[11:02:58.541]                               next
[11:02:58.541]                             if (!grepl(pattern, name)) 
[11:02:58.541]                               next
[11:02:58.541]                             invokeRestart(restart)
[11:02:58.541]                             muffled <- TRUE
[11:02:58.541]                             break
[11:02:58.541]                           }
[11:02:58.541]                         }
[11:02:58.541]                       }
[11:02:58.541]                       invisible(muffled)
[11:02:58.541]                     }
[11:02:58.541]                     muffleCondition(cond, pattern = "^muffle")
[11:02:58.541]                   }
[11:02:58.541]                 }
[11:02:58.541]                 else {
[11:02:58.541]                   if (TRUE) {
[11:02:58.541]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:58.541]                     {
[11:02:58.541]                       inherits <- base::inherits
[11:02:58.541]                       invokeRestart <- base::invokeRestart
[11:02:58.541]                       is.null <- base::is.null
[11:02:58.541]                       muffled <- FALSE
[11:02:58.541]                       if (inherits(cond, "message")) {
[11:02:58.541]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:58.541]                         if (muffled) 
[11:02:58.541]                           invokeRestart("muffleMessage")
[11:02:58.541]                       }
[11:02:58.541]                       else if (inherits(cond, "warning")) {
[11:02:58.541]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:58.541]                         if (muffled) 
[11:02:58.541]                           invokeRestart("muffleWarning")
[11:02:58.541]                       }
[11:02:58.541]                       else if (inherits(cond, "condition")) {
[11:02:58.541]                         if (!is.null(pattern)) {
[11:02:58.541]                           computeRestarts <- base::computeRestarts
[11:02:58.541]                           grepl <- base::grepl
[11:02:58.541]                           restarts <- computeRestarts(cond)
[11:02:58.541]                           for (restart in restarts) {
[11:02:58.541]                             name <- restart$name
[11:02:58.541]                             if (is.null(name)) 
[11:02:58.541]                               next
[11:02:58.541]                             if (!grepl(pattern, name)) 
[11:02:58.541]                               next
[11:02:58.541]                             invokeRestart(restart)
[11:02:58.541]                             muffled <- TRUE
[11:02:58.541]                             break
[11:02:58.541]                           }
[11:02:58.541]                         }
[11:02:58.541]                       }
[11:02:58.541]                       invisible(muffled)
[11:02:58.541]                     }
[11:02:58.541]                     muffleCondition(cond, pattern = "^muffle")
[11:02:58.541]                   }
[11:02:58.541]                 }
[11:02:58.541]             }
[11:02:58.541]         }))
[11:02:58.541]     }, error = function(ex) {
[11:02:58.541]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:58.541]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:58.541]                 ...future.rng), started = ...future.startTime, 
[11:02:58.541]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:58.541]             version = "1.8"), class = "FutureResult")
[11:02:58.541]     }, finally = {
[11:02:58.541]         if (!identical(...future.workdir, getwd())) 
[11:02:58.541]             setwd(...future.workdir)
[11:02:58.541]         {
[11:02:58.541]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:58.541]                 ...future.oldOptions$nwarnings <- NULL
[11:02:58.541]             }
[11:02:58.541]             base::options(...future.oldOptions)
[11:02:58.541]             if (.Platform$OS.type == "windows") {
[11:02:58.541]                 old_names <- names(...future.oldEnvVars)
[11:02:58.541]                 envs <- base::Sys.getenv()
[11:02:58.541]                 names <- names(envs)
[11:02:58.541]                 common <- intersect(names, old_names)
[11:02:58.541]                 added <- setdiff(names, old_names)
[11:02:58.541]                 removed <- setdiff(old_names, names)
[11:02:58.541]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:58.541]                   envs[common]]
[11:02:58.541]                 NAMES <- toupper(changed)
[11:02:58.541]                 args <- list()
[11:02:58.541]                 for (kk in seq_along(NAMES)) {
[11:02:58.541]                   name <- changed[[kk]]
[11:02:58.541]                   NAME <- NAMES[[kk]]
[11:02:58.541]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:58.541]                     next
[11:02:58.541]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:58.541]                 }
[11:02:58.541]                 NAMES <- toupper(added)
[11:02:58.541]                 for (kk in seq_along(NAMES)) {
[11:02:58.541]                   name <- added[[kk]]
[11:02:58.541]                   NAME <- NAMES[[kk]]
[11:02:58.541]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:58.541]                     next
[11:02:58.541]                   args[[name]] <- ""
[11:02:58.541]                 }
[11:02:58.541]                 NAMES <- toupper(removed)
[11:02:58.541]                 for (kk in seq_along(NAMES)) {
[11:02:58.541]                   name <- removed[[kk]]
[11:02:58.541]                   NAME <- NAMES[[kk]]
[11:02:58.541]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:58.541]                     next
[11:02:58.541]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:58.541]                 }
[11:02:58.541]                 if (length(args) > 0) 
[11:02:58.541]                   base::do.call(base::Sys.setenv, args = args)
[11:02:58.541]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:58.541]             }
[11:02:58.541]             else {
[11:02:58.541]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:58.541]             }
[11:02:58.541]             {
[11:02:58.541]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:58.541]                   0L) {
[11:02:58.541]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:58.541]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:58.541]                   base::options(opts)
[11:02:58.541]                 }
[11:02:58.541]                 {
[11:02:58.541]                   {
[11:02:58.541]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:58.541]                     NULL
[11:02:58.541]                   }
[11:02:58.541]                   options(future.plan = NULL)
[11:02:58.541]                   if (is.na(NA_character_)) 
[11:02:58.541]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:58.541]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:58.541]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:58.541]                     .init = FALSE)
[11:02:58.541]                 }
[11:02:58.541]             }
[11:02:58.541]         }
[11:02:58.541]     })
[11:02:58.541]     if (TRUE) {
[11:02:58.541]         base::sink(type = "output", split = FALSE)
[11:02:58.541]         if (TRUE) {
[11:02:58.541]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:58.541]         }
[11:02:58.541]         else {
[11:02:58.541]             ...future.result["stdout"] <- base::list(NULL)
[11:02:58.541]         }
[11:02:58.541]         base::close(...future.stdout)
[11:02:58.541]         ...future.stdout <- NULL
[11:02:58.541]     }
[11:02:58.541]     ...future.result$conditions <- ...future.conditions
[11:02:58.541]     ...future.result$finished <- base::Sys.time()
[11:02:58.541]     ...future.result
[11:02:58.541] }
[11:02:58.543] Poll #1 (0): usedNodes() = 2, workers = 2
[11:02:58.554] receiveMessageFromWorker() for ClusterFuture ...
[11:02:58.554] - Validating connection of MultisessionFuture
[11:02:58.554] - received message: FutureResult
[11:02:58.554] - Received FutureResult
[11:02:58.554] - Erased future from FutureRegistry
[11:02:58.554] result() for ClusterFuture ...
[11:02:58.554] - result already collected: FutureResult
[11:02:58.554] result() for ClusterFuture ... done
[11:02:58.554] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:58.555] result() for ClusterFuture ...
[11:02:58.555] - result already collected: FutureResult
[11:02:58.555] result() for ClusterFuture ... done
[11:02:58.555] result() for ClusterFuture ...
[11:02:58.555] - result already collected: FutureResult
[11:02:58.555] result() for ClusterFuture ... done
[11:02:58.556] MultisessionFuture started
[11:02:58.556] - Launch lazy future ... done
[11:02:58.556] run() for ‘MultisessionFuture’ ... done
[11:02:58.557] resolve() on list environment ...
[11:02:58.557]  recursive: 0
[11:02:58.557]  length: 4
[11:02:58.557]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[11:02:58.558] Future #1
[11:02:58.558]  length: 3 (resolved future 1)
[11:02:58.579]  length: 2 (resolved future 4)
[11:02:58.600] receiveMessageFromWorker() for ClusterFuture ...
[11:02:58.600] - Validating connection of MultisessionFuture
[11:02:58.600] - received message: FutureResult
[11:02:58.601] - Received FutureResult
[11:02:58.601] - Erased future from FutureRegistry
[11:02:58.601] result() for ClusterFuture ...
[11:02:58.601] - result already collected: FutureResult
[11:02:58.601] result() for ClusterFuture ... done
[11:02:58.601] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:58.601] Future #3
[11:02:58.601]  length: 1 (resolved future 3)
[11:02:59.066] receiveMessageFromWorker() for ClusterFuture ...
[11:02:59.066] - Validating connection of MultisessionFuture
[11:02:59.066] - received message: FutureResult
[11:02:59.066] - Received FutureResult
[11:02:59.067] - Erased future from FutureRegistry
[11:02:59.067] result() for ClusterFuture ...
[11:02:59.067] - result already collected: FutureResult
[11:02:59.067] result() for ClusterFuture ... done
[11:02:59.067] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:59.067] Future #2
[11:02:59.067]  length: 0 (resolved future 2)
[11:02:59.067] resolve() on list environment ... DONE
[11:02:59.068] resolve() on list environment ...
[11:02:59.068]  recursive: 0
[11:02:59.068]  length: 4
[11:02:59.068]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[11:02:59.069] Future #1
[11:02:59.069]  length: 3 (resolved future 1)
[11:02:59.069] Future #2
[11:02:59.069]  length: 2 (resolved future 2)
[11:02:59.069] Future #3
[11:02:59.069]  length: 1 (resolved future 3)
[11:02:59.069]  length: 0 (resolved future 4)
[11:02:59.069] resolve() on list environment ... DONE
[11:02:59.070] resolve() on list environment ...
[11:02:59.070]  recursive: 0
[11:02:59.070]  length: 4
[11:02:59.070]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[11:02:59.071] Future #1
[11:02:59.071]  length: 3 (resolved future 1)
[11:02:59.071] Future #2
[11:02:59.071]  length: 2 (resolved future 2)
[11:02:59.071] Future #3
[11:02:59.071]  length: 1 (resolved future 3)
[11:02:59.071]  length: 0 (resolved future 4)
[11:02:59.071] resolve() on list environment ... DONE
[11:02:59.072] resolve() on list environment ...
[11:02:59.072]  recursive: 0
[11:02:59.072]  length: 4
[11:02:59.072]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[11:02:59.073] Future #1
[11:02:59.073]  length: 3 (resolved future 1)
[11:02:59.073] Future #2
[11:02:59.073]  length: 2 (resolved future 2)
[11:02:59.073] Future #3
[11:02:59.073]  length: 1 (resolved future 3)
[11:02:59.073]  length: 0 (resolved future 4)
[11:02:59.073] resolve() on list environment ... DONE
[11:02:59.074] resolve() on list environment ...
[11:02:59.074]  recursive: 0
[11:02:59.074]  length: 4
[11:02:59.074]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[11:02:59.075] Future #1
[11:02:59.075] result() for ClusterFuture ...
[11:02:59.075] - result already collected: FutureResult
[11:02:59.075] result() for ClusterFuture ... done
[11:02:59.075] result() for ClusterFuture ...
[11:02:59.075] - result already collected: FutureResult
[11:02:59.075] result() for ClusterFuture ... done
[11:02:59.075]  length: 3 (resolved future 1)
[11:02:59.075] Future #2
[11:02:59.075] result() for ClusterFuture ...
[11:02:59.075] - result already collected: FutureResult
[11:02:59.076] result() for ClusterFuture ... done
[11:02:59.076] result() for ClusterFuture ...
[11:02:59.076] - result already collected: FutureResult
[11:02:59.076] result() for ClusterFuture ... done
[11:02:59.076]  length: 2 (resolved future 2)
[11:02:59.076] Future #3
[11:02:59.076] result() for ClusterFuture ...
[11:02:59.076] - result already collected: FutureResult
[11:02:59.076] result() for ClusterFuture ... done
[11:02:59.076] result() for ClusterFuture ...
[11:02:59.076] - result already collected: FutureResult
[11:02:59.076] result() for ClusterFuture ... done
[11:02:59.077]  length: 1 (resolved future 3)
[11:02:59.077]  length: 0 (resolved future 4)
[11:02:59.077] resolve() on list environment ... DONE
[11:02:59.077] resolve() on list environment ...
[11:02:59.077]  recursive: 99
[11:02:59.078]  length: 4
[11:02:59.078]  elements: ‘a’, ‘b’, ‘c’, ‘d’
[11:02:59.078] Future #1
[11:02:59.078] result() for ClusterFuture ...
[11:02:59.078] - result already collected: FutureResult
[11:02:59.078] result() for ClusterFuture ... done
[11:02:59.078] result() for ClusterFuture ...
[11:02:59.078] - result already collected: FutureResult
[11:02:59.079] result() for ClusterFuture ... done
[11:02:59.079] A MultisessionFuture was resolved
[11:02:59.079]  length: 3 (resolved future 1)
[11:02:59.079] Future #2
[11:02:59.079] result() for ClusterFuture ...
[11:02:59.079] - result already collected: FutureResult
[11:02:59.079] result() for ClusterFuture ... done
[11:02:59.079] result() for ClusterFuture ...
[11:02:59.079] - result already collected: FutureResult
[11:02:59.079] result() for ClusterFuture ... done
[11:02:59.079] A MultisessionFuture was resolved
[11:02:59.080]  length: 2 (resolved future 2)
[11:02:59.080] Future #3
[11:02:59.080] result() for ClusterFuture ...
[11:02:59.080] - result already collected: FutureResult
[11:02:59.080] result() for ClusterFuture ... done
[11:02:59.080] result() for ClusterFuture ...
[11:02:59.080] - result already collected: FutureResult
[11:02:59.080] result() for ClusterFuture ... done
[11:02:59.080] A MultisessionFuture was resolved
[11:02:59.080]  length: 1 (resolved future 3)
[11:02:59.080]  length: 0 (resolved future 4)
[11:02:59.081] resolve() on list environment ... DONE
*** resolve() for list environments ... DONE
- plan('multisession') ...
> 
> 
> message("*** resolve() - globals with non-trustful length() ...")
*** resolve() - globals with non-trustful length() ...
> 
> length.CantTrustLength <- function(x) length(unclass(x)) + 1L
> 
> .length <- future:::.length
> 
> x <- structure(as.list(1:3), class = c("CantTrustLength", "list"))
> str(list(n = length(x), n_true = .length(x)))
List of 2
 $ n     : int 4
 $ n_true: int 3
> stopifnot(length(x) > .length(x))
> x <- resolve(x)
[11:02:59.084] resolve() on list ...
[11:02:59.084]  recursive: 0
[11:02:59.084]  length: 3
[11:02:59.084] 
[11:02:59.084]  length: 2 (resolved future 1)
[11:02:59.084]  length: 1 (resolved future 2)
[11:02:59.084]  length: 0 (resolved future 3)
[11:02:59.084] resolve() on list ... DONE
> 
> message("*** resolve() - globals with non-trustful length() ... DONE")
*** resolve() - globals with non-trustful length() ... DONE
> 
> 
> message("*** resolved() - default ...")
*** resolved() - default ...
> 
> res <- resolved(42L)
> stopifnot(isTRUE(res))
> 
> message("*** resolved() - default ... DONE")
*** resolved() - default ... DONE
> 
> 
> message("*** resolve() ... DONE")
*** resolve() ... DONE
> 
> source("incl/end.R")
[11:02:59.085] plan(): Setting new future strategy stack:
[11:02:59.085] List of future strategies:
[11:02:59.085] 1. FutureStrategy:
[11:02:59.085]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:59.085]    - tweaked: FALSE
[11:02:59.085]    - call: future::plan(oplan)
[11:02:59.086] plan(): nbrOfWorkers() = 1
> 
