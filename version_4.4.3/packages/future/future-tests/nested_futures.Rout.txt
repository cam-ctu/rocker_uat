
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[10:22:06.658] plan(): Setting new future strategy stack:
[10:22:06.658] List of future strategies:
[10:22:06.658] 1. sequential:
[10:22:06.658]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:06.658]    - tweaked: FALSE
[10:22:06.658]    - call: future::plan("sequential")
[10:22:06.672] plan(): nbrOfWorkers() = 1
> 
> strategies <- supportedStrategies()
> 
> message("*** Nested futures ...")
*** Nested futures ...
> 
> for (strategy1 in strategies) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   for (strategy2 in strategies) {
+     message(sprintf("- plan(list('%s', '%s')) ...", strategy1, strategy2))
+     plan(list(a = strategy1, b = strategy2))
+     
+     nested <- plan("list")
+     stopifnot(
+       length(nested) == 2L,
+       all(names(nested) == c("a", "b")),
+       inherits(plan("next"), strategy1)
+     )
+ 
+     x %<-% {
+       a <- 1L
+ 
+       ## IMPORTANT: Use future::plan() - not just plan() - otherwise
+       ## we're exporting the plan() function including its local stack!
+       plan_a <- unclass(future::plan("list"))
+       nested_a <- nested[-1]
+ 
+       stopifnot(
+         length(nested_a) == 1L,
+         length(plan_a) == 1L,
+         inherits(plan_a[[1]], "future"),
+         inherits(future::plan("next"), strategy2)
+       )
+ 
+       ## Attribute 'init' is modified at run time
+       for (kk in seq_along(plan_a)) attr(plan_a[[kk]], "init") <- NULL
+       for (kk in seq_along(nested_a)) attr(nested_a[[kk]], "init") <- NULL
+       stopifnot(all.equal(plan_a, nested_a))
+ 
+       y %<-% {
+         b <- 2L
+         
+         ## IMPORTANT: Use future::plan() - not just plan() - otherwise
+         ## we're exporting the plan() function including its local stack!
+         plan_b <- future::plan("list")
+         nested_b <- nested_a[-1]
+ 
+         stopifnot(
+           length(nested_b) == 0L,
+           length(plan_b) == 1L,
+           inherits(plan_b[[1]], "future"),
+           inherits(future::plan("next"), "sequential")
+         )
+ 
+         list(a = a, nested_a = nested_a, plan_a = plan_a,
+              b = b, nested_b = nested_b, plan_b = plan_b)
+       }
+       y
+     }
+ 
+     str(x)
+ 
+     stopifnot(
+       length(x) == 3 * length(nested),
+       all(names(x) == c("a", "nested_a", "plan_a",
+                         "b", "nested_b", "plan_b")),
+ 
+       x$a == 1L,
+       length(x$nested_a) == 1L,
+       is.list(x$plan_a),
+       length(x$plan_a) == 1L,
+       inherits(x$plan_a[[1]], "future"),
+ 
+       x$b == 2L,
+       length(x$nested_b) == 0L,
+       is.list(x$plan_b),
+       length(x$plan_b) == 1L,
+       inherits(x$plan_b[[1]], "future"),
+       inherits(x$plan_b[[1]], "sequential")
+     )
+ 
+     ## Attribute 'init' is modified at run time
+     for (kk in seq_along(x$plan_a)) attr(x$plan_a[[kk]], "init") <- NULL
+     for (kk in seq_along(nested)) attr(nested[[kk]], "init") <- NULL
+     stopifnot(all.equal(x$plan_a, nested[-1L]))
+ 
+     rm(list = c("nested", "x"))
+ 
+ 
+     ## Nested futures and globals
+     ## In future (<= 1.7.0), the below would produce an error saying
+     ## "Failed to locate global object in the relevant environments: 'a'"
+     ## Related to https://github.com/HenrikBengtsson/globals/issues/35
+     data <- data.frame(a = 1:3, b = 3:1)
+     y_truth <- subset(data, a == 2)
+     f <- future({
+       value(future( subset(data, a == 2) ))
+     })
+     y <- value(f)
+     stopifnot(identical(y, y_truth))
+     
+     message(sprintf("- plan(list('%s', '%s')) ... DONE", strategy1, strategy2))
+   }
+ }
- plan(list('sequential', 'sequential')) ...
[10:22:06.729] plan(): Setting new future strategy stack:
[10:22:06.730] List of future strategies:
[10:22:06.730] 1. sequential:
[10:22:06.730]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:06.730]    - tweaked: FALSE
[10:22:06.730]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:06.730] 2. sequential:
[10:22:06.730]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:06.730]    - tweaked: FALSE
[10:22:06.730]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:06.742] plan(): nbrOfWorkers() = 1
[10:22:06.743] getGlobalsAndPackages() ...
[10:22:06.743] Searching for globals...
[10:22:06.765] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[10:22:06.765] Searching for globals ... DONE
[10:22:06.765] Resolving globals: FALSE
[10:22:06.767] The total size of the 2 globals is 3.28 KiB (3359 bytes)
[10:22:06.767] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 3.28 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (3.23 KiB of class ‘list’) and ‘strategy2’ (49 bytes of class ‘character’)
[10:22:06.767] - globals: [2] ‘nested’, ‘strategy2’
[10:22:06.767] - packages: [1] ‘future’
[10:22:06.767] getGlobalsAndPackages() ... DONE
[10:22:06.768] run() for ‘Future’ ...
[10:22:06.768] - state: ‘created’
[10:22:06.768] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:06.769] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:06.769] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:06.769]   - Field: ‘label’
[10:22:06.769]   - Field: ‘local’
[10:22:06.769]   - Field: ‘owner’
[10:22:06.769]   - Field: ‘envir’
[10:22:06.769]   - Field: ‘packages’
[10:22:06.769]   - Field: ‘gc’
[10:22:06.769]   - Field: ‘conditions’
[10:22:06.769]   - Field: ‘expr’
[10:22:06.769]   - Field: ‘uuid’
[10:22:06.770]   - Field: ‘seed’
[10:22:06.770]   - Field: ‘version’
[10:22:06.770]   - Field: ‘result’
[10:22:06.770]   - Field: ‘asynchronous’
[10:22:06.770]   - Field: ‘calls’
[10:22:06.770]   - Field: ‘globals’
[10:22:06.770]   - Field: ‘stdout’
[10:22:06.770]   - Field: ‘earlySignal’
[10:22:06.770]   - Field: ‘lazy’
[10:22:06.770]   - Field: ‘state’
[10:22:06.770] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:06.771] - Launch lazy future ...
[10:22:06.771] Packages needed by the future expression (n = 1): ‘future’
[10:22:06.771] Packages needed by future strategies (n = 1): ‘future’
[10:22:06.772] {
[10:22:06.772]     {
[10:22:06.772]         {
[10:22:06.772]             ...future.startTime <- base::Sys.time()
[10:22:06.772]             {
[10:22:06.772]                 {
[10:22:06.772]                   {
[10:22:06.772]                     {
[10:22:06.772]                       base::local({
[10:22:06.772]                         has_future <- base::requireNamespace("future", 
[10:22:06.772]                           quietly = TRUE)
[10:22:06.772]                         if (has_future) {
[10:22:06.772]                           ns <- base::getNamespace("future")
[10:22:06.772]                           version <- ns[[".package"]][["version"]]
[10:22:06.772]                           if (is.null(version)) 
[10:22:06.772]                             version <- utils::packageVersion("future")
[10:22:06.772]                         }
[10:22:06.772]                         else {
[10:22:06.772]                           version <- NULL
[10:22:06.772]                         }
[10:22:06.772]                         if (!has_future || version < "1.8.0") {
[10:22:06.772]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:06.772]                             "", base::R.version$version.string), 
[10:22:06.772]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:06.772]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:06.772]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:06.772]                               "release", "version")], collapse = " "), 
[10:22:06.772]                             hostname = base::Sys.info()[["nodename"]])
[10:22:06.772]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:06.772]                             info)
[10:22:06.772]                           info <- base::paste(info, collapse = "; ")
[10:22:06.772]                           if (!has_future) {
[10:22:06.772]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:06.772]                               info)
[10:22:06.772]                           }
[10:22:06.772]                           else {
[10:22:06.772]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:06.772]                               info, version)
[10:22:06.772]                           }
[10:22:06.772]                           base::stop(msg)
[10:22:06.772]                         }
[10:22:06.772]                       })
[10:22:06.772]                     }
[10:22:06.772]                     base::local({
[10:22:06.772]                       for (pkg in "future") {
[10:22:06.772]                         base::loadNamespace(pkg)
[10:22:06.772]                         base::library(pkg, character.only = TRUE)
[10:22:06.772]                       }
[10:22:06.772]                     })
[10:22:06.772]                   }
[10:22:06.772]                   ...future.strategy.old <- future::plan("list")
[10:22:06.772]                   options(future.plan = NULL)
[10:22:06.772]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:06.772]                   future::plan(list(b = function (..., envir = parent.frame()) 
[10:22:06.772]                   {
[10:22:06.772]                     future <- SequentialFuture(..., envir = envir)
[10:22:06.772]                     if (!future$lazy) 
[10:22:06.772]                       future <- run(future)
[10:22:06.772]                     invisible(future)
[10:22:06.772]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:06.772]                 }
[10:22:06.772]                 ...future.workdir <- getwd()
[10:22:06.772]             }
[10:22:06.772]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:06.772]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:06.772]         }
[10:22:06.772]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:06.772]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:06.772]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:06.772]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:06.772]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:06.772]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:06.772]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:06.772]             base::names(...future.oldOptions))
[10:22:06.772]     }
[10:22:06.772]     if (FALSE) {
[10:22:06.772]     }
[10:22:06.772]     else {
[10:22:06.772]         if (TRUE) {
[10:22:06.772]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:06.772]                 open = "w")
[10:22:06.772]         }
[10:22:06.772]         else {
[10:22:06.772]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:06.772]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:06.772]         }
[10:22:06.772]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:06.772]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:06.772]             base::sink(type = "output", split = FALSE)
[10:22:06.772]             base::close(...future.stdout)
[10:22:06.772]         }, add = TRUE)
[10:22:06.772]     }
[10:22:06.772]     ...future.frame <- base::sys.nframe()
[10:22:06.772]     ...future.conditions <- base::list()
[10:22:06.772]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:06.772]     if (FALSE) {
[10:22:06.772]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:06.772]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:06.772]     }
[10:22:06.772]     ...future.result <- base::tryCatch({
[10:22:06.772]         base::withCallingHandlers({
[10:22:06.772]             ...future.value <- base::withVisible(base::local({
[10:22:06.772]                 a <- 1L
[10:22:06.772]                 plan_a <- unclass(future::plan("list"))
[10:22:06.772]                 nested_a <- nested[-1]
[10:22:06.772]                 stopifnot(length(nested_a) == 1L, length(plan_a) == 
[10:22:06.772]                   1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[10:22:06.772]                   strategy2))
[10:22:06.772]                 for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[10:22:06.772]                   "init") <- NULL
[10:22:06.772]                 for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[10:22:06.772]                   "init") <- NULL
[10:22:06.772]                 stopifnot(all.equal(plan_a, nested_a))
[10:22:06.772]                 y %<-% {
[10:22:06.772]                   b <- 2L
[10:22:06.772]                   plan_b <- future::plan("list")
[10:22:06.772]                   nested_b <- nested_a[-1]
[10:22:06.772]                   stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:22:06.772]                     1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[10:22:06.772]                     "sequential"))
[10:22:06.772]                   list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:22:06.772]                     b = b, nested_b = nested_b, plan_b = plan_b)
[10:22:06.772]                 }
[10:22:06.772]                 y
[10:22:06.772]             }))
[10:22:06.772]             future::FutureResult(value = ...future.value$value, 
[10:22:06.772]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:06.772]                   ...future.rng), globalenv = if (FALSE) 
[10:22:06.772]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:06.772]                     ...future.globalenv.names))
[10:22:06.772]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:06.772]         }, condition = base::local({
[10:22:06.772]             c <- base::c
[10:22:06.772]             inherits <- base::inherits
[10:22:06.772]             invokeRestart <- base::invokeRestart
[10:22:06.772]             length <- base::length
[10:22:06.772]             list <- base::list
[10:22:06.772]             seq.int <- base::seq.int
[10:22:06.772]             signalCondition <- base::signalCondition
[10:22:06.772]             sys.calls <- base::sys.calls
[10:22:06.772]             `[[` <- base::`[[`
[10:22:06.772]             `+` <- base::`+`
[10:22:06.772]             `<<-` <- base::`<<-`
[10:22:06.772]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:06.772]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:06.772]                   3L)]
[10:22:06.772]             }
[10:22:06.772]             function(cond) {
[10:22:06.772]                 is_error <- inherits(cond, "error")
[10:22:06.772]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:06.772]                   NULL)
[10:22:06.772]                 if (is_error) {
[10:22:06.772]                   sessionInformation <- function() {
[10:22:06.772]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:06.772]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:06.772]                       search = base::search(), system = base::Sys.info())
[10:22:06.772]                   }
[10:22:06.772]                   ...future.conditions[[length(...future.conditions) + 
[10:22:06.772]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:06.772]                     cond$call), session = sessionInformation(), 
[10:22:06.772]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:06.772]                   signalCondition(cond)
[10:22:06.772]                 }
[10:22:06.772]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:06.772]                 "immediateCondition"))) {
[10:22:06.772]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:06.772]                   ...future.conditions[[length(...future.conditions) + 
[10:22:06.772]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:06.772]                   if (TRUE && !signal) {
[10:22:06.772]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:06.772]                     {
[10:22:06.772]                       inherits <- base::inherits
[10:22:06.772]                       invokeRestart <- base::invokeRestart
[10:22:06.772]                       is.null <- base::is.null
[10:22:06.772]                       muffled <- FALSE
[10:22:06.772]                       if (inherits(cond, "message")) {
[10:22:06.772]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:06.772]                         if (muffled) 
[10:22:06.772]                           invokeRestart("muffleMessage")
[10:22:06.772]                       }
[10:22:06.772]                       else if (inherits(cond, "warning")) {
[10:22:06.772]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:06.772]                         if (muffled) 
[10:22:06.772]                           invokeRestart("muffleWarning")
[10:22:06.772]                       }
[10:22:06.772]                       else if (inherits(cond, "condition")) {
[10:22:06.772]                         if (!is.null(pattern)) {
[10:22:06.772]                           computeRestarts <- base::computeRestarts
[10:22:06.772]                           grepl <- base::grepl
[10:22:06.772]                           restarts <- computeRestarts(cond)
[10:22:06.772]                           for (restart in restarts) {
[10:22:06.772]                             name <- restart$name
[10:22:06.772]                             if (is.null(name)) 
[10:22:06.772]                               next
[10:22:06.772]                             if (!grepl(pattern, name)) 
[10:22:06.772]                               next
[10:22:06.772]                             invokeRestart(restart)
[10:22:06.772]                             muffled <- TRUE
[10:22:06.772]                             break
[10:22:06.772]                           }
[10:22:06.772]                         }
[10:22:06.772]                       }
[10:22:06.772]                       invisible(muffled)
[10:22:06.772]                     }
[10:22:06.772]                     muffleCondition(cond, pattern = "^muffle")
[10:22:06.772]                   }
[10:22:06.772]                 }
[10:22:06.772]                 else {
[10:22:06.772]                   if (TRUE) {
[10:22:06.772]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:06.772]                     {
[10:22:06.772]                       inherits <- base::inherits
[10:22:06.772]                       invokeRestart <- base::invokeRestart
[10:22:06.772]                       is.null <- base::is.null
[10:22:06.772]                       muffled <- FALSE
[10:22:06.772]                       if (inherits(cond, "message")) {
[10:22:06.772]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:06.772]                         if (muffled) 
[10:22:06.772]                           invokeRestart("muffleMessage")
[10:22:06.772]                       }
[10:22:06.772]                       else if (inherits(cond, "warning")) {
[10:22:06.772]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:06.772]                         if (muffled) 
[10:22:06.772]                           invokeRestart("muffleWarning")
[10:22:06.772]                       }
[10:22:06.772]                       else if (inherits(cond, "condition")) {
[10:22:06.772]                         if (!is.null(pattern)) {
[10:22:06.772]                           computeRestarts <- base::computeRestarts
[10:22:06.772]                           grepl <- base::grepl
[10:22:06.772]                           restarts <- computeRestarts(cond)
[10:22:06.772]                           for (restart in restarts) {
[10:22:06.772]                             name <- restart$name
[10:22:06.772]                             if (is.null(name)) 
[10:22:06.772]                               next
[10:22:06.772]                             if (!grepl(pattern, name)) 
[10:22:06.772]                               next
[10:22:06.772]                             invokeRestart(restart)
[10:22:06.772]                             muffled <- TRUE
[10:22:06.772]                             break
[10:22:06.772]                           }
[10:22:06.772]                         }
[10:22:06.772]                       }
[10:22:06.772]                       invisible(muffled)
[10:22:06.772]                     }
[10:22:06.772]                     muffleCondition(cond, pattern = "^muffle")
[10:22:06.772]                   }
[10:22:06.772]                 }
[10:22:06.772]             }
[10:22:06.772]         }))
[10:22:06.772]     }, error = function(ex) {
[10:22:06.772]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:06.772]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:06.772]                 ...future.rng), started = ...future.startTime, 
[10:22:06.772]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:06.772]             version = "1.8"), class = "FutureResult")
[10:22:06.772]     }, finally = {
[10:22:06.772]         if (!identical(...future.workdir, getwd())) 
[10:22:06.772]             setwd(...future.workdir)
[10:22:06.772]         {
[10:22:06.772]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:06.772]                 ...future.oldOptions$nwarnings <- NULL
[10:22:06.772]             }
[10:22:06.772]             base::options(...future.oldOptions)
[10:22:06.772]             if (.Platform$OS.type == "windows") {
[10:22:06.772]                 old_names <- names(...future.oldEnvVars)
[10:22:06.772]                 envs <- base::Sys.getenv()
[10:22:06.772]                 names <- names(envs)
[10:22:06.772]                 common <- intersect(names, old_names)
[10:22:06.772]                 added <- setdiff(names, old_names)
[10:22:06.772]                 removed <- setdiff(old_names, names)
[10:22:06.772]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:06.772]                   envs[common]]
[10:22:06.772]                 NAMES <- toupper(changed)
[10:22:06.772]                 args <- list()
[10:22:06.772]                 for (kk in seq_along(NAMES)) {
[10:22:06.772]                   name <- changed[[kk]]
[10:22:06.772]                   NAME <- NAMES[[kk]]
[10:22:06.772]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:06.772]                     next
[10:22:06.772]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:06.772]                 }
[10:22:06.772]                 NAMES <- toupper(added)
[10:22:06.772]                 for (kk in seq_along(NAMES)) {
[10:22:06.772]                   name <- added[[kk]]
[10:22:06.772]                   NAME <- NAMES[[kk]]
[10:22:06.772]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:06.772]                     next
[10:22:06.772]                   args[[name]] <- ""
[10:22:06.772]                 }
[10:22:06.772]                 NAMES <- toupper(removed)
[10:22:06.772]                 for (kk in seq_along(NAMES)) {
[10:22:06.772]                   name <- removed[[kk]]
[10:22:06.772]                   NAME <- NAMES[[kk]]
[10:22:06.772]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:06.772]                     next
[10:22:06.772]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:06.772]                 }
[10:22:06.772]                 if (length(args) > 0) 
[10:22:06.772]                   base::do.call(base::Sys.setenv, args = args)
[10:22:06.772]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:06.772]             }
[10:22:06.772]             else {
[10:22:06.772]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:06.772]             }
[10:22:06.772]             {
[10:22:06.772]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:06.772]                   0L) {
[10:22:06.772]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:06.772]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:06.772]                   base::options(opts)
[10:22:06.772]                 }
[10:22:06.772]                 {
[10:22:06.772]                   {
[10:22:06.772]                     NULL
[10:22:06.772]                     RNGkind("Mersenne-Twister")
[10:22:06.772]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:06.772]                       inherits = FALSE)
[10:22:06.772]                   }
[10:22:06.772]                   options(future.plan = NULL)
[10:22:06.772]                   if (is.na(NA_character_)) 
[10:22:06.772]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:06.772]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:06.772]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:06.772]                     .init = FALSE)
[10:22:06.772]                 }
[10:22:06.772]             }
[10:22:06.772]         }
[10:22:06.772]     })
[10:22:06.772]     if (TRUE) {
[10:22:06.772]         base::sink(type = "output", split = FALSE)
[10:22:06.772]         if (TRUE) {
[10:22:06.772]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:06.772]         }
[10:22:06.772]         else {
[10:22:06.772]             ...future.result["stdout"] <- base::list(NULL)
[10:22:06.772]         }
[10:22:06.772]         base::close(...future.stdout)
[10:22:06.772]         ...future.stdout <- NULL
[10:22:06.772]     }
[10:22:06.772]     ...future.result$conditions <- ...future.conditions
[10:22:06.772]     ...future.result$finished <- base::Sys.time()
[10:22:06.772]     ...future.result
[10:22:06.772] }
[10:22:06.774] assign_globals() ...
[10:22:06.774] List of 2
[10:22:06.774]  $ nested   :List of 2
[10:22:06.774]   ..$ a:function (..., envir = parent.frame())  
[10:22:06.774]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[10:22:06.774]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:22:06.774]   ..$ b:function (..., envir = parent.frame())  
[10:22:06.774]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[10:22:06.774]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:22:06.774]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:22:06.774]  $ strategy2: chr "sequential"
[10:22:06.774]  - attr(*, "where")=List of 2
[10:22:06.774]   ..$ nested   :<environment: R_EmptyEnv> 
[10:22:06.774]   ..$ strategy2:<environment: R_EmptyEnv> 
[10:22:06.774]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:06.774]  - attr(*, "resolved")= logi FALSE
[10:22:06.774]  - attr(*, "total_size")= num 3359
[10:22:06.774]  - attr(*, "already-done")= logi TRUE
[10:22:06.780] - copied ‘nested’ to environment
[10:22:06.780] - copied ‘strategy2’ to environment
[10:22:06.780] assign_globals() ... done
[10:22:06.781] plan(): Setting new future strategy stack:
[10:22:06.781] List of future strategies:
[10:22:06.781] 1. sequential:
[10:22:06.781]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:06.781]    - tweaked: FALSE
[10:22:06.781]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:06.781] plan(): nbrOfWorkers() = 1
[10:22:06.817] plan(): Setting new future strategy stack:
[10:22:06.818] List of future strategies:
[10:22:06.818] 1. sequential:
[10:22:06.818]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:06.818]    - tweaked: FALSE
[10:22:06.818]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:06.818] 2. sequential:
[10:22:06.818]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:06.818]    - tweaked: FALSE
[10:22:06.818]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:06.818] plan(): nbrOfWorkers() = 1
[10:22:06.818] SequentialFuture started (and completed)
[10:22:06.818] signalConditions() ...
[10:22:06.819]  - include = ‘immediateCondition’
[10:22:06.819]  - exclude = 
[10:22:06.819]  - resignal = FALSE
[10:22:06.819]  - Number of conditions: 54
[10:22:06.819] signalConditions() ... done
[10:22:06.819] - Launch lazy future ... done
[10:22:06.819] run() for ‘SequentialFuture’ ... done
[10:22:06.819] signalConditions() ...
[10:22:06.819]  - include = ‘immediateCondition’
[10:22:06.819]  - exclude = 
[10:22:06.819]  - resignal = FALSE
[10:22:06.820]  - Number of conditions: 54
[10:22:06.820] signalConditions() ... done
[10:22:06.820] Future state: ‘finished’
[10:22:06.820] signalConditions() ...
[10:22:06.820]  - include = ‘condition’
[10:22:06.820]  - exclude = ‘immediateCondition’
[10:22:06.820]  - resignal = TRUE
[10:22:06.820]  - Number of conditions: 54
[10:22:06.820]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.782] getGlobalsAndPackages() ...
[10:22:06.820]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.783] Searching for globals...
[10:22:06.820]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.801] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[10:22:06.821]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.801] Searching for globals ... DONE
[10:22:06.821]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.801] Resolving globals: FALSE
[10:22:06.821]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.802] The total size of the 3 globals is 3.58 KiB (3661 bytes)
[10:22:06.821]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.802] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 3.58 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (1.77 KiB of class ‘list’), ‘plan_a’ (1.77 KiB of class ‘list’) and ‘a’ (35 bytes of class ‘numeric’)
[10:22:06.821]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.802] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[10:22:06.821]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.802] 
[10:22:06.821]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.802] getGlobalsAndPackages() ... DONE
[10:22:06.821]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.803] run() for ‘Future’ ...
[10:22:06.822]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.803] - state: ‘created’
[10:22:06.822]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.803] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:06.822]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.803] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:06.822]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.803] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:06.822]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.803]   - Field: ‘label’
[10:22:06.822]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.803]   - Field: ‘local’
[10:22:06.822]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.804]   - Field: ‘owner’
[10:22:06.822]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.804]   - Field: ‘envir’
[10:22:06.822]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.804]   - Field: ‘packages’
[10:22:06.823]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.804]   - Field: ‘gc’
[10:22:06.823]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.804]   - Field: ‘conditions’
[10:22:06.823]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.804]   - Field: ‘expr’
[10:22:06.823]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.804]   - Field: ‘uuid’
[10:22:06.823]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.804]   - Field: ‘seed’
[10:22:06.823]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.804]   - Field: ‘version’
[10:22:06.823]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.804]   - Field: ‘result’
[10:22:06.823]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.805]   - Field: ‘asynchronous’
[10:22:06.823]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.805]   - Field: ‘calls’
[10:22:06.824]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.805]   - Field: ‘globals’
[10:22:06.824]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.805]   - Field: ‘stdout’
[10:22:06.824]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.805]   - Field: ‘earlySignal’
[10:22:06.824]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.805]   - Field: ‘lazy’
[10:22:06.824]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.805]   - Field: ‘state’
[10:22:06.824]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.805] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:06.824]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.805] - Launch lazy future ...
[10:22:06.824]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.806] Packages needed by the future expression (n = 0): <none>
[10:22:06.825]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.806] Packages needed by future strategies (n = 0): <none>
[10:22:06.825]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.806] {
[10:22:06.806]     {
[10:22:06.806]         {
[10:22:06.806]             ...future.startTime <- base::Sys.time()
[10:22:06.806]             {
[10:22:06.806]                 {
[10:22:06.806]                   {
[10:22:06.806]                     base::local({
[10:22:06.806]                       has_future <- base::requireNamespace("future", 
[10:22:06.806]                         quietly = TRUE)
[10:22:06.806]                       if (has_future) {
[10:22:06.806]                         ns <- base::getNamespace("future")
[10:22:06.806]                         version <- ns[[".package"]][["version"]]
[10:22:06.806]                         if (is.null(version)) 
[10:22:06.806]                           version <- utils::packageVersion("future")
[10:22:06.806]                       }
[10:22:06.806]                       else {
[10:22:06.806]                         version <- NULL
[10:22:06.806]                       }
[10:22:06.806]                       if (!has_future || version < "1.8.0") {
[10:22:06.806]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:06.806]                           "", base::R.version$version.string), 
[10:22:06.806]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:06.806]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:06.806]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:06.806]                             "release", "version")], collapse = " "), 
[10:22:06.806]                           hostname = base::Sys.info()[["nodename"]])
[10:22:06.806]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:06.806]                           info)
[10:22:06.806]                         info <- base::paste(info, collapse = "; ")
[10:22:06.806]                         if (!has_future) {
[10:22:06.806]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:06.806]                             info)
[10:22:06.806]                         }
[10:22:06.806]                         else {
[10:22:06.806]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:06.806]                             info, version)
[10:22:06.806]                         }
[10:22:06.806]                         base::stop(msg)
[10:22:06.806]                       }
[10:22:06.806]                     })
[10:22:06.806]                   }
[10:22:06.806]                   ...future.strategy.old <- future::plan("list")
[10:22:06.806]                   options(future.plan = NULL)
[10:22:06.806]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:06.806]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:06.806]                 }
[10:22:06.806]                 ...future.workdir <- getwd()
[10:22:06.806]             }
[10:22:06.806]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:06.806]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:06.806]         }
[10:22:06.806]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:06.806]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:06.806]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:06.806]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:06.806]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:06.806]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:06.806]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:06.806]             base::names(...future.oldOptions))
[10:22:06.806]     }
[10:22:06.806]     if (FALSE) {
[10:22:06.806]     }
[10:22:06.806]     else {
[10:22:06.806]         if (TRUE) {
[10:22:06.806]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:06.806]                 open = "w")
[10:22:06.806]         }
[10:22:06.806]         else {
[10:22:06.806]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:06.806]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:06.806]         }
[10:22:06.806]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:06.806]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:06.806]             base::sink(type = "output", split = FALSE)
[10:22:06.806]             base::close(...future.stdout)
[10:22:06.806]         }, add = TRUE)
[10:22:06.806]     }
[10:22:06.806]     ...future.frame <- base::sys.nframe()
[10:22:06.806]     ...future.conditions <- base::list()
[10:22:06.806]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:06.806]     if (FALSE) {
[10:22:06.806]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:06.806]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:06.806]     }
[10:22:06.806]     ...future.result <- base::tryCatch({
[10:22:06.806]         base::withCallingHandlers({
[10:22:06.806]             ...future.value <- base::withVisible(base::local({
[10:22:06.806]                 b <- 2L
[10:22:06.806]                 plan_b <- future::plan("list")
[10:22:06.806]                 nested_b <- nested_a[-1]
[10:22:06.806]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:22:06.806]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[10:22:06.806]                   "sequential"))
[10:22:06.806]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:22:06.806]                   b = b, nested_b = nested_b, plan_b = plan_b)
[10:22:06.806]             }))
[10:22:06.806]             future::FutureResult(value = ...future.value$value, 
[10:22:06.806]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:06.806]                   ...future.rng), globalenv = if (FALSE) 
[10:22:06.806]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:06.806]                     ...future.globalenv.names))
[10:22:06.806]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:06.806]         }, condition = base::local({
[10:22:06.806]             c <- base::c
[10:22:06.806]             inherits <- base::inherits
[10:22:06.806]             invokeRestart <- base::invokeRestart
[10:22:06.806]             length <- base::length
[10:22:06.806]             list <- base::list
[10:22:06.806]             seq.int <- base::seq.int
[10:22:06.806]             signalCondition <- base::signalCondition
[10:22:06.806]             sys.calls <- base::sys.calls
[10:22:06.806]             `[[` <- base::`[[`
[10:22:06.806]             `+` <- base::`+`
[10:22:06.806]             `<<-` <- base::`<<-`
[10:22:06.806]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:06.806]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:06.806]                   3L)]
[10:22:06.806]             }
[10:22:06.806]             function(cond) {
[10:22:06.806]                 is_error <- inherits(cond, "error")
[10:22:06.806]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:06.806]                   NULL)
[10:22:06.806]                 if (is_error) {
[10:22:06.806]                   sessionInformation <- function() {
[10:22:06.806]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:06.806]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:06.806]                       search = base::search(), system = base::Sys.info())
[10:22:06.806]                   }
[10:22:06.806]                   ...future.conditions[[length(...future.conditions) + 
[10:22:06.806]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:06.806]                     cond$call), session = sessionInformation(), 
[10:22:06.806]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:06.806]                   signalCondition(cond)
[10:22:06.806]                 }
[10:22:06.806]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:06.806]                 "immediateCondition"))) {
[10:22:06.806]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:06.806]                   ...future.conditions[[length(...future.conditions) + 
[10:22:06.806]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:06.806]                   if (TRUE && !signal) {
[10:22:06.806]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:06.806]                     {
[10:22:06.806]                       inherits <- base::inherits
[10:22:06.806]                       invokeRestart <- base::invokeRestart
[10:22:06.806]                       is.null <- base::is.null
[10:22:06.806]                       muffled <- FALSE
[10:22:06.806]                       if (inherits(cond, "message")) {
[10:22:06.806]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:06.806]                         if (muffled) 
[10:22:06.806]                           invokeRestart("muffleMessage")
[10:22:06.806]                       }
[10:22:06.806]                       else if (inherits(cond, "warning")) {
[10:22:06.806]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:06.806]                         if (muffled) 
[10:22:06.806]                           invokeRestart("muffleWarning")
[10:22:06.806]                       }
[10:22:06.806]                       else if (inherits(cond, "condition")) {
[10:22:06.806]                         if (!is.null(pattern)) {
[10:22:06.806]                           computeRestarts <- base::computeRestarts
[10:22:06.806]                           grepl <- base::grepl
[10:22:06.806]                           restarts <- computeRestarts(cond)
[10:22:06.806]                           for (restart in restarts) {
[10:22:06.806]                             name <- restart$name
[10:22:06.806]                             if (is.null(name)) 
[10:22:06.806]                               next
[10:22:06.806]                             if (!grepl(pattern, name)) 
[10:22:06.806]                               next
[10:22:06.806]                             invokeRestart(restart)
[10:22:06.806]                             muffled <- TRUE
[10:22:06.806]                             break
[10:22:06.806]                           }
[10:22:06.806]                         }
[10:22:06.806]                       }
[10:22:06.806]                       invisible(muffled)
[10:22:06.806]                     }
[10:22:06.806]                     muffleCondition(cond, pattern = "^muffle")
[10:22:06.806]                   }
[10:22:06.806]                 }
[10:22:06.806]                 else {
[10:22:06.806]                   if (TRUE) {
[10:22:06.806]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:06.806]                     {
[10:22:06.806]                       inherits <- base::inherits
[10:22:06.806]                       invokeRestart <- base::invokeRestart
[10:22:06.806]                       is.null <- base::is.null
[10:22:06.806]                       muffled <- FALSE
[10:22:06.806]                       if (inherits(cond, "message")) {
[10:22:06.806]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:06.806]                         if (muffled) 
[10:22:06.806]                           invokeRestart("muffleMessage")
[10:22:06.806]                       }
[10:22:06.806]                       else if (inherits(cond, "warning")) {
[10:22:06.806]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:06.806]                         if (muffled) 
[10:22:06.806]                           invokeRestart("muffleWarning")
[10:22:06.806]                       }
[10:22:06.806]                       else if (inherits(cond, "condition")) {
[10:22:06.806]                         if (!is.null(pattern)) {
[10:22:06.806]                           computeRestarts <- base::computeRestarts
[10:22:06.806]                           grepl <- base::grepl
[10:22:06.806]                           restarts <- computeRestarts(cond)
[10:22:06.806]                           for (restart in restarts) {
[10:22:06.806]                             name <- restart$name
[10:22:06.806]                             if (is.null(name)) 
[10:22:06.806]                               next
[10:22:06.806]                             if (!grepl(pattern, name)) 
[10:22:06.806]                               next
[10:22:06.806]                             invokeRestart(restart)
[10:22:06.806]                             muffled <- TRUE
[10:22:06.806]                             break
[10:22:06.806]                           }
[10:22:06.806]                         }
[10:22:06.806]                       }
[10:22:06.806]                       invisible(muffled)
[10:22:06.806]                     }
[10:22:06.806]                     muffleCondition(cond, pattern = "^muffle")
[10:22:06.806]                   }
[10:22:06.806]                 }
[10:22:06.806]             }
[10:22:06.806]         }))
[10:22:06.806]     }, error = function(ex) {
[10:22:06.806]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:06.806]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:06.806]                 ...future.rng), started = ...future.startTime, 
[10:22:06.806]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:06.806]             version = "1.8"), class = "FutureResult")
[10:22:06.806]     }, finally = {
[10:22:06.806]         if (!identical(...future.workdir, getwd())) 
[10:22:06.806]             setwd(...future.workdir)
[10:22:06.806]         {
[10:22:06.806]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:06.806]                 ...future.oldOptions$nwarnings <- NULL
[10:22:06.806]             }
[10:22:06.806]             base::options(...future.oldOptions)
[10:22:06.806]             if (.Platform$OS.type == "windows") {
[10:22:06.806]                 old_names <- names(...future.oldEnvVars)
[10:22:06.806]                 envs <- base::Sys.getenv()
[10:22:06.806]                 names <- names(envs)
[10:22:06.806]                 common <- intersect(names, old_names)
[10:22:06.806]                 added <- setdiff(names, old_names)
[10:22:06.806]                 removed <- setdiff(old_names, names)
[10:22:06.806]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:06.806]                   envs[common]]
[10:22:06.806]                 NAMES <- toupper(changed)
[10:22:06.806]                 args <- list()
[10:22:06.806]                 for (kk in seq_along(NAMES)) {
[10:22:06.806]                   name <- changed[[kk]]
[10:22:06.806]                   NAME <- NAMES[[kk]]
[10:22:06.806]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:06.806]                     next
[10:22:06.806]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:06.806]                 }
[10:22:06.806]                 NAMES <- toupper(added)
[10:22:06.806]                 for (kk in seq_along(NAMES)) {
[10:22:06.806]                   name <- added[[kk]]
[10:22:06.806]                   NAME <- NAMES[[kk]]
[10:22:06.806]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:06.806]                     next
[10:22:06.806]                   args[[name]] <- ""
[10:22:06.806]                 }
[10:22:06.806]                 NAMES <- toupper(removed)
[10:22:06.806]                 for (kk in seq_along(NAMES)) {
[10:22:06.806]                   name <- removed[[kk]]
[10:22:06.806]                   NAME <- NAMES[[kk]]
[10:22:06.806]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:06.806]                     next
[10:22:06.806]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:06.806]                 }
[10:22:06.806]                 if (length(args) > 0) 
[10:22:06.806]                   base::do.call(base::Sys.setenv, args = args)
[10:22:06.806]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:06.806]             }
[10:22:06.806]             else {
[10:22:06.806]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:06.806]             }
[10:22:06.806]             {
[10:22:06.806]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:06.806]                   0L) {
[10:22:06.806]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:06.806]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:06.806]                   base::options(opts)
[10:22:06.806]                 }
[10:22:06.806]                 {
[10:22:06.806]                   {
[10:22:06.806]                     NULL
[10:22:06.806]                     RNGkind("Mersenne-Twister")
[10:22:06.806]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:06.806]                       inherits = FALSE)
[10:22:06.806]                   }
[10:22:06.806]                   options(future.plan = NULL)
[10:22:06.806]                   if (is.na(NA_character_)) 
[10:22:06.806]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:06.806]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:06.806]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:06.806]                     .init = FALSE)
[10:22:06.806]                 }
[10:22:06.806]             }
[10:22:06.806]         }
[10:22:06.806]     })
[10:22:06.806]     if (TRUE) {
[10:22:06.806]         base::sink(type = "output", split = FALSE)
[10:22:06.806]         if (TRUE) {
[10:22:06.806]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:06.806]         }
[10:22:06.806]         else {
[10:22:06.806]             ...future.result["stdout"] <- base::list(NULL)
[10:22:06.806]         }
[10:22:06.806]         base::close(...future.stdout)
[10:22:06.806]         ...future.stdout <- NULL
[10:22:06.806]     }
[10:22:06.806]     ...future.result$conditions <- ...future.conditions
[10:22:06.806]     ...future.result$finished <- base::Sys.time()
[10:22:06.806]     ...future.result
[10:22:06.806] }
[10:22:06.825]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.808] assign_globals() ...
[10:22:06.825]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.808] List of 3
[10:22:06.808]  $ nested_a:List of 1
[10:22:06.808]   ..$ b:function (..., envir = parent.frame())  
[10:22:06.808]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[10:22:06.808]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:22:06.808]  $ a       : int 1
[10:22:06.808]  $ plan_a  :List of 1
[10:22:06.808]   ..$ b:function (..., envir = parent.frame())  
[10:22:06.808]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[10:22:06.808]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:22:06.808]  - attr(*, "where")=List of 3
[10:22:06.808]   ..$ nested_a:<environment: R_EmptyEnv> 
[10:22:06.808]   ..$ a       :<environment: R_EmptyEnv> 
[10:22:06.808]   ..$ plan_a  :<environment: R_EmptyEnv> 
[10:22:06.808]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:06.808]  - attr(*, "resolved")= logi FALSE
[10:22:06.808]  - attr(*, "total_size")= num 3661
[10:22:06.808]  - attr(*, "already-done")= logi TRUE
[10:22:06.825]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.813] - copied ‘nested_a’ to environment
[10:22:06.825]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.813] - copied ‘a’ to environment
[10:22:06.825]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.814] - copied ‘plan_a’ to environment
[10:22:06.825]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.814] assign_globals() ... done
[10:22:06.826]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.814] plan(): Setting new future strategy stack:
[10:22:06.826]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.814] List of future strategies:
[10:22:06.814] 1. sequential:
[10:22:06.814]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:06.814]    - tweaked: FALSE
[10:22:06.814]    - call: NULL
[10:22:06.826]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.814] plan(): nbrOfWorkers() = 1
[10:22:06.826]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.816] plan(): Setting new future strategy stack:
[10:22:06.826]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.816] List of future strategies:
[10:22:06.816] 1. sequential:
[10:22:06.816]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:06.816]    - tweaked: FALSE
[10:22:06.816]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:06.826]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.816] plan(): nbrOfWorkers() = 1
[10:22:06.826]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.816] SequentialFuture started (and completed)
[10:22:06.826]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.817] - Launch lazy future ... done
[10:22:06.827]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.817] run() for ‘SequentialFuture’ ... done
[10:22:06.827] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:22:06.831] getGlobalsAndPackages() ...
[10:22:06.831] Searching for globals...
[10:22:06.832] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[10:22:06.832] Searching for globals ... DONE
[10:22:06.832] Resolving globals: FALSE
[10:22:06.833] The total size of the 1 globals is 356 bytes (356 bytes)
[10:22:06.833] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[10:22:06.833] - globals: [1] ‘data’
[10:22:06.833] - packages: [1] ‘future’
[10:22:06.834] getGlobalsAndPackages() ... DONE
[10:22:06.834] run() for ‘Future’ ...
[10:22:06.834] - state: ‘created’
[10:22:06.834] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:06.835] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:06.835] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:06.835]   - Field: ‘label’
[10:22:06.835]   - Field: ‘local’
[10:22:06.836]   - Field: ‘owner’
[10:22:06.836]   - Field: ‘envir’
[10:22:06.836]   - Field: ‘packages’
[10:22:06.836]   - Field: ‘gc’
[10:22:06.836]   - Field: ‘conditions’
[10:22:06.836]   - Field: ‘expr’
[10:22:06.836]   - Field: ‘uuid’
[10:22:06.836]   - Field: ‘seed’
[10:22:06.836]   - Field: ‘version’
[10:22:06.836]   - Field: ‘result’
[10:22:06.836]   - Field: ‘asynchronous’
[10:22:06.836]   - Field: ‘calls’
[10:22:06.837]   - Field: ‘globals’
[10:22:06.837]   - Field: ‘stdout’
[10:22:06.837]   - Field: ‘earlySignal’
[10:22:06.837]   - Field: ‘lazy’
[10:22:06.837]   - Field: ‘state’
[10:22:06.837] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:06.837] - Launch lazy future ...
[10:22:06.837] Packages needed by the future expression (n = 1): ‘future’
[10:22:06.837] Packages needed by future strategies (n = 1): ‘future’
[10:22:06.838] {
[10:22:06.838]     {
[10:22:06.838]         {
[10:22:06.838]             ...future.startTime <- base::Sys.time()
[10:22:06.838]             {
[10:22:06.838]                 {
[10:22:06.838]                   {
[10:22:06.838]                     {
[10:22:06.838]                       base::local({
[10:22:06.838]                         has_future <- base::requireNamespace("future", 
[10:22:06.838]                           quietly = TRUE)
[10:22:06.838]                         if (has_future) {
[10:22:06.838]                           ns <- base::getNamespace("future")
[10:22:06.838]                           version <- ns[[".package"]][["version"]]
[10:22:06.838]                           if (is.null(version)) 
[10:22:06.838]                             version <- utils::packageVersion("future")
[10:22:06.838]                         }
[10:22:06.838]                         else {
[10:22:06.838]                           version <- NULL
[10:22:06.838]                         }
[10:22:06.838]                         if (!has_future || version < "1.8.0") {
[10:22:06.838]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:06.838]                             "", base::R.version$version.string), 
[10:22:06.838]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:06.838]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:06.838]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:06.838]                               "release", "version")], collapse = " "), 
[10:22:06.838]                             hostname = base::Sys.info()[["nodename"]])
[10:22:06.838]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:06.838]                             info)
[10:22:06.838]                           info <- base::paste(info, collapse = "; ")
[10:22:06.838]                           if (!has_future) {
[10:22:06.838]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:06.838]                               info)
[10:22:06.838]                           }
[10:22:06.838]                           else {
[10:22:06.838]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:06.838]                               info, version)
[10:22:06.838]                           }
[10:22:06.838]                           base::stop(msg)
[10:22:06.838]                         }
[10:22:06.838]                       })
[10:22:06.838]                     }
[10:22:06.838]                     base::local({
[10:22:06.838]                       for (pkg in "future") {
[10:22:06.838]                         base::loadNamespace(pkg)
[10:22:06.838]                         base::library(pkg, character.only = TRUE)
[10:22:06.838]                       }
[10:22:06.838]                     })
[10:22:06.838]                   }
[10:22:06.838]                   ...future.strategy.old <- future::plan("list")
[10:22:06.838]                   options(future.plan = NULL)
[10:22:06.838]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:06.838]                   future::plan(list(b = function (..., envir = parent.frame()) 
[10:22:06.838]                   {
[10:22:06.838]                     future <- SequentialFuture(..., envir = envir)
[10:22:06.838]                     if (!future$lazy) 
[10:22:06.838]                       future <- run(future)
[10:22:06.838]                     invisible(future)
[10:22:06.838]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:06.838]                 }
[10:22:06.838]                 ...future.workdir <- getwd()
[10:22:06.838]             }
[10:22:06.838]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:06.838]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:06.838]         }
[10:22:06.838]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:06.838]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:06.838]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:06.838]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:06.838]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:06.838]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:06.838]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:06.838]             base::names(...future.oldOptions))
[10:22:06.838]     }
[10:22:06.838]     if (FALSE) {
[10:22:06.838]     }
[10:22:06.838]     else {
[10:22:06.838]         if (TRUE) {
[10:22:06.838]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:06.838]                 open = "w")
[10:22:06.838]         }
[10:22:06.838]         else {
[10:22:06.838]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:06.838]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:06.838]         }
[10:22:06.838]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:06.838]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:06.838]             base::sink(type = "output", split = FALSE)
[10:22:06.838]             base::close(...future.stdout)
[10:22:06.838]         }, add = TRUE)
[10:22:06.838]     }
[10:22:06.838]     ...future.frame <- base::sys.nframe()
[10:22:06.838]     ...future.conditions <- base::list()
[10:22:06.838]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:06.838]     if (FALSE) {
[10:22:06.838]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:06.838]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:06.838]     }
[10:22:06.838]     ...future.result <- base::tryCatch({
[10:22:06.838]         base::withCallingHandlers({
[10:22:06.838]             ...future.value <- base::withVisible(base::local({
[10:22:06.838]                 value(future(subset(data, a == 2)))
[10:22:06.838]             }))
[10:22:06.838]             future::FutureResult(value = ...future.value$value, 
[10:22:06.838]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:06.838]                   ...future.rng), globalenv = if (FALSE) 
[10:22:06.838]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:06.838]                     ...future.globalenv.names))
[10:22:06.838]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:06.838]         }, condition = base::local({
[10:22:06.838]             c <- base::c
[10:22:06.838]             inherits <- base::inherits
[10:22:06.838]             invokeRestart <- base::invokeRestart
[10:22:06.838]             length <- base::length
[10:22:06.838]             list <- base::list
[10:22:06.838]             seq.int <- base::seq.int
[10:22:06.838]             signalCondition <- base::signalCondition
[10:22:06.838]             sys.calls <- base::sys.calls
[10:22:06.838]             `[[` <- base::`[[`
[10:22:06.838]             `+` <- base::`+`
[10:22:06.838]             `<<-` <- base::`<<-`
[10:22:06.838]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:06.838]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:06.838]                   3L)]
[10:22:06.838]             }
[10:22:06.838]             function(cond) {
[10:22:06.838]                 is_error <- inherits(cond, "error")
[10:22:06.838]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:06.838]                   NULL)
[10:22:06.838]                 if (is_error) {
[10:22:06.838]                   sessionInformation <- function() {
[10:22:06.838]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:06.838]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:06.838]                       search = base::search(), system = base::Sys.info())
[10:22:06.838]                   }
[10:22:06.838]                   ...future.conditions[[length(...future.conditions) + 
[10:22:06.838]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:06.838]                     cond$call), session = sessionInformation(), 
[10:22:06.838]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:06.838]                   signalCondition(cond)
[10:22:06.838]                 }
[10:22:06.838]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:06.838]                 "immediateCondition"))) {
[10:22:06.838]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:06.838]                   ...future.conditions[[length(...future.conditions) + 
[10:22:06.838]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:06.838]                   if (TRUE && !signal) {
[10:22:06.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:06.838]                     {
[10:22:06.838]                       inherits <- base::inherits
[10:22:06.838]                       invokeRestart <- base::invokeRestart
[10:22:06.838]                       is.null <- base::is.null
[10:22:06.838]                       muffled <- FALSE
[10:22:06.838]                       if (inherits(cond, "message")) {
[10:22:06.838]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:06.838]                         if (muffled) 
[10:22:06.838]                           invokeRestart("muffleMessage")
[10:22:06.838]                       }
[10:22:06.838]                       else if (inherits(cond, "warning")) {
[10:22:06.838]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:06.838]                         if (muffled) 
[10:22:06.838]                           invokeRestart("muffleWarning")
[10:22:06.838]                       }
[10:22:06.838]                       else if (inherits(cond, "condition")) {
[10:22:06.838]                         if (!is.null(pattern)) {
[10:22:06.838]                           computeRestarts <- base::computeRestarts
[10:22:06.838]                           grepl <- base::grepl
[10:22:06.838]                           restarts <- computeRestarts(cond)
[10:22:06.838]                           for (restart in restarts) {
[10:22:06.838]                             name <- restart$name
[10:22:06.838]                             if (is.null(name)) 
[10:22:06.838]                               next
[10:22:06.838]                             if (!grepl(pattern, name)) 
[10:22:06.838]                               next
[10:22:06.838]                             invokeRestart(restart)
[10:22:06.838]                             muffled <- TRUE
[10:22:06.838]                             break
[10:22:06.838]                           }
[10:22:06.838]                         }
[10:22:06.838]                       }
[10:22:06.838]                       invisible(muffled)
[10:22:06.838]                     }
[10:22:06.838]                     muffleCondition(cond, pattern = "^muffle")
[10:22:06.838]                   }
[10:22:06.838]                 }
[10:22:06.838]                 else {
[10:22:06.838]                   if (TRUE) {
[10:22:06.838]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:06.838]                     {
[10:22:06.838]                       inherits <- base::inherits
[10:22:06.838]                       invokeRestart <- base::invokeRestart
[10:22:06.838]                       is.null <- base::is.null
[10:22:06.838]                       muffled <- FALSE
[10:22:06.838]                       if (inherits(cond, "message")) {
[10:22:06.838]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:06.838]                         if (muffled) 
[10:22:06.838]                           invokeRestart("muffleMessage")
[10:22:06.838]                       }
[10:22:06.838]                       else if (inherits(cond, "warning")) {
[10:22:06.838]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:06.838]                         if (muffled) 
[10:22:06.838]                           invokeRestart("muffleWarning")
[10:22:06.838]                       }
[10:22:06.838]                       else if (inherits(cond, "condition")) {
[10:22:06.838]                         if (!is.null(pattern)) {
[10:22:06.838]                           computeRestarts <- base::computeRestarts
[10:22:06.838]                           grepl <- base::grepl
[10:22:06.838]                           restarts <- computeRestarts(cond)
[10:22:06.838]                           for (restart in restarts) {
[10:22:06.838]                             name <- restart$name
[10:22:06.838]                             if (is.null(name)) 
[10:22:06.838]                               next
[10:22:06.838]                             if (!grepl(pattern, name)) 
[10:22:06.838]                               next
[10:22:06.838]                             invokeRestart(restart)
[10:22:06.838]                             muffled <- TRUE
[10:22:06.838]                             break
[10:22:06.838]                           }
[10:22:06.838]                         }
[10:22:06.838]                       }
[10:22:06.838]                       invisible(muffled)
[10:22:06.838]                     }
[10:22:06.838]                     muffleCondition(cond, pattern = "^muffle")
[10:22:06.838]                   }
[10:22:06.838]                 }
[10:22:06.838]             }
[10:22:06.838]         }))
[10:22:06.838]     }, error = function(ex) {
[10:22:06.838]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:06.838]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:06.838]                 ...future.rng), started = ...future.startTime, 
[10:22:06.838]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:06.838]             version = "1.8"), class = "FutureResult")
[10:22:06.838]     }, finally = {
[10:22:06.838]         if (!identical(...future.workdir, getwd())) 
[10:22:06.838]             setwd(...future.workdir)
[10:22:06.838]         {
[10:22:06.838]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:06.838]                 ...future.oldOptions$nwarnings <- NULL
[10:22:06.838]             }
[10:22:06.838]             base::options(...future.oldOptions)
[10:22:06.838]             if (.Platform$OS.type == "windows") {
[10:22:06.838]                 old_names <- names(...future.oldEnvVars)
[10:22:06.838]                 envs <- base::Sys.getenv()
[10:22:06.838]                 names <- names(envs)
[10:22:06.838]                 common <- intersect(names, old_names)
[10:22:06.838]                 added <- setdiff(names, old_names)
[10:22:06.838]                 removed <- setdiff(old_names, names)
[10:22:06.838]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:06.838]                   envs[common]]
[10:22:06.838]                 NAMES <- toupper(changed)
[10:22:06.838]                 args <- list()
[10:22:06.838]                 for (kk in seq_along(NAMES)) {
[10:22:06.838]                   name <- changed[[kk]]
[10:22:06.838]                   NAME <- NAMES[[kk]]
[10:22:06.838]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:06.838]                     next
[10:22:06.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:06.838]                 }
[10:22:06.838]                 NAMES <- toupper(added)
[10:22:06.838]                 for (kk in seq_along(NAMES)) {
[10:22:06.838]                   name <- added[[kk]]
[10:22:06.838]                   NAME <- NAMES[[kk]]
[10:22:06.838]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:06.838]                     next
[10:22:06.838]                   args[[name]] <- ""
[10:22:06.838]                 }
[10:22:06.838]                 NAMES <- toupper(removed)
[10:22:06.838]                 for (kk in seq_along(NAMES)) {
[10:22:06.838]                   name <- removed[[kk]]
[10:22:06.838]                   NAME <- NAMES[[kk]]
[10:22:06.838]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:06.838]                     next
[10:22:06.838]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:06.838]                 }
[10:22:06.838]                 if (length(args) > 0) 
[10:22:06.838]                   base::do.call(base::Sys.setenv, args = args)
[10:22:06.838]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:06.838]             }
[10:22:06.838]             else {
[10:22:06.838]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:06.838]             }
[10:22:06.838]             {
[10:22:06.838]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:06.838]                   0L) {
[10:22:06.838]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:06.838]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:06.838]                   base::options(opts)
[10:22:06.838]                 }
[10:22:06.838]                 {
[10:22:06.838]                   {
[10:22:06.838]                     NULL
[10:22:06.838]                     RNGkind("Mersenne-Twister")
[10:22:06.838]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:06.838]                       inherits = FALSE)
[10:22:06.838]                   }
[10:22:06.838]                   options(future.plan = NULL)
[10:22:06.838]                   if (is.na(NA_character_)) 
[10:22:06.838]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:06.838]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:06.838]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:06.838]                     .init = FALSE)
[10:22:06.838]                 }
[10:22:06.838]             }
[10:22:06.838]         }
[10:22:06.838]     })
[10:22:06.838]     if (TRUE) {
[10:22:06.838]         base::sink(type = "output", split = FALSE)
[10:22:06.838]         if (TRUE) {
[10:22:06.838]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:06.838]         }
[10:22:06.838]         else {
[10:22:06.838]             ...future.result["stdout"] <- base::list(NULL)
[10:22:06.838]         }
[10:22:06.838]         base::close(...future.stdout)
[10:22:06.838]         ...future.stdout <- NULL
[10:22:06.838]     }
[10:22:06.838]     ...future.result$conditions <- ...future.conditions
[10:22:06.838]     ...future.result$finished <- base::Sys.time()
[10:22:06.838]     ...future.result
[10:22:06.838] }
[10:22:06.839] assign_globals() ...
[10:22:06.840] List of 1
[10:22:06.840]  $ data:'data.frame':	3 obs. of  2 variables:
[10:22:06.840]   ..$ a: int [1:3] 1 2 3
[10:22:06.840]   ..$ b: int [1:3] 3 2 1
[10:22:06.840]  - attr(*, "where")=List of 1
[10:22:06.840]   ..$ data:<environment: R_EmptyEnv> 
[10:22:06.840]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:06.840]  - attr(*, "resolved")= logi FALSE
[10:22:06.840]  - attr(*, "total_size")= num 356
[10:22:06.840]  - attr(*, "already-done")= logi TRUE
[10:22:06.843] - copied ‘data’ to environment
[10:22:06.843] assign_globals() ... done
[10:22:06.843] plan(): Setting new future strategy stack:
[10:22:06.843] List of future strategies:
[10:22:06.843] 1. sequential:
[10:22:06.843]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:06.843]    - tweaked: FALSE
[10:22:06.843]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:06.843] plan(): nbrOfWorkers() = 1
[10:22:06.870] plan(): Setting new future strategy stack:
[10:22:06.870] List of future strategies:
[10:22:06.870] 1. sequential:
[10:22:06.870]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:06.870]    - tweaked: FALSE
[10:22:06.870]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:06.870] 2. sequential:
[10:22:06.870]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:06.870]    - tweaked: FALSE
[10:22:06.870]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:06.871] plan(): nbrOfWorkers() = 1
[10:22:06.871] SequentialFuture started (and completed)
[10:22:06.871] signalConditions() ...
[10:22:06.871]  - include = ‘immediateCondition’
[10:22:06.872]  - exclude = 
[10:22:06.872]  - resignal = FALSE
[10:22:06.872]  - Number of conditions: 52
[10:22:06.872] signalConditions() ... done
[10:22:06.872] - Launch lazy future ... done
[10:22:06.872] run() for ‘SequentialFuture’ ... done
[10:22:06.872] signalConditions() ...
[10:22:06.872]  - include = ‘immediateCondition’
[10:22:06.872]  - exclude = 
[10:22:06.872]  - resignal = FALSE
[10:22:06.872]  - Number of conditions: 52
[10:22:06.872] signalConditions() ... done
[10:22:06.873] Future state: ‘finished’
[10:22:06.873] signalConditions() ...
[10:22:06.873]  - include = ‘condition’
[10:22:06.873]  - exclude = ‘immediateCondition’
[10:22:06.873]  - resignal = TRUE
[10:22:06.873]  - Number of conditions: 52
[10:22:06.873]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.844] getGlobalsAndPackages() ...
[10:22:06.873]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.844] Searching for globals...
[10:22:06.873]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.858] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[10:22:06.873]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.858] Searching for globals ... DONE
[10:22:06.874]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.858] Resolving globals: FALSE
[10:22:06.874]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.859] The total size of the 1 globals is 356 bytes (356 bytes)
[10:22:06.874]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.859] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[10:22:06.874]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.859] - globals: [1] ‘data’
[10:22:06.874]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.859] 
[10:22:06.874]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.859] getGlobalsAndPackages() ... DONE
[10:22:06.874]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.860] run() for ‘Future’ ...
[10:22:06.874]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.860] - state: ‘created’
[10:22:06.874]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.860] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:06.875]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.860] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:06.875]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.860] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:06.875]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.860]   - Field: ‘label’
[10:22:06.875]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.860]   - Field: ‘local’
[10:22:06.875]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.861]   - Field: ‘owner’
[10:22:06.875]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.861]   - Field: ‘envir’
[10:22:06.875]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.861]   - Field: ‘packages’
[10:22:06.875]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.861]   - Field: ‘gc’
[10:22:06.875]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.861]   - Field: ‘conditions’
[10:22:06.876]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.861]   - Field: ‘expr’
[10:22:06.876]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.861]   - Field: ‘uuid’
[10:22:06.876]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.861]   - Field: ‘seed’
[10:22:06.876]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.861]   - Field: ‘version’
[10:22:06.876]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.861]   - Field: ‘result’
[10:22:06.876]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.861]   - Field: ‘asynchronous’
[10:22:06.876]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.862]   - Field: ‘calls’
[10:22:06.876]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.862]   - Field: ‘globals’
[10:22:06.876]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.862]   - Field: ‘stdout’
[10:22:06.877]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.862]   - Field: ‘earlySignal’
[10:22:06.877]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.862]   - Field: ‘lazy’
[10:22:06.877]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.862]   - Field: ‘state’
[10:22:06.877]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.862] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:06.877]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.862] - Launch lazy future ...
[10:22:06.877]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.862] Packages needed by the future expression (n = 0): <none>
[10:22:06.877]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.863] Packages needed by future strategies (n = 0): <none>
[10:22:06.877]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.863] {
[10:22:06.863]     {
[10:22:06.863]         {
[10:22:06.863]             ...future.startTime <- base::Sys.time()
[10:22:06.863]             {
[10:22:06.863]                 {
[10:22:06.863]                   {
[10:22:06.863]                     base::local({
[10:22:06.863]                       has_future <- base::requireNamespace("future", 
[10:22:06.863]                         quietly = TRUE)
[10:22:06.863]                       if (has_future) {
[10:22:06.863]                         ns <- base::getNamespace("future")
[10:22:06.863]                         version <- ns[[".package"]][["version"]]
[10:22:06.863]                         if (is.null(version)) 
[10:22:06.863]                           version <- utils::packageVersion("future")
[10:22:06.863]                       }
[10:22:06.863]                       else {
[10:22:06.863]                         version <- NULL
[10:22:06.863]                       }
[10:22:06.863]                       if (!has_future || version < "1.8.0") {
[10:22:06.863]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:06.863]                           "", base::R.version$version.string), 
[10:22:06.863]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:06.863]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:06.863]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:06.863]                             "release", "version")], collapse = " "), 
[10:22:06.863]                           hostname = base::Sys.info()[["nodename"]])
[10:22:06.863]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:06.863]                           info)
[10:22:06.863]                         info <- base::paste(info, collapse = "; ")
[10:22:06.863]                         if (!has_future) {
[10:22:06.863]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:06.863]                             info)
[10:22:06.863]                         }
[10:22:06.863]                         else {
[10:22:06.863]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:06.863]                             info, version)
[10:22:06.863]                         }
[10:22:06.863]                         base::stop(msg)
[10:22:06.863]                       }
[10:22:06.863]                     })
[10:22:06.863]                   }
[10:22:06.863]                   ...future.strategy.old <- future::plan("list")
[10:22:06.863]                   options(future.plan = NULL)
[10:22:06.863]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:06.863]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:06.863]                 }
[10:22:06.863]                 ...future.workdir <- getwd()
[10:22:06.863]             }
[10:22:06.863]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:06.863]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:06.863]         }
[10:22:06.863]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:06.863]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:06.863]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:06.863]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:06.863]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:06.863]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:06.863]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:06.863]             base::names(...future.oldOptions))
[10:22:06.863]     }
[10:22:06.863]     if (FALSE) {
[10:22:06.863]     }
[10:22:06.863]     else {
[10:22:06.863]         if (TRUE) {
[10:22:06.863]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:06.863]                 open = "w")
[10:22:06.863]         }
[10:22:06.863]         else {
[10:22:06.863]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:06.863]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:06.863]         }
[10:22:06.863]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:06.863]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:06.863]             base::sink(type = "output", split = FALSE)
[10:22:06.863]             base::close(...future.stdout)
[10:22:06.863]         }, add = TRUE)
[10:22:06.863]     }
[10:22:06.863]     ...future.frame <- base::sys.nframe()
[10:22:06.863]     ...future.conditions <- base::list()
[10:22:06.863]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:06.863]     if (FALSE) {
[10:22:06.863]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:06.863]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:06.863]     }
[10:22:06.863]     ...future.result <- base::tryCatch({
[10:22:06.863]         base::withCallingHandlers({
[10:22:06.863]             ...future.value <- base::withVisible(base::local(subset(data, 
[10:22:06.863]                 a == 2)))
[10:22:06.863]             future::FutureResult(value = ...future.value$value, 
[10:22:06.863]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:06.863]                   ...future.rng), globalenv = if (FALSE) 
[10:22:06.863]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:06.863]                     ...future.globalenv.names))
[10:22:06.863]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:06.863]         }, condition = base::local({
[10:22:06.863]             c <- base::c
[10:22:06.863]             inherits <- base::inherits
[10:22:06.863]             invokeRestart <- base::invokeRestart
[10:22:06.863]             length <- base::length
[10:22:06.863]             list <- base::list
[10:22:06.863]             seq.int <- base::seq.int
[10:22:06.863]             signalCondition <- base::signalCondition
[10:22:06.863]             sys.calls <- base::sys.calls
[10:22:06.863]             `[[` <- base::`[[`
[10:22:06.863]             `+` <- base::`+`
[10:22:06.863]             `<<-` <- base::`<<-`
[10:22:06.863]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:06.863]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:06.863]                   3L)]
[10:22:06.863]             }
[10:22:06.863]             function(cond) {
[10:22:06.863]                 is_error <- inherits(cond, "error")
[10:22:06.863]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:06.863]                   NULL)
[10:22:06.863]                 if (is_error) {
[10:22:06.863]                   sessionInformation <- function() {
[10:22:06.863]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:06.863]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:06.863]                       search = base::search(), system = base::Sys.info())
[10:22:06.863]                   }
[10:22:06.863]                   ...future.conditions[[length(...future.conditions) + 
[10:22:06.863]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:06.863]                     cond$call), session = sessionInformation(), 
[10:22:06.863]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:06.863]                   signalCondition(cond)
[10:22:06.863]                 }
[10:22:06.863]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:06.863]                 "immediateCondition"))) {
[10:22:06.863]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:06.863]                   ...future.conditions[[length(...future.conditions) + 
[10:22:06.863]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:06.863]                   if (TRUE && !signal) {
[10:22:06.863]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:06.863]                     {
[10:22:06.863]                       inherits <- base::inherits
[10:22:06.863]                       invokeRestart <- base::invokeRestart
[10:22:06.863]                       is.null <- base::is.null
[10:22:06.863]                       muffled <- FALSE
[10:22:06.863]                       if (inherits(cond, "message")) {
[10:22:06.863]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:06.863]                         if (muffled) 
[10:22:06.863]                           invokeRestart("muffleMessage")
[10:22:06.863]                       }
[10:22:06.863]                       else if (inherits(cond, "warning")) {
[10:22:06.863]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:06.863]                         if (muffled) 
[10:22:06.863]                           invokeRestart("muffleWarning")
[10:22:06.863]                       }
[10:22:06.863]                       else if (inherits(cond, "condition")) {
[10:22:06.863]                         if (!is.null(pattern)) {
[10:22:06.863]                           computeRestarts <- base::computeRestarts
[10:22:06.863]                           grepl <- base::grepl
[10:22:06.863]                           restarts <- computeRestarts(cond)
[10:22:06.863]                           for (restart in restarts) {
[10:22:06.863]                             name <- restart$name
[10:22:06.863]                             if (is.null(name)) 
[10:22:06.863]                               next
[10:22:06.863]                             if (!grepl(pattern, name)) 
[10:22:06.863]                               next
[10:22:06.863]                             invokeRestart(restart)
[10:22:06.863]                             muffled <- TRUE
[10:22:06.863]                             break
[10:22:06.863]                           }
[10:22:06.863]                         }
[10:22:06.863]                       }
[10:22:06.863]                       invisible(muffled)
[10:22:06.863]                     }
[10:22:06.863]                     muffleCondition(cond, pattern = "^muffle")
[10:22:06.863]                   }
[10:22:06.863]                 }
[10:22:06.863]                 else {
[10:22:06.863]                   if (TRUE) {
[10:22:06.863]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:06.863]                     {
[10:22:06.863]                       inherits <- base::inherits
[10:22:06.863]                       invokeRestart <- base::invokeRestart
[10:22:06.863]                       is.null <- base::is.null
[10:22:06.863]                       muffled <- FALSE
[10:22:06.863]                       if (inherits(cond, "message")) {
[10:22:06.863]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:06.863]                         if (muffled) 
[10:22:06.863]                           invokeRestart("muffleMessage")
[10:22:06.863]                       }
[10:22:06.863]                       else if (inherits(cond, "warning")) {
[10:22:06.863]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:06.863]                         if (muffled) 
[10:22:06.863]                           invokeRestart("muffleWarning")
[10:22:06.863]                       }
[10:22:06.863]                       else if (inherits(cond, "condition")) {
[10:22:06.863]                         if (!is.null(pattern)) {
[10:22:06.863]                           computeRestarts <- base::computeRestarts
[10:22:06.863]                           grepl <- base::grepl
[10:22:06.863]                           restarts <- computeRestarts(cond)
[10:22:06.863]                           for (restart in restarts) {
[10:22:06.863]                             name <- restart$name
[10:22:06.863]                             if (is.null(name)) 
[10:22:06.863]                               next
[10:22:06.863]                             if (!grepl(pattern, name)) 
[10:22:06.863]                               next
[10:22:06.863]                             invokeRestart(restart)
[10:22:06.863]                             muffled <- TRUE
[10:22:06.863]                             break
[10:22:06.863]                           }
[10:22:06.863]                         }
[10:22:06.863]                       }
[10:22:06.863]                       invisible(muffled)
[10:22:06.863]                     }
[10:22:06.863]                     muffleCondition(cond, pattern = "^muffle")
[10:22:06.863]                   }
[10:22:06.863]                 }
[10:22:06.863]             }
[10:22:06.863]         }))
[10:22:06.863]     }, error = function(ex) {
[10:22:06.863]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:06.863]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:06.863]                 ...future.rng), started = ...future.startTime, 
[10:22:06.863]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:06.863]             version = "1.8"), class = "FutureResult")
[10:22:06.863]     }, finally = {
[10:22:06.863]         if (!identical(...future.workdir, getwd())) 
[10:22:06.863]             setwd(...future.workdir)
[10:22:06.863]         {
[10:22:06.863]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:06.863]                 ...future.oldOptions$nwarnings <- NULL
[10:22:06.863]             }
[10:22:06.863]             base::options(...future.oldOptions)
[10:22:06.863]             if (.Platform$OS.type == "windows") {
[10:22:06.863]                 old_names <- names(...future.oldEnvVars)
[10:22:06.863]                 envs <- base::Sys.getenv()
[10:22:06.863]                 names <- names(envs)
[10:22:06.863]                 common <- intersect(names, old_names)
[10:22:06.863]                 added <- setdiff(names, old_names)
[10:22:06.863]                 removed <- setdiff(old_names, names)
[10:22:06.863]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:06.863]                   envs[common]]
[10:22:06.863]                 NAMES <- toupper(changed)
[10:22:06.863]                 args <- list()
[10:22:06.863]                 for (kk in seq_along(NAMES)) {
[10:22:06.863]                   name <- changed[[kk]]
[10:22:06.863]                   NAME <- NAMES[[kk]]
[10:22:06.863]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:06.863]                     next
[10:22:06.863]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:06.863]                 }
[10:22:06.863]                 NAMES <- toupper(added)
[10:22:06.863]                 for (kk in seq_along(NAMES)) {
[10:22:06.863]                   name <- added[[kk]]
[10:22:06.863]                   NAME <- NAMES[[kk]]
[10:22:06.863]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:06.863]                     next
[10:22:06.863]                   args[[name]] <- ""
[10:22:06.863]                 }
[10:22:06.863]                 NAMES <- toupper(removed)
[10:22:06.863]                 for (kk in seq_along(NAMES)) {
[10:22:06.863]                   name <- removed[[kk]]
[10:22:06.863]                   NAME <- NAMES[[kk]]
[10:22:06.863]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:06.863]                     next
[10:22:06.863]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:06.863]                 }
[10:22:06.863]                 if (length(args) > 0) 
[10:22:06.863]                   base::do.call(base::Sys.setenv, args = args)
[10:22:06.863]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:06.863]             }
[10:22:06.863]             else {
[10:22:06.863]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:06.863]             }
[10:22:06.863]             {
[10:22:06.863]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:06.863]                   0L) {
[10:22:06.863]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:06.863]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:06.863]                   base::options(opts)
[10:22:06.863]                 }
[10:22:06.863]                 {
[10:22:06.863]                   {
[10:22:06.863]                     NULL
[10:22:06.863]                     RNGkind("Mersenne-Twister")
[10:22:06.863]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:06.863]                       inherits = FALSE)
[10:22:06.863]                   }
[10:22:06.863]                   options(future.plan = NULL)
[10:22:06.863]                   if (is.na(NA_character_)) 
[10:22:06.863]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:06.863]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:06.863]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:06.863]                     .init = FALSE)
[10:22:06.863]                 }
[10:22:06.863]             }
[10:22:06.863]         }
[10:22:06.863]     })
[10:22:06.863]     if (TRUE) {
[10:22:06.863]         base::sink(type = "output", split = FALSE)
[10:22:06.863]         if (TRUE) {
[10:22:06.863]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:06.863]         }
[10:22:06.863]         else {
[10:22:06.863]             ...future.result["stdout"] <- base::list(NULL)
[10:22:06.863]         }
[10:22:06.863]         base::close(...future.stdout)
[10:22:06.863]         ...future.stdout <- NULL
[10:22:06.863]     }
[10:22:06.863]     ...future.result$conditions <- ...future.conditions
[10:22:06.863]     ...future.result$finished <- base::Sys.time()
[10:22:06.863]     ...future.result
[10:22:06.863] }
[10:22:06.878]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.864] assign_globals() ...
[10:22:06.878]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.864] List of 1
[10:22:06.864]  $ data:'data.frame':	3 obs. of  2 variables:
[10:22:06.864]   ..$ a: int [1:3] 1 2 3
[10:22:06.864]   ..$ b: int [1:3] 3 2 1
[10:22:06.864]  - attr(*, "where")=List of 1
[10:22:06.864]   ..$ data:<environment: R_EmptyEnv> 
[10:22:06.864]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:06.864]  - attr(*, "resolved")= logi FALSE
[10:22:06.864]  - attr(*, "total_size")= num 356
[10:22:06.864]  - attr(*, "already-done")= logi TRUE
[10:22:06.879]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.867] - copied ‘data’ to environment
[10:22:06.879]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.868] assign_globals() ... done
[10:22:06.879]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.868] plan(): Setting new future strategy stack:
[10:22:06.879]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.868] List of future strategies:
[10:22:06.868] 1. sequential:
[10:22:06.868]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:06.868]    - tweaked: FALSE
[10:22:06.868]    - call: NULL
[10:22:06.879]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.868] plan(): nbrOfWorkers() = 1
[10:22:06.879]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.869] plan(): Setting new future strategy stack:
[10:22:06.880]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.869] List of future strategies:
[10:22:06.869] 1. sequential:
[10:22:06.869]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:06.869]    - tweaked: FALSE
[10:22:06.869]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:06.880]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.870] plan(): nbrOfWorkers() = 1
[10:22:06.880]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.870] SequentialFuture started (and completed)
[10:22:06.880]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.870] - Launch lazy future ... done
[10:22:06.880]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.870] run() for ‘SequentialFuture’ ... done
[10:22:06.880] signalConditions() ... done
- plan(list('sequential', 'sequential')) ... DONE
- plan(list('sequential', 'multicore')) ...
[10:22:06.880] plan(): Setting new future strategy stack:
[10:22:06.881] List of future strategies:
[10:22:06.881] 1. sequential:
[10:22:06.881]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:06.881]    - tweaked: FALSE
[10:22:06.881]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:06.881] 2. multicore:
[10:22:06.881]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:06.881]    - tweaked: FALSE
[10:22:06.881]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:06.881] plan(): nbrOfWorkers() = 1
[10:22:06.881] getGlobalsAndPackages() ...
[10:22:06.882] Searching for globals...
[10:22:06.897] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[10:22:06.897] Searching for globals ... DONE
[10:22:06.897] Resolving globals: FALSE
[10:22:06.898] The total size of the 2 globals is 7.79 KiB (7972 bytes)
[10:22:06.898] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 7.79 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (7.74 KiB of class ‘list’) and ‘strategy2’ (48 bytes of class ‘character’)
[10:22:06.899] - globals: [2] ‘nested’, ‘strategy2’
[10:22:06.899] - packages: [1] ‘future’
[10:22:06.899] getGlobalsAndPackages() ... DONE
[10:22:06.899] run() for ‘Future’ ...
[10:22:06.899] - state: ‘created’
[10:22:06.899] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:06.899] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:06.900] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:06.900]   - Field: ‘label’
[10:22:06.900]   - Field: ‘local’
[10:22:06.900]   - Field: ‘owner’
[10:22:06.900]   - Field: ‘envir’
[10:22:06.900]   - Field: ‘packages’
[10:22:06.900]   - Field: ‘gc’
[10:22:06.900]   - Field: ‘conditions’
[10:22:06.900]   - Field: ‘expr’
[10:22:06.900]   - Field: ‘uuid’
[10:22:06.900]   - Field: ‘seed’
[10:22:06.901]   - Field: ‘version’
[10:22:06.901]   - Field: ‘result’
[10:22:06.901]   - Field: ‘asynchronous’
[10:22:06.901]   - Field: ‘calls’
[10:22:06.901]   - Field: ‘globals’
[10:22:06.901]   - Field: ‘stdout’
[10:22:06.901]   - Field: ‘earlySignal’
[10:22:06.901]   - Field: ‘lazy’
[10:22:06.901]   - Field: ‘state’
[10:22:06.901] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:06.901] - Launch lazy future ...
[10:22:06.901] Packages needed by the future expression (n = 1): ‘future’
[10:22:06.902] Packages needed by future strategies (n = 1): ‘future’
[10:22:06.902] {
[10:22:06.902]     {
[10:22:06.902]         {
[10:22:06.902]             ...future.startTime <- base::Sys.time()
[10:22:06.902]             {
[10:22:06.902]                 {
[10:22:06.902]                   {
[10:22:06.902]                     {
[10:22:06.902]                       base::local({
[10:22:06.902]                         has_future <- base::requireNamespace("future", 
[10:22:06.902]                           quietly = TRUE)
[10:22:06.902]                         if (has_future) {
[10:22:06.902]                           ns <- base::getNamespace("future")
[10:22:06.902]                           version <- ns[[".package"]][["version"]]
[10:22:06.902]                           if (is.null(version)) 
[10:22:06.902]                             version <- utils::packageVersion("future")
[10:22:06.902]                         }
[10:22:06.902]                         else {
[10:22:06.902]                           version <- NULL
[10:22:06.902]                         }
[10:22:06.902]                         if (!has_future || version < "1.8.0") {
[10:22:06.902]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:06.902]                             "", base::R.version$version.string), 
[10:22:06.902]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:06.902]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:06.902]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:06.902]                               "release", "version")], collapse = " "), 
[10:22:06.902]                             hostname = base::Sys.info()[["nodename"]])
[10:22:06.902]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:06.902]                             info)
[10:22:06.902]                           info <- base::paste(info, collapse = "; ")
[10:22:06.902]                           if (!has_future) {
[10:22:06.902]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:06.902]                               info)
[10:22:06.902]                           }
[10:22:06.902]                           else {
[10:22:06.902]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:06.902]                               info, version)
[10:22:06.902]                           }
[10:22:06.902]                           base::stop(msg)
[10:22:06.902]                         }
[10:22:06.902]                       })
[10:22:06.902]                     }
[10:22:06.902]                     base::local({
[10:22:06.902]                       for (pkg in "future") {
[10:22:06.902]                         base::loadNamespace(pkg)
[10:22:06.902]                         base::library(pkg, character.only = TRUE)
[10:22:06.902]                       }
[10:22:06.902]                     })
[10:22:06.902]                   }
[10:22:06.902]                   ...future.strategy.old <- future::plan("list")
[10:22:06.902]                   options(future.plan = NULL)
[10:22:06.902]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:06.902]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[10:22:06.902]                     envir = parent.frame()) 
[10:22:06.902]                   {
[10:22:06.902]                     default_workers <- missing(workers)
[10:22:06.902]                     if (is.function(workers)) 
[10:22:06.902]                       workers <- workers()
[10:22:06.902]                     workers <- structure(as.integer(workers), 
[10:22:06.902]                       class = class(workers))
[10:22:06.902]                     stop_if_not(is.finite(workers), workers >= 
[10:22:06.902]                       1L)
[10:22:06.902]                     if ((workers == 1L && !inherits(workers, 
[10:22:06.902]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:06.902]                       if (default_workers) 
[10:22:06.902]                         supportsMulticore(warn = TRUE)
[10:22:06.902]                       return(sequential(..., envir = envir))
[10:22:06.902]                     }
[10:22:06.902]                     oopts <- options(mc.cores = workers)
[10:22:06.902]                     on.exit(options(oopts))
[10:22:06.902]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:06.902]                       envir = envir)
[10:22:06.902]                     if (!future$lazy) 
[10:22:06.902]                       future <- run(future)
[10:22:06.902]                     invisible(future)
[10:22:06.902]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:06.902]                 }
[10:22:06.902]                 ...future.workdir <- getwd()
[10:22:06.902]             }
[10:22:06.902]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:06.902]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:06.902]         }
[10:22:06.902]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:06.902]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:06.902]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:06.902]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:06.902]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:06.902]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:06.902]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:06.902]             base::names(...future.oldOptions))
[10:22:06.902]     }
[10:22:06.902]     if (FALSE) {
[10:22:06.902]     }
[10:22:06.902]     else {
[10:22:06.902]         if (TRUE) {
[10:22:06.902]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:06.902]                 open = "w")
[10:22:06.902]         }
[10:22:06.902]         else {
[10:22:06.902]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:06.902]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:06.902]         }
[10:22:06.902]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:06.902]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:06.902]             base::sink(type = "output", split = FALSE)
[10:22:06.902]             base::close(...future.stdout)
[10:22:06.902]         }, add = TRUE)
[10:22:06.902]     }
[10:22:06.902]     ...future.frame <- base::sys.nframe()
[10:22:06.902]     ...future.conditions <- base::list()
[10:22:06.902]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:06.902]     if (FALSE) {
[10:22:06.902]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:06.902]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:06.902]     }
[10:22:06.902]     ...future.result <- base::tryCatch({
[10:22:06.902]         base::withCallingHandlers({
[10:22:06.902]             ...future.value <- base::withVisible(base::local({
[10:22:06.902]                 a <- 1L
[10:22:06.902]                 plan_a <- unclass(future::plan("list"))
[10:22:06.902]                 nested_a <- nested[-1]
[10:22:06.902]                 stopifnot(length(nested_a) == 1L, length(plan_a) == 
[10:22:06.902]                   1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[10:22:06.902]                   strategy2))
[10:22:06.902]                 for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[10:22:06.902]                   "init") <- NULL
[10:22:06.902]                 for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[10:22:06.902]                   "init") <- NULL
[10:22:06.902]                 stopifnot(all.equal(plan_a, nested_a))
[10:22:06.902]                 y %<-% {
[10:22:06.902]                   b <- 2L
[10:22:06.902]                   plan_b <- future::plan("list")
[10:22:06.902]                   nested_b <- nested_a[-1]
[10:22:06.902]                   stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:22:06.902]                     1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[10:22:06.902]                     "sequential"))
[10:22:06.902]                   list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:22:06.902]                     b = b, nested_b = nested_b, plan_b = plan_b)
[10:22:06.902]                 }
[10:22:06.902]                 y
[10:22:06.902]             }))
[10:22:06.902]             future::FutureResult(value = ...future.value$value, 
[10:22:06.902]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:06.902]                   ...future.rng), globalenv = if (FALSE) 
[10:22:06.902]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:06.902]                     ...future.globalenv.names))
[10:22:06.902]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:06.902]         }, condition = base::local({
[10:22:06.902]             c <- base::c
[10:22:06.902]             inherits <- base::inherits
[10:22:06.902]             invokeRestart <- base::invokeRestart
[10:22:06.902]             length <- base::length
[10:22:06.902]             list <- base::list
[10:22:06.902]             seq.int <- base::seq.int
[10:22:06.902]             signalCondition <- base::signalCondition
[10:22:06.902]             sys.calls <- base::sys.calls
[10:22:06.902]             `[[` <- base::`[[`
[10:22:06.902]             `+` <- base::`+`
[10:22:06.902]             `<<-` <- base::`<<-`
[10:22:06.902]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:06.902]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:06.902]                   3L)]
[10:22:06.902]             }
[10:22:06.902]             function(cond) {
[10:22:06.902]                 is_error <- inherits(cond, "error")
[10:22:06.902]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:06.902]                   NULL)
[10:22:06.902]                 if (is_error) {
[10:22:06.902]                   sessionInformation <- function() {
[10:22:06.902]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:06.902]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:06.902]                       search = base::search(), system = base::Sys.info())
[10:22:06.902]                   }
[10:22:06.902]                   ...future.conditions[[length(...future.conditions) + 
[10:22:06.902]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:06.902]                     cond$call), session = sessionInformation(), 
[10:22:06.902]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:06.902]                   signalCondition(cond)
[10:22:06.902]                 }
[10:22:06.902]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:06.902]                 "immediateCondition"))) {
[10:22:06.902]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:06.902]                   ...future.conditions[[length(...future.conditions) + 
[10:22:06.902]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:06.902]                   if (TRUE && !signal) {
[10:22:06.902]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:06.902]                     {
[10:22:06.902]                       inherits <- base::inherits
[10:22:06.902]                       invokeRestart <- base::invokeRestart
[10:22:06.902]                       is.null <- base::is.null
[10:22:06.902]                       muffled <- FALSE
[10:22:06.902]                       if (inherits(cond, "message")) {
[10:22:06.902]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:06.902]                         if (muffled) 
[10:22:06.902]                           invokeRestart("muffleMessage")
[10:22:06.902]                       }
[10:22:06.902]                       else if (inherits(cond, "warning")) {
[10:22:06.902]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:06.902]                         if (muffled) 
[10:22:06.902]                           invokeRestart("muffleWarning")
[10:22:06.902]                       }
[10:22:06.902]                       else if (inherits(cond, "condition")) {
[10:22:06.902]                         if (!is.null(pattern)) {
[10:22:06.902]                           computeRestarts <- base::computeRestarts
[10:22:06.902]                           grepl <- base::grepl
[10:22:06.902]                           restarts <- computeRestarts(cond)
[10:22:06.902]                           for (restart in restarts) {
[10:22:06.902]                             name <- restart$name
[10:22:06.902]                             if (is.null(name)) 
[10:22:06.902]                               next
[10:22:06.902]                             if (!grepl(pattern, name)) 
[10:22:06.902]                               next
[10:22:06.902]                             invokeRestart(restart)
[10:22:06.902]                             muffled <- TRUE
[10:22:06.902]                             break
[10:22:06.902]                           }
[10:22:06.902]                         }
[10:22:06.902]                       }
[10:22:06.902]                       invisible(muffled)
[10:22:06.902]                     }
[10:22:06.902]                     muffleCondition(cond, pattern = "^muffle")
[10:22:06.902]                   }
[10:22:06.902]                 }
[10:22:06.902]                 else {
[10:22:06.902]                   if (TRUE) {
[10:22:06.902]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:06.902]                     {
[10:22:06.902]                       inherits <- base::inherits
[10:22:06.902]                       invokeRestart <- base::invokeRestart
[10:22:06.902]                       is.null <- base::is.null
[10:22:06.902]                       muffled <- FALSE
[10:22:06.902]                       if (inherits(cond, "message")) {
[10:22:06.902]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:06.902]                         if (muffled) 
[10:22:06.902]                           invokeRestart("muffleMessage")
[10:22:06.902]                       }
[10:22:06.902]                       else if (inherits(cond, "warning")) {
[10:22:06.902]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:06.902]                         if (muffled) 
[10:22:06.902]                           invokeRestart("muffleWarning")
[10:22:06.902]                       }
[10:22:06.902]                       else if (inherits(cond, "condition")) {
[10:22:06.902]                         if (!is.null(pattern)) {
[10:22:06.902]                           computeRestarts <- base::computeRestarts
[10:22:06.902]                           grepl <- base::grepl
[10:22:06.902]                           restarts <- computeRestarts(cond)
[10:22:06.902]                           for (restart in restarts) {
[10:22:06.902]                             name <- restart$name
[10:22:06.902]                             if (is.null(name)) 
[10:22:06.902]                               next
[10:22:06.902]                             if (!grepl(pattern, name)) 
[10:22:06.902]                               next
[10:22:06.902]                             invokeRestart(restart)
[10:22:06.902]                             muffled <- TRUE
[10:22:06.902]                             break
[10:22:06.902]                           }
[10:22:06.902]                         }
[10:22:06.902]                       }
[10:22:06.902]                       invisible(muffled)
[10:22:06.902]                     }
[10:22:06.902]                     muffleCondition(cond, pattern = "^muffle")
[10:22:06.902]                   }
[10:22:06.902]                 }
[10:22:06.902]             }
[10:22:06.902]         }))
[10:22:06.902]     }, error = function(ex) {
[10:22:06.902]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:06.902]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:06.902]                 ...future.rng), started = ...future.startTime, 
[10:22:06.902]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:06.902]             version = "1.8"), class = "FutureResult")
[10:22:06.902]     }, finally = {
[10:22:06.902]         if (!identical(...future.workdir, getwd())) 
[10:22:06.902]             setwd(...future.workdir)
[10:22:06.902]         {
[10:22:06.902]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:06.902]                 ...future.oldOptions$nwarnings <- NULL
[10:22:06.902]             }
[10:22:06.902]             base::options(...future.oldOptions)
[10:22:06.902]             if (.Platform$OS.type == "windows") {
[10:22:06.902]                 old_names <- names(...future.oldEnvVars)
[10:22:06.902]                 envs <- base::Sys.getenv()
[10:22:06.902]                 names <- names(envs)
[10:22:06.902]                 common <- intersect(names, old_names)
[10:22:06.902]                 added <- setdiff(names, old_names)
[10:22:06.902]                 removed <- setdiff(old_names, names)
[10:22:06.902]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:06.902]                   envs[common]]
[10:22:06.902]                 NAMES <- toupper(changed)
[10:22:06.902]                 args <- list()
[10:22:06.902]                 for (kk in seq_along(NAMES)) {
[10:22:06.902]                   name <- changed[[kk]]
[10:22:06.902]                   NAME <- NAMES[[kk]]
[10:22:06.902]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:06.902]                     next
[10:22:06.902]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:06.902]                 }
[10:22:06.902]                 NAMES <- toupper(added)
[10:22:06.902]                 for (kk in seq_along(NAMES)) {
[10:22:06.902]                   name <- added[[kk]]
[10:22:06.902]                   NAME <- NAMES[[kk]]
[10:22:06.902]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:06.902]                     next
[10:22:06.902]                   args[[name]] <- ""
[10:22:06.902]                 }
[10:22:06.902]                 NAMES <- toupper(removed)
[10:22:06.902]                 for (kk in seq_along(NAMES)) {
[10:22:06.902]                   name <- removed[[kk]]
[10:22:06.902]                   NAME <- NAMES[[kk]]
[10:22:06.902]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:06.902]                     next
[10:22:06.902]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:06.902]                 }
[10:22:06.902]                 if (length(args) > 0) 
[10:22:06.902]                   base::do.call(base::Sys.setenv, args = args)
[10:22:06.902]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:06.902]             }
[10:22:06.902]             else {
[10:22:06.902]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:06.902]             }
[10:22:06.902]             {
[10:22:06.902]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:06.902]                   0L) {
[10:22:06.902]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:06.902]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:06.902]                   base::options(opts)
[10:22:06.902]                 }
[10:22:06.902]                 {
[10:22:06.902]                   {
[10:22:06.902]                     NULL
[10:22:06.902]                     RNGkind("Mersenne-Twister")
[10:22:06.902]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:06.902]                       inherits = FALSE)
[10:22:06.902]                   }
[10:22:06.902]                   options(future.plan = NULL)
[10:22:06.902]                   if (is.na(NA_character_)) 
[10:22:06.902]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:06.902]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:06.902]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:06.902]                     .init = FALSE)
[10:22:06.902]                 }
[10:22:06.902]             }
[10:22:06.902]         }
[10:22:06.902]     })
[10:22:06.902]     if (TRUE) {
[10:22:06.902]         base::sink(type = "output", split = FALSE)
[10:22:06.902]         if (TRUE) {
[10:22:06.902]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:06.902]         }
[10:22:06.902]         else {
[10:22:06.902]             ...future.result["stdout"] <- base::list(NULL)
[10:22:06.902]         }
[10:22:06.902]         base::close(...future.stdout)
[10:22:06.902]         ...future.stdout <- NULL
[10:22:06.902]     }
[10:22:06.902]     ...future.result$conditions <- ...future.conditions
[10:22:06.902]     ...future.result$finished <- base::Sys.time()
[10:22:06.902]     ...future.result
[10:22:06.902] }
[10:22:06.904] assign_globals() ...
[10:22:06.904] List of 2
[10:22:06.904]  $ nested   :List of 2
[10:22:06.904]   ..$ a:function (..., envir = parent.frame())  
[10:22:06.904]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[10:22:06.904]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:22:06.904]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[10:22:06.904]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[10:22:06.904]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:22:06.904]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:22:06.904]  $ strategy2: chr "multicore"
[10:22:06.904]  - attr(*, "where")=List of 2
[10:22:06.904]   ..$ nested   :<environment: R_EmptyEnv> 
[10:22:06.904]   ..$ strategy2:<environment: R_EmptyEnv> 
[10:22:06.904]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:06.904]  - attr(*, "resolved")= logi FALSE
[10:22:06.904]  - attr(*, "total_size")= num 7972
[10:22:06.904]  - attr(*, "already-done")= logi TRUE
[10:22:06.908] - copied ‘nested’ to environment
[10:22:06.909] - copied ‘strategy2’ to environment
[10:22:06.909] assign_globals() ... done
[10:22:06.909] plan(): Setting new future strategy stack:
[10:22:06.909] List of future strategies:
[10:22:06.909] 1. multicore:
[10:22:06.909]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:06.909]    - tweaked: FALSE
[10:22:06.909]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:06.911] plan(): nbrOfWorkers() = 2
[10:22:06.967] plan(): Setting new future strategy stack:
[10:22:06.967] List of future strategies:
[10:22:06.967] 1. sequential:
[10:22:06.967]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:06.967]    - tweaked: FALSE
[10:22:06.967]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:06.967] 2. multicore:
[10:22:06.967]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:06.967]    - tweaked: FALSE
[10:22:06.967]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:06.968] plan(): nbrOfWorkers() = 1
[10:22:06.968] SequentialFuture started (and completed)
[10:22:06.968] signalConditions() ...
[10:22:06.968]  - include = ‘immediateCondition’
[10:22:06.969]  - exclude = 
[10:22:06.969]  - resignal = FALSE
[10:22:06.969]  - Number of conditions: 57
[10:22:06.969] signalConditions() ... done
[10:22:06.969] - Launch lazy future ... done
[10:22:06.969] run() for ‘SequentialFuture’ ... done
[10:22:06.970] signalConditions() ...
[10:22:06.970]  - include = ‘immediateCondition’
[10:22:06.970]  - exclude = 
[10:22:06.970]  - resignal = FALSE
[10:22:06.970]  - Number of conditions: 57
[10:22:06.970] signalConditions() ... done
[10:22:06.971] Future state: ‘finished’
[10:22:06.971] signalConditions() ...
[10:22:06.971]  - include = ‘condition’
[10:22:06.971]  - exclude = ‘immediateCondition’
[10:22:06.971]  - resignal = TRUE
[10:22:06.971]  - Number of conditions: 57
[10:22:06.971]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.912] getGlobalsAndPackages() ...
[10:22:06.972]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.912] Searching for globals...
[10:22:06.972]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.930] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[10:22:06.972]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.930] Searching for globals ... DONE
[10:22:06.972]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.930] Resolving globals: FALSE
[10:22:06.972]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.931] The total size of the 3 globals is 12.54 KiB (12841 bytes)
[10:22:06.972]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.931] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 12.54 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (6.25 KiB of class ‘list’), ‘plan_a’ (6.25 KiB of class ‘list’) and ‘a’ (35 bytes of class ‘numeric’)
[10:22:06.973]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.932] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[10:22:06.973]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.932] 
[10:22:06.973]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.932] getGlobalsAndPackages() ... DONE
[10:22:06.973]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.932] run() for ‘Future’ ...
[10:22:06.973]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.932] - state: ‘created’
[10:22:06.973]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.932] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:06.974]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.934] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:06.974]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.934] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:06.974]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.934]   - Field: ‘label’
[10:22:06.974]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.935]   - Field: ‘local’
[10:22:06.974]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.935]   - Field: ‘owner’
[10:22:06.974]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.935]   - Field: ‘envir’
[10:22:06.975]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.935]   - Field: ‘workers’
[10:22:06.975]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.935]   - Field: ‘packages’
[10:22:06.975]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.935]   - Field: ‘gc’
[10:22:06.975]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.935]   - Field: ‘job’
[10:22:06.975]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.935]   - Field: ‘conditions’
[10:22:06.975]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.935]   - Field: ‘expr’
[10:22:06.975]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.935]   - Field: ‘uuid’
[10:22:06.976]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.936]   - Field: ‘seed’
[10:22:06.976]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.936]   - Field: ‘version’
[10:22:06.976]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.937]   - Field: ‘result’
[10:22:06.976]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.937]   - Field: ‘asynchronous’
[10:22:06.976]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.937]   - Field: ‘calls’
[10:22:06.976]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.937]   - Field: ‘globals’
[10:22:06.976]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.937]   - Field: ‘stdout’
[10:22:06.977]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.937]   - Field: ‘earlySignal’
[10:22:06.977]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.937]   - Field: ‘lazy’
[10:22:06.977]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.938]   - Field: ‘state’
[10:22:06.977]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.938] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:06.977]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.938] - Launch lazy future ...
[10:22:06.977]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.939] Packages needed by the future expression (n = 0): <none>
[10:22:06.978]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.939] Packages needed by future strategies (n = 0): <none>
[10:22:06.978]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.939] {
[10:22:06.939]     {
[10:22:06.939]         {
[10:22:06.939]             ...future.startTime <- base::Sys.time()
[10:22:06.939]             {
[10:22:06.939]                 {
[10:22:06.939]                   {
[10:22:06.939]                     {
[10:22:06.939]                       base::local({
[10:22:06.939]                         has_future <- base::requireNamespace("future", 
[10:22:06.939]                           quietly = TRUE)
[10:22:06.939]                         if (has_future) {
[10:22:06.939]                           ns <- base::getNamespace("future")
[10:22:06.939]                           version <- ns[[".package"]][["version"]]
[10:22:06.939]                           if (is.null(version)) 
[10:22:06.939]                             version <- utils::packageVersion("future")
[10:22:06.939]                         }
[10:22:06.939]                         else {
[10:22:06.939]                           version <- NULL
[10:22:06.939]                         }
[10:22:06.939]                         if (!has_future || version < "1.8.0") {
[10:22:06.939]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:06.939]                             "", base::R.version$version.string), 
[10:22:06.939]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:06.939]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:06.939]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:06.939]                               "release", "version")], collapse = " "), 
[10:22:06.939]                             hostname = base::Sys.info()[["nodename"]])
[10:22:06.939]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:06.939]                             info)
[10:22:06.939]                           info <- base::paste(info, collapse = "; ")
[10:22:06.939]                           if (!has_future) {
[10:22:06.939]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:06.939]                               info)
[10:22:06.939]                           }
[10:22:06.939]                           else {
[10:22:06.939]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:06.939]                               info, version)
[10:22:06.939]                           }
[10:22:06.939]                           base::stop(msg)
[10:22:06.939]                         }
[10:22:06.939]                       })
[10:22:06.939]                     }
[10:22:06.939]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:06.939]                     base::options(mc.cores = 1L)
[10:22:06.939]                   }
[10:22:06.939]                   ...future.strategy.old <- future::plan("list")
[10:22:06.939]                   options(future.plan = NULL)
[10:22:06.939]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:06.939]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:06.939]                 }
[10:22:06.939]                 ...future.workdir <- getwd()
[10:22:06.939]             }
[10:22:06.939]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:06.939]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:06.939]         }
[10:22:06.939]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:06.939]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:06.939]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:06.939]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:06.939]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:06.939]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:06.939]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:06.939]             base::names(...future.oldOptions))
[10:22:06.939]     }
[10:22:06.939]     if (FALSE) {
[10:22:06.939]     }
[10:22:06.939]     else {
[10:22:06.939]         if (TRUE) {
[10:22:06.939]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:06.939]                 open = "w")
[10:22:06.939]         }
[10:22:06.939]         else {
[10:22:06.939]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:06.939]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:06.939]         }
[10:22:06.939]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:06.939]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:06.939]             base::sink(type = "output", split = FALSE)
[10:22:06.939]             base::close(...future.stdout)
[10:22:06.939]         }, add = TRUE)
[10:22:06.939]     }
[10:22:06.939]     ...future.frame <- base::sys.nframe()
[10:22:06.939]     ...future.conditions <- base::list()
[10:22:06.939]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:06.939]     if (FALSE) {
[10:22:06.939]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:06.939]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:06.939]     }
[10:22:06.939]     ...future.result <- base::tryCatch({
[10:22:06.939]         base::withCallingHandlers({
[10:22:06.939]             ...future.value <- base::withVisible(base::local({
[10:22:06.939]                 withCallingHandlers({
[10:22:06.939]                   {
[10:22:06.939]                     b <- 2L
[10:22:06.939]                     plan_b <- future::plan("list")
[10:22:06.939]                     nested_b <- nested_a[-1]
[10:22:06.939]                     stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:22:06.939]                       1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[10:22:06.939]                       "sequential"))
[10:22:06.939]                     list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:22:06.939]                       b = b, nested_b = nested_b, plan_b = plan_b)
[10:22:06.939]                   }
[10:22:06.939]                 }, immediateCondition = function(cond) {
[10:22:06.939]                   save_rds <- function (object, pathname, ...) 
[10:22:06.939]                   {
[10:22:06.939]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:06.939]                     if (file_test("-f", pathname_tmp)) {
[10:22:06.939]                       fi_tmp <- file.info(pathname_tmp)
[10:22:06.939]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:06.939]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:06.939]                         fi_tmp[["mtime"]])
[10:22:06.939]                     }
[10:22:06.939]                     tryCatch({
[10:22:06.939]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:06.939]                     }, error = function(ex) {
[10:22:06.939]                       msg <- conditionMessage(ex)
[10:22:06.939]                       fi_tmp <- file.info(pathname_tmp)
[10:22:06.939]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:06.939]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:06.939]                         fi_tmp[["mtime"]], msg)
[10:22:06.939]                       ex$message <- msg
[10:22:06.939]                       stop(ex)
[10:22:06.939]                     })
[10:22:06.939]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:06.939]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:06.939]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:06.939]                       fi_tmp <- file.info(pathname_tmp)
[10:22:06.939]                       fi <- file.info(pathname)
[10:22:06.939]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:06.939]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:06.939]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:06.939]                         fi[["size"]], fi[["mtime"]])
[10:22:06.939]                       stop(msg)
[10:22:06.939]                     }
[10:22:06.939]                     invisible(pathname)
[10:22:06.939]                   }
[10:22:06.939]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:06.939]                     rootPath = tempdir()) 
[10:22:06.939]                   {
[10:22:06.939]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:06.939]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:06.939]                       tmpdir = path, fileext = ".rds")
[10:22:06.939]                     save_rds(obj, file)
[10:22:06.939]                   }
[10:22:06.939]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4kEgVJ/.future/immediateConditions")
[10:22:06.939]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:06.939]                   {
[10:22:06.939]                     inherits <- base::inherits
[10:22:06.939]                     invokeRestart <- base::invokeRestart
[10:22:06.939]                     is.null <- base::is.null
[10:22:06.939]                     muffled <- FALSE
[10:22:06.939]                     if (inherits(cond, "message")) {
[10:22:06.939]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:06.939]                       if (muffled) 
[10:22:06.939]                         invokeRestart("muffleMessage")
[10:22:06.939]                     }
[10:22:06.939]                     else if (inherits(cond, "warning")) {
[10:22:06.939]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:06.939]                       if (muffled) 
[10:22:06.939]                         invokeRestart("muffleWarning")
[10:22:06.939]                     }
[10:22:06.939]                     else if (inherits(cond, "condition")) {
[10:22:06.939]                       if (!is.null(pattern)) {
[10:22:06.939]                         computeRestarts <- base::computeRestarts
[10:22:06.939]                         grepl <- base::grepl
[10:22:06.939]                         restarts <- computeRestarts(cond)
[10:22:06.939]                         for (restart in restarts) {
[10:22:06.939]                           name <- restart$name
[10:22:06.939]                           if (is.null(name)) 
[10:22:06.939]                             next
[10:22:06.939]                           if (!grepl(pattern, name)) 
[10:22:06.939]                             next
[10:22:06.939]                           invokeRestart(restart)
[10:22:06.939]                           muffled <- TRUE
[10:22:06.939]                           break
[10:22:06.939]                         }
[10:22:06.939]                       }
[10:22:06.939]                     }
[10:22:06.939]                     invisible(muffled)
[10:22:06.939]                   }
[10:22:06.939]                   muffleCondition(cond)
[10:22:06.939]                 })
[10:22:06.939]             }))
[10:22:06.939]             future::FutureResult(value = ...future.value$value, 
[10:22:06.939]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:06.939]                   ...future.rng), globalenv = if (FALSE) 
[10:22:06.939]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:06.939]                     ...future.globalenv.names))
[10:22:06.939]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:06.939]         }, condition = base::local({
[10:22:06.939]             c <- base::c
[10:22:06.939]             inherits <- base::inherits
[10:22:06.939]             invokeRestart <- base::invokeRestart
[10:22:06.939]             length <- base::length
[10:22:06.939]             list <- base::list
[10:22:06.939]             seq.int <- base::seq.int
[10:22:06.939]             signalCondition <- base::signalCondition
[10:22:06.939]             sys.calls <- base::sys.calls
[10:22:06.939]             `[[` <- base::`[[`
[10:22:06.939]             `+` <- base::`+`
[10:22:06.939]             `<<-` <- base::`<<-`
[10:22:06.939]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:06.939]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:06.939]                   3L)]
[10:22:06.939]             }
[10:22:06.939]             function(cond) {
[10:22:06.939]                 is_error <- inherits(cond, "error")
[10:22:06.939]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:06.939]                   NULL)
[10:22:06.939]                 if (is_error) {
[10:22:06.939]                   sessionInformation <- function() {
[10:22:06.939]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:06.939]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:06.939]                       search = base::search(), system = base::Sys.info())
[10:22:06.939]                   }
[10:22:06.939]                   ...future.conditions[[length(...future.conditions) + 
[10:22:06.939]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:06.939]                     cond$call), session = sessionInformation(), 
[10:22:06.939]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:06.939]                   signalCondition(cond)
[10:22:06.939]                 }
[10:22:06.939]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:06.939]                 "immediateCondition"))) {
[10:22:06.939]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:06.939]                   ...future.conditions[[length(...future.conditions) + 
[10:22:06.939]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:06.939]                   if (TRUE && !signal) {
[10:22:06.939]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:06.939]                     {
[10:22:06.939]                       inherits <- base::inherits
[10:22:06.939]                       invokeRestart <- base::invokeRestart
[10:22:06.939]                       is.null <- base::is.null
[10:22:06.939]                       muffled <- FALSE
[10:22:06.939]                       if (inherits(cond, "message")) {
[10:22:06.939]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:06.939]                         if (muffled) 
[10:22:06.939]                           invokeRestart("muffleMessage")
[10:22:06.939]                       }
[10:22:06.939]                       else if (inherits(cond, "warning")) {
[10:22:06.939]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:06.939]                         if (muffled) 
[10:22:06.939]                           invokeRestart("muffleWarning")
[10:22:06.939]                       }
[10:22:06.939]                       else if (inherits(cond, "condition")) {
[10:22:06.939]                         if (!is.null(pattern)) {
[10:22:06.939]                           computeRestarts <- base::computeRestarts
[10:22:06.939]                           grepl <- base::grepl
[10:22:06.939]                           restarts <- computeRestarts(cond)
[10:22:06.939]                           for (restart in restarts) {
[10:22:06.939]                             name <- restart$name
[10:22:06.939]                             if (is.null(name)) 
[10:22:06.939]                               next
[10:22:06.939]                             if (!grepl(pattern, name)) 
[10:22:06.939]                               next
[10:22:06.939]                             invokeRestart(restart)
[10:22:06.939]                             muffled <- TRUE
[10:22:06.939]                             break
[10:22:06.939]                           }
[10:22:06.939]                         }
[10:22:06.939]                       }
[10:22:06.939]                       invisible(muffled)
[10:22:06.939]                     }
[10:22:06.939]                     muffleCondition(cond, pattern = "^muffle")
[10:22:06.939]                   }
[10:22:06.939]                 }
[10:22:06.939]                 else {
[10:22:06.939]                   if (TRUE) {
[10:22:06.939]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:06.939]                     {
[10:22:06.939]                       inherits <- base::inherits
[10:22:06.939]                       invokeRestart <- base::invokeRestart
[10:22:06.939]                       is.null <- base::is.null
[10:22:06.939]                       muffled <- FALSE
[10:22:06.939]                       if (inherits(cond, "message")) {
[10:22:06.939]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:06.939]                         if (muffled) 
[10:22:06.939]                           invokeRestart("muffleMessage")
[10:22:06.939]                       }
[10:22:06.939]                       else if (inherits(cond, "warning")) {
[10:22:06.939]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:06.939]                         if (muffled) 
[10:22:06.939]                           invokeRestart("muffleWarning")
[10:22:06.939]                       }
[10:22:06.939]                       else if (inherits(cond, "condition")) {
[10:22:06.939]                         if (!is.null(pattern)) {
[10:22:06.939]                           computeRestarts <- base::computeRestarts
[10:22:06.939]                           grepl <- base::grepl
[10:22:06.939]                           restarts <- computeRestarts(cond)
[10:22:06.939]                           for (restart in restarts) {
[10:22:06.939]                             name <- restart$name
[10:22:06.939]                             if (is.null(name)) 
[10:22:06.939]                               next
[10:22:06.939]                             if (!grepl(pattern, name)) 
[10:22:06.939]                               next
[10:22:06.939]                             invokeRestart(restart)
[10:22:06.939]                             muffled <- TRUE
[10:22:06.939]                             break
[10:22:06.939]                           }
[10:22:06.939]                         }
[10:22:06.939]                       }
[10:22:06.939]                       invisible(muffled)
[10:22:06.939]                     }
[10:22:06.939]                     muffleCondition(cond, pattern = "^muffle")
[10:22:06.939]                   }
[10:22:06.939]                 }
[10:22:06.939]             }
[10:22:06.939]         }))
[10:22:06.939]     }, error = function(ex) {
[10:22:06.939]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:06.939]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:06.939]                 ...future.rng), started = ...future.startTime, 
[10:22:06.939]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:06.939]             version = "1.8"), class = "FutureResult")
[10:22:06.939]     }, finally = {
[10:22:06.939]         if (!identical(...future.workdir, getwd())) 
[10:22:06.939]             setwd(...future.workdir)
[10:22:06.939]         {
[10:22:06.939]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:06.939]                 ...future.oldOptions$nwarnings <- NULL
[10:22:06.939]             }
[10:22:06.939]             base::options(...future.oldOptions)
[10:22:06.939]             if (.Platform$OS.type == "windows") {
[10:22:06.939]                 old_names <- names(...future.oldEnvVars)
[10:22:06.939]                 envs <- base::Sys.getenv()
[10:22:06.939]                 names <- names(envs)
[10:22:06.939]                 common <- intersect(names, old_names)
[10:22:06.939]                 added <- setdiff(names, old_names)
[10:22:06.939]                 removed <- setdiff(old_names, names)
[10:22:06.939]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:06.939]                   envs[common]]
[10:22:06.939]                 NAMES <- toupper(changed)
[10:22:06.939]                 args <- list()
[10:22:06.939]                 for (kk in seq_along(NAMES)) {
[10:22:06.939]                   name <- changed[[kk]]
[10:22:06.939]                   NAME <- NAMES[[kk]]
[10:22:06.939]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:06.939]                     next
[10:22:06.939]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:06.939]                 }
[10:22:06.939]                 NAMES <- toupper(added)
[10:22:06.939]                 for (kk in seq_along(NAMES)) {
[10:22:06.939]                   name <- added[[kk]]
[10:22:06.939]                   NAME <- NAMES[[kk]]
[10:22:06.939]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:06.939]                     next
[10:22:06.939]                   args[[name]] <- ""
[10:22:06.939]                 }
[10:22:06.939]                 NAMES <- toupper(removed)
[10:22:06.939]                 for (kk in seq_along(NAMES)) {
[10:22:06.939]                   name <- removed[[kk]]
[10:22:06.939]                   NAME <- NAMES[[kk]]
[10:22:06.939]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:06.939]                     next
[10:22:06.939]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:06.939]                 }
[10:22:06.939]                 if (length(args) > 0) 
[10:22:06.939]                   base::do.call(base::Sys.setenv, args = args)
[10:22:06.939]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:06.939]             }
[10:22:06.939]             else {
[10:22:06.939]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:06.939]             }
[10:22:06.939]             {
[10:22:06.939]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:06.939]                   0L) {
[10:22:06.939]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:06.939]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:06.939]                   base::options(opts)
[10:22:06.939]                 }
[10:22:06.939]                 {
[10:22:06.939]                   {
[10:22:06.939]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:06.939]                     NULL
[10:22:06.939]                   }
[10:22:06.939]                   options(future.plan = NULL)
[10:22:06.939]                   if (is.na(NA_character_)) 
[10:22:06.939]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:06.939]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:06.939]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:06.939]                     .init = FALSE)
[10:22:06.939]                 }
[10:22:06.939]             }
[10:22:06.939]         }
[10:22:06.939]     })
[10:22:06.939]     if (TRUE) {
[10:22:06.939]         base::sink(type = "output", split = FALSE)
[10:22:06.939]         if (TRUE) {
[10:22:06.939]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:06.939]         }
[10:22:06.939]         else {
[10:22:06.939]             ...future.result["stdout"] <- base::list(NULL)
[10:22:06.939]         }
[10:22:06.939]         base::close(...future.stdout)
[10:22:06.939]         ...future.stdout <- NULL
[10:22:06.939]     }
[10:22:06.939]     ...future.result$conditions <- ...future.conditions
[10:22:06.939]     ...future.result$finished <- base::Sys.time()
[10:22:06.939]     ...future.result
[10:22:06.939] }
[10:22:06.978]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.941] assign_globals() ...
[10:22:06.978]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.941] List of 3
[10:22:06.941]  $ nested_a:List of 1
[10:22:06.941]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[10:22:06.941]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[10:22:06.941]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:22:06.941]  $ a       : int 1
[10:22:06.941]  $ plan_a  :List of 1
[10:22:06.941]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[10:22:06.941]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[10:22:06.941]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:22:06.941]  - attr(*, "where")=List of 3
[10:22:06.941]   ..$ nested_a:<environment: R_EmptyEnv> 
[10:22:06.941]   ..$ a       :<environment: R_EmptyEnv> 
[10:22:06.941]   ..$ plan_a  :<environment: R_EmptyEnv> 
[10:22:06.941]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:06.941]  - attr(*, "resolved")= logi FALSE
[10:22:06.941]  - attr(*, "total_size")= num 12841
[10:22:06.941]  - attr(*, "already-done")= logi TRUE
[10:22:06.981]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.946] - copied ‘nested_a’ to environment
[10:22:06.981]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.946] - copied ‘a’ to environment
[10:22:06.981]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.946] - copied ‘plan_a’ to environment
[10:22:06.982]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.946] assign_globals() ... done
[10:22:06.982]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.946] requestCore(): workers = 2
[10:22:06.982]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.949] MulticoreFuture started
[10:22:06.982]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.950] - Launch lazy future ... done
[10:22:06.983]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.950] run() for ‘MulticoreFuture’ ... done
[10:22:06.983]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.951] result() for MulticoreFuture ...
[10:22:06.983]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.965] result() for MulticoreFuture ...
[10:22:06.984]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.965] result() for MulticoreFuture ... done
[10:22:06.984]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.965] result() for MulticoreFuture ... done
[10:22:06.984]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.965] result() for MulticoreFuture ...
[10:22:06.984]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:06.966] result() for MulticoreFuture ... done
[10:22:06.985] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:22:06.993] getGlobalsAndPackages() ...
[10:22:06.993] Searching for globals...
[10:22:06.996] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[10:22:06.996] Searching for globals ... DONE
[10:22:06.996] Resolving globals: FALSE
[10:22:06.996] The total size of the 1 globals is 356 bytes (356 bytes)
[10:22:06.997] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[10:22:06.997] - globals: [1] ‘data’
[10:22:06.997] - packages: [1] ‘future’
[10:22:06.997] getGlobalsAndPackages() ... DONE
[10:22:06.997] run() for ‘Future’ ...
[10:22:06.998] - state: ‘created’
[10:22:06.998] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:06.998] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:06.998] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:06.998]   - Field: ‘label’
[10:22:06.998]   - Field: ‘local’
[10:22:06.998]   - Field: ‘owner’
[10:22:06.999]   - Field: ‘envir’
[10:22:06.999]   - Field: ‘packages’
[10:22:06.999]   - Field: ‘gc’
[10:22:06.999]   - Field: ‘conditions’
[10:22:06.999]   - Field: ‘expr’
[10:22:06.999]   - Field: ‘uuid’
[10:22:06.999]   - Field: ‘seed’
[10:22:06.999]   - Field: ‘version’
[10:22:06.999]   - Field: ‘result’
[10:22:06.999]   - Field: ‘asynchronous’
[10:22:06.999]   - Field: ‘calls’
[10:22:06.999]   - Field: ‘globals’
[10:22:07.000]   - Field: ‘stdout’
[10:22:07.000]   - Field: ‘earlySignal’
[10:22:07.000]   - Field: ‘lazy’
[10:22:07.000]   - Field: ‘state’
[10:22:07.000] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:07.000] - Launch lazy future ...
[10:22:07.000] Packages needed by the future expression (n = 1): ‘future’
[10:22:07.000] Packages needed by future strategies (n = 1): ‘future’
[10:22:07.001] {
[10:22:07.001]     {
[10:22:07.001]         {
[10:22:07.001]             ...future.startTime <- base::Sys.time()
[10:22:07.001]             {
[10:22:07.001]                 {
[10:22:07.001]                   {
[10:22:07.001]                     {
[10:22:07.001]                       base::local({
[10:22:07.001]                         has_future <- base::requireNamespace("future", 
[10:22:07.001]                           quietly = TRUE)
[10:22:07.001]                         if (has_future) {
[10:22:07.001]                           ns <- base::getNamespace("future")
[10:22:07.001]                           version <- ns[[".package"]][["version"]]
[10:22:07.001]                           if (is.null(version)) 
[10:22:07.001]                             version <- utils::packageVersion("future")
[10:22:07.001]                         }
[10:22:07.001]                         else {
[10:22:07.001]                           version <- NULL
[10:22:07.001]                         }
[10:22:07.001]                         if (!has_future || version < "1.8.0") {
[10:22:07.001]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:07.001]                             "", base::R.version$version.string), 
[10:22:07.001]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:07.001]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:07.001]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:07.001]                               "release", "version")], collapse = " "), 
[10:22:07.001]                             hostname = base::Sys.info()[["nodename"]])
[10:22:07.001]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:07.001]                             info)
[10:22:07.001]                           info <- base::paste(info, collapse = "; ")
[10:22:07.001]                           if (!has_future) {
[10:22:07.001]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:07.001]                               info)
[10:22:07.001]                           }
[10:22:07.001]                           else {
[10:22:07.001]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:07.001]                               info, version)
[10:22:07.001]                           }
[10:22:07.001]                           base::stop(msg)
[10:22:07.001]                         }
[10:22:07.001]                       })
[10:22:07.001]                     }
[10:22:07.001]                     base::local({
[10:22:07.001]                       for (pkg in "future") {
[10:22:07.001]                         base::loadNamespace(pkg)
[10:22:07.001]                         base::library(pkg, character.only = TRUE)
[10:22:07.001]                       }
[10:22:07.001]                     })
[10:22:07.001]                   }
[10:22:07.001]                   ...future.strategy.old <- future::plan("list")
[10:22:07.001]                   options(future.plan = NULL)
[10:22:07.001]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:07.001]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[10:22:07.001]                     envir = parent.frame()) 
[10:22:07.001]                   {
[10:22:07.001]                     default_workers <- missing(workers)
[10:22:07.001]                     if (is.function(workers)) 
[10:22:07.001]                       workers <- workers()
[10:22:07.001]                     workers <- structure(as.integer(workers), 
[10:22:07.001]                       class = class(workers))
[10:22:07.001]                     stop_if_not(is.finite(workers), workers >= 
[10:22:07.001]                       1L)
[10:22:07.001]                     if ((workers == 1L && !inherits(workers, 
[10:22:07.001]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:07.001]                       if (default_workers) 
[10:22:07.001]                         supportsMulticore(warn = TRUE)
[10:22:07.001]                       return(sequential(..., envir = envir))
[10:22:07.001]                     }
[10:22:07.001]                     oopts <- options(mc.cores = workers)
[10:22:07.001]                     on.exit(options(oopts))
[10:22:07.001]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:07.001]                       envir = envir)
[10:22:07.001]                     if (!future$lazy) 
[10:22:07.001]                       future <- run(future)
[10:22:07.001]                     invisible(future)
[10:22:07.001]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:07.001]                 }
[10:22:07.001]                 ...future.workdir <- getwd()
[10:22:07.001]             }
[10:22:07.001]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:07.001]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:07.001]         }
[10:22:07.001]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:07.001]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:07.001]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:07.001]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:07.001]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:07.001]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:07.001]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:07.001]             base::names(...future.oldOptions))
[10:22:07.001]     }
[10:22:07.001]     if (FALSE) {
[10:22:07.001]     }
[10:22:07.001]     else {
[10:22:07.001]         if (TRUE) {
[10:22:07.001]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:07.001]                 open = "w")
[10:22:07.001]         }
[10:22:07.001]         else {
[10:22:07.001]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:07.001]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:07.001]         }
[10:22:07.001]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:07.001]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:07.001]             base::sink(type = "output", split = FALSE)
[10:22:07.001]             base::close(...future.stdout)
[10:22:07.001]         }, add = TRUE)
[10:22:07.001]     }
[10:22:07.001]     ...future.frame <- base::sys.nframe()
[10:22:07.001]     ...future.conditions <- base::list()
[10:22:07.001]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:07.001]     if (FALSE) {
[10:22:07.001]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:07.001]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:07.001]     }
[10:22:07.001]     ...future.result <- base::tryCatch({
[10:22:07.001]         base::withCallingHandlers({
[10:22:07.001]             ...future.value <- base::withVisible(base::local({
[10:22:07.001]                 value(future(subset(data, a == 2)))
[10:22:07.001]             }))
[10:22:07.001]             future::FutureResult(value = ...future.value$value, 
[10:22:07.001]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:07.001]                   ...future.rng), globalenv = if (FALSE) 
[10:22:07.001]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:07.001]                     ...future.globalenv.names))
[10:22:07.001]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:07.001]         }, condition = base::local({
[10:22:07.001]             c <- base::c
[10:22:07.001]             inherits <- base::inherits
[10:22:07.001]             invokeRestart <- base::invokeRestart
[10:22:07.001]             length <- base::length
[10:22:07.001]             list <- base::list
[10:22:07.001]             seq.int <- base::seq.int
[10:22:07.001]             signalCondition <- base::signalCondition
[10:22:07.001]             sys.calls <- base::sys.calls
[10:22:07.001]             `[[` <- base::`[[`
[10:22:07.001]             `+` <- base::`+`
[10:22:07.001]             `<<-` <- base::`<<-`
[10:22:07.001]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:07.001]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:07.001]                   3L)]
[10:22:07.001]             }
[10:22:07.001]             function(cond) {
[10:22:07.001]                 is_error <- inherits(cond, "error")
[10:22:07.001]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:07.001]                   NULL)
[10:22:07.001]                 if (is_error) {
[10:22:07.001]                   sessionInformation <- function() {
[10:22:07.001]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:07.001]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:07.001]                       search = base::search(), system = base::Sys.info())
[10:22:07.001]                   }
[10:22:07.001]                   ...future.conditions[[length(...future.conditions) + 
[10:22:07.001]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:07.001]                     cond$call), session = sessionInformation(), 
[10:22:07.001]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:07.001]                   signalCondition(cond)
[10:22:07.001]                 }
[10:22:07.001]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:07.001]                 "immediateCondition"))) {
[10:22:07.001]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:07.001]                   ...future.conditions[[length(...future.conditions) + 
[10:22:07.001]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:07.001]                   if (TRUE && !signal) {
[10:22:07.001]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:07.001]                     {
[10:22:07.001]                       inherits <- base::inherits
[10:22:07.001]                       invokeRestart <- base::invokeRestart
[10:22:07.001]                       is.null <- base::is.null
[10:22:07.001]                       muffled <- FALSE
[10:22:07.001]                       if (inherits(cond, "message")) {
[10:22:07.001]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:07.001]                         if (muffled) 
[10:22:07.001]                           invokeRestart("muffleMessage")
[10:22:07.001]                       }
[10:22:07.001]                       else if (inherits(cond, "warning")) {
[10:22:07.001]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:07.001]                         if (muffled) 
[10:22:07.001]                           invokeRestart("muffleWarning")
[10:22:07.001]                       }
[10:22:07.001]                       else if (inherits(cond, "condition")) {
[10:22:07.001]                         if (!is.null(pattern)) {
[10:22:07.001]                           computeRestarts <- base::computeRestarts
[10:22:07.001]                           grepl <- base::grepl
[10:22:07.001]                           restarts <- computeRestarts(cond)
[10:22:07.001]                           for (restart in restarts) {
[10:22:07.001]                             name <- restart$name
[10:22:07.001]                             if (is.null(name)) 
[10:22:07.001]                               next
[10:22:07.001]                             if (!grepl(pattern, name)) 
[10:22:07.001]                               next
[10:22:07.001]                             invokeRestart(restart)
[10:22:07.001]                             muffled <- TRUE
[10:22:07.001]                             break
[10:22:07.001]                           }
[10:22:07.001]                         }
[10:22:07.001]                       }
[10:22:07.001]                       invisible(muffled)
[10:22:07.001]                     }
[10:22:07.001]                     muffleCondition(cond, pattern = "^muffle")
[10:22:07.001]                   }
[10:22:07.001]                 }
[10:22:07.001]                 else {
[10:22:07.001]                   if (TRUE) {
[10:22:07.001]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:07.001]                     {
[10:22:07.001]                       inherits <- base::inherits
[10:22:07.001]                       invokeRestart <- base::invokeRestart
[10:22:07.001]                       is.null <- base::is.null
[10:22:07.001]                       muffled <- FALSE
[10:22:07.001]                       if (inherits(cond, "message")) {
[10:22:07.001]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:07.001]                         if (muffled) 
[10:22:07.001]                           invokeRestart("muffleMessage")
[10:22:07.001]                       }
[10:22:07.001]                       else if (inherits(cond, "warning")) {
[10:22:07.001]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:07.001]                         if (muffled) 
[10:22:07.001]                           invokeRestart("muffleWarning")
[10:22:07.001]                       }
[10:22:07.001]                       else if (inherits(cond, "condition")) {
[10:22:07.001]                         if (!is.null(pattern)) {
[10:22:07.001]                           computeRestarts <- base::computeRestarts
[10:22:07.001]                           grepl <- base::grepl
[10:22:07.001]                           restarts <- computeRestarts(cond)
[10:22:07.001]                           for (restart in restarts) {
[10:22:07.001]                             name <- restart$name
[10:22:07.001]                             if (is.null(name)) 
[10:22:07.001]                               next
[10:22:07.001]                             if (!grepl(pattern, name)) 
[10:22:07.001]                               next
[10:22:07.001]                             invokeRestart(restart)
[10:22:07.001]                             muffled <- TRUE
[10:22:07.001]                             break
[10:22:07.001]                           }
[10:22:07.001]                         }
[10:22:07.001]                       }
[10:22:07.001]                       invisible(muffled)
[10:22:07.001]                     }
[10:22:07.001]                     muffleCondition(cond, pattern = "^muffle")
[10:22:07.001]                   }
[10:22:07.001]                 }
[10:22:07.001]             }
[10:22:07.001]         }))
[10:22:07.001]     }, error = function(ex) {
[10:22:07.001]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:07.001]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:07.001]                 ...future.rng), started = ...future.startTime, 
[10:22:07.001]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:07.001]             version = "1.8"), class = "FutureResult")
[10:22:07.001]     }, finally = {
[10:22:07.001]         if (!identical(...future.workdir, getwd())) 
[10:22:07.001]             setwd(...future.workdir)
[10:22:07.001]         {
[10:22:07.001]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:07.001]                 ...future.oldOptions$nwarnings <- NULL
[10:22:07.001]             }
[10:22:07.001]             base::options(...future.oldOptions)
[10:22:07.001]             if (.Platform$OS.type == "windows") {
[10:22:07.001]                 old_names <- names(...future.oldEnvVars)
[10:22:07.001]                 envs <- base::Sys.getenv()
[10:22:07.001]                 names <- names(envs)
[10:22:07.001]                 common <- intersect(names, old_names)
[10:22:07.001]                 added <- setdiff(names, old_names)
[10:22:07.001]                 removed <- setdiff(old_names, names)
[10:22:07.001]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:07.001]                   envs[common]]
[10:22:07.001]                 NAMES <- toupper(changed)
[10:22:07.001]                 args <- list()
[10:22:07.001]                 for (kk in seq_along(NAMES)) {
[10:22:07.001]                   name <- changed[[kk]]
[10:22:07.001]                   NAME <- NAMES[[kk]]
[10:22:07.001]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:07.001]                     next
[10:22:07.001]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:07.001]                 }
[10:22:07.001]                 NAMES <- toupper(added)
[10:22:07.001]                 for (kk in seq_along(NAMES)) {
[10:22:07.001]                   name <- added[[kk]]
[10:22:07.001]                   NAME <- NAMES[[kk]]
[10:22:07.001]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:07.001]                     next
[10:22:07.001]                   args[[name]] <- ""
[10:22:07.001]                 }
[10:22:07.001]                 NAMES <- toupper(removed)
[10:22:07.001]                 for (kk in seq_along(NAMES)) {
[10:22:07.001]                   name <- removed[[kk]]
[10:22:07.001]                   NAME <- NAMES[[kk]]
[10:22:07.001]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:07.001]                     next
[10:22:07.001]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:07.001]                 }
[10:22:07.001]                 if (length(args) > 0) 
[10:22:07.001]                   base::do.call(base::Sys.setenv, args = args)
[10:22:07.001]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:07.001]             }
[10:22:07.001]             else {
[10:22:07.001]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:07.001]             }
[10:22:07.001]             {
[10:22:07.001]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:07.001]                   0L) {
[10:22:07.001]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:07.001]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:07.001]                   base::options(opts)
[10:22:07.001]                 }
[10:22:07.001]                 {
[10:22:07.001]                   {
[10:22:07.001]                     NULL
[10:22:07.001]                     RNGkind("Mersenne-Twister")
[10:22:07.001]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:07.001]                       inherits = FALSE)
[10:22:07.001]                   }
[10:22:07.001]                   options(future.plan = NULL)
[10:22:07.001]                   if (is.na(NA_character_)) 
[10:22:07.001]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:07.001]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:07.001]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:07.001]                     .init = FALSE)
[10:22:07.001]                 }
[10:22:07.001]             }
[10:22:07.001]         }
[10:22:07.001]     })
[10:22:07.001]     if (TRUE) {
[10:22:07.001]         base::sink(type = "output", split = FALSE)
[10:22:07.001]         if (TRUE) {
[10:22:07.001]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:07.001]         }
[10:22:07.001]         else {
[10:22:07.001]             ...future.result["stdout"] <- base::list(NULL)
[10:22:07.001]         }
[10:22:07.001]         base::close(...future.stdout)
[10:22:07.001]         ...future.stdout <- NULL
[10:22:07.001]     }
[10:22:07.001]     ...future.result$conditions <- ...future.conditions
[10:22:07.001]     ...future.result$finished <- base::Sys.time()
[10:22:07.001]     ...future.result
[10:22:07.001] }
[10:22:07.003] assign_globals() ...
[10:22:07.003] List of 1
[10:22:07.003]  $ data:'data.frame':	3 obs. of  2 variables:
[10:22:07.003]   ..$ a: int [1:3] 1 2 3
[10:22:07.003]   ..$ b: int [1:3] 3 2 1
[10:22:07.003]  - attr(*, "where")=List of 1
[10:22:07.003]   ..$ data:<environment: R_EmptyEnv> 
[10:22:07.003]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:07.003]  - attr(*, "resolved")= logi FALSE
[10:22:07.003]  - attr(*, "total_size")= num 356
[10:22:07.003]  - attr(*, "already-done")= logi TRUE
[10:22:07.008] - copied ‘data’ to environment
[10:22:07.008] assign_globals() ... done
[10:22:07.008] plan(): Setting new future strategy stack:
[10:22:07.008] List of future strategies:
[10:22:07.008] 1. multicore:
[10:22:07.008]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:07.008]    - tweaked: FALSE
[10:22:07.008]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:07.010] plan(): nbrOfWorkers() = 2
[10:22:07.072] plan(): Setting new future strategy stack:
[10:22:07.072] List of future strategies:
[10:22:07.072] 1. sequential:
[10:22:07.072]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:07.072]    - tweaked: FALSE
[10:22:07.072]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:07.072] 2. multicore:
[10:22:07.072]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:07.072]    - tweaked: FALSE
[10:22:07.072]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:07.073] plan(): nbrOfWorkers() = 1
[10:22:07.073] SequentialFuture started (and completed)
[10:22:07.073] signalConditions() ...
[10:22:07.073]  - include = ‘immediateCondition’
[10:22:07.074]  - exclude = 
[10:22:07.074]  - resignal = FALSE
[10:22:07.074]  - Number of conditions: 55
[10:22:07.074] signalConditions() ... done
[10:22:07.074] - Launch lazy future ... done
[10:22:07.074] run() for ‘SequentialFuture’ ... done
[10:22:07.074] signalConditions() ...
[10:22:07.075]  - include = ‘immediateCondition’
[10:22:07.075]  - exclude = 
[10:22:07.075]  - resignal = FALSE
[10:22:07.075]  - Number of conditions: 55
[10:22:07.075] signalConditions() ... done
[10:22:07.075] Future state: ‘finished’
[10:22:07.075] signalConditions() ...
[10:22:07.075]  - include = ‘condition’
[10:22:07.076]  - exclude = ‘immediateCondition’
[10:22:07.076]  - resignal = TRUE
[10:22:07.076]  - Number of conditions: 55
[10:22:07.076]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.011] getGlobalsAndPackages() ...
[10:22:07.076]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.011] Searching for globals...
[10:22:07.076]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.034] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[10:22:07.076]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.034] Searching for globals ... DONE
[10:22:07.077]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.035] Resolving globals: FALSE
[10:22:07.077]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.035] The total size of the 1 globals is 356 bytes (356 bytes)
[10:22:07.077]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.036] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[10:22:07.077]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.036] - globals: [1] ‘data’
[10:22:07.077]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.036] 
[10:22:07.077]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.036] getGlobalsAndPackages() ... DONE
[10:22:07.078]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.037] run() for ‘Future’ ...
[10:22:07.078]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.037] - state: ‘created’
[10:22:07.078]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.037] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:07.078]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.040] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:07.078]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.041] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:07.078]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.041]   - Field: ‘label’
[10:22:07.079]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.041]   - Field: ‘local’
[10:22:07.079]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.041]   - Field: ‘owner’
[10:22:07.079]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.041]   - Field: ‘envir’
[10:22:07.079]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.042]   - Field: ‘workers’
[10:22:07.079]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.042]   - Field: ‘packages’
[10:22:07.079]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.042]   - Field: ‘gc’
[10:22:07.079]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.042]   - Field: ‘job’
[10:22:07.080]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.043]   - Field: ‘conditions’
[10:22:07.080]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.043]   - Field: ‘expr’
[10:22:07.080]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.043]   - Field: ‘uuid’
[10:22:07.080]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.043]   - Field: ‘seed’
[10:22:07.080]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.043]   - Field: ‘version’
[10:22:07.080]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.044]   - Field: ‘result’
[10:22:07.081]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.044]   - Field: ‘asynchronous’
[10:22:07.081]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.044]   - Field: ‘calls’
[10:22:07.081]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.044]   - Field: ‘globals’
[10:22:07.081]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.044]   - Field: ‘stdout’
[10:22:07.081]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.045]   - Field: ‘earlySignal’
[10:22:07.081]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.045]   - Field: ‘lazy’
[10:22:07.081]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.045]   - Field: ‘state’
[10:22:07.082]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.045] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:07.082]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.045] - Launch lazy future ...
[10:22:07.082]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.046] Packages needed by the future expression (n = 0): <none>
[10:22:07.082]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.048] Packages needed by future strategies (n = 0): <none>
[10:22:07.082]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.049] {
[10:22:07.049]     {
[10:22:07.049]         {
[10:22:07.049]             ...future.startTime <- base::Sys.time()
[10:22:07.049]             {
[10:22:07.049]                 {
[10:22:07.049]                   {
[10:22:07.049]                     {
[10:22:07.049]                       base::local({
[10:22:07.049]                         has_future <- base::requireNamespace("future", 
[10:22:07.049]                           quietly = TRUE)
[10:22:07.049]                         if (has_future) {
[10:22:07.049]                           ns <- base::getNamespace("future")
[10:22:07.049]                           version <- ns[[".package"]][["version"]]
[10:22:07.049]                           if (is.null(version)) 
[10:22:07.049]                             version <- utils::packageVersion("future")
[10:22:07.049]                         }
[10:22:07.049]                         else {
[10:22:07.049]                           version <- NULL
[10:22:07.049]                         }
[10:22:07.049]                         if (!has_future || version < "1.8.0") {
[10:22:07.049]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:07.049]                             "", base::R.version$version.string), 
[10:22:07.049]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:07.049]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:07.049]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:07.049]                               "release", "version")], collapse = " "), 
[10:22:07.049]                             hostname = base::Sys.info()[["nodename"]])
[10:22:07.049]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:07.049]                             info)
[10:22:07.049]                           info <- base::paste(info, collapse = "; ")
[10:22:07.049]                           if (!has_future) {
[10:22:07.049]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:07.049]                               info)
[10:22:07.049]                           }
[10:22:07.049]                           else {
[10:22:07.049]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:07.049]                               info, version)
[10:22:07.049]                           }
[10:22:07.049]                           base::stop(msg)
[10:22:07.049]                         }
[10:22:07.049]                       })
[10:22:07.049]                     }
[10:22:07.049]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:07.049]                     base::options(mc.cores = 1L)
[10:22:07.049]                   }
[10:22:07.049]                   ...future.strategy.old <- future::plan("list")
[10:22:07.049]                   options(future.plan = NULL)
[10:22:07.049]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:07.049]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:07.049]                 }
[10:22:07.049]                 ...future.workdir <- getwd()
[10:22:07.049]             }
[10:22:07.049]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:07.049]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:07.049]         }
[10:22:07.049]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:07.049]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:07.049]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:07.049]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:07.049]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:07.049]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:07.049]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:07.049]             base::names(...future.oldOptions))
[10:22:07.049]     }
[10:22:07.049]     if (FALSE) {
[10:22:07.049]     }
[10:22:07.049]     else {
[10:22:07.049]         if (TRUE) {
[10:22:07.049]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:07.049]                 open = "w")
[10:22:07.049]         }
[10:22:07.049]         else {
[10:22:07.049]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:07.049]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:07.049]         }
[10:22:07.049]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:07.049]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:07.049]             base::sink(type = "output", split = FALSE)
[10:22:07.049]             base::close(...future.stdout)
[10:22:07.049]         }, add = TRUE)
[10:22:07.049]     }
[10:22:07.049]     ...future.frame <- base::sys.nframe()
[10:22:07.049]     ...future.conditions <- base::list()
[10:22:07.049]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:07.049]     if (FALSE) {
[10:22:07.049]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:07.049]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:07.049]     }
[10:22:07.049]     ...future.result <- base::tryCatch({
[10:22:07.049]         base::withCallingHandlers({
[10:22:07.049]             ...future.value <- base::withVisible(base::local({
[10:22:07.049]                 withCallingHandlers({
[10:22:07.049]                   subset(data, a == 2)
[10:22:07.049]                 }, immediateCondition = function(cond) {
[10:22:07.049]                   save_rds <- function (object, pathname, ...) 
[10:22:07.049]                   {
[10:22:07.049]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:07.049]                     if (file_test("-f", pathname_tmp)) {
[10:22:07.049]                       fi_tmp <- file.info(pathname_tmp)
[10:22:07.049]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:07.049]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:07.049]                         fi_tmp[["mtime"]])
[10:22:07.049]                     }
[10:22:07.049]                     tryCatch({
[10:22:07.049]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:07.049]                     }, error = function(ex) {
[10:22:07.049]                       msg <- conditionMessage(ex)
[10:22:07.049]                       fi_tmp <- file.info(pathname_tmp)
[10:22:07.049]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:07.049]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:07.049]                         fi_tmp[["mtime"]], msg)
[10:22:07.049]                       ex$message <- msg
[10:22:07.049]                       stop(ex)
[10:22:07.049]                     })
[10:22:07.049]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:07.049]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:07.049]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:07.049]                       fi_tmp <- file.info(pathname_tmp)
[10:22:07.049]                       fi <- file.info(pathname)
[10:22:07.049]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:07.049]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:07.049]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:07.049]                         fi[["size"]], fi[["mtime"]])
[10:22:07.049]                       stop(msg)
[10:22:07.049]                     }
[10:22:07.049]                     invisible(pathname)
[10:22:07.049]                   }
[10:22:07.049]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:07.049]                     rootPath = tempdir()) 
[10:22:07.049]                   {
[10:22:07.049]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:07.049]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:07.049]                       tmpdir = path, fileext = ".rds")
[10:22:07.049]                     save_rds(obj, file)
[10:22:07.049]                   }
[10:22:07.049]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4kEgVJ/.future/immediateConditions")
[10:22:07.049]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:07.049]                   {
[10:22:07.049]                     inherits <- base::inherits
[10:22:07.049]                     invokeRestart <- base::invokeRestart
[10:22:07.049]                     is.null <- base::is.null
[10:22:07.049]                     muffled <- FALSE
[10:22:07.049]                     if (inherits(cond, "message")) {
[10:22:07.049]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:07.049]                       if (muffled) 
[10:22:07.049]                         invokeRestart("muffleMessage")
[10:22:07.049]                     }
[10:22:07.049]                     else if (inherits(cond, "warning")) {
[10:22:07.049]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:07.049]                       if (muffled) 
[10:22:07.049]                         invokeRestart("muffleWarning")
[10:22:07.049]                     }
[10:22:07.049]                     else if (inherits(cond, "condition")) {
[10:22:07.049]                       if (!is.null(pattern)) {
[10:22:07.049]                         computeRestarts <- base::computeRestarts
[10:22:07.049]                         grepl <- base::grepl
[10:22:07.049]                         restarts <- computeRestarts(cond)
[10:22:07.049]                         for (restart in restarts) {
[10:22:07.049]                           name <- restart$name
[10:22:07.049]                           if (is.null(name)) 
[10:22:07.049]                             next
[10:22:07.049]                           if (!grepl(pattern, name)) 
[10:22:07.049]                             next
[10:22:07.049]                           invokeRestart(restart)
[10:22:07.049]                           muffled <- TRUE
[10:22:07.049]                           break
[10:22:07.049]                         }
[10:22:07.049]                       }
[10:22:07.049]                     }
[10:22:07.049]                     invisible(muffled)
[10:22:07.049]                   }
[10:22:07.049]                   muffleCondition(cond)
[10:22:07.049]                 })
[10:22:07.049]             }))
[10:22:07.049]             future::FutureResult(value = ...future.value$value, 
[10:22:07.049]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:07.049]                   ...future.rng), globalenv = if (FALSE) 
[10:22:07.049]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:07.049]                     ...future.globalenv.names))
[10:22:07.049]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:07.049]         }, condition = base::local({
[10:22:07.049]             c <- base::c
[10:22:07.049]             inherits <- base::inherits
[10:22:07.049]             invokeRestart <- base::invokeRestart
[10:22:07.049]             length <- base::length
[10:22:07.049]             list <- base::list
[10:22:07.049]             seq.int <- base::seq.int
[10:22:07.049]             signalCondition <- base::signalCondition
[10:22:07.049]             sys.calls <- base::sys.calls
[10:22:07.049]             `[[` <- base::`[[`
[10:22:07.049]             `+` <- base::`+`
[10:22:07.049]             `<<-` <- base::`<<-`
[10:22:07.049]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:07.049]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:07.049]                   3L)]
[10:22:07.049]             }
[10:22:07.049]             function(cond) {
[10:22:07.049]                 is_error <- inherits(cond, "error")
[10:22:07.049]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:07.049]                   NULL)
[10:22:07.049]                 if (is_error) {
[10:22:07.049]                   sessionInformation <- function() {
[10:22:07.049]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:07.049]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:07.049]                       search = base::search(), system = base::Sys.info())
[10:22:07.049]                   }
[10:22:07.049]                   ...future.conditions[[length(...future.conditions) + 
[10:22:07.049]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:07.049]                     cond$call), session = sessionInformation(), 
[10:22:07.049]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:07.049]                   signalCondition(cond)
[10:22:07.049]                 }
[10:22:07.049]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:07.049]                 "immediateCondition"))) {
[10:22:07.049]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:07.049]                   ...future.conditions[[length(...future.conditions) + 
[10:22:07.049]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:07.049]                   if (TRUE && !signal) {
[10:22:07.049]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:07.049]                     {
[10:22:07.049]                       inherits <- base::inherits
[10:22:07.049]                       invokeRestart <- base::invokeRestart
[10:22:07.049]                       is.null <- base::is.null
[10:22:07.049]                       muffled <- FALSE
[10:22:07.049]                       if (inherits(cond, "message")) {
[10:22:07.049]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:07.049]                         if (muffled) 
[10:22:07.049]                           invokeRestart("muffleMessage")
[10:22:07.049]                       }
[10:22:07.049]                       else if (inherits(cond, "warning")) {
[10:22:07.049]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:07.049]                         if (muffled) 
[10:22:07.049]                           invokeRestart("muffleWarning")
[10:22:07.049]                       }
[10:22:07.049]                       else if (inherits(cond, "condition")) {
[10:22:07.049]                         if (!is.null(pattern)) {
[10:22:07.049]                           computeRestarts <- base::computeRestarts
[10:22:07.049]                           grepl <- base::grepl
[10:22:07.049]                           restarts <- computeRestarts(cond)
[10:22:07.049]                           for (restart in restarts) {
[10:22:07.049]                             name <- restart$name
[10:22:07.049]                             if (is.null(name)) 
[10:22:07.049]                               next
[10:22:07.049]                             if (!grepl(pattern, name)) 
[10:22:07.049]                               next
[10:22:07.049]                             invokeRestart(restart)
[10:22:07.049]                             muffled <- TRUE
[10:22:07.049]                             break
[10:22:07.049]                           }
[10:22:07.049]                         }
[10:22:07.049]                       }
[10:22:07.049]                       invisible(muffled)
[10:22:07.049]                     }
[10:22:07.049]                     muffleCondition(cond, pattern = "^muffle")
[10:22:07.049]                   }
[10:22:07.049]                 }
[10:22:07.049]                 else {
[10:22:07.049]                   if (TRUE) {
[10:22:07.049]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:07.049]                     {
[10:22:07.049]                       inherits <- base::inherits
[10:22:07.049]                       invokeRestart <- base::invokeRestart
[10:22:07.049]                       is.null <- base::is.null
[10:22:07.049]                       muffled <- FALSE
[10:22:07.049]                       if (inherits(cond, "message")) {
[10:22:07.049]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:07.049]                         if (muffled) 
[10:22:07.049]                           invokeRestart("muffleMessage")
[10:22:07.049]                       }
[10:22:07.049]                       else if (inherits(cond, "warning")) {
[10:22:07.049]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:07.049]                         if (muffled) 
[10:22:07.049]                           invokeRestart("muffleWarning")
[10:22:07.049]                       }
[10:22:07.049]                       else if (inherits(cond, "condition")) {
[10:22:07.049]                         if (!is.null(pattern)) {
[10:22:07.049]                           computeRestarts <- base::computeRestarts
[10:22:07.049]                           grepl <- base::grepl
[10:22:07.049]                           restarts <- computeRestarts(cond)
[10:22:07.049]                           for (restart in restarts) {
[10:22:07.049]                             name <- restart$name
[10:22:07.049]                             if (is.null(name)) 
[10:22:07.049]                               next
[10:22:07.049]                             if (!grepl(pattern, name)) 
[10:22:07.049]                               next
[10:22:07.049]                             invokeRestart(restart)
[10:22:07.049]                             muffled <- TRUE
[10:22:07.049]                             break
[10:22:07.049]                           }
[10:22:07.049]                         }
[10:22:07.049]                       }
[10:22:07.049]                       invisible(muffled)
[10:22:07.049]                     }
[10:22:07.049]                     muffleCondition(cond, pattern = "^muffle")
[10:22:07.049]                   }
[10:22:07.049]                 }
[10:22:07.049]             }
[10:22:07.049]         }))
[10:22:07.049]     }, error = function(ex) {
[10:22:07.049]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:07.049]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:07.049]                 ...future.rng), started = ...future.startTime, 
[10:22:07.049]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:07.049]             version = "1.8"), class = "FutureResult")
[10:22:07.049]     }, finally = {
[10:22:07.049]         if (!identical(...future.workdir, getwd())) 
[10:22:07.049]             setwd(...future.workdir)
[10:22:07.049]         {
[10:22:07.049]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:07.049]                 ...future.oldOptions$nwarnings <- NULL
[10:22:07.049]             }
[10:22:07.049]             base::options(...future.oldOptions)
[10:22:07.049]             if (.Platform$OS.type == "windows") {
[10:22:07.049]                 old_names <- names(...future.oldEnvVars)
[10:22:07.049]                 envs <- base::Sys.getenv()
[10:22:07.049]                 names <- names(envs)
[10:22:07.049]                 common <- intersect(names, old_names)
[10:22:07.049]                 added <- setdiff(names, old_names)
[10:22:07.049]                 removed <- setdiff(old_names, names)
[10:22:07.049]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:07.049]                   envs[common]]
[10:22:07.049]                 NAMES <- toupper(changed)
[10:22:07.049]                 args <- list()
[10:22:07.049]                 for (kk in seq_along(NAMES)) {
[10:22:07.049]                   name <- changed[[kk]]
[10:22:07.049]                   NAME <- NAMES[[kk]]
[10:22:07.049]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:07.049]                     next
[10:22:07.049]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:07.049]                 }
[10:22:07.049]                 NAMES <- toupper(added)
[10:22:07.049]                 for (kk in seq_along(NAMES)) {
[10:22:07.049]                   name <- added[[kk]]
[10:22:07.049]                   NAME <- NAMES[[kk]]
[10:22:07.049]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:07.049]                     next
[10:22:07.049]                   args[[name]] <- ""
[10:22:07.049]                 }
[10:22:07.049]                 NAMES <- toupper(removed)
[10:22:07.049]                 for (kk in seq_along(NAMES)) {
[10:22:07.049]                   name <- removed[[kk]]
[10:22:07.049]                   NAME <- NAMES[[kk]]
[10:22:07.049]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:07.049]                     next
[10:22:07.049]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:07.049]                 }
[10:22:07.049]                 if (length(args) > 0) 
[10:22:07.049]                   base::do.call(base::Sys.setenv, args = args)
[10:22:07.049]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:07.049]             }
[10:22:07.049]             else {
[10:22:07.049]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:07.049]             }
[10:22:07.049]             {
[10:22:07.049]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:07.049]                   0L) {
[10:22:07.049]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:07.049]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:07.049]                   base::options(opts)
[10:22:07.049]                 }
[10:22:07.049]                 {
[10:22:07.049]                   {
[10:22:07.049]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:07.049]                     NULL
[10:22:07.049]                   }
[10:22:07.049]                   options(future.plan = NULL)
[10:22:07.049]                   if (is.na(NA_character_)) 
[10:22:07.049]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:07.049]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:07.049]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:07.049]                     .init = FALSE)
[10:22:07.049]                 }
[10:22:07.049]             }
[10:22:07.049]         }
[10:22:07.049]     })
[10:22:07.049]     if (TRUE) {
[10:22:07.049]         base::sink(type = "output", split = FALSE)
[10:22:07.049]         if (TRUE) {
[10:22:07.049]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:07.049]         }
[10:22:07.049]         else {
[10:22:07.049]             ...future.result["stdout"] <- base::list(NULL)
[10:22:07.049]         }
[10:22:07.049]         base::close(...future.stdout)
[10:22:07.049]         ...future.stdout <- NULL
[10:22:07.049]     }
[10:22:07.049]     ...future.result$conditions <- ...future.conditions
[10:22:07.049]     ...future.result$finished <- base::Sys.time()
[10:22:07.049]     ...future.result
[10:22:07.049] }
[10:22:07.083]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.053] assign_globals() ...
[10:22:07.083]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.053] List of 1
[10:22:07.053]  $ data:'data.frame':	3 obs. of  2 variables:
[10:22:07.053]   ..$ a: int [1:3] 1 2 3
[10:22:07.053]   ..$ b: int [1:3] 3 2 1
[10:22:07.053]  - attr(*, "where")=List of 1
[10:22:07.053]   ..$ data:<environment: R_EmptyEnv> 
[10:22:07.053]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:07.053]  - attr(*, "resolved")= logi FALSE
[10:22:07.053]  - attr(*, "total_size")= num 356
[10:22:07.053]  - attr(*, "already-done")= logi TRUE
[10:22:07.083]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.059] - copied ‘data’ to environment
[10:22:07.083]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.059] assign_globals() ... done
[10:22:07.083]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.059] requestCore(): workers = 2
[10:22:07.083]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.062] MulticoreFuture started
[10:22:07.084]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.062] - Launch lazy future ... done
[10:22:07.084]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.062] run() for ‘MulticoreFuture’ ... done
[10:22:07.084]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.063] result() for MulticoreFuture ...
[10:22:07.084]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.070] result() for MulticoreFuture ...
[10:22:07.084]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.071] result() for MulticoreFuture ... done
[10:22:07.084]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.071] result() for MulticoreFuture ... done
[10:22:07.084]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.071] result() for MulticoreFuture ...
[10:22:07.085]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.071] result() for MulticoreFuture ... done
[10:22:07.085] signalConditions() ... done
- plan(list('sequential', 'multicore')) ... DONE
- plan(list('sequential', 'multisession')) ...
[10:22:07.085] plan(): Setting new future strategy stack:
[10:22:07.085] List of future strategies:
[10:22:07.085] 1. sequential:
[10:22:07.085]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:07.085]    - tweaked: FALSE
[10:22:07.085]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:07.085] 2. multisession:
[10:22:07.085]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:22:07.085]    - tweaked: FALSE
[10:22:07.085]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:07.086] plan(): nbrOfWorkers() = 1
[10:22:07.086] getGlobalsAndPackages() ...
[10:22:07.087] Searching for globals...
[10:22:07.106] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[10:22:07.108] Searching for globals ... DONE
[10:22:07.108] Resolving globals: FALSE
[10:22:07.109] The total size of the 2 globals is 7.45 KiB (7631 bytes)
[10:22:07.109] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 7.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (7.40 KiB of class ‘list’) and ‘strategy2’ (51 bytes of class ‘character’)
[10:22:07.109] - globals: [2] ‘nested’, ‘strategy2’
[10:22:07.109] - packages: [1] ‘future’
[10:22:07.109] getGlobalsAndPackages() ... DONE
[10:22:07.110] run() for ‘Future’ ...
[10:22:07.110] - state: ‘created’
[10:22:07.110] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:07.110] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:07.110] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:07.110]   - Field: ‘label’
[10:22:07.111]   - Field: ‘local’
[10:22:07.111]   - Field: ‘owner’
[10:22:07.111]   - Field: ‘envir’
[10:22:07.111]   - Field: ‘packages’
[10:22:07.111]   - Field: ‘gc’
[10:22:07.111]   - Field: ‘conditions’
[10:22:07.111]   - Field: ‘expr’
[10:22:07.111]   - Field: ‘uuid’
[10:22:07.111]   - Field: ‘seed’
[10:22:07.111]   - Field: ‘version’
[10:22:07.111]   - Field: ‘result’
[10:22:07.111]   - Field: ‘asynchronous’
[10:22:07.112]   - Field: ‘calls’
[10:22:07.112]   - Field: ‘globals’
[10:22:07.112]   - Field: ‘stdout’
[10:22:07.112]   - Field: ‘earlySignal’
[10:22:07.112]   - Field: ‘lazy’
[10:22:07.112]   - Field: ‘state’
[10:22:07.112] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:07.112] - Launch lazy future ...
[10:22:07.112] Packages needed by the future expression (n = 1): ‘future’
[10:22:07.112] Packages needed by future strategies (n = 1): ‘future’
[10:22:07.113] {
[10:22:07.113]     {
[10:22:07.113]         {
[10:22:07.113]             ...future.startTime <- base::Sys.time()
[10:22:07.113]             {
[10:22:07.113]                 {
[10:22:07.113]                   {
[10:22:07.113]                     {
[10:22:07.113]                       base::local({
[10:22:07.113]                         has_future <- base::requireNamespace("future", 
[10:22:07.113]                           quietly = TRUE)
[10:22:07.113]                         if (has_future) {
[10:22:07.113]                           ns <- base::getNamespace("future")
[10:22:07.113]                           version <- ns[[".package"]][["version"]]
[10:22:07.113]                           if (is.null(version)) 
[10:22:07.113]                             version <- utils::packageVersion("future")
[10:22:07.113]                         }
[10:22:07.113]                         else {
[10:22:07.113]                           version <- NULL
[10:22:07.113]                         }
[10:22:07.113]                         if (!has_future || version < "1.8.0") {
[10:22:07.113]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:07.113]                             "", base::R.version$version.string), 
[10:22:07.113]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:07.113]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:07.113]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:07.113]                               "release", "version")], collapse = " "), 
[10:22:07.113]                             hostname = base::Sys.info()[["nodename"]])
[10:22:07.113]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:07.113]                             info)
[10:22:07.113]                           info <- base::paste(info, collapse = "; ")
[10:22:07.113]                           if (!has_future) {
[10:22:07.113]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:07.113]                               info)
[10:22:07.113]                           }
[10:22:07.113]                           else {
[10:22:07.113]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:07.113]                               info, version)
[10:22:07.113]                           }
[10:22:07.113]                           base::stop(msg)
[10:22:07.113]                         }
[10:22:07.113]                       })
[10:22:07.113]                     }
[10:22:07.113]                     base::local({
[10:22:07.113]                       for (pkg in "future") {
[10:22:07.113]                         base::loadNamespace(pkg)
[10:22:07.113]                         base::library(pkg, character.only = TRUE)
[10:22:07.113]                       }
[10:22:07.113]                     })
[10:22:07.113]                   }
[10:22:07.113]                   ...future.strategy.old <- future::plan("list")
[10:22:07.113]                   options(future.plan = NULL)
[10:22:07.113]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:07.113]                   future::plan(list(b = function (..., workers = availableCores(), 
[10:22:07.113]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:07.113]                     envir = parent.frame()) 
[10:22:07.113]                   {
[10:22:07.113]                     if (is.function(workers)) 
[10:22:07.113]                       workers <- workers()
[10:22:07.113]                     workers <- structure(as.integer(workers), 
[10:22:07.113]                       class = class(workers))
[10:22:07.113]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:07.113]                       workers >= 1)
[10:22:07.113]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:07.113]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:07.113]                     }
[10:22:07.113]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:07.113]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:07.113]                       envir = envir)
[10:22:07.113]                     if (!future$lazy) 
[10:22:07.113]                       future <- run(future)
[10:22:07.113]                     invisible(future)
[10:22:07.113]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:07.113]                 }
[10:22:07.113]                 ...future.workdir <- getwd()
[10:22:07.113]             }
[10:22:07.113]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:07.113]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:07.113]         }
[10:22:07.113]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:07.113]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:07.113]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:07.113]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:07.113]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:07.113]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:07.113]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:07.113]             base::names(...future.oldOptions))
[10:22:07.113]     }
[10:22:07.113]     if (FALSE) {
[10:22:07.113]     }
[10:22:07.113]     else {
[10:22:07.113]         if (TRUE) {
[10:22:07.113]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:07.113]                 open = "w")
[10:22:07.113]         }
[10:22:07.113]         else {
[10:22:07.113]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:07.113]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:07.113]         }
[10:22:07.113]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:07.113]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:07.113]             base::sink(type = "output", split = FALSE)
[10:22:07.113]             base::close(...future.stdout)
[10:22:07.113]         }, add = TRUE)
[10:22:07.113]     }
[10:22:07.113]     ...future.frame <- base::sys.nframe()
[10:22:07.113]     ...future.conditions <- base::list()
[10:22:07.113]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:07.113]     if (FALSE) {
[10:22:07.113]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:07.113]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:07.113]     }
[10:22:07.113]     ...future.result <- base::tryCatch({
[10:22:07.113]         base::withCallingHandlers({
[10:22:07.113]             ...future.value <- base::withVisible(base::local({
[10:22:07.113]                 a <- 1L
[10:22:07.113]                 plan_a <- unclass(future::plan("list"))
[10:22:07.113]                 nested_a <- nested[-1]
[10:22:07.113]                 stopifnot(length(nested_a) == 1L, length(plan_a) == 
[10:22:07.113]                   1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[10:22:07.113]                   strategy2))
[10:22:07.113]                 for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[10:22:07.113]                   "init") <- NULL
[10:22:07.113]                 for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[10:22:07.113]                   "init") <- NULL
[10:22:07.113]                 stopifnot(all.equal(plan_a, nested_a))
[10:22:07.113]                 y %<-% {
[10:22:07.113]                   b <- 2L
[10:22:07.113]                   plan_b <- future::plan("list")
[10:22:07.113]                   nested_b <- nested_a[-1]
[10:22:07.113]                   stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:22:07.113]                     1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[10:22:07.113]                     "sequential"))
[10:22:07.113]                   list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:22:07.113]                     b = b, nested_b = nested_b, plan_b = plan_b)
[10:22:07.113]                 }
[10:22:07.113]                 y
[10:22:07.113]             }))
[10:22:07.113]             future::FutureResult(value = ...future.value$value, 
[10:22:07.113]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:07.113]                   ...future.rng), globalenv = if (FALSE) 
[10:22:07.113]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:07.113]                     ...future.globalenv.names))
[10:22:07.113]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:07.113]         }, condition = base::local({
[10:22:07.113]             c <- base::c
[10:22:07.113]             inherits <- base::inherits
[10:22:07.113]             invokeRestart <- base::invokeRestart
[10:22:07.113]             length <- base::length
[10:22:07.113]             list <- base::list
[10:22:07.113]             seq.int <- base::seq.int
[10:22:07.113]             signalCondition <- base::signalCondition
[10:22:07.113]             sys.calls <- base::sys.calls
[10:22:07.113]             `[[` <- base::`[[`
[10:22:07.113]             `+` <- base::`+`
[10:22:07.113]             `<<-` <- base::`<<-`
[10:22:07.113]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:07.113]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:07.113]                   3L)]
[10:22:07.113]             }
[10:22:07.113]             function(cond) {
[10:22:07.113]                 is_error <- inherits(cond, "error")
[10:22:07.113]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:07.113]                   NULL)
[10:22:07.113]                 if (is_error) {
[10:22:07.113]                   sessionInformation <- function() {
[10:22:07.113]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:07.113]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:07.113]                       search = base::search(), system = base::Sys.info())
[10:22:07.113]                   }
[10:22:07.113]                   ...future.conditions[[length(...future.conditions) + 
[10:22:07.113]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:07.113]                     cond$call), session = sessionInformation(), 
[10:22:07.113]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:07.113]                   signalCondition(cond)
[10:22:07.113]                 }
[10:22:07.113]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:07.113]                 "immediateCondition"))) {
[10:22:07.113]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:07.113]                   ...future.conditions[[length(...future.conditions) + 
[10:22:07.113]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:07.113]                   if (TRUE && !signal) {
[10:22:07.113]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:07.113]                     {
[10:22:07.113]                       inherits <- base::inherits
[10:22:07.113]                       invokeRestart <- base::invokeRestart
[10:22:07.113]                       is.null <- base::is.null
[10:22:07.113]                       muffled <- FALSE
[10:22:07.113]                       if (inherits(cond, "message")) {
[10:22:07.113]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:07.113]                         if (muffled) 
[10:22:07.113]                           invokeRestart("muffleMessage")
[10:22:07.113]                       }
[10:22:07.113]                       else if (inherits(cond, "warning")) {
[10:22:07.113]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:07.113]                         if (muffled) 
[10:22:07.113]                           invokeRestart("muffleWarning")
[10:22:07.113]                       }
[10:22:07.113]                       else if (inherits(cond, "condition")) {
[10:22:07.113]                         if (!is.null(pattern)) {
[10:22:07.113]                           computeRestarts <- base::computeRestarts
[10:22:07.113]                           grepl <- base::grepl
[10:22:07.113]                           restarts <- computeRestarts(cond)
[10:22:07.113]                           for (restart in restarts) {
[10:22:07.113]                             name <- restart$name
[10:22:07.113]                             if (is.null(name)) 
[10:22:07.113]                               next
[10:22:07.113]                             if (!grepl(pattern, name)) 
[10:22:07.113]                               next
[10:22:07.113]                             invokeRestart(restart)
[10:22:07.113]                             muffled <- TRUE
[10:22:07.113]                             break
[10:22:07.113]                           }
[10:22:07.113]                         }
[10:22:07.113]                       }
[10:22:07.113]                       invisible(muffled)
[10:22:07.113]                     }
[10:22:07.113]                     muffleCondition(cond, pattern = "^muffle")
[10:22:07.113]                   }
[10:22:07.113]                 }
[10:22:07.113]                 else {
[10:22:07.113]                   if (TRUE) {
[10:22:07.113]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:07.113]                     {
[10:22:07.113]                       inherits <- base::inherits
[10:22:07.113]                       invokeRestart <- base::invokeRestart
[10:22:07.113]                       is.null <- base::is.null
[10:22:07.113]                       muffled <- FALSE
[10:22:07.113]                       if (inherits(cond, "message")) {
[10:22:07.113]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:07.113]                         if (muffled) 
[10:22:07.113]                           invokeRestart("muffleMessage")
[10:22:07.113]                       }
[10:22:07.113]                       else if (inherits(cond, "warning")) {
[10:22:07.113]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:07.113]                         if (muffled) 
[10:22:07.113]                           invokeRestart("muffleWarning")
[10:22:07.113]                       }
[10:22:07.113]                       else if (inherits(cond, "condition")) {
[10:22:07.113]                         if (!is.null(pattern)) {
[10:22:07.113]                           computeRestarts <- base::computeRestarts
[10:22:07.113]                           grepl <- base::grepl
[10:22:07.113]                           restarts <- computeRestarts(cond)
[10:22:07.113]                           for (restart in restarts) {
[10:22:07.113]                             name <- restart$name
[10:22:07.113]                             if (is.null(name)) 
[10:22:07.113]                               next
[10:22:07.113]                             if (!grepl(pattern, name)) 
[10:22:07.113]                               next
[10:22:07.113]                             invokeRestart(restart)
[10:22:07.113]                             muffled <- TRUE
[10:22:07.113]                             break
[10:22:07.113]                           }
[10:22:07.113]                         }
[10:22:07.113]                       }
[10:22:07.113]                       invisible(muffled)
[10:22:07.113]                     }
[10:22:07.113]                     muffleCondition(cond, pattern = "^muffle")
[10:22:07.113]                   }
[10:22:07.113]                 }
[10:22:07.113]             }
[10:22:07.113]         }))
[10:22:07.113]     }, error = function(ex) {
[10:22:07.113]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:07.113]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:07.113]                 ...future.rng), started = ...future.startTime, 
[10:22:07.113]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:07.113]             version = "1.8"), class = "FutureResult")
[10:22:07.113]     }, finally = {
[10:22:07.113]         if (!identical(...future.workdir, getwd())) 
[10:22:07.113]             setwd(...future.workdir)
[10:22:07.113]         {
[10:22:07.113]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:07.113]                 ...future.oldOptions$nwarnings <- NULL
[10:22:07.113]             }
[10:22:07.113]             base::options(...future.oldOptions)
[10:22:07.113]             if (.Platform$OS.type == "windows") {
[10:22:07.113]                 old_names <- names(...future.oldEnvVars)
[10:22:07.113]                 envs <- base::Sys.getenv()
[10:22:07.113]                 names <- names(envs)
[10:22:07.113]                 common <- intersect(names, old_names)
[10:22:07.113]                 added <- setdiff(names, old_names)
[10:22:07.113]                 removed <- setdiff(old_names, names)
[10:22:07.113]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:07.113]                   envs[common]]
[10:22:07.113]                 NAMES <- toupper(changed)
[10:22:07.113]                 args <- list()
[10:22:07.113]                 for (kk in seq_along(NAMES)) {
[10:22:07.113]                   name <- changed[[kk]]
[10:22:07.113]                   NAME <- NAMES[[kk]]
[10:22:07.113]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:07.113]                     next
[10:22:07.113]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:07.113]                 }
[10:22:07.113]                 NAMES <- toupper(added)
[10:22:07.113]                 for (kk in seq_along(NAMES)) {
[10:22:07.113]                   name <- added[[kk]]
[10:22:07.113]                   NAME <- NAMES[[kk]]
[10:22:07.113]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:07.113]                     next
[10:22:07.113]                   args[[name]] <- ""
[10:22:07.113]                 }
[10:22:07.113]                 NAMES <- toupper(removed)
[10:22:07.113]                 for (kk in seq_along(NAMES)) {
[10:22:07.113]                   name <- removed[[kk]]
[10:22:07.113]                   NAME <- NAMES[[kk]]
[10:22:07.113]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:07.113]                     next
[10:22:07.113]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:07.113]                 }
[10:22:07.113]                 if (length(args) > 0) 
[10:22:07.113]                   base::do.call(base::Sys.setenv, args = args)
[10:22:07.113]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:07.113]             }
[10:22:07.113]             else {
[10:22:07.113]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:07.113]             }
[10:22:07.113]             {
[10:22:07.113]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:07.113]                   0L) {
[10:22:07.113]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:07.113]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:07.113]                   base::options(opts)
[10:22:07.113]                 }
[10:22:07.113]                 {
[10:22:07.113]                   {
[10:22:07.113]                     NULL
[10:22:07.113]                     RNGkind("Mersenne-Twister")
[10:22:07.113]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:07.113]                       inherits = FALSE)
[10:22:07.113]                   }
[10:22:07.113]                   options(future.plan = NULL)
[10:22:07.113]                   if (is.na(NA_character_)) 
[10:22:07.113]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:07.113]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:07.113]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:07.113]                     .init = FALSE)
[10:22:07.113]                 }
[10:22:07.113]             }
[10:22:07.113]         }
[10:22:07.113]     })
[10:22:07.113]     if (TRUE) {
[10:22:07.113]         base::sink(type = "output", split = FALSE)
[10:22:07.113]         if (TRUE) {
[10:22:07.113]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:07.113]         }
[10:22:07.113]         else {
[10:22:07.113]             ...future.result["stdout"] <- base::list(NULL)
[10:22:07.113]         }
[10:22:07.113]         base::close(...future.stdout)
[10:22:07.113]         ...future.stdout <- NULL
[10:22:07.113]     }
[10:22:07.113]     ...future.result$conditions <- ...future.conditions
[10:22:07.113]     ...future.result$finished <- base::Sys.time()
[10:22:07.113]     ...future.result
[10:22:07.113] }
[10:22:07.115] assign_globals() ...
[10:22:07.115] List of 2
[10:22:07.115]  $ nested   :List of 2
[10:22:07.115]   ..$ a:function (..., envir = parent.frame())  
[10:22:07.115]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[10:22:07.115]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:22:07.115]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:07.115]     envir = parent.frame())  
[10:22:07.115]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[10:22:07.115]   .. ..- attr(*, "init")= logi TRUE
[10:22:07.115]   .. ..- attr(*, "cleanup")=function ()  
[10:22:07.115]   .. ..- attr(*, "untweakable")= chr "persistent"
[10:22:07.115]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:22:07.115]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:22:07.115]  $ strategy2: chr "multisession"
[10:22:07.115]  - attr(*, "where")=List of 2
[10:22:07.115]   ..$ nested   :<environment: R_EmptyEnv> 
[10:22:07.115]   ..$ strategy2:<environment: R_EmptyEnv> 
[10:22:07.115]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:07.115]  - attr(*, "resolved")= logi FALSE
[10:22:07.115]  - attr(*, "total_size")= num 7631
[10:22:07.115]  - attr(*, "already-done")= logi TRUE
[10:22:07.120] - copied ‘nested’ to environment
[10:22:07.120] - copied ‘strategy2’ to environment
[10:22:07.121] assign_globals() ... done
[10:22:07.121] plan(): Setting new future strategy stack:
[10:22:07.121] List of future strategies:
[10:22:07.121] 1. multisession:
[10:22:07.121]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:22:07.121]    - tweaked: FALSE
[10:22:07.121]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:07.123] plan(): nbrOfWorkers() = 2
[10:22:07.796] plan(): Setting new future strategy stack:
[10:22:07.796] List of future strategies:
[10:22:07.796] 1. sequential:
[10:22:07.796]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:07.796]    - tweaked: FALSE
[10:22:07.796]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:07.796] 2. multisession:
[10:22:07.796]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:22:07.796]    - tweaked: FALSE
[10:22:07.796]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:07.797] plan(): nbrOfWorkers() = 1
[10:22:07.797] SequentialFuture started (and completed)
[10:22:07.797] signalConditions() ...
[10:22:07.798]  - include = ‘immediateCondition’
[10:22:07.798]  - exclude = 
[10:22:07.798]  - resignal = FALSE
[10:22:07.798]  - Number of conditions: 67
[10:22:07.798] signalConditions() ... done
[10:22:07.798] - Launch lazy future ... done
[10:22:07.798] run() for ‘SequentialFuture’ ... done
[10:22:07.798] signalConditions() ...
[10:22:07.798]  - include = ‘immediateCondition’
[10:22:07.798]  - exclude = 
[10:22:07.799]  - resignal = FALSE
[10:22:07.799]  - Number of conditions: 67
[10:22:07.799] signalConditions() ... done
[10:22:07.799] Future state: ‘finished’
[10:22:07.799] signalConditions() ...
[10:22:07.799]  - include = ‘condition’
[10:22:07.799]  - exclude = ‘immediateCondition’
[10:22:07.799]  - resignal = TRUE
[10:22:07.799]  - Number of conditions: 67
[10:22:07.799]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.124] getGlobalsAndPackages() ...
[10:22:07.800]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.124] Searching for globals...
[10:22:07.800]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.142] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[10:22:07.800]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.142] Searching for globals ... DONE
[10:22:07.800]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.142] Resolving globals: FALSE
[10:22:07.800]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.143] The total size of the 3 globals is 11.81 KiB (12089 bytes)
[10:22:07.800]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.143] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 11.81 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (5.89 KiB of class ‘list’), ‘plan_a’ (5.89 KiB of class ‘list’) and ‘a’ (35 bytes of class ‘numeric’)
[10:22:07.800]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.143] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[10:22:07.800]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.143] 
[10:22:07.801]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.143] getGlobalsAndPackages() ... DONE
[10:22:07.801]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.144] run() for ‘Future’ ...
[10:22:07.801]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.144] - state: ‘created’
[10:22:07.801]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.144] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:07.801]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.625] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:07.801]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.626] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:07.801]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.626]   - Field: ‘node’
[10:22:07.801]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.626]   - Field: ‘label’
[10:22:07.802]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.626]   - Field: ‘local’
[10:22:07.802]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.626]   - Field: ‘owner’
[10:22:07.802]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.626]   - Field: ‘envir’
[10:22:07.802]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.626]   - Field: ‘workers’
[10:22:07.802]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.627]   - Field: ‘packages’
[10:22:07.802]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.627]   - Field: ‘gc’
[10:22:07.802]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.627]   - Field: ‘conditions’
[10:22:07.802]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.627]   - Field: ‘persistent’
[10:22:07.802]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.627]   - Field: ‘expr’
[10:22:07.803]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.627]   - Field: ‘uuid’
[10:22:07.803]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.627]   - Field: ‘seed’
[10:22:07.803]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.627]   - Field: ‘version’
[10:22:07.803]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.627]   - Field: ‘result’
[10:22:07.803]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.627]   - Field: ‘asynchronous’
[10:22:07.803]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.628]   - Field: ‘calls’
[10:22:07.803]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.628]   - Field: ‘globals’
[10:22:07.803]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.628]   - Field: ‘stdout’
[10:22:07.804]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.628]   - Field: ‘earlySignal’
[10:22:07.804]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.628]   - Field: ‘lazy’
[10:22:07.804]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.628]   - Field: ‘state’
[10:22:07.804]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.628] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:07.804]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.628] - Launch lazy future ...
[10:22:07.804]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.629] Packages needed by the future expression (n = 0): <none>
[10:22:07.804]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.629] Packages needed by future strategies (n = 0): <none>
[10:22:07.804]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.630] {
[10:22:07.630]     {
[10:22:07.630]         {
[10:22:07.630]             ...future.startTime <- base::Sys.time()
[10:22:07.630]             {
[10:22:07.630]                 {
[10:22:07.630]                   {
[10:22:07.630]                     {
[10:22:07.630]                       base::local({
[10:22:07.630]                         has_future <- base::requireNamespace("future", 
[10:22:07.630]                           quietly = TRUE)
[10:22:07.630]                         if (has_future) {
[10:22:07.630]                           ns <- base::getNamespace("future")
[10:22:07.630]                           version <- ns[[".package"]][["version"]]
[10:22:07.630]                           if (is.null(version)) 
[10:22:07.630]                             version <- utils::packageVersion("future")
[10:22:07.630]                         }
[10:22:07.630]                         else {
[10:22:07.630]                           version <- NULL
[10:22:07.630]                         }
[10:22:07.630]                         if (!has_future || version < "1.8.0") {
[10:22:07.630]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:07.630]                             "", base::R.version$version.string), 
[10:22:07.630]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:07.630]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:07.630]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:07.630]                               "release", "version")], collapse = " "), 
[10:22:07.630]                             hostname = base::Sys.info()[["nodename"]])
[10:22:07.630]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:07.630]                             info)
[10:22:07.630]                           info <- base::paste(info, collapse = "; ")
[10:22:07.630]                           if (!has_future) {
[10:22:07.630]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:07.630]                               info)
[10:22:07.630]                           }
[10:22:07.630]                           else {
[10:22:07.630]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:07.630]                               info, version)
[10:22:07.630]                           }
[10:22:07.630]                           base::stop(msg)
[10:22:07.630]                         }
[10:22:07.630]                       })
[10:22:07.630]                     }
[10:22:07.630]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:07.630]                     base::options(mc.cores = 1L)
[10:22:07.630]                   }
[10:22:07.630]                   ...future.strategy.old <- future::plan("list")
[10:22:07.630]                   options(future.plan = NULL)
[10:22:07.630]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:07.630]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:07.630]                 }
[10:22:07.630]                 ...future.workdir <- getwd()
[10:22:07.630]             }
[10:22:07.630]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:07.630]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:07.630]         }
[10:22:07.630]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:07.630]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:07.630]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:07.630]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:07.630]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:07.630]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:07.630]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:07.630]             base::names(...future.oldOptions))
[10:22:07.630]     }
[10:22:07.630]     if (FALSE) {
[10:22:07.630]     }
[10:22:07.630]     else {
[10:22:07.630]         if (TRUE) {
[10:22:07.630]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:07.630]                 open = "w")
[10:22:07.630]         }
[10:22:07.630]         else {
[10:22:07.630]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:07.630]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:07.630]         }
[10:22:07.630]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:07.630]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:07.630]             base::sink(type = "output", split = FALSE)
[10:22:07.630]             base::close(...future.stdout)
[10:22:07.630]         }, add = TRUE)
[10:22:07.630]     }
[10:22:07.630]     ...future.frame <- base::sys.nframe()
[10:22:07.630]     ...future.conditions <- base::list()
[10:22:07.630]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:07.630]     if (FALSE) {
[10:22:07.630]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:07.630]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:07.630]     }
[10:22:07.630]     ...future.result <- base::tryCatch({
[10:22:07.630]         base::withCallingHandlers({
[10:22:07.630]             ...future.value <- base::withVisible(base::local({
[10:22:07.630]                 ...future.makeSendCondition <- base::local({
[10:22:07.630]                   sendCondition <- NULL
[10:22:07.630]                   function(frame = 1L) {
[10:22:07.630]                     if (is.function(sendCondition)) 
[10:22:07.630]                       return(sendCondition)
[10:22:07.630]                     ns <- getNamespace("parallel")
[10:22:07.630]                     if (exists("sendData", mode = "function", 
[10:22:07.630]                       envir = ns)) {
[10:22:07.630]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:07.630]                         envir = ns)
[10:22:07.630]                       envir <- sys.frame(frame)
[10:22:07.630]                       master <- NULL
[10:22:07.630]                       while (!identical(envir, .GlobalEnv) && 
[10:22:07.630]                         !identical(envir, emptyenv())) {
[10:22:07.630]                         if (exists("master", mode = "list", envir = envir, 
[10:22:07.630]                           inherits = FALSE)) {
[10:22:07.630]                           master <- get("master", mode = "list", 
[10:22:07.630]                             envir = envir, inherits = FALSE)
[10:22:07.630]                           if (inherits(master, c("SOCKnode", 
[10:22:07.630]                             "SOCK0node"))) {
[10:22:07.630]                             sendCondition <<- function(cond) {
[10:22:07.630]                               data <- list(type = "VALUE", value = cond, 
[10:22:07.630]                                 success = TRUE)
[10:22:07.630]                               parallel_sendData(master, data)
[10:22:07.630]                             }
[10:22:07.630]                             return(sendCondition)
[10:22:07.630]                           }
[10:22:07.630]                         }
[10:22:07.630]                         frame <- frame + 1L
[10:22:07.630]                         envir <- sys.frame(frame)
[10:22:07.630]                       }
[10:22:07.630]                     }
[10:22:07.630]                     sendCondition <<- function(cond) NULL
[10:22:07.630]                   }
[10:22:07.630]                 })
[10:22:07.630]                 withCallingHandlers({
[10:22:07.630]                   {
[10:22:07.630]                     b <- 2L
[10:22:07.630]                     plan_b <- future::plan("list")
[10:22:07.630]                     nested_b <- nested_a[-1]
[10:22:07.630]                     stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:22:07.630]                       1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[10:22:07.630]                       "sequential"))
[10:22:07.630]                     list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:22:07.630]                       b = b, nested_b = nested_b, plan_b = plan_b)
[10:22:07.630]                   }
[10:22:07.630]                 }, immediateCondition = function(cond) {
[10:22:07.630]                   sendCondition <- ...future.makeSendCondition()
[10:22:07.630]                   sendCondition(cond)
[10:22:07.630]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:07.630]                   {
[10:22:07.630]                     inherits <- base::inherits
[10:22:07.630]                     invokeRestart <- base::invokeRestart
[10:22:07.630]                     is.null <- base::is.null
[10:22:07.630]                     muffled <- FALSE
[10:22:07.630]                     if (inherits(cond, "message")) {
[10:22:07.630]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:07.630]                       if (muffled) 
[10:22:07.630]                         invokeRestart("muffleMessage")
[10:22:07.630]                     }
[10:22:07.630]                     else if (inherits(cond, "warning")) {
[10:22:07.630]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:07.630]                       if (muffled) 
[10:22:07.630]                         invokeRestart("muffleWarning")
[10:22:07.630]                     }
[10:22:07.630]                     else if (inherits(cond, "condition")) {
[10:22:07.630]                       if (!is.null(pattern)) {
[10:22:07.630]                         computeRestarts <- base::computeRestarts
[10:22:07.630]                         grepl <- base::grepl
[10:22:07.630]                         restarts <- computeRestarts(cond)
[10:22:07.630]                         for (restart in restarts) {
[10:22:07.630]                           name <- restart$name
[10:22:07.630]                           if (is.null(name)) 
[10:22:07.630]                             next
[10:22:07.630]                           if (!grepl(pattern, name)) 
[10:22:07.630]                             next
[10:22:07.630]                           invokeRestart(restart)
[10:22:07.630]                           muffled <- TRUE
[10:22:07.630]                           break
[10:22:07.630]                         }
[10:22:07.630]                       }
[10:22:07.630]                     }
[10:22:07.630]                     invisible(muffled)
[10:22:07.630]                   }
[10:22:07.630]                   muffleCondition(cond)
[10:22:07.630]                 })
[10:22:07.630]             }))
[10:22:07.630]             future::FutureResult(value = ...future.value$value, 
[10:22:07.630]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:07.630]                   ...future.rng), globalenv = if (FALSE) 
[10:22:07.630]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:07.630]                     ...future.globalenv.names))
[10:22:07.630]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:07.630]         }, condition = base::local({
[10:22:07.630]             c <- base::c
[10:22:07.630]             inherits <- base::inherits
[10:22:07.630]             invokeRestart <- base::invokeRestart
[10:22:07.630]             length <- base::length
[10:22:07.630]             list <- base::list
[10:22:07.630]             seq.int <- base::seq.int
[10:22:07.630]             signalCondition <- base::signalCondition
[10:22:07.630]             sys.calls <- base::sys.calls
[10:22:07.630]             `[[` <- base::`[[`
[10:22:07.630]             `+` <- base::`+`
[10:22:07.630]             `<<-` <- base::`<<-`
[10:22:07.630]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:07.630]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:07.630]                   3L)]
[10:22:07.630]             }
[10:22:07.630]             function(cond) {
[10:22:07.630]                 is_error <- inherits(cond, "error")
[10:22:07.630]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:07.630]                   NULL)
[10:22:07.630]                 if (is_error) {
[10:22:07.630]                   sessionInformation <- function() {
[10:22:07.630]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:07.630]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:07.630]                       search = base::search(), system = base::Sys.info())
[10:22:07.630]                   }
[10:22:07.630]                   ...future.conditions[[length(...future.conditions) + 
[10:22:07.630]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:07.630]                     cond$call), session = sessionInformation(), 
[10:22:07.630]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:07.630]                   signalCondition(cond)
[10:22:07.630]                 }
[10:22:07.630]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:07.630]                 "immediateCondition"))) {
[10:22:07.630]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:07.630]                   ...future.conditions[[length(...future.conditions) + 
[10:22:07.630]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:07.630]                   if (TRUE && !signal) {
[10:22:07.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:07.630]                     {
[10:22:07.630]                       inherits <- base::inherits
[10:22:07.630]                       invokeRestart <- base::invokeRestart
[10:22:07.630]                       is.null <- base::is.null
[10:22:07.630]                       muffled <- FALSE
[10:22:07.630]                       if (inherits(cond, "message")) {
[10:22:07.630]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:07.630]                         if (muffled) 
[10:22:07.630]                           invokeRestart("muffleMessage")
[10:22:07.630]                       }
[10:22:07.630]                       else if (inherits(cond, "warning")) {
[10:22:07.630]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:07.630]                         if (muffled) 
[10:22:07.630]                           invokeRestart("muffleWarning")
[10:22:07.630]                       }
[10:22:07.630]                       else if (inherits(cond, "condition")) {
[10:22:07.630]                         if (!is.null(pattern)) {
[10:22:07.630]                           computeRestarts <- base::computeRestarts
[10:22:07.630]                           grepl <- base::grepl
[10:22:07.630]                           restarts <- computeRestarts(cond)
[10:22:07.630]                           for (restart in restarts) {
[10:22:07.630]                             name <- restart$name
[10:22:07.630]                             if (is.null(name)) 
[10:22:07.630]                               next
[10:22:07.630]                             if (!grepl(pattern, name)) 
[10:22:07.630]                               next
[10:22:07.630]                             invokeRestart(restart)
[10:22:07.630]                             muffled <- TRUE
[10:22:07.630]                             break
[10:22:07.630]                           }
[10:22:07.630]                         }
[10:22:07.630]                       }
[10:22:07.630]                       invisible(muffled)
[10:22:07.630]                     }
[10:22:07.630]                     muffleCondition(cond, pattern = "^muffle")
[10:22:07.630]                   }
[10:22:07.630]                 }
[10:22:07.630]                 else {
[10:22:07.630]                   if (TRUE) {
[10:22:07.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:07.630]                     {
[10:22:07.630]                       inherits <- base::inherits
[10:22:07.630]                       invokeRestart <- base::invokeRestart
[10:22:07.630]                       is.null <- base::is.null
[10:22:07.630]                       muffled <- FALSE
[10:22:07.630]                       if (inherits(cond, "message")) {
[10:22:07.630]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:07.630]                         if (muffled) 
[10:22:07.630]                           invokeRestart("muffleMessage")
[10:22:07.630]                       }
[10:22:07.630]                       else if (inherits(cond, "warning")) {
[10:22:07.630]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:07.630]                         if (muffled) 
[10:22:07.630]                           invokeRestart("muffleWarning")
[10:22:07.630]                       }
[10:22:07.630]                       else if (inherits(cond, "condition")) {
[10:22:07.630]                         if (!is.null(pattern)) {
[10:22:07.630]                           computeRestarts <- base::computeRestarts
[10:22:07.630]                           grepl <- base::grepl
[10:22:07.630]                           restarts <- computeRestarts(cond)
[10:22:07.630]                           for (restart in restarts) {
[10:22:07.630]                             name <- restart$name
[10:22:07.630]                             if (is.null(name)) 
[10:22:07.630]                               next
[10:22:07.630]                             if (!grepl(pattern, name)) 
[10:22:07.630]                               next
[10:22:07.630]                             invokeRestart(restart)
[10:22:07.630]                             muffled <- TRUE
[10:22:07.630]                             break
[10:22:07.630]                           }
[10:22:07.630]                         }
[10:22:07.630]                       }
[10:22:07.630]                       invisible(muffled)
[10:22:07.630]                     }
[10:22:07.630]                     muffleCondition(cond, pattern = "^muffle")
[10:22:07.630]                   }
[10:22:07.630]                 }
[10:22:07.630]             }
[10:22:07.630]         }))
[10:22:07.630]     }, error = function(ex) {
[10:22:07.630]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:07.630]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:07.630]                 ...future.rng), started = ...future.startTime, 
[10:22:07.630]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:07.630]             version = "1.8"), class = "FutureResult")
[10:22:07.630]     }, finally = {
[10:22:07.630]         if (!identical(...future.workdir, getwd())) 
[10:22:07.630]             setwd(...future.workdir)
[10:22:07.630]         {
[10:22:07.630]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:07.630]                 ...future.oldOptions$nwarnings <- NULL
[10:22:07.630]             }
[10:22:07.630]             base::options(...future.oldOptions)
[10:22:07.630]             if (.Platform$OS.type == "windows") {
[10:22:07.630]                 old_names <- names(...future.oldEnvVars)
[10:22:07.630]                 envs <- base::Sys.getenv()
[10:22:07.630]                 names <- names(envs)
[10:22:07.630]                 common <- intersect(names, old_names)
[10:22:07.630]                 added <- setdiff(names, old_names)
[10:22:07.630]                 removed <- setdiff(old_names, names)
[10:22:07.630]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:07.630]                   envs[common]]
[10:22:07.630]                 NAMES <- toupper(changed)
[10:22:07.630]                 args <- list()
[10:22:07.630]                 for (kk in seq_along(NAMES)) {
[10:22:07.630]                   name <- changed[[kk]]
[10:22:07.630]                   NAME <- NAMES[[kk]]
[10:22:07.630]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:07.630]                     next
[10:22:07.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:07.630]                 }
[10:22:07.630]                 NAMES <- toupper(added)
[10:22:07.630]                 for (kk in seq_along(NAMES)) {
[10:22:07.630]                   name <- added[[kk]]
[10:22:07.630]                   NAME <- NAMES[[kk]]
[10:22:07.630]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:07.630]                     next
[10:22:07.630]                   args[[name]] <- ""
[10:22:07.630]                 }
[10:22:07.630]                 NAMES <- toupper(removed)
[10:22:07.630]                 for (kk in seq_along(NAMES)) {
[10:22:07.630]                   name <- removed[[kk]]
[10:22:07.630]                   NAME <- NAMES[[kk]]
[10:22:07.630]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:07.630]                     next
[10:22:07.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:07.630]                 }
[10:22:07.630]                 if (length(args) > 0) 
[10:22:07.630]                   base::do.call(base::Sys.setenv, args = args)
[10:22:07.630]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:07.630]             }
[10:22:07.630]             else {
[10:22:07.630]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:07.630]             }
[10:22:07.630]             {
[10:22:07.630]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:07.630]                   0L) {
[10:22:07.630]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:07.630]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:07.630]                   base::options(opts)
[10:22:07.630]                 }
[10:22:07.630]                 {
[10:22:07.630]                   {
[10:22:07.630]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:07.630]                     NULL
[10:22:07.630]                   }
[10:22:07.630]                   options(future.plan = NULL)
[10:22:07.630]                   if (is.na(NA_character_)) 
[10:22:07.630]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:07.630]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:07.630]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:07.630]                     .init = FALSE)
[10:22:07.630]                 }
[10:22:07.630]             }
[10:22:07.630]         }
[10:22:07.630]     })
[10:22:07.630]     if (TRUE) {
[10:22:07.630]         base::sink(type = "output", split = FALSE)
[10:22:07.630]         if (TRUE) {
[10:22:07.630]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:07.630]         }
[10:22:07.630]         else {
[10:22:07.630]             ...future.result["stdout"] <- base::list(NULL)
[10:22:07.630]         }
[10:22:07.630]         base::close(...future.stdout)
[10:22:07.630]         ...future.stdout <- NULL
[10:22:07.630]     }
[10:22:07.630]     ...future.result$conditions <- ...future.conditions
[10:22:07.630]     ...future.result$finished <- base::Sys.time()
[10:22:07.630]     ...future.result
[10:22:07.630] }
[10:22:07.805]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.680] Exporting 3 global objects (11.47 KiB) to cluster node #1 ...
[10:22:07.805]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.680] Exporting ‘nested_a’ (5.89 KiB) to cluster node #1 ...
[10:22:07.805]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.681] Exporting ‘nested_a’ (5.89 KiB) to cluster node #1 ... DONE
[10:22:07.805]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.681] Exporting ‘a’ (35 bytes) to cluster node #1 ...
[10:22:07.805]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.681] Exporting ‘a’ (35 bytes) to cluster node #1 ... DONE
[10:22:07.805]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.681] Exporting ‘plan_a’ (5.89 KiB) to cluster node #1 ...
[10:22:07.806]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.722] Exporting ‘plan_a’ (5.89 KiB) to cluster node #1 ... DONE
[10:22:07.806]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.722] Exporting 3 global objects (11.47 KiB) to cluster node #1 ... DONE
[10:22:07.806]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.723] MultisessionFuture started
[10:22:07.806]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.723] - Launch lazy future ... done
[10:22:07.806]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.724] run() for ‘MultisessionFuture’ ... done
[10:22:07.806]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.724] result() for ClusterFuture ...
[10:22:07.806]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.724] receiveMessageFromWorker() for ClusterFuture ...
[10:22:07.806]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.724] - Validating connection of MultisessionFuture
[10:22:07.807]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.795] - received message: FutureResult
[10:22:07.807]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.795] - Received FutureResult
[10:22:07.807]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.795] - Erased future from FutureRegistry
[10:22:07.807]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.795] result() for ClusterFuture ...
[10:22:07.807]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.795] - result already collected: FutureResult
[10:22:07.807]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.795] result() for ClusterFuture ... done
[10:22:07.807]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.795] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:07.808]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.795] result() for ClusterFuture ... done
[10:22:07.808]  - Condition #65: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.796] result() for ClusterFuture ...
[10:22:07.808]  - Condition #66: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.796] - result already collected: FutureResult
[10:22:07.808]  - Condition #67: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.796] result() for ClusterFuture ... done
[10:22:07.808] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "cleanup")=function ()  
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "cleanup")=function ()  
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:22:07.815] getGlobalsAndPackages() ...
[10:22:07.815] Searching for globals...
[10:22:07.817] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[10:22:07.817] Searching for globals ... DONE
[10:22:07.817] Resolving globals: FALSE
[10:22:07.818] The total size of the 1 globals is 356 bytes (356 bytes)
[10:22:07.818] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[10:22:07.818] - globals: [1] ‘data’
[10:22:07.819] - packages: [1] ‘future’
[10:22:07.819] getGlobalsAndPackages() ... DONE
[10:22:07.819] run() for ‘Future’ ...
[10:22:07.819] - state: ‘created’
[10:22:07.819] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:07.820] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:07.820] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:07.820]   - Field: ‘label’
[10:22:07.820]   - Field: ‘local’
[10:22:07.820]   - Field: ‘owner’
[10:22:07.820]   - Field: ‘envir’
[10:22:07.820]   - Field: ‘packages’
[10:22:07.821]   - Field: ‘gc’
[10:22:07.821]   - Field: ‘conditions’
[10:22:07.821]   - Field: ‘expr’
[10:22:07.821]   - Field: ‘uuid’
[10:22:07.821]   - Field: ‘seed’
[10:22:07.821]   - Field: ‘version’
[10:22:07.821]   - Field: ‘result’
[10:22:07.821]   - Field: ‘asynchronous’
[10:22:07.821]   - Field: ‘calls’
[10:22:07.822]   - Field: ‘globals’
[10:22:07.822]   - Field: ‘stdout’
[10:22:07.822]   - Field: ‘earlySignal’
[10:22:07.822]   - Field: ‘lazy’
[10:22:07.822]   - Field: ‘state’
[10:22:07.822] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:07.822] - Launch lazy future ...
[10:22:07.822] Packages needed by the future expression (n = 1): ‘future’
[10:22:07.823] Packages needed by future strategies (n = 1): ‘future’
[10:22:07.823] {
[10:22:07.823]     {
[10:22:07.823]         {
[10:22:07.823]             ...future.startTime <- base::Sys.time()
[10:22:07.823]             {
[10:22:07.823]                 {
[10:22:07.823]                   {
[10:22:07.823]                     {
[10:22:07.823]                       base::local({
[10:22:07.823]                         has_future <- base::requireNamespace("future", 
[10:22:07.823]                           quietly = TRUE)
[10:22:07.823]                         if (has_future) {
[10:22:07.823]                           ns <- base::getNamespace("future")
[10:22:07.823]                           version <- ns[[".package"]][["version"]]
[10:22:07.823]                           if (is.null(version)) 
[10:22:07.823]                             version <- utils::packageVersion("future")
[10:22:07.823]                         }
[10:22:07.823]                         else {
[10:22:07.823]                           version <- NULL
[10:22:07.823]                         }
[10:22:07.823]                         if (!has_future || version < "1.8.0") {
[10:22:07.823]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:07.823]                             "", base::R.version$version.string), 
[10:22:07.823]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:07.823]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:07.823]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:07.823]                               "release", "version")], collapse = " "), 
[10:22:07.823]                             hostname = base::Sys.info()[["nodename"]])
[10:22:07.823]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:07.823]                             info)
[10:22:07.823]                           info <- base::paste(info, collapse = "; ")
[10:22:07.823]                           if (!has_future) {
[10:22:07.823]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:07.823]                               info)
[10:22:07.823]                           }
[10:22:07.823]                           else {
[10:22:07.823]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:07.823]                               info, version)
[10:22:07.823]                           }
[10:22:07.823]                           base::stop(msg)
[10:22:07.823]                         }
[10:22:07.823]                       })
[10:22:07.823]                     }
[10:22:07.823]                     base::local({
[10:22:07.823]                       for (pkg in "future") {
[10:22:07.823]                         base::loadNamespace(pkg)
[10:22:07.823]                         base::library(pkg, character.only = TRUE)
[10:22:07.823]                       }
[10:22:07.823]                     })
[10:22:07.823]                   }
[10:22:07.823]                   ...future.strategy.old <- future::plan("list")
[10:22:07.823]                   options(future.plan = NULL)
[10:22:07.823]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:07.823]                   future::plan(list(b = function (..., workers = availableCores(), 
[10:22:07.823]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:07.823]                     envir = parent.frame()) 
[10:22:07.823]                   {
[10:22:07.823]                     if (is.function(workers)) 
[10:22:07.823]                       workers <- workers()
[10:22:07.823]                     workers <- structure(as.integer(workers), 
[10:22:07.823]                       class = class(workers))
[10:22:07.823]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:07.823]                       workers >= 1)
[10:22:07.823]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:07.823]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:07.823]                     }
[10:22:07.823]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:07.823]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:07.823]                       envir = envir)
[10:22:07.823]                     if (!future$lazy) 
[10:22:07.823]                       future <- run(future)
[10:22:07.823]                     invisible(future)
[10:22:07.823]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:07.823]                 }
[10:22:07.823]                 ...future.workdir <- getwd()
[10:22:07.823]             }
[10:22:07.823]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:07.823]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:07.823]         }
[10:22:07.823]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:07.823]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:07.823]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:07.823]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:07.823]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:07.823]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:07.823]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:07.823]             base::names(...future.oldOptions))
[10:22:07.823]     }
[10:22:07.823]     if (FALSE) {
[10:22:07.823]     }
[10:22:07.823]     else {
[10:22:07.823]         if (TRUE) {
[10:22:07.823]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:07.823]                 open = "w")
[10:22:07.823]         }
[10:22:07.823]         else {
[10:22:07.823]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:07.823]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:07.823]         }
[10:22:07.823]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:07.823]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:07.823]             base::sink(type = "output", split = FALSE)
[10:22:07.823]             base::close(...future.stdout)
[10:22:07.823]         }, add = TRUE)
[10:22:07.823]     }
[10:22:07.823]     ...future.frame <- base::sys.nframe()
[10:22:07.823]     ...future.conditions <- base::list()
[10:22:07.823]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:07.823]     if (FALSE) {
[10:22:07.823]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:07.823]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:07.823]     }
[10:22:07.823]     ...future.result <- base::tryCatch({
[10:22:07.823]         base::withCallingHandlers({
[10:22:07.823]             ...future.value <- base::withVisible(base::local({
[10:22:07.823]                 value(future(subset(data, a == 2)))
[10:22:07.823]             }))
[10:22:07.823]             future::FutureResult(value = ...future.value$value, 
[10:22:07.823]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:07.823]                   ...future.rng), globalenv = if (FALSE) 
[10:22:07.823]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:07.823]                     ...future.globalenv.names))
[10:22:07.823]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:07.823]         }, condition = base::local({
[10:22:07.823]             c <- base::c
[10:22:07.823]             inherits <- base::inherits
[10:22:07.823]             invokeRestart <- base::invokeRestart
[10:22:07.823]             length <- base::length
[10:22:07.823]             list <- base::list
[10:22:07.823]             seq.int <- base::seq.int
[10:22:07.823]             signalCondition <- base::signalCondition
[10:22:07.823]             sys.calls <- base::sys.calls
[10:22:07.823]             `[[` <- base::`[[`
[10:22:07.823]             `+` <- base::`+`
[10:22:07.823]             `<<-` <- base::`<<-`
[10:22:07.823]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:07.823]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:07.823]                   3L)]
[10:22:07.823]             }
[10:22:07.823]             function(cond) {
[10:22:07.823]                 is_error <- inherits(cond, "error")
[10:22:07.823]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:07.823]                   NULL)
[10:22:07.823]                 if (is_error) {
[10:22:07.823]                   sessionInformation <- function() {
[10:22:07.823]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:07.823]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:07.823]                       search = base::search(), system = base::Sys.info())
[10:22:07.823]                   }
[10:22:07.823]                   ...future.conditions[[length(...future.conditions) + 
[10:22:07.823]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:07.823]                     cond$call), session = sessionInformation(), 
[10:22:07.823]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:07.823]                   signalCondition(cond)
[10:22:07.823]                 }
[10:22:07.823]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:07.823]                 "immediateCondition"))) {
[10:22:07.823]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:07.823]                   ...future.conditions[[length(...future.conditions) + 
[10:22:07.823]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:07.823]                   if (TRUE && !signal) {
[10:22:07.823]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:07.823]                     {
[10:22:07.823]                       inherits <- base::inherits
[10:22:07.823]                       invokeRestart <- base::invokeRestart
[10:22:07.823]                       is.null <- base::is.null
[10:22:07.823]                       muffled <- FALSE
[10:22:07.823]                       if (inherits(cond, "message")) {
[10:22:07.823]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:07.823]                         if (muffled) 
[10:22:07.823]                           invokeRestart("muffleMessage")
[10:22:07.823]                       }
[10:22:07.823]                       else if (inherits(cond, "warning")) {
[10:22:07.823]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:07.823]                         if (muffled) 
[10:22:07.823]                           invokeRestart("muffleWarning")
[10:22:07.823]                       }
[10:22:07.823]                       else if (inherits(cond, "condition")) {
[10:22:07.823]                         if (!is.null(pattern)) {
[10:22:07.823]                           computeRestarts <- base::computeRestarts
[10:22:07.823]                           grepl <- base::grepl
[10:22:07.823]                           restarts <- computeRestarts(cond)
[10:22:07.823]                           for (restart in restarts) {
[10:22:07.823]                             name <- restart$name
[10:22:07.823]                             if (is.null(name)) 
[10:22:07.823]                               next
[10:22:07.823]                             if (!grepl(pattern, name)) 
[10:22:07.823]                               next
[10:22:07.823]                             invokeRestart(restart)
[10:22:07.823]                             muffled <- TRUE
[10:22:07.823]                             break
[10:22:07.823]                           }
[10:22:07.823]                         }
[10:22:07.823]                       }
[10:22:07.823]                       invisible(muffled)
[10:22:07.823]                     }
[10:22:07.823]                     muffleCondition(cond, pattern = "^muffle")
[10:22:07.823]                   }
[10:22:07.823]                 }
[10:22:07.823]                 else {
[10:22:07.823]                   if (TRUE) {
[10:22:07.823]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:07.823]                     {
[10:22:07.823]                       inherits <- base::inherits
[10:22:07.823]                       invokeRestart <- base::invokeRestart
[10:22:07.823]                       is.null <- base::is.null
[10:22:07.823]                       muffled <- FALSE
[10:22:07.823]                       if (inherits(cond, "message")) {
[10:22:07.823]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:07.823]                         if (muffled) 
[10:22:07.823]                           invokeRestart("muffleMessage")
[10:22:07.823]                       }
[10:22:07.823]                       else if (inherits(cond, "warning")) {
[10:22:07.823]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:07.823]                         if (muffled) 
[10:22:07.823]                           invokeRestart("muffleWarning")
[10:22:07.823]                       }
[10:22:07.823]                       else if (inherits(cond, "condition")) {
[10:22:07.823]                         if (!is.null(pattern)) {
[10:22:07.823]                           computeRestarts <- base::computeRestarts
[10:22:07.823]                           grepl <- base::grepl
[10:22:07.823]                           restarts <- computeRestarts(cond)
[10:22:07.823]                           for (restart in restarts) {
[10:22:07.823]                             name <- restart$name
[10:22:07.823]                             if (is.null(name)) 
[10:22:07.823]                               next
[10:22:07.823]                             if (!grepl(pattern, name)) 
[10:22:07.823]                               next
[10:22:07.823]                             invokeRestart(restart)
[10:22:07.823]                             muffled <- TRUE
[10:22:07.823]                             break
[10:22:07.823]                           }
[10:22:07.823]                         }
[10:22:07.823]                       }
[10:22:07.823]                       invisible(muffled)
[10:22:07.823]                     }
[10:22:07.823]                     muffleCondition(cond, pattern = "^muffle")
[10:22:07.823]                   }
[10:22:07.823]                 }
[10:22:07.823]             }
[10:22:07.823]         }))
[10:22:07.823]     }, error = function(ex) {
[10:22:07.823]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:07.823]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:07.823]                 ...future.rng), started = ...future.startTime, 
[10:22:07.823]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:07.823]             version = "1.8"), class = "FutureResult")
[10:22:07.823]     }, finally = {
[10:22:07.823]         if (!identical(...future.workdir, getwd())) 
[10:22:07.823]             setwd(...future.workdir)
[10:22:07.823]         {
[10:22:07.823]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:07.823]                 ...future.oldOptions$nwarnings <- NULL
[10:22:07.823]             }
[10:22:07.823]             base::options(...future.oldOptions)
[10:22:07.823]             if (.Platform$OS.type == "windows") {
[10:22:07.823]                 old_names <- names(...future.oldEnvVars)
[10:22:07.823]                 envs <- base::Sys.getenv()
[10:22:07.823]                 names <- names(envs)
[10:22:07.823]                 common <- intersect(names, old_names)
[10:22:07.823]                 added <- setdiff(names, old_names)
[10:22:07.823]                 removed <- setdiff(old_names, names)
[10:22:07.823]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:07.823]                   envs[common]]
[10:22:07.823]                 NAMES <- toupper(changed)
[10:22:07.823]                 args <- list()
[10:22:07.823]                 for (kk in seq_along(NAMES)) {
[10:22:07.823]                   name <- changed[[kk]]
[10:22:07.823]                   NAME <- NAMES[[kk]]
[10:22:07.823]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:07.823]                     next
[10:22:07.823]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:07.823]                 }
[10:22:07.823]                 NAMES <- toupper(added)
[10:22:07.823]                 for (kk in seq_along(NAMES)) {
[10:22:07.823]                   name <- added[[kk]]
[10:22:07.823]                   NAME <- NAMES[[kk]]
[10:22:07.823]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:07.823]                     next
[10:22:07.823]                   args[[name]] <- ""
[10:22:07.823]                 }
[10:22:07.823]                 NAMES <- toupper(removed)
[10:22:07.823]                 for (kk in seq_along(NAMES)) {
[10:22:07.823]                   name <- removed[[kk]]
[10:22:07.823]                   NAME <- NAMES[[kk]]
[10:22:07.823]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:07.823]                     next
[10:22:07.823]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:07.823]                 }
[10:22:07.823]                 if (length(args) > 0) 
[10:22:07.823]                   base::do.call(base::Sys.setenv, args = args)
[10:22:07.823]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:07.823]             }
[10:22:07.823]             else {
[10:22:07.823]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:07.823]             }
[10:22:07.823]             {
[10:22:07.823]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:07.823]                   0L) {
[10:22:07.823]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:07.823]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:07.823]                   base::options(opts)
[10:22:07.823]                 }
[10:22:07.823]                 {
[10:22:07.823]                   {
[10:22:07.823]                     NULL
[10:22:07.823]                     RNGkind("Mersenne-Twister")
[10:22:07.823]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:07.823]                       inherits = FALSE)
[10:22:07.823]                   }
[10:22:07.823]                   options(future.plan = NULL)
[10:22:07.823]                   if (is.na(NA_character_)) 
[10:22:07.823]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:07.823]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:07.823]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:07.823]                     .init = FALSE)
[10:22:07.823]                 }
[10:22:07.823]             }
[10:22:07.823]         }
[10:22:07.823]     })
[10:22:07.823]     if (TRUE) {
[10:22:07.823]         base::sink(type = "output", split = FALSE)
[10:22:07.823]         if (TRUE) {
[10:22:07.823]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:07.823]         }
[10:22:07.823]         else {
[10:22:07.823]             ...future.result["stdout"] <- base::list(NULL)
[10:22:07.823]         }
[10:22:07.823]         base::close(...future.stdout)
[10:22:07.823]         ...future.stdout <- NULL
[10:22:07.823]     }
[10:22:07.823]     ...future.result$conditions <- ...future.conditions
[10:22:07.823]     ...future.result$finished <- base::Sys.time()
[10:22:07.823]     ...future.result
[10:22:07.823] }
[10:22:07.825] assign_globals() ...
[10:22:07.825] List of 1
[10:22:07.825]  $ data:'data.frame':	3 obs. of  2 variables:
[10:22:07.825]   ..$ a: int [1:3] 1 2 3
[10:22:07.825]   ..$ b: int [1:3] 3 2 1
[10:22:07.825]  - attr(*, "where")=List of 1
[10:22:07.825]   ..$ data:<environment: R_EmptyEnv> 
[10:22:07.825]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:07.825]  - attr(*, "resolved")= logi FALSE
[10:22:07.825]  - attr(*, "total_size")= num 356
[10:22:07.825]  - attr(*, "already-done")= logi TRUE
[10:22:07.829] - copied ‘data’ to environment
[10:22:07.829] assign_globals() ... done
[10:22:07.830] plan(): Setting new future strategy stack:
[10:22:07.830] List of future strategies:
[10:22:07.830] 1. multisession:
[10:22:07.830]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:22:07.830]    - tweaked: FALSE
[10:22:07.830]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:07.832] plan(): nbrOfWorkers() = 2
[10:22:07.927] plan(): Setting new future strategy stack:
[10:22:07.927] List of future strategies:
[10:22:07.927] 1. sequential:
[10:22:07.927]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:07.927]    - tweaked: FALSE
[10:22:07.927]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:07.927] 2. multisession:
[10:22:07.927]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:22:07.927]    - tweaked: FALSE
[10:22:07.927]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:07.927] plan(): nbrOfWorkers() = 1
[10:22:07.927] SequentialFuture started (and completed)
[10:22:07.928] signalConditions() ...
[10:22:07.928]  - include = ‘immediateCondition’
[10:22:07.928]  - exclude = 
[10:22:07.928]  - resignal = FALSE
[10:22:07.928]  - Number of conditions: 63
[10:22:07.928] signalConditions() ... done
[10:22:07.928] - Launch lazy future ... done
[10:22:07.928] run() for ‘SequentialFuture’ ... done
[10:22:07.928] signalConditions() ...
[10:22:07.928]  - include = ‘immediateCondition’
[10:22:07.928]  - exclude = 
[10:22:07.929]  - resignal = FALSE
[10:22:07.929]  - Number of conditions: 63
[10:22:07.929] signalConditions() ... done
[10:22:07.929] Future state: ‘finished’
[10:22:07.929] signalConditions() ...
[10:22:07.929]  - include = ‘condition’
[10:22:07.929]  - exclude = ‘immediateCondition’
[10:22:07.929]  - resignal = TRUE
[10:22:07.929]  - Number of conditions: 63
[10:22:07.929]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.832] getGlobalsAndPackages() ...
[10:22:07.929]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.832] Searching for globals...
[10:22:07.930]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.850] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[10:22:07.930]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.851] Searching for globals ... DONE
[10:22:07.930]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.851] Resolving globals: FALSE
[10:22:07.930]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.851] The total size of the 1 globals is 356 bytes (356 bytes)
[10:22:07.930]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.852] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[10:22:07.930]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.852] - globals: [1] ‘data’
[10:22:07.930]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.852] 
[10:22:07.930]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.852] getGlobalsAndPackages() ... DONE
[10:22:07.931]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.852] run() for ‘Future’ ...
[10:22:07.931]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.853] - state: ‘created’
[10:22:07.931]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.853] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:07.931]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.867] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:07.931]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.867] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:07.931]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.868]   - Field: ‘node’
[10:22:07.931]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.868]   - Field: ‘label’
[10:22:07.931]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.868]   - Field: ‘local’
[10:22:07.932]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.868]   - Field: ‘owner’
[10:22:07.932]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.868]   - Field: ‘envir’
[10:22:07.932]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.868]   - Field: ‘workers’
[10:22:07.932]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.868]   - Field: ‘packages’
[10:22:07.932]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.868]   - Field: ‘gc’
[10:22:07.932]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.869]   - Field: ‘conditions’
[10:22:07.932]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.869]   - Field: ‘persistent’
[10:22:07.932]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.869]   - Field: ‘expr’
[10:22:07.932]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.869]   - Field: ‘uuid’
[10:22:07.933]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.869]   - Field: ‘seed’
[10:22:07.933]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.869]   - Field: ‘version’
[10:22:07.933]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.869]   - Field: ‘result’
[10:22:07.933]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.869]   - Field: ‘asynchronous’
[10:22:07.933]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.870]   - Field: ‘calls’
[10:22:07.933]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.870]   - Field: ‘globals’
[10:22:07.933]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.870]   - Field: ‘stdout’
[10:22:07.933]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.870]   - Field: ‘earlySignal’
[10:22:07.934]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.874]   - Field: ‘lazy’
[10:22:07.934]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.875]   - Field: ‘state’
[10:22:07.934]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.875] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:07.934]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.875] - Launch lazy future ...
[10:22:07.934]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.875] Packages needed by the future expression (n = 0): <none>
[10:22:07.934]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.875] Packages needed by future strategies (n = 0): <none>
[10:22:07.934]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.876] {
[10:22:07.876]     {
[10:22:07.876]         {
[10:22:07.876]             ...future.startTime <- base::Sys.time()
[10:22:07.876]             {
[10:22:07.876]                 {
[10:22:07.876]                   {
[10:22:07.876]                     {
[10:22:07.876]                       base::local({
[10:22:07.876]                         has_future <- base::requireNamespace("future", 
[10:22:07.876]                           quietly = TRUE)
[10:22:07.876]                         if (has_future) {
[10:22:07.876]                           ns <- base::getNamespace("future")
[10:22:07.876]                           version <- ns[[".package"]][["version"]]
[10:22:07.876]                           if (is.null(version)) 
[10:22:07.876]                             version <- utils::packageVersion("future")
[10:22:07.876]                         }
[10:22:07.876]                         else {
[10:22:07.876]                           version <- NULL
[10:22:07.876]                         }
[10:22:07.876]                         if (!has_future || version < "1.8.0") {
[10:22:07.876]                           info <- base::c(r_version = base::gsub("R version ", 
[10:22:07.876]                             "", base::R.version$version.string), 
[10:22:07.876]                             platform = base::sprintf("%s (%s-bit)", 
[10:22:07.876]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:07.876]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:07.876]                               "release", "version")], collapse = " "), 
[10:22:07.876]                             hostname = base::Sys.info()[["nodename"]])
[10:22:07.876]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:22:07.876]                             info)
[10:22:07.876]                           info <- base::paste(info, collapse = "; ")
[10:22:07.876]                           if (!has_future) {
[10:22:07.876]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:07.876]                               info)
[10:22:07.876]                           }
[10:22:07.876]                           else {
[10:22:07.876]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:07.876]                               info, version)
[10:22:07.876]                           }
[10:22:07.876]                           base::stop(msg)
[10:22:07.876]                         }
[10:22:07.876]                       })
[10:22:07.876]                     }
[10:22:07.876]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:07.876]                     base::options(mc.cores = 1L)
[10:22:07.876]                   }
[10:22:07.876]                   ...future.strategy.old <- future::plan("list")
[10:22:07.876]                   options(future.plan = NULL)
[10:22:07.876]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:07.876]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:07.876]                 }
[10:22:07.876]                 ...future.workdir <- getwd()
[10:22:07.876]             }
[10:22:07.876]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:07.876]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:07.876]         }
[10:22:07.876]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:07.876]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:07.876]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:07.876]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:07.876]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:07.876]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:07.876]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:07.876]             base::names(...future.oldOptions))
[10:22:07.876]     }
[10:22:07.876]     if (FALSE) {
[10:22:07.876]     }
[10:22:07.876]     else {
[10:22:07.876]         if (TRUE) {
[10:22:07.876]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:07.876]                 open = "w")
[10:22:07.876]         }
[10:22:07.876]         else {
[10:22:07.876]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:07.876]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:07.876]         }
[10:22:07.876]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:07.876]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:07.876]             base::sink(type = "output", split = FALSE)
[10:22:07.876]             base::close(...future.stdout)
[10:22:07.876]         }, add = TRUE)
[10:22:07.876]     }
[10:22:07.876]     ...future.frame <- base::sys.nframe()
[10:22:07.876]     ...future.conditions <- base::list()
[10:22:07.876]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:07.876]     if (FALSE) {
[10:22:07.876]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:07.876]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:07.876]     }
[10:22:07.876]     ...future.result <- base::tryCatch({
[10:22:07.876]         base::withCallingHandlers({
[10:22:07.876]             ...future.value <- base::withVisible(base::local({
[10:22:07.876]                 ...future.makeSendCondition <- base::local({
[10:22:07.876]                   sendCondition <- NULL
[10:22:07.876]                   function(frame = 1L) {
[10:22:07.876]                     if (is.function(sendCondition)) 
[10:22:07.876]                       return(sendCondition)
[10:22:07.876]                     ns <- getNamespace("parallel")
[10:22:07.876]                     if (exists("sendData", mode = "function", 
[10:22:07.876]                       envir = ns)) {
[10:22:07.876]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:07.876]                         envir = ns)
[10:22:07.876]                       envir <- sys.frame(frame)
[10:22:07.876]                       master <- NULL
[10:22:07.876]                       while (!identical(envir, .GlobalEnv) && 
[10:22:07.876]                         !identical(envir, emptyenv())) {
[10:22:07.876]                         if (exists("master", mode = "list", envir = envir, 
[10:22:07.876]                           inherits = FALSE)) {
[10:22:07.876]                           master <- get("master", mode = "list", 
[10:22:07.876]                             envir = envir, inherits = FALSE)
[10:22:07.876]                           if (inherits(master, c("SOCKnode", 
[10:22:07.876]                             "SOCK0node"))) {
[10:22:07.876]                             sendCondition <<- function(cond) {
[10:22:07.876]                               data <- list(type = "VALUE", value = cond, 
[10:22:07.876]                                 success = TRUE)
[10:22:07.876]                               parallel_sendData(master, data)
[10:22:07.876]                             }
[10:22:07.876]                             return(sendCondition)
[10:22:07.876]                           }
[10:22:07.876]                         }
[10:22:07.876]                         frame <- frame + 1L
[10:22:07.876]                         envir <- sys.frame(frame)
[10:22:07.876]                       }
[10:22:07.876]                     }
[10:22:07.876]                     sendCondition <<- function(cond) NULL
[10:22:07.876]                   }
[10:22:07.876]                 })
[10:22:07.876]                 withCallingHandlers({
[10:22:07.876]                   subset(data, a == 2)
[10:22:07.876]                 }, immediateCondition = function(cond) {
[10:22:07.876]                   sendCondition <- ...future.makeSendCondition()
[10:22:07.876]                   sendCondition(cond)
[10:22:07.876]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:07.876]                   {
[10:22:07.876]                     inherits <- base::inherits
[10:22:07.876]                     invokeRestart <- base::invokeRestart
[10:22:07.876]                     is.null <- base::is.null
[10:22:07.876]                     muffled <- FALSE
[10:22:07.876]                     if (inherits(cond, "message")) {
[10:22:07.876]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:07.876]                       if (muffled) 
[10:22:07.876]                         invokeRestart("muffleMessage")
[10:22:07.876]                     }
[10:22:07.876]                     else if (inherits(cond, "warning")) {
[10:22:07.876]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:07.876]                       if (muffled) 
[10:22:07.876]                         invokeRestart("muffleWarning")
[10:22:07.876]                     }
[10:22:07.876]                     else if (inherits(cond, "condition")) {
[10:22:07.876]                       if (!is.null(pattern)) {
[10:22:07.876]                         computeRestarts <- base::computeRestarts
[10:22:07.876]                         grepl <- base::grepl
[10:22:07.876]                         restarts <- computeRestarts(cond)
[10:22:07.876]                         for (restart in restarts) {
[10:22:07.876]                           name <- restart$name
[10:22:07.876]                           if (is.null(name)) 
[10:22:07.876]                             next
[10:22:07.876]                           if (!grepl(pattern, name)) 
[10:22:07.876]                             next
[10:22:07.876]                           invokeRestart(restart)
[10:22:07.876]                           muffled <- TRUE
[10:22:07.876]                           break
[10:22:07.876]                         }
[10:22:07.876]                       }
[10:22:07.876]                     }
[10:22:07.876]                     invisible(muffled)
[10:22:07.876]                   }
[10:22:07.876]                   muffleCondition(cond)
[10:22:07.876]                 })
[10:22:07.876]             }))
[10:22:07.876]             future::FutureResult(value = ...future.value$value, 
[10:22:07.876]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:07.876]                   ...future.rng), globalenv = if (FALSE) 
[10:22:07.876]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:07.876]                     ...future.globalenv.names))
[10:22:07.876]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:07.876]         }, condition = base::local({
[10:22:07.876]             c <- base::c
[10:22:07.876]             inherits <- base::inherits
[10:22:07.876]             invokeRestart <- base::invokeRestart
[10:22:07.876]             length <- base::length
[10:22:07.876]             list <- base::list
[10:22:07.876]             seq.int <- base::seq.int
[10:22:07.876]             signalCondition <- base::signalCondition
[10:22:07.876]             sys.calls <- base::sys.calls
[10:22:07.876]             `[[` <- base::`[[`
[10:22:07.876]             `+` <- base::`+`
[10:22:07.876]             `<<-` <- base::`<<-`
[10:22:07.876]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:07.876]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:07.876]                   3L)]
[10:22:07.876]             }
[10:22:07.876]             function(cond) {
[10:22:07.876]                 is_error <- inherits(cond, "error")
[10:22:07.876]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:07.876]                   NULL)
[10:22:07.876]                 if (is_error) {
[10:22:07.876]                   sessionInformation <- function() {
[10:22:07.876]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:07.876]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:07.876]                       search = base::search(), system = base::Sys.info())
[10:22:07.876]                   }
[10:22:07.876]                   ...future.conditions[[length(...future.conditions) + 
[10:22:07.876]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:07.876]                     cond$call), session = sessionInformation(), 
[10:22:07.876]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:07.876]                   signalCondition(cond)
[10:22:07.876]                 }
[10:22:07.876]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:07.876]                 "immediateCondition"))) {
[10:22:07.876]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:07.876]                   ...future.conditions[[length(...future.conditions) + 
[10:22:07.876]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:07.876]                   if (TRUE && !signal) {
[10:22:07.876]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:07.876]                     {
[10:22:07.876]                       inherits <- base::inherits
[10:22:07.876]                       invokeRestart <- base::invokeRestart
[10:22:07.876]                       is.null <- base::is.null
[10:22:07.876]                       muffled <- FALSE
[10:22:07.876]                       if (inherits(cond, "message")) {
[10:22:07.876]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:07.876]                         if (muffled) 
[10:22:07.876]                           invokeRestart("muffleMessage")
[10:22:07.876]                       }
[10:22:07.876]                       else if (inherits(cond, "warning")) {
[10:22:07.876]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:07.876]                         if (muffled) 
[10:22:07.876]                           invokeRestart("muffleWarning")
[10:22:07.876]                       }
[10:22:07.876]                       else if (inherits(cond, "condition")) {
[10:22:07.876]                         if (!is.null(pattern)) {
[10:22:07.876]                           computeRestarts <- base::computeRestarts
[10:22:07.876]                           grepl <- base::grepl
[10:22:07.876]                           restarts <- computeRestarts(cond)
[10:22:07.876]                           for (restart in restarts) {
[10:22:07.876]                             name <- restart$name
[10:22:07.876]                             if (is.null(name)) 
[10:22:07.876]                               next
[10:22:07.876]                             if (!grepl(pattern, name)) 
[10:22:07.876]                               next
[10:22:07.876]                             invokeRestart(restart)
[10:22:07.876]                             muffled <- TRUE
[10:22:07.876]                             break
[10:22:07.876]                           }
[10:22:07.876]                         }
[10:22:07.876]                       }
[10:22:07.876]                       invisible(muffled)
[10:22:07.876]                     }
[10:22:07.876]                     muffleCondition(cond, pattern = "^muffle")
[10:22:07.876]                   }
[10:22:07.876]                 }
[10:22:07.876]                 else {
[10:22:07.876]                   if (TRUE) {
[10:22:07.876]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:07.876]                     {
[10:22:07.876]                       inherits <- base::inherits
[10:22:07.876]                       invokeRestart <- base::invokeRestart
[10:22:07.876]                       is.null <- base::is.null
[10:22:07.876]                       muffled <- FALSE
[10:22:07.876]                       if (inherits(cond, "message")) {
[10:22:07.876]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:07.876]                         if (muffled) 
[10:22:07.876]                           invokeRestart("muffleMessage")
[10:22:07.876]                       }
[10:22:07.876]                       else if (inherits(cond, "warning")) {
[10:22:07.876]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:07.876]                         if (muffled) 
[10:22:07.876]                           invokeRestart("muffleWarning")
[10:22:07.876]                       }
[10:22:07.876]                       else if (inherits(cond, "condition")) {
[10:22:07.876]                         if (!is.null(pattern)) {
[10:22:07.876]                           computeRestarts <- base::computeRestarts
[10:22:07.876]                           grepl <- base::grepl
[10:22:07.876]                           restarts <- computeRestarts(cond)
[10:22:07.876]                           for (restart in restarts) {
[10:22:07.876]                             name <- restart$name
[10:22:07.876]                             if (is.null(name)) 
[10:22:07.876]                               next
[10:22:07.876]                             if (!grepl(pattern, name)) 
[10:22:07.876]                               next
[10:22:07.876]                             invokeRestart(restart)
[10:22:07.876]                             muffled <- TRUE
[10:22:07.876]                             break
[10:22:07.876]                           }
[10:22:07.876]                         }
[10:22:07.876]                       }
[10:22:07.876]                       invisible(muffled)
[10:22:07.876]                     }
[10:22:07.876]                     muffleCondition(cond, pattern = "^muffle")
[10:22:07.876]                   }
[10:22:07.876]                 }
[10:22:07.876]             }
[10:22:07.876]         }))
[10:22:07.876]     }, error = function(ex) {
[10:22:07.876]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:07.876]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:07.876]                 ...future.rng), started = ...future.startTime, 
[10:22:07.876]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:07.876]             version = "1.8"), class = "FutureResult")
[10:22:07.876]     }, finally = {
[10:22:07.876]         if (!identical(...future.workdir, getwd())) 
[10:22:07.876]             setwd(...future.workdir)
[10:22:07.876]         {
[10:22:07.876]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:07.876]                 ...future.oldOptions$nwarnings <- NULL
[10:22:07.876]             }
[10:22:07.876]             base::options(...future.oldOptions)
[10:22:07.876]             if (.Platform$OS.type == "windows") {
[10:22:07.876]                 old_names <- names(...future.oldEnvVars)
[10:22:07.876]                 envs <- base::Sys.getenv()
[10:22:07.876]                 names <- names(envs)
[10:22:07.876]                 common <- intersect(names, old_names)
[10:22:07.876]                 added <- setdiff(names, old_names)
[10:22:07.876]                 removed <- setdiff(old_names, names)
[10:22:07.876]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:07.876]                   envs[common]]
[10:22:07.876]                 NAMES <- toupper(changed)
[10:22:07.876]                 args <- list()
[10:22:07.876]                 for (kk in seq_along(NAMES)) {
[10:22:07.876]                   name <- changed[[kk]]
[10:22:07.876]                   NAME <- NAMES[[kk]]
[10:22:07.876]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:07.876]                     next
[10:22:07.876]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:07.876]                 }
[10:22:07.876]                 NAMES <- toupper(added)
[10:22:07.876]                 for (kk in seq_along(NAMES)) {
[10:22:07.876]                   name <- added[[kk]]
[10:22:07.876]                   NAME <- NAMES[[kk]]
[10:22:07.876]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:07.876]                     next
[10:22:07.876]                   args[[name]] <- ""
[10:22:07.876]                 }
[10:22:07.876]                 NAMES <- toupper(removed)
[10:22:07.876]                 for (kk in seq_along(NAMES)) {
[10:22:07.876]                   name <- removed[[kk]]
[10:22:07.876]                   NAME <- NAMES[[kk]]
[10:22:07.876]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:07.876]                     next
[10:22:07.876]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:07.876]                 }
[10:22:07.876]                 if (length(args) > 0) 
[10:22:07.876]                   base::do.call(base::Sys.setenv, args = args)
[10:22:07.876]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:07.876]             }
[10:22:07.876]             else {
[10:22:07.876]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:07.876]             }
[10:22:07.876]             {
[10:22:07.876]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:07.876]                   0L) {
[10:22:07.876]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:07.876]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:07.876]                   base::options(opts)
[10:22:07.876]                 }
[10:22:07.876]                 {
[10:22:07.876]                   {
[10:22:07.876]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:07.876]                     NULL
[10:22:07.876]                   }
[10:22:07.876]                   options(future.plan = NULL)
[10:22:07.876]                   if (is.na(NA_character_)) 
[10:22:07.876]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:07.876]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:07.876]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:07.876]                     .init = FALSE)
[10:22:07.876]                 }
[10:22:07.876]             }
[10:22:07.876]         }
[10:22:07.876]     })
[10:22:07.876]     if (TRUE) {
[10:22:07.876]         base::sink(type = "output", split = FALSE)
[10:22:07.876]         if (TRUE) {
[10:22:07.876]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:07.876]         }
[10:22:07.876]         else {
[10:22:07.876]             ...future.result["stdout"] <- base::list(NULL)
[10:22:07.876]         }
[10:22:07.876]         base::close(...future.stdout)
[10:22:07.876]         ...future.stdout <- NULL
[10:22:07.876]     }
[10:22:07.876]     ...future.result$conditions <- ...future.conditions
[10:22:07.876]     ...future.result$finished <- base::Sys.time()
[10:22:07.876]     ...future.result
[10:22:07.876] }
[10:22:07.935]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.878] Exporting 1 global objects (643 bytes) to cluster node #1 ...
[10:22:07.935]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.878] Exporting ‘data’ (356 bytes) to cluster node #1 ...
[10:22:07.935]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.879] Exporting ‘data’ (356 bytes) to cluster node #1 ... DONE
[10:22:07.935]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.879] Exporting 1 global objects (643 bytes) to cluster node #1 ... DONE
[10:22:07.935]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.879] MultisessionFuture started
[10:22:07.935]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.879] - Launch lazy future ... done
[10:22:07.935]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.880] run() for ‘MultisessionFuture’ ... done
[10:22:07.935]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.880] result() for ClusterFuture ...
[10:22:07.936]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.880] receiveMessageFromWorker() for ClusterFuture ...
[10:22:07.936]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.880] - Validating connection of MultisessionFuture
[10:22:07.936]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.925] - received message: FutureResult
[10:22:07.936]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.925] - Received FutureResult
[10:22:07.936]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.925] - Erased future from FutureRegistry
[10:22:07.936]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.925] result() for ClusterFuture ...
[10:22:07.936]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.925] - result already collected: FutureResult
[10:22:07.936]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.926] result() for ClusterFuture ... done
[10:22:07.937]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.926] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:07.937]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.926] result() for ClusterFuture ... done
[10:22:07.937]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.926] result() for ClusterFuture ...
[10:22:07.937]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.926] - result already collected: FutureResult
[10:22:07.937]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.926] result() for ClusterFuture ... done
[10:22:07.937] signalConditions() ... done
- plan(list('sequential', 'multisession')) ... DONE
- plan(list('multicore', 'sequential')) ...
[10:22:07.937] plan(): Setting new future strategy stack:
[10:22:07.938] List of future strategies:
[10:22:07.938] 1. multicore:
[10:22:07.938]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:07.938]    - tweaked: FALSE
[10:22:07.938]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:07.938] 2. sequential:
[10:22:07.938]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:07.938]    - tweaked: FALSE
[10:22:07.938]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:07.939] plan(): nbrOfWorkers() = 2
[10:22:07.940] getGlobalsAndPackages() ...
[10:22:07.940] Searching for globals...
[10:22:07.955] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[10:22:07.956] Searching for globals ... DONE
[10:22:07.956] Resolving globals: FALSE
[10:22:07.957] The total size of the 2 globals is 7.79 KiB (7973 bytes)
[10:22:07.957] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 7.79 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (7.74 KiB of class ‘list’) and ‘strategy2’ (49 bytes of class ‘character’)
[10:22:07.957] - globals: [2] ‘nested’, ‘strategy2’
[10:22:07.957] - packages: [1] ‘future’
[10:22:07.957] getGlobalsAndPackages() ... DONE
[10:22:07.958] run() for ‘Future’ ...
[10:22:07.958] - state: ‘created’
[10:22:07.958] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:07.959] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:07.960] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:07.960]   - Field: ‘label’
[10:22:07.960]   - Field: ‘local’
[10:22:07.960]   - Field: ‘owner’
[10:22:07.960]   - Field: ‘envir’
[10:22:07.960]   - Field: ‘workers’
[10:22:07.960]   - Field: ‘packages’
[10:22:07.960]   - Field: ‘gc’
[10:22:07.960]   - Field: ‘job’
[10:22:07.960]   - Field: ‘conditions’
[10:22:07.960]   - Field: ‘expr’
[10:22:07.961]   - Field: ‘uuid’
[10:22:07.961]   - Field: ‘seed’
[10:22:07.961]   - Field: ‘version’
[10:22:07.961]   - Field: ‘result’
[10:22:07.961]   - Field: ‘asynchronous’
[10:22:07.961]   - Field: ‘calls’
[10:22:07.961]   - Field: ‘globals’
[10:22:07.961]   - Field: ‘stdout’
[10:22:07.961]   - Field: ‘earlySignal’
[10:22:07.961]   - Field: ‘lazy’
[10:22:07.961]   - Field: ‘state’
[10:22:07.962] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:07.962] - Launch lazy future ...
[10:22:07.962] Packages needed by the future expression (n = 1): ‘future’
[10:22:07.962] Packages needed by future strategies (n = 1): ‘future’
[10:22:07.963] {
[10:22:07.963]     {
[10:22:07.963]         {
[10:22:07.963]             ...future.startTime <- base::Sys.time()
[10:22:07.963]             {
[10:22:07.963]                 {
[10:22:07.963]                   {
[10:22:07.963]                     {
[10:22:07.963]                       {
[10:22:07.963]                         base::local({
[10:22:07.963]                           has_future <- base::requireNamespace("future", 
[10:22:07.963]                             quietly = TRUE)
[10:22:07.963]                           if (has_future) {
[10:22:07.963]                             ns <- base::getNamespace("future")
[10:22:07.963]                             version <- ns[[".package"]][["version"]]
[10:22:07.963]                             if (is.null(version)) 
[10:22:07.963]                               version <- utils::packageVersion("future")
[10:22:07.963]                           }
[10:22:07.963]                           else {
[10:22:07.963]                             version <- NULL
[10:22:07.963]                           }
[10:22:07.963]                           if (!has_future || version < "1.8.0") {
[10:22:07.963]                             info <- base::c(r_version = base::gsub("R version ", 
[10:22:07.963]                               "", base::R.version$version.string), 
[10:22:07.963]                               platform = base::sprintf("%s (%s-bit)", 
[10:22:07.963]                                 base::R.version$platform, 8 * 
[10:22:07.963]                                   base::.Machine$sizeof.pointer), 
[10:22:07.963]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:07.963]                                 "release", "version")], collapse = " "), 
[10:22:07.963]                               hostname = base::Sys.info()[["nodename"]])
[10:22:07.963]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:22:07.963]                               info)
[10:22:07.963]                             info <- base::paste(info, collapse = "; ")
[10:22:07.963]                             if (!has_future) {
[10:22:07.963]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:07.963]                                 info)
[10:22:07.963]                             }
[10:22:07.963]                             else {
[10:22:07.963]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:07.963]                                 info, version)
[10:22:07.963]                             }
[10:22:07.963]                             base::stop(msg)
[10:22:07.963]                           }
[10:22:07.963]                         })
[10:22:07.963]                       }
[10:22:07.963]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:07.963]                       base::options(mc.cores = 1L)
[10:22:07.963]                     }
[10:22:07.963]                     base::local({
[10:22:07.963]                       for (pkg in "future") {
[10:22:07.963]                         base::loadNamespace(pkg)
[10:22:07.963]                         base::library(pkg, character.only = TRUE)
[10:22:07.963]                       }
[10:22:07.963]                     })
[10:22:07.963]                   }
[10:22:07.963]                   ...future.strategy.old <- future::plan("list")
[10:22:07.963]                   options(future.plan = NULL)
[10:22:07.963]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:07.963]                   future::plan(list(b = function (..., envir = parent.frame()) 
[10:22:07.963]                   {
[10:22:07.963]                     future <- SequentialFuture(..., envir = envir)
[10:22:07.963]                     if (!future$lazy) 
[10:22:07.963]                       future <- run(future)
[10:22:07.963]                     invisible(future)
[10:22:07.963]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:07.963]                 }
[10:22:07.963]                 ...future.workdir <- getwd()
[10:22:07.963]             }
[10:22:07.963]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:07.963]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:07.963]         }
[10:22:07.963]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:07.963]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:07.963]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:07.963]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:07.963]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:07.963]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:07.963]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:07.963]             base::names(...future.oldOptions))
[10:22:07.963]     }
[10:22:07.963]     if (FALSE) {
[10:22:07.963]     }
[10:22:07.963]     else {
[10:22:07.963]         if (TRUE) {
[10:22:07.963]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:07.963]                 open = "w")
[10:22:07.963]         }
[10:22:07.963]         else {
[10:22:07.963]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:07.963]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:07.963]         }
[10:22:07.963]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:07.963]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:07.963]             base::sink(type = "output", split = FALSE)
[10:22:07.963]             base::close(...future.stdout)
[10:22:07.963]         }, add = TRUE)
[10:22:07.963]     }
[10:22:07.963]     ...future.frame <- base::sys.nframe()
[10:22:07.963]     ...future.conditions <- base::list()
[10:22:07.963]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:07.963]     if (FALSE) {
[10:22:07.963]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:07.963]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:07.963]     }
[10:22:07.963]     ...future.result <- base::tryCatch({
[10:22:07.963]         base::withCallingHandlers({
[10:22:07.963]             ...future.value <- base::withVisible(base::local({
[10:22:07.963]                 withCallingHandlers({
[10:22:07.963]                   {
[10:22:07.963]                     a <- 1L
[10:22:07.963]                     plan_a <- unclass(future::plan("list"))
[10:22:07.963]                     nested_a <- nested[-1]
[10:22:07.963]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[10:22:07.963]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[10:22:07.963]                       strategy2))
[10:22:07.963]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[10:22:07.963]                       "init") <- NULL
[10:22:07.963]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[10:22:07.963]                       "init") <- NULL
[10:22:07.963]                     stopifnot(all.equal(plan_a, nested_a))
[10:22:07.963]                     y %<-% {
[10:22:07.963]                       b <- 2L
[10:22:07.963]                       plan_b <- future::plan("list")
[10:22:07.963]                       nested_b <- nested_a[-1]
[10:22:07.963]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:22:07.963]                         1L, inherits(plan_b[[1]], "future"), 
[10:22:07.963]                         inherits(future::plan("next"), "sequential"))
[10:22:07.963]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:22:07.963]                         b = b, nested_b = nested_b, plan_b = plan_b)
[10:22:07.963]                     }
[10:22:07.963]                     y
[10:22:07.963]                   }
[10:22:07.963]                 }, immediateCondition = function(cond) {
[10:22:07.963]                   save_rds <- function (object, pathname, ...) 
[10:22:07.963]                   {
[10:22:07.963]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:07.963]                     if (file_test("-f", pathname_tmp)) {
[10:22:07.963]                       fi_tmp <- file.info(pathname_tmp)
[10:22:07.963]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:07.963]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:07.963]                         fi_tmp[["mtime"]])
[10:22:07.963]                     }
[10:22:07.963]                     tryCatch({
[10:22:07.963]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:07.963]                     }, error = function(ex) {
[10:22:07.963]                       msg <- conditionMessage(ex)
[10:22:07.963]                       fi_tmp <- file.info(pathname_tmp)
[10:22:07.963]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:07.963]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:07.963]                         fi_tmp[["mtime"]], msg)
[10:22:07.963]                       ex$message <- msg
[10:22:07.963]                       stop(ex)
[10:22:07.963]                     })
[10:22:07.963]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:07.963]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:07.963]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:07.963]                       fi_tmp <- file.info(pathname_tmp)
[10:22:07.963]                       fi <- file.info(pathname)
[10:22:07.963]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:07.963]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:07.963]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:07.963]                         fi[["size"]], fi[["mtime"]])
[10:22:07.963]                       stop(msg)
[10:22:07.963]                     }
[10:22:07.963]                     invisible(pathname)
[10:22:07.963]                   }
[10:22:07.963]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:07.963]                     rootPath = tempdir()) 
[10:22:07.963]                   {
[10:22:07.963]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:07.963]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:07.963]                       tmpdir = path, fileext = ".rds")
[10:22:07.963]                     save_rds(obj, file)
[10:22:07.963]                   }
[10:22:07.963]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4kEgVJ/.future/immediateConditions")
[10:22:07.963]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:07.963]                   {
[10:22:07.963]                     inherits <- base::inherits
[10:22:07.963]                     invokeRestart <- base::invokeRestart
[10:22:07.963]                     is.null <- base::is.null
[10:22:07.963]                     muffled <- FALSE
[10:22:07.963]                     if (inherits(cond, "message")) {
[10:22:07.963]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:07.963]                       if (muffled) 
[10:22:07.963]                         invokeRestart("muffleMessage")
[10:22:07.963]                     }
[10:22:07.963]                     else if (inherits(cond, "warning")) {
[10:22:07.963]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:07.963]                       if (muffled) 
[10:22:07.963]                         invokeRestart("muffleWarning")
[10:22:07.963]                     }
[10:22:07.963]                     else if (inherits(cond, "condition")) {
[10:22:07.963]                       if (!is.null(pattern)) {
[10:22:07.963]                         computeRestarts <- base::computeRestarts
[10:22:07.963]                         grepl <- base::grepl
[10:22:07.963]                         restarts <- computeRestarts(cond)
[10:22:07.963]                         for (restart in restarts) {
[10:22:07.963]                           name <- restart$name
[10:22:07.963]                           if (is.null(name)) 
[10:22:07.963]                             next
[10:22:07.963]                           if (!grepl(pattern, name)) 
[10:22:07.963]                             next
[10:22:07.963]                           invokeRestart(restart)
[10:22:07.963]                           muffled <- TRUE
[10:22:07.963]                           break
[10:22:07.963]                         }
[10:22:07.963]                       }
[10:22:07.963]                     }
[10:22:07.963]                     invisible(muffled)
[10:22:07.963]                   }
[10:22:07.963]                   muffleCondition(cond)
[10:22:07.963]                 })
[10:22:07.963]             }))
[10:22:07.963]             future::FutureResult(value = ...future.value$value, 
[10:22:07.963]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:07.963]                   ...future.rng), globalenv = if (FALSE) 
[10:22:07.963]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:07.963]                     ...future.globalenv.names))
[10:22:07.963]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:07.963]         }, condition = base::local({
[10:22:07.963]             c <- base::c
[10:22:07.963]             inherits <- base::inherits
[10:22:07.963]             invokeRestart <- base::invokeRestart
[10:22:07.963]             length <- base::length
[10:22:07.963]             list <- base::list
[10:22:07.963]             seq.int <- base::seq.int
[10:22:07.963]             signalCondition <- base::signalCondition
[10:22:07.963]             sys.calls <- base::sys.calls
[10:22:07.963]             `[[` <- base::`[[`
[10:22:07.963]             `+` <- base::`+`
[10:22:07.963]             `<<-` <- base::`<<-`
[10:22:07.963]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:07.963]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:07.963]                   3L)]
[10:22:07.963]             }
[10:22:07.963]             function(cond) {
[10:22:07.963]                 is_error <- inherits(cond, "error")
[10:22:07.963]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:07.963]                   NULL)
[10:22:07.963]                 if (is_error) {
[10:22:07.963]                   sessionInformation <- function() {
[10:22:07.963]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:07.963]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:07.963]                       search = base::search(), system = base::Sys.info())
[10:22:07.963]                   }
[10:22:07.963]                   ...future.conditions[[length(...future.conditions) + 
[10:22:07.963]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:07.963]                     cond$call), session = sessionInformation(), 
[10:22:07.963]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:07.963]                   signalCondition(cond)
[10:22:07.963]                 }
[10:22:07.963]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:07.963]                 "immediateCondition"))) {
[10:22:07.963]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:07.963]                   ...future.conditions[[length(...future.conditions) + 
[10:22:07.963]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:07.963]                   if (TRUE && !signal) {
[10:22:07.963]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:07.963]                     {
[10:22:07.963]                       inherits <- base::inherits
[10:22:07.963]                       invokeRestart <- base::invokeRestart
[10:22:07.963]                       is.null <- base::is.null
[10:22:07.963]                       muffled <- FALSE
[10:22:07.963]                       if (inherits(cond, "message")) {
[10:22:07.963]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:07.963]                         if (muffled) 
[10:22:07.963]                           invokeRestart("muffleMessage")
[10:22:07.963]                       }
[10:22:07.963]                       else if (inherits(cond, "warning")) {
[10:22:07.963]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:07.963]                         if (muffled) 
[10:22:07.963]                           invokeRestart("muffleWarning")
[10:22:07.963]                       }
[10:22:07.963]                       else if (inherits(cond, "condition")) {
[10:22:07.963]                         if (!is.null(pattern)) {
[10:22:07.963]                           computeRestarts <- base::computeRestarts
[10:22:07.963]                           grepl <- base::grepl
[10:22:07.963]                           restarts <- computeRestarts(cond)
[10:22:07.963]                           for (restart in restarts) {
[10:22:07.963]                             name <- restart$name
[10:22:07.963]                             if (is.null(name)) 
[10:22:07.963]                               next
[10:22:07.963]                             if (!grepl(pattern, name)) 
[10:22:07.963]                               next
[10:22:07.963]                             invokeRestart(restart)
[10:22:07.963]                             muffled <- TRUE
[10:22:07.963]                             break
[10:22:07.963]                           }
[10:22:07.963]                         }
[10:22:07.963]                       }
[10:22:07.963]                       invisible(muffled)
[10:22:07.963]                     }
[10:22:07.963]                     muffleCondition(cond, pattern = "^muffle")
[10:22:07.963]                   }
[10:22:07.963]                 }
[10:22:07.963]                 else {
[10:22:07.963]                   if (TRUE) {
[10:22:07.963]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:07.963]                     {
[10:22:07.963]                       inherits <- base::inherits
[10:22:07.963]                       invokeRestart <- base::invokeRestart
[10:22:07.963]                       is.null <- base::is.null
[10:22:07.963]                       muffled <- FALSE
[10:22:07.963]                       if (inherits(cond, "message")) {
[10:22:07.963]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:07.963]                         if (muffled) 
[10:22:07.963]                           invokeRestart("muffleMessage")
[10:22:07.963]                       }
[10:22:07.963]                       else if (inherits(cond, "warning")) {
[10:22:07.963]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:07.963]                         if (muffled) 
[10:22:07.963]                           invokeRestart("muffleWarning")
[10:22:07.963]                       }
[10:22:07.963]                       else if (inherits(cond, "condition")) {
[10:22:07.963]                         if (!is.null(pattern)) {
[10:22:07.963]                           computeRestarts <- base::computeRestarts
[10:22:07.963]                           grepl <- base::grepl
[10:22:07.963]                           restarts <- computeRestarts(cond)
[10:22:07.963]                           for (restart in restarts) {
[10:22:07.963]                             name <- restart$name
[10:22:07.963]                             if (is.null(name)) 
[10:22:07.963]                               next
[10:22:07.963]                             if (!grepl(pattern, name)) 
[10:22:07.963]                               next
[10:22:07.963]                             invokeRestart(restart)
[10:22:07.963]                             muffled <- TRUE
[10:22:07.963]                             break
[10:22:07.963]                           }
[10:22:07.963]                         }
[10:22:07.963]                       }
[10:22:07.963]                       invisible(muffled)
[10:22:07.963]                     }
[10:22:07.963]                     muffleCondition(cond, pattern = "^muffle")
[10:22:07.963]                   }
[10:22:07.963]                 }
[10:22:07.963]             }
[10:22:07.963]         }))
[10:22:07.963]     }, error = function(ex) {
[10:22:07.963]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:07.963]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:07.963]                 ...future.rng), started = ...future.startTime, 
[10:22:07.963]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:07.963]             version = "1.8"), class = "FutureResult")
[10:22:07.963]     }, finally = {
[10:22:07.963]         if (!identical(...future.workdir, getwd())) 
[10:22:07.963]             setwd(...future.workdir)
[10:22:07.963]         {
[10:22:07.963]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:07.963]                 ...future.oldOptions$nwarnings <- NULL
[10:22:07.963]             }
[10:22:07.963]             base::options(...future.oldOptions)
[10:22:07.963]             if (.Platform$OS.type == "windows") {
[10:22:07.963]                 old_names <- names(...future.oldEnvVars)
[10:22:07.963]                 envs <- base::Sys.getenv()
[10:22:07.963]                 names <- names(envs)
[10:22:07.963]                 common <- intersect(names, old_names)
[10:22:07.963]                 added <- setdiff(names, old_names)
[10:22:07.963]                 removed <- setdiff(old_names, names)
[10:22:07.963]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:07.963]                   envs[common]]
[10:22:07.963]                 NAMES <- toupper(changed)
[10:22:07.963]                 args <- list()
[10:22:07.963]                 for (kk in seq_along(NAMES)) {
[10:22:07.963]                   name <- changed[[kk]]
[10:22:07.963]                   NAME <- NAMES[[kk]]
[10:22:07.963]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:07.963]                     next
[10:22:07.963]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:07.963]                 }
[10:22:07.963]                 NAMES <- toupper(added)
[10:22:07.963]                 for (kk in seq_along(NAMES)) {
[10:22:07.963]                   name <- added[[kk]]
[10:22:07.963]                   NAME <- NAMES[[kk]]
[10:22:07.963]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:07.963]                     next
[10:22:07.963]                   args[[name]] <- ""
[10:22:07.963]                 }
[10:22:07.963]                 NAMES <- toupper(removed)
[10:22:07.963]                 for (kk in seq_along(NAMES)) {
[10:22:07.963]                   name <- removed[[kk]]
[10:22:07.963]                   NAME <- NAMES[[kk]]
[10:22:07.963]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:07.963]                     next
[10:22:07.963]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:07.963]                 }
[10:22:07.963]                 if (length(args) > 0) 
[10:22:07.963]                   base::do.call(base::Sys.setenv, args = args)
[10:22:07.963]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:07.963]             }
[10:22:07.963]             else {
[10:22:07.963]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:07.963]             }
[10:22:07.963]             {
[10:22:07.963]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:07.963]                   0L) {
[10:22:07.963]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:07.963]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:07.963]                   base::options(opts)
[10:22:07.963]                 }
[10:22:07.963]                 {
[10:22:07.963]                   {
[10:22:07.963]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:07.963]                     NULL
[10:22:07.963]                   }
[10:22:07.963]                   options(future.plan = NULL)
[10:22:07.963]                   if (is.na(NA_character_)) 
[10:22:07.963]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:07.963]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:07.963]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:07.963]                     .init = FALSE)
[10:22:07.963]                 }
[10:22:07.963]             }
[10:22:07.963]         }
[10:22:07.963]     })
[10:22:07.963]     if (TRUE) {
[10:22:07.963]         base::sink(type = "output", split = FALSE)
[10:22:07.963]         if (TRUE) {
[10:22:07.963]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:07.963]         }
[10:22:07.963]         else {
[10:22:07.963]             ...future.result["stdout"] <- base::list(NULL)
[10:22:07.963]         }
[10:22:07.963]         base::close(...future.stdout)
[10:22:07.963]         ...future.stdout <- NULL
[10:22:07.963]     }
[10:22:07.963]     ...future.result$conditions <- ...future.conditions
[10:22:07.963]     ...future.result$finished <- base::Sys.time()
[10:22:07.963]     ...future.result
[10:22:07.963] }
[10:22:07.965] assign_globals() ...
[10:22:07.965] List of 2
[10:22:07.965]  $ nested   :List of 2
[10:22:07.965]   ..$ a:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[10:22:07.965]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[10:22:07.965]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:22:07.965]   ..$ b:function (..., envir = parent.frame())  
[10:22:07.965]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[10:22:07.965]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:22:07.965]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:22:07.965]  $ strategy2: chr "sequential"
[10:22:07.965]  - attr(*, "where")=List of 2
[10:22:07.965]   ..$ nested   :<environment: R_EmptyEnv> 
[10:22:07.965]   ..$ strategy2:<environment: R_EmptyEnv> 
[10:22:07.965]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:07.965]  - attr(*, "resolved")= logi FALSE
[10:22:07.965]  - attr(*, "total_size")= num 7973
[10:22:07.965]  - attr(*, "already-done")= logi TRUE
[10:22:07.970] - copied ‘nested’ to environment
[10:22:07.970] - copied ‘strategy2’ to environment
[10:22:07.970] assign_globals() ... done
[10:22:07.970] requestCore(): workers = 2
[10:22:07.973] MulticoreFuture started
[10:22:07.973] - Launch lazy future ... done
[10:22:07.973] run() for ‘MulticoreFuture’ ... done
[10:22:07.974] result() for MulticoreFuture ...
[10:22:07.974] plan(): Setting new future strategy stack:
[10:22:07.974] List of future strategies:
[10:22:07.974] 1. sequential:
[10:22:07.974]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:07.974]    - tweaked: FALSE
[10:22:07.974]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:07.975] plan(): nbrOfWorkers() = 1
[10:22:08.013] plan(): Setting new future strategy stack:
[10:22:08.013] List of future strategies:
[10:22:08.013] 1. multicore:
[10:22:08.013]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:08.013]    - tweaked: FALSE
[10:22:08.013]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:08.013] 2. sequential:
[10:22:08.013]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:08.013]    - tweaked: FALSE
[10:22:08.013]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:08.016] plan(): nbrOfWorkers() = 2
[10:22:08.017] result() for MulticoreFuture ...
[10:22:08.017] result() for MulticoreFuture ... done
[10:22:08.017] signalConditions() ...
[10:22:08.017]  - include = ‘immediateCondition’
[10:22:08.018]  - exclude = 
[10:22:08.018]  - resignal = FALSE
[10:22:08.018]  - Number of conditions: 54
[10:22:08.018] signalConditions() ... done
[10:22:08.018] result() for MulticoreFuture ... done
[10:22:08.018] result() for MulticoreFuture ...
[10:22:08.018] result() for MulticoreFuture ... done
[10:22:08.018] signalConditions() ...
[10:22:08.019]  - include = ‘immediateCondition’
[10:22:08.019]  - exclude = 
[10:22:08.019]  - resignal = FALSE
[10:22:08.019]  - Number of conditions: 54
[10:22:08.019] signalConditions() ... done
[10:22:08.019] Future state: ‘finished’
[10:22:08.019] result() for MulticoreFuture ...
[10:22:08.019] result() for MulticoreFuture ... done
[10:22:08.019] signalConditions() ...
[10:22:08.020]  - include = ‘condition’
[10:22:08.020]  - exclude = ‘immediateCondition’
[10:22:08.020]  - resignal = TRUE
[10:22:08.020]  - Number of conditions: 54
[10:22:08.020]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.977] getGlobalsAndPackages() ...
[10:22:08.020]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.977] Searching for globals...
[10:22:08.020]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.985] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[10:22:08.020]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.985] Searching for globals ... DONE
[10:22:08.021]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.985] Resolving globals: FALSE
[10:22:08.021]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.986] The total size of the 3 globals is 3.58 KiB (3661 bytes)
[10:22:08.021]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.987] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 3.58 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (1.77 KiB of class ‘list’), ‘plan_a’ (1.77 KiB of class ‘list’) and ‘a’ (35 bytes of class ‘numeric’)
[10:22:08.021]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.987] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[10:22:08.021]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.987] 
[10:22:08.021]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.987] getGlobalsAndPackages() ... DONE
[10:22:08.021]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.988] run() for ‘Future’ ...
[10:22:08.022]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.988] - state: ‘created’
[10:22:08.022]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.989] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:08.022]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.989] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:08.022]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.989] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:08.022]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.989]   - Field: ‘label’
[10:22:08.022]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.990]   - Field: ‘local’
[10:22:08.022]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.990]   - Field: ‘owner’
[10:22:08.023]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.990]   - Field: ‘envir’
[10:22:08.023]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.990]   - Field: ‘packages’
[10:22:08.023]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.990]   - Field: ‘gc’
[10:22:08.023]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.990]   - Field: ‘conditions’
[10:22:08.023]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.990]   - Field: ‘expr’
[10:22:08.023]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.991]   - Field: ‘uuid’
[10:22:08.024]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.991]   - Field: ‘seed’
[10:22:08.024]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.991]   - Field: ‘version’
[10:22:08.024]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.991]   - Field: ‘result’
[10:22:08.024]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.991]   - Field: ‘asynchronous’
[10:22:08.024]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.991]   - Field: ‘calls’
[10:22:08.024]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.991]   - Field: ‘globals’
[10:22:08.024]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.992]   - Field: ‘stdout’
[10:22:08.024]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.992]   - Field: ‘earlySignal’
[10:22:08.025]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.992]   - Field: ‘lazy’
[10:22:08.025]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.992]   - Field: ‘state’
[10:22:08.025]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.992] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:08.025]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.992] - Launch lazy future ...
[10:22:08.025]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.993] Packages needed by the future expression (n = 0): <none>
[10:22:08.025]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.993] Packages needed by future strategies (n = 0): <none>
[10:22:08.026]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.994] {
[10:22:07.994]     {
[10:22:07.994]         {
[10:22:07.994]             ...future.startTime <- base::Sys.time()
[10:22:07.994]             {
[10:22:07.994]                 {
[10:22:07.994]                   {
[10:22:07.994]                     base::local({
[10:22:07.994]                       has_future <- base::requireNamespace("future", 
[10:22:07.994]                         quietly = TRUE)
[10:22:07.994]                       if (has_future) {
[10:22:07.994]                         ns <- base::getNamespace("future")
[10:22:07.994]                         version <- ns[[".package"]][["version"]]
[10:22:07.994]                         if (is.null(version)) 
[10:22:07.994]                           version <- utils::packageVersion("future")
[10:22:07.994]                       }
[10:22:07.994]                       else {
[10:22:07.994]                         version <- NULL
[10:22:07.994]                       }
[10:22:07.994]                       if (!has_future || version < "1.8.0") {
[10:22:07.994]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:07.994]                           "", base::R.version$version.string), 
[10:22:07.994]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:07.994]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:07.994]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:07.994]                             "release", "version")], collapse = " "), 
[10:22:07.994]                           hostname = base::Sys.info()[["nodename"]])
[10:22:07.994]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:07.994]                           info)
[10:22:07.994]                         info <- base::paste(info, collapse = "; ")
[10:22:07.994]                         if (!has_future) {
[10:22:07.994]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:07.994]                             info)
[10:22:07.994]                         }
[10:22:07.994]                         else {
[10:22:07.994]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:07.994]                             info, version)
[10:22:07.994]                         }
[10:22:07.994]                         base::stop(msg)
[10:22:07.994]                       }
[10:22:07.994]                     })
[10:22:07.994]                   }
[10:22:07.994]                   ...future.strategy.old <- future::plan("list")
[10:22:07.994]                   options(future.plan = NULL)
[10:22:07.994]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:07.994]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:07.994]                 }
[10:22:07.994]                 ...future.workdir <- getwd()
[10:22:07.994]             }
[10:22:07.994]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:07.994]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:07.994]         }
[10:22:07.994]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:07.994]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:07.994]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:07.994]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:07.994]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:07.994]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:07.994]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:07.994]             base::names(...future.oldOptions))
[10:22:07.994]     }
[10:22:07.994]     if (FALSE) {
[10:22:07.994]     }
[10:22:07.994]     else {
[10:22:07.994]         if (TRUE) {
[10:22:07.994]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:07.994]                 open = "w")
[10:22:07.994]         }
[10:22:07.994]         else {
[10:22:07.994]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:07.994]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:07.994]         }
[10:22:07.994]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:07.994]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:07.994]             base::sink(type = "output", split = FALSE)
[10:22:07.994]             base::close(...future.stdout)
[10:22:07.994]         }, add = TRUE)
[10:22:07.994]     }
[10:22:07.994]     ...future.frame <- base::sys.nframe()
[10:22:07.994]     ...future.conditions <- base::list()
[10:22:07.994]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:07.994]     if (FALSE) {
[10:22:07.994]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:07.994]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:07.994]     }
[10:22:07.994]     ...future.result <- base::tryCatch({
[10:22:07.994]         base::withCallingHandlers({
[10:22:07.994]             ...future.value <- base::withVisible(base::local({
[10:22:07.994]                 b <- 2L
[10:22:07.994]                 plan_b <- future::plan("list")
[10:22:07.994]                 nested_b <- nested_a[-1]
[10:22:07.994]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:22:07.994]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[10:22:07.994]                   "sequential"))
[10:22:07.994]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:22:07.994]                   b = b, nested_b = nested_b, plan_b = plan_b)
[10:22:07.994]             }))
[10:22:07.994]             future::FutureResult(value = ...future.value$value, 
[10:22:07.994]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:07.994]                   ...future.rng), globalenv = if (FALSE) 
[10:22:07.994]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:07.994]                     ...future.globalenv.names))
[10:22:07.994]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:07.994]         }, condition = base::local({
[10:22:07.994]             c <- base::c
[10:22:07.994]             inherits <- base::inherits
[10:22:07.994]             invokeRestart <- base::invokeRestart
[10:22:07.994]             length <- base::length
[10:22:07.994]             list <- base::list
[10:22:07.994]             seq.int <- base::seq.int
[10:22:07.994]             signalCondition <- base::signalCondition
[10:22:07.994]             sys.calls <- base::sys.calls
[10:22:07.994]             `[[` <- base::`[[`
[10:22:07.994]             `+` <- base::`+`
[10:22:07.994]             `<<-` <- base::`<<-`
[10:22:07.994]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:07.994]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:07.994]                   3L)]
[10:22:07.994]             }
[10:22:07.994]             function(cond) {
[10:22:07.994]                 is_error <- inherits(cond, "error")
[10:22:07.994]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:07.994]                   NULL)
[10:22:07.994]                 if (is_error) {
[10:22:07.994]                   sessionInformation <- function() {
[10:22:07.994]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:07.994]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:07.994]                       search = base::search(), system = base::Sys.info())
[10:22:07.994]                   }
[10:22:07.994]                   ...future.conditions[[length(...future.conditions) + 
[10:22:07.994]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:07.994]                     cond$call), session = sessionInformation(), 
[10:22:07.994]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:07.994]                   signalCondition(cond)
[10:22:07.994]                 }
[10:22:07.994]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:07.994]                 "immediateCondition"))) {
[10:22:07.994]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:07.994]                   ...future.conditions[[length(...future.conditions) + 
[10:22:07.994]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:07.994]                   if (TRUE && !signal) {
[10:22:07.994]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:07.994]                     {
[10:22:07.994]                       inherits <- base::inherits
[10:22:07.994]                       invokeRestart <- base::invokeRestart
[10:22:07.994]                       is.null <- base::is.null
[10:22:07.994]                       muffled <- FALSE
[10:22:07.994]                       if (inherits(cond, "message")) {
[10:22:07.994]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:07.994]                         if (muffled) 
[10:22:07.994]                           invokeRestart("muffleMessage")
[10:22:07.994]                       }
[10:22:07.994]                       else if (inherits(cond, "warning")) {
[10:22:07.994]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:07.994]                         if (muffled) 
[10:22:07.994]                           invokeRestart("muffleWarning")
[10:22:07.994]                       }
[10:22:07.994]                       else if (inherits(cond, "condition")) {
[10:22:07.994]                         if (!is.null(pattern)) {
[10:22:07.994]                           computeRestarts <- base::computeRestarts
[10:22:07.994]                           grepl <- base::grepl
[10:22:07.994]                           restarts <- computeRestarts(cond)
[10:22:07.994]                           for (restart in restarts) {
[10:22:07.994]                             name <- restart$name
[10:22:07.994]                             if (is.null(name)) 
[10:22:07.994]                               next
[10:22:07.994]                             if (!grepl(pattern, name)) 
[10:22:07.994]                               next
[10:22:07.994]                             invokeRestart(restart)
[10:22:07.994]                             muffled <- TRUE
[10:22:07.994]                             break
[10:22:07.994]                           }
[10:22:07.994]                         }
[10:22:07.994]                       }
[10:22:07.994]                       invisible(muffled)
[10:22:07.994]                     }
[10:22:07.994]                     muffleCondition(cond, pattern = "^muffle")
[10:22:07.994]                   }
[10:22:07.994]                 }
[10:22:07.994]                 else {
[10:22:07.994]                   if (TRUE) {
[10:22:07.994]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:07.994]                     {
[10:22:07.994]                       inherits <- base::inherits
[10:22:07.994]                       invokeRestart <- base::invokeRestart
[10:22:07.994]                       is.null <- base::is.null
[10:22:07.994]                       muffled <- FALSE
[10:22:07.994]                       if (inherits(cond, "message")) {
[10:22:07.994]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:07.994]                         if (muffled) 
[10:22:07.994]                           invokeRestart("muffleMessage")
[10:22:07.994]                       }
[10:22:07.994]                       else if (inherits(cond, "warning")) {
[10:22:07.994]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:07.994]                         if (muffled) 
[10:22:07.994]                           invokeRestart("muffleWarning")
[10:22:07.994]                       }
[10:22:07.994]                       else if (inherits(cond, "condition")) {
[10:22:07.994]                         if (!is.null(pattern)) {
[10:22:07.994]                           computeRestarts <- base::computeRestarts
[10:22:07.994]                           grepl <- base::grepl
[10:22:07.994]                           restarts <- computeRestarts(cond)
[10:22:07.994]                           for (restart in restarts) {
[10:22:07.994]                             name <- restart$name
[10:22:07.994]                             if (is.null(name)) 
[10:22:07.994]                               next
[10:22:07.994]                             if (!grepl(pattern, name)) 
[10:22:07.994]                               next
[10:22:07.994]                             invokeRestart(restart)
[10:22:07.994]                             muffled <- TRUE
[10:22:07.994]                             break
[10:22:07.994]                           }
[10:22:07.994]                         }
[10:22:07.994]                       }
[10:22:07.994]                       invisible(muffled)
[10:22:07.994]                     }
[10:22:07.994]                     muffleCondition(cond, pattern = "^muffle")
[10:22:07.994]                   }
[10:22:07.994]                 }
[10:22:07.994]             }
[10:22:07.994]         }))
[10:22:07.994]     }, error = function(ex) {
[10:22:07.994]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:07.994]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:07.994]                 ...future.rng), started = ...future.startTime, 
[10:22:07.994]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:07.994]             version = "1.8"), class = "FutureResult")
[10:22:07.994]     }, finally = {
[10:22:07.994]         if (!identical(...future.workdir, getwd())) 
[10:22:07.994]             setwd(...future.workdir)
[10:22:07.994]         {
[10:22:07.994]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:07.994]                 ...future.oldOptions$nwarnings <- NULL
[10:22:07.994]             }
[10:22:07.994]             base::options(...future.oldOptions)
[10:22:07.994]             if (.Platform$OS.type == "windows") {
[10:22:07.994]                 old_names <- names(...future.oldEnvVars)
[10:22:07.994]                 envs <- base::Sys.getenv()
[10:22:07.994]                 names <- names(envs)
[10:22:07.994]                 common <- intersect(names, old_names)
[10:22:07.994]                 added <- setdiff(names, old_names)
[10:22:07.994]                 removed <- setdiff(old_names, names)
[10:22:07.994]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:07.994]                   envs[common]]
[10:22:07.994]                 NAMES <- toupper(changed)
[10:22:07.994]                 args <- list()
[10:22:07.994]                 for (kk in seq_along(NAMES)) {
[10:22:07.994]                   name <- changed[[kk]]
[10:22:07.994]                   NAME <- NAMES[[kk]]
[10:22:07.994]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:07.994]                     next
[10:22:07.994]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:07.994]                 }
[10:22:07.994]                 NAMES <- toupper(added)
[10:22:07.994]                 for (kk in seq_along(NAMES)) {
[10:22:07.994]                   name <- added[[kk]]
[10:22:07.994]                   NAME <- NAMES[[kk]]
[10:22:07.994]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:07.994]                     next
[10:22:07.994]                   args[[name]] <- ""
[10:22:07.994]                 }
[10:22:07.994]                 NAMES <- toupper(removed)
[10:22:07.994]                 for (kk in seq_along(NAMES)) {
[10:22:07.994]                   name <- removed[[kk]]
[10:22:07.994]                   NAME <- NAMES[[kk]]
[10:22:07.994]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:07.994]                     next
[10:22:07.994]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:07.994]                 }
[10:22:07.994]                 if (length(args) > 0) 
[10:22:07.994]                   base::do.call(base::Sys.setenv, args = args)
[10:22:07.994]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:07.994]             }
[10:22:07.994]             else {
[10:22:07.994]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:07.994]             }
[10:22:07.994]             {
[10:22:07.994]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:07.994]                   0L) {
[10:22:07.994]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:07.994]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:07.994]                   base::options(opts)
[10:22:07.994]                 }
[10:22:07.994]                 {
[10:22:07.994]                   {
[10:22:07.994]                     NULL
[10:22:07.994]                     RNGkind("Mersenne-Twister")
[10:22:07.994]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:07.994]                       inherits = FALSE)
[10:22:07.994]                   }
[10:22:07.994]                   options(future.plan = NULL)
[10:22:07.994]                   if (is.na(NA_character_)) 
[10:22:07.994]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:07.994]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:07.994]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:07.994]                     .init = FALSE)
[10:22:07.994]                 }
[10:22:07.994]             }
[10:22:07.994]         }
[10:22:07.994]     })
[10:22:07.994]     if (TRUE) {
[10:22:07.994]         base::sink(type = "output", split = FALSE)
[10:22:07.994]         if (TRUE) {
[10:22:07.994]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:07.994]         }
[10:22:07.994]         else {
[10:22:07.994]             ...future.result["stdout"] <- base::list(NULL)
[10:22:07.994]         }
[10:22:07.994]         base::close(...future.stdout)
[10:22:07.994]         ...future.stdout <- NULL
[10:22:07.994]     }
[10:22:07.994]     ...future.result$conditions <- ...future.conditions
[10:22:07.994]     ...future.result$finished <- base::Sys.time()
[10:22:07.994]     ...future.result
[10:22:07.994] }
[10:22:08.026]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.996] assign_globals() ...
[10:22:08.026]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:07.996] List of 3
[10:22:07.996]  $ nested_a:List of 1
[10:22:07.996]   ..$ b:function (..., envir = parent.frame())  
[10:22:07.996]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[10:22:07.996]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:22:07.996]  $ a       : int 1
[10:22:07.996]  $ plan_a  :List of 1
[10:22:07.996]   ..$ b:function (..., envir = parent.frame())  
[10:22:07.996]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[10:22:07.996]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:22:07.996]  - attr(*, "where")=List of 3
[10:22:07.996]   ..$ nested_a:<environment: R_EmptyEnv> 
[10:22:07.996]   ..$ a       :<environment: R_EmptyEnv> 
[10:22:07.996]   ..$ plan_a  :<environment: R_EmptyEnv> 
[10:22:07.996]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:07.996]  - attr(*, "resolved")= logi FALSE
[10:22:07.996]  - attr(*, "total_size")= num 3661
[10:22:07.996]  - attr(*, "already-done")= logi TRUE
[10:22:08.026]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.008] - copied ‘nested_a’ to environment
[10:22:08.026]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.008] - copied ‘a’ to environment
[10:22:08.026]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.008] - copied ‘plan_a’ to environment
[10:22:08.027]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.009] assign_globals() ... done
[10:22:08.027]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.009] plan(): Setting new future strategy stack:
[10:22:08.027]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.009] List of future strategies:
[10:22:08.009] 1. sequential:
[10:22:08.009]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:08.009]    - tweaked: FALSE
[10:22:08.009]    - call: NULL
[10:22:08.027]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.010] plan(): nbrOfWorkers() = 1
[10:22:08.027]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.011] plan(): Setting new future strategy stack:
[10:22:08.027]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.011] List of future strategies:
[10:22:08.011] 1. sequential:
[10:22:08.011]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:08.011]    - tweaked: FALSE
[10:22:08.011]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:08.027]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.012] plan(): nbrOfWorkers() = 1
[10:22:08.028]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.012] SequentialFuture started (and completed)
[10:22:08.028]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.012] - Launch lazy future ... done
[10:22:08.028]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.012] run() for ‘SequentialFuture’ ... done
[10:22:08.028] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:22:08.037] getGlobalsAndPackages() ...
[10:22:08.037] Searching for globals...
[10:22:08.039] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[10:22:08.039] Searching for globals ... DONE
[10:22:08.039] Resolving globals: FALSE
[10:22:08.040] The total size of the 1 globals is 356 bytes (356 bytes)
[10:22:08.040] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[10:22:08.040] - globals: [1] ‘data’
[10:22:08.040] - packages: [1] ‘future’
[10:22:08.041] getGlobalsAndPackages() ... DONE
[10:22:08.041] run() for ‘Future’ ...
[10:22:08.041] - state: ‘created’
[10:22:08.041] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:08.043] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:08.043] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:08.044]   - Field: ‘label’
[10:22:08.044]   - Field: ‘local’
[10:22:08.044]   - Field: ‘owner’
[10:22:08.044]   - Field: ‘envir’
[10:22:08.044]   - Field: ‘workers’
[10:22:08.044]   - Field: ‘packages’
[10:22:08.044]   - Field: ‘gc’
[10:22:08.044]   - Field: ‘job’
[10:22:08.044]   - Field: ‘conditions’
[10:22:08.044]   - Field: ‘expr’
[10:22:08.045]   - Field: ‘uuid’
[10:22:08.045]   - Field: ‘seed’
[10:22:08.045]   - Field: ‘version’
[10:22:08.045]   - Field: ‘result’
[10:22:08.045]   - Field: ‘asynchronous’
[10:22:08.045]   - Field: ‘calls’
[10:22:08.045]   - Field: ‘globals’
[10:22:08.045]   - Field: ‘stdout’
[10:22:08.045]   - Field: ‘earlySignal’
[10:22:08.045]   - Field: ‘lazy’
[10:22:08.046]   - Field: ‘state’
[10:22:08.046] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:08.046] - Launch lazy future ...
[10:22:08.046] Packages needed by the future expression (n = 1): ‘future’
[10:22:08.046] Packages needed by future strategies (n = 1): ‘future’
[10:22:08.047] {
[10:22:08.047]     {
[10:22:08.047]         {
[10:22:08.047]             ...future.startTime <- base::Sys.time()
[10:22:08.047]             {
[10:22:08.047]                 {
[10:22:08.047]                   {
[10:22:08.047]                     {
[10:22:08.047]                       {
[10:22:08.047]                         base::local({
[10:22:08.047]                           has_future <- base::requireNamespace("future", 
[10:22:08.047]                             quietly = TRUE)
[10:22:08.047]                           if (has_future) {
[10:22:08.047]                             ns <- base::getNamespace("future")
[10:22:08.047]                             version <- ns[[".package"]][["version"]]
[10:22:08.047]                             if (is.null(version)) 
[10:22:08.047]                               version <- utils::packageVersion("future")
[10:22:08.047]                           }
[10:22:08.047]                           else {
[10:22:08.047]                             version <- NULL
[10:22:08.047]                           }
[10:22:08.047]                           if (!has_future || version < "1.8.0") {
[10:22:08.047]                             info <- base::c(r_version = base::gsub("R version ", 
[10:22:08.047]                               "", base::R.version$version.string), 
[10:22:08.047]                               platform = base::sprintf("%s (%s-bit)", 
[10:22:08.047]                                 base::R.version$platform, 8 * 
[10:22:08.047]                                   base::.Machine$sizeof.pointer), 
[10:22:08.047]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:08.047]                                 "release", "version")], collapse = " "), 
[10:22:08.047]                               hostname = base::Sys.info()[["nodename"]])
[10:22:08.047]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:22:08.047]                               info)
[10:22:08.047]                             info <- base::paste(info, collapse = "; ")
[10:22:08.047]                             if (!has_future) {
[10:22:08.047]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:08.047]                                 info)
[10:22:08.047]                             }
[10:22:08.047]                             else {
[10:22:08.047]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:08.047]                                 info, version)
[10:22:08.047]                             }
[10:22:08.047]                             base::stop(msg)
[10:22:08.047]                           }
[10:22:08.047]                         })
[10:22:08.047]                       }
[10:22:08.047]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:08.047]                       base::options(mc.cores = 1L)
[10:22:08.047]                     }
[10:22:08.047]                     base::local({
[10:22:08.047]                       for (pkg in "future") {
[10:22:08.047]                         base::loadNamespace(pkg)
[10:22:08.047]                         base::library(pkg, character.only = TRUE)
[10:22:08.047]                       }
[10:22:08.047]                     })
[10:22:08.047]                   }
[10:22:08.047]                   ...future.strategy.old <- future::plan("list")
[10:22:08.047]                   options(future.plan = NULL)
[10:22:08.047]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:08.047]                   future::plan(list(b = function (..., envir = parent.frame()) 
[10:22:08.047]                   {
[10:22:08.047]                     future <- SequentialFuture(..., envir = envir)
[10:22:08.047]                     if (!future$lazy) 
[10:22:08.047]                       future <- run(future)
[10:22:08.047]                     invisible(future)
[10:22:08.047]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:08.047]                 }
[10:22:08.047]                 ...future.workdir <- getwd()
[10:22:08.047]             }
[10:22:08.047]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:08.047]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:08.047]         }
[10:22:08.047]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:08.047]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:08.047]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:08.047]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:08.047]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:08.047]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:08.047]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:08.047]             base::names(...future.oldOptions))
[10:22:08.047]     }
[10:22:08.047]     if (FALSE) {
[10:22:08.047]     }
[10:22:08.047]     else {
[10:22:08.047]         if (TRUE) {
[10:22:08.047]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:08.047]                 open = "w")
[10:22:08.047]         }
[10:22:08.047]         else {
[10:22:08.047]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:08.047]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:08.047]         }
[10:22:08.047]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:08.047]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:08.047]             base::sink(type = "output", split = FALSE)
[10:22:08.047]             base::close(...future.stdout)
[10:22:08.047]         }, add = TRUE)
[10:22:08.047]     }
[10:22:08.047]     ...future.frame <- base::sys.nframe()
[10:22:08.047]     ...future.conditions <- base::list()
[10:22:08.047]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:08.047]     if (FALSE) {
[10:22:08.047]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:08.047]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:08.047]     }
[10:22:08.047]     ...future.result <- base::tryCatch({
[10:22:08.047]         base::withCallingHandlers({
[10:22:08.047]             ...future.value <- base::withVisible(base::local({
[10:22:08.047]                 withCallingHandlers({
[10:22:08.047]                   {
[10:22:08.047]                     value(future(subset(data, a == 2)))
[10:22:08.047]                   }
[10:22:08.047]                 }, immediateCondition = function(cond) {
[10:22:08.047]                   save_rds <- function (object, pathname, ...) 
[10:22:08.047]                   {
[10:22:08.047]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:08.047]                     if (file_test("-f", pathname_tmp)) {
[10:22:08.047]                       fi_tmp <- file.info(pathname_tmp)
[10:22:08.047]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:08.047]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:08.047]                         fi_tmp[["mtime"]])
[10:22:08.047]                     }
[10:22:08.047]                     tryCatch({
[10:22:08.047]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:08.047]                     }, error = function(ex) {
[10:22:08.047]                       msg <- conditionMessage(ex)
[10:22:08.047]                       fi_tmp <- file.info(pathname_tmp)
[10:22:08.047]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:08.047]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:08.047]                         fi_tmp[["mtime"]], msg)
[10:22:08.047]                       ex$message <- msg
[10:22:08.047]                       stop(ex)
[10:22:08.047]                     })
[10:22:08.047]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:08.047]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:08.047]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:08.047]                       fi_tmp <- file.info(pathname_tmp)
[10:22:08.047]                       fi <- file.info(pathname)
[10:22:08.047]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:08.047]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:08.047]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:08.047]                         fi[["size"]], fi[["mtime"]])
[10:22:08.047]                       stop(msg)
[10:22:08.047]                     }
[10:22:08.047]                     invisible(pathname)
[10:22:08.047]                   }
[10:22:08.047]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:08.047]                     rootPath = tempdir()) 
[10:22:08.047]                   {
[10:22:08.047]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:08.047]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:08.047]                       tmpdir = path, fileext = ".rds")
[10:22:08.047]                     save_rds(obj, file)
[10:22:08.047]                   }
[10:22:08.047]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4kEgVJ/.future/immediateConditions")
[10:22:08.047]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:08.047]                   {
[10:22:08.047]                     inherits <- base::inherits
[10:22:08.047]                     invokeRestart <- base::invokeRestart
[10:22:08.047]                     is.null <- base::is.null
[10:22:08.047]                     muffled <- FALSE
[10:22:08.047]                     if (inherits(cond, "message")) {
[10:22:08.047]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:08.047]                       if (muffled) 
[10:22:08.047]                         invokeRestart("muffleMessage")
[10:22:08.047]                     }
[10:22:08.047]                     else if (inherits(cond, "warning")) {
[10:22:08.047]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:08.047]                       if (muffled) 
[10:22:08.047]                         invokeRestart("muffleWarning")
[10:22:08.047]                     }
[10:22:08.047]                     else if (inherits(cond, "condition")) {
[10:22:08.047]                       if (!is.null(pattern)) {
[10:22:08.047]                         computeRestarts <- base::computeRestarts
[10:22:08.047]                         grepl <- base::grepl
[10:22:08.047]                         restarts <- computeRestarts(cond)
[10:22:08.047]                         for (restart in restarts) {
[10:22:08.047]                           name <- restart$name
[10:22:08.047]                           if (is.null(name)) 
[10:22:08.047]                             next
[10:22:08.047]                           if (!grepl(pattern, name)) 
[10:22:08.047]                             next
[10:22:08.047]                           invokeRestart(restart)
[10:22:08.047]                           muffled <- TRUE
[10:22:08.047]                           break
[10:22:08.047]                         }
[10:22:08.047]                       }
[10:22:08.047]                     }
[10:22:08.047]                     invisible(muffled)
[10:22:08.047]                   }
[10:22:08.047]                   muffleCondition(cond)
[10:22:08.047]                 })
[10:22:08.047]             }))
[10:22:08.047]             future::FutureResult(value = ...future.value$value, 
[10:22:08.047]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:08.047]                   ...future.rng), globalenv = if (FALSE) 
[10:22:08.047]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:08.047]                     ...future.globalenv.names))
[10:22:08.047]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:08.047]         }, condition = base::local({
[10:22:08.047]             c <- base::c
[10:22:08.047]             inherits <- base::inherits
[10:22:08.047]             invokeRestart <- base::invokeRestart
[10:22:08.047]             length <- base::length
[10:22:08.047]             list <- base::list
[10:22:08.047]             seq.int <- base::seq.int
[10:22:08.047]             signalCondition <- base::signalCondition
[10:22:08.047]             sys.calls <- base::sys.calls
[10:22:08.047]             `[[` <- base::`[[`
[10:22:08.047]             `+` <- base::`+`
[10:22:08.047]             `<<-` <- base::`<<-`
[10:22:08.047]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:08.047]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:08.047]                   3L)]
[10:22:08.047]             }
[10:22:08.047]             function(cond) {
[10:22:08.047]                 is_error <- inherits(cond, "error")
[10:22:08.047]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:08.047]                   NULL)
[10:22:08.047]                 if (is_error) {
[10:22:08.047]                   sessionInformation <- function() {
[10:22:08.047]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:08.047]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:08.047]                       search = base::search(), system = base::Sys.info())
[10:22:08.047]                   }
[10:22:08.047]                   ...future.conditions[[length(...future.conditions) + 
[10:22:08.047]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:08.047]                     cond$call), session = sessionInformation(), 
[10:22:08.047]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:08.047]                   signalCondition(cond)
[10:22:08.047]                 }
[10:22:08.047]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:08.047]                 "immediateCondition"))) {
[10:22:08.047]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:08.047]                   ...future.conditions[[length(...future.conditions) + 
[10:22:08.047]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:08.047]                   if (TRUE && !signal) {
[10:22:08.047]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:08.047]                     {
[10:22:08.047]                       inherits <- base::inherits
[10:22:08.047]                       invokeRestart <- base::invokeRestart
[10:22:08.047]                       is.null <- base::is.null
[10:22:08.047]                       muffled <- FALSE
[10:22:08.047]                       if (inherits(cond, "message")) {
[10:22:08.047]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:08.047]                         if (muffled) 
[10:22:08.047]                           invokeRestart("muffleMessage")
[10:22:08.047]                       }
[10:22:08.047]                       else if (inherits(cond, "warning")) {
[10:22:08.047]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:08.047]                         if (muffled) 
[10:22:08.047]                           invokeRestart("muffleWarning")
[10:22:08.047]                       }
[10:22:08.047]                       else if (inherits(cond, "condition")) {
[10:22:08.047]                         if (!is.null(pattern)) {
[10:22:08.047]                           computeRestarts <- base::computeRestarts
[10:22:08.047]                           grepl <- base::grepl
[10:22:08.047]                           restarts <- computeRestarts(cond)
[10:22:08.047]                           for (restart in restarts) {
[10:22:08.047]                             name <- restart$name
[10:22:08.047]                             if (is.null(name)) 
[10:22:08.047]                               next
[10:22:08.047]                             if (!grepl(pattern, name)) 
[10:22:08.047]                               next
[10:22:08.047]                             invokeRestart(restart)
[10:22:08.047]                             muffled <- TRUE
[10:22:08.047]                             break
[10:22:08.047]                           }
[10:22:08.047]                         }
[10:22:08.047]                       }
[10:22:08.047]                       invisible(muffled)
[10:22:08.047]                     }
[10:22:08.047]                     muffleCondition(cond, pattern = "^muffle")
[10:22:08.047]                   }
[10:22:08.047]                 }
[10:22:08.047]                 else {
[10:22:08.047]                   if (TRUE) {
[10:22:08.047]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:08.047]                     {
[10:22:08.047]                       inherits <- base::inherits
[10:22:08.047]                       invokeRestart <- base::invokeRestart
[10:22:08.047]                       is.null <- base::is.null
[10:22:08.047]                       muffled <- FALSE
[10:22:08.047]                       if (inherits(cond, "message")) {
[10:22:08.047]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:08.047]                         if (muffled) 
[10:22:08.047]                           invokeRestart("muffleMessage")
[10:22:08.047]                       }
[10:22:08.047]                       else if (inherits(cond, "warning")) {
[10:22:08.047]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:08.047]                         if (muffled) 
[10:22:08.047]                           invokeRestart("muffleWarning")
[10:22:08.047]                       }
[10:22:08.047]                       else if (inherits(cond, "condition")) {
[10:22:08.047]                         if (!is.null(pattern)) {
[10:22:08.047]                           computeRestarts <- base::computeRestarts
[10:22:08.047]                           grepl <- base::grepl
[10:22:08.047]                           restarts <- computeRestarts(cond)
[10:22:08.047]                           for (restart in restarts) {
[10:22:08.047]                             name <- restart$name
[10:22:08.047]                             if (is.null(name)) 
[10:22:08.047]                               next
[10:22:08.047]                             if (!grepl(pattern, name)) 
[10:22:08.047]                               next
[10:22:08.047]                             invokeRestart(restart)
[10:22:08.047]                             muffled <- TRUE
[10:22:08.047]                             break
[10:22:08.047]                           }
[10:22:08.047]                         }
[10:22:08.047]                       }
[10:22:08.047]                       invisible(muffled)
[10:22:08.047]                     }
[10:22:08.047]                     muffleCondition(cond, pattern = "^muffle")
[10:22:08.047]                   }
[10:22:08.047]                 }
[10:22:08.047]             }
[10:22:08.047]         }))
[10:22:08.047]     }, error = function(ex) {
[10:22:08.047]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:08.047]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:08.047]                 ...future.rng), started = ...future.startTime, 
[10:22:08.047]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:08.047]             version = "1.8"), class = "FutureResult")
[10:22:08.047]     }, finally = {
[10:22:08.047]         if (!identical(...future.workdir, getwd())) 
[10:22:08.047]             setwd(...future.workdir)
[10:22:08.047]         {
[10:22:08.047]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:08.047]                 ...future.oldOptions$nwarnings <- NULL
[10:22:08.047]             }
[10:22:08.047]             base::options(...future.oldOptions)
[10:22:08.047]             if (.Platform$OS.type == "windows") {
[10:22:08.047]                 old_names <- names(...future.oldEnvVars)
[10:22:08.047]                 envs <- base::Sys.getenv()
[10:22:08.047]                 names <- names(envs)
[10:22:08.047]                 common <- intersect(names, old_names)
[10:22:08.047]                 added <- setdiff(names, old_names)
[10:22:08.047]                 removed <- setdiff(old_names, names)
[10:22:08.047]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:08.047]                   envs[common]]
[10:22:08.047]                 NAMES <- toupper(changed)
[10:22:08.047]                 args <- list()
[10:22:08.047]                 for (kk in seq_along(NAMES)) {
[10:22:08.047]                   name <- changed[[kk]]
[10:22:08.047]                   NAME <- NAMES[[kk]]
[10:22:08.047]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:08.047]                     next
[10:22:08.047]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:08.047]                 }
[10:22:08.047]                 NAMES <- toupper(added)
[10:22:08.047]                 for (kk in seq_along(NAMES)) {
[10:22:08.047]                   name <- added[[kk]]
[10:22:08.047]                   NAME <- NAMES[[kk]]
[10:22:08.047]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:08.047]                     next
[10:22:08.047]                   args[[name]] <- ""
[10:22:08.047]                 }
[10:22:08.047]                 NAMES <- toupper(removed)
[10:22:08.047]                 for (kk in seq_along(NAMES)) {
[10:22:08.047]                   name <- removed[[kk]]
[10:22:08.047]                   NAME <- NAMES[[kk]]
[10:22:08.047]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:08.047]                     next
[10:22:08.047]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:08.047]                 }
[10:22:08.047]                 if (length(args) > 0) 
[10:22:08.047]                   base::do.call(base::Sys.setenv, args = args)
[10:22:08.047]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:08.047]             }
[10:22:08.047]             else {
[10:22:08.047]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:08.047]             }
[10:22:08.047]             {
[10:22:08.047]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:08.047]                   0L) {
[10:22:08.047]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:08.047]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:08.047]                   base::options(opts)
[10:22:08.047]                 }
[10:22:08.047]                 {
[10:22:08.047]                   {
[10:22:08.047]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:08.047]                     NULL
[10:22:08.047]                   }
[10:22:08.047]                   options(future.plan = NULL)
[10:22:08.047]                   if (is.na(NA_character_)) 
[10:22:08.047]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:08.047]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:08.047]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:08.047]                     .init = FALSE)
[10:22:08.047]                 }
[10:22:08.047]             }
[10:22:08.047]         }
[10:22:08.047]     })
[10:22:08.047]     if (TRUE) {
[10:22:08.047]         base::sink(type = "output", split = FALSE)
[10:22:08.047]         if (TRUE) {
[10:22:08.047]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:08.047]         }
[10:22:08.047]         else {
[10:22:08.047]             ...future.result["stdout"] <- base::list(NULL)
[10:22:08.047]         }
[10:22:08.047]         base::close(...future.stdout)
[10:22:08.047]         ...future.stdout <- NULL
[10:22:08.047]     }
[10:22:08.047]     ...future.result$conditions <- ...future.conditions
[10:22:08.047]     ...future.result$finished <- base::Sys.time()
[10:22:08.047]     ...future.result
[10:22:08.047] }
[10:22:08.049] assign_globals() ...
[10:22:08.049] List of 1
[10:22:08.049]  $ data:'data.frame':	3 obs. of  2 variables:
[10:22:08.049]   ..$ a: int [1:3] 1 2 3
[10:22:08.049]   ..$ b: int [1:3] 3 2 1
[10:22:08.049]  - attr(*, "where")=List of 1
[10:22:08.049]   ..$ data:<environment: R_EmptyEnv> 
[10:22:08.049]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:08.049]  - attr(*, "resolved")= logi FALSE
[10:22:08.049]  - attr(*, "total_size")= num 356
[10:22:08.049]  - attr(*, "already-done")= logi TRUE
[10:22:08.053] - copied ‘data’ to environment
[10:22:08.053] assign_globals() ... done
[10:22:08.053] requestCore(): workers = 2
[10:22:08.056] MulticoreFuture started
[10:22:08.056] - Launch lazy future ... done
[10:22:08.056] run() for ‘MulticoreFuture’ ... done
[10:22:08.056] result() for MulticoreFuture ...
[10:22:08.057] plan(): Setting new future strategy stack:
[10:22:08.057] List of future strategies:
[10:22:08.057] 1. sequential:
[10:22:08.057]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:08.057]    - tweaked: FALSE
[10:22:08.057]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:08.058] plan(): nbrOfWorkers() = 1
[10:22:08.085] plan(): Setting new future strategy stack:
[10:22:08.085] List of future strategies:
[10:22:08.085] 1. multicore:
[10:22:08.085]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:08.085]    - tweaked: FALSE
[10:22:08.085]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:08.085] 2. sequential:
[10:22:08.085]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:08.085]    - tweaked: FALSE
[10:22:08.085]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:08.088] plan(): nbrOfWorkers() = 2
[10:22:08.089] result() for MulticoreFuture ...
[10:22:08.090] result() for MulticoreFuture ... done
[10:22:08.090] signalConditions() ...
[10:22:08.090]  - include = ‘immediateCondition’
[10:22:08.090]  - exclude = 
[10:22:08.090]  - resignal = FALSE
[10:22:08.090]  - Number of conditions: 52
[10:22:08.090] signalConditions() ... done
[10:22:08.090] result() for MulticoreFuture ... done
[10:22:08.091] result() for MulticoreFuture ...
[10:22:08.091] result() for MulticoreFuture ... done
[10:22:08.091] signalConditions() ...
[10:22:08.091]  - include = ‘immediateCondition’
[10:22:08.091]  - exclude = 
[10:22:08.091]  - resignal = FALSE
[10:22:08.091]  - Number of conditions: 52
[10:22:08.091] signalConditions() ... done
[10:22:08.091] Future state: ‘finished’
[10:22:08.092] result() for MulticoreFuture ...
[10:22:08.092] result() for MulticoreFuture ... done
[10:22:08.092] signalConditions() ...
[10:22:08.092]  - include = ‘condition’
[10:22:08.092]  - exclude = ‘immediateCondition’
[10:22:08.092]  - resignal = TRUE
[10:22:08.092]  - Number of conditions: 52
[10:22:08.092]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.059] getGlobalsAndPackages() ...
[10:22:08.093]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.060] Searching for globals...
[10:22:08.093]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.062] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[10:22:08.093]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.062] Searching for globals ... DONE
[10:22:08.093]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.062] Resolving globals: FALSE
[10:22:08.093]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.063] The total size of the 1 globals is 356 bytes (356 bytes)
[10:22:08.093]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.064] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[10:22:08.093]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.064] - globals: [1] ‘data’
[10:22:08.094]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.064] 
[10:22:08.094]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.064] getGlobalsAndPackages() ... DONE
[10:22:08.094]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.065] run() for ‘Future’ ...
[10:22:08.094]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.065] - state: ‘created’
[10:22:08.094]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.066] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:22:08.094]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.066] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:08.095]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.066] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:08.095]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.067]   - Field: ‘label’
[10:22:08.095]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.067]   - Field: ‘local’
[10:22:08.095]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.067]   - Field: ‘owner’
[10:22:08.095]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.067]   - Field: ‘envir’
[10:22:08.095]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.067]   - Field: ‘packages’
[10:22:08.096]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.067]   - Field: ‘gc’
[10:22:08.096]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.068]   - Field: ‘conditions’
[10:22:08.096]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.068]   - Field: ‘expr’
[10:22:08.096]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.068]   - Field: ‘uuid’
[10:22:08.096]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.068]   - Field: ‘seed’
[10:22:08.097]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.068]   - Field: ‘version’
[10:22:08.097]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.068]   - Field: ‘result’
[10:22:08.097]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.069]   - Field: ‘asynchronous’
[10:22:08.097]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.069]   - Field: ‘calls’
[10:22:08.097]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.069]   - Field: ‘globals’
[10:22:08.097]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.069]   - Field: ‘stdout’
[10:22:08.098]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.070]   - Field: ‘earlySignal’
[10:22:08.098]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.070]   - Field: ‘lazy’
[10:22:08.098]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.070]   - Field: ‘state’
[10:22:08.098]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.070] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:08.098]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.070] - Launch lazy future ...
[10:22:08.098]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.071] Packages needed by the future expression (n = 0): <none>
[10:22:08.099]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.071] Packages needed by future strategies (n = 0): <none>
[10:22:08.099]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.072] {
[10:22:08.072]     {
[10:22:08.072]         {
[10:22:08.072]             ...future.startTime <- base::Sys.time()
[10:22:08.072]             {
[10:22:08.072]                 {
[10:22:08.072]                   {
[10:22:08.072]                     base::local({
[10:22:08.072]                       has_future <- base::requireNamespace("future", 
[10:22:08.072]                         quietly = TRUE)
[10:22:08.072]                       if (has_future) {
[10:22:08.072]                         ns <- base::getNamespace("future")
[10:22:08.072]                         version <- ns[[".package"]][["version"]]
[10:22:08.072]                         if (is.null(version)) 
[10:22:08.072]                           version <- utils::packageVersion("future")
[10:22:08.072]                       }
[10:22:08.072]                       else {
[10:22:08.072]                         version <- NULL
[10:22:08.072]                       }
[10:22:08.072]                       if (!has_future || version < "1.8.0") {
[10:22:08.072]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:08.072]                           "", base::R.version$version.string), 
[10:22:08.072]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:08.072]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:08.072]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:08.072]                             "release", "version")], collapse = " "), 
[10:22:08.072]                           hostname = base::Sys.info()[["nodename"]])
[10:22:08.072]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:08.072]                           info)
[10:22:08.072]                         info <- base::paste(info, collapse = "; ")
[10:22:08.072]                         if (!has_future) {
[10:22:08.072]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:08.072]                             info)
[10:22:08.072]                         }
[10:22:08.072]                         else {
[10:22:08.072]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:08.072]                             info, version)
[10:22:08.072]                         }
[10:22:08.072]                         base::stop(msg)
[10:22:08.072]                       }
[10:22:08.072]                     })
[10:22:08.072]                   }
[10:22:08.072]                   ...future.strategy.old <- future::plan("list")
[10:22:08.072]                   options(future.plan = NULL)
[10:22:08.072]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:08.072]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:08.072]                 }
[10:22:08.072]                 ...future.workdir <- getwd()
[10:22:08.072]             }
[10:22:08.072]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:08.072]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:08.072]         }
[10:22:08.072]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:08.072]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:08.072]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:08.072]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:08.072]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:08.072]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:08.072]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:08.072]             base::names(...future.oldOptions))
[10:22:08.072]     }
[10:22:08.072]     if (FALSE) {
[10:22:08.072]     }
[10:22:08.072]     else {
[10:22:08.072]         if (TRUE) {
[10:22:08.072]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:08.072]                 open = "w")
[10:22:08.072]         }
[10:22:08.072]         else {
[10:22:08.072]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:08.072]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:08.072]         }
[10:22:08.072]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:08.072]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:08.072]             base::sink(type = "output", split = FALSE)
[10:22:08.072]             base::close(...future.stdout)
[10:22:08.072]         }, add = TRUE)
[10:22:08.072]     }
[10:22:08.072]     ...future.frame <- base::sys.nframe()
[10:22:08.072]     ...future.conditions <- base::list()
[10:22:08.072]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:08.072]     if (FALSE) {
[10:22:08.072]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:08.072]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:08.072]     }
[10:22:08.072]     ...future.result <- base::tryCatch({
[10:22:08.072]         base::withCallingHandlers({
[10:22:08.072]             ...future.value <- base::withVisible(base::local(subset(data, 
[10:22:08.072]                 a == 2)))
[10:22:08.072]             future::FutureResult(value = ...future.value$value, 
[10:22:08.072]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:08.072]                   ...future.rng), globalenv = if (FALSE) 
[10:22:08.072]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:08.072]                     ...future.globalenv.names))
[10:22:08.072]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:08.072]         }, condition = base::local({
[10:22:08.072]             c <- base::c
[10:22:08.072]             inherits <- base::inherits
[10:22:08.072]             invokeRestart <- base::invokeRestart
[10:22:08.072]             length <- base::length
[10:22:08.072]             list <- base::list
[10:22:08.072]             seq.int <- base::seq.int
[10:22:08.072]             signalCondition <- base::signalCondition
[10:22:08.072]             sys.calls <- base::sys.calls
[10:22:08.072]             `[[` <- base::`[[`
[10:22:08.072]             `+` <- base::`+`
[10:22:08.072]             `<<-` <- base::`<<-`
[10:22:08.072]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:08.072]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:08.072]                   3L)]
[10:22:08.072]             }
[10:22:08.072]             function(cond) {
[10:22:08.072]                 is_error <- inherits(cond, "error")
[10:22:08.072]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:08.072]                   NULL)
[10:22:08.072]                 if (is_error) {
[10:22:08.072]                   sessionInformation <- function() {
[10:22:08.072]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:08.072]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:08.072]                       search = base::search(), system = base::Sys.info())
[10:22:08.072]                   }
[10:22:08.072]                   ...future.conditions[[length(...future.conditions) + 
[10:22:08.072]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:08.072]                     cond$call), session = sessionInformation(), 
[10:22:08.072]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:08.072]                   signalCondition(cond)
[10:22:08.072]                 }
[10:22:08.072]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:08.072]                 "immediateCondition"))) {
[10:22:08.072]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:08.072]                   ...future.conditions[[length(...future.conditions) + 
[10:22:08.072]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:08.072]                   if (TRUE && !signal) {
[10:22:08.072]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:08.072]                     {
[10:22:08.072]                       inherits <- base::inherits
[10:22:08.072]                       invokeRestart <- base::invokeRestart
[10:22:08.072]                       is.null <- base::is.null
[10:22:08.072]                       muffled <- FALSE
[10:22:08.072]                       if (inherits(cond, "message")) {
[10:22:08.072]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:08.072]                         if (muffled) 
[10:22:08.072]                           invokeRestart("muffleMessage")
[10:22:08.072]                       }
[10:22:08.072]                       else if (inherits(cond, "warning")) {
[10:22:08.072]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:08.072]                         if (muffled) 
[10:22:08.072]                           invokeRestart("muffleWarning")
[10:22:08.072]                       }
[10:22:08.072]                       else if (inherits(cond, "condition")) {
[10:22:08.072]                         if (!is.null(pattern)) {
[10:22:08.072]                           computeRestarts <- base::computeRestarts
[10:22:08.072]                           grepl <- base::grepl
[10:22:08.072]                           restarts <- computeRestarts(cond)
[10:22:08.072]                           for (restart in restarts) {
[10:22:08.072]                             name <- restart$name
[10:22:08.072]                             if (is.null(name)) 
[10:22:08.072]                               next
[10:22:08.072]                             if (!grepl(pattern, name)) 
[10:22:08.072]                               next
[10:22:08.072]                             invokeRestart(restart)
[10:22:08.072]                             muffled <- TRUE
[10:22:08.072]                             break
[10:22:08.072]                           }
[10:22:08.072]                         }
[10:22:08.072]                       }
[10:22:08.072]                       invisible(muffled)
[10:22:08.072]                     }
[10:22:08.072]                     muffleCondition(cond, pattern = "^muffle")
[10:22:08.072]                   }
[10:22:08.072]                 }
[10:22:08.072]                 else {
[10:22:08.072]                   if (TRUE) {
[10:22:08.072]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:08.072]                     {
[10:22:08.072]                       inherits <- base::inherits
[10:22:08.072]                       invokeRestart <- base::invokeRestart
[10:22:08.072]                       is.null <- base::is.null
[10:22:08.072]                       muffled <- FALSE
[10:22:08.072]                       if (inherits(cond, "message")) {
[10:22:08.072]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:08.072]                         if (muffled) 
[10:22:08.072]                           invokeRestart("muffleMessage")
[10:22:08.072]                       }
[10:22:08.072]                       else if (inherits(cond, "warning")) {
[10:22:08.072]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:08.072]                         if (muffled) 
[10:22:08.072]                           invokeRestart("muffleWarning")
[10:22:08.072]                       }
[10:22:08.072]                       else if (inherits(cond, "condition")) {
[10:22:08.072]                         if (!is.null(pattern)) {
[10:22:08.072]                           computeRestarts <- base::computeRestarts
[10:22:08.072]                           grepl <- base::grepl
[10:22:08.072]                           restarts <- computeRestarts(cond)
[10:22:08.072]                           for (restart in restarts) {
[10:22:08.072]                             name <- restart$name
[10:22:08.072]                             if (is.null(name)) 
[10:22:08.072]                               next
[10:22:08.072]                             if (!grepl(pattern, name)) 
[10:22:08.072]                               next
[10:22:08.072]                             invokeRestart(restart)
[10:22:08.072]                             muffled <- TRUE
[10:22:08.072]                             break
[10:22:08.072]                           }
[10:22:08.072]                         }
[10:22:08.072]                       }
[10:22:08.072]                       invisible(muffled)
[10:22:08.072]                     }
[10:22:08.072]                     muffleCondition(cond, pattern = "^muffle")
[10:22:08.072]                   }
[10:22:08.072]                 }
[10:22:08.072]             }
[10:22:08.072]         }))
[10:22:08.072]     }, error = function(ex) {
[10:22:08.072]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:08.072]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:08.072]                 ...future.rng), started = ...future.startTime, 
[10:22:08.072]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:08.072]             version = "1.8"), class = "FutureResult")
[10:22:08.072]     }, finally = {
[10:22:08.072]         if (!identical(...future.workdir, getwd())) 
[10:22:08.072]             setwd(...future.workdir)
[10:22:08.072]         {
[10:22:08.072]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:08.072]                 ...future.oldOptions$nwarnings <- NULL
[10:22:08.072]             }
[10:22:08.072]             base::options(...future.oldOptions)
[10:22:08.072]             if (.Platform$OS.type == "windows") {
[10:22:08.072]                 old_names <- names(...future.oldEnvVars)
[10:22:08.072]                 envs <- base::Sys.getenv()
[10:22:08.072]                 names <- names(envs)
[10:22:08.072]                 common <- intersect(names, old_names)
[10:22:08.072]                 added <- setdiff(names, old_names)
[10:22:08.072]                 removed <- setdiff(old_names, names)
[10:22:08.072]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:08.072]                   envs[common]]
[10:22:08.072]                 NAMES <- toupper(changed)
[10:22:08.072]                 args <- list()
[10:22:08.072]                 for (kk in seq_along(NAMES)) {
[10:22:08.072]                   name <- changed[[kk]]
[10:22:08.072]                   NAME <- NAMES[[kk]]
[10:22:08.072]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:08.072]                     next
[10:22:08.072]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:08.072]                 }
[10:22:08.072]                 NAMES <- toupper(added)
[10:22:08.072]                 for (kk in seq_along(NAMES)) {
[10:22:08.072]                   name <- added[[kk]]
[10:22:08.072]                   NAME <- NAMES[[kk]]
[10:22:08.072]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:08.072]                     next
[10:22:08.072]                   args[[name]] <- ""
[10:22:08.072]                 }
[10:22:08.072]                 NAMES <- toupper(removed)
[10:22:08.072]                 for (kk in seq_along(NAMES)) {
[10:22:08.072]                   name <- removed[[kk]]
[10:22:08.072]                   NAME <- NAMES[[kk]]
[10:22:08.072]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:08.072]                     next
[10:22:08.072]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:08.072]                 }
[10:22:08.072]                 if (length(args) > 0) 
[10:22:08.072]                   base::do.call(base::Sys.setenv, args = args)
[10:22:08.072]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:08.072]             }
[10:22:08.072]             else {
[10:22:08.072]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:08.072]             }
[10:22:08.072]             {
[10:22:08.072]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:08.072]                   0L) {
[10:22:08.072]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:08.072]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:08.072]                   base::options(opts)
[10:22:08.072]                 }
[10:22:08.072]                 {
[10:22:08.072]                   {
[10:22:08.072]                     NULL
[10:22:08.072]                     RNGkind("Mersenne-Twister")
[10:22:08.072]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:08.072]                       inherits = FALSE)
[10:22:08.072]                   }
[10:22:08.072]                   options(future.plan = NULL)
[10:22:08.072]                   if (is.na(NA_character_)) 
[10:22:08.072]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:08.072]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:08.072]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:08.072]                     .init = FALSE)
[10:22:08.072]                 }
[10:22:08.072]             }
[10:22:08.072]         }
[10:22:08.072]     })
[10:22:08.072]     if (TRUE) {
[10:22:08.072]         base::sink(type = "output", split = FALSE)
[10:22:08.072]         if (TRUE) {
[10:22:08.072]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:08.072]         }
[10:22:08.072]         else {
[10:22:08.072]             ...future.result["stdout"] <- base::list(NULL)
[10:22:08.072]         }
[10:22:08.072]         base::close(...future.stdout)
[10:22:08.072]         ...future.stdout <- NULL
[10:22:08.072]     }
[10:22:08.072]     ...future.result$conditions <- ...future.conditions
[10:22:08.072]     ...future.result$finished <- base::Sys.time()
[10:22:08.072]     ...future.result
[10:22:08.072] }
[10:22:08.099]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.074] assign_globals() ...
[10:22:08.099]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.075] List of 1
[10:22:08.075]  $ data:'data.frame':	3 obs. of  2 variables:
[10:22:08.075]   ..$ a: int [1:3] 1 2 3
[10:22:08.075]   ..$ b: int [1:3] 3 2 1
[10:22:08.075]  - attr(*, "where")=List of 1
[10:22:08.075]   ..$ data:<environment: R_EmptyEnv> 
[10:22:08.075]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:08.075]  - attr(*, "resolved")= logi FALSE
[10:22:08.075]  - attr(*, "total_size")= num 356
[10:22:08.075]  - attr(*, "already-done")= logi TRUE
[10:22:08.099]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.080] - copied ‘data’ to environment
[10:22:08.100]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.080] assign_globals() ... done
[10:22:08.100]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.081] plan(): Setting new future strategy stack:
[10:22:08.100]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.081] List of future strategies:
[10:22:08.081] 1. sequential:
[10:22:08.081]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:08.081]    - tweaked: FALSE
[10:22:08.081]    - call: NULL
[10:22:08.100]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.082] plan(): nbrOfWorkers() = 1
[10:22:08.100]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.083] plan(): Setting new future strategy stack:
[10:22:08.101]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.083] List of future strategies:
[10:22:08.083] 1. sequential:
[10:22:08.083]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:08.083]    - tweaked: FALSE
[10:22:08.083]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:08.101]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.084] plan(): nbrOfWorkers() = 1
[10:22:08.101]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.084] SequentialFuture started (and completed)
[10:22:08.101]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.084] - Launch lazy future ... done
[10:22:08.101]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.085] run() for ‘SequentialFuture’ ... done
[10:22:08.101] signalConditions() ... done
- plan(list('multicore', 'sequential')) ... DONE
- plan(list('multicore', 'multicore')) ...
[10:22:08.102] plan(): Setting new future strategy stack:
[10:22:08.102] List of future strategies:
[10:22:08.102] 1. multicore:
[10:22:08.102]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:08.102]    - tweaked: FALSE
[10:22:08.102]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:08.102] 2. multicore:
[10:22:08.102]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:08.102]    - tweaked: FALSE
[10:22:08.102]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:08.104] plan(): nbrOfWorkers() = 2
[10:22:08.105] getGlobalsAndPackages() ...
[10:22:08.105] Searching for globals...
[10:22:08.124] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[10:22:08.124] Searching for globals ... DONE
[10:22:08.125] Resolving globals: FALSE
[10:22:08.126] The total size of the 2 globals is 11.88 KiB (12162 bytes)
[10:22:08.126] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 11.88 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (11.83 KiB of class ‘list’) and ‘strategy2’ (48 bytes of class ‘character’)
[10:22:08.126] - globals: [2] ‘nested’, ‘strategy2’
[10:22:08.127] - packages: [1] ‘future’
[10:22:08.127] getGlobalsAndPackages() ... DONE
[10:22:08.127] run() for ‘Future’ ...
[10:22:08.127] - state: ‘created’
[10:22:08.127] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:08.129] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:08.129] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:08.129]   - Field: ‘label’
[10:22:08.129]   - Field: ‘local’
[10:22:08.130]   - Field: ‘owner’
[10:22:08.130]   - Field: ‘envir’
[10:22:08.130]   - Field: ‘workers’
[10:22:08.130]   - Field: ‘packages’
[10:22:08.130]   - Field: ‘gc’
[10:22:08.130]   - Field: ‘job’
[10:22:08.130]   - Field: ‘conditions’
[10:22:08.130]   - Field: ‘expr’
[10:22:08.130]   - Field: ‘uuid’
[10:22:08.131]   - Field: ‘seed’
[10:22:08.131]   - Field: ‘version’
[10:22:08.131]   - Field: ‘result’
[10:22:08.131]   - Field: ‘asynchronous’
[10:22:08.131]   - Field: ‘calls’
[10:22:08.131]   - Field: ‘globals’
[10:22:08.131]   - Field: ‘stdout’
[10:22:08.131]   - Field: ‘earlySignal’
[10:22:08.131]   - Field: ‘lazy’
[10:22:08.131]   - Field: ‘state’
[10:22:08.132] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:08.132] - Launch lazy future ...
[10:22:08.132] Packages needed by the future expression (n = 1): ‘future’
[10:22:08.132] Packages needed by future strategies (n = 1): ‘future’
[10:22:08.133] {
[10:22:08.133]     {
[10:22:08.133]         {
[10:22:08.133]             ...future.startTime <- base::Sys.time()
[10:22:08.133]             {
[10:22:08.133]                 {
[10:22:08.133]                   {
[10:22:08.133]                     {
[10:22:08.133]                       {
[10:22:08.133]                         base::local({
[10:22:08.133]                           has_future <- base::requireNamespace("future", 
[10:22:08.133]                             quietly = TRUE)
[10:22:08.133]                           if (has_future) {
[10:22:08.133]                             ns <- base::getNamespace("future")
[10:22:08.133]                             version <- ns[[".package"]][["version"]]
[10:22:08.133]                             if (is.null(version)) 
[10:22:08.133]                               version <- utils::packageVersion("future")
[10:22:08.133]                           }
[10:22:08.133]                           else {
[10:22:08.133]                             version <- NULL
[10:22:08.133]                           }
[10:22:08.133]                           if (!has_future || version < "1.8.0") {
[10:22:08.133]                             info <- base::c(r_version = base::gsub("R version ", 
[10:22:08.133]                               "", base::R.version$version.string), 
[10:22:08.133]                               platform = base::sprintf("%s (%s-bit)", 
[10:22:08.133]                                 base::R.version$platform, 8 * 
[10:22:08.133]                                   base::.Machine$sizeof.pointer), 
[10:22:08.133]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:08.133]                                 "release", "version")], collapse = " "), 
[10:22:08.133]                               hostname = base::Sys.info()[["nodename"]])
[10:22:08.133]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:22:08.133]                               info)
[10:22:08.133]                             info <- base::paste(info, collapse = "; ")
[10:22:08.133]                             if (!has_future) {
[10:22:08.133]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:08.133]                                 info)
[10:22:08.133]                             }
[10:22:08.133]                             else {
[10:22:08.133]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:08.133]                                 info, version)
[10:22:08.133]                             }
[10:22:08.133]                             base::stop(msg)
[10:22:08.133]                           }
[10:22:08.133]                         })
[10:22:08.133]                       }
[10:22:08.133]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:08.133]                       base::options(mc.cores = 1L)
[10:22:08.133]                     }
[10:22:08.133]                     base::local({
[10:22:08.133]                       for (pkg in "future") {
[10:22:08.133]                         base::loadNamespace(pkg)
[10:22:08.133]                         base::library(pkg, character.only = TRUE)
[10:22:08.133]                       }
[10:22:08.133]                     })
[10:22:08.133]                   }
[10:22:08.133]                   ...future.strategy.old <- future::plan("list")
[10:22:08.133]                   options(future.plan = NULL)
[10:22:08.133]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:08.133]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[10:22:08.133]                     envir = parent.frame()) 
[10:22:08.133]                   {
[10:22:08.133]                     default_workers <- missing(workers)
[10:22:08.133]                     if (is.function(workers)) 
[10:22:08.133]                       workers <- workers()
[10:22:08.133]                     workers <- structure(as.integer(workers), 
[10:22:08.133]                       class = class(workers))
[10:22:08.133]                     stop_if_not(is.finite(workers), workers >= 
[10:22:08.133]                       1L)
[10:22:08.133]                     if ((workers == 1L && !inherits(workers, 
[10:22:08.133]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:08.133]                       if (default_workers) 
[10:22:08.133]                         supportsMulticore(warn = TRUE)
[10:22:08.133]                       return(sequential(..., envir = envir))
[10:22:08.133]                     }
[10:22:08.133]                     oopts <- options(mc.cores = workers)
[10:22:08.133]                     on.exit(options(oopts))
[10:22:08.133]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:08.133]                       envir = envir)
[10:22:08.133]                     if (!future$lazy) 
[10:22:08.133]                       future <- run(future)
[10:22:08.133]                     invisible(future)
[10:22:08.133]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:08.133]                 }
[10:22:08.133]                 ...future.workdir <- getwd()
[10:22:08.133]             }
[10:22:08.133]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:08.133]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:08.133]         }
[10:22:08.133]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:08.133]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:08.133]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:08.133]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:08.133]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:08.133]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:08.133]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:08.133]             base::names(...future.oldOptions))
[10:22:08.133]     }
[10:22:08.133]     if (FALSE) {
[10:22:08.133]     }
[10:22:08.133]     else {
[10:22:08.133]         if (TRUE) {
[10:22:08.133]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:08.133]                 open = "w")
[10:22:08.133]         }
[10:22:08.133]         else {
[10:22:08.133]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:08.133]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:08.133]         }
[10:22:08.133]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:08.133]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:08.133]             base::sink(type = "output", split = FALSE)
[10:22:08.133]             base::close(...future.stdout)
[10:22:08.133]         }, add = TRUE)
[10:22:08.133]     }
[10:22:08.133]     ...future.frame <- base::sys.nframe()
[10:22:08.133]     ...future.conditions <- base::list()
[10:22:08.133]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:08.133]     if (FALSE) {
[10:22:08.133]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:08.133]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:08.133]     }
[10:22:08.133]     ...future.result <- base::tryCatch({
[10:22:08.133]         base::withCallingHandlers({
[10:22:08.133]             ...future.value <- base::withVisible(base::local({
[10:22:08.133]                 withCallingHandlers({
[10:22:08.133]                   {
[10:22:08.133]                     a <- 1L
[10:22:08.133]                     plan_a <- unclass(future::plan("list"))
[10:22:08.133]                     nested_a <- nested[-1]
[10:22:08.133]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[10:22:08.133]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[10:22:08.133]                       strategy2))
[10:22:08.133]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[10:22:08.133]                       "init") <- NULL
[10:22:08.133]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[10:22:08.133]                       "init") <- NULL
[10:22:08.133]                     stopifnot(all.equal(plan_a, nested_a))
[10:22:08.133]                     y %<-% {
[10:22:08.133]                       b <- 2L
[10:22:08.133]                       plan_b <- future::plan("list")
[10:22:08.133]                       nested_b <- nested_a[-1]
[10:22:08.133]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:22:08.133]                         1L, inherits(plan_b[[1]], "future"), 
[10:22:08.133]                         inherits(future::plan("next"), "sequential"))
[10:22:08.133]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:22:08.133]                         b = b, nested_b = nested_b, plan_b = plan_b)
[10:22:08.133]                     }
[10:22:08.133]                     y
[10:22:08.133]                   }
[10:22:08.133]                 }, immediateCondition = function(cond) {
[10:22:08.133]                   save_rds <- function (object, pathname, ...) 
[10:22:08.133]                   {
[10:22:08.133]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:08.133]                     if (file_test("-f", pathname_tmp)) {
[10:22:08.133]                       fi_tmp <- file.info(pathname_tmp)
[10:22:08.133]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:08.133]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:08.133]                         fi_tmp[["mtime"]])
[10:22:08.133]                     }
[10:22:08.133]                     tryCatch({
[10:22:08.133]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:08.133]                     }, error = function(ex) {
[10:22:08.133]                       msg <- conditionMessage(ex)
[10:22:08.133]                       fi_tmp <- file.info(pathname_tmp)
[10:22:08.133]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:08.133]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:08.133]                         fi_tmp[["mtime"]], msg)
[10:22:08.133]                       ex$message <- msg
[10:22:08.133]                       stop(ex)
[10:22:08.133]                     })
[10:22:08.133]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:08.133]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:08.133]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:08.133]                       fi_tmp <- file.info(pathname_tmp)
[10:22:08.133]                       fi <- file.info(pathname)
[10:22:08.133]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:08.133]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:08.133]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:08.133]                         fi[["size"]], fi[["mtime"]])
[10:22:08.133]                       stop(msg)
[10:22:08.133]                     }
[10:22:08.133]                     invisible(pathname)
[10:22:08.133]                   }
[10:22:08.133]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:08.133]                     rootPath = tempdir()) 
[10:22:08.133]                   {
[10:22:08.133]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:08.133]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:08.133]                       tmpdir = path, fileext = ".rds")
[10:22:08.133]                     save_rds(obj, file)
[10:22:08.133]                   }
[10:22:08.133]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4kEgVJ/.future/immediateConditions")
[10:22:08.133]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:08.133]                   {
[10:22:08.133]                     inherits <- base::inherits
[10:22:08.133]                     invokeRestart <- base::invokeRestart
[10:22:08.133]                     is.null <- base::is.null
[10:22:08.133]                     muffled <- FALSE
[10:22:08.133]                     if (inherits(cond, "message")) {
[10:22:08.133]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:08.133]                       if (muffled) 
[10:22:08.133]                         invokeRestart("muffleMessage")
[10:22:08.133]                     }
[10:22:08.133]                     else if (inherits(cond, "warning")) {
[10:22:08.133]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:08.133]                       if (muffled) 
[10:22:08.133]                         invokeRestart("muffleWarning")
[10:22:08.133]                     }
[10:22:08.133]                     else if (inherits(cond, "condition")) {
[10:22:08.133]                       if (!is.null(pattern)) {
[10:22:08.133]                         computeRestarts <- base::computeRestarts
[10:22:08.133]                         grepl <- base::grepl
[10:22:08.133]                         restarts <- computeRestarts(cond)
[10:22:08.133]                         for (restart in restarts) {
[10:22:08.133]                           name <- restart$name
[10:22:08.133]                           if (is.null(name)) 
[10:22:08.133]                             next
[10:22:08.133]                           if (!grepl(pattern, name)) 
[10:22:08.133]                             next
[10:22:08.133]                           invokeRestart(restart)
[10:22:08.133]                           muffled <- TRUE
[10:22:08.133]                           break
[10:22:08.133]                         }
[10:22:08.133]                       }
[10:22:08.133]                     }
[10:22:08.133]                     invisible(muffled)
[10:22:08.133]                   }
[10:22:08.133]                   muffleCondition(cond)
[10:22:08.133]                 })
[10:22:08.133]             }))
[10:22:08.133]             future::FutureResult(value = ...future.value$value, 
[10:22:08.133]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:08.133]                   ...future.rng), globalenv = if (FALSE) 
[10:22:08.133]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:08.133]                     ...future.globalenv.names))
[10:22:08.133]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:08.133]         }, condition = base::local({
[10:22:08.133]             c <- base::c
[10:22:08.133]             inherits <- base::inherits
[10:22:08.133]             invokeRestart <- base::invokeRestart
[10:22:08.133]             length <- base::length
[10:22:08.133]             list <- base::list
[10:22:08.133]             seq.int <- base::seq.int
[10:22:08.133]             signalCondition <- base::signalCondition
[10:22:08.133]             sys.calls <- base::sys.calls
[10:22:08.133]             `[[` <- base::`[[`
[10:22:08.133]             `+` <- base::`+`
[10:22:08.133]             `<<-` <- base::`<<-`
[10:22:08.133]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:08.133]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:08.133]                   3L)]
[10:22:08.133]             }
[10:22:08.133]             function(cond) {
[10:22:08.133]                 is_error <- inherits(cond, "error")
[10:22:08.133]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:08.133]                   NULL)
[10:22:08.133]                 if (is_error) {
[10:22:08.133]                   sessionInformation <- function() {
[10:22:08.133]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:08.133]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:08.133]                       search = base::search(), system = base::Sys.info())
[10:22:08.133]                   }
[10:22:08.133]                   ...future.conditions[[length(...future.conditions) + 
[10:22:08.133]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:08.133]                     cond$call), session = sessionInformation(), 
[10:22:08.133]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:08.133]                   signalCondition(cond)
[10:22:08.133]                 }
[10:22:08.133]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:08.133]                 "immediateCondition"))) {
[10:22:08.133]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:08.133]                   ...future.conditions[[length(...future.conditions) + 
[10:22:08.133]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:08.133]                   if (TRUE && !signal) {
[10:22:08.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:08.133]                     {
[10:22:08.133]                       inherits <- base::inherits
[10:22:08.133]                       invokeRestart <- base::invokeRestart
[10:22:08.133]                       is.null <- base::is.null
[10:22:08.133]                       muffled <- FALSE
[10:22:08.133]                       if (inherits(cond, "message")) {
[10:22:08.133]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:08.133]                         if (muffled) 
[10:22:08.133]                           invokeRestart("muffleMessage")
[10:22:08.133]                       }
[10:22:08.133]                       else if (inherits(cond, "warning")) {
[10:22:08.133]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:08.133]                         if (muffled) 
[10:22:08.133]                           invokeRestart("muffleWarning")
[10:22:08.133]                       }
[10:22:08.133]                       else if (inherits(cond, "condition")) {
[10:22:08.133]                         if (!is.null(pattern)) {
[10:22:08.133]                           computeRestarts <- base::computeRestarts
[10:22:08.133]                           grepl <- base::grepl
[10:22:08.133]                           restarts <- computeRestarts(cond)
[10:22:08.133]                           for (restart in restarts) {
[10:22:08.133]                             name <- restart$name
[10:22:08.133]                             if (is.null(name)) 
[10:22:08.133]                               next
[10:22:08.133]                             if (!grepl(pattern, name)) 
[10:22:08.133]                               next
[10:22:08.133]                             invokeRestart(restart)
[10:22:08.133]                             muffled <- TRUE
[10:22:08.133]                             break
[10:22:08.133]                           }
[10:22:08.133]                         }
[10:22:08.133]                       }
[10:22:08.133]                       invisible(muffled)
[10:22:08.133]                     }
[10:22:08.133]                     muffleCondition(cond, pattern = "^muffle")
[10:22:08.133]                   }
[10:22:08.133]                 }
[10:22:08.133]                 else {
[10:22:08.133]                   if (TRUE) {
[10:22:08.133]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:08.133]                     {
[10:22:08.133]                       inherits <- base::inherits
[10:22:08.133]                       invokeRestart <- base::invokeRestart
[10:22:08.133]                       is.null <- base::is.null
[10:22:08.133]                       muffled <- FALSE
[10:22:08.133]                       if (inherits(cond, "message")) {
[10:22:08.133]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:08.133]                         if (muffled) 
[10:22:08.133]                           invokeRestart("muffleMessage")
[10:22:08.133]                       }
[10:22:08.133]                       else if (inherits(cond, "warning")) {
[10:22:08.133]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:08.133]                         if (muffled) 
[10:22:08.133]                           invokeRestart("muffleWarning")
[10:22:08.133]                       }
[10:22:08.133]                       else if (inherits(cond, "condition")) {
[10:22:08.133]                         if (!is.null(pattern)) {
[10:22:08.133]                           computeRestarts <- base::computeRestarts
[10:22:08.133]                           grepl <- base::grepl
[10:22:08.133]                           restarts <- computeRestarts(cond)
[10:22:08.133]                           for (restart in restarts) {
[10:22:08.133]                             name <- restart$name
[10:22:08.133]                             if (is.null(name)) 
[10:22:08.133]                               next
[10:22:08.133]                             if (!grepl(pattern, name)) 
[10:22:08.133]                               next
[10:22:08.133]                             invokeRestart(restart)
[10:22:08.133]                             muffled <- TRUE
[10:22:08.133]                             break
[10:22:08.133]                           }
[10:22:08.133]                         }
[10:22:08.133]                       }
[10:22:08.133]                       invisible(muffled)
[10:22:08.133]                     }
[10:22:08.133]                     muffleCondition(cond, pattern = "^muffle")
[10:22:08.133]                   }
[10:22:08.133]                 }
[10:22:08.133]             }
[10:22:08.133]         }))
[10:22:08.133]     }, error = function(ex) {
[10:22:08.133]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:08.133]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:08.133]                 ...future.rng), started = ...future.startTime, 
[10:22:08.133]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:08.133]             version = "1.8"), class = "FutureResult")
[10:22:08.133]     }, finally = {
[10:22:08.133]         if (!identical(...future.workdir, getwd())) 
[10:22:08.133]             setwd(...future.workdir)
[10:22:08.133]         {
[10:22:08.133]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:08.133]                 ...future.oldOptions$nwarnings <- NULL
[10:22:08.133]             }
[10:22:08.133]             base::options(...future.oldOptions)
[10:22:08.133]             if (.Platform$OS.type == "windows") {
[10:22:08.133]                 old_names <- names(...future.oldEnvVars)
[10:22:08.133]                 envs <- base::Sys.getenv()
[10:22:08.133]                 names <- names(envs)
[10:22:08.133]                 common <- intersect(names, old_names)
[10:22:08.133]                 added <- setdiff(names, old_names)
[10:22:08.133]                 removed <- setdiff(old_names, names)
[10:22:08.133]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:08.133]                   envs[common]]
[10:22:08.133]                 NAMES <- toupper(changed)
[10:22:08.133]                 args <- list()
[10:22:08.133]                 for (kk in seq_along(NAMES)) {
[10:22:08.133]                   name <- changed[[kk]]
[10:22:08.133]                   NAME <- NAMES[[kk]]
[10:22:08.133]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:08.133]                     next
[10:22:08.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:08.133]                 }
[10:22:08.133]                 NAMES <- toupper(added)
[10:22:08.133]                 for (kk in seq_along(NAMES)) {
[10:22:08.133]                   name <- added[[kk]]
[10:22:08.133]                   NAME <- NAMES[[kk]]
[10:22:08.133]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:08.133]                     next
[10:22:08.133]                   args[[name]] <- ""
[10:22:08.133]                 }
[10:22:08.133]                 NAMES <- toupper(removed)
[10:22:08.133]                 for (kk in seq_along(NAMES)) {
[10:22:08.133]                   name <- removed[[kk]]
[10:22:08.133]                   NAME <- NAMES[[kk]]
[10:22:08.133]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:08.133]                     next
[10:22:08.133]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:08.133]                 }
[10:22:08.133]                 if (length(args) > 0) 
[10:22:08.133]                   base::do.call(base::Sys.setenv, args = args)
[10:22:08.133]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:08.133]             }
[10:22:08.133]             else {
[10:22:08.133]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:08.133]             }
[10:22:08.133]             {
[10:22:08.133]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:08.133]                   0L) {
[10:22:08.133]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:08.133]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:08.133]                   base::options(opts)
[10:22:08.133]                 }
[10:22:08.133]                 {
[10:22:08.133]                   {
[10:22:08.133]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:08.133]                     NULL
[10:22:08.133]                   }
[10:22:08.133]                   options(future.plan = NULL)
[10:22:08.133]                   if (is.na(NA_character_)) 
[10:22:08.133]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:08.133]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:08.133]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:08.133]                     .init = FALSE)
[10:22:08.133]                 }
[10:22:08.133]             }
[10:22:08.133]         }
[10:22:08.133]     })
[10:22:08.133]     if (TRUE) {
[10:22:08.133]         base::sink(type = "output", split = FALSE)
[10:22:08.133]         if (TRUE) {
[10:22:08.133]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:08.133]         }
[10:22:08.133]         else {
[10:22:08.133]             ...future.result["stdout"] <- base::list(NULL)
[10:22:08.133]         }
[10:22:08.133]         base::close(...future.stdout)
[10:22:08.133]         ...future.stdout <- NULL
[10:22:08.133]     }
[10:22:08.133]     ...future.result$conditions <- ...future.conditions
[10:22:08.133]     ...future.result$finished <- base::Sys.time()
[10:22:08.133]     ...future.result
[10:22:08.133] }
[10:22:08.136] assign_globals() ...
[10:22:08.136] List of 2
[10:22:08.136]  $ nested   :List of 2
[10:22:08.136]   ..$ a:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[10:22:08.136]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[10:22:08.136]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:22:08.136]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[10:22:08.136]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[10:22:08.136]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:22:08.136]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:22:08.136]  $ strategy2: chr "multicore"
[10:22:08.136]  - attr(*, "where")=List of 2
[10:22:08.136]   ..$ nested   :<environment: R_EmptyEnv> 
[10:22:08.136]   ..$ strategy2:<environment: R_EmptyEnv> 
[10:22:08.136]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:08.136]  - attr(*, "resolved")= logi FALSE
[10:22:08.136]  - attr(*, "total_size")= num 12162
[10:22:08.136]  - attr(*, "already-done")= logi TRUE
[10:22:08.141] - copied ‘nested’ to environment
[10:22:08.141] - copied ‘strategy2’ to environment
[10:22:08.141] assign_globals() ... done
[10:22:08.142] requestCore(): workers = 2
[10:22:08.144] MulticoreFuture started
[10:22:08.144] - Launch lazy future ... done
[10:22:08.144] run() for ‘MulticoreFuture’ ... done
[10:22:08.145] result() for MulticoreFuture ...
[10:22:08.145] plan(): Setting new future strategy stack:
[10:22:08.145] List of future strategies:
[10:22:08.145] 1. multicore:
[10:22:08.145]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:08.145]    - tweaked: FALSE
[10:22:08.145]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:08.149] plan(): nbrOfWorkers() = 1
[10:22:08.189] plan(): Setting new future strategy stack:
[10:22:08.189] List of future strategies:
[10:22:08.189] 1. multicore:
[10:22:08.189]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:08.189]    - tweaked: FALSE
[10:22:08.189]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:08.189] 2. multicore:
[10:22:08.189]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:08.189]    - tweaked: FALSE
[10:22:08.189]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:08.191] plan(): nbrOfWorkers() = 2
[10:22:08.193] result() for MulticoreFuture ...
[10:22:08.193] result() for MulticoreFuture ... done
[10:22:08.193] signalConditions() ...
[10:22:08.193]  - include = ‘immediateCondition’
[10:22:08.193]  - exclude = 
[10:22:08.193]  - resignal = FALSE
[10:22:08.194]  - Number of conditions: 54
[10:22:08.194] signalConditions() ... done
[10:22:08.194] result() for MulticoreFuture ... done
[10:22:08.194] result() for MulticoreFuture ...
[10:22:08.194] result() for MulticoreFuture ... done
[10:22:08.194] signalConditions() ...
[10:22:08.194]  - include = ‘immediateCondition’
[10:22:08.194]  - exclude = 
[10:22:08.194]  - resignal = FALSE
[10:22:08.195]  - Number of conditions: 54
[10:22:08.195] signalConditions() ... done
[10:22:08.195] Future state: ‘finished’
[10:22:08.195] result() for MulticoreFuture ...
[10:22:08.195] result() for MulticoreFuture ... done
[10:22:08.195] signalConditions() ...
[10:22:08.195]  - include = ‘condition’
[10:22:08.195]  - exclude = ‘immediateCondition’
[10:22:08.195]  - resignal = TRUE
[10:22:08.196]  - Number of conditions: 54
[10:22:08.196]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.151] getGlobalsAndPackages() ...
[10:22:08.196]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.151] Searching for globals...
[10:22:08.196]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.163] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[10:22:08.196]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.163] Searching for globals ... DONE
[10:22:08.196]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.164] Resolving globals: FALSE
[10:22:08.196]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.165] The total size of the 3 globals is 12.54 KiB (12841 bytes)
[10:22:08.197]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.165] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 12.54 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (6.25 KiB of class ‘list’), ‘plan_a’ (6.25 KiB of class ‘list’) and ‘a’ (35 bytes of class ‘numeric’)
[10:22:08.197]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.166] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[10:22:08.197]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.166] 
[10:22:08.197]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.166] getGlobalsAndPackages() ... DONE
[10:22:08.197]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.167] run() for ‘Future’ ...
[10:22:08.197]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.167] - state: ‘created’
[10:22:08.197]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.167] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:08.198]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.169] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:08.198]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.169] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:08.198]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.170]   - Field: ‘label’
[10:22:08.198]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.170]   - Field: ‘local’
[10:22:08.198]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.170]   - Field: ‘owner’
[10:22:08.198]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.170]   - Field: ‘envir’
[10:22:08.199]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.170]   - Field: ‘packages’
[10:22:08.199]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.170]   - Field: ‘gc’
[10:22:08.199]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.171]   - Field: ‘conditions’
[10:22:08.199]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.171]   - Field: ‘expr’
[10:22:08.199]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.171]   - Field: ‘uuid’
[10:22:08.199]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.171]   - Field: ‘seed’
[10:22:08.199]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.171]   - Field: ‘version’
[10:22:08.200]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.171]   - Field: ‘result’
[10:22:08.200]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.172]   - Field: ‘asynchronous’
[10:22:08.200]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.172]   - Field: ‘calls’
[10:22:08.200]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.172]   - Field: ‘globals’
[10:22:08.203]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.172]   - Field: ‘stdout’
[10:22:08.203]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.172]   - Field: ‘earlySignal’
[10:22:08.204]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.172]   - Field: ‘lazy’
[10:22:08.204]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.172]   - Field: ‘state’
[10:22:08.204]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.173] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:08.204]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.173] - Launch lazy future ...
[10:22:08.204]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.173] Packages needed by the future expression (n = 0): <none>
[10:22:08.204]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.173] Packages needed by future strategies (n = 0): <none>
[10:22:08.205]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.174] {
[10:22:08.174]     {
[10:22:08.174]         {
[10:22:08.174]             ...future.startTime <- base::Sys.time()
[10:22:08.174]             {
[10:22:08.174]                 {
[10:22:08.174]                   {
[10:22:08.174]                     base::local({
[10:22:08.174]                       has_future <- base::requireNamespace("future", 
[10:22:08.174]                         quietly = TRUE)
[10:22:08.174]                       if (has_future) {
[10:22:08.174]                         ns <- base::getNamespace("future")
[10:22:08.174]                         version <- ns[[".package"]][["version"]]
[10:22:08.174]                         if (is.null(version)) 
[10:22:08.174]                           version <- utils::packageVersion("future")
[10:22:08.174]                       }
[10:22:08.174]                       else {
[10:22:08.174]                         version <- NULL
[10:22:08.174]                       }
[10:22:08.174]                       if (!has_future || version < "1.8.0") {
[10:22:08.174]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:08.174]                           "", base::R.version$version.string), 
[10:22:08.174]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:08.174]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:08.174]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:08.174]                             "release", "version")], collapse = " "), 
[10:22:08.174]                           hostname = base::Sys.info()[["nodename"]])
[10:22:08.174]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:08.174]                           info)
[10:22:08.174]                         info <- base::paste(info, collapse = "; ")
[10:22:08.174]                         if (!has_future) {
[10:22:08.174]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:08.174]                             info)
[10:22:08.174]                         }
[10:22:08.174]                         else {
[10:22:08.174]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:08.174]                             info, version)
[10:22:08.174]                         }
[10:22:08.174]                         base::stop(msg)
[10:22:08.174]                       }
[10:22:08.174]                     })
[10:22:08.174]                   }
[10:22:08.174]                   ...future.strategy.old <- future::plan("list")
[10:22:08.174]                   options(future.plan = NULL)
[10:22:08.174]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:08.174]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:08.174]                 }
[10:22:08.174]                 ...future.workdir <- getwd()
[10:22:08.174]             }
[10:22:08.174]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:08.174]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:08.174]         }
[10:22:08.174]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:08.174]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:08.174]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:08.174]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:08.174]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:08.174]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:08.174]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:08.174]             base::names(...future.oldOptions))
[10:22:08.174]     }
[10:22:08.174]     if (FALSE) {
[10:22:08.174]     }
[10:22:08.174]     else {
[10:22:08.174]         if (TRUE) {
[10:22:08.174]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:08.174]                 open = "w")
[10:22:08.174]         }
[10:22:08.174]         else {
[10:22:08.174]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:08.174]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:08.174]         }
[10:22:08.174]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:08.174]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:08.174]             base::sink(type = "output", split = FALSE)
[10:22:08.174]             base::close(...future.stdout)
[10:22:08.174]         }, add = TRUE)
[10:22:08.174]     }
[10:22:08.174]     ...future.frame <- base::sys.nframe()
[10:22:08.174]     ...future.conditions <- base::list()
[10:22:08.174]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:08.174]     if (FALSE) {
[10:22:08.174]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:08.174]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:08.174]     }
[10:22:08.174]     ...future.result <- base::tryCatch({
[10:22:08.174]         base::withCallingHandlers({
[10:22:08.174]             ...future.value <- base::withVisible(base::local({
[10:22:08.174]                 b <- 2L
[10:22:08.174]                 plan_b <- future::plan("list")
[10:22:08.174]                 nested_b <- nested_a[-1]
[10:22:08.174]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:22:08.174]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[10:22:08.174]                   "sequential"))
[10:22:08.174]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:22:08.174]                   b = b, nested_b = nested_b, plan_b = plan_b)
[10:22:08.174]             }))
[10:22:08.174]             future::FutureResult(value = ...future.value$value, 
[10:22:08.174]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:08.174]                   ...future.rng), globalenv = if (FALSE) 
[10:22:08.174]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:08.174]                     ...future.globalenv.names))
[10:22:08.174]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:08.174]         }, condition = base::local({
[10:22:08.174]             c <- base::c
[10:22:08.174]             inherits <- base::inherits
[10:22:08.174]             invokeRestart <- base::invokeRestart
[10:22:08.174]             length <- base::length
[10:22:08.174]             list <- base::list
[10:22:08.174]             seq.int <- base::seq.int
[10:22:08.174]             signalCondition <- base::signalCondition
[10:22:08.174]             sys.calls <- base::sys.calls
[10:22:08.174]             `[[` <- base::`[[`
[10:22:08.174]             `+` <- base::`+`
[10:22:08.174]             `<<-` <- base::`<<-`
[10:22:08.174]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:08.174]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:08.174]                   3L)]
[10:22:08.174]             }
[10:22:08.174]             function(cond) {
[10:22:08.174]                 is_error <- inherits(cond, "error")
[10:22:08.174]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:08.174]                   NULL)
[10:22:08.174]                 if (is_error) {
[10:22:08.174]                   sessionInformation <- function() {
[10:22:08.174]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:08.174]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:08.174]                       search = base::search(), system = base::Sys.info())
[10:22:08.174]                   }
[10:22:08.174]                   ...future.conditions[[length(...future.conditions) + 
[10:22:08.174]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:08.174]                     cond$call), session = sessionInformation(), 
[10:22:08.174]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:08.174]                   signalCondition(cond)
[10:22:08.174]                 }
[10:22:08.174]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:08.174]                 "immediateCondition"))) {
[10:22:08.174]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:08.174]                   ...future.conditions[[length(...future.conditions) + 
[10:22:08.174]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:08.174]                   if (TRUE && !signal) {
[10:22:08.174]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:08.174]                     {
[10:22:08.174]                       inherits <- base::inherits
[10:22:08.174]                       invokeRestart <- base::invokeRestart
[10:22:08.174]                       is.null <- base::is.null
[10:22:08.174]                       muffled <- FALSE
[10:22:08.174]                       if (inherits(cond, "message")) {
[10:22:08.174]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:08.174]                         if (muffled) 
[10:22:08.174]                           invokeRestart("muffleMessage")
[10:22:08.174]                       }
[10:22:08.174]                       else if (inherits(cond, "warning")) {
[10:22:08.174]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:08.174]                         if (muffled) 
[10:22:08.174]                           invokeRestart("muffleWarning")
[10:22:08.174]                       }
[10:22:08.174]                       else if (inherits(cond, "condition")) {
[10:22:08.174]                         if (!is.null(pattern)) {
[10:22:08.174]                           computeRestarts <- base::computeRestarts
[10:22:08.174]                           grepl <- base::grepl
[10:22:08.174]                           restarts <- computeRestarts(cond)
[10:22:08.174]                           for (restart in restarts) {
[10:22:08.174]                             name <- restart$name
[10:22:08.174]                             if (is.null(name)) 
[10:22:08.174]                               next
[10:22:08.174]                             if (!grepl(pattern, name)) 
[10:22:08.174]                               next
[10:22:08.174]                             invokeRestart(restart)
[10:22:08.174]                             muffled <- TRUE
[10:22:08.174]                             break
[10:22:08.174]                           }
[10:22:08.174]                         }
[10:22:08.174]                       }
[10:22:08.174]                       invisible(muffled)
[10:22:08.174]                     }
[10:22:08.174]                     muffleCondition(cond, pattern = "^muffle")
[10:22:08.174]                   }
[10:22:08.174]                 }
[10:22:08.174]                 else {
[10:22:08.174]                   if (TRUE) {
[10:22:08.174]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:08.174]                     {
[10:22:08.174]                       inherits <- base::inherits
[10:22:08.174]                       invokeRestart <- base::invokeRestart
[10:22:08.174]                       is.null <- base::is.null
[10:22:08.174]                       muffled <- FALSE
[10:22:08.174]                       if (inherits(cond, "message")) {
[10:22:08.174]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:08.174]                         if (muffled) 
[10:22:08.174]                           invokeRestart("muffleMessage")
[10:22:08.174]                       }
[10:22:08.174]                       else if (inherits(cond, "warning")) {
[10:22:08.174]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:08.174]                         if (muffled) 
[10:22:08.174]                           invokeRestart("muffleWarning")
[10:22:08.174]                       }
[10:22:08.174]                       else if (inherits(cond, "condition")) {
[10:22:08.174]                         if (!is.null(pattern)) {
[10:22:08.174]                           computeRestarts <- base::computeRestarts
[10:22:08.174]                           grepl <- base::grepl
[10:22:08.174]                           restarts <- computeRestarts(cond)
[10:22:08.174]                           for (restart in restarts) {
[10:22:08.174]                             name <- restart$name
[10:22:08.174]                             if (is.null(name)) 
[10:22:08.174]                               next
[10:22:08.174]                             if (!grepl(pattern, name)) 
[10:22:08.174]                               next
[10:22:08.174]                             invokeRestart(restart)
[10:22:08.174]                             muffled <- TRUE
[10:22:08.174]                             break
[10:22:08.174]                           }
[10:22:08.174]                         }
[10:22:08.174]                       }
[10:22:08.174]                       invisible(muffled)
[10:22:08.174]                     }
[10:22:08.174]                     muffleCondition(cond, pattern = "^muffle")
[10:22:08.174]                   }
[10:22:08.174]                 }
[10:22:08.174]             }
[10:22:08.174]         }))
[10:22:08.174]     }, error = function(ex) {
[10:22:08.174]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:08.174]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:08.174]                 ...future.rng), started = ...future.startTime, 
[10:22:08.174]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:08.174]             version = "1.8"), class = "FutureResult")
[10:22:08.174]     }, finally = {
[10:22:08.174]         if (!identical(...future.workdir, getwd())) 
[10:22:08.174]             setwd(...future.workdir)
[10:22:08.174]         {
[10:22:08.174]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:08.174]                 ...future.oldOptions$nwarnings <- NULL
[10:22:08.174]             }
[10:22:08.174]             base::options(...future.oldOptions)
[10:22:08.174]             if (.Platform$OS.type == "windows") {
[10:22:08.174]                 old_names <- names(...future.oldEnvVars)
[10:22:08.174]                 envs <- base::Sys.getenv()
[10:22:08.174]                 names <- names(envs)
[10:22:08.174]                 common <- intersect(names, old_names)
[10:22:08.174]                 added <- setdiff(names, old_names)
[10:22:08.174]                 removed <- setdiff(old_names, names)
[10:22:08.174]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:08.174]                   envs[common]]
[10:22:08.174]                 NAMES <- toupper(changed)
[10:22:08.174]                 args <- list()
[10:22:08.174]                 for (kk in seq_along(NAMES)) {
[10:22:08.174]                   name <- changed[[kk]]
[10:22:08.174]                   NAME <- NAMES[[kk]]
[10:22:08.174]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:08.174]                     next
[10:22:08.174]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:08.174]                 }
[10:22:08.174]                 NAMES <- toupper(added)
[10:22:08.174]                 for (kk in seq_along(NAMES)) {
[10:22:08.174]                   name <- added[[kk]]
[10:22:08.174]                   NAME <- NAMES[[kk]]
[10:22:08.174]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:08.174]                     next
[10:22:08.174]                   args[[name]] <- ""
[10:22:08.174]                 }
[10:22:08.174]                 NAMES <- toupper(removed)
[10:22:08.174]                 for (kk in seq_along(NAMES)) {
[10:22:08.174]                   name <- removed[[kk]]
[10:22:08.174]                   NAME <- NAMES[[kk]]
[10:22:08.174]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:08.174]                     next
[10:22:08.174]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:08.174]                 }
[10:22:08.174]                 if (length(args) > 0) 
[10:22:08.174]                   base::do.call(base::Sys.setenv, args = args)
[10:22:08.174]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:08.174]             }
[10:22:08.174]             else {
[10:22:08.174]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:08.174]             }
[10:22:08.174]             {
[10:22:08.174]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:08.174]                   0L) {
[10:22:08.174]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:08.174]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:08.174]                   base::options(opts)
[10:22:08.174]                 }
[10:22:08.174]                 {
[10:22:08.174]                   {
[10:22:08.174]                     NULL
[10:22:08.174]                     RNGkind("Mersenne-Twister")
[10:22:08.174]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:08.174]                       inherits = FALSE)
[10:22:08.174]                   }
[10:22:08.174]                   options(future.plan = NULL)
[10:22:08.174]                   if (is.na(NA_character_)) 
[10:22:08.174]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:08.174]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:08.174]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:08.174]                     .init = FALSE)
[10:22:08.174]                 }
[10:22:08.174]             }
[10:22:08.174]         }
[10:22:08.174]     })
[10:22:08.174]     if (TRUE) {
[10:22:08.174]         base::sink(type = "output", split = FALSE)
[10:22:08.174]         if (TRUE) {
[10:22:08.174]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:08.174]         }
[10:22:08.174]         else {
[10:22:08.174]             ...future.result["stdout"] <- base::list(NULL)
[10:22:08.174]         }
[10:22:08.174]         base::close(...future.stdout)
[10:22:08.174]         ...future.stdout <- NULL
[10:22:08.174]     }
[10:22:08.174]     ...future.result$conditions <- ...future.conditions
[10:22:08.174]     ...future.result$finished <- base::Sys.time()
[10:22:08.174]     ...future.result
[10:22:08.174] }
[10:22:08.205]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.176] assign_globals() ...
[10:22:08.205]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.176] List of 3
[10:22:08.176]  $ nested_a:List of 1
[10:22:08.176]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[10:22:08.176]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[10:22:08.176]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:22:08.176]  $ a       : int 1
[10:22:08.176]  $ plan_a  :List of 1
[10:22:08.176]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[10:22:08.176]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[10:22:08.176]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:22:08.176]  - attr(*, "where")=List of 3
[10:22:08.176]   ..$ nested_a:<environment: R_EmptyEnv> 
[10:22:08.176]   ..$ a       :<environment: R_EmptyEnv> 
[10:22:08.176]   ..$ plan_a  :<environment: R_EmptyEnv> 
[10:22:08.176]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:08.176]  - attr(*, "resolved")= logi FALSE
[10:22:08.176]  - attr(*, "total_size")= num 12841
[10:22:08.176]  - attr(*, "already-done")= logi TRUE
[10:22:08.205]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.183] - copied ‘nested_a’ to environment
[10:22:08.205]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.183] - copied ‘a’ to environment
[10:22:08.206]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.183] - copied ‘plan_a’ to environment
[10:22:08.206]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.183] assign_globals() ... done
[10:22:08.206]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.184] plan(): Setting new future strategy stack:
[10:22:08.206]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.184] List of future strategies:
[10:22:08.184] 1. sequential:
[10:22:08.184]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:08.184]    - tweaked: FALSE
[10:22:08.184]    - call: NULL
[10:22:08.206]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.185] plan(): nbrOfWorkers() = 1
[10:22:08.206]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.186] plan(): Setting new future strategy stack:
[10:22:08.206]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.186] List of future strategies:
[10:22:08.186] 1. multicore:
[10:22:08.186]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:08.186]    - tweaked: FALSE
[10:22:08.186]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:08.207]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.188] plan(): nbrOfWorkers() = 1
[10:22:08.207]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.188] SequentialFuture started (and completed)
[10:22:08.207]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.188] - Launch lazy future ... done
[10:22:08.207]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.188] run() for ‘SequentialFuture’ ... done
[10:22:08.207] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:22:08.213] getGlobalsAndPackages() ...
[10:22:08.213] Searching for globals...
[10:22:08.215] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[10:22:08.215] Searching for globals ... DONE
[10:22:08.215] Resolving globals: FALSE
[10:22:08.216] The total size of the 1 globals is 356 bytes (356 bytes)
[10:22:08.216] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[10:22:08.217] - globals: [1] ‘data’
[10:22:08.217] - packages: [1] ‘future’
[10:22:08.217] getGlobalsAndPackages() ... DONE
[10:22:08.217] run() for ‘Future’ ...
[10:22:08.217] - state: ‘created’
[10:22:08.217] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:08.219] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:08.220] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:08.220]   - Field: ‘label’
[10:22:08.220]   - Field: ‘local’
[10:22:08.220]   - Field: ‘owner’
[10:22:08.220]   - Field: ‘envir’
[10:22:08.220]   - Field: ‘workers’
[10:22:08.220]   - Field: ‘packages’
[10:22:08.220]   - Field: ‘gc’
[10:22:08.220]   - Field: ‘job’
[10:22:08.221]   - Field: ‘conditions’
[10:22:08.221]   - Field: ‘expr’
[10:22:08.221]   - Field: ‘uuid’
[10:22:08.221]   - Field: ‘seed’
[10:22:08.221]   - Field: ‘version’
[10:22:08.221]   - Field: ‘result’
[10:22:08.221]   - Field: ‘asynchronous’
[10:22:08.221]   - Field: ‘calls’
[10:22:08.221]   - Field: ‘globals’
[10:22:08.222]   - Field: ‘stdout’
[10:22:08.222]   - Field: ‘earlySignal’
[10:22:08.222]   - Field: ‘lazy’
[10:22:08.222]   - Field: ‘state’
[10:22:08.222] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:08.222] - Launch lazy future ...
[10:22:08.222] Packages needed by the future expression (n = 1): ‘future’
[10:22:08.223] Packages needed by future strategies (n = 1): ‘future’
[10:22:08.223] {
[10:22:08.223]     {
[10:22:08.223]         {
[10:22:08.223]             ...future.startTime <- base::Sys.time()
[10:22:08.223]             {
[10:22:08.223]                 {
[10:22:08.223]                   {
[10:22:08.223]                     {
[10:22:08.223]                       {
[10:22:08.223]                         base::local({
[10:22:08.223]                           has_future <- base::requireNamespace("future", 
[10:22:08.223]                             quietly = TRUE)
[10:22:08.223]                           if (has_future) {
[10:22:08.223]                             ns <- base::getNamespace("future")
[10:22:08.223]                             version <- ns[[".package"]][["version"]]
[10:22:08.223]                             if (is.null(version)) 
[10:22:08.223]                               version <- utils::packageVersion("future")
[10:22:08.223]                           }
[10:22:08.223]                           else {
[10:22:08.223]                             version <- NULL
[10:22:08.223]                           }
[10:22:08.223]                           if (!has_future || version < "1.8.0") {
[10:22:08.223]                             info <- base::c(r_version = base::gsub("R version ", 
[10:22:08.223]                               "", base::R.version$version.string), 
[10:22:08.223]                               platform = base::sprintf("%s (%s-bit)", 
[10:22:08.223]                                 base::R.version$platform, 8 * 
[10:22:08.223]                                   base::.Machine$sizeof.pointer), 
[10:22:08.223]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:08.223]                                 "release", "version")], collapse = " "), 
[10:22:08.223]                               hostname = base::Sys.info()[["nodename"]])
[10:22:08.223]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:22:08.223]                               info)
[10:22:08.223]                             info <- base::paste(info, collapse = "; ")
[10:22:08.223]                             if (!has_future) {
[10:22:08.223]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:08.223]                                 info)
[10:22:08.223]                             }
[10:22:08.223]                             else {
[10:22:08.223]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:08.223]                                 info, version)
[10:22:08.223]                             }
[10:22:08.223]                             base::stop(msg)
[10:22:08.223]                           }
[10:22:08.223]                         })
[10:22:08.223]                       }
[10:22:08.223]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:08.223]                       base::options(mc.cores = 1L)
[10:22:08.223]                     }
[10:22:08.223]                     base::local({
[10:22:08.223]                       for (pkg in "future") {
[10:22:08.223]                         base::loadNamespace(pkg)
[10:22:08.223]                         base::library(pkg, character.only = TRUE)
[10:22:08.223]                       }
[10:22:08.223]                     })
[10:22:08.223]                   }
[10:22:08.223]                   ...future.strategy.old <- future::plan("list")
[10:22:08.223]                   options(future.plan = NULL)
[10:22:08.223]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:08.223]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[10:22:08.223]                     envir = parent.frame()) 
[10:22:08.223]                   {
[10:22:08.223]                     default_workers <- missing(workers)
[10:22:08.223]                     if (is.function(workers)) 
[10:22:08.223]                       workers <- workers()
[10:22:08.223]                     workers <- structure(as.integer(workers), 
[10:22:08.223]                       class = class(workers))
[10:22:08.223]                     stop_if_not(is.finite(workers), workers >= 
[10:22:08.223]                       1L)
[10:22:08.223]                     if ((workers == 1L && !inherits(workers, 
[10:22:08.223]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:08.223]                       if (default_workers) 
[10:22:08.223]                         supportsMulticore(warn = TRUE)
[10:22:08.223]                       return(sequential(..., envir = envir))
[10:22:08.223]                     }
[10:22:08.223]                     oopts <- options(mc.cores = workers)
[10:22:08.223]                     on.exit(options(oopts))
[10:22:08.223]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:08.223]                       envir = envir)
[10:22:08.223]                     if (!future$lazy) 
[10:22:08.223]                       future <- run(future)
[10:22:08.223]                     invisible(future)
[10:22:08.223]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:08.223]                 }
[10:22:08.223]                 ...future.workdir <- getwd()
[10:22:08.223]             }
[10:22:08.223]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:08.223]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:08.223]         }
[10:22:08.223]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:08.223]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:08.223]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:08.223]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:08.223]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:08.223]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:08.223]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:08.223]             base::names(...future.oldOptions))
[10:22:08.223]     }
[10:22:08.223]     if (FALSE) {
[10:22:08.223]     }
[10:22:08.223]     else {
[10:22:08.223]         if (TRUE) {
[10:22:08.223]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:08.223]                 open = "w")
[10:22:08.223]         }
[10:22:08.223]         else {
[10:22:08.223]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:08.223]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:08.223]         }
[10:22:08.223]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:08.223]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:08.223]             base::sink(type = "output", split = FALSE)
[10:22:08.223]             base::close(...future.stdout)
[10:22:08.223]         }, add = TRUE)
[10:22:08.223]     }
[10:22:08.223]     ...future.frame <- base::sys.nframe()
[10:22:08.223]     ...future.conditions <- base::list()
[10:22:08.223]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:08.223]     if (FALSE) {
[10:22:08.223]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:08.223]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:08.223]     }
[10:22:08.223]     ...future.result <- base::tryCatch({
[10:22:08.223]         base::withCallingHandlers({
[10:22:08.223]             ...future.value <- base::withVisible(base::local({
[10:22:08.223]                 withCallingHandlers({
[10:22:08.223]                   {
[10:22:08.223]                     value(future(subset(data, a == 2)))
[10:22:08.223]                   }
[10:22:08.223]                 }, immediateCondition = function(cond) {
[10:22:08.223]                   save_rds <- function (object, pathname, ...) 
[10:22:08.223]                   {
[10:22:08.223]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:08.223]                     if (file_test("-f", pathname_tmp)) {
[10:22:08.223]                       fi_tmp <- file.info(pathname_tmp)
[10:22:08.223]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:08.223]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:08.223]                         fi_tmp[["mtime"]])
[10:22:08.223]                     }
[10:22:08.223]                     tryCatch({
[10:22:08.223]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:08.223]                     }, error = function(ex) {
[10:22:08.223]                       msg <- conditionMessage(ex)
[10:22:08.223]                       fi_tmp <- file.info(pathname_tmp)
[10:22:08.223]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:08.223]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:08.223]                         fi_tmp[["mtime"]], msg)
[10:22:08.223]                       ex$message <- msg
[10:22:08.223]                       stop(ex)
[10:22:08.223]                     })
[10:22:08.223]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:08.223]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:08.223]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:08.223]                       fi_tmp <- file.info(pathname_tmp)
[10:22:08.223]                       fi <- file.info(pathname)
[10:22:08.223]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:08.223]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:08.223]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:08.223]                         fi[["size"]], fi[["mtime"]])
[10:22:08.223]                       stop(msg)
[10:22:08.223]                     }
[10:22:08.223]                     invisible(pathname)
[10:22:08.223]                   }
[10:22:08.223]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:08.223]                     rootPath = tempdir()) 
[10:22:08.223]                   {
[10:22:08.223]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:08.223]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:08.223]                       tmpdir = path, fileext = ".rds")
[10:22:08.223]                     save_rds(obj, file)
[10:22:08.223]                   }
[10:22:08.223]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4kEgVJ/.future/immediateConditions")
[10:22:08.223]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:08.223]                   {
[10:22:08.223]                     inherits <- base::inherits
[10:22:08.223]                     invokeRestart <- base::invokeRestart
[10:22:08.223]                     is.null <- base::is.null
[10:22:08.223]                     muffled <- FALSE
[10:22:08.223]                     if (inherits(cond, "message")) {
[10:22:08.223]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:08.223]                       if (muffled) 
[10:22:08.223]                         invokeRestart("muffleMessage")
[10:22:08.223]                     }
[10:22:08.223]                     else if (inherits(cond, "warning")) {
[10:22:08.223]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:08.223]                       if (muffled) 
[10:22:08.223]                         invokeRestart("muffleWarning")
[10:22:08.223]                     }
[10:22:08.223]                     else if (inherits(cond, "condition")) {
[10:22:08.223]                       if (!is.null(pattern)) {
[10:22:08.223]                         computeRestarts <- base::computeRestarts
[10:22:08.223]                         grepl <- base::grepl
[10:22:08.223]                         restarts <- computeRestarts(cond)
[10:22:08.223]                         for (restart in restarts) {
[10:22:08.223]                           name <- restart$name
[10:22:08.223]                           if (is.null(name)) 
[10:22:08.223]                             next
[10:22:08.223]                           if (!grepl(pattern, name)) 
[10:22:08.223]                             next
[10:22:08.223]                           invokeRestart(restart)
[10:22:08.223]                           muffled <- TRUE
[10:22:08.223]                           break
[10:22:08.223]                         }
[10:22:08.223]                       }
[10:22:08.223]                     }
[10:22:08.223]                     invisible(muffled)
[10:22:08.223]                   }
[10:22:08.223]                   muffleCondition(cond)
[10:22:08.223]                 })
[10:22:08.223]             }))
[10:22:08.223]             future::FutureResult(value = ...future.value$value, 
[10:22:08.223]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:08.223]                   ...future.rng), globalenv = if (FALSE) 
[10:22:08.223]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:08.223]                     ...future.globalenv.names))
[10:22:08.223]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:08.223]         }, condition = base::local({
[10:22:08.223]             c <- base::c
[10:22:08.223]             inherits <- base::inherits
[10:22:08.223]             invokeRestart <- base::invokeRestart
[10:22:08.223]             length <- base::length
[10:22:08.223]             list <- base::list
[10:22:08.223]             seq.int <- base::seq.int
[10:22:08.223]             signalCondition <- base::signalCondition
[10:22:08.223]             sys.calls <- base::sys.calls
[10:22:08.223]             `[[` <- base::`[[`
[10:22:08.223]             `+` <- base::`+`
[10:22:08.223]             `<<-` <- base::`<<-`
[10:22:08.223]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:08.223]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:08.223]                   3L)]
[10:22:08.223]             }
[10:22:08.223]             function(cond) {
[10:22:08.223]                 is_error <- inherits(cond, "error")
[10:22:08.223]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:08.223]                   NULL)
[10:22:08.223]                 if (is_error) {
[10:22:08.223]                   sessionInformation <- function() {
[10:22:08.223]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:08.223]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:08.223]                       search = base::search(), system = base::Sys.info())
[10:22:08.223]                   }
[10:22:08.223]                   ...future.conditions[[length(...future.conditions) + 
[10:22:08.223]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:08.223]                     cond$call), session = sessionInformation(), 
[10:22:08.223]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:08.223]                   signalCondition(cond)
[10:22:08.223]                 }
[10:22:08.223]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:08.223]                 "immediateCondition"))) {
[10:22:08.223]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:08.223]                   ...future.conditions[[length(...future.conditions) + 
[10:22:08.223]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:08.223]                   if (TRUE && !signal) {
[10:22:08.223]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:08.223]                     {
[10:22:08.223]                       inherits <- base::inherits
[10:22:08.223]                       invokeRestart <- base::invokeRestart
[10:22:08.223]                       is.null <- base::is.null
[10:22:08.223]                       muffled <- FALSE
[10:22:08.223]                       if (inherits(cond, "message")) {
[10:22:08.223]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:08.223]                         if (muffled) 
[10:22:08.223]                           invokeRestart("muffleMessage")
[10:22:08.223]                       }
[10:22:08.223]                       else if (inherits(cond, "warning")) {
[10:22:08.223]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:08.223]                         if (muffled) 
[10:22:08.223]                           invokeRestart("muffleWarning")
[10:22:08.223]                       }
[10:22:08.223]                       else if (inherits(cond, "condition")) {
[10:22:08.223]                         if (!is.null(pattern)) {
[10:22:08.223]                           computeRestarts <- base::computeRestarts
[10:22:08.223]                           grepl <- base::grepl
[10:22:08.223]                           restarts <- computeRestarts(cond)
[10:22:08.223]                           for (restart in restarts) {
[10:22:08.223]                             name <- restart$name
[10:22:08.223]                             if (is.null(name)) 
[10:22:08.223]                               next
[10:22:08.223]                             if (!grepl(pattern, name)) 
[10:22:08.223]                               next
[10:22:08.223]                             invokeRestart(restart)
[10:22:08.223]                             muffled <- TRUE
[10:22:08.223]                             break
[10:22:08.223]                           }
[10:22:08.223]                         }
[10:22:08.223]                       }
[10:22:08.223]                       invisible(muffled)
[10:22:08.223]                     }
[10:22:08.223]                     muffleCondition(cond, pattern = "^muffle")
[10:22:08.223]                   }
[10:22:08.223]                 }
[10:22:08.223]                 else {
[10:22:08.223]                   if (TRUE) {
[10:22:08.223]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:08.223]                     {
[10:22:08.223]                       inherits <- base::inherits
[10:22:08.223]                       invokeRestart <- base::invokeRestart
[10:22:08.223]                       is.null <- base::is.null
[10:22:08.223]                       muffled <- FALSE
[10:22:08.223]                       if (inherits(cond, "message")) {
[10:22:08.223]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:08.223]                         if (muffled) 
[10:22:08.223]                           invokeRestart("muffleMessage")
[10:22:08.223]                       }
[10:22:08.223]                       else if (inherits(cond, "warning")) {
[10:22:08.223]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:08.223]                         if (muffled) 
[10:22:08.223]                           invokeRestart("muffleWarning")
[10:22:08.223]                       }
[10:22:08.223]                       else if (inherits(cond, "condition")) {
[10:22:08.223]                         if (!is.null(pattern)) {
[10:22:08.223]                           computeRestarts <- base::computeRestarts
[10:22:08.223]                           grepl <- base::grepl
[10:22:08.223]                           restarts <- computeRestarts(cond)
[10:22:08.223]                           for (restart in restarts) {
[10:22:08.223]                             name <- restart$name
[10:22:08.223]                             if (is.null(name)) 
[10:22:08.223]                               next
[10:22:08.223]                             if (!grepl(pattern, name)) 
[10:22:08.223]                               next
[10:22:08.223]                             invokeRestart(restart)
[10:22:08.223]                             muffled <- TRUE
[10:22:08.223]                             break
[10:22:08.223]                           }
[10:22:08.223]                         }
[10:22:08.223]                       }
[10:22:08.223]                       invisible(muffled)
[10:22:08.223]                     }
[10:22:08.223]                     muffleCondition(cond, pattern = "^muffle")
[10:22:08.223]                   }
[10:22:08.223]                 }
[10:22:08.223]             }
[10:22:08.223]         }))
[10:22:08.223]     }, error = function(ex) {
[10:22:08.223]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:08.223]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:08.223]                 ...future.rng), started = ...future.startTime, 
[10:22:08.223]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:08.223]             version = "1.8"), class = "FutureResult")
[10:22:08.223]     }, finally = {
[10:22:08.223]         if (!identical(...future.workdir, getwd())) 
[10:22:08.223]             setwd(...future.workdir)
[10:22:08.223]         {
[10:22:08.223]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:08.223]                 ...future.oldOptions$nwarnings <- NULL
[10:22:08.223]             }
[10:22:08.223]             base::options(...future.oldOptions)
[10:22:08.223]             if (.Platform$OS.type == "windows") {
[10:22:08.223]                 old_names <- names(...future.oldEnvVars)
[10:22:08.223]                 envs <- base::Sys.getenv()
[10:22:08.223]                 names <- names(envs)
[10:22:08.223]                 common <- intersect(names, old_names)
[10:22:08.223]                 added <- setdiff(names, old_names)
[10:22:08.223]                 removed <- setdiff(old_names, names)
[10:22:08.223]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:08.223]                   envs[common]]
[10:22:08.223]                 NAMES <- toupper(changed)
[10:22:08.223]                 args <- list()
[10:22:08.223]                 for (kk in seq_along(NAMES)) {
[10:22:08.223]                   name <- changed[[kk]]
[10:22:08.223]                   NAME <- NAMES[[kk]]
[10:22:08.223]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:08.223]                     next
[10:22:08.223]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:08.223]                 }
[10:22:08.223]                 NAMES <- toupper(added)
[10:22:08.223]                 for (kk in seq_along(NAMES)) {
[10:22:08.223]                   name <- added[[kk]]
[10:22:08.223]                   NAME <- NAMES[[kk]]
[10:22:08.223]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:08.223]                     next
[10:22:08.223]                   args[[name]] <- ""
[10:22:08.223]                 }
[10:22:08.223]                 NAMES <- toupper(removed)
[10:22:08.223]                 for (kk in seq_along(NAMES)) {
[10:22:08.223]                   name <- removed[[kk]]
[10:22:08.223]                   NAME <- NAMES[[kk]]
[10:22:08.223]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:08.223]                     next
[10:22:08.223]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:08.223]                 }
[10:22:08.223]                 if (length(args) > 0) 
[10:22:08.223]                   base::do.call(base::Sys.setenv, args = args)
[10:22:08.223]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:08.223]             }
[10:22:08.223]             else {
[10:22:08.223]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:08.223]             }
[10:22:08.223]             {
[10:22:08.223]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:08.223]                   0L) {
[10:22:08.223]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:08.223]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:08.223]                   base::options(opts)
[10:22:08.223]                 }
[10:22:08.223]                 {
[10:22:08.223]                   {
[10:22:08.223]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:08.223]                     NULL
[10:22:08.223]                   }
[10:22:08.223]                   options(future.plan = NULL)
[10:22:08.223]                   if (is.na(NA_character_)) 
[10:22:08.223]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:08.223]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:08.223]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:08.223]                     .init = FALSE)
[10:22:08.223]                 }
[10:22:08.223]             }
[10:22:08.223]         }
[10:22:08.223]     })
[10:22:08.223]     if (TRUE) {
[10:22:08.223]         base::sink(type = "output", split = FALSE)
[10:22:08.223]         if (TRUE) {
[10:22:08.223]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:08.223]         }
[10:22:08.223]         else {
[10:22:08.223]             ...future.result["stdout"] <- base::list(NULL)
[10:22:08.223]         }
[10:22:08.223]         base::close(...future.stdout)
[10:22:08.223]         ...future.stdout <- NULL
[10:22:08.223]     }
[10:22:08.223]     ...future.result$conditions <- ...future.conditions
[10:22:08.223]     ...future.result$finished <- base::Sys.time()
[10:22:08.223]     ...future.result
[10:22:08.223] }
[10:22:08.226] assign_globals() ...
[10:22:08.226] List of 1
[10:22:08.226]  $ data:'data.frame':	3 obs. of  2 variables:
[10:22:08.226]   ..$ a: int [1:3] 1 2 3
[10:22:08.226]   ..$ b: int [1:3] 3 2 1
[10:22:08.226]  - attr(*, "where")=List of 1
[10:22:08.226]   ..$ data:<environment: R_EmptyEnv> 
[10:22:08.226]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:08.226]  - attr(*, "resolved")= logi FALSE
[10:22:08.226]  - attr(*, "total_size")= num 356
[10:22:08.226]  - attr(*, "already-done")= logi TRUE
[10:22:08.229] - copied ‘data’ to environment
[10:22:08.230] assign_globals() ... done
[10:22:08.230] requestCore(): workers = 2
[10:22:08.232] MulticoreFuture started
[10:22:08.232] - Launch lazy future ... done
[10:22:08.233] run() for ‘MulticoreFuture’ ... done
[10:22:08.233] result() for MulticoreFuture ...
[10:22:08.233] plan(): Setting new future strategy stack:
[10:22:08.234] List of future strategies:
[10:22:08.234] 1. multicore:
[10:22:08.234]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:08.234]    - tweaked: FALSE
[10:22:08.234]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:08.237] plan(): nbrOfWorkers() = 1
[10:22:08.265] plan(): Setting new future strategy stack:
[10:22:08.265] List of future strategies:
[10:22:08.265] 1. multicore:
[10:22:08.265]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:08.265]    - tweaked: FALSE
[10:22:08.265]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:08.265] 2. multicore:
[10:22:08.265]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:08.265]    - tweaked: FALSE
[10:22:08.265]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:08.267] plan(): nbrOfWorkers() = 2
[10:22:08.268] result() for MulticoreFuture ...
[10:22:08.268] result() for MulticoreFuture ... done
[10:22:08.268] signalConditions() ...
[10:22:08.269]  - include = ‘immediateCondition’
[10:22:08.269]  - exclude = 
[10:22:08.269]  - resignal = FALSE
[10:22:08.269]  - Number of conditions: 52
[10:22:08.269] signalConditions() ... done
[10:22:08.269] result() for MulticoreFuture ... done
[10:22:08.269] result() for MulticoreFuture ...
[10:22:08.270] result() for MulticoreFuture ... done
[10:22:08.270] signalConditions() ...
[10:22:08.270]  - include = ‘immediateCondition’
[10:22:08.270]  - exclude = 
[10:22:08.270]  - resignal = FALSE
[10:22:08.270]  - Number of conditions: 52
[10:22:08.270] signalConditions() ... done
[10:22:08.271] Future state: ‘finished’
[10:22:08.271] result() for MulticoreFuture ...
[10:22:08.271] result() for MulticoreFuture ... done
[10:22:08.271] signalConditions() ...
[10:22:08.271]  - include = ‘condition’
[10:22:08.271]  - exclude = ‘immediateCondition’
[10:22:08.271]  - resignal = TRUE
[10:22:08.271]  - Number of conditions: 52
[10:22:08.271]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.239] getGlobalsAndPackages() ...
[10:22:08.272]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.239] Searching for globals...
[10:22:08.272]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.241] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[10:22:08.272]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.241] Searching for globals ... DONE
[10:22:08.272]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.241] Resolving globals: FALSE
[10:22:08.272]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.242] The total size of the 1 globals is 356 bytes (356 bytes)
[10:22:08.273]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.243] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[10:22:08.273]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.243] - globals: [1] ‘data’
[10:22:08.273]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.243] 
[10:22:08.273]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.243] getGlobalsAndPackages() ... DONE
[10:22:08.273]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.244] run() for ‘Future’ ...
[10:22:08.274]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.244] - state: ‘created’
[10:22:08.274]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.245] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:08.274]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.247] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:08.274]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.247] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:08.274]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.247]   - Field: ‘label’
[10:22:08.274]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.247]   - Field: ‘local’
[10:22:08.274]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.248]   - Field: ‘owner’
[10:22:08.275]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.248]   - Field: ‘envir’
[10:22:08.275]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.248]   - Field: ‘packages’
[10:22:08.275]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.248]   - Field: ‘gc’
[10:22:08.275]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.248]   - Field: ‘conditions’
[10:22:08.275]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.248]   - Field: ‘expr’
[10:22:08.275]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.249]   - Field: ‘uuid’
[10:22:08.276]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.249]   - Field: ‘seed’
[10:22:08.276]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.249]   - Field: ‘version’
[10:22:08.276]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.249]   - Field: ‘result’
[10:22:08.276]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.249]   - Field: ‘asynchronous’
[10:22:08.276]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.249]   - Field: ‘calls’
[10:22:08.276]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.250]   - Field: ‘globals’
[10:22:08.277]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.250]   - Field: ‘stdout’
[10:22:08.277]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.250]   - Field: ‘earlySignal’
[10:22:08.277]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.250]   - Field: ‘lazy’
[10:22:08.277]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.250]   - Field: ‘state’
[10:22:08.277]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.251] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:08.277]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.251] - Launch lazy future ...
[10:22:08.277]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.251] Packages needed by the future expression (n = 0): <none>
[10:22:08.278]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.251] Packages needed by future strategies (n = 0): <none>
[10:22:08.278]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.252] {
[10:22:08.252]     {
[10:22:08.252]         {
[10:22:08.252]             ...future.startTime <- base::Sys.time()
[10:22:08.252]             {
[10:22:08.252]                 {
[10:22:08.252]                   {
[10:22:08.252]                     base::local({
[10:22:08.252]                       has_future <- base::requireNamespace("future", 
[10:22:08.252]                         quietly = TRUE)
[10:22:08.252]                       if (has_future) {
[10:22:08.252]                         ns <- base::getNamespace("future")
[10:22:08.252]                         version <- ns[[".package"]][["version"]]
[10:22:08.252]                         if (is.null(version)) 
[10:22:08.252]                           version <- utils::packageVersion("future")
[10:22:08.252]                       }
[10:22:08.252]                       else {
[10:22:08.252]                         version <- NULL
[10:22:08.252]                       }
[10:22:08.252]                       if (!has_future || version < "1.8.0") {
[10:22:08.252]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:08.252]                           "", base::R.version$version.string), 
[10:22:08.252]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:08.252]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:08.252]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:08.252]                             "release", "version")], collapse = " "), 
[10:22:08.252]                           hostname = base::Sys.info()[["nodename"]])
[10:22:08.252]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:08.252]                           info)
[10:22:08.252]                         info <- base::paste(info, collapse = "; ")
[10:22:08.252]                         if (!has_future) {
[10:22:08.252]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:08.252]                             info)
[10:22:08.252]                         }
[10:22:08.252]                         else {
[10:22:08.252]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:08.252]                             info, version)
[10:22:08.252]                         }
[10:22:08.252]                         base::stop(msg)
[10:22:08.252]                       }
[10:22:08.252]                     })
[10:22:08.252]                   }
[10:22:08.252]                   ...future.strategy.old <- future::plan("list")
[10:22:08.252]                   options(future.plan = NULL)
[10:22:08.252]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:08.252]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:08.252]                 }
[10:22:08.252]                 ...future.workdir <- getwd()
[10:22:08.252]             }
[10:22:08.252]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:08.252]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:08.252]         }
[10:22:08.252]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:08.252]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:08.252]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:08.252]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:08.252]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:08.252]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:08.252]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:08.252]             base::names(...future.oldOptions))
[10:22:08.252]     }
[10:22:08.252]     if (FALSE) {
[10:22:08.252]     }
[10:22:08.252]     else {
[10:22:08.252]         if (TRUE) {
[10:22:08.252]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:08.252]                 open = "w")
[10:22:08.252]         }
[10:22:08.252]         else {
[10:22:08.252]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:08.252]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:08.252]         }
[10:22:08.252]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:08.252]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:08.252]             base::sink(type = "output", split = FALSE)
[10:22:08.252]             base::close(...future.stdout)
[10:22:08.252]         }, add = TRUE)
[10:22:08.252]     }
[10:22:08.252]     ...future.frame <- base::sys.nframe()
[10:22:08.252]     ...future.conditions <- base::list()
[10:22:08.252]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:08.252]     if (FALSE) {
[10:22:08.252]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:08.252]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:08.252]     }
[10:22:08.252]     ...future.result <- base::tryCatch({
[10:22:08.252]         base::withCallingHandlers({
[10:22:08.252]             ...future.value <- base::withVisible(base::local(subset(data, 
[10:22:08.252]                 a == 2)))
[10:22:08.252]             future::FutureResult(value = ...future.value$value, 
[10:22:08.252]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:08.252]                   ...future.rng), globalenv = if (FALSE) 
[10:22:08.252]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:08.252]                     ...future.globalenv.names))
[10:22:08.252]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:08.252]         }, condition = base::local({
[10:22:08.252]             c <- base::c
[10:22:08.252]             inherits <- base::inherits
[10:22:08.252]             invokeRestart <- base::invokeRestart
[10:22:08.252]             length <- base::length
[10:22:08.252]             list <- base::list
[10:22:08.252]             seq.int <- base::seq.int
[10:22:08.252]             signalCondition <- base::signalCondition
[10:22:08.252]             sys.calls <- base::sys.calls
[10:22:08.252]             `[[` <- base::`[[`
[10:22:08.252]             `+` <- base::`+`
[10:22:08.252]             `<<-` <- base::`<<-`
[10:22:08.252]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:08.252]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:08.252]                   3L)]
[10:22:08.252]             }
[10:22:08.252]             function(cond) {
[10:22:08.252]                 is_error <- inherits(cond, "error")
[10:22:08.252]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:08.252]                   NULL)
[10:22:08.252]                 if (is_error) {
[10:22:08.252]                   sessionInformation <- function() {
[10:22:08.252]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:08.252]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:08.252]                       search = base::search(), system = base::Sys.info())
[10:22:08.252]                   }
[10:22:08.252]                   ...future.conditions[[length(...future.conditions) + 
[10:22:08.252]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:08.252]                     cond$call), session = sessionInformation(), 
[10:22:08.252]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:08.252]                   signalCondition(cond)
[10:22:08.252]                 }
[10:22:08.252]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:08.252]                 "immediateCondition"))) {
[10:22:08.252]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:08.252]                   ...future.conditions[[length(...future.conditions) + 
[10:22:08.252]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:08.252]                   if (TRUE && !signal) {
[10:22:08.252]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:08.252]                     {
[10:22:08.252]                       inherits <- base::inherits
[10:22:08.252]                       invokeRestart <- base::invokeRestart
[10:22:08.252]                       is.null <- base::is.null
[10:22:08.252]                       muffled <- FALSE
[10:22:08.252]                       if (inherits(cond, "message")) {
[10:22:08.252]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:08.252]                         if (muffled) 
[10:22:08.252]                           invokeRestart("muffleMessage")
[10:22:08.252]                       }
[10:22:08.252]                       else if (inherits(cond, "warning")) {
[10:22:08.252]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:08.252]                         if (muffled) 
[10:22:08.252]                           invokeRestart("muffleWarning")
[10:22:08.252]                       }
[10:22:08.252]                       else if (inherits(cond, "condition")) {
[10:22:08.252]                         if (!is.null(pattern)) {
[10:22:08.252]                           computeRestarts <- base::computeRestarts
[10:22:08.252]                           grepl <- base::grepl
[10:22:08.252]                           restarts <- computeRestarts(cond)
[10:22:08.252]                           for (restart in restarts) {
[10:22:08.252]                             name <- restart$name
[10:22:08.252]                             if (is.null(name)) 
[10:22:08.252]                               next
[10:22:08.252]                             if (!grepl(pattern, name)) 
[10:22:08.252]                               next
[10:22:08.252]                             invokeRestart(restart)
[10:22:08.252]                             muffled <- TRUE
[10:22:08.252]                             break
[10:22:08.252]                           }
[10:22:08.252]                         }
[10:22:08.252]                       }
[10:22:08.252]                       invisible(muffled)
[10:22:08.252]                     }
[10:22:08.252]                     muffleCondition(cond, pattern = "^muffle")
[10:22:08.252]                   }
[10:22:08.252]                 }
[10:22:08.252]                 else {
[10:22:08.252]                   if (TRUE) {
[10:22:08.252]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:08.252]                     {
[10:22:08.252]                       inherits <- base::inherits
[10:22:08.252]                       invokeRestart <- base::invokeRestart
[10:22:08.252]                       is.null <- base::is.null
[10:22:08.252]                       muffled <- FALSE
[10:22:08.252]                       if (inherits(cond, "message")) {
[10:22:08.252]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:08.252]                         if (muffled) 
[10:22:08.252]                           invokeRestart("muffleMessage")
[10:22:08.252]                       }
[10:22:08.252]                       else if (inherits(cond, "warning")) {
[10:22:08.252]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:08.252]                         if (muffled) 
[10:22:08.252]                           invokeRestart("muffleWarning")
[10:22:08.252]                       }
[10:22:08.252]                       else if (inherits(cond, "condition")) {
[10:22:08.252]                         if (!is.null(pattern)) {
[10:22:08.252]                           computeRestarts <- base::computeRestarts
[10:22:08.252]                           grepl <- base::grepl
[10:22:08.252]                           restarts <- computeRestarts(cond)
[10:22:08.252]                           for (restart in restarts) {
[10:22:08.252]                             name <- restart$name
[10:22:08.252]                             if (is.null(name)) 
[10:22:08.252]                               next
[10:22:08.252]                             if (!grepl(pattern, name)) 
[10:22:08.252]                               next
[10:22:08.252]                             invokeRestart(restart)
[10:22:08.252]                             muffled <- TRUE
[10:22:08.252]                             break
[10:22:08.252]                           }
[10:22:08.252]                         }
[10:22:08.252]                       }
[10:22:08.252]                       invisible(muffled)
[10:22:08.252]                     }
[10:22:08.252]                     muffleCondition(cond, pattern = "^muffle")
[10:22:08.252]                   }
[10:22:08.252]                 }
[10:22:08.252]             }
[10:22:08.252]         }))
[10:22:08.252]     }, error = function(ex) {
[10:22:08.252]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:08.252]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:08.252]                 ...future.rng), started = ...future.startTime, 
[10:22:08.252]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:08.252]             version = "1.8"), class = "FutureResult")
[10:22:08.252]     }, finally = {
[10:22:08.252]         if (!identical(...future.workdir, getwd())) 
[10:22:08.252]             setwd(...future.workdir)
[10:22:08.252]         {
[10:22:08.252]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:08.252]                 ...future.oldOptions$nwarnings <- NULL
[10:22:08.252]             }
[10:22:08.252]             base::options(...future.oldOptions)
[10:22:08.252]             if (.Platform$OS.type == "windows") {
[10:22:08.252]                 old_names <- names(...future.oldEnvVars)
[10:22:08.252]                 envs <- base::Sys.getenv()
[10:22:08.252]                 names <- names(envs)
[10:22:08.252]                 common <- intersect(names, old_names)
[10:22:08.252]                 added <- setdiff(names, old_names)
[10:22:08.252]                 removed <- setdiff(old_names, names)
[10:22:08.252]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:08.252]                   envs[common]]
[10:22:08.252]                 NAMES <- toupper(changed)
[10:22:08.252]                 args <- list()
[10:22:08.252]                 for (kk in seq_along(NAMES)) {
[10:22:08.252]                   name <- changed[[kk]]
[10:22:08.252]                   NAME <- NAMES[[kk]]
[10:22:08.252]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:08.252]                     next
[10:22:08.252]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:08.252]                 }
[10:22:08.252]                 NAMES <- toupper(added)
[10:22:08.252]                 for (kk in seq_along(NAMES)) {
[10:22:08.252]                   name <- added[[kk]]
[10:22:08.252]                   NAME <- NAMES[[kk]]
[10:22:08.252]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:08.252]                     next
[10:22:08.252]                   args[[name]] <- ""
[10:22:08.252]                 }
[10:22:08.252]                 NAMES <- toupper(removed)
[10:22:08.252]                 for (kk in seq_along(NAMES)) {
[10:22:08.252]                   name <- removed[[kk]]
[10:22:08.252]                   NAME <- NAMES[[kk]]
[10:22:08.252]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:08.252]                     next
[10:22:08.252]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:08.252]                 }
[10:22:08.252]                 if (length(args) > 0) 
[10:22:08.252]                   base::do.call(base::Sys.setenv, args = args)
[10:22:08.252]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:08.252]             }
[10:22:08.252]             else {
[10:22:08.252]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:08.252]             }
[10:22:08.252]             {
[10:22:08.252]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:08.252]                   0L) {
[10:22:08.252]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:08.252]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:08.252]                   base::options(opts)
[10:22:08.252]                 }
[10:22:08.252]                 {
[10:22:08.252]                   {
[10:22:08.252]                     NULL
[10:22:08.252]                     RNGkind("Mersenne-Twister")
[10:22:08.252]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:08.252]                       inherits = FALSE)
[10:22:08.252]                   }
[10:22:08.252]                   options(future.plan = NULL)
[10:22:08.252]                   if (is.na(NA_character_)) 
[10:22:08.252]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:08.252]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:08.252]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:08.252]                     .init = FALSE)
[10:22:08.252]                 }
[10:22:08.252]             }
[10:22:08.252]         }
[10:22:08.252]     })
[10:22:08.252]     if (TRUE) {
[10:22:08.252]         base::sink(type = "output", split = FALSE)
[10:22:08.252]         if (TRUE) {
[10:22:08.252]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:08.252]         }
[10:22:08.252]         else {
[10:22:08.252]             ...future.result["stdout"] <- base::list(NULL)
[10:22:08.252]         }
[10:22:08.252]         base::close(...future.stdout)
[10:22:08.252]         ...future.stdout <- NULL
[10:22:08.252]     }
[10:22:08.252]     ...future.result$conditions <- ...future.conditions
[10:22:08.252]     ...future.result$finished <- base::Sys.time()
[10:22:08.252]     ...future.result
[10:22:08.252] }
[10:22:08.278]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.254] assign_globals() ...
[10:22:08.278]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.254] List of 1
[10:22:08.254]  $ data:'data.frame':	3 obs. of  2 variables:
[10:22:08.254]   ..$ a: int [1:3] 1 2 3
[10:22:08.254]   ..$ b: int [1:3] 3 2 1
[10:22:08.254]  - attr(*, "where")=List of 1
[10:22:08.254]   ..$ data:<environment: R_EmptyEnv> 
[10:22:08.254]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:08.254]  - attr(*, "resolved")= logi FALSE
[10:22:08.254]  - attr(*, "total_size")= num 356
[10:22:08.254]  - attr(*, "already-done")= logi TRUE
[10:22:08.278]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.259] - copied ‘data’ to environment
[10:22:08.279]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.259] assign_globals() ... done
[10:22:08.279]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.259] plan(): Setting new future strategy stack:
[10:22:08.279]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.260] List of future strategies:
[10:22:08.260] 1. sequential:
[10:22:08.260]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:08.260]    - tweaked: FALSE
[10:22:08.260]    - call: NULL
[10:22:08.279]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.260] plan(): nbrOfWorkers() = 1
[10:22:08.279]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.261] plan(): Setting new future strategy stack:
[10:22:08.279]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.261] List of future strategies:
[10:22:08.261] 1. multicore:
[10:22:08.261]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:08.261]    - tweaked: FALSE
[10:22:08.261]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:08.279]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.263] plan(): nbrOfWorkers() = 1
[10:22:08.280]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.264] SequentialFuture started (and completed)
[10:22:08.280]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.264] - Launch lazy future ... done
[10:22:08.280]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.264] run() for ‘SequentialFuture’ ... done
[10:22:08.280] signalConditions() ... done
- plan(list('multicore', 'multicore')) ... DONE
- plan(list('multicore', 'multisession')) ...
[10:22:08.281] plan(): Setting new future strategy stack:
[10:22:08.281] List of future strategies:
[10:22:08.281] 1. multicore:
[10:22:08.281]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:08.281]    - tweaked: FALSE
[10:22:08.281]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:08.281] 2. multisession:
[10:22:08.281]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:22:08.281]    - tweaked: FALSE
[10:22:08.281]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:08.283] plan(): nbrOfWorkers() = 2
[10:22:08.283] getGlobalsAndPackages() ...
[10:22:08.284] Searching for globals...
[10:22:08.303] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[10:22:08.303] Searching for globals ... DONE
[10:22:08.303] Resolving globals: FALSE
[10:22:08.304] The total size of the 2 globals is 11.73 KiB (12016 bytes)
[10:22:08.305] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 11.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (11.68 KiB of class ‘list’) and ‘strategy2’ (51 bytes of class ‘character’)
[10:22:08.305] - globals: [2] ‘nested’, ‘strategy2’
[10:22:08.305] - packages: [1] ‘future’
[10:22:08.305] getGlobalsAndPackages() ... DONE
[10:22:08.305] run() for ‘Future’ ...
[10:22:08.306] - state: ‘created’
[10:22:08.306] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:08.307] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:08.308] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:08.308]   - Field: ‘label’
[10:22:08.308]   - Field: ‘local’
[10:22:08.308]   - Field: ‘owner’
[10:22:08.308]   - Field: ‘envir’
[10:22:08.308]   - Field: ‘workers’
[10:22:08.308]   - Field: ‘packages’
[10:22:08.308]   - Field: ‘gc’
[10:22:08.309]   - Field: ‘job’
[10:22:08.309]   - Field: ‘conditions’
[10:22:08.309]   - Field: ‘expr’
[10:22:08.309]   - Field: ‘uuid’
[10:22:08.309]   - Field: ‘seed’
[10:22:08.309]   - Field: ‘version’
[10:22:08.309]   - Field: ‘result’
[10:22:08.309]   - Field: ‘asynchronous’
[10:22:08.309]   - Field: ‘calls’
[10:22:08.309]   - Field: ‘globals’
[10:22:08.310]   - Field: ‘stdout’
[10:22:08.310]   - Field: ‘earlySignal’
[10:22:08.310]   - Field: ‘lazy’
[10:22:08.310]   - Field: ‘state’
[10:22:08.310] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:08.310] - Launch lazy future ...
[10:22:08.310] Packages needed by the future expression (n = 1): ‘future’
[10:22:08.311] Packages needed by future strategies (n = 1): ‘future’
[10:22:08.311] {
[10:22:08.311]     {
[10:22:08.311]         {
[10:22:08.311]             ...future.startTime <- base::Sys.time()
[10:22:08.311]             {
[10:22:08.311]                 {
[10:22:08.311]                   {
[10:22:08.311]                     {
[10:22:08.311]                       {
[10:22:08.311]                         base::local({
[10:22:08.311]                           has_future <- base::requireNamespace("future", 
[10:22:08.311]                             quietly = TRUE)
[10:22:08.311]                           if (has_future) {
[10:22:08.311]                             ns <- base::getNamespace("future")
[10:22:08.311]                             version <- ns[[".package"]][["version"]]
[10:22:08.311]                             if (is.null(version)) 
[10:22:08.311]                               version <- utils::packageVersion("future")
[10:22:08.311]                           }
[10:22:08.311]                           else {
[10:22:08.311]                             version <- NULL
[10:22:08.311]                           }
[10:22:08.311]                           if (!has_future || version < "1.8.0") {
[10:22:08.311]                             info <- base::c(r_version = base::gsub("R version ", 
[10:22:08.311]                               "", base::R.version$version.string), 
[10:22:08.311]                               platform = base::sprintf("%s (%s-bit)", 
[10:22:08.311]                                 base::R.version$platform, 8 * 
[10:22:08.311]                                   base::.Machine$sizeof.pointer), 
[10:22:08.311]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:08.311]                                 "release", "version")], collapse = " "), 
[10:22:08.311]                               hostname = base::Sys.info()[["nodename"]])
[10:22:08.311]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:22:08.311]                               info)
[10:22:08.311]                             info <- base::paste(info, collapse = "; ")
[10:22:08.311]                             if (!has_future) {
[10:22:08.311]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:08.311]                                 info)
[10:22:08.311]                             }
[10:22:08.311]                             else {
[10:22:08.311]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:08.311]                                 info, version)
[10:22:08.311]                             }
[10:22:08.311]                             base::stop(msg)
[10:22:08.311]                           }
[10:22:08.311]                         })
[10:22:08.311]                       }
[10:22:08.311]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:08.311]                       base::options(mc.cores = 1L)
[10:22:08.311]                     }
[10:22:08.311]                     base::local({
[10:22:08.311]                       for (pkg in "future") {
[10:22:08.311]                         base::loadNamespace(pkg)
[10:22:08.311]                         base::library(pkg, character.only = TRUE)
[10:22:08.311]                       }
[10:22:08.311]                     })
[10:22:08.311]                   }
[10:22:08.311]                   ...future.strategy.old <- future::plan("list")
[10:22:08.311]                   options(future.plan = NULL)
[10:22:08.311]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:08.311]                   future::plan(list(b = function (..., workers = availableCores(), 
[10:22:08.311]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:08.311]                     envir = parent.frame()) 
[10:22:08.311]                   {
[10:22:08.311]                     if (is.function(workers)) 
[10:22:08.311]                       workers <- workers()
[10:22:08.311]                     workers <- structure(as.integer(workers), 
[10:22:08.311]                       class = class(workers))
[10:22:08.311]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:08.311]                       workers >= 1)
[10:22:08.311]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:08.311]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:08.311]                     }
[10:22:08.311]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:08.311]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:08.311]                       envir = envir)
[10:22:08.311]                     if (!future$lazy) 
[10:22:08.311]                       future <- run(future)
[10:22:08.311]                     invisible(future)
[10:22:08.311]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:08.311]                 }
[10:22:08.311]                 ...future.workdir <- getwd()
[10:22:08.311]             }
[10:22:08.311]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:08.311]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:08.311]         }
[10:22:08.311]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:08.311]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:08.311]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:08.311]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:08.311]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:08.311]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:08.311]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:08.311]             base::names(...future.oldOptions))
[10:22:08.311]     }
[10:22:08.311]     if (FALSE) {
[10:22:08.311]     }
[10:22:08.311]     else {
[10:22:08.311]         if (TRUE) {
[10:22:08.311]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:08.311]                 open = "w")
[10:22:08.311]         }
[10:22:08.311]         else {
[10:22:08.311]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:08.311]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:08.311]         }
[10:22:08.311]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:08.311]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:08.311]             base::sink(type = "output", split = FALSE)
[10:22:08.311]             base::close(...future.stdout)
[10:22:08.311]         }, add = TRUE)
[10:22:08.311]     }
[10:22:08.311]     ...future.frame <- base::sys.nframe()
[10:22:08.311]     ...future.conditions <- base::list()
[10:22:08.311]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:08.311]     if (FALSE) {
[10:22:08.311]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:08.311]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:08.311]     }
[10:22:08.311]     ...future.result <- base::tryCatch({
[10:22:08.311]         base::withCallingHandlers({
[10:22:08.311]             ...future.value <- base::withVisible(base::local({
[10:22:08.311]                 withCallingHandlers({
[10:22:08.311]                   {
[10:22:08.311]                     a <- 1L
[10:22:08.311]                     plan_a <- unclass(future::plan("list"))
[10:22:08.311]                     nested_a <- nested[-1]
[10:22:08.311]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[10:22:08.311]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[10:22:08.311]                       strategy2))
[10:22:08.311]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[10:22:08.311]                       "init") <- NULL
[10:22:08.311]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[10:22:08.311]                       "init") <- NULL
[10:22:08.311]                     stopifnot(all.equal(plan_a, nested_a))
[10:22:08.311]                     y %<-% {
[10:22:08.311]                       b <- 2L
[10:22:08.311]                       plan_b <- future::plan("list")
[10:22:08.311]                       nested_b <- nested_a[-1]
[10:22:08.311]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:22:08.311]                         1L, inherits(plan_b[[1]], "future"), 
[10:22:08.311]                         inherits(future::plan("next"), "sequential"))
[10:22:08.311]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:22:08.311]                         b = b, nested_b = nested_b, plan_b = plan_b)
[10:22:08.311]                     }
[10:22:08.311]                     y
[10:22:08.311]                   }
[10:22:08.311]                 }, immediateCondition = function(cond) {
[10:22:08.311]                   save_rds <- function (object, pathname, ...) 
[10:22:08.311]                   {
[10:22:08.311]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:08.311]                     if (file_test("-f", pathname_tmp)) {
[10:22:08.311]                       fi_tmp <- file.info(pathname_tmp)
[10:22:08.311]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:08.311]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:08.311]                         fi_tmp[["mtime"]])
[10:22:08.311]                     }
[10:22:08.311]                     tryCatch({
[10:22:08.311]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:08.311]                     }, error = function(ex) {
[10:22:08.311]                       msg <- conditionMessage(ex)
[10:22:08.311]                       fi_tmp <- file.info(pathname_tmp)
[10:22:08.311]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:08.311]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:08.311]                         fi_tmp[["mtime"]], msg)
[10:22:08.311]                       ex$message <- msg
[10:22:08.311]                       stop(ex)
[10:22:08.311]                     })
[10:22:08.311]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:08.311]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:08.311]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:08.311]                       fi_tmp <- file.info(pathname_tmp)
[10:22:08.311]                       fi <- file.info(pathname)
[10:22:08.311]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:08.311]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:08.311]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:08.311]                         fi[["size"]], fi[["mtime"]])
[10:22:08.311]                       stop(msg)
[10:22:08.311]                     }
[10:22:08.311]                     invisible(pathname)
[10:22:08.311]                   }
[10:22:08.311]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:08.311]                     rootPath = tempdir()) 
[10:22:08.311]                   {
[10:22:08.311]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:08.311]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:08.311]                       tmpdir = path, fileext = ".rds")
[10:22:08.311]                     save_rds(obj, file)
[10:22:08.311]                   }
[10:22:08.311]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4kEgVJ/.future/immediateConditions")
[10:22:08.311]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:08.311]                   {
[10:22:08.311]                     inherits <- base::inherits
[10:22:08.311]                     invokeRestart <- base::invokeRestart
[10:22:08.311]                     is.null <- base::is.null
[10:22:08.311]                     muffled <- FALSE
[10:22:08.311]                     if (inherits(cond, "message")) {
[10:22:08.311]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:08.311]                       if (muffled) 
[10:22:08.311]                         invokeRestart("muffleMessage")
[10:22:08.311]                     }
[10:22:08.311]                     else if (inherits(cond, "warning")) {
[10:22:08.311]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:08.311]                       if (muffled) 
[10:22:08.311]                         invokeRestart("muffleWarning")
[10:22:08.311]                     }
[10:22:08.311]                     else if (inherits(cond, "condition")) {
[10:22:08.311]                       if (!is.null(pattern)) {
[10:22:08.311]                         computeRestarts <- base::computeRestarts
[10:22:08.311]                         grepl <- base::grepl
[10:22:08.311]                         restarts <- computeRestarts(cond)
[10:22:08.311]                         for (restart in restarts) {
[10:22:08.311]                           name <- restart$name
[10:22:08.311]                           if (is.null(name)) 
[10:22:08.311]                             next
[10:22:08.311]                           if (!grepl(pattern, name)) 
[10:22:08.311]                             next
[10:22:08.311]                           invokeRestart(restart)
[10:22:08.311]                           muffled <- TRUE
[10:22:08.311]                           break
[10:22:08.311]                         }
[10:22:08.311]                       }
[10:22:08.311]                     }
[10:22:08.311]                     invisible(muffled)
[10:22:08.311]                   }
[10:22:08.311]                   muffleCondition(cond)
[10:22:08.311]                 })
[10:22:08.311]             }))
[10:22:08.311]             future::FutureResult(value = ...future.value$value, 
[10:22:08.311]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:08.311]                   ...future.rng), globalenv = if (FALSE) 
[10:22:08.311]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:08.311]                     ...future.globalenv.names))
[10:22:08.311]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:08.311]         }, condition = base::local({
[10:22:08.311]             c <- base::c
[10:22:08.311]             inherits <- base::inherits
[10:22:08.311]             invokeRestart <- base::invokeRestart
[10:22:08.311]             length <- base::length
[10:22:08.311]             list <- base::list
[10:22:08.311]             seq.int <- base::seq.int
[10:22:08.311]             signalCondition <- base::signalCondition
[10:22:08.311]             sys.calls <- base::sys.calls
[10:22:08.311]             `[[` <- base::`[[`
[10:22:08.311]             `+` <- base::`+`
[10:22:08.311]             `<<-` <- base::`<<-`
[10:22:08.311]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:08.311]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:08.311]                   3L)]
[10:22:08.311]             }
[10:22:08.311]             function(cond) {
[10:22:08.311]                 is_error <- inherits(cond, "error")
[10:22:08.311]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:08.311]                   NULL)
[10:22:08.311]                 if (is_error) {
[10:22:08.311]                   sessionInformation <- function() {
[10:22:08.311]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:08.311]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:08.311]                       search = base::search(), system = base::Sys.info())
[10:22:08.311]                   }
[10:22:08.311]                   ...future.conditions[[length(...future.conditions) + 
[10:22:08.311]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:08.311]                     cond$call), session = sessionInformation(), 
[10:22:08.311]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:08.311]                   signalCondition(cond)
[10:22:08.311]                 }
[10:22:08.311]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:08.311]                 "immediateCondition"))) {
[10:22:08.311]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:08.311]                   ...future.conditions[[length(...future.conditions) + 
[10:22:08.311]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:08.311]                   if (TRUE && !signal) {
[10:22:08.311]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:08.311]                     {
[10:22:08.311]                       inherits <- base::inherits
[10:22:08.311]                       invokeRestart <- base::invokeRestart
[10:22:08.311]                       is.null <- base::is.null
[10:22:08.311]                       muffled <- FALSE
[10:22:08.311]                       if (inherits(cond, "message")) {
[10:22:08.311]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:08.311]                         if (muffled) 
[10:22:08.311]                           invokeRestart("muffleMessage")
[10:22:08.311]                       }
[10:22:08.311]                       else if (inherits(cond, "warning")) {
[10:22:08.311]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:08.311]                         if (muffled) 
[10:22:08.311]                           invokeRestart("muffleWarning")
[10:22:08.311]                       }
[10:22:08.311]                       else if (inherits(cond, "condition")) {
[10:22:08.311]                         if (!is.null(pattern)) {
[10:22:08.311]                           computeRestarts <- base::computeRestarts
[10:22:08.311]                           grepl <- base::grepl
[10:22:08.311]                           restarts <- computeRestarts(cond)
[10:22:08.311]                           for (restart in restarts) {
[10:22:08.311]                             name <- restart$name
[10:22:08.311]                             if (is.null(name)) 
[10:22:08.311]                               next
[10:22:08.311]                             if (!grepl(pattern, name)) 
[10:22:08.311]                               next
[10:22:08.311]                             invokeRestart(restart)
[10:22:08.311]                             muffled <- TRUE
[10:22:08.311]                             break
[10:22:08.311]                           }
[10:22:08.311]                         }
[10:22:08.311]                       }
[10:22:08.311]                       invisible(muffled)
[10:22:08.311]                     }
[10:22:08.311]                     muffleCondition(cond, pattern = "^muffle")
[10:22:08.311]                   }
[10:22:08.311]                 }
[10:22:08.311]                 else {
[10:22:08.311]                   if (TRUE) {
[10:22:08.311]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:08.311]                     {
[10:22:08.311]                       inherits <- base::inherits
[10:22:08.311]                       invokeRestart <- base::invokeRestart
[10:22:08.311]                       is.null <- base::is.null
[10:22:08.311]                       muffled <- FALSE
[10:22:08.311]                       if (inherits(cond, "message")) {
[10:22:08.311]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:08.311]                         if (muffled) 
[10:22:08.311]                           invokeRestart("muffleMessage")
[10:22:08.311]                       }
[10:22:08.311]                       else if (inherits(cond, "warning")) {
[10:22:08.311]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:08.311]                         if (muffled) 
[10:22:08.311]                           invokeRestart("muffleWarning")
[10:22:08.311]                       }
[10:22:08.311]                       else if (inherits(cond, "condition")) {
[10:22:08.311]                         if (!is.null(pattern)) {
[10:22:08.311]                           computeRestarts <- base::computeRestarts
[10:22:08.311]                           grepl <- base::grepl
[10:22:08.311]                           restarts <- computeRestarts(cond)
[10:22:08.311]                           for (restart in restarts) {
[10:22:08.311]                             name <- restart$name
[10:22:08.311]                             if (is.null(name)) 
[10:22:08.311]                               next
[10:22:08.311]                             if (!grepl(pattern, name)) 
[10:22:08.311]                               next
[10:22:08.311]                             invokeRestart(restart)
[10:22:08.311]                             muffled <- TRUE
[10:22:08.311]                             break
[10:22:08.311]                           }
[10:22:08.311]                         }
[10:22:08.311]                       }
[10:22:08.311]                       invisible(muffled)
[10:22:08.311]                     }
[10:22:08.311]                     muffleCondition(cond, pattern = "^muffle")
[10:22:08.311]                   }
[10:22:08.311]                 }
[10:22:08.311]             }
[10:22:08.311]         }))
[10:22:08.311]     }, error = function(ex) {
[10:22:08.311]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:08.311]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:08.311]                 ...future.rng), started = ...future.startTime, 
[10:22:08.311]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:08.311]             version = "1.8"), class = "FutureResult")
[10:22:08.311]     }, finally = {
[10:22:08.311]         if (!identical(...future.workdir, getwd())) 
[10:22:08.311]             setwd(...future.workdir)
[10:22:08.311]         {
[10:22:08.311]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:08.311]                 ...future.oldOptions$nwarnings <- NULL
[10:22:08.311]             }
[10:22:08.311]             base::options(...future.oldOptions)
[10:22:08.311]             if (.Platform$OS.type == "windows") {
[10:22:08.311]                 old_names <- names(...future.oldEnvVars)
[10:22:08.311]                 envs <- base::Sys.getenv()
[10:22:08.311]                 names <- names(envs)
[10:22:08.311]                 common <- intersect(names, old_names)
[10:22:08.311]                 added <- setdiff(names, old_names)
[10:22:08.311]                 removed <- setdiff(old_names, names)
[10:22:08.311]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:08.311]                   envs[common]]
[10:22:08.311]                 NAMES <- toupper(changed)
[10:22:08.311]                 args <- list()
[10:22:08.311]                 for (kk in seq_along(NAMES)) {
[10:22:08.311]                   name <- changed[[kk]]
[10:22:08.311]                   NAME <- NAMES[[kk]]
[10:22:08.311]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:08.311]                     next
[10:22:08.311]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:08.311]                 }
[10:22:08.311]                 NAMES <- toupper(added)
[10:22:08.311]                 for (kk in seq_along(NAMES)) {
[10:22:08.311]                   name <- added[[kk]]
[10:22:08.311]                   NAME <- NAMES[[kk]]
[10:22:08.311]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:08.311]                     next
[10:22:08.311]                   args[[name]] <- ""
[10:22:08.311]                 }
[10:22:08.311]                 NAMES <- toupper(removed)
[10:22:08.311]                 for (kk in seq_along(NAMES)) {
[10:22:08.311]                   name <- removed[[kk]]
[10:22:08.311]                   NAME <- NAMES[[kk]]
[10:22:08.311]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:08.311]                     next
[10:22:08.311]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:08.311]                 }
[10:22:08.311]                 if (length(args) > 0) 
[10:22:08.311]                   base::do.call(base::Sys.setenv, args = args)
[10:22:08.311]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:08.311]             }
[10:22:08.311]             else {
[10:22:08.311]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:08.311]             }
[10:22:08.311]             {
[10:22:08.311]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:08.311]                   0L) {
[10:22:08.311]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:08.311]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:08.311]                   base::options(opts)
[10:22:08.311]                 }
[10:22:08.311]                 {
[10:22:08.311]                   {
[10:22:08.311]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:08.311]                     NULL
[10:22:08.311]                   }
[10:22:08.311]                   options(future.plan = NULL)
[10:22:08.311]                   if (is.na(NA_character_)) 
[10:22:08.311]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:08.311]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:08.311]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:08.311]                     .init = FALSE)
[10:22:08.311]                 }
[10:22:08.311]             }
[10:22:08.311]         }
[10:22:08.311]     })
[10:22:08.311]     if (TRUE) {
[10:22:08.311]         base::sink(type = "output", split = FALSE)
[10:22:08.311]         if (TRUE) {
[10:22:08.311]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:08.311]         }
[10:22:08.311]         else {
[10:22:08.311]             ...future.result["stdout"] <- base::list(NULL)
[10:22:08.311]         }
[10:22:08.311]         base::close(...future.stdout)
[10:22:08.311]         ...future.stdout <- NULL
[10:22:08.311]     }
[10:22:08.311]     ...future.result$conditions <- ...future.conditions
[10:22:08.311]     ...future.result$finished <- base::Sys.time()
[10:22:08.311]     ...future.result
[10:22:08.311] }
[10:22:08.314] assign_globals() ...
[10:22:08.314] List of 2
[10:22:08.314]  $ nested   :List of 2
[10:22:08.314]   ..$ a:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[10:22:08.314]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[10:22:08.314]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:22:08.314]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:08.314]     envir = parent.frame())  
[10:22:08.314]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[10:22:08.314]   .. ..- attr(*, "init")= logi TRUE
[10:22:08.314]   .. ..- attr(*, "cleanup")=function ()  
[10:22:08.314]   .. ..- attr(*, "untweakable")= chr "persistent"
[10:22:08.314]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:22:08.314]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:22:08.314]  $ strategy2: chr "multisession"
[10:22:08.314]  - attr(*, "where")=List of 2
[10:22:08.314]   ..$ nested   :<environment: R_EmptyEnv> 
[10:22:08.314]   ..$ strategy2:<environment: R_EmptyEnv> 
[10:22:08.314]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:08.314]  - attr(*, "resolved")= logi FALSE
[10:22:08.314]  - attr(*, "total_size")= num 12016
[10:22:08.314]  - attr(*, "already-done")= logi TRUE
[10:22:08.323] - copied ‘nested’ to environment
[10:22:08.323] - copied ‘strategy2’ to environment
[10:22:08.323] assign_globals() ... done
[10:22:08.323] requestCore(): workers = 2
[10:22:08.326] MulticoreFuture started
[10:22:08.326] - Launch lazy future ... done
[10:22:08.326] run() for ‘MulticoreFuture’ ... done
[10:22:08.327] result() for MulticoreFuture ...
[10:22:08.327] plan(): Setting new future strategy stack:
[10:22:08.328] List of future strategies:
[10:22:08.328] 1. multisession:
[10:22:08.328]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:22:08.328]    - tweaked: FALSE
[10:22:08.328]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:08.332] plan(): nbrOfWorkers() = 1
[10:22:08.383] plan(): Setting new future strategy stack:
[10:22:08.383] List of future strategies:
[10:22:08.383] 1. multicore:
[10:22:08.383]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:08.383]    - tweaked: FALSE
[10:22:08.383]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:08.383] 2. multisession:
[10:22:08.383]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:22:08.383]    - tweaked: FALSE
[10:22:08.383]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:08.385] plan(): nbrOfWorkers() = 2
[10:22:08.387] result() for MulticoreFuture ...
[10:22:08.387] result() for MulticoreFuture ... done
[10:22:08.387] signalConditions() ...
[10:22:08.387]  - include = ‘immediateCondition’
[10:22:08.388]  - exclude = 
[10:22:08.388]  - resignal = FALSE
[10:22:08.388]  - Number of conditions: 54
[10:22:08.388] signalConditions() ... done
[10:22:08.388] result() for MulticoreFuture ... done
[10:22:08.388] result() for MulticoreFuture ...
[10:22:08.388] result() for MulticoreFuture ... done
[10:22:08.388] signalConditions() ...
[10:22:08.388]  - include = ‘immediateCondition’
[10:22:08.389]  - exclude = 
[10:22:08.389]  - resignal = FALSE
[10:22:08.389]  - Number of conditions: 54
[10:22:08.389] signalConditions() ... done
[10:22:08.389] Future state: ‘finished’
[10:22:08.389] result() for MulticoreFuture ...
[10:22:08.389] result() for MulticoreFuture ... done
[10:22:08.389] signalConditions() ...
[10:22:08.390]  - include = ‘condition’
[10:22:08.390]  - exclude = ‘immediateCondition’
[10:22:08.390]  - resignal = TRUE
[10:22:08.390]  - Number of conditions: 54
[10:22:08.390]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.335] getGlobalsAndPackages() ...
[10:22:08.390]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.335] Searching for globals...
[10:22:08.390]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.345] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[10:22:08.391]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.346] Searching for globals ... DONE
[10:22:08.391]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.346] Resolving globals: FALSE
[10:22:08.391]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.347] The total size of the 3 globals is 11.81 KiB (12089 bytes)
[10:22:08.391]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.348] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 11.81 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (5.89 KiB of class ‘list’), ‘plan_a’ (5.89 KiB of class ‘list’) and ‘a’ (35 bytes of class ‘numeric’)
[10:22:08.391]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.348] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[10:22:08.391]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.349] 
[10:22:08.392]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.349] getGlobalsAndPackages() ... DONE
[10:22:08.392]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.350] run() for ‘Future’ ...
[10:22:08.392]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.350] - state: ‘created’
[10:22:08.392]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.350] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:08.392]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.353] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:08.392]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.353] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:08.392]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.353]   - Field: ‘label’
[10:22:08.393]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.354]   - Field: ‘local’
[10:22:08.393]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.354]   - Field: ‘owner’
[10:22:08.393]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.354]   - Field: ‘envir’
[10:22:08.393]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.354]   - Field: ‘packages’
[10:22:08.393]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.354]   - Field: ‘gc’
[10:22:08.393]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.355]   - Field: ‘conditions’
[10:22:08.394]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.355]   - Field: ‘expr’
[10:22:08.394]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.355]   - Field: ‘uuid’
[10:22:08.394]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.355]   - Field: ‘seed’
[10:22:08.394]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.356]   - Field: ‘version’
[10:22:08.394]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.356]   - Field: ‘result’
[10:22:08.394]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.356]   - Field: ‘asynchronous’
[10:22:08.394]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.356]   - Field: ‘calls’
[10:22:08.395]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.356]   - Field: ‘globals’
[10:22:08.395]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.357]   - Field: ‘stdout’
[10:22:08.395]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.357]   - Field: ‘earlySignal’
[10:22:08.395]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.357]   - Field: ‘lazy’
[10:22:08.395]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.357]   - Field: ‘state’
[10:22:08.395]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.357] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:08.396]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.358] - Launch lazy future ...
[10:22:08.396]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.358] Packages needed by the future expression (n = 0): <none>
[10:22:08.396]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.358] Packages needed by future strategies (n = 0): <none>
[10:22:08.396]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.359] {
[10:22:08.359]     {
[10:22:08.359]         {
[10:22:08.359]             ...future.startTime <- base::Sys.time()
[10:22:08.359]             {
[10:22:08.359]                 {
[10:22:08.359]                   {
[10:22:08.359]                     base::local({
[10:22:08.359]                       has_future <- base::requireNamespace("future", 
[10:22:08.359]                         quietly = TRUE)
[10:22:08.359]                       if (has_future) {
[10:22:08.359]                         ns <- base::getNamespace("future")
[10:22:08.359]                         version <- ns[[".package"]][["version"]]
[10:22:08.359]                         if (is.null(version)) 
[10:22:08.359]                           version <- utils::packageVersion("future")
[10:22:08.359]                       }
[10:22:08.359]                       else {
[10:22:08.359]                         version <- NULL
[10:22:08.359]                       }
[10:22:08.359]                       if (!has_future || version < "1.8.0") {
[10:22:08.359]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:08.359]                           "", base::R.version$version.string), 
[10:22:08.359]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:08.359]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:08.359]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:08.359]                             "release", "version")], collapse = " "), 
[10:22:08.359]                           hostname = base::Sys.info()[["nodename"]])
[10:22:08.359]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:08.359]                           info)
[10:22:08.359]                         info <- base::paste(info, collapse = "; ")
[10:22:08.359]                         if (!has_future) {
[10:22:08.359]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:08.359]                             info)
[10:22:08.359]                         }
[10:22:08.359]                         else {
[10:22:08.359]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:08.359]                             info, version)
[10:22:08.359]                         }
[10:22:08.359]                         base::stop(msg)
[10:22:08.359]                       }
[10:22:08.359]                     })
[10:22:08.359]                   }
[10:22:08.359]                   ...future.strategy.old <- future::plan("list")
[10:22:08.359]                   options(future.plan = NULL)
[10:22:08.359]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:08.359]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:08.359]                 }
[10:22:08.359]                 ...future.workdir <- getwd()
[10:22:08.359]             }
[10:22:08.359]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:08.359]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:08.359]         }
[10:22:08.359]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:08.359]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:08.359]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:08.359]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:08.359]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:08.359]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:08.359]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:08.359]             base::names(...future.oldOptions))
[10:22:08.359]     }
[10:22:08.359]     if (FALSE) {
[10:22:08.359]     }
[10:22:08.359]     else {
[10:22:08.359]         if (TRUE) {
[10:22:08.359]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:08.359]                 open = "w")
[10:22:08.359]         }
[10:22:08.359]         else {
[10:22:08.359]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:08.359]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:08.359]         }
[10:22:08.359]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:08.359]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:08.359]             base::sink(type = "output", split = FALSE)
[10:22:08.359]             base::close(...future.stdout)
[10:22:08.359]         }, add = TRUE)
[10:22:08.359]     }
[10:22:08.359]     ...future.frame <- base::sys.nframe()
[10:22:08.359]     ...future.conditions <- base::list()
[10:22:08.359]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:08.359]     if (FALSE) {
[10:22:08.359]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:08.359]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:08.359]     }
[10:22:08.359]     ...future.result <- base::tryCatch({
[10:22:08.359]         base::withCallingHandlers({
[10:22:08.359]             ...future.value <- base::withVisible(base::local({
[10:22:08.359]                 b <- 2L
[10:22:08.359]                 plan_b <- future::plan("list")
[10:22:08.359]                 nested_b <- nested_a[-1]
[10:22:08.359]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:22:08.359]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[10:22:08.359]                   "sequential"))
[10:22:08.359]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:22:08.359]                   b = b, nested_b = nested_b, plan_b = plan_b)
[10:22:08.359]             }))
[10:22:08.359]             future::FutureResult(value = ...future.value$value, 
[10:22:08.359]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:08.359]                   ...future.rng), globalenv = if (FALSE) 
[10:22:08.359]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:08.359]                     ...future.globalenv.names))
[10:22:08.359]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:08.359]         }, condition = base::local({
[10:22:08.359]             c <- base::c
[10:22:08.359]             inherits <- base::inherits
[10:22:08.359]             invokeRestart <- base::invokeRestart
[10:22:08.359]             length <- base::length
[10:22:08.359]             list <- base::list
[10:22:08.359]             seq.int <- base::seq.int
[10:22:08.359]             signalCondition <- base::signalCondition
[10:22:08.359]             sys.calls <- base::sys.calls
[10:22:08.359]             `[[` <- base::`[[`
[10:22:08.359]             `+` <- base::`+`
[10:22:08.359]             `<<-` <- base::`<<-`
[10:22:08.359]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:08.359]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:08.359]                   3L)]
[10:22:08.359]             }
[10:22:08.359]             function(cond) {
[10:22:08.359]                 is_error <- inherits(cond, "error")
[10:22:08.359]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:08.359]                   NULL)
[10:22:08.359]                 if (is_error) {
[10:22:08.359]                   sessionInformation <- function() {
[10:22:08.359]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:08.359]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:08.359]                       search = base::search(), system = base::Sys.info())
[10:22:08.359]                   }
[10:22:08.359]                   ...future.conditions[[length(...future.conditions) + 
[10:22:08.359]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:08.359]                     cond$call), session = sessionInformation(), 
[10:22:08.359]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:08.359]                   signalCondition(cond)
[10:22:08.359]                 }
[10:22:08.359]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:08.359]                 "immediateCondition"))) {
[10:22:08.359]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:08.359]                   ...future.conditions[[length(...future.conditions) + 
[10:22:08.359]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:08.359]                   if (TRUE && !signal) {
[10:22:08.359]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:08.359]                     {
[10:22:08.359]                       inherits <- base::inherits
[10:22:08.359]                       invokeRestart <- base::invokeRestart
[10:22:08.359]                       is.null <- base::is.null
[10:22:08.359]                       muffled <- FALSE
[10:22:08.359]                       if (inherits(cond, "message")) {
[10:22:08.359]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:08.359]                         if (muffled) 
[10:22:08.359]                           invokeRestart("muffleMessage")
[10:22:08.359]                       }
[10:22:08.359]                       else if (inherits(cond, "warning")) {
[10:22:08.359]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:08.359]                         if (muffled) 
[10:22:08.359]                           invokeRestart("muffleWarning")
[10:22:08.359]                       }
[10:22:08.359]                       else if (inherits(cond, "condition")) {
[10:22:08.359]                         if (!is.null(pattern)) {
[10:22:08.359]                           computeRestarts <- base::computeRestarts
[10:22:08.359]                           grepl <- base::grepl
[10:22:08.359]                           restarts <- computeRestarts(cond)
[10:22:08.359]                           for (restart in restarts) {
[10:22:08.359]                             name <- restart$name
[10:22:08.359]                             if (is.null(name)) 
[10:22:08.359]                               next
[10:22:08.359]                             if (!grepl(pattern, name)) 
[10:22:08.359]                               next
[10:22:08.359]                             invokeRestart(restart)
[10:22:08.359]                             muffled <- TRUE
[10:22:08.359]                             break
[10:22:08.359]                           }
[10:22:08.359]                         }
[10:22:08.359]                       }
[10:22:08.359]                       invisible(muffled)
[10:22:08.359]                     }
[10:22:08.359]                     muffleCondition(cond, pattern = "^muffle")
[10:22:08.359]                   }
[10:22:08.359]                 }
[10:22:08.359]                 else {
[10:22:08.359]                   if (TRUE) {
[10:22:08.359]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:08.359]                     {
[10:22:08.359]                       inherits <- base::inherits
[10:22:08.359]                       invokeRestart <- base::invokeRestart
[10:22:08.359]                       is.null <- base::is.null
[10:22:08.359]                       muffled <- FALSE
[10:22:08.359]                       if (inherits(cond, "message")) {
[10:22:08.359]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:08.359]                         if (muffled) 
[10:22:08.359]                           invokeRestart("muffleMessage")
[10:22:08.359]                       }
[10:22:08.359]                       else if (inherits(cond, "warning")) {
[10:22:08.359]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:08.359]                         if (muffled) 
[10:22:08.359]                           invokeRestart("muffleWarning")
[10:22:08.359]                       }
[10:22:08.359]                       else if (inherits(cond, "condition")) {
[10:22:08.359]                         if (!is.null(pattern)) {
[10:22:08.359]                           computeRestarts <- base::computeRestarts
[10:22:08.359]                           grepl <- base::grepl
[10:22:08.359]                           restarts <- computeRestarts(cond)
[10:22:08.359]                           for (restart in restarts) {
[10:22:08.359]                             name <- restart$name
[10:22:08.359]                             if (is.null(name)) 
[10:22:08.359]                               next
[10:22:08.359]                             if (!grepl(pattern, name)) 
[10:22:08.359]                               next
[10:22:08.359]                             invokeRestart(restart)
[10:22:08.359]                             muffled <- TRUE
[10:22:08.359]                             break
[10:22:08.359]                           }
[10:22:08.359]                         }
[10:22:08.359]                       }
[10:22:08.359]                       invisible(muffled)
[10:22:08.359]                     }
[10:22:08.359]                     muffleCondition(cond, pattern = "^muffle")
[10:22:08.359]                   }
[10:22:08.359]                 }
[10:22:08.359]             }
[10:22:08.359]         }))
[10:22:08.359]     }, error = function(ex) {
[10:22:08.359]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:08.359]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:08.359]                 ...future.rng), started = ...future.startTime, 
[10:22:08.359]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:08.359]             version = "1.8"), class = "FutureResult")
[10:22:08.359]     }, finally = {
[10:22:08.359]         if (!identical(...future.workdir, getwd())) 
[10:22:08.359]             setwd(...future.workdir)
[10:22:08.359]         {
[10:22:08.359]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:08.359]                 ...future.oldOptions$nwarnings <- NULL
[10:22:08.359]             }
[10:22:08.359]             base::options(...future.oldOptions)
[10:22:08.359]             if (.Platform$OS.type == "windows") {
[10:22:08.359]                 old_names <- names(...future.oldEnvVars)
[10:22:08.359]                 envs <- base::Sys.getenv()
[10:22:08.359]                 names <- names(envs)
[10:22:08.359]                 common <- intersect(names, old_names)
[10:22:08.359]                 added <- setdiff(names, old_names)
[10:22:08.359]                 removed <- setdiff(old_names, names)
[10:22:08.359]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:08.359]                   envs[common]]
[10:22:08.359]                 NAMES <- toupper(changed)
[10:22:08.359]                 args <- list()
[10:22:08.359]                 for (kk in seq_along(NAMES)) {
[10:22:08.359]                   name <- changed[[kk]]
[10:22:08.359]                   NAME <- NAMES[[kk]]
[10:22:08.359]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:08.359]                     next
[10:22:08.359]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:08.359]                 }
[10:22:08.359]                 NAMES <- toupper(added)
[10:22:08.359]                 for (kk in seq_along(NAMES)) {
[10:22:08.359]                   name <- added[[kk]]
[10:22:08.359]                   NAME <- NAMES[[kk]]
[10:22:08.359]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:08.359]                     next
[10:22:08.359]                   args[[name]] <- ""
[10:22:08.359]                 }
[10:22:08.359]                 NAMES <- toupper(removed)
[10:22:08.359]                 for (kk in seq_along(NAMES)) {
[10:22:08.359]                   name <- removed[[kk]]
[10:22:08.359]                   NAME <- NAMES[[kk]]
[10:22:08.359]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:08.359]                     next
[10:22:08.359]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:08.359]                 }
[10:22:08.359]                 if (length(args) > 0) 
[10:22:08.359]                   base::do.call(base::Sys.setenv, args = args)
[10:22:08.359]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:08.359]             }
[10:22:08.359]             else {
[10:22:08.359]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:08.359]             }
[10:22:08.359]             {
[10:22:08.359]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:08.359]                   0L) {
[10:22:08.359]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:08.359]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:08.359]                   base::options(opts)
[10:22:08.359]                 }
[10:22:08.359]                 {
[10:22:08.359]                   {
[10:22:08.359]                     NULL
[10:22:08.359]                     RNGkind("Mersenne-Twister")
[10:22:08.359]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:08.359]                       inherits = FALSE)
[10:22:08.359]                   }
[10:22:08.359]                   options(future.plan = NULL)
[10:22:08.359]                   if (is.na(NA_character_)) 
[10:22:08.359]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:08.359]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:08.359]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:08.359]                     .init = FALSE)
[10:22:08.359]                 }
[10:22:08.359]             }
[10:22:08.359]         }
[10:22:08.359]     })
[10:22:08.359]     if (TRUE) {
[10:22:08.359]         base::sink(type = "output", split = FALSE)
[10:22:08.359]         if (TRUE) {
[10:22:08.359]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:08.359]         }
[10:22:08.359]         else {
[10:22:08.359]             ...future.result["stdout"] <- base::list(NULL)
[10:22:08.359]         }
[10:22:08.359]         base::close(...future.stdout)
[10:22:08.359]         ...future.stdout <- NULL
[10:22:08.359]     }
[10:22:08.359]     ...future.result$conditions <- ...future.conditions
[10:22:08.359]     ...future.result$finished <- base::Sys.time()
[10:22:08.359]     ...future.result
[10:22:08.359] }
[10:22:08.396]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.362] assign_globals() ...
[10:22:08.397]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.362] List of 3
[10:22:08.362]  $ nested_a:List of 1
[10:22:08.362]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:08.362]     envir = parent.frame())  
[10:22:08.362]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[10:22:08.362]   .. ..- attr(*, "cleanup")=function ()  
[10:22:08.362]   .. ..- attr(*, "untweakable")= chr "persistent"
[10:22:08.362]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:22:08.362]  $ a       : int 1
[10:22:08.362]  $ plan_a  :List of 1
[10:22:08.362]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:08.362]     envir = parent.frame())  
[10:22:08.362]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[10:22:08.362]   .. ..- attr(*, "cleanup")=function ()  
[10:22:08.362]   .. ..- attr(*, "untweakable")= chr "persistent"
[10:22:08.362]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[10:22:08.362]  - attr(*, "where")=List of 3
[10:22:08.362]   ..$ nested_a:<environment: R_EmptyEnv> 
[10:22:08.362]   ..$ a       :<environment: R_EmptyEnv> 
[10:22:08.362]   ..$ plan_a  :<environment: R_EmptyEnv> 
[10:22:08.362]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:08.362]  - attr(*, "resolved")= logi FALSE
[10:22:08.362]  - attr(*, "total_size")= num 12089
[10:22:08.362]  - attr(*, "already-done")= logi TRUE
[10:22:08.397]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.374] - copied ‘nested_a’ to environment
[10:22:08.397]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.375] - copied ‘a’ to environment
[10:22:08.397]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.375] - copied ‘plan_a’ to environment
[10:22:08.397]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.375] assign_globals() ... done
[10:22:08.397]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.376] plan(): Setting new future strategy stack:
[10:22:08.397]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.376] List of future strategies:
[10:22:08.376] 1. sequential:
[10:22:08.376]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:08.376]    - tweaked: FALSE
[10:22:08.376]    - call: NULL
[10:22:08.398]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.377] plan(): nbrOfWorkers() = 1
[10:22:08.398]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.379] plan(): Setting new future strategy stack:
[10:22:08.398]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.379] List of future strategies:
[10:22:08.379] 1. multisession:
[10:22:08.379]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:22:08.379]    - tweaked: FALSE
[10:22:08.379]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:08.398]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.381] plan(): nbrOfWorkers() = 1
[10:22:08.398]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.382] SequentialFuture started (and completed)
[10:22:08.398]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.382] - Launch lazy future ... done
[10:22:08.399]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.382] run() for ‘SequentialFuture’ ... done
[10:22:08.399] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "cleanup")=function ()  
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "cleanup")=function ()  
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:22:08.406] getGlobalsAndPackages() ...
[10:22:08.406] Searching for globals...
[10:22:08.408] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[10:22:08.408] Searching for globals ... DONE
[10:22:08.409] Resolving globals: FALSE
[10:22:08.409] The total size of the 1 globals is 356 bytes (356 bytes)
[10:22:08.410] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[10:22:08.410] - globals: [1] ‘data’
[10:22:08.410] - packages: [1] ‘future’
[10:22:08.410] getGlobalsAndPackages() ... DONE
[10:22:08.411] run() for ‘Future’ ...
[10:22:08.411] - state: ‘created’
[10:22:08.411] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:22:08.413] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:08.413] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:22:08.414]   - Field: ‘label’
[10:22:08.414]   - Field: ‘local’
[10:22:08.414]   - Field: ‘owner’
[10:22:08.414]   - Field: ‘envir’
[10:22:08.414]   - Field: ‘workers’
[10:22:08.414]   - Field: ‘packages’
[10:22:08.414]   - Field: ‘gc’
[10:22:08.415]   - Field: ‘job’
[10:22:08.415]   - Field: ‘conditions’
[10:22:08.415]   - Field: ‘expr’
[10:22:08.415]   - Field: ‘uuid’
[10:22:08.415]   - Field: ‘seed’
[10:22:08.415]   - Field: ‘version’
[10:22:08.415]   - Field: ‘result’
[10:22:08.415]   - Field: ‘asynchronous’
[10:22:08.415]   - Field: ‘calls’
[10:22:08.416]   - Field: ‘globals’
[10:22:08.416]   - Field: ‘stdout’
[10:22:08.416]   - Field: ‘earlySignal’
[10:22:08.416]   - Field: ‘lazy’
[10:22:08.416]   - Field: ‘state’
[10:22:08.416] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:22:08.416] - Launch lazy future ...
[10:22:08.417] Packages needed by the future expression (n = 1): ‘future’
[10:22:08.417] Packages needed by future strategies (n = 1): ‘future’
[10:22:08.417] {
[10:22:08.417]     {
[10:22:08.417]         {
[10:22:08.417]             ...future.startTime <- base::Sys.time()
[10:22:08.417]             {
[10:22:08.417]                 {
[10:22:08.417]                   {
[10:22:08.417]                     {
[10:22:08.417]                       {
[10:22:08.417]                         base::local({
[10:22:08.417]                           has_future <- base::requireNamespace("future", 
[10:22:08.417]                             quietly = TRUE)
[10:22:08.417]                           if (has_future) {
[10:22:08.417]                             ns <- base::getNamespace("future")
[10:22:08.417]                             version <- ns[[".package"]][["version"]]
[10:22:08.417]                             if (is.null(version)) 
[10:22:08.417]                               version <- utils::packageVersion("future")
[10:22:08.417]                           }
[10:22:08.417]                           else {
[10:22:08.417]                             version <- NULL
[10:22:08.417]                           }
[10:22:08.417]                           if (!has_future || version < "1.8.0") {
[10:22:08.417]                             info <- base::c(r_version = base::gsub("R version ", 
[10:22:08.417]                               "", base::R.version$version.string), 
[10:22:08.417]                               platform = base::sprintf("%s (%s-bit)", 
[10:22:08.417]                                 base::R.version$platform, 8 * 
[10:22:08.417]                                   base::.Machine$sizeof.pointer), 
[10:22:08.417]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:08.417]                                 "release", "version")], collapse = " "), 
[10:22:08.417]                               hostname = base::Sys.info()[["nodename"]])
[10:22:08.417]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:22:08.417]                               info)
[10:22:08.417]                             info <- base::paste(info, collapse = "; ")
[10:22:08.417]                             if (!has_future) {
[10:22:08.417]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:08.417]                                 info)
[10:22:08.417]                             }
[10:22:08.417]                             else {
[10:22:08.417]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:08.417]                                 info, version)
[10:22:08.417]                             }
[10:22:08.417]                             base::stop(msg)
[10:22:08.417]                           }
[10:22:08.417]                         })
[10:22:08.417]                       }
[10:22:08.417]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:08.417]                       base::options(mc.cores = 1L)
[10:22:08.417]                     }
[10:22:08.417]                     base::local({
[10:22:08.417]                       for (pkg in "future") {
[10:22:08.417]                         base::loadNamespace(pkg)
[10:22:08.417]                         base::library(pkg, character.only = TRUE)
[10:22:08.417]                       }
[10:22:08.417]                     })
[10:22:08.417]                   }
[10:22:08.417]                   ...future.strategy.old <- future::plan("list")
[10:22:08.417]                   options(future.plan = NULL)
[10:22:08.417]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:08.417]                   future::plan(list(b = function (..., workers = availableCores(), 
[10:22:08.417]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:08.417]                     envir = parent.frame()) 
[10:22:08.417]                   {
[10:22:08.417]                     if (is.function(workers)) 
[10:22:08.417]                       workers <- workers()
[10:22:08.417]                     workers <- structure(as.integer(workers), 
[10:22:08.417]                       class = class(workers))
[10:22:08.417]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:08.417]                       workers >= 1)
[10:22:08.417]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:08.417]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:08.417]                     }
[10:22:08.417]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:08.417]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:08.417]                       envir = envir)
[10:22:08.417]                     if (!future$lazy) 
[10:22:08.417]                       future <- run(future)
[10:22:08.417]                     invisible(future)
[10:22:08.417]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:08.417]                 }
[10:22:08.417]                 ...future.workdir <- getwd()
[10:22:08.417]             }
[10:22:08.417]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:08.417]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:08.417]         }
[10:22:08.417]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:08.417]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:08.417]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:08.417]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:08.417]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:08.417]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:08.417]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:08.417]             base::names(...future.oldOptions))
[10:22:08.417]     }
[10:22:08.417]     if (FALSE) {
[10:22:08.417]     }
[10:22:08.417]     else {
[10:22:08.417]         if (TRUE) {
[10:22:08.417]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:08.417]                 open = "w")
[10:22:08.417]         }
[10:22:08.417]         else {
[10:22:08.417]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:08.417]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:08.417]         }
[10:22:08.417]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:08.417]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:08.417]             base::sink(type = "output", split = FALSE)
[10:22:08.417]             base::close(...future.stdout)
[10:22:08.417]         }, add = TRUE)
[10:22:08.417]     }
[10:22:08.417]     ...future.frame <- base::sys.nframe()
[10:22:08.417]     ...future.conditions <- base::list()
[10:22:08.417]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:08.417]     if (FALSE) {
[10:22:08.417]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:08.417]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:08.417]     }
[10:22:08.417]     ...future.result <- base::tryCatch({
[10:22:08.417]         base::withCallingHandlers({
[10:22:08.417]             ...future.value <- base::withVisible(base::local({
[10:22:08.417]                 withCallingHandlers({
[10:22:08.417]                   {
[10:22:08.417]                     value(future(subset(data, a == 2)))
[10:22:08.417]                   }
[10:22:08.417]                 }, immediateCondition = function(cond) {
[10:22:08.417]                   save_rds <- function (object, pathname, ...) 
[10:22:08.417]                   {
[10:22:08.417]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:22:08.417]                     if (file_test("-f", pathname_tmp)) {
[10:22:08.417]                       fi_tmp <- file.info(pathname_tmp)
[10:22:08.417]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:22:08.417]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:08.417]                         fi_tmp[["mtime"]])
[10:22:08.417]                     }
[10:22:08.417]                     tryCatch({
[10:22:08.417]                       saveRDS(object, file = pathname_tmp, ...)
[10:22:08.417]                     }, error = function(ex) {
[10:22:08.417]                       msg <- conditionMessage(ex)
[10:22:08.417]                       fi_tmp <- file.info(pathname_tmp)
[10:22:08.417]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:22:08.417]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:08.417]                         fi_tmp[["mtime"]], msg)
[10:22:08.417]                       ex$message <- msg
[10:22:08.417]                       stop(ex)
[10:22:08.417]                     })
[10:22:08.417]                     stopifnot(file_test("-f", pathname_tmp))
[10:22:08.417]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:22:08.417]                     if (!res || file_test("-f", pathname_tmp)) {
[10:22:08.417]                       fi_tmp <- file.info(pathname_tmp)
[10:22:08.417]                       fi <- file.info(pathname)
[10:22:08.417]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:22:08.417]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:22:08.417]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:22:08.417]                         fi[["size"]], fi[["mtime"]])
[10:22:08.417]                       stop(msg)
[10:22:08.417]                     }
[10:22:08.417]                     invisible(pathname)
[10:22:08.417]                   }
[10:22:08.417]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:22:08.417]                     rootPath = tempdir()) 
[10:22:08.417]                   {
[10:22:08.417]                     obj <- list(time = Sys.time(), condition = cond)
[10:22:08.417]                     file <- tempfile(pattern = class(cond)[1], 
[10:22:08.417]                       tmpdir = path, fileext = ".rds")
[10:22:08.417]                     save_rds(obj, file)
[10:22:08.417]                   }
[10:22:08.417]                   saveImmediateCondition(cond, path = "/tmp/Rtmp4kEgVJ/.future/immediateConditions")
[10:22:08.417]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:08.417]                   {
[10:22:08.417]                     inherits <- base::inherits
[10:22:08.417]                     invokeRestart <- base::invokeRestart
[10:22:08.417]                     is.null <- base::is.null
[10:22:08.417]                     muffled <- FALSE
[10:22:08.417]                     if (inherits(cond, "message")) {
[10:22:08.417]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:08.417]                       if (muffled) 
[10:22:08.417]                         invokeRestart("muffleMessage")
[10:22:08.417]                     }
[10:22:08.417]                     else if (inherits(cond, "warning")) {
[10:22:08.417]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:08.417]                       if (muffled) 
[10:22:08.417]                         invokeRestart("muffleWarning")
[10:22:08.417]                     }
[10:22:08.417]                     else if (inherits(cond, "condition")) {
[10:22:08.417]                       if (!is.null(pattern)) {
[10:22:08.417]                         computeRestarts <- base::computeRestarts
[10:22:08.417]                         grepl <- base::grepl
[10:22:08.417]                         restarts <- computeRestarts(cond)
[10:22:08.417]                         for (restart in restarts) {
[10:22:08.417]                           name <- restart$name
[10:22:08.417]                           if (is.null(name)) 
[10:22:08.417]                             next
[10:22:08.417]                           if (!grepl(pattern, name)) 
[10:22:08.417]                             next
[10:22:08.417]                           invokeRestart(restart)
[10:22:08.417]                           muffled <- TRUE
[10:22:08.417]                           break
[10:22:08.417]                         }
[10:22:08.417]                       }
[10:22:08.417]                     }
[10:22:08.417]                     invisible(muffled)
[10:22:08.417]                   }
[10:22:08.417]                   muffleCondition(cond)
[10:22:08.417]                 })
[10:22:08.417]             }))
[10:22:08.417]             future::FutureResult(value = ...future.value$value, 
[10:22:08.417]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:08.417]                   ...future.rng), globalenv = if (FALSE) 
[10:22:08.417]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:08.417]                     ...future.globalenv.names))
[10:22:08.417]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:08.417]         }, condition = base::local({
[10:22:08.417]             c <- base::c
[10:22:08.417]             inherits <- base::inherits
[10:22:08.417]             invokeRestart <- base::invokeRestart
[10:22:08.417]             length <- base::length
[10:22:08.417]             list <- base::list
[10:22:08.417]             seq.int <- base::seq.int
[10:22:08.417]             signalCondition <- base::signalCondition
[10:22:08.417]             sys.calls <- base::sys.calls
[10:22:08.417]             `[[` <- base::`[[`
[10:22:08.417]             `+` <- base::`+`
[10:22:08.417]             `<<-` <- base::`<<-`
[10:22:08.417]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:08.417]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:08.417]                   3L)]
[10:22:08.417]             }
[10:22:08.417]             function(cond) {
[10:22:08.417]                 is_error <- inherits(cond, "error")
[10:22:08.417]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:08.417]                   NULL)
[10:22:08.417]                 if (is_error) {
[10:22:08.417]                   sessionInformation <- function() {
[10:22:08.417]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:08.417]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:08.417]                       search = base::search(), system = base::Sys.info())
[10:22:08.417]                   }
[10:22:08.417]                   ...future.conditions[[length(...future.conditions) + 
[10:22:08.417]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:08.417]                     cond$call), session = sessionInformation(), 
[10:22:08.417]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:08.417]                   signalCondition(cond)
[10:22:08.417]                 }
[10:22:08.417]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:08.417]                 "immediateCondition"))) {
[10:22:08.417]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:08.417]                   ...future.conditions[[length(...future.conditions) + 
[10:22:08.417]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:08.417]                   if (TRUE && !signal) {
[10:22:08.417]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:08.417]                     {
[10:22:08.417]                       inherits <- base::inherits
[10:22:08.417]                       invokeRestart <- base::invokeRestart
[10:22:08.417]                       is.null <- base::is.null
[10:22:08.417]                       muffled <- FALSE
[10:22:08.417]                       if (inherits(cond, "message")) {
[10:22:08.417]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:08.417]                         if (muffled) 
[10:22:08.417]                           invokeRestart("muffleMessage")
[10:22:08.417]                       }
[10:22:08.417]                       else if (inherits(cond, "warning")) {
[10:22:08.417]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:08.417]                         if (muffled) 
[10:22:08.417]                           invokeRestart("muffleWarning")
[10:22:08.417]                       }
[10:22:08.417]                       else if (inherits(cond, "condition")) {
[10:22:08.417]                         if (!is.null(pattern)) {
[10:22:08.417]                           computeRestarts <- base::computeRestarts
[10:22:08.417]                           grepl <- base::grepl
[10:22:08.417]                           restarts <- computeRestarts(cond)
[10:22:08.417]                           for (restart in restarts) {
[10:22:08.417]                             name <- restart$name
[10:22:08.417]                             if (is.null(name)) 
[10:22:08.417]                               next
[10:22:08.417]                             if (!grepl(pattern, name)) 
[10:22:08.417]                               next
[10:22:08.417]                             invokeRestart(restart)
[10:22:08.417]                             muffled <- TRUE
[10:22:08.417]                             break
[10:22:08.417]                           }
[10:22:08.417]                         }
[10:22:08.417]                       }
[10:22:08.417]                       invisible(muffled)
[10:22:08.417]                     }
[10:22:08.417]                     muffleCondition(cond, pattern = "^muffle")
[10:22:08.417]                   }
[10:22:08.417]                 }
[10:22:08.417]                 else {
[10:22:08.417]                   if (TRUE) {
[10:22:08.417]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:08.417]                     {
[10:22:08.417]                       inherits <- base::inherits
[10:22:08.417]                       invokeRestart <- base::invokeRestart
[10:22:08.417]                       is.null <- base::is.null
[10:22:08.417]                       muffled <- FALSE
[10:22:08.417]                       if (inherits(cond, "message")) {
[10:22:08.417]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:08.417]                         if (muffled) 
[10:22:08.417]                           invokeRestart("muffleMessage")
[10:22:08.417]                       }
[10:22:08.417]                       else if (inherits(cond, "warning")) {
[10:22:08.417]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:08.417]                         if (muffled) 
[10:22:08.417]                           invokeRestart("muffleWarning")
[10:22:08.417]                       }
[10:22:08.417]                       else if (inherits(cond, "condition")) {
[10:22:08.417]                         if (!is.null(pattern)) {
[10:22:08.417]                           computeRestarts <- base::computeRestarts
[10:22:08.417]                           grepl <- base::grepl
[10:22:08.417]                           restarts <- computeRestarts(cond)
[10:22:08.417]                           for (restart in restarts) {
[10:22:08.417]                             name <- restart$name
[10:22:08.417]                             if (is.null(name)) 
[10:22:08.417]                               next
[10:22:08.417]                             if (!grepl(pattern, name)) 
[10:22:08.417]                               next
[10:22:08.417]                             invokeRestart(restart)
[10:22:08.417]                             muffled <- TRUE
[10:22:08.417]                             break
[10:22:08.417]                           }
[10:22:08.417]                         }
[10:22:08.417]                       }
[10:22:08.417]                       invisible(muffled)
[10:22:08.417]                     }
[10:22:08.417]                     muffleCondition(cond, pattern = "^muffle")
[10:22:08.417]                   }
[10:22:08.417]                 }
[10:22:08.417]             }
[10:22:08.417]         }))
[10:22:08.417]     }, error = function(ex) {
[10:22:08.417]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:08.417]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:08.417]                 ...future.rng), started = ...future.startTime, 
[10:22:08.417]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:08.417]             version = "1.8"), class = "FutureResult")
[10:22:08.417]     }, finally = {
[10:22:08.417]         if (!identical(...future.workdir, getwd())) 
[10:22:08.417]             setwd(...future.workdir)
[10:22:08.417]         {
[10:22:08.417]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:08.417]                 ...future.oldOptions$nwarnings <- NULL
[10:22:08.417]             }
[10:22:08.417]             base::options(...future.oldOptions)
[10:22:08.417]             if (.Platform$OS.type == "windows") {
[10:22:08.417]                 old_names <- names(...future.oldEnvVars)
[10:22:08.417]                 envs <- base::Sys.getenv()
[10:22:08.417]                 names <- names(envs)
[10:22:08.417]                 common <- intersect(names, old_names)
[10:22:08.417]                 added <- setdiff(names, old_names)
[10:22:08.417]                 removed <- setdiff(old_names, names)
[10:22:08.417]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:08.417]                   envs[common]]
[10:22:08.417]                 NAMES <- toupper(changed)
[10:22:08.417]                 args <- list()
[10:22:08.417]                 for (kk in seq_along(NAMES)) {
[10:22:08.417]                   name <- changed[[kk]]
[10:22:08.417]                   NAME <- NAMES[[kk]]
[10:22:08.417]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:08.417]                     next
[10:22:08.417]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:08.417]                 }
[10:22:08.417]                 NAMES <- toupper(added)
[10:22:08.417]                 for (kk in seq_along(NAMES)) {
[10:22:08.417]                   name <- added[[kk]]
[10:22:08.417]                   NAME <- NAMES[[kk]]
[10:22:08.417]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:08.417]                     next
[10:22:08.417]                   args[[name]] <- ""
[10:22:08.417]                 }
[10:22:08.417]                 NAMES <- toupper(removed)
[10:22:08.417]                 for (kk in seq_along(NAMES)) {
[10:22:08.417]                   name <- removed[[kk]]
[10:22:08.417]                   NAME <- NAMES[[kk]]
[10:22:08.417]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:08.417]                     next
[10:22:08.417]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:08.417]                 }
[10:22:08.417]                 if (length(args) > 0) 
[10:22:08.417]                   base::do.call(base::Sys.setenv, args = args)
[10:22:08.417]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:08.417]             }
[10:22:08.417]             else {
[10:22:08.417]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:08.417]             }
[10:22:08.417]             {
[10:22:08.417]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:08.417]                   0L) {
[10:22:08.417]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:08.417]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:08.417]                   base::options(opts)
[10:22:08.417]                 }
[10:22:08.417]                 {
[10:22:08.417]                   {
[10:22:08.417]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:08.417]                     NULL
[10:22:08.417]                   }
[10:22:08.417]                   options(future.plan = NULL)
[10:22:08.417]                   if (is.na(NA_character_)) 
[10:22:08.417]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:08.417]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:08.417]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:08.417]                     .init = FALSE)
[10:22:08.417]                 }
[10:22:08.417]             }
[10:22:08.417]         }
[10:22:08.417]     })
[10:22:08.417]     if (TRUE) {
[10:22:08.417]         base::sink(type = "output", split = FALSE)
[10:22:08.417]         if (TRUE) {
[10:22:08.417]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:08.417]         }
[10:22:08.417]         else {
[10:22:08.417]             ...future.result["stdout"] <- base::list(NULL)
[10:22:08.417]         }
[10:22:08.417]         base::close(...future.stdout)
[10:22:08.417]         ...future.stdout <- NULL
[10:22:08.417]     }
[10:22:08.417]     ...future.result$conditions <- ...future.conditions
[10:22:08.417]     ...future.result$finished <- base::Sys.time()
[10:22:08.417]     ...future.result
[10:22:08.417] }
[10:22:08.420] assign_globals() ...
[10:22:08.420] List of 1
[10:22:08.420]  $ data:'data.frame':	3 obs. of  2 variables:
[10:22:08.420]   ..$ a: int [1:3] 1 2 3
[10:22:08.420]   ..$ b: int [1:3] 3 2 1
[10:22:08.420]  - attr(*, "where")=List of 1
[10:22:08.420]   ..$ data:<environment: R_EmptyEnv> 
[10:22:08.420]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:08.420]  - attr(*, "resolved")= logi FALSE
[10:22:08.420]  - attr(*, "total_size")= num 356
[10:22:08.420]  - attr(*, "already-done")= logi TRUE
[10:22:08.424] - copied ‘data’ to environment
[10:22:08.424] assign_globals() ... done
[10:22:08.424] requestCore(): workers = 2
[10:22:08.427] MulticoreFuture started
[10:22:08.427] - Launch lazy future ... done
[10:22:08.427] run() for ‘MulticoreFuture’ ... done
[10:22:08.427] result() for MulticoreFuture ...
[10:22:08.428] plan(): Setting new future strategy stack:
[10:22:08.428] List of future strategies:
[10:22:08.428] 1. multisession:
[10:22:08.428]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:22:08.428]    - tweaked: FALSE
[10:22:08.428]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:08.432] plan(): nbrOfWorkers() = 1
[10:22:08.458] plan(): Setting new future strategy stack:
[10:22:08.458] List of future strategies:
[10:22:08.458] 1. multicore:
[10:22:08.458]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:08.458]    - tweaked: FALSE
[10:22:08.458]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:08.458] 2. multisession:
[10:22:08.458]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:22:08.458]    - tweaked: FALSE
[10:22:08.458]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:08.460] plan(): nbrOfWorkers() = 2
[10:22:08.461] result() for MulticoreFuture ...
[10:22:08.461] result() for MulticoreFuture ... done
[10:22:08.462] signalConditions() ...
[10:22:08.462]  - include = ‘immediateCondition’
[10:22:08.462]  - exclude = 
[10:22:08.462]  - resignal = FALSE
[10:22:08.462]  - Number of conditions: 52
[10:22:08.462] signalConditions() ... done
[10:22:08.462] result() for MulticoreFuture ... done
[10:22:08.462] result() for MulticoreFuture ...
[10:22:08.463] result() for MulticoreFuture ... done
[10:22:08.463] signalConditions() ...
[10:22:08.463]  - include = ‘immediateCondition’
[10:22:08.463]  - exclude = 
[10:22:08.463]  - resignal = FALSE
[10:22:08.463]  - Number of conditions: 52
[10:22:08.463] signalConditions() ... done
[10:22:08.463] Future state: ‘finished’
[10:22:08.463] result() for MulticoreFuture ...
[10:22:08.464] result() for MulticoreFuture ... done
[10:22:08.464] signalConditions() ...
[10:22:08.464]  - include = ‘condition’
[10:22:08.464]  - exclude = ‘immediateCondition’
[10:22:08.464]  - resignal = TRUE
[10:22:08.464]  - Number of conditions: 52
[10:22:08.464]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.433] getGlobalsAndPackages() ...
[10:22:08.464]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.433] Searching for globals...
[10:22:08.465]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.435] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[10:22:08.465]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.435] Searching for globals ... DONE
[10:22:08.465]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.435] Resolving globals: FALSE
[10:22:08.465]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.436] The total size of the 1 globals is 356 bytes (356 bytes)
[10:22:08.465]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.436] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[10:22:08.465]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.437] - globals: [1] ‘data’
[10:22:08.465]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.437] 
[10:22:08.466]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.437] getGlobalsAndPackages() ... DONE
[10:22:08.466]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.438] run() for ‘Future’ ...
[10:22:08.466]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.438] - state: ‘created’
[10:22:08.466]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.438] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:08.466]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.440] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:22:08.466]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.440] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:22:08.467]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.441]   - Field: ‘label’
[10:22:08.467]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.441]   - Field: ‘local’
[10:22:08.467]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.441]   - Field: ‘owner’
[10:22:08.467]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.441]   - Field: ‘envir’
[10:22:08.467]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.441]   - Field: ‘packages’
[10:22:08.467]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.441]   - Field: ‘gc’
[10:22:08.467]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.442]   - Field: ‘conditions’
[10:22:08.468]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.442]   - Field: ‘expr’
[10:22:08.468]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.442]   - Field: ‘uuid’
[10:22:08.468]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.442]   - Field: ‘seed’
[10:22:08.468]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.442]   - Field: ‘version’
[10:22:08.468]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.442]   - Field: ‘result’
[10:22:08.468]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.442]   - Field: ‘asynchronous’
[10:22:08.469]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.443]   - Field: ‘calls’
[10:22:08.469]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.443]   - Field: ‘globals’
[10:22:08.469]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.443]   - Field: ‘stdout’
[10:22:08.469]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.443]   - Field: ‘earlySignal’
[10:22:08.469]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.443]   - Field: ‘lazy’
[10:22:08.469]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.443]   - Field: ‘state’
[10:22:08.469]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.443] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:22:08.470]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.444] - Launch lazy future ...
[10:22:08.470]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.444] Packages needed by the future expression (n = 0): <none>
[10:22:08.470]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.444] Packages needed by future strategies (n = 0): <none>
[10:22:08.470]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.445] {
[10:22:08.445]     {
[10:22:08.445]         {
[10:22:08.445]             ...future.startTime <- base::Sys.time()
[10:22:08.445]             {
[10:22:08.445]                 {
[10:22:08.445]                   {
[10:22:08.445]                     base::local({
[10:22:08.445]                       has_future <- base::requireNamespace("future", 
[10:22:08.445]                         quietly = TRUE)
[10:22:08.445]                       if (has_future) {
[10:22:08.445]                         ns <- base::getNamespace("future")
[10:22:08.445]                         version <- ns[[".package"]][["version"]]
[10:22:08.445]                         if (is.null(version)) 
[10:22:08.445]                           version <- utils::packageVersion("future")
[10:22:08.445]                       }
[10:22:08.445]                       else {
[10:22:08.445]                         version <- NULL
[10:22:08.445]                       }
[10:22:08.445]                       if (!has_future || version < "1.8.0") {
[10:22:08.445]                         info <- base::c(r_version = base::gsub("R version ", 
[10:22:08.445]                           "", base::R.version$version.string), 
[10:22:08.445]                           platform = base::sprintf("%s (%s-bit)", 
[10:22:08.445]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:22:08.445]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:08.445]                             "release", "version")], collapse = " "), 
[10:22:08.445]                           hostname = base::Sys.info()[["nodename"]])
[10:22:08.445]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:22:08.445]                           info)
[10:22:08.445]                         info <- base::paste(info, collapse = "; ")
[10:22:08.445]                         if (!has_future) {
[10:22:08.445]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:08.445]                             info)
[10:22:08.445]                         }
[10:22:08.445]                         else {
[10:22:08.445]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:08.445]                             info, version)
[10:22:08.445]                         }
[10:22:08.445]                         base::stop(msg)
[10:22:08.445]                       }
[10:22:08.445]                     })
[10:22:08.445]                   }
[10:22:08.445]                   ...future.strategy.old <- future::plan("list")
[10:22:08.445]                   options(future.plan = NULL)
[10:22:08.445]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:08.445]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:22:08.445]                 }
[10:22:08.445]                 ...future.workdir <- getwd()
[10:22:08.445]             }
[10:22:08.445]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:08.445]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:08.445]         }
[10:22:08.445]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:08.445]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:08.445]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:08.445]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:08.445]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:08.445]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:08.445]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:08.445]             base::names(...future.oldOptions))
[10:22:08.445]     }
[10:22:08.445]     if (FALSE) {
[10:22:08.445]     }
[10:22:08.445]     else {
[10:22:08.445]         if (TRUE) {
[10:22:08.445]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:08.445]                 open = "w")
[10:22:08.445]         }
[10:22:08.445]         else {
[10:22:08.445]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:08.445]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:08.445]         }
[10:22:08.445]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:08.445]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:08.445]             base::sink(type = "output", split = FALSE)
[10:22:08.445]             base::close(...future.stdout)
[10:22:08.445]         }, add = TRUE)
[10:22:08.445]     }
[10:22:08.445]     ...future.frame <- base::sys.nframe()
[10:22:08.445]     ...future.conditions <- base::list()
[10:22:08.445]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:08.445]     if (FALSE) {
[10:22:08.445]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:08.445]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:08.445]     }
[10:22:08.445]     ...future.result <- base::tryCatch({
[10:22:08.445]         base::withCallingHandlers({
[10:22:08.445]             ...future.value <- base::withVisible(base::local(subset(data, 
[10:22:08.445]                 a == 2)))
[10:22:08.445]             future::FutureResult(value = ...future.value$value, 
[10:22:08.445]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:08.445]                   ...future.rng), globalenv = if (FALSE) 
[10:22:08.445]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:08.445]                     ...future.globalenv.names))
[10:22:08.445]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:08.445]         }, condition = base::local({
[10:22:08.445]             c <- base::c
[10:22:08.445]             inherits <- base::inherits
[10:22:08.445]             invokeRestart <- base::invokeRestart
[10:22:08.445]             length <- base::length
[10:22:08.445]             list <- base::list
[10:22:08.445]             seq.int <- base::seq.int
[10:22:08.445]             signalCondition <- base::signalCondition
[10:22:08.445]             sys.calls <- base::sys.calls
[10:22:08.445]             `[[` <- base::`[[`
[10:22:08.445]             `+` <- base::`+`
[10:22:08.445]             `<<-` <- base::`<<-`
[10:22:08.445]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:08.445]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:08.445]                   3L)]
[10:22:08.445]             }
[10:22:08.445]             function(cond) {
[10:22:08.445]                 is_error <- inherits(cond, "error")
[10:22:08.445]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:08.445]                   NULL)
[10:22:08.445]                 if (is_error) {
[10:22:08.445]                   sessionInformation <- function() {
[10:22:08.445]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:08.445]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:08.445]                       search = base::search(), system = base::Sys.info())
[10:22:08.445]                   }
[10:22:08.445]                   ...future.conditions[[length(...future.conditions) + 
[10:22:08.445]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:08.445]                     cond$call), session = sessionInformation(), 
[10:22:08.445]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:08.445]                   signalCondition(cond)
[10:22:08.445]                 }
[10:22:08.445]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:08.445]                 "immediateCondition"))) {
[10:22:08.445]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:08.445]                   ...future.conditions[[length(...future.conditions) + 
[10:22:08.445]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:08.445]                   if (TRUE && !signal) {
[10:22:08.445]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:08.445]                     {
[10:22:08.445]                       inherits <- base::inherits
[10:22:08.445]                       invokeRestart <- base::invokeRestart
[10:22:08.445]                       is.null <- base::is.null
[10:22:08.445]                       muffled <- FALSE
[10:22:08.445]                       if (inherits(cond, "message")) {
[10:22:08.445]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:08.445]                         if (muffled) 
[10:22:08.445]                           invokeRestart("muffleMessage")
[10:22:08.445]                       }
[10:22:08.445]                       else if (inherits(cond, "warning")) {
[10:22:08.445]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:08.445]                         if (muffled) 
[10:22:08.445]                           invokeRestart("muffleWarning")
[10:22:08.445]                       }
[10:22:08.445]                       else if (inherits(cond, "condition")) {
[10:22:08.445]                         if (!is.null(pattern)) {
[10:22:08.445]                           computeRestarts <- base::computeRestarts
[10:22:08.445]                           grepl <- base::grepl
[10:22:08.445]                           restarts <- computeRestarts(cond)
[10:22:08.445]                           for (restart in restarts) {
[10:22:08.445]                             name <- restart$name
[10:22:08.445]                             if (is.null(name)) 
[10:22:08.445]                               next
[10:22:08.445]                             if (!grepl(pattern, name)) 
[10:22:08.445]                               next
[10:22:08.445]                             invokeRestart(restart)
[10:22:08.445]                             muffled <- TRUE
[10:22:08.445]                             break
[10:22:08.445]                           }
[10:22:08.445]                         }
[10:22:08.445]                       }
[10:22:08.445]                       invisible(muffled)
[10:22:08.445]                     }
[10:22:08.445]                     muffleCondition(cond, pattern = "^muffle")
[10:22:08.445]                   }
[10:22:08.445]                 }
[10:22:08.445]                 else {
[10:22:08.445]                   if (TRUE) {
[10:22:08.445]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:08.445]                     {
[10:22:08.445]                       inherits <- base::inherits
[10:22:08.445]                       invokeRestart <- base::invokeRestart
[10:22:08.445]                       is.null <- base::is.null
[10:22:08.445]                       muffled <- FALSE
[10:22:08.445]                       if (inherits(cond, "message")) {
[10:22:08.445]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:08.445]                         if (muffled) 
[10:22:08.445]                           invokeRestart("muffleMessage")
[10:22:08.445]                       }
[10:22:08.445]                       else if (inherits(cond, "warning")) {
[10:22:08.445]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:08.445]                         if (muffled) 
[10:22:08.445]                           invokeRestart("muffleWarning")
[10:22:08.445]                       }
[10:22:08.445]                       else if (inherits(cond, "condition")) {
[10:22:08.445]                         if (!is.null(pattern)) {
[10:22:08.445]                           computeRestarts <- base::computeRestarts
[10:22:08.445]                           grepl <- base::grepl
[10:22:08.445]                           restarts <- computeRestarts(cond)
[10:22:08.445]                           for (restart in restarts) {
[10:22:08.445]                             name <- restart$name
[10:22:08.445]                             if (is.null(name)) 
[10:22:08.445]                               next
[10:22:08.445]                             if (!grepl(pattern, name)) 
[10:22:08.445]                               next
[10:22:08.445]                             invokeRestart(restart)
[10:22:08.445]                             muffled <- TRUE
[10:22:08.445]                             break
[10:22:08.445]                           }
[10:22:08.445]                         }
[10:22:08.445]                       }
[10:22:08.445]                       invisible(muffled)
[10:22:08.445]                     }
[10:22:08.445]                     muffleCondition(cond, pattern = "^muffle")
[10:22:08.445]                   }
[10:22:08.445]                 }
[10:22:08.445]             }
[10:22:08.445]         }))
[10:22:08.445]     }, error = function(ex) {
[10:22:08.445]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:08.445]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:08.445]                 ...future.rng), started = ...future.startTime, 
[10:22:08.445]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:08.445]             version = "1.8"), class = "FutureResult")
[10:22:08.445]     }, finally = {
[10:22:08.445]         if (!identical(...future.workdir, getwd())) 
[10:22:08.445]             setwd(...future.workdir)
[10:22:08.445]         {
[10:22:08.445]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:08.445]                 ...future.oldOptions$nwarnings <- NULL
[10:22:08.445]             }
[10:22:08.445]             base::options(...future.oldOptions)
[10:22:08.445]             if (.Platform$OS.type == "windows") {
[10:22:08.445]                 old_names <- names(...future.oldEnvVars)
[10:22:08.445]                 envs <- base::Sys.getenv()
[10:22:08.445]                 names <- names(envs)
[10:22:08.445]                 common <- intersect(names, old_names)
[10:22:08.445]                 added <- setdiff(names, old_names)
[10:22:08.445]                 removed <- setdiff(old_names, names)
[10:22:08.445]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:08.445]                   envs[common]]
[10:22:08.445]                 NAMES <- toupper(changed)
[10:22:08.445]                 args <- list()
[10:22:08.445]                 for (kk in seq_along(NAMES)) {
[10:22:08.445]                   name <- changed[[kk]]
[10:22:08.445]                   NAME <- NAMES[[kk]]
[10:22:08.445]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:08.445]                     next
[10:22:08.445]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:08.445]                 }
[10:22:08.445]                 NAMES <- toupper(added)
[10:22:08.445]                 for (kk in seq_along(NAMES)) {
[10:22:08.445]                   name <- added[[kk]]
[10:22:08.445]                   NAME <- NAMES[[kk]]
[10:22:08.445]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:08.445]                     next
[10:22:08.445]                   args[[name]] <- ""
[10:22:08.445]                 }
[10:22:08.445]                 NAMES <- toupper(removed)
[10:22:08.445]                 for (kk in seq_along(NAMES)) {
[10:22:08.445]                   name <- removed[[kk]]
[10:22:08.445]                   NAME <- NAMES[[kk]]
[10:22:08.445]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:08.445]                     next
[10:22:08.445]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:08.445]                 }
[10:22:08.445]                 if (length(args) > 0) 
[10:22:08.445]                   base::do.call(base::Sys.setenv, args = args)
[10:22:08.445]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:08.445]             }
[10:22:08.445]             else {
[10:22:08.445]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:08.445]             }
[10:22:08.445]             {
[10:22:08.445]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:08.445]                   0L) {
[10:22:08.445]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:08.445]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:08.445]                   base::options(opts)
[10:22:08.445]                 }
[10:22:08.445]                 {
[10:22:08.445]                   {
[10:22:08.445]                     NULL
[10:22:08.445]                     RNGkind("Mersenne-Twister")
[10:22:08.445]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:22:08.445]                       inherits = FALSE)
[10:22:08.445]                   }
[10:22:08.445]                   options(future.plan = NULL)
[10:22:08.445]                   if (is.na(NA_character_)) 
[10:22:08.445]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:08.445]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:08.445]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:08.445]                     .init = FALSE)
[10:22:08.445]                 }
[10:22:08.445]             }
[10:22:08.445]         }
[10:22:08.445]     })
[10:22:08.445]     if (TRUE) {
[10:22:08.445]         base::sink(type = "output", split = FALSE)
[10:22:08.445]         if (TRUE) {
[10:22:08.445]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:08.445]         }
[10:22:08.445]         else {
[10:22:08.445]             ...future.result["stdout"] <- base::list(NULL)
[10:22:08.445]         }
[10:22:08.445]         base::close(...future.stdout)
[10:22:08.445]         ...future.stdout <- NULL
[10:22:08.445]     }
[10:22:08.445]     ...future.result$conditions <- ...future.conditions
[10:22:08.445]     ...future.result$finished <- base::Sys.time()
[10:22:08.445]     ...future.result
[10:22:08.445] }
[10:22:08.470]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.447] assign_globals() ...
[10:22:08.470]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.447] List of 1
[10:22:08.447]  $ data:'data.frame':	3 obs. of  2 variables:
[10:22:08.447]   ..$ a: int [1:3] 1 2 3
[10:22:08.447]   ..$ b: int [1:3] 3 2 1
[10:22:08.447]  - attr(*, "where")=List of 1
[10:22:08.447]   ..$ data:<environment: R_EmptyEnv> 
[10:22:08.447]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:22:08.447]  - attr(*, "resolved")= logi FALSE
[10:22:08.447]  - attr(*, "total_size")= num 356
[10:22:08.447]  - attr(*, "already-done")= logi TRUE
[10:22:08.471]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.452] - copied ‘data’ to environment
[10:22:08.471]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.452] assign_globals() ... done
[10:22:08.471]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.452] plan(): Setting new future strategy stack:
[10:22:08.471]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.453] List of future strategies:
[10:22:08.453] 1. sequential:
[10:22:08.453]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:08.453]    - tweaked: FALSE
[10:22:08.453]    - call: NULL
[10:22:08.471]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.453] plan(): nbrOfWorkers() = 1
[10:22:08.471]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.454] plan(): Setting new future strategy stack:
[10:22:08.472]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.455] List of future strategies:
[10:22:08.455] 1. multisession:
[10:22:08.455]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:22:08.455]    - tweaked: FALSE
[10:22:08.455]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:08.472]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.456] plan(): nbrOfWorkers() = 1
[10:22:08.472]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.457] SequentialFuture started (and completed)
[10:22:08.472]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.457] - Launch lazy future ... done
[10:22:08.472]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[10:22:08.457] run() for ‘SequentialFuture’ ... done
[10:22:08.472] signalConditions() ... done
- plan(list('multicore', 'multisession')) ... DONE
- plan(list('multisession', 'sequential')) ...
[10:22:08.473] plan(): Setting new future strategy stack:
[10:22:08.473] List of future strategies:
[10:22:08.473] 1. multisession:
[10:22:08.473]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:22:08.473]    - tweaked: FALSE
[10:22:08.473]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:08.473] 2. sequential:
[10:22:08.473]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:08.473]    - tweaked: FALSE
[10:22:08.473]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:08.474] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:22:08.474] multisession:
[10:22:08.474] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:22:08.474] - tweaked: FALSE
[10:22:08.474] - call: plan(list(a = strategy1, b = strategy2))
[10:22:08.476] getGlobalsAndPackages() ...
[10:22:08.476] Not searching for globals
[10:22:08.477] - globals: [0] <none>
[10:22:08.477] getGlobalsAndPackages() ... DONE
[10:22:08.490] Packages needed by the future expression (n = 0): <none>
[10:22:08.490] Packages needed by future strategies (n = 1): ‘future’
[10:22:08.491] {
[10:22:08.491]     {
[10:22:08.491]         {
[10:22:08.491]             ...future.startTime <- base::Sys.time()
[10:22:08.491]             {
[10:22:08.491]                 {
[10:22:08.491]                   {
[10:22:08.491]                     {
[10:22:08.491]                       {
[10:22:08.491]                         base::local({
[10:22:08.491]                           has_future <- base::requireNamespace("future", 
[10:22:08.491]                             quietly = TRUE)
[10:22:08.491]                           if (has_future) {
[10:22:08.491]                             ns <- base::getNamespace("future")
[10:22:08.491]                             version <- ns[[".package"]][["version"]]
[10:22:08.491]                             if (is.null(version)) 
[10:22:08.491]                               version <- utils::packageVersion("future")
[10:22:08.491]                           }
[10:22:08.491]                           else {
[10:22:08.491]                             version <- NULL
[10:22:08.491]                           }
[10:22:08.491]                           if (!has_future || version < "1.8.0") {
[10:22:08.491]                             info <- base::c(r_version = base::gsub("R version ", 
[10:22:08.491]                               "", base::R.version$version.string), 
[10:22:08.491]                               platform = base::sprintf("%s (%s-bit)", 
[10:22:08.491]                                 base::R.version$platform, 8 * 
[10:22:08.491]                                   base::.Machine$sizeof.pointer), 
[10:22:08.491]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:08.491]                                 "release", "version")], collapse = " "), 
[10:22:08.491]                               hostname = base::Sys.info()[["nodename"]])
[10:22:08.491]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:22:08.491]                               info)
[10:22:08.491]                             info <- base::paste(info, collapse = "; ")
[10:22:08.491]                             if (!has_future) {
[10:22:08.491]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:08.491]                                 info)
[10:22:08.491]                             }
[10:22:08.491]                             else {
[10:22:08.491]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:08.491]                                 info, version)
[10:22:08.491]                             }
[10:22:08.491]                             base::stop(msg)
[10:22:08.491]                           }
[10:22:08.491]                         })
[10:22:08.491]                       }
[10:22:08.491]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:08.491]                       base::options(mc.cores = 1L)
[10:22:08.491]                     }
[10:22:08.491]                     base::local({
[10:22:08.491]                       for (pkg in "future") {
[10:22:08.491]                         base::loadNamespace(pkg)
[10:22:08.491]                         base::library(pkg, character.only = TRUE)
[10:22:08.491]                       }
[10:22:08.491]                     })
[10:22:08.491]                   }
[10:22:08.491]                   ...future.strategy.old <- future::plan("list")
[10:22:08.491]                   options(future.plan = NULL)
[10:22:08.491]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:08.491]                   future::plan(list(b = function (..., envir = parent.frame()) 
[10:22:08.491]                   {
[10:22:08.491]                     future <- SequentialFuture(..., envir = envir)
[10:22:08.491]                     if (!future$lazy) 
[10:22:08.491]                       future <- run(future)
[10:22:08.491]                     invisible(future)
[10:22:08.491]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:08.491]                 }
[10:22:08.491]                 ...future.workdir <- getwd()
[10:22:08.491]             }
[10:22:08.491]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:08.491]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:08.491]         }
[10:22:08.491]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:08.491]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:08.491]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:08.491]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:08.491]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:08.491]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:08.491]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:08.491]             base::names(...future.oldOptions))
[10:22:08.491]     }
[10:22:08.491]     if (FALSE) {
[10:22:08.491]     }
[10:22:08.491]     else {
[10:22:08.491]         if (TRUE) {
[10:22:08.491]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:08.491]                 open = "w")
[10:22:08.491]         }
[10:22:08.491]         else {
[10:22:08.491]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:08.491]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:08.491]         }
[10:22:08.491]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:08.491]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:08.491]             base::sink(type = "output", split = FALSE)
[10:22:08.491]             base::close(...future.stdout)
[10:22:08.491]         }, add = TRUE)
[10:22:08.491]     }
[10:22:08.491]     ...future.frame <- base::sys.nframe()
[10:22:08.491]     ...future.conditions <- base::list()
[10:22:08.491]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:08.491]     if (FALSE) {
[10:22:08.491]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:08.491]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:08.491]     }
[10:22:08.491]     ...future.result <- base::tryCatch({
[10:22:08.491]         base::withCallingHandlers({
[10:22:08.491]             ...future.value <- base::withVisible(base::local({
[10:22:08.491]                 ...future.makeSendCondition <- base::local({
[10:22:08.491]                   sendCondition <- NULL
[10:22:08.491]                   function(frame = 1L) {
[10:22:08.491]                     if (is.function(sendCondition)) 
[10:22:08.491]                       return(sendCondition)
[10:22:08.491]                     ns <- getNamespace("parallel")
[10:22:08.491]                     if (exists("sendData", mode = "function", 
[10:22:08.491]                       envir = ns)) {
[10:22:08.491]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:08.491]                         envir = ns)
[10:22:08.491]                       envir <- sys.frame(frame)
[10:22:08.491]                       master <- NULL
[10:22:08.491]                       while (!identical(envir, .GlobalEnv) && 
[10:22:08.491]                         !identical(envir, emptyenv())) {
[10:22:08.491]                         if (exists("master", mode = "list", envir = envir, 
[10:22:08.491]                           inherits = FALSE)) {
[10:22:08.491]                           master <- get("master", mode = "list", 
[10:22:08.491]                             envir = envir, inherits = FALSE)
[10:22:08.491]                           if (inherits(master, c("SOCKnode", 
[10:22:08.491]                             "SOCK0node"))) {
[10:22:08.491]                             sendCondition <<- function(cond) {
[10:22:08.491]                               data <- list(type = "VALUE", value = cond, 
[10:22:08.491]                                 success = TRUE)
[10:22:08.491]                               parallel_sendData(master, data)
[10:22:08.491]                             }
[10:22:08.491]                             return(sendCondition)
[10:22:08.491]                           }
[10:22:08.491]                         }
[10:22:08.491]                         frame <- frame + 1L
[10:22:08.491]                         envir <- sys.frame(frame)
[10:22:08.491]                       }
[10:22:08.491]                     }
[10:22:08.491]                     sendCondition <<- function(cond) NULL
[10:22:08.491]                   }
[10:22:08.491]                 })
[10:22:08.491]                 withCallingHandlers({
[10:22:08.491]                   NA
[10:22:08.491]                 }, immediateCondition = function(cond) {
[10:22:08.491]                   sendCondition <- ...future.makeSendCondition()
[10:22:08.491]                   sendCondition(cond)
[10:22:08.491]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:08.491]                   {
[10:22:08.491]                     inherits <- base::inherits
[10:22:08.491]                     invokeRestart <- base::invokeRestart
[10:22:08.491]                     is.null <- base::is.null
[10:22:08.491]                     muffled <- FALSE
[10:22:08.491]                     if (inherits(cond, "message")) {
[10:22:08.491]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:08.491]                       if (muffled) 
[10:22:08.491]                         invokeRestart("muffleMessage")
[10:22:08.491]                     }
[10:22:08.491]                     else if (inherits(cond, "warning")) {
[10:22:08.491]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:08.491]                       if (muffled) 
[10:22:08.491]                         invokeRestart("muffleWarning")
[10:22:08.491]                     }
[10:22:08.491]                     else if (inherits(cond, "condition")) {
[10:22:08.491]                       if (!is.null(pattern)) {
[10:22:08.491]                         computeRestarts <- base::computeRestarts
[10:22:08.491]                         grepl <- base::grepl
[10:22:08.491]                         restarts <- computeRestarts(cond)
[10:22:08.491]                         for (restart in restarts) {
[10:22:08.491]                           name <- restart$name
[10:22:08.491]                           if (is.null(name)) 
[10:22:08.491]                             next
[10:22:08.491]                           if (!grepl(pattern, name)) 
[10:22:08.491]                             next
[10:22:08.491]                           invokeRestart(restart)
[10:22:08.491]                           muffled <- TRUE
[10:22:08.491]                           break
[10:22:08.491]                         }
[10:22:08.491]                       }
[10:22:08.491]                     }
[10:22:08.491]                     invisible(muffled)
[10:22:08.491]                   }
[10:22:08.491]                   muffleCondition(cond)
[10:22:08.491]                 })
[10:22:08.491]             }))
[10:22:08.491]             future::FutureResult(value = ...future.value$value, 
[10:22:08.491]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:08.491]                   ...future.rng), globalenv = if (FALSE) 
[10:22:08.491]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:08.491]                     ...future.globalenv.names))
[10:22:08.491]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:08.491]         }, condition = base::local({
[10:22:08.491]             c <- base::c
[10:22:08.491]             inherits <- base::inherits
[10:22:08.491]             invokeRestart <- base::invokeRestart
[10:22:08.491]             length <- base::length
[10:22:08.491]             list <- base::list
[10:22:08.491]             seq.int <- base::seq.int
[10:22:08.491]             signalCondition <- base::signalCondition
[10:22:08.491]             sys.calls <- base::sys.calls
[10:22:08.491]             `[[` <- base::`[[`
[10:22:08.491]             `+` <- base::`+`
[10:22:08.491]             `<<-` <- base::`<<-`
[10:22:08.491]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:08.491]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:08.491]                   3L)]
[10:22:08.491]             }
[10:22:08.491]             function(cond) {
[10:22:08.491]                 is_error <- inherits(cond, "error")
[10:22:08.491]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:08.491]                   NULL)
[10:22:08.491]                 if (is_error) {
[10:22:08.491]                   sessionInformation <- function() {
[10:22:08.491]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:08.491]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:08.491]                       search = base::search(), system = base::Sys.info())
[10:22:08.491]                   }
[10:22:08.491]                   ...future.conditions[[length(...future.conditions) + 
[10:22:08.491]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:08.491]                     cond$call), session = sessionInformation(), 
[10:22:08.491]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:08.491]                   signalCondition(cond)
[10:22:08.491]                 }
[10:22:08.491]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:08.491]                 "immediateCondition"))) {
[10:22:08.491]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:08.491]                   ...future.conditions[[length(...future.conditions) + 
[10:22:08.491]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:08.491]                   if (TRUE && !signal) {
[10:22:08.491]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:08.491]                     {
[10:22:08.491]                       inherits <- base::inherits
[10:22:08.491]                       invokeRestart <- base::invokeRestart
[10:22:08.491]                       is.null <- base::is.null
[10:22:08.491]                       muffled <- FALSE
[10:22:08.491]                       if (inherits(cond, "message")) {
[10:22:08.491]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:08.491]                         if (muffled) 
[10:22:08.491]                           invokeRestart("muffleMessage")
[10:22:08.491]                       }
[10:22:08.491]                       else if (inherits(cond, "warning")) {
[10:22:08.491]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:08.491]                         if (muffled) 
[10:22:08.491]                           invokeRestart("muffleWarning")
[10:22:08.491]                       }
[10:22:08.491]                       else if (inherits(cond, "condition")) {
[10:22:08.491]                         if (!is.null(pattern)) {
[10:22:08.491]                           computeRestarts <- base::computeRestarts
[10:22:08.491]                           grepl <- base::grepl
[10:22:08.491]                           restarts <- computeRestarts(cond)
[10:22:08.491]                           for (restart in restarts) {
[10:22:08.491]                             name <- restart$name
[10:22:08.491]                             if (is.null(name)) 
[10:22:08.491]                               next
[10:22:08.491]                             if (!grepl(pattern, name)) 
[10:22:08.491]                               next
[10:22:08.491]                             invokeRestart(restart)
[10:22:08.491]                             muffled <- TRUE
[10:22:08.491]                             break
[10:22:08.491]                           }
[10:22:08.491]                         }
[10:22:08.491]                       }
[10:22:08.491]                       invisible(muffled)
[10:22:08.491]                     }
[10:22:08.491]                     muffleCondition(cond, pattern = "^muffle")
[10:22:08.491]                   }
[10:22:08.491]                 }
[10:22:08.491]                 else {
[10:22:08.491]                   if (TRUE) {
[10:22:08.491]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:08.491]                     {
[10:22:08.491]                       inherits <- base::inherits
[10:22:08.491]                       invokeRestart <- base::invokeRestart
[10:22:08.491]                       is.null <- base::is.null
[10:22:08.491]                       muffled <- FALSE
[10:22:08.491]                       if (inherits(cond, "message")) {
[10:22:08.491]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:08.491]                         if (muffled) 
[10:22:08.491]                           invokeRestart("muffleMessage")
[10:22:08.491]                       }
[10:22:08.491]                       else if (inherits(cond, "warning")) {
[10:22:08.491]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:08.491]                         if (muffled) 
[10:22:08.491]                           invokeRestart("muffleWarning")
[10:22:08.491]                       }
[10:22:08.491]                       else if (inherits(cond, "condition")) {
[10:22:08.491]                         if (!is.null(pattern)) {
[10:22:08.491]                           computeRestarts <- base::computeRestarts
[10:22:08.491]                           grepl <- base::grepl
[10:22:08.491]                           restarts <- computeRestarts(cond)
[10:22:08.491]                           for (restart in restarts) {
[10:22:08.491]                             name <- restart$name
[10:22:08.491]                             if (is.null(name)) 
[10:22:08.491]                               next
[10:22:08.491]                             if (!grepl(pattern, name)) 
[10:22:08.491]                               next
[10:22:08.491]                             invokeRestart(restart)
[10:22:08.491]                             muffled <- TRUE
[10:22:08.491]                             break
[10:22:08.491]                           }
[10:22:08.491]                         }
[10:22:08.491]                       }
[10:22:08.491]                       invisible(muffled)
[10:22:08.491]                     }
[10:22:08.491]                     muffleCondition(cond, pattern = "^muffle")
[10:22:08.491]                   }
[10:22:08.491]                 }
[10:22:08.491]             }
[10:22:08.491]         }))
[10:22:08.491]     }, error = function(ex) {
[10:22:08.491]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:08.491]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:08.491]                 ...future.rng), started = ...future.startTime, 
[10:22:08.491]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:08.491]             version = "1.8"), class = "FutureResult")
[10:22:08.491]     }, finally = {
[10:22:08.491]         if (!identical(...future.workdir, getwd())) 
[10:22:08.491]             setwd(...future.workdir)
[10:22:08.491]         {
[10:22:08.491]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:08.491]                 ...future.oldOptions$nwarnings <- NULL
[10:22:08.491]             }
[10:22:08.491]             base::options(...future.oldOptions)
[10:22:08.491]             if (.Platform$OS.type == "windows") {
[10:22:08.491]                 old_names <- names(...future.oldEnvVars)
[10:22:08.491]                 envs <- base::Sys.getenv()
[10:22:08.491]                 names <- names(envs)
[10:22:08.491]                 common <- intersect(names, old_names)
[10:22:08.491]                 added <- setdiff(names, old_names)
[10:22:08.491]                 removed <- setdiff(old_names, names)
[10:22:08.491]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:08.491]                   envs[common]]
[10:22:08.491]                 NAMES <- toupper(changed)
[10:22:08.491]                 args <- list()
[10:22:08.491]                 for (kk in seq_along(NAMES)) {
[10:22:08.491]                   name <- changed[[kk]]
[10:22:08.491]                   NAME <- NAMES[[kk]]
[10:22:08.491]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:08.491]                     next
[10:22:08.491]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:08.491]                 }
[10:22:08.491]                 NAMES <- toupper(added)
[10:22:08.491]                 for (kk in seq_along(NAMES)) {
[10:22:08.491]                   name <- added[[kk]]
[10:22:08.491]                   NAME <- NAMES[[kk]]
[10:22:08.491]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:08.491]                     next
[10:22:08.491]                   args[[name]] <- ""
[10:22:08.491]                 }
[10:22:08.491]                 NAMES <- toupper(removed)
[10:22:08.491]                 for (kk in seq_along(NAMES)) {
[10:22:08.491]                   name <- removed[[kk]]
[10:22:08.491]                   NAME <- NAMES[[kk]]
[10:22:08.491]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:08.491]                     next
[10:22:08.491]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:08.491]                 }
[10:22:08.491]                 if (length(args) > 0) 
[10:22:08.491]                   base::do.call(base::Sys.setenv, args = args)
[10:22:08.491]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:08.491]             }
[10:22:08.491]             else {
[10:22:08.491]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:08.491]             }
[10:22:08.491]             {
[10:22:08.491]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:08.491]                   0L) {
[10:22:08.491]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:08.491]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:08.491]                   base::options(opts)
[10:22:08.491]                 }
[10:22:08.491]                 {
[10:22:08.491]                   {
[10:22:08.491]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:08.491]                     NULL
[10:22:08.491]                   }
[10:22:08.491]                   options(future.plan = NULL)
[10:22:08.491]                   if (is.na(NA_character_)) 
[10:22:08.491]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:08.491]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:08.491]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:08.491]                     .init = FALSE)
[10:22:08.491]                 }
[10:22:08.491]             }
[10:22:08.491]         }
[10:22:08.491]     })
[10:22:08.491]     if (TRUE) {
[10:22:08.491]         base::sink(type = "output", split = FALSE)
[10:22:08.491]         if (TRUE) {
[10:22:08.491]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:08.491]         }
[10:22:08.491]         else {
[10:22:08.491]             ...future.result["stdout"] <- base::list(NULL)
[10:22:08.491]         }
[10:22:08.491]         base::close(...future.stdout)
[10:22:08.491]         ...future.stdout <- NULL
[10:22:08.491]     }
[10:22:08.491]     ...future.result$conditions <- ...future.conditions
[10:22:08.491]     ...future.result$finished <- base::Sys.time()
[10:22:08.491]     ...future.result
[10:22:08.491] }
[10:22:08.495] MultisessionFuture started
[10:22:08.495] result() for ClusterFuture ...
[10:22:08.495] receiveMessageFromWorker() for ClusterFuture ...
[10:22:08.495] - Validating connection of MultisessionFuture
[10:22:08.540] - received message: FutureResult
[10:22:08.540] - Received FutureResult
[10:22:08.540] - Erased future from FutureRegistry
[10:22:08.541] result() for ClusterFuture ...
[10:22:08.541] - result already collected: FutureResult
[10:22:08.541] result() for ClusterFuture ... done
[10:22:08.541] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:08.541] result() for ClusterFuture ... done
[10:22:08.541] result() for ClusterFuture ...
[10:22:08.541] - result already collected: FutureResult
[10:22:08.541] result() for ClusterFuture ... done
[10:22:08.541] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:22:08.543] plan(): nbrOfWorkers() = 2
[10:22:08.543] getGlobalsAndPackages() ...
[10:22:08.543] Searching for globals...
[10:22:08.565] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[10:22:08.565] Searching for globals ... DONE
[10:22:08.565] Resolving globals: FALSE
[10:22:08.566] The total size of the 2 globals is 7.46 KiB (7637 bytes)
[10:22:08.567] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 7.46 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (7.41 KiB of class ‘list’) and ‘strategy2’ (49 bytes of class ‘character’)
[10:22:08.567] - globals: [2] ‘nested’, ‘strategy2’
[10:22:08.567] - packages: [1] ‘future’
[10:22:08.567] getGlobalsAndPackages() ... DONE
[10:22:08.567] run() for ‘Future’ ...
[10:22:08.567] - state: ‘created’
[10:22:08.568] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:08.582] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:08.582] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:08.582]   - Field: ‘node’
[10:22:08.582]   - Field: ‘label’
[10:22:08.582]   - Field: ‘local’
[10:22:08.582]   - Field: ‘owner’
[10:22:08.582]   - Field: ‘envir’
[10:22:08.582]   - Field: ‘workers’
[10:22:08.583]   - Field: ‘packages’
[10:22:08.583]   - Field: ‘gc’
[10:22:08.583]   - Field: ‘conditions’
[10:22:08.583]   - Field: ‘persistent’
[10:22:08.583]   - Field: ‘expr’
[10:22:08.583]   - Field: ‘uuid’
[10:22:08.583]   - Field: ‘seed’
[10:22:08.583]   - Field: ‘version’
[10:22:08.583]   - Field: ‘result’
[10:22:08.583]   - Field: ‘asynchronous’
[10:22:08.584]   - Field: ‘calls’
[10:22:08.584]   - Field: ‘globals’
[10:22:08.584]   - Field: ‘stdout’
[10:22:08.584]   - Field: ‘earlySignal’
[10:22:08.584]   - Field: ‘lazy’
[10:22:08.584]   - Field: ‘state’
[10:22:08.584] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:08.584] - Launch lazy future ...
[10:22:08.585] Packages needed by the future expression (n = 1): ‘future’
[10:22:08.585] Packages needed by future strategies (n = 1): ‘future’
[10:22:08.585] {
[10:22:08.585]     {
[10:22:08.585]         {
[10:22:08.585]             ...future.startTime <- base::Sys.time()
[10:22:08.585]             {
[10:22:08.585]                 {
[10:22:08.585]                   {
[10:22:08.585]                     {
[10:22:08.585]                       {
[10:22:08.585]                         base::local({
[10:22:08.585]                           has_future <- base::requireNamespace("future", 
[10:22:08.585]                             quietly = TRUE)
[10:22:08.585]                           if (has_future) {
[10:22:08.585]                             ns <- base::getNamespace("future")
[10:22:08.585]                             version <- ns[[".package"]][["version"]]
[10:22:08.585]                             if (is.null(version)) 
[10:22:08.585]                               version <- utils::packageVersion("future")
[10:22:08.585]                           }
[10:22:08.585]                           else {
[10:22:08.585]                             version <- NULL
[10:22:08.585]                           }
[10:22:08.585]                           if (!has_future || version < "1.8.0") {
[10:22:08.585]                             info <- base::c(r_version = base::gsub("R version ", 
[10:22:08.585]                               "", base::R.version$version.string), 
[10:22:08.585]                               platform = base::sprintf("%s (%s-bit)", 
[10:22:08.585]                                 base::R.version$platform, 8 * 
[10:22:08.585]                                   base::.Machine$sizeof.pointer), 
[10:22:08.585]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:08.585]                                 "release", "version")], collapse = " "), 
[10:22:08.585]                               hostname = base::Sys.info()[["nodename"]])
[10:22:08.585]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:22:08.585]                               info)
[10:22:08.585]                             info <- base::paste(info, collapse = "; ")
[10:22:08.585]                             if (!has_future) {
[10:22:08.585]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:08.585]                                 info)
[10:22:08.585]                             }
[10:22:08.585]                             else {
[10:22:08.585]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:08.585]                                 info, version)
[10:22:08.585]                             }
[10:22:08.585]                             base::stop(msg)
[10:22:08.585]                           }
[10:22:08.585]                         })
[10:22:08.585]                       }
[10:22:08.585]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:08.585]                       base::options(mc.cores = 1L)
[10:22:08.585]                     }
[10:22:08.585]                     base::local({
[10:22:08.585]                       for (pkg in "future") {
[10:22:08.585]                         base::loadNamespace(pkg)
[10:22:08.585]                         base::library(pkg, character.only = TRUE)
[10:22:08.585]                       }
[10:22:08.585]                     })
[10:22:08.585]                   }
[10:22:08.585]                   ...future.strategy.old <- future::plan("list")
[10:22:08.585]                   options(future.plan = NULL)
[10:22:08.585]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:08.585]                   future::plan(list(b = function (..., envir = parent.frame()) 
[10:22:08.585]                   {
[10:22:08.585]                     future <- SequentialFuture(..., envir = envir)
[10:22:08.585]                     if (!future$lazy) 
[10:22:08.585]                       future <- run(future)
[10:22:08.585]                     invisible(future)
[10:22:08.585]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:08.585]                 }
[10:22:08.585]                 ...future.workdir <- getwd()
[10:22:08.585]             }
[10:22:08.585]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:08.585]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:08.585]         }
[10:22:08.585]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:08.585]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:08.585]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:08.585]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:08.585]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:08.585]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:08.585]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:08.585]             base::names(...future.oldOptions))
[10:22:08.585]     }
[10:22:08.585]     if (FALSE) {
[10:22:08.585]     }
[10:22:08.585]     else {
[10:22:08.585]         if (TRUE) {
[10:22:08.585]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:08.585]                 open = "w")
[10:22:08.585]         }
[10:22:08.585]         else {
[10:22:08.585]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:08.585]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:08.585]         }
[10:22:08.585]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:08.585]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:08.585]             base::sink(type = "output", split = FALSE)
[10:22:08.585]             base::close(...future.stdout)
[10:22:08.585]         }, add = TRUE)
[10:22:08.585]     }
[10:22:08.585]     ...future.frame <- base::sys.nframe()
[10:22:08.585]     ...future.conditions <- base::list()
[10:22:08.585]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:08.585]     if (FALSE) {
[10:22:08.585]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:08.585]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:08.585]     }
[10:22:08.585]     ...future.result <- base::tryCatch({
[10:22:08.585]         base::withCallingHandlers({
[10:22:08.585]             ...future.value <- base::withVisible(base::local({
[10:22:08.585]                 ...future.makeSendCondition <- base::local({
[10:22:08.585]                   sendCondition <- NULL
[10:22:08.585]                   function(frame = 1L) {
[10:22:08.585]                     if (is.function(sendCondition)) 
[10:22:08.585]                       return(sendCondition)
[10:22:08.585]                     ns <- getNamespace("parallel")
[10:22:08.585]                     if (exists("sendData", mode = "function", 
[10:22:08.585]                       envir = ns)) {
[10:22:08.585]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:08.585]                         envir = ns)
[10:22:08.585]                       envir <- sys.frame(frame)
[10:22:08.585]                       master <- NULL
[10:22:08.585]                       while (!identical(envir, .GlobalEnv) && 
[10:22:08.585]                         !identical(envir, emptyenv())) {
[10:22:08.585]                         if (exists("master", mode = "list", envir = envir, 
[10:22:08.585]                           inherits = FALSE)) {
[10:22:08.585]                           master <- get("master", mode = "list", 
[10:22:08.585]                             envir = envir, inherits = FALSE)
[10:22:08.585]                           if (inherits(master, c("SOCKnode", 
[10:22:08.585]                             "SOCK0node"))) {
[10:22:08.585]                             sendCondition <<- function(cond) {
[10:22:08.585]                               data <- list(type = "VALUE", value = cond, 
[10:22:08.585]                                 success = TRUE)
[10:22:08.585]                               parallel_sendData(master, data)
[10:22:08.585]                             }
[10:22:08.585]                             return(sendCondition)
[10:22:08.585]                           }
[10:22:08.585]                         }
[10:22:08.585]                         frame <- frame + 1L
[10:22:08.585]                         envir <- sys.frame(frame)
[10:22:08.585]                       }
[10:22:08.585]                     }
[10:22:08.585]                     sendCondition <<- function(cond) NULL
[10:22:08.585]                   }
[10:22:08.585]                 })
[10:22:08.585]                 withCallingHandlers({
[10:22:08.585]                   {
[10:22:08.585]                     a <- 1L
[10:22:08.585]                     plan_a <- unclass(future::plan("list"))
[10:22:08.585]                     nested_a <- nested[-1]
[10:22:08.585]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[10:22:08.585]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[10:22:08.585]                       strategy2))
[10:22:08.585]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[10:22:08.585]                       "init") <- NULL
[10:22:08.585]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[10:22:08.585]                       "init") <- NULL
[10:22:08.585]                     stopifnot(all.equal(plan_a, nested_a))
[10:22:08.585]                     y %<-% {
[10:22:08.585]                       b <- 2L
[10:22:08.585]                       plan_b <- future::plan("list")
[10:22:08.585]                       nested_b <- nested_a[-1]
[10:22:08.585]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:22:08.585]                         1L, inherits(plan_b[[1]], "future"), 
[10:22:08.585]                         inherits(future::plan("next"), "sequential"))
[10:22:08.585]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:22:08.585]                         b = b, nested_b = nested_b, plan_b = plan_b)
[10:22:08.585]                     }
[10:22:08.585]                     y
[10:22:08.585]                   }
[10:22:08.585]                 }, immediateCondition = function(cond) {
[10:22:08.585]                   sendCondition <- ...future.makeSendCondition()
[10:22:08.585]                   sendCondition(cond)
[10:22:08.585]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:08.585]                   {
[10:22:08.585]                     inherits <- base::inherits
[10:22:08.585]                     invokeRestart <- base::invokeRestart
[10:22:08.585]                     is.null <- base::is.null
[10:22:08.585]                     muffled <- FALSE
[10:22:08.585]                     if (inherits(cond, "message")) {
[10:22:08.585]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:08.585]                       if (muffled) 
[10:22:08.585]                         invokeRestart("muffleMessage")
[10:22:08.585]                     }
[10:22:08.585]                     else if (inherits(cond, "warning")) {
[10:22:08.585]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:08.585]                       if (muffled) 
[10:22:08.585]                         invokeRestart("muffleWarning")
[10:22:08.585]                     }
[10:22:08.585]                     else if (inherits(cond, "condition")) {
[10:22:08.585]                       if (!is.null(pattern)) {
[10:22:08.585]                         computeRestarts <- base::computeRestarts
[10:22:08.585]                         grepl <- base::grepl
[10:22:08.585]                         restarts <- computeRestarts(cond)
[10:22:08.585]                         for (restart in restarts) {
[10:22:08.585]                           name <- restart$name
[10:22:08.585]                           if (is.null(name)) 
[10:22:08.585]                             next
[10:22:08.585]                           if (!grepl(pattern, name)) 
[10:22:08.585]                             next
[10:22:08.585]                           invokeRestart(restart)
[10:22:08.585]                           muffled <- TRUE
[10:22:08.585]                           break
[10:22:08.585]                         }
[10:22:08.585]                       }
[10:22:08.585]                     }
[10:22:08.585]                     invisible(muffled)
[10:22:08.585]                   }
[10:22:08.585]                   muffleCondition(cond)
[10:22:08.585]                 })
[10:22:08.585]             }))
[10:22:08.585]             future::FutureResult(value = ...future.value$value, 
[10:22:08.585]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:08.585]                   ...future.rng), globalenv = if (FALSE) 
[10:22:08.585]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:08.585]                     ...future.globalenv.names))
[10:22:08.585]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:08.585]         }, condition = base::local({
[10:22:08.585]             c <- base::c
[10:22:08.585]             inherits <- base::inherits
[10:22:08.585]             invokeRestart <- base::invokeRestart
[10:22:08.585]             length <- base::length
[10:22:08.585]             list <- base::list
[10:22:08.585]             seq.int <- base::seq.int
[10:22:08.585]             signalCondition <- base::signalCondition
[10:22:08.585]             sys.calls <- base::sys.calls
[10:22:08.585]             `[[` <- base::`[[`
[10:22:08.585]             `+` <- base::`+`
[10:22:08.585]             `<<-` <- base::`<<-`
[10:22:08.585]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:08.585]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:08.585]                   3L)]
[10:22:08.585]             }
[10:22:08.585]             function(cond) {
[10:22:08.585]                 is_error <- inherits(cond, "error")
[10:22:08.585]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:08.585]                   NULL)
[10:22:08.585]                 if (is_error) {
[10:22:08.585]                   sessionInformation <- function() {
[10:22:08.585]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:08.585]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:08.585]                       search = base::search(), system = base::Sys.info())
[10:22:08.585]                   }
[10:22:08.585]                   ...future.conditions[[length(...future.conditions) + 
[10:22:08.585]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:08.585]                     cond$call), session = sessionInformation(), 
[10:22:08.585]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:08.585]                   signalCondition(cond)
[10:22:08.585]                 }
[10:22:08.585]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:08.585]                 "immediateCondition"))) {
[10:22:08.585]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:08.585]                   ...future.conditions[[length(...future.conditions) + 
[10:22:08.585]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:08.585]                   if (TRUE && !signal) {
[10:22:08.585]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:08.585]                     {
[10:22:08.585]                       inherits <- base::inherits
[10:22:08.585]                       invokeRestart <- base::invokeRestart
[10:22:08.585]                       is.null <- base::is.null
[10:22:08.585]                       muffled <- FALSE
[10:22:08.585]                       if (inherits(cond, "message")) {
[10:22:08.585]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:08.585]                         if (muffled) 
[10:22:08.585]                           invokeRestart("muffleMessage")
[10:22:08.585]                       }
[10:22:08.585]                       else if (inherits(cond, "warning")) {
[10:22:08.585]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:08.585]                         if (muffled) 
[10:22:08.585]                           invokeRestart("muffleWarning")
[10:22:08.585]                       }
[10:22:08.585]                       else if (inherits(cond, "condition")) {
[10:22:08.585]                         if (!is.null(pattern)) {
[10:22:08.585]                           computeRestarts <- base::computeRestarts
[10:22:08.585]                           grepl <- base::grepl
[10:22:08.585]                           restarts <- computeRestarts(cond)
[10:22:08.585]                           for (restart in restarts) {
[10:22:08.585]                             name <- restart$name
[10:22:08.585]                             if (is.null(name)) 
[10:22:08.585]                               next
[10:22:08.585]                             if (!grepl(pattern, name)) 
[10:22:08.585]                               next
[10:22:08.585]                             invokeRestart(restart)
[10:22:08.585]                             muffled <- TRUE
[10:22:08.585]                             break
[10:22:08.585]                           }
[10:22:08.585]                         }
[10:22:08.585]                       }
[10:22:08.585]                       invisible(muffled)
[10:22:08.585]                     }
[10:22:08.585]                     muffleCondition(cond, pattern = "^muffle")
[10:22:08.585]                   }
[10:22:08.585]                 }
[10:22:08.585]                 else {
[10:22:08.585]                   if (TRUE) {
[10:22:08.585]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:08.585]                     {
[10:22:08.585]                       inherits <- base::inherits
[10:22:08.585]                       invokeRestart <- base::invokeRestart
[10:22:08.585]                       is.null <- base::is.null
[10:22:08.585]                       muffled <- FALSE
[10:22:08.585]                       if (inherits(cond, "message")) {
[10:22:08.585]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:08.585]                         if (muffled) 
[10:22:08.585]                           invokeRestart("muffleMessage")
[10:22:08.585]                       }
[10:22:08.585]                       else if (inherits(cond, "warning")) {
[10:22:08.585]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:08.585]                         if (muffled) 
[10:22:08.585]                           invokeRestart("muffleWarning")
[10:22:08.585]                       }
[10:22:08.585]                       else if (inherits(cond, "condition")) {
[10:22:08.585]                         if (!is.null(pattern)) {
[10:22:08.585]                           computeRestarts <- base::computeRestarts
[10:22:08.585]                           grepl <- base::grepl
[10:22:08.585]                           restarts <- computeRestarts(cond)
[10:22:08.585]                           for (restart in restarts) {
[10:22:08.585]                             name <- restart$name
[10:22:08.585]                             if (is.null(name)) 
[10:22:08.585]                               next
[10:22:08.585]                             if (!grepl(pattern, name)) 
[10:22:08.585]                               next
[10:22:08.585]                             invokeRestart(restart)
[10:22:08.585]                             muffled <- TRUE
[10:22:08.585]                             break
[10:22:08.585]                           }
[10:22:08.585]                         }
[10:22:08.585]                       }
[10:22:08.585]                       invisible(muffled)
[10:22:08.585]                     }
[10:22:08.585]                     muffleCondition(cond, pattern = "^muffle")
[10:22:08.585]                   }
[10:22:08.585]                 }
[10:22:08.585]             }
[10:22:08.585]         }))
[10:22:08.585]     }, error = function(ex) {
[10:22:08.585]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:08.585]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:08.585]                 ...future.rng), started = ...future.startTime, 
[10:22:08.585]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:08.585]             version = "1.8"), class = "FutureResult")
[10:22:08.585]     }, finally = {
[10:22:08.585]         if (!identical(...future.workdir, getwd())) 
[10:22:08.585]             setwd(...future.workdir)
[10:22:08.585]         {
[10:22:08.585]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:08.585]                 ...future.oldOptions$nwarnings <- NULL
[10:22:08.585]             }
[10:22:08.585]             base::options(...future.oldOptions)
[10:22:08.585]             if (.Platform$OS.type == "windows") {
[10:22:08.585]                 old_names <- names(...future.oldEnvVars)
[10:22:08.585]                 envs <- base::Sys.getenv()
[10:22:08.585]                 names <- names(envs)
[10:22:08.585]                 common <- intersect(names, old_names)
[10:22:08.585]                 added <- setdiff(names, old_names)
[10:22:08.585]                 removed <- setdiff(old_names, names)
[10:22:08.585]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:08.585]                   envs[common]]
[10:22:08.585]                 NAMES <- toupper(changed)
[10:22:08.585]                 args <- list()
[10:22:08.585]                 for (kk in seq_along(NAMES)) {
[10:22:08.585]                   name <- changed[[kk]]
[10:22:08.585]                   NAME <- NAMES[[kk]]
[10:22:08.585]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:08.585]                     next
[10:22:08.585]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:08.585]                 }
[10:22:08.585]                 NAMES <- toupper(added)
[10:22:08.585]                 for (kk in seq_along(NAMES)) {
[10:22:08.585]                   name <- added[[kk]]
[10:22:08.585]                   NAME <- NAMES[[kk]]
[10:22:08.585]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:08.585]                     next
[10:22:08.585]                   args[[name]] <- ""
[10:22:08.585]                 }
[10:22:08.585]                 NAMES <- toupper(removed)
[10:22:08.585]                 for (kk in seq_along(NAMES)) {
[10:22:08.585]                   name <- removed[[kk]]
[10:22:08.585]                   NAME <- NAMES[[kk]]
[10:22:08.585]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:08.585]                     next
[10:22:08.585]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:08.585]                 }
[10:22:08.585]                 if (length(args) > 0) 
[10:22:08.585]                   base::do.call(base::Sys.setenv, args = args)
[10:22:08.585]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:08.585]             }
[10:22:08.585]             else {
[10:22:08.585]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:08.585]             }
[10:22:08.585]             {
[10:22:08.585]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:08.585]                   0L) {
[10:22:08.585]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:08.585]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:08.585]                   base::options(opts)
[10:22:08.585]                 }
[10:22:08.585]                 {
[10:22:08.585]                   {
[10:22:08.585]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:08.585]                     NULL
[10:22:08.585]                   }
[10:22:08.585]                   options(future.plan = NULL)
[10:22:08.585]                   if (is.na(NA_character_)) 
[10:22:08.585]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:08.585]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:08.585]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:08.585]                     .init = FALSE)
[10:22:08.585]                 }
[10:22:08.585]             }
[10:22:08.585]         }
[10:22:08.585]     })
[10:22:08.585]     if (TRUE) {
[10:22:08.585]         base::sink(type = "output", split = FALSE)
[10:22:08.585]         if (TRUE) {
[10:22:08.585]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:08.585]         }
[10:22:08.585]         else {
[10:22:08.585]             ...future.result["stdout"] <- base::list(NULL)
[10:22:08.585]         }
[10:22:08.585]         base::close(...future.stdout)
[10:22:08.585]         ...future.stdout <- NULL
[10:22:08.585]     }
[10:22:08.585]     ...future.result$conditions <- ...future.conditions
[10:22:08.585]     ...future.result$finished <- base::Sys.time()
[10:22:08.585]     ...future.result
[10:22:08.585] }
[10:22:08.588] Exporting 2 global objects (7.76 KiB) to cluster node #1 ...
[10:22:08.589] Exporting ‘nested’ (7.41 KiB) to cluster node #1 ...
[10:22:08.629] Exporting ‘nested’ (7.41 KiB) to cluster node #1 ... DONE
[10:22:08.630] Exporting ‘strategy2’ (49 bytes) to cluster node #1 ...
[10:22:08.630] Exporting ‘strategy2’ (49 bytes) to cluster node #1 ... DONE
[10:22:08.630] Exporting 2 global objects (7.76 KiB) to cluster node #1 ... DONE
[10:22:08.631] MultisessionFuture started
[10:22:08.631] - Launch lazy future ... done
[10:22:08.631] run() for ‘MultisessionFuture’ ... done
[10:22:08.631] result() for ClusterFuture ...
[10:22:08.631] receiveMessageFromWorker() for ClusterFuture ...
[10:22:08.631] - Validating connection of MultisessionFuture
[10:22:08.690] - received message: FutureResult
[10:22:08.691] - Received FutureResult
[10:22:08.691] - Erased future from FutureRegistry
[10:22:08.691] result() for ClusterFuture ...
[10:22:08.691] - result already collected: FutureResult
[10:22:08.691] result() for ClusterFuture ... done
[10:22:08.691] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:08.691] result() for ClusterFuture ... done
[10:22:08.691] result() for ClusterFuture ...
[10:22:08.691] - result already collected: FutureResult
[10:22:08.692] result() for ClusterFuture ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:22:08.697] getGlobalsAndPackages() ...
[10:22:08.698] Searching for globals...
[10:22:08.699] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[10:22:08.699] Searching for globals ... DONE
[10:22:08.699] Resolving globals: FALSE
[10:22:08.700] The total size of the 1 globals is 356 bytes (356 bytes)
[10:22:08.700] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[10:22:08.701] - globals: [1] ‘data’
[10:22:08.701] - packages: [1] ‘future’
[10:22:08.701] getGlobalsAndPackages() ... DONE
[10:22:08.701] run() for ‘Future’ ...
[10:22:08.701] - state: ‘created’
[10:22:08.701] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:08.716] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:08.716] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:08.716]   - Field: ‘node’
[10:22:08.716]   - Field: ‘label’
[10:22:08.716]   - Field: ‘local’
[10:22:08.716]   - Field: ‘owner’
[10:22:08.717]   - Field: ‘envir’
[10:22:08.717]   - Field: ‘workers’
[10:22:08.717]   - Field: ‘packages’
[10:22:08.717]   - Field: ‘gc’
[10:22:08.717]   - Field: ‘conditions’
[10:22:08.717]   - Field: ‘persistent’
[10:22:08.717]   - Field: ‘expr’
[10:22:08.717]   - Field: ‘uuid’
[10:22:08.717]   - Field: ‘seed’
[10:22:08.717]   - Field: ‘version’
[10:22:08.718]   - Field: ‘result’
[10:22:08.718]   - Field: ‘asynchronous’
[10:22:08.718]   - Field: ‘calls’
[10:22:08.718]   - Field: ‘globals’
[10:22:08.718]   - Field: ‘stdout’
[10:22:08.718]   - Field: ‘earlySignal’
[10:22:08.718]   - Field: ‘lazy’
[10:22:08.718]   - Field: ‘state’
[10:22:08.718] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:08.718] - Launch lazy future ...
[10:22:08.719] Packages needed by the future expression (n = 1): ‘future’
[10:22:08.719] Packages needed by future strategies (n = 1): ‘future’
[10:22:08.719] {
[10:22:08.719]     {
[10:22:08.719]         {
[10:22:08.719]             ...future.startTime <- base::Sys.time()
[10:22:08.719]             {
[10:22:08.719]                 {
[10:22:08.719]                   {
[10:22:08.719]                     {
[10:22:08.719]                       {
[10:22:08.719]                         base::local({
[10:22:08.719]                           has_future <- base::requireNamespace("future", 
[10:22:08.719]                             quietly = TRUE)
[10:22:08.719]                           if (has_future) {
[10:22:08.719]                             ns <- base::getNamespace("future")
[10:22:08.719]                             version <- ns[[".package"]][["version"]]
[10:22:08.719]                             if (is.null(version)) 
[10:22:08.719]                               version <- utils::packageVersion("future")
[10:22:08.719]                           }
[10:22:08.719]                           else {
[10:22:08.719]                             version <- NULL
[10:22:08.719]                           }
[10:22:08.719]                           if (!has_future || version < "1.8.0") {
[10:22:08.719]                             info <- base::c(r_version = base::gsub("R version ", 
[10:22:08.719]                               "", base::R.version$version.string), 
[10:22:08.719]                               platform = base::sprintf("%s (%s-bit)", 
[10:22:08.719]                                 base::R.version$platform, 8 * 
[10:22:08.719]                                   base::.Machine$sizeof.pointer), 
[10:22:08.719]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:08.719]                                 "release", "version")], collapse = " "), 
[10:22:08.719]                               hostname = base::Sys.info()[["nodename"]])
[10:22:08.719]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:22:08.719]                               info)
[10:22:08.719]                             info <- base::paste(info, collapse = "; ")
[10:22:08.719]                             if (!has_future) {
[10:22:08.719]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:08.719]                                 info)
[10:22:08.719]                             }
[10:22:08.719]                             else {
[10:22:08.719]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:08.719]                                 info, version)
[10:22:08.719]                             }
[10:22:08.719]                             base::stop(msg)
[10:22:08.719]                           }
[10:22:08.719]                         })
[10:22:08.719]                       }
[10:22:08.719]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:08.719]                       base::options(mc.cores = 1L)
[10:22:08.719]                     }
[10:22:08.719]                     base::local({
[10:22:08.719]                       for (pkg in "future") {
[10:22:08.719]                         base::loadNamespace(pkg)
[10:22:08.719]                         base::library(pkg, character.only = TRUE)
[10:22:08.719]                       }
[10:22:08.719]                     })
[10:22:08.719]                   }
[10:22:08.719]                   ...future.strategy.old <- future::plan("list")
[10:22:08.719]                   options(future.plan = NULL)
[10:22:08.719]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:08.719]                   future::plan(list(b = function (..., envir = parent.frame()) 
[10:22:08.719]                   {
[10:22:08.719]                     future <- SequentialFuture(..., envir = envir)
[10:22:08.719]                     if (!future$lazy) 
[10:22:08.719]                       future <- run(future)
[10:22:08.719]                     invisible(future)
[10:22:08.719]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:08.719]                 }
[10:22:08.719]                 ...future.workdir <- getwd()
[10:22:08.719]             }
[10:22:08.719]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:08.719]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:08.719]         }
[10:22:08.719]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:08.719]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:08.719]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:08.719]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:08.719]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:08.719]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:08.719]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:08.719]             base::names(...future.oldOptions))
[10:22:08.719]     }
[10:22:08.719]     if (FALSE) {
[10:22:08.719]     }
[10:22:08.719]     else {
[10:22:08.719]         if (TRUE) {
[10:22:08.719]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:08.719]                 open = "w")
[10:22:08.719]         }
[10:22:08.719]         else {
[10:22:08.719]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:08.719]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:08.719]         }
[10:22:08.719]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:08.719]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:08.719]             base::sink(type = "output", split = FALSE)
[10:22:08.719]             base::close(...future.stdout)
[10:22:08.719]         }, add = TRUE)
[10:22:08.719]     }
[10:22:08.719]     ...future.frame <- base::sys.nframe()
[10:22:08.719]     ...future.conditions <- base::list()
[10:22:08.719]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:08.719]     if (FALSE) {
[10:22:08.719]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:08.719]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:08.719]     }
[10:22:08.719]     ...future.result <- base::tryCatch({
[10:22:08.719]         base::withCallingHandlers({
[10:22:08.719]             ...future.value <- base::withVisible(base::local({
[10:22:08.719]                 ...future.makeSendCondition <- base::local({
[10:22:08.719]                   sendCondition <- NULL
[10:22:08.719]                   function(frame = 1L) {
[10:22:08.719]                     if (is.function(sendCondition)) 
[10:22:08.719]                       return(sendCondition)
[10:22:08.719]                     ns <- getNamespace("parallel")
[10:22:08.719]                     if (exists("sendData", mode = "function", 
[10:22:08.719]                       envir = ns)) {
[10:22:08.719]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:08.719]                         envir = ns)
[10:22:08.719]                       envir <- sys.frame(frame)
[10:22:08.719]                       master <- NULL
[10:22:08.719]                       while (!identical(envir, .GlobalEnv) && 
[10:22:08.719]                         !identical(envir, emptyenv())) {
[10:22:08.719]                         if (exists("master", mode = "list", envir = envir, 
[10:22:08.719]                           inherits = FALSE)) {
[10:22:08.719]                           master <- get("master", mode = "list", 
[10:22:08.719]                             envir = envir, inherits = FALSE)
[10:22:08.719]                           if (inherits(master, c("SOCKnode", 
[10:22:08.719]                             "SOCK0node"))) {
[10:22:08.719]                             sendCondition <<- function(cond) {
[10:22:08.719]                               data <- list(type = "VALUE", value = cond, 
[10:22:08.719]                                 success = TRUE)
[10:22:08.719]                               parallel_sendData(master, data)
[10:22:08.719]                             }
[10:22:08.719]                             return(sendCondition)
[10:22:08.719]                           }
[10:22:08.719]                         }
[10:22:08.719]                         frame <- frame + 1L
[10:22:08.719]                         envir <- sys.frame(frame)
[10:22:08.719]                       }
[10:22:08.719]                     }
[10:22:08.719]                     sendCondition <<- function(cond) NULL
[10:22:08.719]                   }
[10:22:08.719]                 })
[10:22:08.719]                 withCallingHandlers({
[10:22:08.719]                   {
[10:22:08.719]                     value(future(subset(data, a == 2)))
[10:22:08.719]                   }
[10:22:08.719]                 }, immediateCondition = function(cond) {
[10:22:08.719]                   sendCondition <- ...future.makeSendCondition()
[10:22:08.719]                   sendCondition(cond)
[10:22:08.719]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:08.719]                   {
[10:22:08.719]                     inherits <- base::inherits
[10:22:08.719]                     invokeRestart <- base::invokeRestart
[10:22:08.719]                     is.null <- base::is.null
[10:22:08.719]                     muffled <- FALSE
[10:22:08.719]                     if (inherits(cond, "message")) {
[10:22:08.719]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:08.719]                       if (muffled) 
[10:22:08.719]                         invokeRestart("muffleMessage")
[10:22:08.719]                     }
[10:22:08.719]                     else if (inherits(cond, "warning")) {
[10:22:08.719]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:08.719]                       if (muffled) 
[10:22:08.719]                         invokeRestart("muffleWarning")
[10:22:08.719]                     }
[10:22:08.719]                     else if (inherits(cond, "condition")) {
[10:22:08.719]                       if (!is.null(pattern)) {
[10:22:08.719]                         computeRestarts <- base::computeRestarts
[10:22:08.719]                         grepl <- base::grepl
[10:22:08.719]                         restarts <- computeRestarts(cond)
[10:22:08.719]                         for (restart in restarts) {
[10:22:08.719]                           name <- restart$name
[10:22:08.719]                           if (is.null(name)) 
[10:22:08.719]                             next
[10:22:08.719]                           if (!grepl(pattern, name)) 
[10:22:08.719]                             next
[10:22:08.719]                           invokeRestart(restart)
[10:22:08.719]                           muffled <- TRUE
[10:22:08.719]                           break
[10:22:08.719]                         }
[10:22:08.719]                       }
[10:22:08.719]                     }
[10:22:08.719]                     invisible(muffled)
[10:22:08.719]                   }
[10:22:08.719]                   muffleCondition(cond)
[10:22:08.719]                 })
[10:22:08.719]             }))
[10:22:08.719]             future::FutureResult(value = ...future.value$value, 
[10:22:08.719]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:08.719]                   ...future.rng), globalenv = if (FALSE) 
[10:22:08.719]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:08.719]                     ...future.globalenv.names))
[10:22:08.719]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:08.719]         }, condition = base::local({
[10:22:08.719]             c <- base::c
[10:22:08.719]             inherits <- base::inherits
[10:22:08.719]             invokeRestart <- base::invokeRestart
[10:22:08.719]             length <- base::length
[10:22:08.719]             list <- base::list
[10:22:08.719]             seq.int <- base::seq.int
[10:22:08.719]             signalCondition <- base::signalCondition
[10:22:08.719]             sys.calls <- base::sys.calls
[10:22:08.719]             `[[` <- base::`[[`
[10:22:08.719]             `+` <- base::`+`
[10:22:08.719]             `<<-` <- base::`<<-`
[10:22:08.719]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:08.719]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:08.719]                   3L)]
[10:22:08.719]             }
[10:22:08.719]             function(cond) {
[10:22:08.719]                 is_error <- inherits(cond, "error")
[10:22:08.719]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:08.719]                   NULL)
[10:22:08.719]                 if (is_error) {
[10:22:08.719]                   sessionInformation <- function() {
[10:22:08.719]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:08.719]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:08.719]                       search = base::search(), system = base::Sys.info())
[10:22:08.719]                   }
[10:22:08.719]                   ...future.conditions[[length(...future.conditions) + 
[10:22:08.719]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:08.719]                     cond$call), session = sessionInformation(), 
[10:22:08.719]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:08.719]                   signalCondition(cond)
[10:22:08.719]                 }
[10:22:08.719]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:08.719]                 "immediateCondition"))) {
[10:22:08.719]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:08.719]                   ...future.conditions[[length(...future.conditions) + 
[10:22:08.719]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:08.719]                   if (TRUE && !signal) {
[10:22:08.719]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:08.719]                     {
[10:22:08.719]                       inherits <- base::inherits
[10:22:08.719]                       invokeRestart <- base::invokeRestart
[10:22:08.719]                       is.null <- base::is.null
[10:22:08.719]                       muffled <- FALSE
[10:22:08.719]                       if (inherits(cond, "message")) {
[10:22:08.719]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:08.719]                         if (muffled) 
[10:22:08.719]                           invokeRestart("muffleMessage")
[10:22:08.719]                       }
[10:22:08.719]                       else if (inherits(cond, "warning")) {
[10:22:08.719]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:08.719]                         if (muffled) 
[10:22:08.719]                           invokeRestart("muffleWarning")
[10:22:08.719]                       }
[10:22:08.719]                       else if (inherits(cond, "condition")) {
[10:22:08.719]                         if (!is.null(pattern)) {
[10:22:08.719]                           computeRestarts <- base::computeRestarts
[10:22:08.719]                           grepl <- base::grepl
[10:22:08.719]                           restarts <- computeRestarts(cond)
[10:22:08.719]                           for (restart in restarts) {
[10:22:08.719]                             name <- restart$name
[10:22:08.719]                             if (is.null(name)) 
[10:22:08.719]                               next
[10:22:08.719]                             if (!grepl(pattern, name)) 
[10:22:08.719]                               next
[10:22:08.719]                             invokeRestart(restart)
[10:22:08.719]                             muffled <- TRUE
[10:22:08.719]                             break
[10:22:08.719]                           }
[10:22:08.719]                         }
[10:22:08.719]                       }
[10:22:08.719]                       invisible(muffled)
[10:22:08.719]                     }
[10:22:08.719]                     muffleCondition(cond, pattern = "^muffle")
[10:22:08.719]                   }
[10:22:08.719]                 }
[10:22:08.719]                 else {
[10:22:08.719]                   if (TRUE) {
[10:22:08.719]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:08.719]                     {
[10:22:08.719]                       inherits <- base::inherits
[10:22:08.719]                       invokeRestart <- base::invokeRestart
[10:22:08.719]                       is.null <- base::is.null
[10:22:08.719]                       muffled <- FALSE
[10:22:08.719]                       if (inherits(cond, "message")) {
[10:22:08.719]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:08.719]                         if (muffled) 
[10:22:08.719]                           invokeRestart("muffleMessage")
[10:22:08.719]                       }
[10:22:08.719]                       else if (inherits(cond, "warning")) {
[10:22:08.719]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:08.719]                         if (muffled) 
[10:22:08.719]                           invokeRestart("muffleWarning")
[10:22:08.719]                       }
[10:22:08.719]                       else if (inherits(cond, "condition")) {
[10:22:08.719]                         if (!is.null(pattern)) {
[10:22:08.719]                           computeRestarts <- base::computeRestarts
[10:22:08.719]                           grepl <- base::grepl
[10:22:08.719]                           restarts <- computeRestarts(cond)
[10:22:08.719]                           for (restart in restarts) {
[10:22:08.719]                             name <- restart$name
[10:22:08.719]                             if (is.null(name)) 
[10:22:08.719]                               next
[10:22:08.719]                             if (!grepl(pattern, name)) 
[10:22:08.719]                               next
[10:22:08.719]                             invokeRestart(restart)
[10:22:08.719]                             muffled <- TRUE
[10:22:08.719]                             break
[10:22:08.719]                           }
[10:22:08.719]                         }
[10:22:08.719]                       }
[10:22:08.719]                       invisible(muffled)
[10:22:08.719]                     }
[10:22:08.719]                     muffleCondition(cond, pattern = "^muffle")
[10:22:08.719]                   }
[10:22:08.719]                 }
[10:22:08.719]             }
[10:22:08.719]         }))
[10:22:08.719]     }, error = function(ex) {
[10:22:08.719]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:08.719]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:08.719]                 ...future.rng), started = ...future.startTime, 
[10:22:08.719]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:08.719]             version = "1.8"), class = "FutureResult")
[10:22:08.719]     }, finally = {
[10:22:08.719]         if (!identical(...future.workdir, getwd())) 
[10:22:08.719]             setwd(...future.workdir)
[10:22:08.719]         {
[10:22:08.719]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:08.719]                 ...future.oldOptions$nwarnings <- NULL
[10:22:08.719]             }
[10:22:08.719]             base::options(...future.oldOptions)
[10:22:08.719]             if (.Platform$OS.type == "windows") {
[10:22:08.719]                 old_names <- names(...future.oldEnvVars)
[10:22:08.719]                 envs <- base::Sys.getenv()
[10:22:08.719]                 names <- names(envs)
[10:22:08.719]                 common <- intersect(names, old_names)
[10:22:08.719]                 added <- setdiff(names, old_names)
[10:22:08.719]                 removed <- setdiff(old_names, names)
[10:22:08.719]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:08.719]                   envs[common]]
[10:22:08.719]                 NAMES <- toupper(changed)
[10:22:08.719]                 args <- list()
[10:22:08.719]                 for (kk in seq_along(NAMES)) {
[10:22:08.719]                   name <- changed[[kk]]
[10:22:08.719]                   NAME <- NAMES[[kk]]
[10:22:08.719]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:08.719]                     next
[10:22:08.719]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:08.719]                 }
[10:22:08.719]                 NAMES <- toupper(added)
[10:22:08.719]                 for (kk in seq_along(NAMES)) {
[10:22:08.719]                   name <- added[[kk]]
[10:22:08.719]                   NAME <- NAMES[[kk]]
[10:22:08.719]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:08.719]                     next
[10:22:08.719]                   args[[name]] <- ""
[10:22:08.719]                 }
[10:22:08.719]                 NAMES <- toupper(removed)
[10:22:08.719]                 for (kk in seq_along(NAMES)) {
[10:22:08.719]                   name <- removed[[kk]]
[10:22:08.719]                   NAME <- NAMES[[kk]]
[10:22:08.719]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:08.719]                     next
[10:22:08.719]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:08.719]                 }
[10:22:08.719]                 if (length(args) > 0) 
[10:22:08.719]                   base::do.call(base::Sys.setenv, args = args)
[10:22:08.719]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:08.719]             }
[10:22:08.719]             else {
[10:22:08.719]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:08.719]             }
[10:22:08.719]             {
[10:22:08.719]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:08.719]                   0L) {
[10:22:08.719]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:08.719]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:08.719]                   base::options(opts)
[10:22:08.719]                 }
[10:22:08.719]                 {
[10:22:08.719]                   {
[10:22:08.719]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:08.719]                     NULL
[10:22:08.719]                   }
[10:22:08.719]                   options(future.plan = NULL)
[10:22:08.719]                   if (is.na(NA_character_)) 
[10:22:08.719]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:08.719]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:08.719]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:08.719]                     .init = FALSE)
[10:22:08.719]                 }
[10:22:08.719]             }
[10:22:08.719]         }
[10:22:08.719]     })
[10:22:08.719]     if (TRUE) {
[10:22:08.719]         base::sink(type = "output", split = FALSE)
[10:22:08.719]         if (TRUE) {
[10:22:08.719]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:08.719]         }
[10:22:08.719]         else {
[10:22:08.719]             ...future.result["stdout"] <- base::list(NULL)
[10:22:08.719]         }
[10:22:08.719]         base::close(...future.stdout)
[10:22:08.719]         ...future.stdout <- NULL
[10:22:08.719]     }
[10:22:08.719]     ...future.result$conditions <- ...future.conditions
[10:22:08.719]     ...future.result$finished <- base::Sys.time()
[10:22:08.719]     ...future.result
[10:22:08.719] }
[10:22:08.722] Exporting 1 global objects (643 bytes) to cluster node #1 ...
[10:22:08.722] Exporting ‘data’ (356 bytes) to cluster node #1 ...
[10:22:08.723] Exporting ‘data’ (356 bytes) to cluster node #1 ... DONE
[10:22:08.723] Exporting 1 global objects (643 bytes) to cluster node #1 ... DONE
[10:22:08.723] MultisessionFuture started
[10:22:08.723] - Launch lazy future ... done
[10:22:08.724] run() for ‘MultisessionFuture’ ... done
[10:22:08.724] result() for ClusterFuture ...
[10:22:08.724] receiveMessageFromWorker() for ClusterFuture ...
[10:22:08.724] - Validating connection of MultisessionFuture
[10:22:08.768] - received message: FutureResult
[10:22:08.768] - Received FutureResult
[10:22:08.769] - Erased future from FutureRegistry
[10:22:08.769] result() for ClusterFuture ...
[10:22:08.769] - result already collected: FutureResult
[10:22:08.769] result() for ClusterFuture ... done
[10:22:08.769] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:08.769] result() for ClusterFuture ... done
[10:22:08.769] result() for ClusterFuture ...
[10:22:08.769] - result already collected: FutureResult
[10:22:08.769] result() for ClusterFuture ... done
- plan(list('multisession', 'sequential')) ... DONE
- plan(list('multisession', 'multicore')) ...
[10:22:08.770] plan(): Setting new future strategy stack:
[10:22:08.770] List of future strategies:
[10:22:08.770] 1. multisession:
[10:22:08.770]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:22:08.770]    - tweaked: FALSE
[10:22:08.770]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:08.770] 2. multicore:
[10:22:08.770]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:22:08.770]    - tweaked: FALSE
[10:22:08.770]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:08.771] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:22:08.771] multisession:
[10:22:08.771] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:22:08.771] - tweaked: FALSE
[10:22:08.771] - call: plan(list(a = strategy1, b = strategy2))
[10:22:08.773] getGlobalsAndPackages() ...
[10:22:08.773] Not searching for globals
[10:22:08.773] - globals: [0] <none>
[10:22:08.773] getGlobalsAndPackages() ... DONE
[10:22:09.034] Packages needed by the future expression (n = 0): <none>
[10:22:09.034] Packages needed by future strategies (n = 1): ‘future’
[10:22:09.034] {
[10:22:09.034]     {
[10:22:09.034]         {
[10:22:09.034]             ...future.startTime <- base::Sys.time()
[10:22:09.034]             {
[10:22:09.034]                 {
[10:22:09.034]                   {
[10:22:09.034]                     {
[10:22:09.034]                       {
[10:22:09.034]                         base::local({
[10:22:09.034]                           has_future <- base::requireNamespace("future", 
[10:22:09.034]                             quietly = TRUE)
[10:22:09.034]                           if (has_future) {
[10:22:09.034]                             ns <- base::getNamespace("future")
[10:22:09.034]                             version <- ns[[".package"]][["version"]]
[10:22:09.034]                             if (is.null(version)) 
[10:22:09.034]                               version <- utils::packageVersion("future")
[10:22:09.034]                           }
[10:22:09.034]                           else {
[10:22:09.034]                             version <- NULL
[10:22:09.034]                           }
[10:22:09.034]                           if (!has_future || version < "1.8.0") {
[10:22:09.034]                             info <- base::c(r_version = base::gsub("R version ", 
[10:22:09.034]                               "", base::R.version$version.string), 
[10:22:09.034]                               platform = base::sprintf("%s (%s-bit)", 
[10:22:09.034]                                 base::R.version$platform, 8 * 
[10:22:09.034]                                   base::.Machine$sizeof.pointer), 
[10:22:09.034]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:09.034]                                 "release", "version")], collapse = " "), 
[10:22:09.034]                               hostname = base::Sys.info()[["nodename"]])
[10:22:09.034]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:22:09.034]                               info)
[10:22:09.034]                             info <- base::paste(info, collapse = "; ")
[10:22:09.034]                             if (!has_future) {
[10:22:09.034]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:09.034]                                 info)
[10:22:09.034]                             }
[10:22:09.034]                             else {
[10:22:09.034]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:09.034]                                 info, version)
[10:22:09.034]                             }
[10:22:09.034]                             base::stop(msg)
[10:22:09.034]                           }
[10:22:09.034]                         })
[10:22:09.034]                       }
[10:22:09.034]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:09.034]                       base::options(mc.cores = 1L)
[10:22:09.034]                     }
[10:22:09.034]                     base::local({
[10:22:09.034]                       for (pkg in "future") {
[10:22:09.034]                         base::loadNamespace(pkg)
[10:22:09.034]                         base::library(pkg, character.only = TRUE)
[10:22:09.034]                       }
[10:22:09.034]                     })
[10:22:09.034]                   }
[10:22:09.034]                   ...future.strategy.old <- future::plan("list")
[10:22:09.034]                   options(future.plan = NULL)
[10:22:09.034]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:09.034]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[10:22:09.034]                     envir = parent.frame()) 
[10:22:09.034]                   {
[10:22:09.034]                     default_workers <- missing(workers)
[10:22:09.034]                     if (is.function(workers)) 
[10:22:09.034]                       workers <- workers()
[10:22:09.034]                     workers <- structure(as.integer(workers), 
[10:22:09.034]                       class = class(workers))
[10:22:09.034]                     stop_if_not(is.finite(workers), workers >= 
[10:22:09.034]                       1L)
[10:22:09.034]                     if ((workers == 1L && !inherits(workers, 
[10:22:09.034]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:09.034]                       if (default_workers) 
[10:22:09.034]                         supportsMulticore(warn = TRUE)
[10:22:09.034]                       return(sequential(..., envir = envir))
[10:22:09.034]                     }
[10:22:09.034]                     oopts <- options(mc.cores = workers)
[10:22:09.034]                     on.exit(options(oopts))
[10:22:09.034]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:09.034]                       envir = envir)
[10:22:09.034]                     if (!future$lazy) 
[10:22:09.034]                       future <- run(future)
[10:22:09.034]                     invisible(future)
[10:22:09.034]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:09.034]                 }
[10:22:09.034]                 ...future.workdir <- getwd()
[10:22:09.034]             }
[10:22:09.034]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:09.034]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:09.034]         }
[10:22:09.034]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:09.034]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:09.034]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:09.034]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:09.034]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:09.034]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:09.034]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:09.034]             base::names(...future.oldOptions))
[10:22:09.034]     }
[10:22:09.034]     if (FALSE) {
[10:22:09.034]     }
[10:22:09.034]     else {
[10:22:09.034]         if (TRUE) {
[10:22:09.034]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:09.034]                 open = "w")
[10:22:09.034]         }
[10:22:09.034]         else {
[10:22:09.034]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:09.034]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:09.034]         }
[10:22:09.034]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:09.034]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:09.034]             base::sink(type = "output", split = FALSE)
[10:22:09.034]             base::close(...future.stdout)
[10:22:09.034]         }, add = TRUE)
[10:22:09.034]     }
[10:22:09.034]     ...future.frame <- base::sys.nframe()
[10:22:09.034]     ...future.conditions <- base::list()
[10:22:09.034]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:09.034]     if (FALSE) {
[10:22:09.034]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:09.034]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:09.034]     }
[10:22:09.034]     ...future.result <- base::tryCatch({
[10:22:09.034]         base::withCallingHandlers({
[10:22:09.034]             ...future.value <- base::withVisible(base::local({
[10:22:09.034]                 ...future.makeSendCondition <- base::local({
[10:22:09.034]                   sendCondition <- NULL
[10:22:09.034]                   function(frame = 1L) {
[10:22:09.034]                     if (is.function(sendCondition)) 
[10:22:09.034]                       return(sendCondition)
[10:22:09.034]                     ns <- getNamespace("parallel")
[10:22:09.034]                     if (exists("sendData", mode = "function", 
[10:22:09.034]                       envir = ns)) {
[10:22:09.034]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:09.034]                         envir = ns)
[10:22:09.034]                       envir <- sys.frame(frame)
[10:22:09.034]                       master <- NULL
[10:22:09.034]                       while (!identical(envir, .GlobalEnv) && 
[10:22:09.034]                         !identical(envir, emptyenv())) {
[10:22:09.034]                         if (exists("master", mode = "list", envir = envir, 
[10:22:09.034]                           inherits = FALSE)) {
[10:22:09.034]                           master <- get("master", mode = "list", 
[10:22:09.034]                             envir = envir, inherits = FALSE)
[10:22:09.034]                           if (inherits(master, c("SOCKnode", 
[10:22:09.034]                             "SOCK0node"))) {
[10:22:09.034]                             sendCondition <<- function(cond) {
[10:22:09.034]                               data <- list(type = "VALUE", value = cond, 
[10:22:09.034]                                 success = TRUE)
[10:22:09.034]                               parallel_sendData(master, data)
[10:22:09.034]                             }
[10:22:09.034]                             return(sendCondition)
[10:22:09.034]                           }
[10:22:09.034]                         }
[10:22:09.034]                         frame <- frame + 1L
[10:22:09.034]                         envir <- sys.frame(frame)
[10:22:09.034]                       }
[10:22:09.034]                     }
[10:22:09.034]                     sendCondition <<- function(cond) NULL
[10:22:09.034]                   }
[10:22:09.034]                 })
[10:22:09.034]                 withCallingHandlers({
[10:22:09.034]                   NA
[10:22:09.034]                 }, immediateCondition = function(cond) {
[10:22:09.034]                   sendCondition <- ...future.makeSendCondition()
[10:22:09.034]                   sendCondition(cond)
[10:22:09.034]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:09.034]                   {
[10:22:09.034]                     inherits <- base::inherits
[10:22:09.034]                     invokeRestart <- base::invokeRestart
[10:22:09.034]                     is.null <- base::is.null
[10:22:09.034]                     muffled <- FALSE
[10:22:09.034]                     if (inherits(cond, "message")) {
[10:22:09.034]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:09.034]                       if (muffled) 
[10:22:09.034]                         invokeRestart("muffleMessage")
[10:22:09.034]                     }
[10:22:09.034]                     else if (inherits(cond, "warning")) {
[10:22:09.034]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:09.034]                       if (muffled) 
[10:22:09.034]                         invokeRestart("muffleWarning")
[10:22:09.034]                     }
[10:22:09.034]                     else if (inherits(cond, "condition")) {
[10:22:09.034]                       if (!is.null(pattern)) {
[10:22:09.034]                         computeRestarts <- base::computeRestarts
[10:22:09.034]                         grepl <- base::grepl
[10:22:09.034]                         restarts <- computeRestarts(cond)
[10:22:09.034]                         for (restart in restarts) {
[10:22:09.034]                           name <- restart$name
[10:22:09.034]                           if (is.null(name)) 
[10:22:09.034]                             next
[10:22:09.034]                           if (!grepl(pattern, name)) 
[10:22:09.034]                             next
[10:22:09.034]                           invokeRestart(restart)
[10:22:09.034]                           muffled <- TRUE
[10:22:09.034]                           break
[10:22:09.034]                         }
[10:22:09.034]                       }
[10:22:09.034]                     }
[10:22:09.034]                     invisible(muffled)
[10:22:09.034]                   }
[10:22:09.034]                   muffleCondition(cond)
[10:22:09.034]                 })
[10:22:09.034]             }))
[10:22:09.034]             future::FutureResult(value = ...future.value$value, 
[10:22:09.034]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:09.034]                   ...future.rng), globalenv = if (FALSE) 
[10:22:09.034]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:09.034]                     ...future.globalenv.names))
[10:22:09.034]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:09.034]         }, condition = base::local({
[10:22:09.034]             c <- base::c
[10:22:09.034]             inherits <- base::inherits
[10:22:09.034]             invokeRestart <- base::invokeRestart
[10:22:09.034]             length <- base::length
[10:22:09.034]             list <- base::list
[10:22:09.034]             seq.int <- base::seq.int
[10:22:09.034]             signalCondition <- base::signalCondition
[10:22:09.034]             sys.calls <- base::sys.calls
[10:22:09.034]             `[[` <- base::`[[`
[10:22:09.034]             `+` <- base::`+`
[10:22:09.034]             `<<-` <- base::`<<-`
[10:22:09.034]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:09.034]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:09.034]                   3L)]
[10:22:09.034]             }
[10:22:09.034]             function(cond) {
[10:22:09.034]                 is_error <- inherits(cond, "error")
[10:22:09.034]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:09.034]                   NULL)
[10:22:09.034]                 if (is_error) {
[10:22:09.034]                   sessionInformation <- function() {
[10:22:09.034]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:09.034]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:09.034]                       search = base::search(), system = base::Sys.info())
[10:22:09.034]                   }
[10:22:09.034]                   ...future.conditions[[length(...future.conditions) + 
[10:22:09.034]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:09.034]                     cond$call), session = sessionInformation(), 
[10:22:09.034]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:09.034]                   signalCondition(cond)
[10:22:09.034]                 }
[10:22:09.034]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:09.034]                 "immediateCondition"))) {
[10:22:09.034]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:09.034]                   ...future.conditions[[length(...future.conditions) + 
[10:22:09.034]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:09.034]                   if (TRUE && !signal) {
[10:22:09.034]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:09.034]                     {
[10:22:09.034]                       inherits <- base::inherits
[10:22:09.034]                       invokeRestart <- base::invokeRestart
[10:22:09.034]                       is.null <- base::is.null
[10:22:09.034]                       muffled <- FALSE
[10:22:09.034]                       if (inherits(cond, "message")) {
[10:22:09.034]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:09.034]                         if (muffled) 
[10:22:09.034]                           invokeRestart("muffleMessage")
[10:22:09.034]                       }
[10:22:09.034]                       else if (inherits(cond, "warning")) {
[10:22:09.034]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:09.034]                         if (muffled) 
[10:22:09.034]                           invokeRestart("muffleWarning")
[10:22:09.034]                       }
[10:22:09.034]                       else if (inherits(cond, "condition")) {
[10:22:09.034]                         if (!is.null(pattern)) {
[10:22:09.034]                           computeRestarts <- base::computeRestarts
[10:22:09.034]                           grepl <- base::grepl
[10:22:09.034]                           restarts <- computeRestarts(cond)
[10:22:09.034]                           for (restart in restarts) {
[10:22:09.034]                             name <- restart$name
[10:22:09.034]                             if (is.null(name)) 
[10:22:09.034]                               next
[10:22:09.034]                             if (!grepl(pattern, name)) 
[10:22:09.034]                               next
[10:22:09.034]                             invokeRestart(restart)
[10:22:09.034]                             muffled <- TRUE
[10:22:09.034]                             break
[10:22:09.034]                           }
[10:22:09.034]                         }
[10:22:09.034]                       }
[10:22:09.034]                       invisible(muffled)
[10:22:09.034]                     }
[10:22:09.034]                     muffleCondition(cond, pattern = "^muffle")
[10:22:09.034]                   }
[10:22:09.034]                 }
[10:22:09.034]                 else {
[10:22:09.034]                   if (TRUE) {
[10:22:09.034]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:09.034]                     {
[10:22:09.034]                       inherits <- base::inherits
[10:22:09.034]                       invokeRestart <- base::invokeRestart
[10:22:09.034]                       is.null <- base::is.null
[10:22:09.034]                       muffled <- FALSE
[10:22:09.034]                       if (inherits(cond, "message")) {
[10:22:09.034]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:09.034]                         if (muffled) 
[10:22:09.034]                           invokeRestart("muffleMessage")
[10:22:09.034]                       }
[10:22:09.034]                       else if (inherits(cond, "warning")) {
[10:22:09.034]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:09.034]                         if (muffled) 
[10:22:09.034]                           invokeRestart("muffleWarning")
[10:22:09.034]                       }
[10:22:09.034]                       else if (inherits(cond, "condition")) {
[10:22:09.034]                         if (!is.null(pattern)) {
[10:22:09.034]                           computeRestarts <- base::computeRestarts
[10:22:09.034]                           grepl <- base::grepl
[10:22:09.034]                           restarts <- computeRestarts(cond)
[10:22:09.034]                           for (restart in restarts) {
[10:22:09.034]                             name <- restart$name
[10:22:09.034]                             if (is.null(name)) 
[10:22:09.034]                               next
[10:22:09.034]                             if (!grepl(pattern, name)) 
[10:22:09.034]                               next
[10:22:09.034]                             invokeRestart(restart)
[10:22:09.034]                             muffled <- TRUE
[10:22:09.034]                             break
[10:22:09.034]                           }
[10:22:09.034]                         }
[10:22:09.034]                       }
[10:22:09.034]                       invisible(muffled)
[10:22:09.034]                     }
[10:22:09.034]                     muffleCondition(cond, pattern = "^muffle")
[10:22:09.034]                   }
[10:22:09.034]                 }
[10:22:09.034]             }
[10:22:09.034]         }))
[10:22:09.034]     }, error = function(ex) {
[10:22:09.034]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:09.034]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:09.034]                 ...future.rng), started = ...future.startTime, 
[10:22:09.034]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:09.034]             version = "1.8"), class = "FutureResult")
[10:22:09.034]     }, finally = {
[10:22:09.034]         if (!identical(...future.workdir, getwd())) 
[10:22:09.034]             setwd(...future.workdir)
[10:22:09.034]         {
[10:22:09.034]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:09.034]                 ...future.oldOptions$nwarnings <- NULL
[10:22:09.034]             }
[10:22:09.034]             base::options(...future.oldOptions)
[10:22:09.034]             if (.Platform$OS.type == "windows") {
[10:22:09.034]                 old_names <- names(...future.oldEnvVars)
[10:22:09.034]                 envs <- base::Sys.getenv()
[10:22:09.034]                 names <- names(envs)
[10:22:09.034]                 common <- intersect(names, old_names)
[10:22:09.034]                 added <- setdiff(names, old_names)
[10:22:09.034]                 removed <- setdiff(old_names, names)
[10:22:09.034]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:09.034]                   envs[common]]
[10:22:09.034]                 NAMES <- toupper(changed)
[10:22:09.034]                 args <- list()
[10:22:09.034]                 for (kk in seq_along(NAMES)) {
[10:22:09.034]                   name <- changed[[kk]]
[10:22:09.034]                   NAME <- NAMES[[kk]]
[10:22:09.034]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:09.034]                     next
[10:22:09.034]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:09.034]                 }
[10:22:09.034]                 NAMES <- toupper(added)
[10:22:09.034]                 for (kk in seq_along(NAMES)) {
[10:22:09.034]                   name <- added[[kk]]
[10:22:09.034]                   NAME <- NAMES[[kk]]
[10:22:09.034]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:09.034]                     next
[10:22:09.034]                   args[[name]] <- ""
[10:22:09.034]                 }
[10:22:09.034]                 NAMES <- toupper(removed)
[10:22:09.034]                 for (kk in seq_along(NAMES)) {
[10:22:09.034]                   name <- removed[[kk]]
[10:22:09.034]                   NAME <- NAMES[[kk]]
[10:22:09.034]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:09.034]                     next
[10:22:09.034]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:09.034]                 }
[10:22:09.034]                 if (length(args) > 0) 
[10:22:09.034]                   base::do.call(base::Sys.setenv, args = args)
[10:22:09.034]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:09.034]             }
[10:22:09.034]             else {
[10:22:09.034]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:09.034]             }
[10:22:09.034]             {
[10:22:09.034]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:09.034]                   0L) {
[10:22:09.034]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:09.034]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:09.034]                   base::options(opts)
[10:22:09.034]                 }
[10:22:09.034]                 {
[10:22:09.034]                   {
[10:22:09.034]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:09.034]                     NULL
[10:22:09.034]                   }
[10:22:09.034]                   options(future.plan = NULL)
[10:22:09.034]                   if (is.na(NA_character_)) 
[10:22:09.034]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:09.034]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:09.034]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:09.034]                     .init = FALSE)
[10:22:09.034]                 }
[10:22:09.034]             }
[10:22:09.034]         }
[10:22:09.034]     })
[10:22:09.034]     if (TRUE) {
[10:22:09.034]         base::sink(type = "output", split = FALSE)
[10:22:09.034]         if (TRUE) {
[10:22:09.034]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:09.034]         }
[10:22:09.034]         else {
[10:22:09.034]             ...future.result["stdout"] <- base::list(NULL)
[10:22:09.034]         }
[10:22:09.034]         base::close(...future.stdout)
[10:22:09.034]         ...future.stdout <- NULL
[10:22:09.034]     }
[10:22:09.034]     ...future.result$conditions <- ...future.conditions
[10:22:09.034]     ...future.result$finished <- base::Sys.time()
[10:22:09.034]     ...future.result
[10:22:09.034] }
[10:22:09.087] MultisessionFuture started
[10:22:09.087] result() for ClusterFuture ...
[10:22:09.087] receiveMessageFromWorker() for ClusterFuture ...
[10:22:09.087] - Validating connection of MultisessionFuture
[10:22:09.136] - received message: FutureResult
[10:22:09.136] - Received FutureResult
[10:22:09.137] - Erased future from FutureRegistry
[10:22:09.137] result() for ClusterFuture ...
[10:22:09.137] - result already collected: FutureResult
[10:22:09.137] result() for ClusterFuture ... done
[10:22:09.137] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:09.137] result() for ClusterFuture ... done
[10:22:09.137] result() for ClusterFuture ...
[10:22:09.137] - result already collected: FutureResult
[10:22:09.137] result() for ClusterFuture ... done
[10:22:09.137] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:22:09.139] plan(): nbrOfWorkers() = 2
[10:22:09.139] getGlobalsAndPackages() ...
[10:22:09.139] Searching for globals...
[10:22:09.155] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[10:22:09.155] Searching for globals ... DONE
[10:22:09.155] Resolving globals: FALSE
[10:22:09.156] The total size of the 2 globals is 11.74 KiB (12021 bytes)
[10:22:09.159] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 11.74 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (11.69 KiB of class ‘list’) and ‘strategy2’ (48 bytes of class ‘character’)
[10:22:09.159] - globals: [2] ‘nested’, ‘strategy2’
[10:22:09.159] - packages: [1] ‘future’
[10:22:09.159] getGlobalsAndPackages() ... DONE
[10:22:09.159] run() for ‘Future’ ...
[10:22:09.159] - state: ‘created’
[10:22:09.160] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:09.173] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:09.174] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:09.174]   - Field: ‘node’
[10:22:09.174]   - Field: ‘label’
[10:22:09.174]   - Field: ‘local’
[10:22:09.174]   - Field: ‘owner’
[10:22:09.174]   - Field: ‘envir’
[10:22:09.174]   - Field: ‘workers’
[10:22:09.174]   - Field: ‘packages’
[10:22:09.174]   - Field: ‘gc’
[10:22:09.174]   - Field: ‘conditions’
[10:22:09.174]   - Field: ‘persistent’
[10:22:09.175]   - Field: ‘expr’
[10:22:09.175]   - Field: ‘uuid’
[10:22:09.175]   - Field: ‘seed’
[10:22:09.175]   - Field: ‘version’
[10:22:09.175]   - Field: ‘result’
[10:22:09.175]   - Field: ‘asynchronous’
[10:22:09.175]   - Field: ‘calls’
[10:22:09.175]   - Field: ‘globals’
[10:22:09.175]   - Field: ‘stdout’
[10:22:09.175]   - Field: ‘earlySignal’
[10:22:09.175]   - Field: ‘lazy’
[10:22:09.175]   - Field: ‘state’
[10:22:09.176] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:09.176] - Launch lazy future ...
[10:22:09.176] Packages needed by the future expression (n = 1): ‘future’
[10:22:09.176] Packages needed by future strategies (n = 1): ‘future’
[10:22:09.177] {
[10:22:09.177]     {
[10:22:09.177]         {
[10:22:09.177]             ...future.startTime <- base::Sys.time()
[10:22:09.177]             {
[10:22:09.177]                 {
[10:22:09.177]                   {
[10:22:09.177]                     {
[10:22:09.177]                       {
[10:22:09.177]                         base::local({
[10:22:09.177]                           has_future <- base::requireNamespace("future", 
[10:22:09.177]                             quietly = TRUE)
[10:22:09.177]                           if (has_future) {
[10:22:09.177]                             ns <- base::getNamespace("future")
[10:22:09.177]                             version <- ns[[".package"]][["version"]]
[10:22:09.177]                             if (is.null(version)) 
[10:22:09.177]                               version <- utils::packageVersion("future")
[10:22:09.177]                           }
[10:22:09.177]                           else {
[10:22:09.177]                             version <- NULL
[10:22:09.177]                           }
[10:22:09.177]                           if (!has_future || version < "1.8.0") {
[10:22:09.177]                             info <- base::c(r_version = base::gsub("R version ", 
[10:22:09.177]                               "", base::R.version$version.string), 
[10:22:09.177]                               platform = base::sprintf("%s (%s-bit)", 
[10:22:09.177]                                 base::R.version$platform, 8 * 
[10:22:09.177]                                   base::.Machine$sizeof.pointer), 
[10:22:09.177]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:09.177]                                 "release", "version")], collapse = " "), 
[10:22:09.177]                               hostname = base::Sys.info()[["nodename"]])
[10:22:09.177]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:22:09.177]                               info)
[10:22:09.177]                             info <- base::paste(info, collapse = "; ")
[10:22:09.177]                             if (!has_future) {
[10:22:09.177]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:09.177]                                 info)
[10:22:09.177]                             }
[10:22:09.177]                             else {
[10:22:09.177]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:09.177]                                 info, version)
[10:22:09.177]                             }
[10:22:09.177]                             base::stop(msg)
[10:22:09.177]                           }
[10:22:09.177]                         })
[10:22:09.177]                       }
[10:22:09.177]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:09.177]                       base::options(mc.cores = 1L)
[10:22:09.177]                     }
[10:22:09.177]                     base::local({
[10:22:09.177]                       for (pkg in "future") {
[10:22:09.177]                         base::loadNamespace(pkg)
[10:22:09.177]                         base::library(pkg, character.only = TRUE)
[10:22:09.177]                       }
[10:22:09.177]                     })
[10:22:09.177]                   }
[10:22:09.177]                   ...future.strategy.old <- future::plan("list")
[10:22:09.177]                   options(future.plan = NULL)
[10:22:09.177]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:09.177]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[10:22:09.177]                     envir = parent.frame()) 
[10:22:09.177]                   {
[10:22:09.177]                     default_workers <- missing(workers)
[10:22:09.177]                     if (is.function(workers)) 
[10:22:09.177]                       workers <- workers()
[10:22:09.177]                     workers <- structure(as.integer(workers), 
[10:22:09.177]                       class = class(workers))
[10:22:09.177]                     stop_if_not(is.finite(workers), workers >= 
[10:22:09.177]                       1L)
[10:22:09.177]                     if ((workers == 1L && !inherits(workers, 
[10:22:09.177]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:09.177]                       if (default_workers) 
[10:22:09.177]                         supportsMulticore(warn = TRUE)
[10:22:09.177]                       return(sequential(..., envir = envir))
[10:22:09.177]                     }
[10:22:09.177]                     oopts <- options(mc.cores = workers)
[10:22:09.177]                     on.exit(options(oopts))
[10:22:09.177]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:09.177]                       envir = envir)
[10:22:09.177]                     if (!future$lazy) 
[10:22:09.177]                       future <- run(future)
[10:22:09.177]                     invisible(future)
[10:22:09.177]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:09.177]                 }
[10:22:09.177]                 ...future.workdir <- getwd()
[10:22:09.177]             }
[10:22:09.177]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:09.177]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:09.177]         }
[10:22:09.177]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:09.177]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:09.177]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:09.177]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:09.177]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:09.177]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:09.177]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:09.177]             base::names(...future.oldOptions))
[10:22:09.177]     }
[10:22:09.177]     if (FALSE) {
[10:22:09.177]     }
[10:22:09.177]     else {
[10:22:09.177]         if (TRUE) {
[10:22:09.177]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:09.177]                 open = "w")
[10:22:09.177]         }
[10:22:09.177]         else {
[10:22:09.177]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:09.177]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:09.177]         }
[10:22:09.177]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:09.177]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:09.177]             base::sink(type = "output", split = FALSE)
[10:22:09.177]             base::close(...future.stdout)
[10:22:09.177]         }, add = TRUE)
[10:22:09.177]     }
[10:22:09.177]     ...future.frame <- base::sys.nframe()
[10:22:09.177]     ...future.conditions <- base::list()
[10:22:09.177]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:09.177]     if (FALSE) {
[10:22:09.177]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:09.177]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:09.177]     }
[10:22:09.177]     ...future.result <- base::tryCatch({
[10:22:09.177]         base::withCallingHandlers({
[10:22:09.177]             ...future.value <- base::withVisible(base::local({
[10:22:09.177]                 ...future.makeSendCondition <- base::local({
[10:22:09.177]                   sendCondition <- NULL
[10:22:09.177]                   function(frame = 1L) {
[10:22:09.177]                     if (is.function(sendCondition)) 
[10:22:09.177]                       return(sendCondition)
[10:22:09.177]                     ns <- getNamespace("parallel")
[10:22:09.177]                     if (exists("sendData", mode = "function", 
[10:22:09.177]                       envir = ns)) {
[10:22:09.177]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:09.177]                         envir = ns)
[10:22:09.177]                       envir <- sys.frame(frame)
[10:22:09.177]                       master <- NULL
[10:22:09.177]                       while (!identical(envir, .GlobalEnv) && 
[10:22:09.177]                         !identical(envir, emptyenv())) {
[10:22:09.177]                         if (exists("master", mode = "list", envir = envir, 
[10:22:09.177]                           inherits = FALSE)) {
[10:22:09.177]                           master <- get("master", mode = "list", 
[10:22:09.177]                             envir = envir, inherits = FALSE)
[10:22:09.177]                           if (inherits(master, c("SOCKnode", 
[10:22:09.177]                             "SOCK0node"))) {
[10:22:09.177]                             sendCondition <<- function(cond) {
[10:22:09.177]                               data <- list(type = "VALUE", value = cond, 
[10:22:09.177]                                 success = TRUE)
[10:22:09.177]                               parallel_sendData(master, data)
[10:22:09.177]                             }
[10:22:09.177]                             return(sendCondition)
[10:22:09.177]                           }
[10:22:09.177]                         }
[10:22:09.177]                         frame <- frame + 1L
[10:22:09.177]                         envir <- sys.frame(frame)
[10:22:09.177]                       }
[10:22:09.177]                     }
[10:22:09.177]                     sendCondition <<- function(cond) NULL
[10:22:09.177]                   }
[10:22:09.177]                 })
[10:22:09.177]                 withCallingHandlers({
[10:22:09.177]                   {
[10:22:09.177]                     a <- 1L
[10:22:09.177]                     plan_a <- unclass(future::plan("list"))
[10:22:09.177]                     nested_a <- nested[-1]
[10:22:09.177]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[10:22:09.177]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[10:22:09.177]                       strategy2))
[10:22:09.177]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[10:22:09.177]                       "init") <- NULL
[10:22:09.177]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[10:22:09.177]                       "init") <- NULL
[10:22:09.177]                     stopifnot(all.equal(plan_a, nested_a))
[10:22:09.177]                     y %<-% {
[10:22:09.177]                       b <- 2L
[10:22:09.177]                       plan_b <- future::plan("list")
[10:22:09.177]                       nested_b <- nested_a[-1]
[10:22:09.177]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:22:09.177]                         1L, inherits(plan_b[[1]], "future"), 
[10:22:09.177]                         inherits(future::plan("next"), "sequential"))
[10:22:09.177]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:22:09.177]                         b = b, nested_b = nested_b, plan_b = plan_b)
[10:22:09.177]                     }
[10:22:09.177]                     y
[10:22:09.177]                   }
[10:22:09.177]                 }, immediateCondition = function(cond) {
[10:22:09.177]                   sendCondition <- ...future.makeSendCondition()
[10:22:09.177]                   sendCondition(cond)
[10:22:09.177]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:09.177]                   {
[10:22:09.177]                     inherits <- base::inherits
[10:22:09.177]                     invokeRestart <- base::invokeRestart
[10:22:09.177]                     is.null <- base::is.null
[10:22:09.177]                     muffled <- FALSE
[10:22:09.177]                     if (inherits(cond, "message")) {
[10:22:09.177]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:09.177]                       if (muffled) 
[10:22:09.177]                         invokeRestart("muffleMessage")
[10:22:09.177]                     }
[10:22:09.177]                     else if (inherits(cond, "warning")) {
[10:22:09.177]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:09.177]                       if (muffled) 
[10:22:09.177]                         invokeRestart("muffleWarning")
[10:22:09.177]                     }
[10:22:09.177]                     else if (inherits(cond, "condition")) {
[10:22:09.177]                       if (!is.null(pattern)) {
[10:22:09.177]                         computeRestarts <- base::computeRestarts
[10:22:09.177]                         grepl <- base::grepl
[10:22:09.177]                         restarts <- computeRestarts(cond)
[10:22:09.177]                         for (restart in restarts) {
[10:22:09.177]                           name <- restart$name
[10:22:09.177]                           if (is.null(name)) 
[10:22:09.177]                             next
[10:22:09.177]                           if (!grepl(pattern, name)) 
[10:22:09.177]                             next
[10:22:09.177]                           invokeRestart(restart)
[10:22:09.177]                           muffled <- TRUE
[10:22:09.177]                           break
[10:22:09.177]                         }
[10:22:09.177]                       }
[10:22:09.177]                     }
[10:22:09.177]                     invisible(muffled)
[10:22:09.177]                   }
[10:22:09.177]                   muffleCondition(cond)
[10:22:09.177]                 })
[10:22:09.177]             }))
[10:22:09.177]             future::FutureResult(value = ...future.value$value, 
[10:22:09.177]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:09.177]                   ...future.rng), globalenv = if (FALSE) 
[10:22:09.177]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:09.177]                     ...future.globalenv.names))
[10:22:09.177]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:09.177]         }, condition = base::local({
[10:22:09.177]             c <- base::c
[10:22:09.177]             inherits <- base::inherits
[10:22:09.177]             invokeRestart <- base::invokeRestart
[10:22:09.177]             length <- base::length
[10:22:09.177]             list <- base::list
[10:22:09.177]             seq.int <- base::seq.int
[10:22:09.177]             signalCondition <- base::signalCondition
[10:22:09.177]             sys.calls <- base::sys.calls
[10:22:09.177]             `[[` <- base::`[[`
[10:22:09.177]             `+` <- base::`+`
[10:22:09.177]             `<<-` <- base::`<<-`
[10:22:09.177]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:09.177]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:09.177]                   3L)]
[10:22:09.177]             }
[10:22:09.177]             function(cond) {
[10:22:09.177]                 is_error <- inherits(cond, "error")
[10:22:09.177]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:09.177]                   NULL)
[10:22:09.177]                 if (is_error) {
[10:22:09.177]                   sessionInformation <- function() {
[10:22:09.177]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:09.177]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:09.177]                       search = base::search(), system = base::Sys.info())
[10:22:09.177]                   }
[10:22:09.177]                   ...future.conditions[[length(...future.conditions) + 
[10:22:09.177]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:09.177]                     cond$call), session = sessionInformation(), 
[10:22:09.177]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:09.177]                   signalCondition(cond)
[10:22:09.177]                 }
[10:22:09.177]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:09.177]                 "immediateCondition"))) {
[10:22:09.177]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:09.177]                   ...future.conditions[[length(...future.conditions) + 
[10:22:09.177]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:09.177]                   if (TRUE && !signal) {
[10:22:09.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:09.177]                     {
[10:22:09.177]                       inherits <- base::inherits
[10:22:09.177]                       invokeRestart <- base::invokeRestart
[10:22:09.177]                       is.null <- base::is.null
[10:22:09.177]                       muffled <- FALSE
[10:22:09.177]                       if (inherits(cond, "message")) {
[10:22:09.177]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:09.177]                         if (muffled) 
[10:22:09.177]                           invokeRestart("muffleMessage")
[10:22:09.177]                       }
[10:22:09.177]                       else if (inherits(cond, "warning")) {
[10:22:09.177]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:09.177]                         if (muffled) 
[10:22:09.177]                           invokeRestart("muffleWarning")
[10:22:09.177]                       }
[10:22:09.177]                       else if (inherits(cond, "condition")) {
[10:22:09.177]                         if (!is.null(pattern)) {
[10:22:09.177]                           computeRestarts <- base::computeRestarts
[10:22:09.177]                           grepl <- base::grepl
[10:22:09.177]                           restarts <- computeRestarts(cond)
[10:22:09.177]                           for (restart in restarts) {
[10:22:09.177]                             name <- restart$name
[10:22:09.177]                             if (is.null(name)) 
[10:22:09.177]                               next
[10:22:09.177]                             if (!grepl(pattern, name)) 
[10:22:09.177]                               next
[10:22:09.177]                             invokeRestart(restart)
[10:22:09.177]                             muffled <- TRUE
[10:22:09.177]                             break
[10:22:09.177]                           }
[10:22:09.177]                         }
[10:22:09.177]                       }
[10:22:09.177]                       invisible(muffled)
[10:22:09.177]                     }
[10:22:09.177]                     muffleCondition(cond, pattern = "^muffle")
[10:22:09.177]                   }
[10:22:09.177]                 }
[10:22:09.177]                 else {
[10:22:09.177]                   if (TRUE) {
[10:22:09.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:09.177]                     {
[10:22:09.177]                       inherits <- base::inherits
[10:22:09.177]                       invokeRestart <- base::invokeRestart
[10:22:09.177]                       is.null <- base::is.null
[10:22:09.177]                       muffled <- FALSE
[10:22:09.177]                       if (inherits(cond, "message")) {
[10:22:09.177]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:09.177]                         if (muffled) 
[10:22:09.177]                           invokeRestart("muffleMessage")
[10:22:09.177]                       }
[10:22:09.177]                       else if (inherits(cond, "warning")) {
[10:22:09.177]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:09.177]                         if (muffled) 
[10:22:09.177]                           invokeRestart("muffleWarning")
[10:22:09.177]                       }
[10:22:09.177]                       else if (inherits(cond, "condition")) {
[10:22:09.177]                         if (!is.null(pattern)) {
[10:22:09.177]                           computeRestarts <- base::computeRestarts
[10:22:09.177]                           grepl <- base::grepl
[10:22:09.177]                           restarts <- computeRestarts(cond)
[10:22:09.177]                           for (restart in restarts) {
[10:22:09.177]                             name <- restart$name
[10:22:09.177]                             if (is.null(name)) 
[10:22:09.177]                               next
[10:22:09.177]                             if (!grepl(pattern, name)) 
[10:22:09.177]                               next
[10:22:09.177]                             invokeRestart(restart)
[10:22:09.177]                             muffled <- TRUE
[10:22:09.177]                             break
[10:22:09.177]                           }
[10:22:09.177]                         }
[10:22:09.177]                       }
[10:22:09.177]                       invisible(muffled)
[10:22:09.177]                     }
[10:22:09.177]                     muffleCondition(cond, pattern = "^muffle")
[10:22:09.177]                   }
[10:22:09.177]                 }
[10:22:09.177]             }
[10:22:09.177]         }))
[10:22:09.177]     }, error = function(ex) {
[10:22:09.177]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:09.177]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:09.177]                 ...future.rng), started = ...future.startTime, 
[10:22:09.177]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:09.177]             version = "1.8"), class = "FutureResult")
[10:22:09.177]     }, finally = {
[10:22:09.177]         if (!identical(...future.workdir, getwd())) 
[10:22:09.177]             setwd(...future.workdir)
[10:22:09.177]         {
[10:22:09.177]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:09.177]                 ...future.oldOptions$nwarnings <- NULL
[10:22:09.177]             }
[10:22:09.177]             base::options(...future.oldOptions)
[10:22:09.177]             if (.Platform$OS.type == "windows") {
[10:22:09.177]                 old_names <- names(...future.oldEnvVars)
[10:22:09.177]                 envs <- base::Sys.getenv()
[10:22:09.177]                 names <- names(envs)
[10:22:09.177]                 common <- intersect(names, old_names)
[10:22:09.177]                 added <- setdiff(names, old_names)
[10:22:09.177]                 removed <- setdiff(old_names, names)
[10:22:09.177]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:09.177]                   envs[common]]
[10:22:09.177]                 NAMES <- toupper(changed)
[10:22:09.177]                 args <- list()
[10:22:09.177]                 for (kk in seq_along(NAMES)) {
[10:22:09.177]                   name <- changed[[kk]]
[10:22:09.177]                   NAME <- NAMES[[kk]]
[10:22:09.177]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:09.177]                     next
[10:22:09.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:09.177]                 }
[10:22:09.177]                 NAMES <- toupper(added)
[10:22:09.177]                 for (kk in seq_along(NAMES)) {
[10:22:09.177]                   name <- added[[kk]]
[10:22:09.177]                   NAME <- NAMES[[kk]]
[10:22:09.177]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:09.177]                     next
[10:22:09.177]                   args[[name]] <- ""
[10:22:09.177]                 }
[10:22:09.177]                 NAMES <- toupper(removed)
[10:22:09.177]                 for (kk in seq_along(NAMES)) {
[10:22:09.177]                   name <- removed[[kk]]
[10:22:09.177]                   NAME <- NAMES[[kk]]
[10:22:09.177]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:09.177]                     next
[10:22:09.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:09.177]                 }
[10:22:09.177]                 if (length(args) > 0) 
[10:22:09.177]                   base::do.call(base::Sys.setenv, args = args)
[10:22:09.177]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:09.177]             }
[10:22:09.177]             else {
[10:22:09.177]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:09.177]             }
[10:22:09.177]             {
[10:22:09.177]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:09.177]                   0L) {
[10:22:09.177]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:09.177]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:09.177]                   base::options(opts)
[10:22:09.177]                 }
[10:22:09.177]                 {
[10:22:09.177]                   {
[10:22:09.177]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:09.177]                     NULL
[10:22:09.177]                   }
[10:22:09.177]                   options(future.plan = NULL)
[10:22:09.177]                   if (is.na(NA_character_)) 
[10:22:09.177]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:09.177]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:09.177]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:09.177]                     .init = FALSE)
[10:22:09.177]                 }
[10:22:09.177]             }
[10:22:09.177]         }
[10:22:09.177]     })
[10:22:09.177]     if (TRUE) {
[10:22:09.177]         base::sink(type = "output", split = FALSE)
[10:22:09.177]         if (TRUE) {
[10:22:09.177]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:09.177]         }
[10:22:09.177]         else {
[10:22:09.177]             ...future.result["stdout"] <- base::list(NULL)
[10:22:09.177]         }
[10:22:09.177]         base::close(...future.stdout)
[10:22:09.177]         ...future.stdout <- NULL
[10:22:09.177]     }
[10:22:09.177]     ...future.result$conditions <- ...future.conditions
[10:22:09.177]     ...future.result$finished <- base::Sys.time()
[10:22:09.177]     ...future.result
[10:22:09.177] }
[10:22:09.180] Exporting 2 global objects (12.04 KiB) to cluster node #1 ...
[10:22:09.180] Exporting ‘nested’ (11.69 KiB) to cluster node #1 ...
[10:22:09.220] Exporting ‘nested’ (11.69 KiB) to cluster node #1 ... DONE
[10:22:09.220] Exporting ‘strategy2’ (48 bytes) to cluster node #1 ...
[10:22:09.221] Exporting ‘strategy2’ (48 bytes) to cluster node #1 ... DONE
[10:22:09.221] Exporting 2 global objects (12.04 KiB) to cluster node #1 ... DONE
[10:22:09.221] MultisessionFuture started
[10:22:09.222] - Launch lazy future ... done
[10:22:09.222] run() for ‘MultisessionFuture’ ... done
[10:22:09.222] result() for ClusterFuture ...
[10:22:09.222] receiveMessageFromWorker() for ClusterFuture ...
[10:22:09.222] - Validating connection of MultisessionFuture
[10:22:09.285] - received message: FutureResult
[10:22:09.285] - Received FutureResult
[10:22:09.285] - Erased future from FutureRegistry
[10:22:09.285] result() for ClusterFuture ...
[10:22:09.285] - result already collected: FutureResult
[10:22:09.286] result() for ClusterFuture ... done
[10:22:09.286] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:09.286] result() for ClusterFuture ... done
[10:22:09.286] result() for ClusterFuture ...
[10:22:09.286] - result already collected: FutureResult
[10:22:09.286] result() for ClusterFuture ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:22:09.291] getGlobalsAndPackages() ...
[10:22:09.291] Searching for globals...
[10:22:09.292] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[10:22:09.292] Searching for globals ... DONE
[10:22:09.292] Resolving globals: FALSE
[10:22:09.293] The total size of the 1 globals is 356 bytes (356 bytes)
[10:22:09.293] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[10:22:09.293] - globals: [1] ‘data’
[10:22:09.293] - packages: [1] ‘future’
[10:22:09.294] getGlobalsAndPackages() ... DONE
[10:22:09.294] run() for ‘Future’ ...
[10:22:09.294] - state: ‘created’
[10:22:09.294] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:09.310] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:09.310] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:09.310]   - Field: ‘node’
[10:22:09.310]   - Field: ‘label’
[10:22:09.310]   - Field: ‘local’
[10:22:09.310]   - Field: ‘owner’
[10:22:09.310]   - Field: ‘envir’
[10:22:09.311]   - Field: ‘workers’
[10:22:09.311]   - Field: ‘packages’
[10:22:09.311]   - Field: ‘gc’
[10:22:09.311]   - Field: ‘conditions’
[10:22:09.311]   - Field: ‘persistent’
[10:22:09.311]   - Field: ‘expr’
[10:22:09.311]   - Field: ‘uuid’
[10:22:09.311]   - Field: ‘seed’
[10:22:09.311]   - Field: ‘version’
[10:22:09.311]   - Field: ‘result’
[10:22:09.311]   - Field: ‘asynchronous’
[10:22:09.311]   - Field: ‘calls’
[10:22:09.312]   - Field: ‘globals’
[10:22:09.312]   - Field: ‘stdout’
[10:22:09.312]   - Field: ‘earlySignal’
[10:22:09.312]   - Field: ‘lazy’
[10:22:09.312]   - Field: ‘state’
[10:22:09.312] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:09.312] - Launch lazy future ...
[10:22:09.312] Packages needed by the future expression (n = 1): ‘future’
[10:22:09.313] Packages needed by future strategies (n = 1): ‘future’
[10:22:09.313] {
[10:22:09.313]     {
[10:22:09.313]         {
[10:22:09.313]             ...future.startTime <- base::Sys.time()
[10:22:09.313]             {
[10:22:09.313]                 {
[10:22:09.313]                   {
[10:22:09.313]                     {
[10:22:09.313]                       {
[10:22:09.313]                         base::local({
[10:22:09.313]                           has_future <- base::requireNamespace("future", 
[10:22:09.313]                             quietly = TRUE)
[10:22:09.313]                           if (has_future) {
[10:22:09.313]                             ns <- base::getNamespace("future")
[10:22:09.313]                             version <- ns[[".package"]][["version"]]
[10:22:09.313]                             if (is.null(version)) 
[10:22:09.313]                               version <- utils::packageVersion("future")
[10:22:09.313]                           }
[10:22:09.313]                           else {
[10:22:09.313]                             version <- NULL
[10:22:09.313]                           }
[10:22:09.313]                           if (!has_future || version < "1.8.0") {
[10:22:09.313]                             info <- base::c(r_version = base::gsub("R version ", 
[10:22:09.313]                               "", base::R.version$version.string), 
[10:22:09.313]                               platform = base::sprintf("%s (%s-bit)", 
[10:22:09.313]                                 base::R.version$platform, 8 * 
[10:22:09.313]                                   base::.Machine$sizeof.pointer), 
[10:22:09.313]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:09.313]                                 "release", "version")], collapse = " "), 
[10:22:09.313]                               hostname = base::Sys.info()[["nodename"]])
[10:22:09.313]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:22:09.313]                               info)
[10:22:09.313]                             info <- base::paste(info, collapse = "; ")
[10:22:09.313]                             if (!has_future) {
[10:22:09.313]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:09.313]                                 info)
[10:22:09.313]                             }
[10:22:09.313]                             else {
[10:22:09.313]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:09.313]                                 info, version)
[10:22:09.313]                             }
[10:22:09.313]                             base::stop(msg)
[10:22:09.313]                           }
[10:22:09.313]                         })
[10:22:09.313]                       }
[10:22:09.313]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:09.313]                       base::options(mc.cores = 1L)
[10:22:09.313]                     }
[10:22:09.313]                     base::local({
[10:22:09.313]                       for (pkg in "future") {
[10:22:09.313]                         base::loadNamespace(pkg)
[10:22:09.313]                         base::library(pkg, character.only = TRUE)
[10:22:09.313]                       }
[10:22:09.313]                     })
[10:22:09.313]                   }
[10:22:09.313]                   ...future.strategy.old <- future::plan("list")
[10:22:09.313]                   options(future.plan = NULL)
[10:22:09.313]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:09.313]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[10:22:09.313]                     envir = parent.frame()) 
[10:22:09.313]                   {
[10:22:09.313]                     default_workers <- missing(workers)
[10:22:09.313]                     if (is.function(workers)) 
[10:22:09.313]                       workers <- workers()
[10:22:09.313]                     workers <- structure(as.integer(workers), 
[10:22:09.313]                       class = class(workers))
[10:22:09.313]                     stop_if_not(is.finite(workers), workers >= 
[10:22:09.313]                       1L)
[10:22:09.313]                     if ((workers == 1L && !inherits(workers, 
[10:22:09.313]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[10:22:09.313]                       if (default_workers) 
[10:22:09.313]                         supportsMulticore(warn = TRUE)
[10:22:09.313]                       return(sequential(..., envir = envir))
[10:22:09.313]                     }
[10:22:09.313]                     oopts <- options(mc.cores = workers)
[10:22:09.313]                     on.exit(options(oopts))
[10:22:09.313]                     future <- MulticoreFuture(..., workers = workers, 
[10:22:09.313]                       envir = envir)
[10:22:09.313]                     if (!future$lazy) 
[10:22:09.313]                       future <- run(future)
[10:22:09.313]                     invisible(future)
[10:22:09.313]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:09.313]                 }
[10:22:09.313]                 ...future.workdir <- getwd()
[10:22:09.313]             }
[10:22:09.313]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:09.313]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:09.313]         }
[10:22:09.313]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:09.313]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:09.313]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:09.313]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:09.313]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:09.313]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:09.313]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:09.313]             base::names(...future.oldOptions))
[10:22:09.313]     }
[10:22:09.313]     if (FALSE) {
[10:22:09.313]     }
[10:22:09.313]     else {
[10:22:09.313]         if (TRUE) {
[10:22:09.313]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:09.313]                 open = "w")
[10:22:09.313]         }
[10:22:09.313]         else {
[10:22:09.313]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:09.313]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:09.313]         }
[10:22:09.313]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:09.313]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:09.313]             base::sink(type = "output", split = FALSE)
[10:22:09.313]             base::close(...future.stdout)
[10:22:09.313]         }, add = TRUE)
[10:22:09.313]     }
[10:22:09.313]     ...future.frame <- base::sys.nframe()
[10:22:09.313]     ...future.conditions <- base::list()
[10:22:09.313]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:09.313]     if (FALSE) {
[10:22:09.313]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:09.313]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:09.313]     }
[10:22:09.313]     ...future.result <- base::tryCatch({
[10:22:09.313]         base::withCallingHandlers({
[10:22:09.313]             ...future.value <- base::withVisible(base::local({
[10:22:09.313]                 ...future.makeSendCondition <- base::local({
[10:22:09.313]                   sendCondition <- NULL
[10:22:09.313]                   function(frame = 1L) {
[10:22:09.313]                     if (is.function(sendCondition)) 
[10:22:09.313]                       return(sendCondition)
[10:22:09.313]                     ns <- getNamespace("parallel")
[10:22:09.313]                     if (exists("sendData", mode = "function", 
[10:22:09.313]                       envir = ns)) {
[10:22:09.313]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:09.313]                         envir = ns)
[10:22:09.313]                       envir <- sys.frame(frame)
[10:22:09.313]                       master <- NULL
[10:22:09.313]                       while (!identical(envir, .GlobalEnv) && 
[10:22:09.313]                         !identical(envir, emptyenv())) {
[10:22:09.313]                         if (exists("master", mode = "list", envir = envir, 
[10:22:09.313]                           inherits = FALSE)) {
[10:22:09.313]                           master <- get("master", mode = "list", 
[10:22:09.313]                             envir = envir, inherits = FALSE)
[10:22:09.313]                           if (inherits(master, c("SOCKnode", 
[10:22:09.313]                             "SOCK0node"))) {
[10:22:09.313]                             sendCondition <<- function(cond) {
[10:22:09.313]                               data <- list(type = "VALUE", value = cond, 
[10:22:09.313]                                 success = TRUE)
[10:22:09.313]                               parallel_sendData(master, data)
[10:22:09.313]                             }
[10:22:09.313]                             return(sendCondition)
[10:22:09.313]                           }
[10:22:09.313]                         }
[10:22:09.313]                         frame <- frame + 1L
[10:22:09.313]                         envir <- sys.frame(frame)
[10:22:09.313]                       }
[10:22:09.313]                     }
[10:22:09.313]                     sendCondition <<- function(cond) NULL
[10:22:09.313]                   }
[10:22:09.313]                 })
[10:22:09.313]                 withCallingHandlers({
[10:22:09.313]                   {
[10:22:09.313]                     value(future(subset(data, a == 2)))
[10:22:09.313]                   }
[10:22:09.313]                 }, immediateCondition = function(cond) {
[10:22:09.313]                   sendCondition <- ...future.makeSendCondition()
[10:22:09.313]                   sendCondition(cond)
[10:22:09.313]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:09.313]                   {
[10:22:09.313]                     inherits <- base::inherits
[10:22:09.313]                     invokeRestart <- base::invokeRestart
[10:22:09.313]                     is.null <- base::is.null
[10:22:09.313]                     muffled <- FALSE
[10:22:09.313]                     if (inherits(cond, "message")) {
[10:22:09.313]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:09.313]                       if (muffled) 
[10:22:09.313]                         invokeRestart("muffleMessage")
[10:22:09.313]                     }
[10:22:09.313]                     else if (inherits(cond, "warning")) {
[10:22:09.313]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:09.313]                       if (muffled) 
[10:22:09.313]                         invokeRestart("muffleWarning")
[10:22:09.313]                     }
[10:22:09.313]                     else if (inherits(cond, "condition")) {
[10:22:09.313]                       if (!is.null(pattern)) {
[10:22:09.313]                         computeRestarts <- base::computeRestarts
[10:22:09.313]                         grepl <- base::grepl
[10:22:09.313]                         restarts <- computeRestarts(cond)
[10:22:09.313]                         for (restart in restarts) {
[10:22:09.313]                           name <- restart$name
[10:22:09.313]                           if (is.null(name)) 
[10:22:09.313]                             next
[10:22:09.313]                           if (!grepl(pattern, name)) 
[10:22:09.313]                             next
[10:22:09.313]                           invokeRestart(restart)
[10:22:09.313]                           muffled <- TRUE
[10:22:09.313]                           break
[10:22:09.313]                         }
[10:22:09.313]                       }
[10:22:09.313]                     }
[10:22:09.313]                     invisible(muffled)
[10:22:09.313]                   }
[10:22:09.313]                   muffleCondition(cond)
[10:22:09.313]                 })
[10:22:09.313]             }))
[10:22:09.313]             future::FutureResult(value = ...future.value$value, 
[10:22:09.313]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:09.313]                   ...future.rng), globalenv = if (FALSE) 
[10:22:09.313]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:09.313]                     ...future.globalenv.names))
[10:22:09.313]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:09.313]         }, condition = base::local({
[10:22:09.313]             c <- base::c
[10:22:09.313]             inherits <- base::inherits
[10:22:09.313]             invokeRestart <- base::invokeRestart
[10:22:09.313]             length <- base::length
[10:22:09.313]             list <- base::list
[10:22:09.313]             seq.int <- base::seq.int
[10:22:09.313]             signalCondition <- base::signalCondition
[10:22:09.313]             sys.calls <- base::sys.calls
[10:22:09.313]             `[[` <- base::`[[`
[10:22:09.313]             `+` <- base::`+`
[10:22:09.313]             `<<-` <- base::`<<-`
[10:22:09.313]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:09.313]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:09.313]                   3L)]
[10:22:09.313]             }
[10:22:09.313]             function(cond) {
[10:22:09.313]                 is_error <- inherits(cond, "error")
[10:22:09.313]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:09.313]                   NULL)
[10:22:09.313]                 if (is_error) {
[10:22:09.313]                   sessionInformation <- function() {
[10:22:09.313]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:09.313]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:09.313]                       search = base::search(), system = base::Sys.info())
[10:22:09.313]                   }
[10:22:09.313]                   ...future.conditions[[length(...future.conditions) + 
[10:22:09.313]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:09.313]                     cond$call), session = sessionInformation(), 
[10:22:09.313]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:09.313]                   signalCondition(cond)
[10:22:09.313]                 }
[10:22:09.313]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:09.313]                 "immediateCondition"))) {
[10:22:09.313]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:09.313]                   ...future.conditions[[length(...future.conditions) + 
[10:22:09.313]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:09.313]                   if (TRUE && !signal) {
[10:22:09.313]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:09.313]                     {
[10:22:09.313]                       inherits <- base::inherits
[10:22:09.313]                       invokeRestart <- base::invokeRestart
[10:22:09.313]                       is.null <- base::is.null
[10:22:09.313]                       muffled <- FALSE
[10:22:09.313]                       if (inherits(cond, "message")) {
[10:22:09.313]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:09.313]                         if (muffled) 
[10:22:09.313]                           invokeRestart("muffleMessage")
[10:22:09.313]                       }
[10:22:09.313]                       else if (inherits(cond, "warning")) {
[10:22:09.313]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:09.313]                         if (muffled) 
[10:22:09.313]                           invokeRestart("muffleWarning")
[10:22:09.313]                       }
[10:22:09.313]                       else if (inherits(cond, "condition")) {
[10:22:09.313]                         if (!is.null(pattern)) {
[10:22:09.313]                           computeRestarts <- base::computeRestarts
[10:22:09.313]                           grepl <- base::grepl
[10:22:09.313]                           restarts <- computeRestarts(cond)
[10:22:09.313]                           for (restart in restarts) {
[10:22:09.313]                             name <- restart$name
[10:22:09.313]                             if (is.null(name)) 
[10:22:09.313]                               next
[10:22:09.313]                             if (!grepl(pattern, name)) 
[10:22:09.313]                               next
[10:22:09.313]                             invokeRestart(restart)
[10:22:09.313]                             muffled <- TRUE
[10:22:09.313]                             break
[10:22:09.313]                           }
[10:22:09.313]                         }
[10:22:09.313]                       }
[10:22:09.313]                       invisible(muffled)
[10:22:09.313]                     }
[10:22:09.313]                     muffleCondition(cond, pattern = "^muffle")
[10:22:09.313]                   }
[10:22:09.313]                 }
[10:22:09.313]                 else {
[10:22:09.313]                   if (TRUE) {
[10:22:09.313]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:09.313]                     {
[10:22:09.313]                       inherits <- base::inherits
[10:22:09.313]                       invokeRestart <- base::invokeRestart
[10:22:09.313]                       is.null <- base::is.null
[10:22:09.313]                       muffled <- FALSE
[10:22:09.313]                       if (inherits(cond, "message")) {
[10:22:09.313]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:09.313]                         if (muffled) 
[10:22:09.313]                           invokeRestart("muffleMessage")
[10:22:09.313]                       }
[10:22:09.313]                       else if (inherits(cond, "warning")) {
[10:22:09.313]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:09.313]                         if (muffled) 
[10:22:09.313]                           invokeRestart("muffleWarning")
[10:22:09.313]                       }
[10:22:09.313]                       else if (inherits(cond, "condition")) {
[10:22:09.313]                         if (!is.null(pattern)) {
[10:22:09.313]                           computeRestarts <- base::computeRestarts
[10:22:09.313]                           grepl <- base::grepl
[10:22:09.313]                           restarts <- computeRestarts(cond)
[10:22:09.313]                           for (restart in restarts) {
[10:22:09.313]                             name <- restart$name
[10:22:09.313]                             if (is.null(name)) 
[10:22:09.313]                               next
[10:22:09.313]                             if (!grepl(pattern, name)) 
[10:22:09.313]                               next
[10:22:09.313]                             invokeRestart(restart)
[10:22:09.313]                             muffled <- TRUE
[10:22:09.313]                             break
[10:22:09.313]                           }
[10:22:09.313]                         }
[10:22:09.313]                       }
[10:22:09.313]                       invisible(muffled)
[10:22:09.313]                     }
[10:22:09.313]                     muffleCondition(cond, pattern = "^muffle")
[10:22:09.313]                   }
[10:22:09.313]                 }
[10:22:09.313]             }
[10:22:09.313]         }))
[10:22:09.313]     }, error = function(ex) {
[10:22:09.313]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:09.313]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:09.313]                 ...future.rng), started = ...future.startTime, 
[10:22:09.313]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:09.313]             version = "1.8"), class = "FutureResult")
[10:22:09.313]     }, finally = {
[10:22:09.313]         if (!identical(...future.workdir, getwd())) 
[10:22:09.313]             setwd(...future.workdir)
[10:22:09.313]         {
[10:22:09.313]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:09.313]                 ...future.oldOptions$nwarnings <- NULL
[10:22:09.313]             }
[10:22:09.313]             base::options(...future.oldOptions)
[10:22:09.313]             if (.Platform$OS.type == "windows") {
[10:22:09.313]                 old_names <- names(...future.oldEnvVars)
[10:22:09.313]                 envs <- base::Sys.getenv()
[10:22:09.313]                 names <- names(envs)
[10:22:09.313]                 common <- intersect(names, old_names)
[10:22:09.313]                 added <- setdiff(names, old_names)
[10:22:09.313]                 removed <- setdiff(old_names, names)
[10:22:09.313]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:09.313]                   envs[common]]
[10:22:09.313]                 NAMES <- toupper(changed)
[10:22:09.313]                 args <- list()
[10:22:09.313]                 for (kk in seq_along(NAMES)) {
[10:22:09.313]                   name <- changed[[kk]]
[10:22:09.313]                   NAME <- NAMES[[kk]]
[10:22:09.313]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:09.313]                     next
[10:22:09.313]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:09.313]                 }
[10:22:09.313]                 NAMES <- toupper(added)
[10:22:09.313]                 for (kk in seq_along(NAMES)) {
[10:22:09.313]                   name <- added[[kk]]
[10:22:09.313]                   NAME <- NAMES[[kk]]
[10:22:09.313]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:09.313]                     next
[10:22:09.313]                   args[[name]] <- ""
[10:22:09.313]                 }
[10:22:09.313]                 NAMES <- toupper(removed)
[10:22:09.313]                 for (kk in seq_along(NAMES)) {
[10:22:09.313]                   name <- removed[[kk]]
[10:22:09.313]                   NAME <- NAMES[[kk]]
[10:22:09.313]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:09.313]                     next
[10:22:09.313]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:09.313]                 }
[10:22:09.313]                 if (length(args) > 0) 
[10:22:09.313]                   base::do.call(base::Sys.setenv, args = args)
[10:22:09.313]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:09.313]             }
[10:22:09.313]             else {
[10:22:09.313]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:09.313]             }
[10:22:09.313]             {
[10:22:09.313]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:09.313]                   0L) {
[10:22:09.313]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:09.313]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:09.313]                   base::options(opts)
[10:22:09.313]                 }
[10:22:09.313]                 {
[10:22:09.313]                   {
[10:22:09.313]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:09.313]                     NULL
[10:22:09.313]                   }
[10:22:09.313]                   options(future.plan = NULL)
[10:22:09.313]                   if (is.na(NA_character_)) 
[10:22:09.313]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:09.313]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:09.313]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:09.313]                     .init = FALSE)
[10:22:09.313]                 }
[10:22:09.313]             }
[10:22:09.313]         }
[10:22:09.313]     })
[10:22:09.313]     if (TRUE) {
[10:22:09.313]         base::sink(type = "output", split = FALSE)
[10:22:09.313]         if (TRUE) {
[10:22:09.313]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:09.313]         }
[10:22:09.313]         else {
[10:22:09.313]             ...future.result["stdout"] <- base::list(NULL)
[10:22:09.313]         }
[10:22:09.313]         base::close(...future.stdout)
[10:22:09.313]         ...future.stdout <- NULL
[10:22:09.313]     }
[10:22:09.313]     ...future.result$conditions <- ...future.conditions
[10:22:09.313]     ...future.result$finished <- base::Sys.time()
[10:22:09.313]     ...future.result
[10:22:09.313] }
[10:22:09.316] Exporting 1 global objects (643 bytes) to cluster node #1 ...
[10:22:09.316] Exporting ‘data’ (356 bytes) to cluster node #1 ...
[10:22:09.316] Exporting ‘data’ (356 bytes) to cluster node #1 ... DONE
[10:22:09.316] Exporting 1 global objects (643 bytes) to cluster node #1 ... DONE
[10:22:09.317] MultisessionFuture started
[10:22:09.317] - Launch lazy future ... done
[10:22:09.317] run() for ‘MultisessionFuture’ ... done
[10:22:09.317] result() for ClusterFuture ...
[10:22:09.317] receiveMessageFromWorker() for ClusterFuture ...
[10:22:09.317] - Validating connection of MultisessionFuture
[10:22:09.366] - received message: FutureResult
[10:22:09.367] - Received FutureResult
[10:22:09.367] - Erased future from FutureRegistry
[10:22:09.367] result() for ClusterFuture ...
[10:22:09.367] - result already collected: FutureResult
[10:22:09.367] result() for ClusterFuture ... done
[10:22:09.367] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:09.367] result() for ClusterFuture ... done
[10:22:09.367] result() for ClusterFuture ...
[10:22:09.367] - result already collected: FutureResult
[10:22:09.368] result() for ClusterFuture ... done
- plan(list('multisession', 'multicore')) ... DONE
- plan(list('multisession', 'multisession')) ...
[10:22:09.368] plan(): Setting new future strategy stack:
[10:22:09.368] List of future strategies:
[10:22:09.368] 1. multisession:
[10:22:09.368]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:22:09.368]    - tweaked: FALSE
[10:22:09.368]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:09.368] 2. multisession:
[10:22:09.368]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:22:09.368]    - tweaked: FALSE
[10:22:09.368]    - call: plan(list(a = strategy1, b = strategy2))
[10:22:09.369] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:22:09.369] multisession:
[10:22:09.369] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:22:09.369] - tweaked: FALSE
[10:22:09.369] - call: plan(list(a = strategy1, b = strategy2))
[10:22:09.372] getGlobalsAndPackages() ...
[10:22:09.372] Not searching for globals
[10:22:09.372] - globals: [0] <none>
[10:22:09.372] getGlobalsAndPackages() ... DONE
[10:22:09.638] Packages needed by the future expression (n = 0): <none>
[10:22:09.638] Packages needed by future strategies (n = 1): ‘future’
[10:22:09.639] {
[10:22:09.639]     {
[10:22:09.639]         {
[10:22:09.639]             ...future.startTime <- base::Sys.time()
[10:22:09.639]             {
[10:22:09.639]                 {
[10:22:09.639]                   {
[10:22:09.639]                     {
[10:22:09.639]                       {
[10:22:09.639]                         base::local({
[10:22:09.639]                           has_future <- base::requireNamespace("future", 
[10:22:09.639]                             quietly = TRUE)
[10:22:09.639]                           if (has_future) {
[10:22:09.639]                             ns <- base::getNamespace("future")
[10:22:09.639]                             version <- ns[[".package"]][["version"]]
[10:22:09.639]                             if (is.null(version)) 
[10:22:09.639]                               version <- utils::packageVersion("future")
[10:22:09.639]                           }
[10:22:09.639]                           else {
[10:22:09.639]                             version <- NULL
[10:22:09.639]                           }
[10:22:09.639]                           if (!has_future || version < "1.8.0") {
[10:22:09.639]                             info <- base::c(r_version = base::gsub("R version ", 
[10:22:09.639]                               "", base::R.version$version.string), 
[10:22:09.639]                               platform = base::sprintf("%s (%s-bit)", 
[10:22:09.639]                                 base::R.version$platform, 8 * 
[10:22:09.639]                                   base::.Machine$sizeof.pointer), 
[10:22:09.639]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:09.639]                                 "release", "version")], collapse = " "), 
[10:22:09.639]                               hostname = base::Sys.info()[["nodename"]])
[10:22:09.639]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:22:09.639]                               info)
[10:22:09.639]                             info <- base::paste(info, collapse = "; ")
[10:22:09.639]                             if (!has_future) {
[10:22:09.639]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:09.639]                                 info)
[10:22:09.639]                             }
[10:22:09.639]                             else {
[10:22:09.639]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:09.639]                                 info, version)
[10:22:09.639]                             }
[10:22:09.639]                             base::stop(msg)
[10:22:09.639]                           }
[10:22:09.639]                         })
[10:22:09.639]                       }
[10:22:09.639]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:09.639]                       base::options(mc.cores = 1L)
[10:22:09.639]                     }
[10:22:09.639]                     base::local({
[10:22:09.639]                       for (pkg in "future") {
[10:22:09.639]                         base::loadNamespace(pkg)
[10:22:09.639]                         base::library(pkg, character.only = TRUE)
[10:22:09.639]                       }
[10:22:09.639]                     })
[10:22:09.639]                   }
[10:22:09.639]                   ...future.strategy.old <- future::plan("list")
[10:22:09.639]                   options(future.plan = NULL)
[10:22:09.639]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:09.639]                   future::plan(list(b = function (..., workers = availableCores(), 
[10:22:09.639]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:09.639]                     envir = parent.frame()) 
[10:22:09.639]                   {
[10:22:09.639]                     if (is.function(workers)) 
[10:22:09.639]                       workers <- workers()
[10:22:09.639]                     workers <- structure(as.integer(workers), 
[10:22:09.639]                       class = class(workers))
[10:22:09.639]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:09.639]                       workers >= 1)
[10:22:09.639]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:09.639]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:09.639]                     }
[10:22:09.639]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:09.639]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:09.639]                       envir = envir)
[10:22:09.639]                     if (!future$lazy) 
[10:22:09.639]                       future <- run(future)
[10:22:09.639]                     invisible(future)
[10:22:09.639]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:09.639]                 }
[10:22:09.639]                 ...future.workdir <- getwd()
[10:22:09.639]             }
[10:22:09.639]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:09.639]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:09.639]         }
[10:22:09.639]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:09.639]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:09.639]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:09.639]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:09.639]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:09.639]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:09.639]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:09.639]             base::names(...future.oldOptions))
[10:22:09.639]     }
[10:22:09.639]     if (FALSE) {
[10:22:09.639]     }
[10:22:09.639]     else {
[10:22:09.639]         if (TRUE) {
[10:22:09.639]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:09.639]                 open = "w")
[10:22:09.639]         }
[10:22:09.639]         else {
[10:22:09.639]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:09.639]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:09.639]         }
[10:22:09.639]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:09.639]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:09.639]             base::sink(type = "output", split = FALSE)
[10:22:09.639]             base::close(...future.stdout)
[10:22:09.639]         }, add = TRUE)
[10:22:09.639]     }
[10:22:09.639]     ...future.frame <- base::sys.nframe()
[10:22:09.639]     ...future.conditions <- base::list()
[10:22:09.639]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:09.639]     if (FALSE) {
[10:22:09.639]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:09.639]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:09.639]     }
[10:22:09.639]     ...future.result <- base::tryCatch({
[10:22:09.639]         base::withCallingHandlers({
[10:22:09.639]             ...future.value <- base::withVisible(base::local({
[10:22:09.639]                 ...future.makeSendCondition <- base::local({
[10:22:09.639]                   sendCondition <- NULL
[10:22:09.639]                   function(frame = 1L) {
[10:22:09.639]                     if (is.function(sendCondition)) 
[10:22:09.639]                       return(sendCondition)
[10:22:09.639]                     ns <- getNamespace("parallel")
[10:22:09.639]                     if (exists("sendData", mode = "function", 
[10:22:09.639]                       envir = ns)) {
[10:22:09.639]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:09.639]                         envir = ns)
[10:22:09.639]                       envir <- sys.frame(frame)
[10:22:09.639]                       master <- NULL
[10:22:09.639]                       while (!identical(envir, .GlobalEnv) && 
[10:22:09.639]                         !identical(envir, emptyenv())) {
[10:22:09.639]                         if (exists("master", mode = "list", envir = envir, 
[10:22:09.639]                           inherits = FALSE)) {
[10:22:09.639]                           master <- get("master", mode = "list", 
[10:22:09.639]                             envir = envir, inherits = FALSE)
[10:22:09.639]                           if (inherits(master, c("SOCKnode", 
[10:22:09.639]                             "SOCK0node"))) {
[10:22:09.639]                             sendCondition <<- function(cond) {
[10:22:09.639]                               data <- list(type = "VALUE", value = cond, 
[10:22:09.639]                                 success = TRUE)
[10:22:09.639]                               parallel_sendData(master, data)
[10:22:09.639]                             }
[10:22:09.639]                             return(sendCondition)
[10:22:09.639]                           }
[10:22:09.639]                         }
[10:22:09.639]                         frame <- frame + 1L
[10:22:09.639]                         envir <- sys.frame(frame)
[10:22:09.639]                       }
[10:22:09.639]                     }
[10:22:09.639]                     sendCondition <<- function(cond) NULL
[10:22:09.639]                   }
[10:22:09.639]                 })
[10:22:09.639]                 withCallingHandlers({
[10:22:09.639]                   NA
[10:22:09.639]                 }, immediateCondition = function(cond) {
[10:22:09.639]                   sendCondition <- ...future.makeSendCondition()
[10:22:09.639]                   sendCondition(cond)
[10:22:09.639]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:09.639]                   {
[10:22:09.639]                     inherits <- base::inherits
[10:22:09.639]                     invokeRestart <- base::invokeRestart
[10:22:09.639]                     is.null <- base::is.null
[10:22:09.639]                     muffled <- FALSE
[10:22:09.639]                     if (inherits(cond, "message")) {
[10:22:09.639]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:09.639]                       if (muffled) 
[10:22:09.639]                         invokeRestart("muffleMessage")
[10:22:09.639]                     }
[10:22:09.639]                     else if (inherits(cond, "warning")) {
[10:22:09.639]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:09.639]                       if (muffled) 
[10:22:09.639]                         invokeRestart("muffleWarning")
[10:22:09.639]                     }
[10:22:09.639]                     else if (inherits(cond, "condition")) {
[10:22:09.639]                       if (!is.null(pattern)) {
[10:22:09.639]                         computeRestarts <- base::computeRestarts
[10:22:09.639]                         grepl <- base::grepl
[10:22:09.639]                         restarts <- computeRestarts(cond)
[10:22:09.639]                         for (restart in restarts) {
[10:22:09.639]                           name <- restart$name
[10:22:09.639]                           if (is.null(name)) 
[10:22:09.639]                             next
[10:22:09.639]                           if (!grepl(pattern, name)) 
[10:22:09.639]                             next
[10:22:09.639]                           invokeRestart(restart)
[10:22:09.639]                           muffled <- TRUE
[10:22:09.639]                           break
[10:22:09.639]                         }
[10:22:09.639]                       }
[10:22:09.639]                     }
[10:22:09.639]                     invisible(muffled)
[10:22:09.639]                   }
[10:22:09.639]                   muffleCondition(cond)
[10:22:09.639]                 })
[10:22:09.639]             }))
[10:22:09.639]             future::FutureResult(value = ...future.value$value, 
[10:22:09.639]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:09.639]                   ...future.rng), globalenv = if (FALSE) 
[10:22:09.639]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:09.639]                     ...future.globalenv.names))
[10:22:09.639]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:09.639]         }, condition = base::local({
[10:22:09.639]             c <- base::c
[10:22:09.639]             inherits <- base::inherits
[10:22:09.639]             invokeRestart <- base::invokeRestart
[10:22:09.639]             length <- base::length
[10:22:09.639]             list <- base::list
[10:22:09.639]             seq.int <- base::seq.int
[10:22:09.639]             signalCondition <- base::signalCondition
[10:22:09.639]             sys.calls <- base::sys.calls
[10:22:09.639]             `[[` <- base::`[[`
[10:22:09.639]             `+` <- base::`+`
[10:22:09.639]             `<<-` <- base::`<<-`
[10:22:09.639]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:09.639]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:09.639]                   3L)]
[10:22:09.639]             }
[10:22:09.639]             function(cond) {
[10:22:09.639]                 is_error <- inherits(cond, "error")
[10:22:09.639]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:09.639]                   NULL)
[10:22:09.639]                 if (is_error) {
[10:22:09.639]                   sessionInformation <- function() {
[10:22:09.639]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:09.639]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:09.639]                       search = base::search(), system = base::Sys.info())
[10:22:09.639]                   }
[10:22:09.639]                   ...future.conditions[[length(...future.conditions) + 
[10:22:09.639]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:09.639]                     cond$call), session = sessionInformation(), 
[10:22:09.639]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:09.639]                   signalCondition(cond)
[10:22:09.639]                 }
[10:22:09.639]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:09.639]                 "immediateCondition"))) {
[10:22:09.639]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:09.639]                   ...future.conditions[[length(...future.conditions) + 
[10:22:09.639]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:09.639]                   if (TRUE && !signal) {
[10:22:09.639]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:09.639]                     {
[10:22:09.639]                       inherits <- base::inherits
[10:22:09.639]                       invokeRestart <- base::invokeRestart
[10:22:09.639]                       is.null <- base::is.null
[10:22:09.639]                       muffled <- FALSE
[10:22:09.639]                       if (inherits(cond, "message")) {
[10:22:09.639]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:09.639]                         if (muffled) 
[10:22:09.639]                           invokeRestart("muffleMessage")
[10:22:09.639]                       }
[10:22:09.639]                       else if (inherits(cond, "warning")) {
[10:22:09.639]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:09.639]                         if (muffled) 
[10:22:09.639]                           invokeRestart("muffleWarning")
[10:22:09.639]                       }
[10:22:09.639]                       else if (inherits(cond, "condition")) {
[10:22:09.639]                         if (!is.null(pattern)) {
[10:22:09.639]                           computeRestarts <- base::computeRestarts
[10:22:09.639]                           grepl <- base::grepl
[10:22:09.639]                           restarts <- computeRestarts(cond)
[10:22:09.639]                           for (restart in restarts) {
[10:22:09.639]                             name <- restart$name
[10:22:09.639]                             if (is.null(name)) 
[10:22:09.639]                               next
[10:22:09.639]                             if (!grepl(pattern, name)) 
[10:22:09.639]                               next
[10:22:09.639]                             invokeRestart(restart)
[10:22:09.639]                             muffled <- TRUE
[10:22:09.639]                             break
[10:22:09.639]                           }
[10:22:09.639]                         }
[10:22:09.639]                       }
[10:22:09.639]                       invisible(muffled)
[10:22:09.639]                     }
[10:22:09.639]                     muffleCondition(cond, pattern = "^muffle")
[10:22:09.639]                   }
[10:22:09.639]                 }
[10:22:09.639]                 else {
[10:22:09.639]                   if (TRUE) {
[10:22:09.639]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:09.639]                     {
[10:22:09.639]                       inherits <- base::inherits
[10:22:09.639]                       invokeRestart <- base::invokeRestart
[10:22:09.639]                       is.null <- base::is.null
[10:22:09.639]                       muffled <- FALSE
[10:22:09.639]                       if (inherits(cond, "message")) {
[10:22:09.639]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:09.639]                         if (muffled) 
[10:22:09.639]                           invokeRestart("muffleMessage")
[10:22:09.639]                       }
[10:22:09.639]                       else if (inherits(cond, "warning")) {
[10:22:09.639]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:09.639]                         if (muffled) 
[10:22:09.639]                           invokeRestart("muffleWarning")
[10:22:09.639]                       }
[10:22:09.639]                       else if (inherits(cond, "condition")) {
[10:22:09.639]                         if (!is.null(pattern)) {
[10:22:09.639]                           computeRestarts <- base::computeRestarts
[10:22:09.639]                           grepl <- base::grepl
[10:22:09.639]                           restarts <- computeRestarts(cond)
[10:22:09.639]                           for (restart in restarts) {
[10:22:09.639]                             name <- restart$name
[10:22:09.639]                             if (is.null(name)) 
[10:22:09.639]                               next
[10:22:09.639]                             if (!grepl(pattern, name)) 
[10:22:09.639]                               next
[10:22:09.639]                             invokeRestart(restart)
[10:22:09.639]                             muffled <- TRUE
[10:22:09.639]                             break
[10:22:09.639]                           }
[10:22:09.639]                         }
[10:22:09.639]                       }
[10:22:09.639]                       invisible(muffled)
[10:22:09.639]                     }
[10:22:09.639]                     muffleCondition(cond, pattern = "^muffle")
[10:22:09.639]                   }
[10:22:09.639]                 }
[10:22:09.639]             }
[10:22:09.639]         }))
[10:22:09.639]     }, error = function(ex) {
[10:22:09.639]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:09.639]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:09.639]                 ...future.rng), started = ...future.startTime, 
[10:22:09.639]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:09.639]             version = "1.8"), class = "FutureResult")
[10:22:09.639]     }, finally = {
[10:22:09.639]         if (!identical(...future.workdir, getwd())) 
[10:22:09.639]             setwd(...future.workdir)
[10:22:09.639]         {
[10:22:09.639]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:09.639]                 ...future.oldOptions$nwarnings <- NULL
[10:22:09.639]             }
[10:22:09.639]             base::options(...future.oldOptions)
[10:22:09.639]             if (.Platform$OS.type == "windows") {
[10:22:09.639]                 old_names <- names(...future.oldEnvVars)
[10:22:09.639]                 envs <- base::Sys.getenv()
[10:22:09.639]                 names <- names(envs)
[10:22:09.639]                 common <- intersect(names, old_names)
[10:22:09.639]                 added <- setdiff(names, old_names)
[10:22:09.639]                 removed <- setdiff(old_names, names)
[10:22:09.639]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:09.639]                   envs[common]]
[10:22:09.639]                 NAMES <- toupper(changed)
[10:22:09.639]                 args <- list()
[10:22:09.639]                 for (kk in seq_along(NAMES)) {
[10:22:09.639]                   name <- changed[[kk]]
[10:22:09.639]                   NAME <- NAMES[[kk]]
[10:22:09.639]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:09.639]                     next
[10:22:09.639]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:09.639]                 }
[10:22:09.639]                 NAMES <- toupper(added)
[10:22:09.639]                 for (kk in seq_along(NAMES)) {
[10:22:09.639]                   name <- added[[kk]]
[10:22:09.639]                   NAME <- NAMES[[kk]]
[10:22:09.639]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:09.639]                     next
[10:22:09.639]                   args[[name]] <- ""
[10:22:09.639]                 }
[10:22:09.639]                 NAMES <- toupper(removed)
[10:22:09.639]                 for (kk in seq_along(NAMES)) {
[10:22:09.639]                   name <- removed[[kk]]
[10:22:09.639]                   NAME <- NAMES[[kk]]
[10:22:09.639]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:09.639]                     next
[10:22:09.639]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:09.639]                 }
[10:22:09.639]                 if (length(args) > 0) 
[10:22:09.639]                   base::do.call(base::Sys.setenv, args = args)
[10:22:09.639]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:09.639]             }
[10:22:09.639]             else {
[10:22:09.639]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:09.639]             }
[10:22:09.639]             {
[10:22:09.639]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:09.639]                   0L) {
[10:22:09.639]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:09.639]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:09.639]                   base::options(opts)
[10:22:09.639]                 }
[10:22:09.639]                 {
[10:22:09.639]                   {
[10:22:09.639]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:09.639]                     NULL
[10:22:09.639]                   }
[10:22:09.639]                   options(future.plan = NULL)
[10:22:09.639]                   if (is.na(NA_character_)) 
[10:22:09.639]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:09.639]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:09.639]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:09.639]                     .init = FALSE)
[10:22:09.639]                 }
[10:22:09.639]             }
[10:22:09.639]         }
[10:22:09.639]     })
[10:22:09.639]     if (TRUE) {
[10:22:09.639]         base::sink(type = "output", split = FALSE)
[10:22:09.639]         if (TRUE) {
[10:22:09.639]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:09.639]         }
[10:22:09.639]         else {
[10:22:09.639]             ...future.result["stdout"] <- base::list(NULL)
[10:22:09.639]         }
[10:22:09.639]         base::close(...future.stdout)
[10:22:09.639]         ...future.stdout <- NULL
[10:22:09.639]     }
[10:22:09.639]     ...future.result$conditions <- ...future.conditions
[10:22:09.639]     ...future.result$finished <- base::Sys.time()
[10:22:09.639]     ...future.result
[10:22:09.639] }
[10:22:09.691] MultisessionFuture started
[10:22:09.691] result() for ClusterFuture ...
[10:22:09.691] receiveMessageFromWorker() for ClusterFuture ...
[10:22:09.692] - Validating connection of MultisessionFuture
[10:22:09.741] - received message: FutureResult
[10:22:09.741] - Received FutureResult
[10:22:09.741] - Erased future from FutureRegistry
[10:22:09.741] result() for ClusterFuture ...
[10:22:09.741] - result already collected: FutureResult
[10:22:09.741] result() for ClusterFuture ... done
[10:22:09.741] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:09.742] result() for ClusterFuture ... done
[10:22:09.742] result() for ClusterFuture ...
[10:22:09.742] - result already collected: FutureResult
[10:22:09.742] result() for ClusterFuture ... done
[10:22:09.742] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:22:09.743] plan(): nbrOfWorkers() = 2
[10:22:09.744] getGlobalsAndPackages() ...
[10:22:09.744] Searching for globals...
[10:22:09.759] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[10:22:09.760] Searching for globals ... DONE
[10:22:09.760] Resolving globals: FALSE
[10:22:09.761] The total size of the 2 globals is 11.25 KiB (11520 bytes)
[10:22:09.761] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 11.25 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (11.20 KiB of class ‘list’) and ‘strategy2’ (51 bytes of class ‘character’)
[10:22:09.761] - globals: [2] ‘nested’, ‘strategy2’
[10:22:09.761] - packages: [1] ‘future’
[10:22:09.762] getGlobalsAndPackages() ... DONE
[10:22:09.762] run() for ‘Future’ ...
[10:22:09.762] - state: ‘created’
[10:22:09.762] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:09.776] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:09.776] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:09.776]   - Field: ‘node’
[10:22:09.776]   - Field: ‘label’
[10:22:09.777]   - Field: ‘local’
[10:22:09.777]   - Field: ‘owner’
[10:22:09.777]   - Field: ‘envir’
[10:22:09.777]   - Field: ‘workers’
[10:22:09.777]   - Field: ‘packages’
[10:22:09.777]   - Field: ‘gc’
[10:22:09.777]   - Field: ‘conditions’
[10:22:09.777]   - Field: ‘persistent’
[10:22:09.777]   - Field: ‘expr’
[10:22:09.780]   - Field: ‘uuid’
[10:22:09.780]   - Field: ‘seed’
[10:22:09.780]   - Field: ‘version’
[10:22:09.780]   - Field: ‘result’
[10:22:09.780]   - Field: ‘asynchronous’
[10:22:09.780]   - Field: ‘calls’
[10:22:09.780]   - Field: ‘globals’
[10:22:09.780]   - Field: ‘stdout’
[10:22:09.780]   - Field: ‘earlySignal’
[10:22:09.780]   - Field: ‘lazy’
[10:22:09.780]   - Field: ‘state’
[10:22:09.781] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:09.781] - Launch lazy future ...
[10:22:09.781] Packages needed by the future expression (n = 1): ‘future’
[10:22:09.781] Packages needed by future strategies (n = 1): ‘future’
[10:22:09.782] {
[10:22:09.782]     {
[10:22:09.782]         {
[10:22:09.782]             ...future.startTime <- base::Sys.time()
[10:22:09.782]             {
[10:22:09.782]                 {
[10:22:09.782]                   {
[10:22:09.782]                     {
[10:22:09.782]                       {
[10:22:09.782]                         base::local({
[10:22:09.782]                           has_future <- base::requireNamespace("future", 
[10:22:09.782]                             quietly = TRUE)
[10:22:09.782]                           if (has_future) {
[10:22:09.782]                             ns <- base::getNamespace("future")
[10:22:09.782]                             version <- ns[[".package"]][["version"]]
[10:22:09.782]                             if (is.null(version)) 
[10:22:09.782]                               version <- utils::packageVersion("future")
[10:22:09.782]                           }
[10:22:09.782]                           else {
[10:22:09.782]                             version <- NULL
[10:22:09.782]                           }
[10:22:09.782]                           if (!has_future || version < "1.8.0") {
[10:22:09.782]                             info <- base::c(r_version = base::gsub("R version ", 
[10:22:09.782]                               "", base::R.version$version.string), 
[10:22:09.782]                               platform = base::sprintf("%s (%s-bit)", 
[10:22:09.782]                                 base::R.version$platform, 8 * 
[10:22:09.782]                                   base::.Machine$sizeof.pointer), 
[10:22:09.782]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:09.782]                                 "release", "version")], collapse = " "), 
[10:22:09.782]                               hostname = base::Sys.info()[["nodename"]])
[10:22:09.782]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:22:09.782]                               info)
[10:22:09.782]                             info <- base::paste(info, collapse = "; ")
[10:22:09.782]                             if (!has_future) {
[10:22:09.782]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:09.782]                                 info)
[10:22:09.782]                             }
[10:22:09.782]                             else {
[10:22:09.782]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:09.782]                                 info, version)
[10:22:09.782]                             }
[10:22:09.782]                             base::stop(msg)
[10:22:09.782]                           }
[10:22:09.782]                         })
[10:22:09.782]                       }
[10:22:09.782]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:09.782]                       base::options(mc.cores = 1L)
[10:22:09.782]                     }
[10:22:09.782]                     base::local({
[10:22:09.782]                       for (pkg in "future") {
[10:22:09.782]                         base::loadNamespace(pkg)
[10:22:09.782]                         base::library(pkg, character.only = TRUE)
[10:22:09.782]                       }
[10:22:09.782]                     })
[10:22:09.782]                   }
[10:22:09.782]                   ...future.strategy.old <- future::plan("list")
[10:22:09.782]                   options(future.plan = NULL)
[10:22:09.782]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:09.782]                   future::plan(list(b = function (..., workers = availableCores(), 
[10:22:09.782]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:09.782]                     envir = parent.frame()) 
[10:22:09.782]                   {
[10:22:09.782]                     if (is.function(workers)) 
[10:22:09.782]                       workers <- workers()
[10:22:09.782]                     workers <- structure(as.integer(workers), 
[10:22:09.782]                       class = class(workers))
[10:22:09.782]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:09.782]                       workers >= 1)
[10:22:09.782]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:09.782]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:09.782]                     }
[10:22:09.782]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:09.782]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:09.782]                       envir = envir)
[10:22:09.782]                     if (!future$lazy) 
[10:22:09.782]                       future <- run(future)
[10:22:09.782]                     invisible(future)
[10:22:09.782]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:09.782]                 }
[10:22:09.782]                 ...future.workdir <- getwd()
[10:22:09.782]             }
[10:22:09.782]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:09.782]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:09.782]         }
[10:22:09.782]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:09.782]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:09.782]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:09.782]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:09.782]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:09.782]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:09.782]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:09.782]             base::names(...future.oldOptions))
[10:22:09.782]     }
[10:22:09.782]     if (FALSE) {
[10:22:09.782]     }
[10:22:09.782]     else {
[10:22:09.782]         if (TRUE) {
[10:22:09.782]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:09.782]                 open = "w")
[10:22:09.782]         }
[10:22:09.782]         else {
[10:22:09.782]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:09.782]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:09.782]         }
[10:22:09.782]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:09.782]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:09.782]             base::sink(type = "output", split = FALSE)
[10:22:09.782]             base::close(...future.stdout)
[10:22:09.782]         }, add = TRUE)
[10:22:09.782]     }
[10:22:09.782]     ...future.frame <- base::sys.nframe()
[10:22:09.782]     ...future.conditions <- base::list()
[10:22:09.782]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:09.782]     if (FALSE) {
[10:22:09.782]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:09.782]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:09.782]     }
[10:22:09.782]     ...future.result <- base::tryCatch({
[10:22:09.782]         base::withCallingHandlers({
[10:22:09.782]             ...future.value <- base::withVisible(base::local({
[10:22:09.782]                 ...future.makeSendCondition <- base::local({
[10:22:09.782]                   sendCondition <- NULL
[10:22:09.782]                   function(frame = 1L) {
[10:22:09.782]                     if (is.function(sendCondition)) 
[10:22:09.782]                       return(sendCondition)
[10:22:09.782]                     ns <- getNamespace("parallel")
[10:22:09.782]                     if (exists("sendData", mode = "function", 
[10:22:09.782]                       envir = ns)) {
[10:22:09.782]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:09.782]                         envir = ns)
[10:22:09.782]                       envir <- sys.frame(frame)
[10:22:09.782]                       master <- NULL
[10:22:09.782]                       while (!identical(envir, .GlobalEnv) && 
[10:22:09.782]                         !identical(envir, emptyenv())) {
[10:22:09.782]                         if (exists("master", mode = "list", envir = envir, 
[10:22:09.782]                           inherits = FALSE)) {
[10:22:09.782]                           master <- get("master", mode = "list", 
[10:22:09.782]                             envir = envir, inherits = FALSE)
[10:22:09.782]                           if (inherits(master, c("SOCKnode", 
[10:22:09.782]                             "SOCK0node"))) {
[10:22:09.782]                             sendCondition <<- function(cond) {
[10:22:09.782]                               data <- list(type = "VALUE", value = cond, 
[10:22:09.782]                                 success = TRUE)
[10:22:09.782]                               parallel_sendData(master, data)
[10:22:09.782]                             }
[10:22:09.782]                             return(sendCondition)
[10:22:09.782]                           }
[10:22:09.782]                         }
[10:22:09.782]                         frame <- frame + 1L
[10:22:09.782]                         envir <- sys.frame(frame)
[10:22:09.782]                       }
[10:22:09.782]                     }
[10:22:09.782]                     sendCondition <<- function(cond) NULL
[10:22:09.782]                   }
[10:22:09.782]                 })
[10:22:09.782]                 withCallingHandlers({
[10:22:09.782]                   {
[10:22:09.782]                     a <- 1L
[10:22:09.782]                     plan_a <- unclass(future::plan("list"))
[10:22:09.782]                     nested_a <- nested[-1]
[10:22:09.782]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[10:22:09.782]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[10:22:09.782]                       strategy2))
[10:22:09.782]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[10:22:09.782]                       "init") <- NULL
[10:22:09.782]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[10:22:09.782]                       "init") <- NULL
[10:22:09.782]                     stopifnot(all.equal(plan_a, nested_a))
[10:22:09.782]                     y %<-% {
[10:22:09.782]                       b <- 2L
[10:22:09.782]                       plan_b <- future::plan("list")
[10:22:09.782]                       nested_b <- nested_a[-1]
[10:22:09.782]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[10:22:09.782]                         1L, inherits(plan_b[[1]], "future"), 
[10:22:09.782]                         inherits(future::plan("next"), "sequential"))
[10:22:09.782]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[10:22:09.782]                         b = b, nested_b = nested_b, plan_b = plan_b)
[10:22:09.782]                     }
[10:22:09.782]                     y
[10:22:09.782]                   }
[10:22:09.782]                 }, immediateCondition = function(cond) {
[10:22:09.782]                   sendCondition <- ...future.makeSendCondition()
[10:22:09.782]                   sendCondition(cond)
[10:22:09.782]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:09.782]                   {
[10:22:09.782]                     inherits <- base::inherits
[10:22:09.782]                     invokeRestart <- base::invokeRestart
[10:22:09.782]                     is.null <- base::is.null
[10:22:09.782]                     muffled <- FALSE
[10:22:09.782]                     if (inherits(cond, "message")) {
[10:22:09.782]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:09.782]                       if (muffled) 
[10:22:09.782]                         invokeRestart("muffleMessage")
[10:22:09.782]                     }
[10:22:09.782]                     else if (inherits(cond, "warning")) {
[10:22:09.782]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:09.782]                       if (muffled) 
[10:22:09.782]                         invokeRestart("muffleWarning")
[10:22:09.782]                     }
[10:22:09.782]                     else if (inherits(cond, "condition")) {
[10:22:09.782]                       if (!is.null(pattern)) {
[10:22:09.782]                         computeRestarts <- base::computeRestarts
[10:22:09.782]                         grepl <- base::grepl
[10:22:09.782]                         restarts <- computeRestarts(cond)
[10:22:09.782]                         for (restart in restarts) {
[10:22:09.782]                           name <- restart$name
[10:22:09.782]                           if (is.null(name)) 
[10:22:09.782]                             next
[10:22:09.782]                           if (!grepl(pattern, name)) 
[10:22:09.782]                             next
[10:22:09.782]                           invokeRestart(restart)
[10:22:09.782]                           muffled <- TRUE
[10:22:09.782]                           break
[10:22:09.782]                         }
[10:22:09.782]                       }
[10:22:09.782]                     }
[10:22:09.782]                     invisible(muffled)
[10:22:09.782]                   }
[10:22:09.782]                   muffleCondition(cond)
[10:22:09.782]                 })
[10:22:09.782]             }))
[10:22:09.782]             future::FutureResult(value = ...future.value$value, 
[10:22:09.782]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:09.782]                   ...future.rng), globalenv = if (FALSE) 
[10:22:09.782]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:09.782]                     ...future.globalenv.names))
[10:22:09.782]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:09.782]         }, condition = base::local({
[10:22:09.782]             c <- base::c
[10:22:09.782]             inherits <- base::inherits
[10:22:09.782]             invokeRestart <- base::invokeRestart
[10:22:09.782]             length <- base::length
[10:22:09.782]             list <- base::list
[10:22:09.782]             seq.int <- base::seq.int
[10:22:09.782]             signalCondition <- base::signalCondition
[10:22:09.782]             sys.calls <- base::sys.calls
[10:22:09.782]             `[[` <- base::`[[`
[10:22:09.782]             `+` <- base::`+`
[10:22:09.782]             `<<-` <- base::`<<-`
[10:22:09.782]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:09.782]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:09.782]                   3L)]
[10:22:09.782]             }
[10:22:09.782]             function(cond) {
[10:22:09.782]                 is_error <- inherits(cond, "error")
[10:22:09.782]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:09.782]                   NULL)
[10:22:09.782]                 if (is_error) {
[10:22:09.782]                   sessionInformation <- function() {
[10:22:09.782]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:09.782]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:09.782]                       search = base::search(), system = base::Sys.info())
[10:22:09.782]                   }
[10:22:09.782]                   ...future.conditions[[length(...future.conditions) + 
[10:22:09.782]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:09.782]                     cond$call), session = sessionInformation(), 
[10:22:09.782]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:09.782]                   signalCondition(cond)
[10:22:09.782]                 }
[10:22:09.782]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:09.782]                 "immediateCondition"))) {
[10:22:09.782]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:09.782]                   ...future.conditions[[length(...future.conditions) + 
[10:22:09.782]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:09.782]                   if (TRUE && !signal) {
[10:22:09.782]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:09.782]                     {
[10:22:09.782]                       inherits <- base::inherits
[10:22:09.782]                       invokeRestart <- base::invokeRestart
[10:22:09.782]                       is.null <- base::is.null
[10:22:09.782]                       muffled <- FALSE
[10:22:09.782]                       if (inherits(cond, "message")) {
[10:22:09.782]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:09.782]                         if (muffled) 
[10:22:09.782]                           invokeRestart("muffleMessage")
[10:22:09.782]                       }
[10:22:09.782]                       else if (inherits(cond, "warning")) {
[10:22:09.782]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:09.782]                         if (muffled) 
[10:22:09.782]                           invokeRestart("muffleWarning")
[10:22:09.782]                       }
[10:22:09.782]                       else if (inherits(cond, "condition")) {
[10:22:09.782]                         if (!is.null(pattern)) {
[10:22:09.782]                           computeRestarts <- base::computeRestarts
[10:22:09.782]                           grepl <- base::grepl
[10:22:09.782]                           restarts <- computeRestarts(cond)
[10:22:09.782]                           for (restart in restarts) {
[10:22:09.782]                             name <- restart$name
[10:22:09.782]                             if (is.null(name)) 
[10:22:09.782]                               next
[10:22:09.782]                             if (!grepl(pattern, name)) 
[10:22:09.782]                               next
[10:22:09.782]                             invokeRestart(restart)
[10:22:09.782]                             muffled <- TRUE
[10:22:09.782]                             break
[10:22:09.782]                           }
[10:22:09.782]                         }
[10:22:09.782]                       }
[10:22:09.782]                       invisible(muffled)
[10:22:09.782]                     }
[10:22:09.782]                     muffleCondition(cond, pattern = "^muffle")
[10:22:09.782]                   }
[10:22:09.782]                 }
[10:22:09.782]                 else {
[10:22:09.782]                   if (TRUE) {
[10:22:09.782]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:09.782]                     {
[10:22:09.782]                       inherits <- base::inherits
[10:22:09.782]                       invokeRestart <- base::invokeRestart
[10:22:09.782]                       is.null <- base::is.null
[10:22:09.782]                       muffled <- FALSE
[10:22:09.782]                       if (inherits(cond, "message")) {
[10:22:09.782]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:09.782]                         if (muffled) 
[10:22:09.782]                           invokeRestart("muffleMessage")
[10:22:09.782]                       }
[10:22:09.782]                       else if (inherits(cond, "warning")) {
[10:22:09.782]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:09.782]                         if (muffled) 
[10:22:09.782]                           invokeRestart("muffleWarning")
[10:22:09.782]                       }
[10:22:09.782]                       else if (inherits(cond, "condition")) {
[10:22:09.782]                         if (!is.null(pattern)) {
[10:22:09.782]                           computeRestarts <- base::computeRestarts
[10:22:09.782]                           grepl <- base::grepl
[10:22:09.782]                           restarts <- computeRestarts(cond)
[10:22:09.782]                           for (restart in restarts) {
[10:22:09.782]                             name <- restart$name
[10:22:09.782]                             if (is.null(name)) 
[10:22:09.782]                               next
[10:22:09.782]                             if (!grepl(pattern, name)) 
[10:22:09.782]                               next
[10:22:09.782]                             invokeRestart(restart)
[10:22:09.782]                             muffled <- TRUE
[10:22:09.782]                             break
[10:22:09.782]                           }
[10:22:09.782]                         }
[10:22:09.782]                       }
[10:22:09.782]                       invisible(muffled)
[10:22:09.782]                     }
[10:22:09.782]                     muffleCondition(cond, pattern = "^muffle")
[10:22:09.782]                   }
[10:22:09.782]                 }
[10:22:09.782]             }
[10:22:09.782]         }))
[10:22:09.782]     }, error = function(ex) {
[10:22:09.782]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:09.782]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:09.782]                 ...future.rng), started = ...future.startTime, 
[10:22:09.782]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:09.782]             version = "1.8"), class = "FutureResult")
[10:22:09.782]     }, finally = {
[10:22:09.782]         if (!identical(...future.workdir, getwd())) 
[10:22:09.782]             setwd(...future.workdir)
[10:22:09.782]         {
[10:22:09.782]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:09.782]                 ...future.oldOptions$nwarnings <- NULL
[10:22:09.782]             }
[10:22:09.782]             base::options(...future.oldOptions)
[10:22:09.782]             if (.Platform$OS.type == "windows") {
[10:22:09.782]                 old_names <- names(...future.oldEnvVars)
[10:22:09.782]                 envs <- base::Sys.getenv()
[10:22:09.782]                 names <- names(envs)
[10:22:09.782]                 common <- intersect(names, old_names)
[10:22:09.782]                 added <- setdiff(names, old_names)
[10:22:09.782]                 removed <- setdiff(old_names, names)
[10:22:09.782]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:09.782]                   envs[common]]
[10:22:09.782]                 NAMES <- toupper(changed)
[10:22:09.782]                 args <- list()
[10:22:09.782]                 for (kk in seq_along(NAMES)) {
[10:22:09.782]                   name <- changed[[kk]]
[10:22:09.782]                   NAME <- NAMES[[kk]]
[10:22:09.782]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:09.782]                     next
[10:22:09.782]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:09.782]                 }
[10:22:09.782]                 NAMES <- toupper(added)
[10:22:09.782]                 for (kk in seq_along(NAMES)) {
[10:22:09.782]                   name <- added[[kk]]
[10:22:09.782]                   NAME <- NAMES[[kk]]
[10:22:09.782]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:09.782]                     next
[10:22:09.782]                   args[[name]] <- ""
[10:22:09.782]                 }
[10:22:09.782]                 NAMES <- toupper(removed)
[10:22:09.782]                 for (kk in seq_along(NAMES)) {
[10:22:09.782]                   name <- removed[[kk]]
[10:22:09.782]                   NAME <- NAMES[[kk]]
[10:22:09.782]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:09.782]                     next
[10:22:09.782]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:09.782]                 }
[10:22:09.782]                 if (length(args) > 0) 
[10:22:09.782]                   base::do.call(base::Sys.setenv, args = args)
[10:22:09.782]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:09.782]             }
[10:22:09.782]             else {
[10:22:09.782]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:09.782]             }
[10:22:09.782]             {
[10:22:09.782]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:09.782]                   0L) {
[10:22:09.782]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:09.782]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:09.782]                   base::options(opts)
[10:22:09.782]                 }
[10:22:09.782]                 {
[10:22:09.782]                   {
[10:22:09.782]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:09.782]                     NULL
[10:22:09.782]                   }
[10:22:09.782]                   options(future.plan = NULL)
[10:22:09.782]                   if (is.na(NA_character_)) 
[10:22:09.782]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:09.782]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:09.782]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:09.782]                     .init = FALSE)
[10:22:09.782]                 }
[10:22:09.782]             }
[10:22:09.782]         }
[10:22:09.782]     })
[10:22:09.782]     if (TRUE) {
[10:22:09.782]         base::sink(type = "output", split = FALSE)
[10:22:09.782]         if (TRUE) {
[10:22:09.782]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:09.782]         }
[10:22:09.782]         else {
[10:22:09.782]             ...future.result["stdout"] <- base::list(NULL)
[10:22:09.782]         }
[10:22:09.782]         base::close(...future.stdout)
[10:22:09.782]         ...future.stdout <- NULL
[10:22:09.782]     }
[10:22:09.782]     ...future.result$conditions <- ...future.conditions
[10:22:09.782]     ...future.result$finished <- base::Sys.time()
[10:22:09.782]     ...future.result
[10:22:09.782] }
[10:22:09.785] Exporting 2 global objects (11.55 KiB) to cluster node #1 ...
[10:22:09.785] Exporting ‘nested’ (11.20 KiB) to cluster node #1 ...
[10:22:09.825] Exporting ‘nested’ (11.20 KiB) to cluster node #1 ... DONE
[10:22:09.826] Exporting ‘strategy2’ (51 bytes) to cluster node #1 ...
[10:22:09.826] Exporting ‘strategy2’ (51 bytes) to cluster node #1 ... DONE
[10:22:09.826] Exporting 2 global objects (11.55 KiB) to cluster node #1 ... DONE
[10:22:09.827] MultisessionFuture started
[10:22:09.827] - Launch lazy future ... done
[10:22:09.827] run() for ‘MultisessionFuture’ ... done
[10:22:09.827] result() for ClusterFuture ...
[10:22:09.827] receiveMessageFromWorker() for ClusterFuture ...
[10:22:09.827] - Validating connection of MultisessionFuture
[10:22:09.890] - received message: FutureResult
[10:22:09.890] - Received FutureResult
[10:22:09.890] - Erased future from FutureRegistry
[10:22:09.890] result() for ClusterFuture ...
[10:22:09.890] - result already collected: FutureResult
[10:22:09.890] result() for ClusterFuture ... done
[10:22:09.891] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:09.891] result() for ClusterFuture ... done
[10:22:09.891] result() for ClusterFuture ...
[10:22:09.891] - result already collected: FutureResult
[10:22:09.891] result() for ClusterFuture ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "cleanup")=function ()  
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "cleanup")=function ()  
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[10:22:09.897] getGlobalsAndPackages() ...
[10:22:09.897] Searching for globals...
[10:22:09.898] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[10:22:09.898] Searching for globals ... DONE
[10:22:09.898] Resolving globals: FALSE
[10:22:09.899] The total size of the 1 globals is 356 bytes (356 bytes)
[10:22:09.899] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[10:22:09.899] - globals: [1] ‘data’
[10:22:09.899] - packages: [1] ‘future’
[10:22:09.899] getGlobalsAndPackages() ... DONE
[10:22:09.900] run() for ‘Future’ ...
[10:22:09.900] - state: ‘created’
[10:22:09.900] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:22:09.914] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:22:09.914] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:22:09.914]   - Field: ‘node’
[10:22:09.914]   - Field: ‘label’
[10:22:09.914]   - Field: ‘local’
[10:22:09.914]   - Field: ‘owner’
[10:22:09.914]   - Field: ‘envir’
[10:22:09.914]   - Field: ‘workers’
[10:22:09.915]   - Field: ‘packages’
[10:22:09.915]   - Field: ‘gc’
[10:22:09.915]   - Field: ‘conditions’
[10:22:09.915]   - Field: ‘persistent’
[10:22:09.915]   - Field: ‘expr’
[10:22:09.915]   - Field: ‘uuid’
[10:22:09.915]   - Field: ‘seed’
[10:22:09.915]   - Field: ‘version’
[10:22:09.915]   - Field: ‘result’
[10:22:09.915]   - Field: ‘asynchronous’
[10:22:09.915]   - Field: ‘calls’
[10:22:09.916]   - Field: ‘globals’
[10:22:09.916]   - Field: ‘stdout’
[10:22:09.916]   - Field: ‘earlySignal’
[10:22:09.916]   - Field: ‘lazy’
[10:22:09.916]   - Field: ‘state’
[10:22:09.916] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:22:09.916] - Launch lazy future ...
[10:22:09.916] Packages needed by the future expression (n = 1): ‘future’
[10:22:09.916] Packages needed by future strategies (n = 1): ‘future’
[10:22:09.917] {
[10:22:09.917]     {
[10:22:09.917]         {
[10:22:09.917]             ...future.startTime <- base::Sys.time()
[10:22:09.917]             {
[10:22:09.917]                 {
[10:22:09.917]                   {
[10:22:09.917]                     {
[10:22:09.917]                       {
[10:22:09.917]                         base::local({
[10:22:09.917]                           has_future <- base::requireNamespace("future", 
[10:22:09.917]                             quietly = TRUE)
[10:22:09.917]                           if (has_future) {
[10:22:09.917]                             ns <- base::getNamespace("future")
[10:22:09.917]                             version <- ns[[".package"]][["version"]]
[10:22:09.917]                             if (is.null(version)) 
[10:22:09.917]                               version <- utils::packageVersion("future")
[10:22:09.917]                           }
[10:22:09.917]                           else {
[10:22:09.917]                             version <- NULL
[10:22:09.917]                           }
[10:22:09.917]                           if (!has_future || version < "1.8.0") {
[10:22:09.917]                             info <- base::c(r_version = base::gsub("R version ", 
[10:22:09.917]                               "", base::R.version$version.string), 
[10:22:09.917]                               platform = base::sprintf("%s (%s-bit)", 
[10:22:09.917]                                 base::R.version$platform, 8 * 
[10:22:09.917]                                   base::.Machine$sizeof.pointer), 
[10:22:09.917]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:22:09.917]                                 "release", "version")], collapse = " "), 
[10:22:09.917]                               hostname = base::Sys.info()[["nodename"]])
[10:22:09.917]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:22:09.917]                               info)
[10:22:09.917]                             info <- base::paste(info, collapse = "; ")
[10:22:09.917]                             if (!has_future) {
[10:22:09.917]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:22:09.917]                                 info)
[10:22:09.917]                             }
[10:22:09.917]                             else {
[10:22:09.917]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:22:09.917]                                 info, version)
[10:22:09.917]                             }
[10:22:09.917]                             base::stop(msg)
[10:22:09.917]                           }
[10:22:09.917]                         })
[10:22:09.917]                       }
[10:22:09.917]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:22:09.917]                       base::options(mc.cores = 1L)
[10:22:09.917]                     }
[10:22:09.917]                     base::local({
[10:22:09.917]                       for (pkg in "future") {
[10:22:09.917]                         base::loadNamespace(pkg)
[10:22:09.917]                         base::library(pkg, character.only = TRUE)
[10:22:09.917]                       }
[10:22:09.917]                     })
[10:22:09.917]                   }
[10:22:09.917]                   ...future.strategy.old <- future::plan("list")
[10:22:09.917]                   options(future.plan = NULL)
[10:22:09.917]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:22:09.917]                   future::plan(list(b = function (..., workers = availableCores(), 
[10:22:09.917]                     lazy = FALSE, rscript_libs = .libPaths(), 
[10:22:09.917]                     envir = parent.frame()) 
[10:22:09.917]                   {
[10:22:09.917]                     if (is.function(workers)) 
[10:22:09.917]                       workers <- workers()
[10:22:09.917]                     workers <- structure(as.integer(workers), 
[10:22:09.917]                       class = class(workers))
[10:22:09.917]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[10:22:09.917]                       workers >= 1)
[10:22:09.917]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[10:22:09.917]                       return(sequential(..., lazy = TRUE, envir = envir))
[10:22:09.917]                     }
[10:22:09.917]                     future <- MultisessionFuture(..., workers = workers, 
[10:22:09.917]                       lazy = lazy, rscript_libs = rscript_libs, 
[10:22:09.917]                       envir = envir)
[10:22:09.917]                     if (!future$lazy) 
[10:22:09.917]                       future <- run(future)
[10:22:09.917]                     invisible(future)
[10:22:09.917]                   }), .cleanup = FALSE, .init = FALSE)
[10:22:09.917]                 }
[10:22:09.917]                 ...future.workdir <- getwd()
[10:22:09.917]             }
[10:22:09.917]             ...future.oldOptions <- base::as.list(base::.Options)
[10:22:09.917]             ...future.oldEnvVars <- base::Sys.getenv()
[10:22:09.917]         }
[10:22:09.917]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:22:09.917]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:22:09.917]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:22:09.917]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:22:09.917]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:22:09.917]             future.stdout.windows.reencode = NULL, width = 80L)
[10:22:09.917]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:22:09.917]             base::names(...future.oldOptions))
[10:22:09.917]     }
[10:22:09.917]     if (FALSE) {
[10:22:09.917]     }
[10:22:09.917]     else {
[10:22:09.917]         if (TRUE) {
[10:22:09.917]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:22:09.917]                 open = "w")
[10:22:09.917]         }
[10:22:09.917]         else {
[10:22:09.917]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:22:09.917]                 windows = "NUL", "/dev/null"), open = "w")
[10:22:09.917]         }
[10:22:09.917]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:22:09.917]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:22:09.917]             base::sink(type = "output", split = FALSE)
[10:22:09.917]             base::close(...future.stdout)
[10:22:09.917]         }, add = TRUE)
[10:22:09.917]     }
[10:22:09.917]     ...future.frame <- base::sys.nframe()
[10:22:09.917]     ...future.conditions <- base::list()
[10:22:09.917]     ...future.rng <- base::globalenv()$.Random.seed
[10:22:09.917]     if (FALSE) {
[10:22:09.917]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:22:09.917]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:22:09.917]     }
[10:22:09.917]     ...future.result <- base::tryCatch({
[10:22:09.917]         base::withCallingHandlers({
[10:22:09.917]             ...future.value <- base::withVisible(base::local({
[10:22:09.917]                 ...future.makeSendCondition <- base::local({
[10:22:09.917]                   sendCondition <- NULL
[10:22:09.917]                   function(frame = 1L) {
[10:22:09.917]                     if (is.function(sendCondition)) 
[10:22:09.917]                       return(sendCondition)
[10:22:09.917]                     ns <- getNamespace("parallel")
[10:22:09.917]                     if (exists("sendData", mode = "function", 
[10:22:09.917]                       envir = ns)) {
[10:22:09.917]                       parallel_sendData <- get("sendData", mode = "function", 
[10:22:09.917]                         envir = ns)
[10:22:09.917]                       envir <- sys.frame(frame)
[10:22:09.917]                       master <- NULL
[10:22:09.917]                       while (!identical(envir, .GlobalEnv) && 
[10:22:09.917]                         !identical(envir, emptyenv())) {
[10:22:09.917]                         if (exists("master", mode = "list", envir = envir, 
[10:22:09.917]                           inherits = FALSE)) {
[10:22:09.917]                           master <- get("master", mode = "list", 
[10:22:09.917]                             envir = envir, inherits = FALSE)
[10:22:09.917]                           if (inherits(master, c("SOCKnode", 
[10:22:09.917]                             "SOCK0node"))) {
[10:22:09.917]                             sendCondition <<- function(cond) {
[10:22:09.917]                               data <- list(type = "VALUE", value = cond, 
[10:22:09.917]                                 success = TRUE)
[10:22:09.917]                               parallel_sendData(master, data)
[10:22:09.917]                             }
[10:22:09.917]                             return(sendCondition)
[10:22:09.917]                           }
[10:22:09.917]                         }
[10:22:09.917]                         frame <- frame + 1L
[10:22:09.917]                         envir <- sys.frame(frame)
[10:22:09.917]                       }
[10:22:09.917]                     }
[10:22:09.917]                     sendCondition <<- function(cond) NULL
[10:22:09.917]                   }
[10:22:09.917]                 })
[10:22:09.917]                 withCallingHandlers({
[10:22:09.917]                   {
[10:22:09.917]                     value(future(subset(data, a == 2)))
[10:22:09.917]                   }
[10:22:09.917]                 }, immediateCondition = function(cond) {
[10:22:09.917]                   sendCondition <- ...future.makeSendCondition()
[10:22:09.917]                   sendCondition(cond)
[10:22:09.917]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:09.917]                   {
[10:22:09.917]                     inherits <- base::inherits
[10:22:09.917]                     invokeRestart <- base::invokeRestart
[10:22:09.917]                     is.null <- base::is.null
[10:22:09.917]                     muffled <- FALSE
[10:22:09.917]                     if (inherits(cond, "message")) {
[10:22:09.917]                       muffled <- grepl(pattern, "muffleMessage")
[10:22:09.917]                       if (muffled) 
[10:22:09.917]                         invokeRestart("muffleMessage")
[10:22:09.917]                     }
[10:22:09.917]                     else if (inherits(cond, "warning")) {
[10:22:09.917]                       muffled <- grepl(pattern, "muffleWarning")
[10:22:09.917]                       if (muffled) 
[10:22:09.917]                         invokeRestart("muffleWarning")
[10:22:09.917]                     }
[10:22:09.917]                     else if (inherits(cond, "condition")) {
[10:22:09.917]                       if (!is.null(pattern)) {
[10:22:09.917]                         computeRestarts <- base::computeRestarts
[10:22:09.917]                         grepl <- base::grepl
[10:22:09.917]                         restarts <- computeRestarts(cond)
[10:22:09.917]                         for (restart in restarts) {
[10:22:09.917]                           name <- restart$name
[10:22:09.917]                           if (is.null(name)) 
[10:22:09.917]                             next
[10:22:09.917]                           if (!grepl(pattern, name)) 
[10:22:09.917]                             next
[10:22:09.917]                           invokeRestart(restart)
[10:22:09.917]                           muffled <- TRUE
[10:22:09.917]                           break
[10:22:09.917]                         }
[10:22:09.917]                       }
[10:22:09.917]                     }
[10:22:09.917]                     invisible(muffled)
[10:22:09.917]                   }
[10:22:09.917]                   muffleCondition(cond)
[10:22:09.917]                 })
[10:22:09.917]             }))
[10:22:09.917]             future::FutureResult(value = ...future.value$value, 
[10:22:09.917]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:09.917]                   ...future.rng), globalenv = if (FALSE) 
[10:22:09.917]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:22:09.917]                     ...future.globalenv.names))
[10:22:09.917]                 else NULL, started = ...future.startTime, version = "1.8")
[10:22:09.917]         }, condition = base::local({
[10:22:09.917]             c <- base::c
[10:22:09.917]             inherits <- base::inherits
[10:22:09.917]             invokeRestart <- base::invokeRestart
[10:22:09.917]             length <- base::length
[10:22:09.917]             list <- base::list
[10:22:09.917]             seq.int <- base::seq.int
[10:22:09.917]             signalCondition <- base::signalCondition
[10:22:09.917]             sys.calls <- base::sys.calls
[10:22:09.917]             `[[` <- base::`[[`
[10:22:09.917]             `+` <- base::`+`
[10:22:09.917]             `<<-` <- base::`<<-`
[10:22:09.917]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:22:09.917]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:22:09.917]                   3L)]
[10:22:09.917]             }
[10:22:09.917]             function(cond) {
[10:22:09.917]                 is_error <- inherits(cond, "error")
[10:22:09.917]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:22:09.917]                   NULL)
[10:22:09.917]                 if (is_error) {
[10:22:09.917]                   sessionInformation <- function() {
[10:22:09.917]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:22:09.917]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:22:09.917]                       search = base::search(), system = base::Sys.info())
[10:22:09.917]                   }
[10:22:09.917]                   ...future.conditions[[length(...future.conditions) + 
[10:22:09.917]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:22:09.917]                     cond$call), session = sessionInformation(), 
[10:22:09.917]                     timestamp = base::Sys.time(), signaled = 0L)
[10:22:09.917]                   signalCondition(cond)
[10:22:09.917]                 }
[10:22:09.917]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:22:09.917]                 "immediateCondition"))) {
[10:22:09.917]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:22:09.917]                   ...future.conditions[[length(...future.conditions) + 
[10:22:09.917]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:22:09.917]                   if (TRUE && !signal) {
[10:22:09.917]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:09.917]                     {
[10:22:09.917]                       inherits <- base::inherits
[10:22:09.917]                       invokeRestart <- base::invokeRestart
[10:22:09.917]                       is.null <- base::is.null
[10:22:09.917]                       muffled <- FALSE
[10:22:09.917]                       if (inherits(cond, "message")) {
[10:22:09.917]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:09.917]                         if (muffled) 
[10:22:09.917]                           invokeRestart("muffleMessage")
[10:22:09.917]                       }
[10:22:09.917]                       else if (inherits(cond, "warning")) {
[10:22:09.917]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:09.917]                         if (muffled) 
[10:22:09.917]                           invokeRestart("muffleWarning")
[10:22:09.917]                       }
[10:22:09.917]                       else if (inherits(cond, "condition")) {
[10:22:09.917]                         if (!is.null(pattern)) {
[10:22:09.917]                           computeRestarts <- base::computeRestarts
[10:22:09.917]                           grepl <- base::grepl
[10:22:09.917]                           restarts <- computeRestarts(cond)
[10:22:09.917]                           for (restart in restarts) {
[10:22:09.917]                             name <- restart$name
[10:22:09.917]                             if (is.null(name)) 
[10:22:09.917]                               next
[10:22:09.917]                             if (!grepl(pattern, name)) 
[10:22:09.917]                               next
[10:22:09.917]                             invokeRestart(restart)
[10:22:09.917]                             muffled <- TRUE
[10:22:09.917]                             break
[10:22:09.917]                           }
[10:22:09.917]                         }
[10:22:09.917]                       }
[10:22:09.917]                       invisible(muffled)
[10:22:09.917]                     }
[10:22:09.917]                     muffleCondition(cond, pattern = "^muffle")
[10:22:09.917]                   }
[10:22:09.917]                 }
[10:22:09.917]                 else {
[10:22:09.917]                   if (TRUE) {
[10:22:09.917]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:22:09.917]                     {
[10:22:09.917]                       inherits <- base::inherits
[10:22:09.917]                       invokeRestart <- base::invokeRestart
[10:22:09.917]                       is.null <- base::is.null
[10:22:09.917]                       muffled <- FALSE
[10:22:09.917]                       if (inherits(cond, "message")) {
[10:22:09.917]                         muffled <- grepl(pattern, "muffleMessage")
[10:22:09.917]                         if (muffled) 
[10:22:09.917]                           invokeRestart("muffleMessage")
[10:22:09.917]                       }
[10:22:09.917]                       else if (inherits(cond, "warning")) {
[10:22:09.917]                         muffled <- grepl(pattern, "muffleWarning")
[10:22:09.917]                         if (muffled) 
[10:22:09.917]                           invokeRestart("muffleWarning")
[10:22:09.917]                       }
[10:22:09.917]                       else if (inherits(cond, "condition")) {
[10:22:09.917]                         if (!is.null(pattern)) {
[10:22:09.917]                           computeRestarts <- base::computeRestarts
[10:22:09.917]                           grepl <- base::grepl
[10:22:09.917]                           restarts <- computeRestarts(cond)
[10:22:09.917]                           for (restart in restarts) {
[10:22:09.917]                             name <- restart$name
[10:22:09.917]                             if (is.null(name)) 
[10:22:09.917]                               next
[10:22:09.917]                             if (!grepl(pattern, name)) 
[10:22:09.917]                               next
[10:22:09.917]                             invokeRestart(restart)
[10:22:09.917]                             muffled <- TRUE
[10:22:09.917]                             break
[10:22:09.917]                           }
[10:22:09.917]                         }
[10:22:09.917]                       }
[10:22:09.917]                       invisible(muffled)
[10:22:09.917]                     }
[10:22:09.917]                     muffleCondition(cond, pattern = "^muffle")
[10:22:09.917]                   }
[10:22:09.917]                 }
[10:22:09.917]             }
[10:22:09.917]         }))
[10:22:09.917]     }, error = function(ex) {
[10:22:09.917]         base::structure(base::list(value = NULL, visible = NULL, 
[10:22:09.917]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:22:09.917]                 ...future.rng), started = ...future.startTime, 
[10:22:09.917]             finished = Sys.time(), session_uuid = NA_character_, 
[10:22:09.917]             version = "1.8"), class = "FutureResult")
[10:22:09.917]     }, finally = {
[10:22:09.917]         if (!identical(...future.workdir, getwd())) 
[10:22:09.917]             setwd(...future.workdir)
[10:22:09.917]         {
[10:22:09.917]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:22:09.917]                 ...future.oldOptions$nwarnings <- NULL
[10:22:09.917]             }
[10:22:09.917]             base::options(...future.oldOptions)
[10:22:09.917]             if (.Platform$OS.type == "windows") {
[10:22:09.917]                 old_names <- names(...future.oldEnvVars)
[10:22:09.917]                 envs <- base::Sys.getenv()
[10:22:09.917]                 names <- names(envs)
[10:22:09.917]                 common <- intersect(names, old_names)
[10:22:09.917]                 added <- setdiff(names, old_names)
[10:22:09.917]                 removed <- setdiff(old_names, names)
[10:22:09.917]                 changed <- common[...future.oldEnvVars[common] != 
[10:22:09.917]                   envs[common]]
[10:22:09.917]                 NAMES <- toupper(changed)
[10:22:09.917]                 args <- list()
[10:22:09.917]                 for (kk in seq_along(NAMES)) {
[10:22:09.917]                   name <- changed[[kk]]
[10:22:09.917]                   NAME <- NAMES[[kk]]
[10:22:09.917]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:09.917]                     next
[10:22:09.917]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:09.917]                 }
[10:22:09.917]                 NAMES <- toupper(added)
[10:22:09.917]                 for (kk in seq_along(NAMES)) {
[10:22:09.917]                   name <- added[[kk]]
[10:22:09.917]                   NAME <- NAMES[[kk]]
[10:22:09.917]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:09.917]                     next
[10:22:09.917]                   args[[name]] <- ""
[10:22:09.917]                 }
[10:22:09.917]                 NAMES <- toupper(removed)
[10:22:09.917]                 for (kk in seq_along(NAMES)) {
[10:22:09.917]                   name <- removed[[kk]]
[10:22:09.917]                   NAME <- NAMES[[kk]]
[10:22:09.917]                   if (name != NAME && is.element(NAME, old_names)) 
[10:22:09.917]                     next
[10:22:09.917]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:22:09.917]                 }
[10:22:09.917]                 if (length(args) > 0) 
[10:22:09.917]                   base::do.call(base::Sys.setenv, args = args)
[10:22:09.917]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:22:09.917]             }
[10:22:09.917]             else {
[10:22:09.917]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:22:09.917]             }
[10:22:09.917]             {
[10:22:09.917]                 if (base::length(...future.futureOptionsAdded) > 
[10:22:09.917]                   0L) {
[10:22:09.917]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:22:09.917]                   base::names(opts) <- ...future.futureOptionsAdded
[10:22:09.917]                   base::options(opts)
[10:22:09.917]                 }
[10:22:09.917]                 {
[10:22:09.917]                   {
[10:22:09.917]                     base::options(mc.cores = ...future.mc.cores.old)
[10:22:09.917]                     NULL
[10:22:09.917]                   }
[10:22:09.917]                   options(future.plan = NULL)
[10:22:09.917]                   if (is.na(NA_character_)) 
[10:22:09.917]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:22:09.917]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:22:09.917]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:22:09.917]                     .init = FALSE)
[10:22:09.917]                 }
[10:22:09.917]             }
[10:22:09.917]         }
[10:22:09.917]     })
[10:22:09.917]     if (TRUE) {
[10:22:09.917]         base::sink(type = "output", split = FALSE)
[10:22:09.917]         if (TRUE) {
[10:22:09.917]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:22:09.917]         }
[10:22:09.917]         else {
[10:22:09.917]             ...future.result["stdout"] <- base::list(NULL)
[10:22:09.917]         }
[10:22:09.917]         base::close(...future.stdout)
[10:22:09.917]         ...future.stdout <- NULL
[10:22:09.917]     }
[10:22:09.917]     ...future.result$conditions <- ...future.conditions
[10:22:09.917]     ...future.result$finished <- base::Sys.time()
[10:22:09.917]     ...future.result
[10:22:09.917] }
[10:22:09.920] Exporting 1 global objects (643 bytes) to cluster node #1 ...
[10:22:09.920] Exporting ‘data’ (356 bytes) to cluster node #1 ...
[10:22:09.920] Exporting ‘data’ (356 bytes) to cluster node #1 ... DONE
[10:22:09.920] Exporting 1 global objects (643 bytes) to cluster node #1 ... DONE
[10:22:09.921] MultisessionFuture started
[10:22:09.921] - Launch lazy future ... done
[10:22:09.921] run() for ‘MultisessionFuture’ ... done
[10:22:09.921] result() for ClusterFuture ...
[10:22:09.921] receiveMessageFromWorker() for ClusterFuture ...
[10:22:09.922] - Validating connection of MultisessionFuture
[10:22:09.970] - received message: FutureResult
[10:22:09.970] - Received FutureResult
[10:22:09.970] - Erased future from FutureRegistry
[10:22:09.970] result() for ClusterFuture ...
[10:22:09.970] - result already collected: FutureResult
[10:22:09.970] result() for ClusterFuture ... done
[10:22:09.970] receiveMessageFromWorker() for ClusterFuture ... done
[10:22:09.970] result() for ClusterFuture ... done
[10:22:09.970] result() for ClusterFuture ...
[10:22:09.970] - result already collected: FutureResult
[10:22:09.971] result() for ClusterFuture ... done
- plan(list('multisession', 'multisession')) ... DONE
> 
> message("*** Nested futures ... DONE")
*** Nested futures ... DONE
> 
> source("incl/end.R")
[10:22:09.971] plan(): Setting new future strategy stack:
[10:22:09.971] List of future strategies:
[10:22:09.971] 1. FutureStrategy:
[10:22:09.971]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:22:09.971]    - tweaked: FALSE
[10:22:09.971]    - call: future::plan(oplan)
[10:22:09.972] plan(): nbrOfWorkers() = 1
> 
