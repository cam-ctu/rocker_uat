
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[08:28:38.187] plan(): Setting new future strategy stack:
[08:28:38.188] List of future strategies:
[08:28:38.188] 1. sequential:
[08:28:38.188]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:38.188]    - tweaked: FALSE
[08:28:38.188]    - call: future::plan("sequential")
[08:28:38.203] plan(): nbrOfWorkers() = 1
> 
> strategies <- supportedStrategies()
> 
> message("*** Nested futures ...")
*** Nested futures ...
> 
> for (strategy1 in strategies) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   for (strategy2 in strategies) {
+     message(sprintf("- plan(list('%s', '%s')) ...", strategy1, strategy2))
+     plan(list(a = strategy1, b = strategy2))
+     
+     nested <- plan("list")
+     stopifnot(
+       length(nested) == 2L,
+       all(names(nested) == c("a", "b")),
+       inherits(plan("next"), strategy1)
+     )
+ 
+     x %<-% {
+       a <- 1L
+ 
+       ## IMPORTANT: Use future::plan() - not just plan() - otherwise
+       ## we're exporting the plan() function including its local stack!
+       plan_a <- unclass(future::plan("list"))
+       nested_a <- nested[-1]
+ 
+       stopifnot(
+         length(nested_a) == 1L,
+         length(plan_a) == 1L,
+         inherits(plan_a[[1]], "future"),
+         inherits(future::plan("next"), strategy2)
+       )
+ 
+       ## Attribute 'init' is modified at run time
+       for (kk in seq_along(plan_a)) attr(plan_a[[kk]], "init") <- NULL
+       for (kk in seq_along(nested_a)) attr(nested_a[[kk]], "init") <- NULL
+       stopifnot(all.equal(plan_a, nested_a))
+ 
+       y %<-% {
+         b <- 2L
+         
+         ## IMPORTANT: Use future::plan() - not just plan() - otherwise
+         ## we're exporting the plan() function including its local stack!
+         plan_b <- future::plan("list")
+         nested_b <- nested_a[-1]
+ 
+         stopifnot(
+           length(nested_b) == 0L,
+           length(plan_b) == 1L,
+           inherits(plan_b[[1]], "future"),
+           inherits(future::plan("next"), "sequential")
+         )
+ 
+         list(a = a, nested_a = nested_a, plan_a = plan_a,
+              b = b, nested_b = nested_b, plan_b = plan_b)
+       }
+       y
+     }
+ 
+     str(x)
+ 
+     stopifnot(
+       length(x) == 3 * length(nested),
+       all(names(x) == c("a", "nested_a", "plan_a",
+                         "b", "nested_b", "plan_b")),
+ 
+       x$a == 1L,
+       length(x$nested_a) == 1L,
+       is.list(x$plan_a),
+       length(x$plan_a) == 1L,
+       inherits(x$plan_a[[1]], "future"),
+ 
+       x$b == 2L,
+       length(x$nested_b) == 0L,
+       is.list(x$plan_b),
+       length(x$plan_b) == 1L,
+       inherits(x$plan_b[[1]], "future"),
+       inherits(x$plan_b[[1]], "sequential")
+     )
+ 
+     ## Attribute 'init' is modified at run time
+     for (kk in seq_along(x$plan_a)) attr(x$plan_a[[kk]], "init") <- NULL
+     for (kk in seq_along(nested)) attr(nested[[kk]], "init") <- NULL
+     stopifnot(all.equal(x$plan_a, nested[-1L]))
+ 
+     rm(list = c("nested", "x"))
+ 
+ 
+     ## Nested futures and globals
+     ## In future (<= 1.7.0), the below would produce an error saying
+     ## "Failed to locate global object in the relevant environments: 'a'"
+     ## Related to https://github.com/HenrikBengtsson/globals/issues/35
+     data <- data.frame(a = 1:3, b = 3:1)
+     y_truth <- subset(data, a == 2)
+     f <- future({
+       value(future( subset(data, a == 2) ))
+     })
+     y <- value(f)
+     stopifnot(identical(y, y_truth))
+     
+     message(sprintf("- plan(list('%s', '%s')) ... DONE", strategy1, strategy2))
+   }
+ }
- plan(list('sequential', 'sequential')) ...
[08:28:38.261] plan(): Setting new future strategy stack:
[08:28:38.261] List of future strategies:
[08:28:38.261] 1. sequential:
[08:28:38.261]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:38.261]    - tweaked: FALSE
[08:28:38.261]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:38.261] 2. sequential:
[08:28:38.261]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:38.261]    - tweaked: FALSE
[08:28:38.261]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:38.274] plan(): nbrOfWorkers() = 1
[08:28:38.276] getGlobalsAndPackages() ...
[08:28:38.276] Searching for globals...
[08:28:38.299] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[08:28:38.299] Searching for globals ... DONE
[08:28:38.299] Resolving globals: FALSE
[08:28:38.301] The total size of the 2 globals is 3.28 KiB (3359 bytes)
[08:28:38.301] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 3.28 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (3.23 KiB of class ‘list’) and ‘strategy2’ (49 bytes of class ‘character’)
[08:28:38.301] - globals: [2] ‘nested’, ‘strategy2’
[08:28:38.301] - packages: [1] ‘future’
[08:28:38.301] getGlobalsAndPackages() ... DONE
[08:28:38.302] run() for ‘Future’ ...
[08:28:38.302] - state: ‘created’
[08:28:38.302] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:38.303] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:38.303] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:38.303]   - Field: ‘label’
[08:28:38.303]   - Field: ‘local’
[08:28:38.303]   - Field: ‘owner’
[08:28:38.303]   - Field: ‘envir’
[08:28:38.303]   - Field: ‘packages’
[08:28:38.303]   - Field: ‘gc’
[08:28:38.304]   - Field: ‘conditions’
[08:28:38.304]   - Field: ‘expr’
[08:28:38.304]   - Field: ‘uuid’
[08:28:38.304]   - Field: ‘seed’
[08:28:38.304]   - Field: ‘version’
[08:28:38.304]   - Field: ‘result’
[08:28:38.304]   - Field: ‘asynchronous’
[08:28:38.304]   - Field: ‘calls’
[08:28:38.304]   - Field: ‘globals’
[08:28:38.304]   - Field: ‘stdout’
[08:28:38.304]   - Field: ‘earlySignal’
[08:28:38.305]   - Field: ‘lazy’
[08:28:38.305]   - Field: ‘state’
[08:28:38.305] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:38.305] - Launch lazy future ...
[08:28:38.305] Packages needed by the future expression (n = 1): ‘future’
[08:28:38.306] Packages needed by future strategies (n = 1): ‘future’
[08:28:38.307] {
[08:28:38.307]     {
[08:28:38.307]         {
[08:28:38.307]             ...future.startTime <- base::Sys.time()
[08:28:38.307]             {
[08:28:38.307]                 {
[08:28:38.307]                   {
[08:28:38.307]                     {
[08:28:38.307]                       base::local({
[08:28:38.307]                         has_future <- base::requireNamespace("future", 
[08:28:38.307]                           quietly = TRUE)
[08:28:38.307]                         if (has_future) {
[08:28:38.307]                           ns <- base::getNamespace("future")
[08:28:38.307]                           version <- ns[[".package"]][["version"]]
[08:28:38.307]                           if (is.null(version)) 
[08:28:38.307]                             version <- utils::packageVersion("future")
[08:28:38.307]                         }
[08:28:38.307]                         else {
[08:28:38.307]                           version <- NULL
[08:28:38.307]                         }
[08:28:38.307]                         if (!has_future || version < "1.8.0") {
[08:28:38.307]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:38.307]                             "", base::R.version$version.string), 
[08:28:38.307]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:38.307]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:38.307]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:38.307]                               "release", "version")], collapse = " "), 
[08:28:38.307]                             hostname = base::Sys.info()[["nodename"]])
[08:28:38.307]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:38.307]                             info)
[08:28:38.307]                           info <- base::paste(info, collapse = "; ")
[08:28:38.307]                           if (!has_future) {
[08:28:38.307]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:38.307]                               info)
[08:28:38.307]                           }
[08:28:38.307]                           else {
[08:28:38.307]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:38.307]                               info, version)
[08:28:38.307]                           }
[08:28:38.307]                           base::stop(msg)
[08:28:38.307]                         }
[08:28:38.307]                       })
[08:28:38.307]                     }
[08:28:38.307]                     base::local({
[08:28:38.307]                       for (pkg in "future") {
[08:28:38.307]                         base::loadNamespace(pkg)
[08:28:38.307]                         base::library(pkg, character.only = TRUE)
[08:28:38.307]                       }
[08:28:38.307]                     })
[08:28:38.307]                   }
[08:28:38.307]                   ...future.strategy.old <- future::plan("list")
[08:28:38.307]                   options(future.plan = NULL)
[08:28:38.307]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:38.307]                   future::plan(list(b = function (..., envir = parent.frame()) 
[08:28:38.307]                   {
[08:28:38.307]                     future <- SequentialFuture(..., envir = envir)
[08:28:38.307]                     if (!future$lazy) 
[08:28:38.307]                       future <- run(future)
[08:28:38.307]                     invisible(future)
[08:28:38.307]                   }), .cleanup = FALSE, .init = FALSE)
[08:28:38.307]                 }
[08:28:38.307]                 ...future.workdir <- getwd()
[08:28:38.307]             }
[08:28:38.307]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:38.307]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:38.307]         }
[08:28:38.307]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:38.307]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:38.307]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:38.307]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:38.307]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:38.307]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:38.307]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:38.307]             base::names(...future.oldOptions))
[08:28:38.307]     }
[08:28:38.307]     if (FALSE) {
[08:28:38.307]     }
[08:28:38.307]     else {
[08:28:38.307]         if (TRUE) {
[08:28:38.307]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:38.307]                 open = "w")
[08:28:38.307]         }
[08:28:38.307]         else {
[08:28:38.307]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:38.307]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:38.307]         }
[08:28:38.307]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:38.307]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:38.307]             base::sink(type = "output", split = FALSE)
[08:28:38.307]             base::close(...future.stdout)
[08:28:38.307]         }, add = TRUE)
[08:28:38.307]     }
[08:28:38.307]     ...future.frame <- base::sys.nframe()
[08:28:38.307]     ...future.conditions <- base::list()
[08:28:38.307]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:38.307]     if (FALSE) {
[08:28:38.307]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:38.307]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:38.307]     }
[08:28:38.307]     ...future.result <- base::tryCatch({
[08:28:38.307]         base::withCallingHandlers({
[08:28:38.307]             ...future.value <- base::withVisible(base::local({
[08:28:38.307]                 a <- 1L
[08:28:38.307]                 plan_a <- unclass(future::plan("list"))
[08:28:38.307]                 nested_a <- nested[-1]
[08:28:38.307]                 stopifnot(length(nested_a) == 1L, length(plan_a) == 
[08:28:38.307]                   1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[08:28:38.307]                   strategy2))
[08:28:38.307]                 for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[08:28:38.307]                   "init") <- NULL
[08:28:38.307]                 for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[08:28:38.307]                   "init") <- NULL
[08:28:38.307]                 stopifnot(all.equal(plan_a, nested_a))
[08:28:38.307]                 y %<-% {
[08:28:38.307]                   b <- 2L
[08:28:38.307]                   plan_b <- future::plan("list")
[08:28:38.307]                   nested_b <- nested_a[-1]
[08:28:38.307]                   stopifnot(length(nested_b) == 0L, length(plan_b) == 
[08:28:38.307]                     1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[08:28:38.307]                     "sequential"))
[08:28:38.307]                   list(a = a, nested_a = nested_a, plan_a = plan_a, 
[08:28:38.307]                     b = b, nested_b = nested_b, plan_b = plan_b)
[08:28:38.307]                 }
[08:28:38.307]                 y
[08:28:38.307]             }))
[08:28:38.307]             future::FutureResult(value = ...future.value$value, 
[08:28:38.307]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:38.307]                   ...future.rng), globalenv = if (FALSE) 
[08:28:38.307]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:38.307]                     ...future.globalenv.names))
[08:28:38.307]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:38.307]         }, condition = base::local({
[08:28:38.307]             c <- base::c
[08:28:38.307]             inherits <- base::inherits
[08:28:38.307]             invokeRestart <- base::invokeRestart
[08:28:38.307]             length <- base::length
[08:28:38.307]             list <- base::list
[08:28:38.307]             seq.int <- base::seq.int
[08:28:38.307]             signalCondition <- base::signalCondition
[08:28:38.307]             sys.calls <- base::sys.calls
[08:28:38.307]             `[[` <- base::`[[`
[08:28:38.307]             `+` <- base::`+`
[08:28:38.307]             `<<-` <- base::`<<-`
[08:28:38.307]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:38.307]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:38.307]                   3L)]
[08:28:38.307]             }
[08:28:38.307]             function(cond) {
[08:28:38.307]                 is_error <- inherits(cond, "error")
[08:28:38.307]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:38.307]                   NULL)
[08:28:38.307]                 if (is_error) {
[08:28:38.307]                   sessionInformation <- function() {
[08:28:38.307]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:38.307]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:38.307]                       search = base::search(), system = base::Sys.info())
[08:28:38.307]                   }
[08:28:38.307]                   ...future.conditions[[length(...future.conditions) + 
[08:28:38.307]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:38.307]                     cond$call), session = sessionInformation(), 
[08:28:38.307]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:38.307]                   signalCondition(cond)
[08:28:38.307]                 }
[08:28:38.307]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:38.307]                 "immediateCondition"))) {
[08:28:38.307]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:38.307]                   ...future.conditions[[length(...future.conditions) + 
[08:28:38.307]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:38.307]                   if (TRUE && !signal) {
[08:28:38.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:38.307]                     {
[08:28:38.307]                       inherits <- base::inherits
[08:28:38.307]                       invokeRestart <- base::invokeRestart
[08:28:38.307]                       is.null <- base::is.null
[08:28:38.307]                       muffled <- FALSE
[08:28:38.307]                       if (inherits(cond, "message")) {
[08:28:38.307]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:38.307]                         if (muffled) 
[08:28:38.307]                           invokeRestart("muffleMessage")
[08:28:38.307]                       }
[08:28:38.307]                       else if (inherits(cond, "warning")) {
[08:28:38.307]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:38.307]                         if (muffled) 
[08:28:38.307]                           invokeRestart("muffleWarning")
[08:28:38.307]                       }
[08:28:38.307]                       else if (inherits(cond, "condition")) {
[08:28:38.307]                         if (!is.null(pattern)) {
[08:28:38.307]                           computeRestarts <- base::computeRestarts
[08:28:38.307]                           grepl <- base::grepl
[08:28:38.307]                           restarts <- computeRestarts(cond)
[08:28:38.307]                           for (restart in restarts) {
[08:28:38.307]                             name <- restart$name
[08:28:38.307]                             if (is.null(name)) 
[08:28:38.307]                               next
[08:28:38.307]                             if (!grepl(pattern, name)) 
[08:28:38.307]                               next
[08:28:38.307]                             invokeRestart(restart)
[08:28:38.307]                             muffled <- TRUE
[08:28:38.307]                             break
[08:28:38.307]                           }
[08:28:38.307]                         }
[08:28:38.307]                       }
[08:28:38.307]                       invisible(muffled)
[08:28:38.307]                     }
[08:28:38.307]                     muffleCondition(cond, pattern = "^muffle")
[08:28:38.307]                   }
[08:28:38.307]                 }
[08:28:38.307]                 else {
[08:28:38.307]                   if (TRUE) {
[08:28:38.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:38.307]                     {
[08:28:38.307]                       inherits <- base::inherits
[08:28:38.307]                       invokeRestart <- base::invokeRestart
[08:28:38.307]                       is.null <- base::is.null
[08:28:38.307]                       muffled <- FALSE
[08:28:38.307]                       if (inherits(cond, "message")) {
[08:28:38.307]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:38.307]                         if (muffled) 
[08:28:38.307]                           invokeRestart("muffleMessage")
[08:28:38.307]                       }
[08:28:38.307]                       else if (inherits(cond, "warning")) {
[08:28:38.307]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:38.307]                         if (muffled) 
[08:28:38.307]                           invokeRestart("muffleWarning")
[08:28:38.307]                       }
[08:28:38.307]                       else if (inherits(cond, "condition")) {
[08:28:38.307]                         if (!is.null(pattern)) {
[08:28:38.307]                           computeRestarts <- base::computeRestarts
[08:28:38.307]                           grepl <- base::grepl
[08:28:38.307]                           restarts <- computeRestarts(cond)
[08:28:38.307]                           for (restart in restarts) {
[08:28:38.307]                             name <- restart$name
[08:28:38.307]                             if (is.null(name)) 
[08:28:38.307]                               next
[08:28:38.307]                             if (!grepl(pattern, name)) 
[08:28:38.307]                               next
[08:28:38.307]                             invokeRestart(restart)
[08:28:38.307]                             muffled <- TRUE
[08:28:38.307]                             break
[08:28:38.307]                           }
[08:28:38.307]                         }
[08:28:38.307]                       }
[08:28:38.307]                       invisible(muffled)
[08:28:38.307]                     }
[08:28:38.307]                     muffleCondition(cond, pattern = "^muffle")
[08:28:38.307]                   }
[08:28:38.307]                 }
[08:28:38.307]             }
[08:28:38.307]         }))
[08:28:38.307]     }, error = function(ex) {
[08:28:38.307]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:38.307]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:38.307]                 ...future.rng), started = ...future.startTime, 
[08:28:38.307]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:38.307]             version = "1.8"), class = "FutureResult")
[08:28:38.307]     }, finally = {
[08:28:38.307]         if (!identical(...future.workdir, getwd())) 
[08:28:38.307]             setwd(...future.workdir)
[08:28:38.307]         {
[08:28:38.307]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:38.307]                 ...future.oldOptions$nwarnings <- NULL
[08:28:38.307]             }
[08:28:38.307]             base::options(...future.oldOptions)
[08:28:38.307]             if (.Platform$OS.type == "windows") {
[08:28:38.307]                 old_names <- names(...future.oldEnvVars)
[08:28:38.307]                 envs <- base::Sys.getenv()
[08:28:38.307]                 names <- names(envs)
[08:28:38.307]                 common <- intersect(names, old_names)
[08:28:38.307]                 added <- setdiff(names, old_names)
[08:28:38.307]                 removed <- setdiff(old_names, names)
[08:28:38.307]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:38.307]                   envs[common]]
[08:28:38.307]                 NAMES <- toupper(changed)
[08:28:38.307]                 args <- list()
[08:28:38.307]                 for (kk in seq_along(NAMES)) {
[08:28:38.307]                   name <- changed[[kk]]
[08:28:38.307]                   NAME <- NAMES[[kk]]
[08:28:38.307]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:38.307]                     next
[08:28:38.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:38.307]                 }
[08:28:38.307]                 NAMES <- toupper(added)
[08:28:38.307]                 for (kk in seq_along(NAMES)) {
[08:28:38.307]                   name <- added[[kk]]
[08:28:38.307]                   NAME <- NAMES[[kk]]
[08:28:38.307]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:38.307]                     next
[08:28:38.307]                   args[[name]] <- ""
[08:28:38.307]                 }
[08:28:38.307]                 NAMES <- toupper(removed)
[08:28:38.307]                 for (kk in seq_along(NAMES)) {
[08:28:38.307]                   name <- removed[[kk]]
[08:28:38.307]                   NAME <- NAMES[[kk]]
[08:28:38.307]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:38.307]                     next
[08:28:38.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:38.307]                 }
[08:28:38.307]                 if (length(args) > 0) 
[08:28:38.307]                   base::do.call(base::Sys.setenv, args = args)
[08:28:38.307]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:38.307]             }
[08:28:38.307]             else {
[08:28:38.307]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:38.307]             }
[08:28:38.307]             {
[08:28:38.307]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:38.307]                   0L) {
[08:28:38.307]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:38.307]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:38.307]                   base::options(opts)
[08:28:38.307]                 }
[08:28:38.307]                 {
[08:28:38.307]                   {
[08:28:38.307]                     NULL
[08:28:38.307]                     RNGkind("Mersenne-Twister")
[08:28:38.307]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:38.307]                       inherits = FALSE)
[08:28:38.307]                   }
[08:28:38.307]                   options(future.plan = NULL)
[08:28:38.307]                   if (is.na(NA_character_)) 
[08:28:38.307]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:38.307]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:38.307]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:38.307]                     .init = FALSE)
[08:28:38.307]                 }
[08:28:38.307]             }
[08:28:38.307]         }
[08:28:38.307]     })
[08:28:38.307]     if (TRUE) {
[08:28:38.307]         base::sink(type = "output", split = FALSE)
[08:28:38.307]         if (TRUE) {
[08:28:38.307]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:38.307]         }
[08:28:38.307]         else {
[08:28:38.307]             ...future.result["stdout"] <- base::list(NULL)
[08:28:38.307]         }
[08:28:38.307]         base::close(...future.stdout)
[08:28:38.307]         ...future.stdout <- NULL
[08:28:38.307]     }
[08:28:38.307]     ...future.result$conditions <- ...future.conditions
[08:28:38.307]     ...future.result$finished <- base::Sys.time()
[08:28:38.307]     ...future.result
[08:28:38.307] }
[08:28:38.309] assign_globals() ...
[08:28:38.309] List of 2
[08:28:38.309]  $ nested   :List of 2
[08:28:38.309]   ..$ a:function (..., envir = parent.frame())  
[08:28:38.309]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[08:28:38.309]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[08:28:38.309]   ..$ b:function (..., envir = parent.frame())  
[08:28:38.309]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[08:28:38.309]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[08:28:38.309]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[08:28:38.309]  $ strategy2: chr "sequential"
[08:28:38.309]  - attr(*, "where")=List of 2
[08:28:38.309]   ..$ nested   :<environment: R_EmptyEnv> 
[08:28:38.309]   ..$ strategy2:<environment: R_EmptyEnv> 
[08:28:38.309]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:38.309]  - attr(*, "resolved")= logi FALSE
[08:28:38.309]  - attr(*, "total_size")= num 3359
[08:28:38.309]  - attr(*, "already-done")= logi TRUE
[08:28:38.315] - copied ‘nested’ to environment
[08:28:38.316] - copied ‘strategy2’ to environment
[08:28:38.316] assign_globals() ... done
[08:28:38.316] plan(): Setting new future strategy stack:
[08:28:38.316] List of future strategies:
[08:28:38.316] 1. sequential:
[08:28:38.316]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:38.316]    - tweaked: FALSE
[08:28:38.316]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:38.317] plan(): nbrOfWorkers() = 1
[08:28:38.358] plan(): Setting new future strategy stack:
[08:28:38.358] List of future strategies:
[08:28:38.358] 1. sequential:
[08:28:38.358]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:38.358]    - tweaked: FALSE
[08:28:38.358]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:38.358] 2. sequential:
[08:28:38.358]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:38.358]    - tweaked: FALSE
[08:28:38.358]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:38.359] plan(): nbrOfWorkers() = 1
[08:28:38.359] SequentialFuture started (and completed)
[08:28:38.359] signalConditions() ...
[08:28:38.359]  - include = ‘immediateCondition’
[08:28:38.359]  - exclude = 
[08:28:38.359]  - resignal = FALSE
[08:28:38.359]  - Number of conditions: 54
[08:28:38.359] signalConditions() ... done
[08:28:38.359] - Launch lazy future ... done
[08:28:38.359] run() for ‘SequentialFuture’ ... done
[08:28:38.360] signalConditions() ...
[08:28:38.360]  - include = ‘immediateCondition’
[08:28:38.360]  - exclude = 
[08:28:38.360]  - resignal = FALSE
[08:28:38.360]  - Number of conditions: 54
[08:28:38.360] signalConditions() ... done
[08:28:38.360] Future state: ‘finished’
[08:28:38.360] signalConditions() ...
[08:28:38.360]  - include = ‘condition’
[08:28:38.361]  - exclude = ‘immediateCondition’
[08:28:38.361]  - resignal = TRUE
[08:28:38.361]  - Number of conditions: 54
[08:28:38.361]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.318] getGlobalsAndPackages() ...
[08:28:38.361]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.318] Searching for globals...
[08:28:38.361]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.339] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[08:28:38.361]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.339] Searching for globals ... DONE
[08:28:38.361]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.339] Resolving globals: FALSE
[08:28:38.361]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.340] The total size of the 3 globals is 3.58 KiB (3661 bytes)
[08:28:38.362]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.340] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 3.58 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (1.77 KiB of class ‘list’), ‘plan_a’ (1.77 KiB of class ‘list’) and ‘a’ (35 bytes of class ‘numeric’)
[08:28:38.362]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.340] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[08:28:38.362]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.340] 
[08:28:38.362]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.341] getGlobalsAndPackages() ... DONE
[08:28:38.362]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.341] run() for ‘Future’ ...
[08:28:38.362]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.341] - state: ‘created’
[08:28:38.362]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.341] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:38.362]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.341] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:38.363]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.342] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:38.363]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.342]   - Field: ‘label’
[08:28:38.363]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.342]   - Field: ‘local’
[08:28:38.363]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.342]   - Field: ‘owner’
[08:28:38.363]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.342]   - Field: ‘envir’
[08:28:38.363]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.342]   - Field: ‘packages’
[08:28:38.363]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.342]   - Field: ‘gc’
[08:28:38.363]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.342]   - Field: ‘conditions’
[08:28:38.364]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.343]   - Field: ‘expr’
[08:28:38.364]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.343]   - Field: ‘uuid’
[08:28:38.364]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.343]   - Field: ‘seed’
[08:28:38.364]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.343]   - Field: ‘version’
[08:28:38.364]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.343]   - Field: ‘result’
[08:28:38.364]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.343]   - Field: ‘asynchronous’
[08:28:38.364]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.343]   - Field: ‘calls’
[08:28:38.364]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.343]   - Field: ‘globals’
[08:28:38.364]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.343]   - Field: ‘stdout’
[08:28:38.365]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.343]   - Field: ‘earlySignal’
[08:28:38.365]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.344]   - Field: ‘lazy’
[08:28:38.365]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.344]   - Field: ‘state’
[08:28:38.365]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.344] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:38.365]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.344] - Launch lazy future ...
[08:28:38.365]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.344] Packages needed by the future expression (n = 0): <none>
[08:28:38.365]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.344] Packages needed by future strategies (n = 0): <none>
[08:28:38.365]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.345] {
[08:28:38.345]     {
[08:28:38.345]         {
[08:28:38.345]             ...future.startTime <- base::Sys.time()
[08:28:38.345]             {
[08:28:38.345]                 {
[08:28:38.345]                   {
[08:28:38.345]                     base::local({
[08:28:38.345]                       has_future <- base::requireNamespace("future", 
[08:28:38.345]                         quietly = TRUE)
[08:28:38.345]                       if (has_future) {
[08:28:38.345]                         ns <- base::getNamespace("future")
[08:28:38.345]                         version <- ns[[".package"]][["version"]]
[08:28:38.345]                         if (is.null(version)) 
[08:28:38.345]                           version <- utils::packageVersion("future")
[08:28:38.345]                       }
[08:28:38.345]                       else {
[08:28:38.345]                         version <- NULL
[08:28:38.345]                       }
[08:28:38.345]                       if (!has_future || version < "1.8.0") {
[08:28:38.345]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:38.345]                           "", base::R.version$version.string), 
[08:28:38.345]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:38.345]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:38.345]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:38.345]                             "release", "version")], collapse = " "), 
[08:28:38.345]                           hostname = base::Sys.info()[["nodename"]])
[08:28:38.345]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:38.345]                           info)
[08:28:38.345]                         info <- base::paste(info, collapse = "; ")
[08:28:38.345]                         if (!has_future) {
[08:28:38.345]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:38.345]                             info)
[08:28:38.345]                         }
[08:28:38.345]                         else {
[08:28:38.345]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:38.345]                             info, version)
[08:28:38.345]                         }
[08:28:38.345]                         base::stop(msg)
[08:28:38.345]                       }
[08:28:38.345]                     })
[08:28:38.345]                   }
[08:28:38.345]                   ...future.strategy.old <- future::plan("list")
[08:28:38.345]                   options(future.plan = NULL)
[08:28:38.345]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:38.345]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:38.345]                 }
[08:28:38.345]                 ...future.workdir <- getwd()
[08:28:38.345]             }
[08:28:38.345]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:38.345]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:38.345]         }
[08:28:38.345]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:38.345]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:38.345]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:38.345]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:38.345]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:38.345]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:38.345]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:38.345]             base::names(...future.oldOptions))
[08:28:38.345]     }
[08:28:38.345]     if (FALSE) {
[08:28:38.345]     }
[08:28:38.345]     else {
[08:28:38.345]         if (TRUE) {
[08:28:38.345]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:38.345]                 open = "w")
[08:28:38.345]         }
[08:28:38.345]         else {
[08:28:38.345]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:38.345]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:38.345]         }
[08:28:38.345]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:38.345]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:38.345]             base::sink(type = "output", split = FALSE)
[08:28:38.345]             base::close(...future.stdout)
[08:28:38.345]         }, add = TRUE)
[08:28:38.345]     }
[08:28:38.345]     ...future.frame <- base::sys.nframe()
[08:28:38.345]     ...future.conditions <- base::list()
[08:28:38.345]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:38.345]     if (FALSE) {
[08:28:38.345]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:38.345]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:38.345]     }
[08:28:38.345]     ...future.result <- base::tryCatch({
[08:28:38.345]         base::withCallingHandlers({
[08:28:38.345]             ...future.value <- base::withVisible(base::local({
[08:28:38.345]                 b <- 2L
[08:28:38.345]                 plan_b <- future::plan("list")
[08:28:38.345]                 nested_b <- nested_a[-1]
[08:28:38.345]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[08:28:38.345]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[08:28:38.345]                   "sequential"))
[08:28:38.345]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[08:28:38.345]                   b = b, nested_b = nested_b, plan_b = plan_b)
[08:28:38.345]             }))
[08:28:38.345]             future::FutureResult(value = ...future.value$value, 
[08:28:38.345]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:38.345]                   ...future.rng), globalenv = if (FALSE) 
[08:28:38.345]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:38.345]                     ...future.globalenv.names))
[08:28:38.345]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:38.345]         }, condition = base::local({
[08:28:38.345]             c <- base::c
[08:28:38.345]             inherits <- base::inherits
[08:28:38.345]             invokeRestart <- base::invokeRestart
[08:28:38.345]             length <- base::length
[08:28:38.345]             list <- base::list
[08:28:38.345]             seq.int <- base::seq.int
[08:28:38.345]             signalCondition <- base::signalCondition
[08:28:38.345]             sys.calls <- base::sys.calls
[08:28:38.345]             `[[` <- base::`[[`
[08:28:38.345]             `+` <- base::`+`
[08:28:38.345]             `<<-` <- base::`<<-`
[08:28:38.345]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:38.345]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:38.345]                   3L)]
[08:28:38.345]             }
[08:28:38.345]             function(cond) {
[08:28:38.345]                 is_error <- inherits(cond, "error")
[08:28:38.345]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:38.345]                   NULL)
[08:28:38.345]                 if (is_error) {
[08:28:38.345]                   sessionInformation <- function() {
[08:28:38.345]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:38.345]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:38.345]                       search = base::search(), system = base::Sys.info())
[08:28:38.345]                   }
[08:28:38.345]                   ...future.conditions[[length(...future.conditions) + 
[08:28:38.345]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:38.345]                     cond$call), session = sessionInformation(), 
[08:28:38.345]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:38.345]                   signalCondition(cond)
[08:28:38.345]                 }
[08:28:38.345]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:38.345]                 "immediateCondition"))) {
[08:28:38.345]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:38.345]                   ...future.conditions[[length(...future.conditions) + 
[08:28:38.345]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:38.345]                   if (TRUE && !signal) {
[08:28:38.345]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:38.345]                     {
[08:28:38.345]                       inherits <- base::inherits
[08:28:38.345]                       invokeRestart <- base::invokeRestart
[08:28:38.345]                       is.null <- base::is.null
[08:28:38.345]                       muffled <- FALSE
[08:28:38.345]                       if (inherits(cond, "message")) {
[08:28:38.345]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:38.345]                         if (muffled) 
[08:28:38.345]                           invokeRestart("muffleMessage")
[08:28:38.345]                       }
[08:28:38.345]                       else if (inherits(cond, "warning")) {
[08:28:38.345]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:38.345]                         if (muffled) 
[08:28:38.345]                           invokeRestart("muffleWarning")
[08:28:38.345]                       }
[08:28:38.345]                       else if (inherits(cond, "condition")) {
[08:28:38.345]                         if (!is.null(pattern)) {
[08:28:38.345]                           computeRestarts <- base::computeRestarts
[08:28:38.345]                           grepl <- base::grepl
[08:28:38.345]                           restarts <- computeRestarts(cond)
[08:28:38.345]                           for (restart in restarts) {
[08:28:38.345]                             name <- restart$name
[08:28:38.345]                             if (is.null(name)) 
[08:28:38.345]                               next
[08:28:38.345]                             if (!grepl(pattern, name)) 
[08:28:38.345]                               next
[08:28:38.345]                             invokeRestart(restart)
[08:28:38.345]                             muffled <- TRUE
[08:28:38.345]                             break
[08:28:38.345]                           }
[08:28:38.345]                         }
[08:28:38.345]                       }
[08:28:38.345]                       invisible(muffled)
[08:28:38.345]                     }
[08:28:38.345]                     muffleCondition(cond, pattern = "^muffle")
[08:28:38.345]                   }
[08:28:38.345]                 }
[08:28:38.345]                 else {
[08:28:38.345]                   if (TRUE) {
[08:28:38.345]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:38.345]                     {
[08:28:38.345]                       inherits <- base::inherits
[08:28:38.345]                       invokeRestart <- base::invokeRestart
[08:28:38.345]                       is.null <- base::is.null
[08:28:38.345]                       muffled <- FALSE
[08:28:38.345]                       if (inherits(cond, "message")) {
[08:28:38.345]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:38.345]                         if (muffled) 
[08:28:38.345]                           invokeRestart("muffleMessage")
[08:28:38.345]                       }
[08:28:38.345]                       else if (inherits(cond, "warning")) {
[08:28:38.345]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:38.345]                         if (muffled) 
[08:28:38.345]                           invokeRestart("muffleWarning")
[08:28:38.345]                       }
[08:28:38.345]                       else if (inherits(cond, "condition")) {
[08:28:38.345]                         if (!is.null(pattern)) {
[08:28:38.345]                           computeRestarts <- base::computeRestarts
[08:28:38.345]                           grepl <- base::grepl
[08:28:38.345]                           restarts <- computeRestarts(cond)
[08:28:38.345]                           for (restart in restarts) {
[08:28:38.345]                             name <- restart$name
[08:28:38.345]                             if (is.null(name)) 
[08:28:38.345]                               next
[08:28:38.345]                             if (!grepl(pattern, name)) 
[08:28:38.345]                               next
[08:28:38.345]                             invokeRestart(restart)
[08:28:38.345]                             muffled <- TRUE
[08:28:38.345]                             break
[08:28:38.345]                           }
[08:28:38.345]                         }
[08:28:38.345]                       }
[08:28:38.345]                       invisible(muffled)
[08:28:38.345]                     }
[08:28:38.345]                     muffleCondition(cond, pattern = "^muffle")
[08:28:38.345]                   }
[08:28:38.345]                 }
[08:28:38.345]             }
[08:28:38.345]         }))
[08:28:38.345]     }, error = function(ex) {
[08:28:38.345]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:38.345]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:38.345]                 ...future.rng), started = ...future.startTime, 
[08:28:38.345]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:38.345]             version = "1.8"), class = "FutureResult")
[08:28:38.345]     }, finally = {
[08:28:38.345]         if (!identical(...future.workdir, getwd())) 
[08:28:38.345]             setwd(...future.workdir)
[08:28:38.345]         {
[08:28:38.345]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:38.345]                 ...future.oldOptions$nwarnings <- NULL
[08:28:38.345]             }
[08:28:38.345]             base::options(...future.oldOptions)
[08:28:38.345]             if (.Platform$OS.type == "windows") {
[08:28:38.345]                 old_names <- names(...future.oldEnvVars)
[08:28:38.345]                 envs <- base::Sys.getenv()
[08:28:38.345]                 names <- names(envs)
[08:28:38.345]                 common <- intersect(names, old_names)
[08:28:38.345]                 added <- setdiff(names, old_names)
[08:28:38.345]                 removed <- setdiff(old_names, names)
[08:28:38.345]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:38.345]                   envs[common]]
[08:28:38.345]                 NAMES <- toupper(changed)
[08:28:38.345]                 args <- list()
[08:28:38.345]                 for (kk in seq_along(NAMES)) {
[08:28:38.345]                   name <- changed[[kk]]
[08:28:38.345]                   NAME <- NAMES[[kk]]
[08:28:38.345]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:38.345]                     next
[08:28:38.345]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:38.345]                 }
[08:28:38.345]                 NAMES <- toupper(added)
[08:28:38.345]                 for (kk in seq_along(NAMES)) {
[08:28:38.345]                   name <- added[[kk]]
[08:28:38.345]                   NAME <- NAMES[[kk]]
[08:28:38.345]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:38.345]                     next
[08:28:38.345]                   args[[name]] <- ""
[08:28:38.345]                 }
[08:28:38.345]                 NAMES <- toupper(removed)
[08:28:38.345]                 for (kk in seq_along(NAMES)) {
[08:28:38.345]                   name <- removed[[kk]]
[08:28:38.345]                   NAME <- NAMES[[kk]]
[08:28:38.345]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:38.345]                     next
[08:28:38.345]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:38.345]                 }
[08:28:38.345]                 if (length(args) > 0) 
[08:28:38.345]                   base::do.call(base::Sys.setenv, args = args)
[08:28:38.345]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:38.345]             }
[08:28:38.345]             else {
[08:28:38.345]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:38.345]             }
[08:28:38.345]             {
[08:28:38.345]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:38.345]                   0L) {
[08:28:38.345]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:38.345]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:38.345]                   base::options(opts)
[08:28:38.345]                 }
[08:28:38.345]                 {
[08:28:38.345]                   {
[08:28:38.345]                     NULL
[08:28:38.345]                     RNGkind("Mersenne-Twister")
[08:28:38.345]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:38.345]                       inherits = FALSE)
[08:28:38.345]                   }
[08:28:38.345]                   options(future.plan = NULL)
[08:28:38.345]                   if (is.na(NA_character_)) 
[08:28:38.345]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:38.345]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:38.345]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:38.345]                     .init = FALSE)
[08:28:38.345]                 }
[08:28:38.345]             }
[08:28:38.345]         }
[08:28:38.345]     })
[08:28:38.345]     if (TRUE) {
[08:28:38.345]         base::sink(type = "output", split = FALSE)
[08:28:38.345]         if (TRUE) {
[08:28:38.345]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:38.345]         }
[08:28:38.345]         else {
[08:28:38.345]             ...future.result["stdout"] <- base::list(NULL)
[08:28:38.345]         }
[08:28:38.345]         base::close(...future.stdout)
[08:28:38.345]         ...future.stdout <- NULL
[08:28:38.345]     }
[08:28:38.345]     ...future.result$conditions <- ...future.conditions
[08:28:38.345]     ...future.result$finished <- base::Sys.time()
[08:28:38.345]     ...future.result
[08:28:38.345] }
[08:28:38.366]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.346] assign_globals() ...
[08:28:38.366]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.346] List of 3
[08:28:38.346]  $ nested_a:List of 1
[08:28:38.346]   ..$ b:function (..., envir = parent.frame())  
[08:28:38.346]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[08:28:38.346]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[08:28:38.346]  $ a       : int 1
[08:28:38.346]  $ plan_a  :List of 1
[08:28:38.346]   ..$ b:function (..., envir = parent.frame())  
[08:28:38.346]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[08:28:38.346]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[08:28:38.346]  - attr(*, "where")=List of 3
[08:28:38.346]   ..$ nested_a:<environment: R_EmptyEnv> 
[08:28:38.346]   ..$ a       :<environment: R_EmptyEnv> 
[08:28:38.346]   ..$ plan_a  :<environment: R_EmptyEnv> 
[08:28:38.346]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:38.346]  - attr(*, "resolved")= logi FALSE
[08:28:38.346]  - attr(*, "total_size")= num 3661
[08:28:38.346]  - attr(*, "already-done")= logi TRUE
[08:28:38.366]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.353] - copied ‘nested_a’ to environment
[08:28:38.366]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.353] - copied ‘a’ to environment
[08:28:38.366]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.353] - copied ‘plan_a’ to environment
[08:28:38.366]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.354] assign_globals() ... done
[08:28:38.367]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.354] plan(): Setting new future strategy stack:
[08:28:38.367]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.354] List of future strategies:
[08:28:38.354] 1. sequential:
[08:28:38.354]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:38.354]    - tweaked: FALSE
[08:28:38.354]    - call: NULL
[08:28:38.367]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.354] plan(): nbrOfWorkers() = 1
[08:28:38.367]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.356] plan(): Setting new future strategy stack:
[08:28:38.367]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.356] List of future strategies:
[08:28:38.356] 1. sequential:
[08:28:38.356]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:38.356]    - tweaked: FALSE
[08:28:38.356]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:38.367]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.356] plan(): nbrOfWorkers() = 1
[08:28:38.367]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.356] SequentialFuture started (and completed)
[08:28:38.367]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.357] - Launch lazy future ... done
[08:28:38.368]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.357] run() for ‘SequentialFuture’ ... done
[08:28:38.368] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[08:28:38.372] getGlobalsAndPackages() ...
[08:28:38.373] Searching for globals...
[08:28:38.374] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[08:28:38.374] Searching for globals ... DONE
[08:28:38.374] Resolving globals: FALSE
[08:28:38.375] The total size of the 1 globals is 356 bytes (356 bytes)
[08:28:38.375] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[08:28:38.375] - globals: [1] ‘data’
[08:28:38.375] - packages: [1] ‘future’
[08:28:38.375] getGlobalsAndPackages() ... DONE
[08:28:38.376] run() for ‘Future’ ...
[08:28:38.376] - state: ‘created’
[08:28:38.376] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:38.378] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:38.378] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:38.378]   - Field: ‘label’
[08:28:38.378]   - Field: ‘local’
[08:28:38.378]   - Field: ‘owner’
[08:28:38.378]   - Field: ‘envir’
[08:28:38.378]   - Field: ‘packages’
[08:28:38.379]   - Field: ‘gc’
[08:28:38.379]   - Field: ‘conditions’
[08:28:38.379]   - Field: ‘expr’
[08:28:38.379]   - Field: ‘uuid’
[08:28:38.379]   - Field: ‘seed’
[08:28:38.379]   - Field: ‘version’
[08:28:38.379]   - Field: ‘result’
[08:28:38.379]   - Field: ‘asynchronous’
[08:28:38.379]   - Field: ‘calls’
[08:28:38.379]   - Field: ‘globals’
[08:28:38.379]   - Field: ‘stdout’
[08:28:38.379]   - Field: ‘earlySignal’
[08:28:38.380]   - Field: ‘lazy’
[08:28:38.380]   - Field: ‘state’
[08:28:38.380] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:38.380] - Launch lazy future ...
[08:28:38.380] Packages needed by the future expression (n = 1): ‘future’
[08:28:38.380] Packages needed by future strategies (n = 1): ‘future’
[08:28:38.381] {
[08:28:38.381]     {
[08:28:38.381]         {
[08:28:38.381]             ...future.startTime <- base::Sys.time()
[08:28:38.381]             {
[08:28:38.381]                 {
[08:28:38.381]                   {
[08:28:38.381]                     {
[08:28:38.381]                       base::local({
[08:28:38.381]                         has_future <- base::requireNamespace("future", 
[08:28:38.381]                           quietly = TRUE)
[08:28:38.381]                         if (has_future) {
[08:28:38.381]                           ns <- base::getNamespace("future")
[08:28:38.381]                           version <- ns[[".package"]][["version"]]
[08:28:38.381]                           if (is.null(version)) 
[08:28:38.381]                             version <- utils::packageVersion("future")
[08:28:38.381]                         }
[08:28:38.381]                         else {
[08:28:38.381]                           version <- NULL
[08:28:38.381]                         }
[08:28:38.381]                         if (!has_future || version < "1.8.0") {
[08:28:38.381]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:38.381]                             "", base::R.version$version.string), 
[08:28:38.381]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:38.381]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:38.381]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:38.381]                               "release", "version")], collapse = " "), 
[08:28:38.381]                             hostname = base::Sys.info()[["nodename"]])
[08:28:38.381]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:38.381]                             info)
[08:28:38.381]                           info <- base::paste(info, collapse = "; ")
[08:28:38.381]                           if (!has_future) {
[08:28:38.381]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:38.381]                               info)
[08:28:38.381]                           }
[08:28:38.381]                           else {
[08:28:38.381]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:38.381]                               info, version)
[08:28:38.381]                           }
[08:28:38.381]                           base::stop(msg)
[08:28:38.381]                         }
[08:28:38.381]                       })
[08:28:38.381]                     }
[08:28:38.381]                     base::local({
[08:28:38.381]                       for (pkg in "future") {
[08:28:38.381]                         base::loadNamespace(pkg)
[08:28:38.381]                         base::library(pkg, character.only = TRUE)
[08:28:38.381]                       }
[08:28:38.381]                     })
[08:28:38.381]                   }
[08:28:38.381]                   ...future.strategy.old <- future::plan("list")
[08:28:38.381]                   options(future.plan = NULL)
[08:28:38.381]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:38.381]                   future::plan(list(b = function (..., envir = parent.frame()) 
[08:28:38.381]                   {
[08:28:38.381]                     future <- SequentialFuture(..., envir = envir)
[08:28:38.381]                     if (!future$lazy) 
[08:28:38.381]                       future <- run(future)
[08:28:38.381]                     invisible(future)
[08:28:38.381]                   }), .cleanup = FALSE, .init = FALSE)
[08:28:38.381]                 }
[08:28:38.381]                 ...future.workdir <- getwd()
[08:28:38.381]             }
[08:28:38.381]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:38.381]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:38.381]         }
[08:28:38.381]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:38.381]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:38.381]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:38.381]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:38.381]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:38.381]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:38.381]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:38.381]             base::names(...future.oldOptions))
[08:28:38.381]     }
[08:28:38.381]     if (FALSE) {
[08:28:38.381]     }
[08:28:38.381]     else {
[08:28:38.381]         if (TRUE) {
[08:28:38.381]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:38.381]                 open = "w")
[08:28:38.381]         }
[08:28:38.381]         else {
[08:28:38.381]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:38.381]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:38.381]         }
[08:28:38.381]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:38.381]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:38.381]             base::sink(type = "output", split = FALSE)
[08:28:38.381]             base::close(...future.stdout)
[08:28:38.381]         }, add = TRUE)
[08:28:38.381]     }
[08:28:38.381]     ...future.frame <- base::sys.nframe()
[08:28:38.381]     ...future.conditions <- base::list()
[08:28:38.381]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:38.381]     if (FALSE) {
[08:28:38.381]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:38.381]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:38.381]     }
[08:28:38.381]     ...future.result <- base::tryCatch({
[08:28:38.381]         base::withCallingHandlers({
[08:28:38.381]             ...future.value <- base::withVisible(base::local({
[08:28:38.381]                 value(future(subset(data, a == 2)))
[08:28:38.381]             }))
[08:28:38.381]             future::FutureResult(value = ...future.value$value, 
[08:28:38.381]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:38.381]                   ...future.rng), globalenv = if (FALSE) 
[08:28:38.381]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:38.381]                     ...future.globalenv.names))
[08:28:38.381]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:38.381]         }, condition = base::local({
[08:28:38.381]             c <- base::c
[08:28:38.381]             inherits <- base::inherits
[08:28:38.381]             invokeRestart <- base::invokeRestart
[08:28:38.381]             length <- base::length
[08:28:38.381]             list <- base::list
[08:28:38.381]             seq.int <- base::seq.int
[08:28:38.381]             signalCondition <- base::signalCondition
[08:28:38.381]             sys.calls <- base::sys.calls
[08:28:38.381]             `[[` <- base::`[[`
[08:28:38.381]             `+` <- base::`+`
[08:28:38.381]             `<<-` <- base::`<<-`
[08:28:38.381]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:38.381]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:38.381]                   3L)]
[08:28:38.381]             }
[08:28:38.381]             function(cond) {
[08:28:38.381]                 is_error <- inherits(cond, "error")
[08:28:38.381]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:38.381]                   NULL)
[08:28:38.381]                 if (is_error) {
[08:28:38.381]                   sessionInformation <- function() {
[08:28:38.381]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:38.381]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:38.381]                       search = base::search(), system = base::Sys.info())
[08:28:38.381]                   }
[08:28:38.381]                   ...future.conditions[[length(...future.conditions) + 
[08:28:38.381]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:38.381]                     cond$call), session = sessionInformation(), 
[08:28:38.381]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:38.381]                   signalCondition(cond)
[08:28:38.381]                 }
[08:28:38.381]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:38.381]                 "immediateCondition"))) {
[08:28:38.381]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:38.381]                   ...future.conditions[[length(...future.conditions) + 
[08:28:38.381]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:38.381]                   if (TRUE && !signal) {
[08:28:38.381]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:38.381]                     {
[08:28:38.381]                       inherits <- base::inherits
[08:28:38.381]                       invokeRestart <- base::invokeRestart
[08:28:38.381]                       is.null <- base::is.null
[08:28:38.381]                       muffled <- FALSE
[08:28:38.381]                       if (inherits(cond, "message")) {
[08:28:38.381]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:38.381]                         if (muffled) 
[08:28:38.381]                           invokeRestart("muffleMessage")
[08:28:38.381]                       }
[08:28:38.381]                       else if (inherits(cond, "warning")) {
[08:28:38.381]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:38.381]                         if (muffled) 
[08:28:38.381]                           invokeRestart("muffleWarning")
[08:28:38.381]                       }
[08:28:38.381]                       else if (inherits(cond, "condition")) {
[08:28:38.381]                         if (!is.null(pattern)) {
[08:28:38.381]                           computeRestarts <- base::computeRestarts
[08:28:38.381]                           grepl <- base::grepl
[08:28:38.381]                           restarts <- computeRestarts(cond)
[08:28:38.381]                           for (restart in restarts) {
[08:28:38.381]                             name <- restart$name
[08:28:38.381]                             if (is.null(name)) 
[08:28:38.381]                               next
[08:28:38.381]                             if (!grepl(pattern, name)) 
[08:28:38.381]                               next
[08:28:38.381]                             invokeRestart(restart)
[08:28:38.381]                             muffled <- TRUE
[08:28:38.381]                             break
[08:28:38.381]                           }
[08:28:38.381]                         }
[08:28:38.381]                       }
[08:28:38.381]                       invisible(muffled)
[08:28:38.381]                     }
[08:28:38.381]                     muffleCondition(cond, pattern = "^muffle")
[08:28:38.381]                   }
[08:28:38.381]                 }
[08:28:38.381]                 else {
[08:28:38.381]                   if (TRUE) {
[08:28:38.381]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:38.381]                     {
[08:28:38.381]                       inherits <- base::inherits
[08:28:38.381]                       invokeRestart <- base::invokeRestart
[08:28:38.381]                       is.null <- base::is.null
[08:28:38.381]                       muffled <- FALSE
[08:28:38.381]                       if (inherits(cond, "message")) {
[08:28:38.381]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:38.381]                         if (muffled) 
[08:28:38.381]                           invokeRestart("muffleMessage")
[08:28:38.381]                       }
[08:28:38.381]                       else if (inherits(cond, "warning")) {
[08:28:38.381]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:38.381]                         if (muffled) 
[08:28:38.381]                           invokeRestart("muffleWarning")
[08:28:38.381]                       }
[08:28:38.381]                       else if (inherits(cond, "condition")) {
[08:28:38.381]                         if (!is.null(pattern)) {
[08:28:38.381]                           computeRestarts <- base::computeRestarts
[08:28:38.381]                           grepl <- base::grepl
[08:28:38.381]                           restarts <- computeRestarts(cond)
[08:28:38.381]                           for (restart in restarts) {
[08:28:38.381]                             name <- restart$name
[08:28:38.381]                             if (is.null(name)) 
[08:28:38.381]                               next
[08:28:38.381]                             if (!grepl(pattern, name)) 
[08:28:38.381]                               next
[08:28:38.381]                             invokeRestart(restart)
[08:28:38.381]                             muffled <- TRUE
[08:28:38.381]                             break
[08:28:38.381]                           }
[08:28:38.381]                         }
[08:28:38.381]                       }
[08:28:38.381]                       invisible(muffled)
[08:28:38.381]                     }
[08:28:38.381]                     muffleCondition(cond, pattern = "^muffle")
[08:28:38.381]                   }
[08:28:38.381]                 }
[08:28:38.381]             }
[08:28:38.381]         }))
[08:28:38.381]     }, error = function(ex) {
[08:28:38.381]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:38.381]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:38.381]                 ...future.rng), started = ...future.startTime, 
[08:28:38.381]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:38.381]             version = "1.8"), class = "FutureResult")
[08:28:38.381]     }, finally = {
[08:28:38.381]         if (!identical(...future.workdir, getwd())) 
[08:28:38.381]             setwd(...future.workdir)
[08:28:38.381]         {
[08:28:38.381]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:38.381]                 ...future.oldOptions$nwarnings <- NULL
[08:28:38.381]             }
[08:28:38.381]             base::options(...future.oldOptions)
[08:28:38.381]             if (.Platform$OS.type == "windows") {
[08:28:38.381]                 old_names <- names(...future.oldEnvVars)
[08:28:38.381]                 envs <- base::Sys.getenv()
[08:28:38.381]                 names <- names(envs)
[08:28:38.381]                 common <- intersect(names, old_names)
[08:28:38.381]                 added <- setdiff(names, old_names)
[08:28:38.381]                 removed <- setdiff(old_names, names)
[08:28:38.381]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:38.381]                   envs[common]]
[08:28:38.381]                 NAMES <- toupper(changed)
[08:28:38.381]                 args <- list()
[08:28:38.381]                 for (kk in seq_along(NAMES)) {
[08:28:38.381]                   name <- changed[[kk]]
[08:28:38.381]                   NAME <- NAMES[[kk]]
[08:28:38.381]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:38.381]                     next
[08:28:38.381]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:38.381]                 }
[08:28:38.381]                 NAMES <- toupper(added)
[08:28:38.381]                 for (kk in seq_along(NAMES)) {
[08:28:38.381]                   name <- added[[kk]]
[08:28:38.381]                   NAME <- NAMES[[kk]]
[08:28:38.381]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:38.381]                     next
[08:28:38.381]                   args[[name]] <- ""
[08:28:38.381]                 }
[08:28:38.381]                 NAMES <- toupper(removed)
[08:28:38.381]                 for (kk in seq_along(NAMES)) {
[08:28:38.381]                   name <- removed[[kk]]
[08:28:38.381]                   NAME <- NAMES[[kk]]
[08:28:38.381]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:38.381]                     next
[08:28:38.381]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:38.381]                 }
[08:28:38.381]                 if (length(args) > 0) 
[08:28:38.381]                   base::do.call(base::Sys.setenv, args = args)
[08:28:38.381]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:38.381]             }
[08:28:38.381]             else {
[08:28:38.381]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:38.381]             }
[08:28:38.381]             {
[08:28:38.381]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:38.381]                   0L) {
[08:28:38.381]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:38.381]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:38.381]                   base::options(opts)
[08:28:38.381]                 }
[08:28:38.381]                 {
[08:28:38.381]                   {
[08:28:38.381]                     NULL
[08:28:38.381]                     RNGkind("Mersenne-Twister")
[08:28:38.381]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:38.381]                       inherits = FALSE)
[08:28:38.381]                   }
[08:28:38.381]                   options(future.plan = NULL)
[08:28:38.381]                   if (is.na(NA_character_)) 
[08:28:38.381]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:38.381]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:38.381]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:38.381]                     .init = FALSE)
[08:28:38.381]                 }
[08:28:38.381]             }
[08:28:38.381]         }
[08:28:38.381]     })
[08:28:38.381]     if (TRUE) {
[08:28:38.381]         base::sink(type = "output", split = FALSE)
[08:28:38.381]         if (TRUE) {
[08:28:38.381]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:38.381]         }
[08:28:38.381]         else {
[08:28:38.381]             ...future.result["stdout"] <- base::list(NULL)
[08:28:38.381]         }
[08:28:38.381]         base::close(...future.stdout)
[08:28:38.381]         ...future.stdout <- NULL
[08:28:38.381]     }
[08:28:38.381]     ...future.result$conditions <- ...future.conditions
[08:28:38.381]     ...future.result$finished <- base::Sys.time()
[08:28:38.381]     ...future.result
[08:28:38.381] }
[08:28:38.383] assign_globals() ...
[08:28:38.383] List of 1
[08:28:38.383]  $ data:'data.frame':	3 obs. of  2 variables:
[08:28:38.383]   ..$ a: int [1:3] 1 2 3
[08:28:38.383]   ..$ b: int [1:3] 3 2 1
[08:28:38.383]  - attr(*, "where")=List of 1
[08:28:38.383]   ..$ data:<environment: R_EmptyEnv> 
[08:28:38.383]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:38.383]  - attr(*, "resolved")= logi FALSE
[08:28:38.383]  - attr(*, "total_size")= num 356
[08:28:38.383]  - attr(*, "already-done")= logi TRUE
[08:28:38.386] - copied ‘data’ to environment
[08:28:38.386] assign_globals() ... done
[08:28:38.386] plan(): Setting new future strategy stack:
[08:28:38.386] List of future strategies:
[08:28:38.386] 1. sequential:
[08:28:38.386]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:38.386]    - tweaked: FALSE
[08:28:38.386]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:38.387] plan(): nbrOfWorkers() = 1
[08:28:38.418] plan(): Setting new future strategy stack:
[08:28:38.418] List of future strategies:
[08:28:38.418] 1. sequential:
[08:28:38.418]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:38.418]    - tweaked: FALSE
[08:28:38.418]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:38.418] 2. sequential:
[08:28:38.418]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:38.418]    - tweaked: FALSE
[08:28:38.418]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:38.418] plan(): nbrOfWorkers() = 1
[08:28:38.418] SequentialFuture started (and completed)
[08:28:38.419] signalConditions() ...
[08:28:38.419]  - include = ‘immediateCondition’
[08:28:38.419]  - exclude = 
[08:28:38.419]  - resignal = FALSE
[08:28:38.419]  - Number of conditions: 52
[08:28:38.419] signalConditions() ... done
[08:28:38.419] - Launch lazy future ... done
[08:28:38.419] run() for ‘SequentialFuture’ ... done
[08:28:38.419] signalConditions() ...
[08:28:38.419]  - include = ‘immediateCondition’
[08:28:38.420]  - exclude = 
[08:28:38.420]  - resignal = FALSE
[08:28:38.420]  - Number of conditions: 52
[08:28:38.420] signalConditions() ... done
[08:28:38.420] Future state: ‘finished’
[08:28:38.420] signalConditions() ...
[08:28:38.420]  - include = ‘condition’
[08:28:38.420]  - exclude = ‘immediateCondition’
[08:28:38.420]  - resignal = TRUE
[08:28:38.420]  - Number of conditions: 52
[08:28:38.420]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.387] getGlobalsAndPackages() ...
[08:28:38.421]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.388] Searching for globals...
[08:28:38.421]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.404] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[08:28:38.421]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.404] Searching for globals ... DONE
[08:28:38.421]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.404] Resolving globals: FALSE
[08:28:38.421]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.405] The total size of the 1 globals is 356 bytes (356 bytes)
[08:28:38.421]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.405] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[08:28:38.421]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.405] - globals: [1] ‘data’
[08:28:38.421]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.405] 
[08:28:38.422]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.405] getGlobalsAndPackages() ... DONE
[08:28:38.422]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.406] run() for ‘Future’ ...
[08:28:38.422]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.406] - state: ‘created’
[08:28:38.422]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.406] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:38.422]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.406] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:38.422]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.406] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:38.422]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.406]   - Field: ‘label’
[08:28:38.422]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.407]   - Field: ‘local’
[08:28:38.423]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.407]   - Field: ‘owner’
[08:28:38.423]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.407]   - Field: ‘envir’
[08:28:38.423]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.407]   - Field: ‘packages’
[08:28:38.423]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.407]   - Field: ‘gc’
[08:28:38.423]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.407]   - Field: ‘conditions’
[08:28:38.423]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.407]   - Field: ‘expr’
[08:28:38.423]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.407]   - Field: ‘uuid’
[08:28:38.423]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.407]   - Field: ‘seed’
[08:28:38.423]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.407]   - Field: ‘version’
[08:28:38.424]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.408]   - Field: ‘result’
[08:28:38.424]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.408]   - Field: ‘asynchronous’
[08:28:38.424]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.408]   - Field: ‘calls’
[08:28:38.424]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.408]   - Field: ‘globals’
[08:28:38.424]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.408]   - Field: ‘stdout’
[08:28:38.424]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.408]   - Field: ‘earlySignal’
[08:28:38.424]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.408]   - Field: ‘lazy’
[08:28:38.424]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.408]   - Field: ‘state’
[08:28:38.425]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.408] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:38.425]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.409] - Launch lazy future ...
[08:28:38.425]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.409] Packages needed by the future expression (n = 0): <none>
[08:28:38.425]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.409] Packages needed by future strategies (n = 0): <none>
[08:28:38.425]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.409] {
[08:28:38.409]     {
[08:28:38.409]         {
[08:28:38.409]             ...future.startTime <- base::Sys.time()
[08:28:38.409]             {
[08:28:38.409]                 {
[08:28:38.409]                   {
[08:28:38.409]                     base::local({
[08:28:38.409]                       has_future <- base::requireNamespace("future", 
[08:28:38.409]                         quietly = TRUE)
[08:28:38.409]                       if (has_future) {
[08:28:38.409]                         ns <- base::getNamespace("future")
[08:28:38.409]                         version <- ns[[".package"]][["version"]]
[08:28:38.409]                         if (is.null(version)) 
[08:28:38.409]                           version <- utils::packageVersion("future")
[08:28:38.409]                       }
[08:28:38.409]                       else {
[08:28:38.409]                         version <- NULL
[08:28:38.409]                       }
[08:28:38.409]                       if (!has_future || version < "1.8.0") {
[08:28:38.409]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:38.409]                           "", base::R.version$version.string), 
[08:28:38.409]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:38.409]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:38.409]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:38.409]                             "release", "version")], collapse = " "), 
[08:28:38.409]                           hostname = base::Sys.info()[["nodename"]])
[08:28:38.409]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:38.409]                           info)
[08:28:38.409]                         info <- base::paste(info, collapse = "; ")
[08:28:38.409]                         if (!has_future) {
[08:28:38.409]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:38.409]                             info)
[08:28:38.409]                         }
[08:28:38.409]                         else {
[08:28:38.409]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:38.409]                             info, version)
[08:28:38.409]                         }
[08:28:38.409]                         base::stop(msg)
[08:28:38.409]                       }
[08:28:38.409]                     })
[08:28:38.409]                   }
[08:28:38.409]                   ...future.strategy.old <- future::plan("list")
[08:28:38.409]                   options(future.plan = NULL)
[08:28:38.409]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:38.409]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:38.409]                 }
[08:28:38.409]                 ...future.workdir <- getwd()
[08:28:38.409]             }
[08:28:38.409]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:38.409]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:38.409]         }
[08:28:38.409]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:38.409]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:38.409]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:38.409]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:38.409]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:38.409]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:38.409]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:38.409]             base::names(...future.oldOptions))
[08:28:38.409]     }
[08:28:38.409]     if (FALSE) {
[08:28:38.409]     }
[08:28:38.409]     else {
[08:28:38.409]         if (TRUE) {
[08:28:38.409]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:38.409]                 open = "w")
[08:28:38.409]         }
[08:28:38.409]         else {
[08:28:38.409]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:38.409]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:38.409]         }
[08:28:38.409]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:38.409]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:38.409]             base::sink(type = "output", split = FALSE)
[08:28:38.409]             base::close(...future.stdout)
[08:28:38.409]         }, add = TRUE)
[08:28:38.409]     }
[08:28:38.409]     ...future.frame <- base::sys.nframe()
[08:28:38.409]     ...future.conditions <- base::list()
[08:28:38.409]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:38.409]     if (FALSE) {
[08:28:38.409]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:38.409]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:38.409]     }
[08:28:38.409]     ...future.result <- base::tryCatch({
[08:28:38.409]         base::withCallingHandlers({
[08:28:38.409]             ...future.value <- base::withVisible(base::local(subset(data, 
[08:28:38.409]                 a == 2)))
[08:28:38.409]             future::FutureResult(value = ...future.value$value, 
[08:28:38.409]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:38.409]                   ...future.rng), globalenv = if (FALSE) 
[08:28:38.409]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:38.409]                     ...future.globalenv.names))
[08:28:38.409]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:38.409]         }, condition = base::local({
[08:28:38.409]             c <- base::c
[08:28:38.409]             inherits <- base::inherits
[08:28:38.409]             invokeRestart <- base::invokeRestart
[08:28:38.409]             length <- base::length
[08:28:38.409]             list <- base::list
[08:28:38.409]             seq.int <- base::seq.int
[08:28:38.409]             signalCondition <- base::signalCondition
[08:28:38.409]             sys.calls <- base::sys.calls
[08:28:38.409]             `[[` <- base::`[[`
[08:28:38.409]             `+` <- base::`+`
[08:28:38.409]             `<<-` <- base::`<<-`
[08:28:38.409]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:38.409]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:38.409]                   3L)]
[08:28:38.409]             }
[08:28:38.409]             function(cond) {
[08:28:38.409]                 is_error <- inherits(cond, "error")
[08:28:38.409]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:38.409]                   NULL)
[08:28:38.409]                 if (is_error) {
[08:28:38.409]                   sessionInformation <- function() {
[08:28:38.409]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:38.409]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:38.409]                       search = base::search(), system = base::Sys.info())
[08:28:38.409]                   }
[08:28:38.409]                   ...future.conditions[[length(...future.conditions) + 
[08:28:38.409]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:38.409]                     cond$call), session = sessionInformation(), 
[08:28:38.409]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:38.409]                   signalCondition(cond)
[08:28:38.409]                 }
[08:28:38.409]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:38.409]                 "immediateCondition"))) {
[08:28:38.409]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:38.409]                   ...future.conditions[[length(...future.conditions) + 
[08:28:38.409]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:38.409]                   if (TRUE && !signal) {
[08:28:38.409]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:38.409]                     {
[08:28:38.409]                       inherits <- base::inherits
[08:28:38.409]                       invokeRestart <- base::invokeRestart
[08:28:38.409]                       is.null <- base::is.null
[08:28:38.409]                       muffled <- FALSE
[08:28:38.409]                       if (inherits(cond, "message")) {
[08:28:38.409]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:38.409]                         if (muffled) 
[08:28:38.409]                           invokeRestart("muffleMessage")
[08:28:38.409]                       }
[08:28:38.409]                       else if (inherits(cond, "warning")) {
[08:28:38.409]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:38.409]                         if (muffled) 
[08:28:38.409]                           invokeRestart("muffleWarning")
[08:28:38.409]                       }
[08:28:38.409]                       else if (inherits(cond, "condition")) {
[08:28:38.409]                         if (!is.null(pattern)) {
[08:28:38.409]                           computeRestarts <- base::computeRestarts
[08:28:38.409]                           grepl <- base::grepl
[08:28:38.409]                           restarts <- computeRestarts(cond)
[08:28:38.409]                           for (restart in restarts) {
[08:28:38.409]                             name <- restart$name
[08:28:38.409]                             if (is.null(name)) 
[08:28:38.409]                               next
[08:28:38.409]                             if (!grepl(pattern, name)) 
[08:28:38.409]                               next
[08:28:38.409]                             invokeRestart(restart)
[08:28:38.409]                             muffled <- TRUE
[08:28:38.409]                             break
[08:28:38.409]                           }
[08:28:38.409]                         }
[08:28:38.409]                       }
[08:28:38.409]                       invisible(muffled)
[08:28:38.409]                     }
[08:28:38.409]                     muffleCondition(cond, pattern = "^muffle")
[08:28:38.409]                   }
[08:28:38.409]                 }
[08:28:38.409]                 else {
[08:28:38.409]                   if (TRUE) {
[08:28:38.409]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:38.409]                     {
[08:28:38.409]                       inherits <- base::inherits
[08:28:38.409]                       invokeRestart <- base::invokeRestart
[08:28:38.409]                       is.null <- base::is.null
[08:28:38.409]                       muffled <- FALSE
[08:28:38.409]                       if (inherits(cond, "message")) {
[08:28:38.409]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:38.409]                         if (muffled) 
[08:28:38.409]                           invokeRestart("muffleMessage")
[08:28:38.409]                       }
[08:28:38.409]                       else if (inherits(cond, "warning")) {
[08:28:38.409]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:38.409]                         if (muffled) 
[08:28:38.409]                           invokeRestart("muffleWarning")
[08:28:38.409]                       }
[08:28:38.409]                       else if (inherits(cond, "condition")) {
[08:28:38.409]                         if (!is.null(pattern)) {
[08:28:38.409]                           computeRestarts <- base::computeRestarts
[08:28:38.409]                           grepl <- base::grepl
[08:28:38.409]                           restarts <- computeRestarts(cond)
[08:28:38.409]                           for (restart in restarts) {
[08:28:38.409]                             name <- restart$name
[08:28:38.409]                             if (is.null(name)) 
[08:28:38.409]                               next
[08:28:38.409]                             if (!grepl(pattern, name)) 
[08:28:38.409]                               next
[08:28:38.409]                             invokeRestart(restart)
[08:28:38.409]                             muffled <- TRUE
[08:28:38.409]                             break
[08:28:38.409]                           }
[08:28:38.409]                         }
[08:28:38.409]                       }
[08:28:38.409]                       invisible(muffled)
[08:28:38.409]                     }
[08:28:38.409]                     muffleCondition(cond, pattern = "^muffle")
[08:28:38.409]                   }
[08:28:38.409]                 }
[08:28:38.409]             }
[08:28:38.409]         }))
[08:28:38.409]     }, error = function(ex) {
[08:28:38.409]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:38.409]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:38.409]                 ...future.rng), started = ...future.startTime, 
[08:28:38.409]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:38.409]             version = "1.8"), class = "FutureResult")
[08:28:38.409]     }, finally = {
[08:28:38.409]         if (!identical(...future.workdir, getwd())) 
[08:28:38.409]             setwd(...future.workdir)
[08:28:38.409]         {
[08:28:38.409]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:38.409]                 ...future.oldOptions$nwarnings <- NULL
[08:28:38.409]             }
[08:28:38.409]             base::options(...future.oldOptions)
[08:28:38.409]             if (.Platform$OS.type == "windows") {
[08:28:38.409]                 old_names <- names(...future.oldEnvVars)
[08:28:38.409]                 envs <- base::Sys.getenv()
[08:28:38.409]                 names <- names(envs)
[08:28:38.409]                 common <- intersect(names, old_names)
[08:28:38.409]                 added <- setdiff(names, old_names)
[08:28:38.409]                 removed <- setdiff(old_names, names)
[08:28:38.409]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:38.409]                   envs[common]]
[08:28:38.409]                 NAMES <- toupper(changed)
[08:28:38.409]                 args <- list()
[08:28:38.409]                 for (kk in seq_along(NAMES)) {
[08:28:38.409]                   name <- changed[[kk]]
[08:28:38.409]                   NAME <- NAMES[[kk]]
[08:28:38.409]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:38.409]                     next
[08:28:38.409]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:38.409]                 }
[08:28:38.409]                 NAMES <- toupper(added)
[08:28:38.409]                 for (kk in seq_along(NAMES)) {
[08:28:38.409]                   name <- added[[kk]]
[08:28:38.409]                   NAME <- NAMES[[kk]]
[08:28:38.409]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:38.409]                     next
[08:28:38.409]                   args[[name]] <- ""
[08:28:38.409]                 }
[08:28:38.409]                 NAMES <- toupper(removed)
[08:28:38.409]                 for (kk in seq_along(NAMES)) {
[08:28:38.409]                   name <- removed[[kk]]
[08:28:38.409]                   NAME <- NAMES[[kk]]
[08:28:38.409]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:38.409]                     next
[08:28:38.409]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:38.409]                 }
[08:28:38.409]                 if (length(args) > 0) 
[08:28:38.409]                   base::do.call(base::Sys.setenv, args = args)
[08:28:38.409]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:38.409]             }
[08:28:38.409]             else {
[08:28:38.409]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:38.409]             }
[08:28:38.409]             {
[08:28:38.409]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:38.409]                   0L) {
[08:28:38.409]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:38.409]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:38.409]                   base::options(opts)
[08:28:38.409]                 }
[08:28:38.409]                 {
[08:28:38.409]                   {
[08:28:38.409]                     NULL
[08:28:38.409]                     RNGkind("Mersenne-Twister")
[08:28:38.409]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:38.409]                       inherits = FALSE)
[08:28:38.409]                   }
[08:28:38.409]                   options(future.plan = NULL)
[08:28:38.409]                   if (is.na(NA_character_)) 
[08:28:38.409]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:38.409]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:38.409]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:38.409]                     .init = FALSE)
[08:28:38.409]                 }
[08:28:38.409]             }
[08:28:38.409]         }
[08:28:38.409]     })
[08:28:38.409]     if (TRUE) {
[08:28:38.409]         base::sink(type = "output", split = FALSE)
[08:28:38.409]         if (TRUE) {
[08:28:38.409]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:38.409]         }
[08:28:38.409]         else {
[08:28:38.409]             ...future.result["stdout"] <- base::list(NULL)
[08:28:38.409]         }
[08:28:38.409]         base::close(...future.stdout)
[08:28:38.409]         ...future.stdout <- NULL
[08:28:38.409]     }
[08:28:38.409]     ...future.result$conditions <- ...future.conditions
[08:28:38.409]     ...future.result$finished <- base::Sys.time()
[08:28:38.409]     ...future.result
[08:28:38.409] }
[08:28:38.425]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.411] assign_globals() ...
[08:28:38.425]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.411] List of 1
[08:28:38.411]  $ data:'data.frame':	3 obs. of  2 variables:
[08:28:38.411]   ..$ a: int [1:3] 1 2 3
[08:28:38.411]   ..$ b: int [1:3] 3 2 1
[08:28:38.411]  - attr(*, "where")=List of 1
[08:28:38.411]   ..$ data:<environment: R_EmptyEnv> 
[08:28:38.411]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:38.411]  - attr(*, "resolved")= logi FALSE
[08:28:38.411]  - attr(*, "total_size")= num 356
[08:28:38.411]  - attr(*, "already-done")= logi TRUE
[08:28:38.427]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.414] - copied ‘data’ to environment
[08:28:38.427]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.414] assign_globals() ... done
[08:28:38.427]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.415] plan(): Setting new future strategy stack:
[08:28:38.428]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.415] List of future strategies:
[08:28:38.415] 1. sequential:
[08:28:38.415]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:38.415]    - tweaked: FALSE
[08:28:38.415]    - call: NULL
[08:28:38.428]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.415] plan(): nbrOfWorkers() = 1
[08:28:38.428]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.416] plan(): Setting new future strategy stack:
[08:28:38.428]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.416] List of future strategies:
[08:28:38.416] 1. sequential:
[08:28:38.416]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:38.416]    - tweaked: FALSE
[08:28:38.416]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:38.428]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.417] plan(): nbrOfWorkers() = 1
[08:28:38.428]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.417] SequentialFuture started (and completed)
[08:28:38.428]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.417] - Launch lazy future ... done
[08:28:38.429]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.417] run() for ‘SequentialFuture’ ... done
[08:28:38.429] signalConditions() ... done
- plan(list('sequential', 'sequential')) ... DONE
- plan(list('sequential', 'multicore')) ...
[08:28:38.429] plan(): Setting new future strategy stack:
[08:28:38.429] List of future strategies:
[08:28:38.429] 1. sequential:
[08:28:38.429]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:38.429]    - tweaked: FALSE
[08:28:38.429]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:38.429] 2. multicore:
[08:28:38.429]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:38.429]    - tweaked: FALSE
[08:28:38.429]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:38.430] plan(): nbrOfWorkers() = 1
[08:28:38.430] getGlobalsAndPackages() ...
[08:28:38.430] Searching for globals...
[08:28:38.447] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[08:28:38.447] Searching for globals ... DONE
[08:28:38.447] Resolving globals: FALSE
[08:28:38.448] The total size of the 2 globals is 7.79 KiB (7972 bytes)
[08:28:38.449] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 7.79 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (7.74 KiB of class ‘list’) and ‘strategy2’ (48 bytes of class ‘character’)
[08:28:38.449] - globals: [2] ‘nested’, ‘strategy2’
[08:28:38.449] - packages: [1] ‘future’
[08:28:38.449] getGlobalsAndPackages() ... DONE
[08:28:38.449] run() for ‘Future’ ...
[08:28:38.449] - state: ‘created’
[08:28:38.449] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:38.450] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:38.450] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:38.450]   - Field: ‘label’
[08:28:38.450]   - Field: ‘local’
[08:28:38.450]   - Field: ‘owner’
[08:28:38.450]   - Field: ‘envir’
[08:28:38.450]   - Field: ‘packages’
[08:28:38.450]   - Field: ‘gc’
[08:28:38.450]   - Field: ‘conditions’
[08:28:38.451]   - Field: ‘expr’
[08:28:38.451]   - Field: ‘uuid’
[08:28:38.451]   - Field: ‘seed’
[08:28:38.451]   - Field: ‘version’
[08:28:38.451]   - Field: ‘result’
[08:28:38.451]   - Field: ‘asynchronous’
[08:28:38.451]   - Field: ‘calls’
[08:28:38.451]   - Field: ‘globals’
[08:28:38.451]   - Field: ‘stdout’
[08:28:38.451]   - Field: ‘earlySignal’
[08:28:38.451]   - Field: ‘lazy’
[08:28:38.451]   - Field: ‘state’
[08:28:38.452] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:38.452] - Launch lazy future ...
[08:28:38.452] Packages needed by the future expression (n = 1): ‘future’
[08:28:38.452] Packages needed by future strategies (n = 1): ‘future’
[08:28:38.453] {
[08:28:38.453]     {
[08:28:38.453]         {
[08:28:38.453]             ...future.startTime <- base::Sys.time()
[08:28:38.453]             {
[08:28:38.453]                 {
[08:28:38.453]                   {
[08:28:38.453]                     {
[08:28:38.453]                       base::local({
[08:28:38.453]                         has_future <- base::requireNamespace("future", 
[08:28:38.453]                           quietly = TRUE)
[08:28:38.453]                         if (has_future) {
[08:28:38.453]                           ns <- base::getNamespace("future")
[08:28:38.453]                           version <- ns[[".package"]][["version"]]
[08:28:38.453]                           if (is.null(version)) 
[08:28:38.453]                             version <- utils::packageVersion("future")
[08:28:38.453]                         }
[08:28:38.453]                         else {
[08:28:38.453]                           version <- NULL
[08:28:38.453]                         }
[08:28:38.453]                         if (!has_future || version < "1.8.0") {
[08:28:38.453]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:38.453]                             "", base::R.version$version.string), 
[08:28:38.453]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:38.453]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:38.453]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:38.453]                               "release", "version")], collapse = " "), 
[08:28:38.453]                             hostname = base::Sys.info()[["nodename"]])
[08:28:38.453]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:38.453]                             info)
[08:28:38.453]                           info <- base::paste(info, collapse = "; ")
[08:28:38.453]                           if (!has_future) {
[08:28:38.453]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:38.453]                               info)
[08:28:38.453]                           }
[08:28:38.453]                           else {
[08:28:38.453]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:38.453]                               info, version)
[08:28:38.453]                           }
[08:28:38.453]                           base::stop(msg)
[08:28:38.453]                         }
[08:28:38.453]                       })
[08:28:38.453]                     }
[08:28:38.453]                     base::local({
[08:28:38.453]                       for (pkg in "future") {
[08:28:38.453]                         base::loadNamespace(pkg)
[08:28:38.453]                         base::library(pkg, character.only = TRUE)
[08:28:38.453]                       }
[08:28:38.453]                     })
[08:28:38.453]                   }
[08:28:38.453]                   ...future.strategy.old <- future::plan("list")
[08:28:38.453]                   options(future.plan = NULL)
[08:28:38.453]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:38.453]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[08:28:38.453]                     envir = parent.frame()) 
[08:28:38.453]                   {
[08:28:38.453]                     default_workers <- missing(workers)
[08:28:38.453]                     if (is.function(workers)) 
[08:28:38.453]                       workers <- workers()
[08:28:38.453]                     workers <- structure(as.integer(workers), 
[08:28:38.453]                       class = class(workers))
[08:28:38.453]                     stop_if_not(is.finite(workers), workers >= 
[08:28:38.453]                       1L)
[08:28:38.453]                     if ((workers == 1L && !inherits(workers, 
[08:28:38.453]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[08:28:38.453]                       if (default_workers) 
[08:28:38.453]                         supportsMulticore(warn = TRUE)
[08:28:38.453]                       return(sequential(..., envir = envir))
[08:28:38.453]                     }
[08:28:38.453]                     oopts <- options(mc.cores = workers)
[08:28:38.453]                     on.exit(options(oopts))
[08:28:38.453]                     future <- MulticoreFuture(..., workers = workers, 
[08:28:38.453]                       envir = envir)
[08:28:38.453]                     if (!future$lazy) 
[08:28:38.453]                       future <- run(future)
[08:28:38.453]                     invisible(future)
[08:28:38.453]                   }), .cleanup = FALSE, .init = FALSE)
[08:28:38.453]                 }
[08:28:38.453]                 ...future.workdir <- getwd()
[08:28:38.453]             }
[08:28:38.453]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:38.453]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:38.453]         }
[08:28:38.453]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:38.453]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:38.453]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:38.453]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:38.453]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:38.453]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:38.453]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:38.453]             base::names(...future.oldOptions))
[08:28:38.453]     }
[08:28:38.453]     if (FALSE) {
[08:28:38.453]     }
[08:28:38.453]     else {
[08:28:38.453]         if (TRUE) {
[08:28:38.453]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:38.453]                 open = "w")
[08:28:38.453]         }
[08:28:38.453]         else {
[08:28:38.453]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:38.453]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:38.453]         }
[08:28:38.453]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:38.453]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:38.453]             base::sink(type = "output", split = FALSE)
[08:28:38.453]             base::close(...future.stdout)
[08:28:38.453]         }, add = TRUE)
[08:28:38.453]     }
[08:28:38.453]     ...future.frame <- base::sys.nframe()
[08:28:38.453]     ...future.conditions <- base::list()
[08:28:38.453]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:38.453]     if (FALSE) {
[08:28:38.453]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:38.453]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:38.453]     }
[08:28:38.453]     ...future.result <- base::tryCatch({
[08:28:38.453]         base::withCallingHandlers({
[08:28:38.453]             ...future.value <- base::withVisible(base::local({
[08:28:38.453]                 a <- 1L
[08:28:38.453]                 plan_a <- unclass(future::plan("list"))
[08:28:38.453]                 nested_a <- nested[-1]
[08:28:38.453]                 stopifnot(length(nested_a) == 1L, length(plan_a) == 
[08:28:38.453]                   1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[08:28:38.453]                   strategy2))
[08:28:38.453]                 for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[08:28:38.453]                   "init") <- NULL
[08:28:38.453]                 for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[08:28:38.453]                   "init") <- NULL
[08:28:38.453]                 stopifnot(all.equal(plan_a, nested_a))
[08:28:38.453]                 y %<-% {
[08:28:38.453]                   b <- 2L
[08:28:38.453]                   plan_b <- future::plan("list")
[08:28:38.453]                   nested_b <- nested_a[-1]
[08:28:38.453]                   stopifnot(length(nested_b) == 0L, length(plan_b) == 
[08:28:38.453]                     1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[08:28:38.453]                     "sequential"))
[08:28:38.453]                   list(a = a, nested_a = nested_a, plan_a = plan_a, 
[08:28:38.453]                     b = b, nested_b = nested_b, plan_b = plan_b)
[08:28:38.453]                 }
[08:28:38.453]                 y
[08:28:38.453]             }))
[08:28:38.453]             future::FutureResult(value = ...future.value$value, 
[08:28:38.453]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:38.453]                   ...future.rng), globalenv = if (FALSE) 
[08:28:38.453]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:38.453]                     ...future.globalenv.names))
[08:28:38.453]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:38.453]         }, condition = base::local({
[08:28:38.453]             c <- base::c
[08:28:38.453]             inherits <- base::inherits
[08:28:38.453]             invokeRestart <- base::invokeRestart
[08:28:38.453]             length <- base::length
[08:28:38.453]             list <- base::list
[08:28:38.453]             seq.int <- base::seq.int
[08:28:38.453]             signalCondition <- base::signalCondition
[08:28:38.453]             sys.calls <- base::sys.calls
[08:28:38.453]             `[[` <- base::`[[`
[08:28:38.453]             `+` <- base::`+`
[08:28:38.453]             `<<-` <- base::`<<-`
[08:28:38.453]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:38.453]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:38.453]                   3L)]
[08:28:38.453]             }
[08:28:38.453]             function(cond) {
[08:28:38.453]                 is_error <- inherits(cond, "error")
[08:28:38.453]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:38.453]                   NULL)
[08:28:38.453]                 if (is_error) {
[08:28:38.453]                   sessionInformation <- function() {
[08:28:38.453]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:38.453]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:38.453]                       search = base::search(), system = base::Sys.info())
[08:28:38.453]                   }
[08:28:38.453]                   ...future.conditions[[length(...future.conditions) + 
[08:28:38.453]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:38.453]                     cond$call), session = sessionInformation(), 
[08:28:38.453]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:38.453]                   signalCondition(cond)
[08:28:38.453]                 }
[08:28:38.453]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:38.453]                 "immediateCondition"))) {
[08:28:38.453]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:38.453]                   ...future.conditions[[length(...future.conditions) + 
[08:28:38.453]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:38.453]                   if (TRUE && !signal) {
[08:28:38.453]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:38.453]                     {
[08:28:38.453]                       inherits <- base::inherits
[08:28:38.453]                       invokeRestart <- base::invokeRestart
[08:28:38.453]                       is.null <- base::is.null
[08:28:38.453]                       muffled <- FALSE
[08:28:38.453]                       if (inherits(cond, "message")) {
[08:28:38.453]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:38.453]                         if (muffled) 
[08:28:38.453]                           invokeRestart("muffleMessage")
[08:28:38.453]                       }
[08:28:38.453]                       else if (inherits(cond, "warning")) {
[08:28:38.453]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:38.453]                         if (muffled) 
[08:28:38.453]                           invokeRestart("muffleWarning")
[08:28:38.453]                       }
[08:28:38.453]                       else if (inherits(cond, "condition")) {
[08:28:38.453]                         if (!is.null(pattern)) {
[08:28:38.453]                           computeRestarts <- base::computeRestarts
[08:28:38.453]                           grepl <- base::grepl
[08:28:38.453]                           restarts <- computeRestarts(cond)
[08:28:38.453]                           for (restart in restarts) {
[08:28:38.453]                             name <- restart$name
[08:28:38.453]                             if (is.null(name)) 
[08:28:38.453]                               next
[08:28:38.453]                             if (!grepl(pattern, name)) 
[08:28:38.453]                               next
[08:28:38.453]                             invokeRestart(restart)
[08:28:38.453]                             muffled <- TRUE
[08:28:38.453]                             break
[08:28:38.453]                           }
[08:28:38.453]                         }
[08:28:38.453]                       }
[08:28:38.453]                       invisible(muffled)
[08:28:38.453]                     }
[08:28:38.453]                     muffleCondition(cond, pattern = "^muffle")
[08:28:38.453]                   }
[08:28:38.453]                 }
[08:28:38.453]                 else {
[08:28:38.453]                   if (TRUE) {
[08:28:38.453]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:38.453]                     {
[08:28:38.453]                       inherits <- base::inherits
[08:28:38.453]                       invokeRestart <- base::invokeRestart
[08:28:38.453]                       is.null <- base::is.null
[08:28:38.453]                       muffled <- FALSE
[08:28:38.453]                       if (inherits(cond, "message")) {
[08:28:38.453]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:38.453]                         if (muffled) 
[08:28:38.453]                           invokeRestart("muffleMessage")
[08:28:38.453]                       }
[08:28:38.453]                       else if (inherits(cond, "warning")) {
[08:28:38.453]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:38.453]                         if (muffled) 
[08:28:38.453]                           invokeRestart("muffleWarning")
[08:28:38.453]                       }
[08:28:38.453]                       else if (inherits(cond, "condition")) {
[08:28:38.453]                         if (!is.null(pattern)) {
[08:28:38.453]                           computeRestarts <- base::computeRestarts
[08:28:38.453]                           grepl <- base::grepl
[08:28:38.453]                           restarts <- computeRestarts(cond)
[08:28:38.453]                           for (restart in restarts) {
[08:28:38.453]                             name <- restart$name
[08:28:38.453]                             if (is.null(name)) 
[08:28:38.453]                               next
[08:28:38.453]                             if (!grepl(pattern, name)) 
[08:28:38.453]                               next
[08:28:38.453]                             invokeRestart(restart)
[08:28:38.453]                             muffled <- TRUE
[08:28:38.453]                             break
[08:28:38.453]                           }
[08:28:38.453]                         }
[08:28:38.453]                       }
[08:28:38.453]                       invisible(muffled)
[08:28:38.453]                     }
[08:28:38.453]                     muffleCondition(cond, pattern = "^muffle")
[08:28:38.453]                   }
[08:28:38.453]                 }
[08:28:38.453]             }
[08:28:38.453]         }))
[08:28:38.453]     }, error = function(ex) {
[08:28:38.453]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:38.453]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:38.453]                 ...future.rng), started = ...future.startTime, 
[08:28:38.453]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:38.453]             version = "1.8"), class = "FutureResult")
[08:28:38.453]     }, finally = {
[08:28:38.453]         if (!identical(...future.workdir, getwd())) 
[08:28:38.453]             setwd(...future.workdir)
[08:28:38.453]         {
[08:28:38.453]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:38.453]                 ...future.oldOptions$nwarnings <- NULL
[08:28:38.453]             }
[08:28:38.453]             base::options(...future.oldOptions)
[08:28:38.453]             if (.Platform$OS.type == "windows") {
[08:28:38.453]                 old_names <- names(...future.oldEnvVars)
[08:28:38.453]                 envs <- base::Sys.getenv()
[08:28:38.453]                 names <- names(envs)
[08:28:38.453]                 common <- intersect(names, old_names)
[08:28:38.453]                 added <- setdiff(names, old_names)
[08:28:38.453]                 removed <- setdiff(old_names, names)
[08:28:38.453]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:38.453]                   envs[common]]
[08:28:38.453]                 NAMES <- toupper(changed)
[08:28:38.453]                 args <- list()
[08:28:38.453]                 for (kk in seq_along(NAMES)) {
[08:28:38.453]                   name <- changed[[kk]]
[08:28:38.453]                   NAME <- NAMES[[kk]]
[08:28:38.453]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:38.453]                     next
[08:28:38.453]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:38.453]                 }
[08:28:38.453]                 NAMES <- toupper(added)
[08:28:38.453]                 for (kk in seq_along(NAMES)) {
[08:28:38.453]                   name <- added[[kk]]
[08:28:38.453]                   NAME <- NAMES[[kk]]
[08:28:38.453]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:38.453]                     next
[08:28:38.453]                   args[[name]] <- ""
[08:28:38.453]                 }
[08:28:38.453]                 NAMES <- toupper(removed)
[08:28:38.453]                 for (kk in seq_along(NAMES)) {
[08:28:38.453]                   name <- removed[[kk]]
[08:28:38.453]                   NAME <- NAMES[[kk]]
[08:28:38.453]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:38.453]                     next
[08:28:38.453]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:38.453]                 }
[08:28:38.453]                 if (length(args) > 0) 
[08:28:38.453]                   base::do.call(base::Sys.setenv, args = args)
[08:28:38.453]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:38.453]             }
[08:28:38.453]             else {
[08:28:38.453]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:38.453]             }
[08:28:38.453]             {
[08:28:38.453]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:38.453]                   0L) {
[08:28:38.453]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:38.453]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:38.453]                   base::options(opts)
[08:28:38.453]                 }
[08:28:38.453]                 {
[08:28:38.453]                   {
[08:28:38.453]                     NULL
[08:28:38.453]                     RNGkind("Mersenne-Twister")
[08:28:38.453]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:38.453]                       inherits = FALSE)
[08:28:38.453]                   }
[08:28:38.453]                   options(future.plan = NULL)
[08:28:38.453]                   if (is.na(NA_character_)) 
[08:28:38.453]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:38.453]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:38.453]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:38.453]                     .init = FALSE)
[08:28:38.453]                 }
[08:28:38.453]             }
[08:28:38.453]         }
[08:28:38.453]     })
[08:28:38.453]     if (TRUE) {
[08:28:38.453]         base::sink(type = "output", split = FALSE)
[08:28:38.453]         if (TRUE) {
[08:28:38.453]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:38.453]         }
[08:28:38.453]         else {
[08:28:38.453]             ...future.result["stdout"] <- base::list(NULL)
[08:28:38.453]         }
[08:28:38.453]         base::close(...future.stdout)
[08:28:38.453]         ...future.stdout <- NULL
[08:28:38.453]     }
[08:28:38.453]     ...future.result$conditions <- ...future.conditions
[08:28:38.453]     ...future.result$finished <- base::Sys.time()
[08:28:38.453]     ...future.result
[08:28:38.453] }
[08:28:38.455] assign_globals() ...
[08:28:38.455] List of 2
[08:28:38.455]  $ nested   :List of 2
[08:28:38.455]   ..$ a:function (..., envir = parent.frame())  
[08:28:38.455]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[08:28:38.455]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[08:28:38.455]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[08:28:38.455]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[08:28:38.455]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[08:28:38.455]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[08:28:38.455]  $ strategy2: chr "multicore"
[08:28:38.455]  - attr(*, "where")=List of 2
[08:28:38.455]   ..$ nested   :<environment: R_EmptyEnv> 
[08:28:38.455]   ..$ strategy2:<environment: R_EmptyEnv> 
[08:28:38.455]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:38.455]  - attr(*, "resolved")= logi FALSE
[08:28:38.455]  - attr(*, "total_size")= num 7972
[08:28:38.455]  - attr(*, "already-done")= logi TRUE
[08:28:38.459] - copied ‘nested’ to environment
[08:28:38.459] - copied ‘strategy2’ to environment
[08:28:38.459] assign_globals() ... done
[08:28:38.460] plan(): Setting new future strategy stack:
[08:28:38.460] List of future strategies:
[08:28:38.460] 1. multicore:
[08:28:38.460]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:38.460]    - tweaked: FALSE
[08:28:38.460]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:38.462] plan(): nbrOfWorkers() = 2
[08:28:38.516] plan(): Setting new future strategy stack:
[08:28:38.516] List of future strategies:
[08:28:38.516] 1. sequential:
[08:28:38.516]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:38.516]    - tweaked: FALSE
[08:28:38.516]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:38.516] 2. multicore:
[08:28:38.516]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:38.516]    - tweaked: FALSE
[08:28:38.516]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:38.516] plan(): nbrOfWorkers() = 1
[08:28:38.517] SequentialFuture started (and completed)
[08:28:38.517] signalConditions() ...
[08:28:38.517]  - include = ‘immediateCondition’
[08:28:38.517]  - exclude = 
[08:28:38.517]  - resignal = FALSE
[08:28:38.517]  - Number of conditions: 57
[08:28:38.517] signalConditions() ... done
[08:28:38.518] - Launch lazy future ... done
[08:28:38.518] run() for ‘SequentialFuture’ ... done
[08:28:38.518] signalConditions() ...
[08:28:38.518]  - include = ‘immediateCondition’
[08:28:38.518]  - exclude = 
[08:28:38.518]  - resignal = FALSE
[08:28:38.518]  - Number of conditions: 57
[08:28:38.519] signalConditions() ... done
[08:28:38.519] Future state: ‘finished’
[08:28:38.519] signalConditions() ...
[08:28:38.519]  - include = ‘condition’
[08:28:38.519]  - exclude = ‘immediateCondition’
[08:28:38.519]  - resignal = TRUE
[08:28:38.519]  - Number of conditions: 57
[08:28:38.519]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.462] getGlobalsAndPackages() ...
[08:28:38.519]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.463] Searching for globals...
[08:28:38.520]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.482] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[08:28:38.520]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.482] Searching for globals ... DONE
[08:28:38.520]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.482] Resolving globals: FALSE
[08:28:38.520]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.483] The total size of the 3 globals is 12.54 KiB (12841 bytes)
[08:28:38.520]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.483] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 12.54 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (6.25 KiB of class ‘list’), ‘plan_a’ (6.25 KiB of class ‘list’) and ‘a’ (35 bytes of class ‘numeric’)
[08:28:38.520]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.483] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[08:28:38.521]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.483] 
[08:28:38.521]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.483] getGlobalsAndPackages() ... DONE
[08:28:38.521]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.484] run() for ‘Future’ ...
[08:28:38.521]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.484] - state: ‘created’
[08:28:38.521]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.484] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:38.521]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.486] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:38.521]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.486] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:38.522]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.486]   - Field: ‘label’
[08:28:38.522]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.486]   - Field: ‘local’
[08:28:38.522]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.486]   - Field: ‘owner’
[08:28:38.522]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.486]   - Field: ‘envir’
[08:28:38.522]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.486]   - Field: ‘workers’
[08:28:38.522]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.486]   - Field: ‘packages’
[08:28:38.522]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.487]   - Field: ‘gc’
[08:28:38.523]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.487]   - Field: ‘job’
[08:28:38.523]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.487]   - Field: ‘conditions’
[08:28:38.523]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.487]   - Field: ‘expr’
[08:28:38.523]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.487]   - Field: ‘uuid’
[08:28:38.523]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.487]   - Field: ‘seed’
[08:28:38.523]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.487]   - Field: ‘version’
[08:28:38.524]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.489]   - Field: ‘result’
[08:28:38.524]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.489]   - Field: ‘asynchronous’
[08:28:38.524]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.489]   - Field: ‘calls’
[08:28:38.524]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.489]   - Field: ‘globals’
[08:28:38.524]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.489]   - Field: ‘stdout’
[08:28:38.524]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.489]   - Field: ‘earlySignal’
[08:28:38.524]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.489]   - Field: ‘lazy’
[08:28:38.525]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.489]   - Field: ‘state’
[08:28:38.525]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.489] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:38.525]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.490] - Launch lazy future ...
[08:28:38.525]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.491] Packages needed by the future expression (n = 0): <none>
[08:28:38.525]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.491] Packages needed by future strategies (n = 0): <none>
[08:28:38.525]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.491] {
[08:28:38.491]     {
[08:28:38.491]         {
[08:28:38.491]             ...future.startTime <- base::Sys.time()
[08:28:38.491]             {
[08:28:38.491]                 {
[08:28:38.491]                   {
[08:28:38.491]                     {
[08:28:38.491]                       base::local({
[08:28:38.491]                         has_future <- base::requireNamespace("future", 
[08:28:38.491]                           quietly = TRUE)
[08:28:38.491]                         if (has_future) {
[08:28:38.491]                           ns <- base::getNamespace("future")
[08:28:38.491]                           version <- ns[[".package"]][["version"]]
[08:28:38.491]                           if (is.null(version)) 
[08:28:38.491]                             version <- utils::packageVersion("future")
[08:28:38.491]                         }
[08:28:38.491]                         else {
[08:28:38.491]                           version <- NULL
[08:28:38.491]                         }
[08:28:38.491]                         if (!has_future || version < "1.8.0") {
[08:28:38.491]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:38.491]                             "", base::R.version$version.string), 
[08:28:38.491]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:38.491]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:38.491]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:38.491]                               "release", "version")], collapse = " "), 
[08:28:38.491]                             hostname = base::Sys.info()[["nodename"]])
[08:28:38.491]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:38.491]                             info)
[08:28:38.491]                           info <- base::paste(info, collapse = "; ")
[08:28:38.491]                           if (!has_future) {
[08:28:38.491]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:38.491]                               info)
[08:28:38.491]                           }
[08:28:38.491]                           else {
[08:28:38.491]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:38.491]                               info, version)
[08:28:38.491]                           }
[08:28:38.491]                           base::stop(msg)
[08:28:38.491]                         }
[08:28:38.491]                       })
[08:28:38.491]                     }
[08:28:38.491]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:38.491]                     base::options(mc.cores = 1L)
[08:28:38.491]                   }
[08:28:38.491]                   ...future.strategy.old <- future::plan("list")
[08:28:38.491]                   options(future.plan = NULL)
[08:28:38.491]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:38.491]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:38.491]                 }
[08:28:38.491]                 ...future.workdir <- getwd()
[08:28:38.491]             }
[08:28:38.491]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:38.491]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:38.491]         }
[08:28:38.491]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:38.491]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:38.491]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:38.491]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:38.491]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:38.491]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:38.491]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:38.491]             base::names(...future.oldOptions))
[08:28:38.491]     }
[08:28:38.491]     if (FALSE) {
[08:28:38.491]     }
[08:28:38.491]     else {
[08:28:38.491]         if (TRUE) {
[08:28:38.491]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:38.491]                 open = "w")
[08:28:38.491]         }
[08:28:38.491]         else {
[08:28:38.491]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:38.491]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:38.491]         }
[08:28:38.491]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:38.491]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:38.491]             base::sink(type = "output", split = FALSE)
[08:28:38.491]             base::close(...future.stdout)
[08:28:38.491]         }, add = TRUE)
[08:28:38.491]     }
[08:28:38.491]     ...future.frame <- base::sys.nframe()
[08:28:38.491]     ...future.conditions <- base::list()
[08:28:38.491]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:38.491]     if (FALSE) {
[08:28:38.491]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:38.491]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:38.491]     }
[08:28:38.491]     ...future.result <- base::tryCatch({
[08:28:38.491]         base::withCallingHandlers({
[08:28:38.491]             ...future.value <- base::withVisible(base::local({
[08:28:38.491]                 withCallingHandlers({
[08:28:38.491]                   {
[08:28:38.491]                     b <- 2L
[08:28:38.491]                     plan_b <- future::plan("list")
[08:28:38.491]                     nested_b <- nested_a[-1]
[08:28:38.491]                     stopifnot(length(nested_b) == 0L, length(plan_b) == 
[08:28:38.491]                       1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[08:28:38.491]                       "sequential"))
[08:28:38.491]                     list(a = a, nested_a = nested_a, plan_a = plan_a, 
[08:28:38.491]                       b = b, nested_b = nested_b, plan_b = plan_b)
[08:28:38.491]                   }
[08:28:38.491]                 }, immediateCondition = function(cond) {
[08:28:38.491]                   save_rds <- function (object, pathname, ...) 
[08:28:38.491]                   {
[08:28:38.491]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:38.491]                     if (file_test("-f", pathname_tmp)) {
[08:28:38.491]                       fi_tmp <- file.info(pathname_tmp)
[08:28:38.491]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:38.491]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:38.491]                         fi_tmp[["mtime"]])
[08:28:38.491]                     }
[08:28:38.491]                     tryCatch({
[08:28:38.491]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:38.491]                     }, error = function(ex) {
[08:28:38.491]                       msg <- conditionMessage(ex)
[08:28:38.491]                       fi_tmp <- file.info(pathname_tmp)
[08:28:38.491]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:38.491]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:38.491]                         fi_tmp[["mtime"]], msg)
[08:28:38.491]                       ex$message <- msg
[08:28:38.491]                       stop(ex)
[08:28:38.491]                     })
[08:28:38.491]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:38.491]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:38.491]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:38.491]                       fi_tmp <- file.info(pathname_tmp)
[08:28:38.491]                       fi <- file.info(pathname)
[08:28:38.491]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:38.491]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:38.491]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:38.491]                         fi[["size"]], fi[["mtime"]])
[08:28:38.491]                       stop(msg)
[08:28:38.491]                     }
[08:28:38.491]                     invisible(pathname)
[08:28:38.491]                   }
[08:28:38.491]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:38.491]                     rootPath = tempdir()) 
[08:28:38.491]                   {
[08:28:38.491]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:38.491]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:38.491]                       tmpdir = path, fileext = ".rds")
[08:28:38.491]                     save_rds(obj, file)
[08:28:38.491]                   }
[08:28:38.491]                   saveImmediateCondition(cond, path = "/tmp/RtmphjARvB/.future/immediateConditions")
[08:28:38.491]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:38.491]                   {
[08:28:38.491]                     inherits <- base::inherits
[08:28:38.491]                     invokeRestart <- base::invokeRestart
[08:28:38.491]                     is.null <- base::is.null
[08:28:38.491]                     muffled <- FALSE
[08:28:38.491]                     if (inherits(cond, "message")) {
[08:28:38.491]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:38.491]                       if (muffled) 
[08:28:38.491]                         invokeRestart("muffleMessage")
[08:28:38.491]                     }
[08:28:38.491]                     else if (inherits(cond, "warning")) {
[08:28:38.491]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:38.491]                       if (muffled) 
[08:28:38.491]                         invokeRestart("muffleWarning")
[08:28:38.491]                     }
[08:28:38.491]                     else if (inherits(cond, "condition")) {
[08:28:38.491]                       if (!is.null(pattern)) {
[08:28:38.491]                         computeRestarts <- base::computeRestarts
[08:28:38.491]                         grepl <- base::grepl
[08:28:38.491]                         restarts <- computeRestarts(cond)
[08:28:38.491]                         for (restart in restarts) {
[08:28:38.491]                           name <- restart$name
[08:28:38.491]                           if (is.null(name)) 
[08:28:38.491]                             next
[08:28:38.491]                           if (!grepl(pattern, name)) 
[08:28:38.491]                             next
[08:28:38.491]                           invokeRestart(restart)
[08:28:38.491]                           muffled <- TRUE
[08:28:38.491]                           break
[08:28:38.491]                         }
[08:28:38.491]                       }
[08:28:38.491]                     }
[08:28:38.491]                     invisible(muffled)
[08:28:38.491]                   }
[08:28:38.491]                   muffleCondition(cond)
[08:28:38.491]                 })
[08:28:38.491]             }))
[08:28:38.491]             future::FutureResult(value = ...future.value$value, 
[08:28:38.491]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:38.491]                   ...future.rng), globalenv = if (FALSE) 
[08:28:38.491]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:38.491]                     ...future.globalenv.names))
[08:28:38.491]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:38.491]         }, condition = base::local({
[08:28:38.491]             c <- base::c
[08:28:38.491]             inherits <- base::inherits
[08:28:38.491]             invokeRestart <- base::invokeRestart
[08:28:38.491]             length <- base::length
[08:28:38.491]             list <- base::list
[08:28:38.491]             seq.int <- base::seq.int
[08:28:38.491]             signalCondition <- base::signalCondition
[08:28:38.491]             sys.calls <- base::sys.calls
[08:28:38.491]             `[[` <- base::`[[`
[08:28:38.491]             `+` <- base::`+`
[08:28:38.491]             `<<-` <- base::`<<-`
[08:28:38.491]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:38.491]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:38.491]                   3L)]
[08:28:38.491]             }
[08:28:38.491]             function(cond) {
[08:28:38.491]                 is_error <- inherits(cond, "error")
[08:28:38.491]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:38.491]                   NULL)
[08:28:38.491]                 if (is_error) {
[08:28:38.491]                   sessionInformation <- function() {
[08:28:38.491]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:38.491]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:38.491]                       search = base::search(), system = base::Sys.info())
[08:28:38.491]                   }
[08:28:38.491]                   ...future.conditions[[length(...future.conditions) + 
[08:28:38.491]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:38.491]                     cond$call), session = sessionInformation(), 
[08:28:38.491]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:38.491]                   signalCondition(cond)
[08:28:38.491]                 }
[08:28:38.491]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:38.491]                 "immediateCondition"))) {
[08:28:38.491]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:38.491]                   ...future.conditions[[length(...future.conditions) + 
[08:28:38.491]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:38.491]                   if (TRUE && !signal) {
[08:28:38.491]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:38.491]                     {
[08:28:38.491]                       inherits <- base::inherits
[08:28:38.491]                       invokeRestart <- base::invokeRestart
[08:28:38.491]                       is.null <- base::is.null
[08:28:38.491]                       muffled <- FALSE
[08:28:38.491]                       if (inherits(cond, "message")) {
[08:28:38.491]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:38.491]                         if (muffled) 
[08:28:38.491]                           invokeRestart("muffleMessage")
[08:28:38.491]                       }
[08:28:38.491]                       else if (inherits(cond, "warning")) {
[08:28:38.491]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:38.491]                         if (muffled) 
[08:28:38.491]                           invokeRestart("muffleWarning")
[08:28:38.491]                       }
[08:28:38.491]                       else if (inherits(cond, "condition")) {
[08:28:38.491]                         if (!is.null(pattern)) {
[08:28:38.491]                           computeRestarts <- base::computeRestarts
[08:28:38.491]                           grepl <- base::grepl
[08:28:38.491]                           restarts <- computeRestarts(cond)
[08:28:38.491]                           for (restart in restarts) {
[08:28:38.491]                             name <- restart$name
[08:28:38.491]                             if (is.null(name)) 
[08:28:38.491]                               next
[08:28:38.491]                             if (!grepl(pattern, name)) 
[08:28:38.491]                               next
[08:28:38.491]                             invokeRestart(restart)
[08:28:38.491]                             muffled <- TRUE
[08:28:38.491]                             break
[08:28:38.491]                           }
[08:28:38.491]                         }
[08:28:38.491]                       }
[08:28:38.491]                       invisible(muffled)
[08:28:38.491]                     }
[08:28:38.491]                     muffleCondition(cond, pattern = "^muffle")
[08:28:38.491]                   }
[08:28:38.491]                 }
[08:28:38.491]                 else {
[08:28:38.491]                   if (TRUE) {
[08:28:38.491]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:38.491]                     {
[08:28:38.491]                       inherits <- base::inherits
[08:28:38.491]                       invokeRestart <- base::invokeRestart
[08:28:38.491]                       is.null <- base::is.null
[08:28:38.491]                       muffled <- FALSE
[08:28:38.491]                       if (inherits(cond, "message")) {
[08:28:38.491]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:38.491]                         if (muffled) 
[08:28:38.491]                           invokeRestart("muffleMessage")
[08:28:38.491]                       }
[08:28:38.491]                       else if (inherits(cond, "warning")) {
[08:28:38.491]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:38.491]                         if (muffled) 
[08:28:38.491]                           invokeRestart("muffleWarning")
[08:28:38.491]                       }
[08:28:38.491]                       else if (inherits(cond, "condition")) {
[08:28:38.491]                         if (!is.null(pattern)) {
[08:28:38.491]                           computeRestarts <- base::computeRestarts
[08:28:38.491]                           grepl <- base::grepl
[08:28:38.491]                           restarts <- computeRestarts(cond)
[08:28:38.491]                           for (restart in restarts) {
[08:28:38.491]                             name <- restart$name
[08:28:38.491]                             if (is.null(name)) 
[08:28:38.491]                               next
[08:28:38.491]                             if (!grepl(pattern, name)) 
[08:28:38.491]                               next
[08:28:38.491]                             invokeRestart(restart)
[08:28:38.491]                             muffled <- TRUE
[08:28:38.491]                             break
[08:28:38.491]                           }
[08:28:38.491]                         }
[08:28:38.491]                       }
[08:28:38.491]                       invisible(muffled)
[08:28:38.491]                     }
[08:28:38.491]                     muffleCondition(cond, pattern = "^muffle")
[08:28:38.491]                   }
[08:28:38.491]                 }
[08:28:38.491]             }
[08:28:38.491]         }))
[08:28:38.491]     }, error = function(ex) {
[08:28:38.491]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:38.491]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:38.491]                 ...future.rng), started = ...future.startTime, 
[08:28:38.491]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:38.491]             version = "1.8"), class = "FutureResult")
[08:28:38.491]     }, finally = {
[08:28:38.491]         if (!identical(...future.workdir, getwd())) 
[08:28:38.491]             setwd(...future.workdir)
[08:28:38.491]         {
[08:28:38.491]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:38.491]                 ...future.oldOptions$nwarnings <- NULL
[08:28:38.491]             }
[08:28:38.491]             base::options(...future.oldOptions)
[08:28:38.491]             if (.Platform$OS.type == "windows") {
[08:28:38.491]                 old_names <- names(...future.oldEnvVars)
[08:28:38.491]                 envs <- base::Sys.getenv()
[08:28:38.491]                 names <- names(envs)
[08:28:38.491]                 common <- intersect(names, old_names)
[08:28:38.491]                 added <- setdiff(names, old_names)
[08:28:38.491]                 removed <- setdiff(old_names, names)
[08:28:38.491]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:38.491]                   envs[common]]
[08:28:38.491]                 NAMES <- toupper(changed)
[08:28:38.491]                 args <- list()
[08:28:38.491]                 for (kk in seq_along(NAMES)) {
[08:28:38.491]                   name <- changed[[kk]]
[08:28:38.491]                   NAME <- NAMES[[kk]]
[08:28:38.491]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:38.491]                     next
[08:28:38.491]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:38.491]                 }
[08:28:38.491]                 NAMES <- toupper(added)
[08:28:38.491]                 for (kk in seq_along(NAMES)) {
[08:28:38.491]                   name <- added[[kk]]
[08:28:38.491]                   NAME <- NAMES[[kk]]
[08:28:38.491]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:38.491]                     next
[08:28:38.491]                   args[[name]] <- ""
[08:28:38.491]                 }
[08:28:38.491]                 NAMES <- toupper(removed)
[08:28:38.491]                 for (kk in seq_along(NAMES)) {
[08:28:38.491]                   name <- removed[[kk]]
[08:28:38.491]                   NAME <- NAMES[[kk]]
[08:28:38.491]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:38.491]                     next
[08:28:38.491]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:38.491]                 }
[08:28:38.491]                 if (length(args) > 0) 
[08:28:38.491]                   base::do.call(base::Sys.setenv, args = args)
[08:28:38.491]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:38.491]             }
[08:28:38.491]             else {
[08:28:38.491]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:38.491]             }
[08:28:38.491]             {
[08:28:38.491]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:38.491]                   0L) {
[08:28:38.491]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:38.491]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:38.491]                   base::options(opts)
[08:28:38.491]                 }
[08:28:38.491]                 {
[08:28:38.491]                   {
[08:28:38.491]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:38.491]                     NULL
[08:28:38.491]                   }
[08:28:38.491]                   options(future.plan = NULL)
[08:28:38.491]                   if (is.na(NA_character_)) 
[08:28:38.491]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:38.491]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:38.491]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:38.491]                     .init = FALSE)
[08:28:38.491]                 }
[08:28:38.491]             }
[08:28:38.491]         }
[08:28:38.491]     })
[08:28:38.491]     if (TRUE) {
[08:28:38.491]         base::sink(type = "output", split = FALSE)
[08:28:38.491]         if (TRUE) {
[08:28:38.491]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:38.491]         }
[08:28:38.491]         else {
[08:28:38.491]             ...future.result["stdout"] <- base::list(NULL)
[08:28:38.491]         }
[08:28:38.491]         base::close(...future.stdout)
[08:28:38.491]         ...future.stdout <- NULL
[08:28:38.491]     }
[08:28:38.491]     ...future.result$conditions <- ...future.conditions
[08:28:38.491]     ...future.result$finished <- base::Sys.time()
[08:28:38.491]     ...future.result
[08:28:38.491] }
[08:28:38.526]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.493] assign_globals() ...
[08:28:38.526]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.493] List of 3
[08:28:38.493]  $ nested_a:List of 1
[08:28:38.493]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[08:28:38.493]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[08:28:38.493]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[08:28:38.493]  $ a       : int 1
[08:28:38.493]  $ plan_a  :List of 1
[08:28:38.493]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[08:28:38.493]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[08:28:38.493]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[08:28:38.493]  - attr(*, "where")=List of 3
[08:28:38.493]   ..$ nested_a:<environment: R_EmptyEnv> 
[08:28:38.493]   ..$ a       :<environment: R_EmptyEnv> 
[08:28:38.493]   ..$ plan_a  :<environment: R_EmptyEnv> 
[08:28:38.493]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:38.493]  - attr(*, "resolved")= logi FALSE
[08:28:38.493]  - attr(*, "total_size")= num 12841
[08:28:38.493]  - attr(*, "already-done")= logi TRUE
[08:28:38.528]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.498] - copied ‘nested_a’ to environment
[08:28:38.529]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.498] - copied ‘a’ to environment
[08:28:38.529]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.499] - copied ‘plan_a’ to environment
[08:28:38.529]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.499] assign_globals() ... done
[08:28:38.529]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.499] requestCore(): workers = 2
[08:28:38.529]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.502] MulticoreFuture started
[08:28:38.530]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.503] - Launch lazy future ... done
[08:28:38.530]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.503] run() for ‘MulticoreFuture’ ... done
[08:28:38.530]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.504] result() for MulticoreFuture ...
[08:28:38.530]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.514] result() for MulticoreFuture ...
[08:28:38.530]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.514] result() for MulticoreFuture ... done
[08:28:38.530]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.514] result() for MulticoreFuture ... done
[08:28:38.531]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.515] result() for MulticoreFuture ...
[08:28:38.531]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.515] result() for MulticoreFuture ... done
[08:28:38.531] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[08:28:38.537] getGlobalsAndPackages() ...
[08:28:38.537] Searching for globals...
[08:28:38.539] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[08:28:38.539] Searching for globals ... DONE
[08:28:38.539] Resolving globals: FALSE
[08:28:38.539] The total size of the 1 globals is 356 bytes (356 bytes)
[08:28:38.540] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[08:28:38.540] - globals: [1] ‘data’
[08:28:38.540] - packages: [1] ‘future’
[08:28:38.540] getGlobalsAndPackages() ... DONE
[08:28:38.540] run() for ‘Future’ ...
[08:28:38.541] - state: ‘created’
[08:28:38.541] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:38.541] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:38.541] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:38.541]   - Field: ‘label’
[08:28:38.541]   - Field: ‘local’
[08:28:38.541]   - Field: ‘owner’
[08:28:38.541]   - Field: ‘envir’
[08:28:38.542]   - Field: ‘packages’
[08:28:38.542]   - Field: ‘gc’
[08:28:38.542]   - Field: ‘conditions’
[08:28:38.542]   - Field: ‘expr’
[08:28:38.542]   - Field: ‘uuid’
[08:28:38.542]   - Field: ‘seed’
[08:28:38.542]   - Field: ‘version’
[08:28:38.542]   - Field: ‘result’
[08:28:38.542]   - Field: ‘asynchronous’
[08:28:38.542]   - Field: ‘calls’
[08:28:38.542]   - Field: ‘globals’
[08:28:38.542]   - Field: ‘stdout’
[08:28:38.543]   - Field: ‘earlySignal’
[08:28:38.543]   - Field: ‘lazy’
[08:28:38.543]   - Field: ‘state’
[08:28:38.543] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:38.543] - Launch lazy future ...
[08:28:38.543] Packages needed by the future expression (n = 1): ‘future’
[08:28:38.543] Packages needed by future strategies (n = 1): ‘future’
[08:28:38.544] {
[08:28:38.544]     {
[08:28:38.544]         {
[08:28:38.544]             ...future.startTime <- base::Sys.time()
[08:28:38.544]             {
[08:28:38.544]                 {
[08:28:38.544]                   {
[08:28:38.544]                     {
[08:28:38.544]                       base::local({
[08:28:38.544]                         has_future <- base::requireNamespace("future", 
[08:28:38.544]                           quietly = TRUE)
[08:28:38.544]                         if (has_future) {
[08:28:38.544]                           ns <- base::getNamespace("future")
[08:28:38.544]                           version <- ns[[".package"]][["version"]]
[08:28:38.544]                           if (is.null(version)) 
[08:28:38.544]                             version <- utils::packageVersion("future")
[08:28:38.544]                         }
[08:28:38.544]                         else {
[08:28:38.544]                           version <- NULL
[08:28:38.544]                         }
[08:28:38.544]                         if (!has_future || version < "1.8.0") {
[08:28:38.544]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:38.544]                             "", base::R.version$version.string), 
[08:28:38.544]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:38.544]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:38.544]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:38.544]                               "release", "version")], collapse = " "), 
[08:28:38.544]                             hostname = base::Sys.info()[["nodename"]])
[08:28:38.544]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:38.544]                             info)
[08:28:38.544]                           info <- base::paste(info, collapse = "; ")
[08:28:38.544]                           if (!has_future) {
[08:28:38.544]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:38.544]                               info)
[08:28:38.544]                           }
[08:28:38.544]                           else {
[08:28:38.544]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:38.544]                               info, version)
[08:28:38.544]                           }
[08:28:38.544]                           base::stop(msg)
[08:28:38.544]                         }
[08:28:38.544]                       })
[08:28:38.544]                     }
[08:28:38.544]                     base::local({
[08:28:38.544]                       for (pkg in "future") {
[08:28:38.544]                         base::loadNamespace(pkg)
[08:28:38.544]                         base::library(pkg, character.only = TRUE)
[08:28:38.544]                       }
[08:28:38.544]                     })
[08:28:38.544]                   }
[08:28:38.544]                   ...future.strategy.old <- future::plan("list")
[08:28:38.544]                   options(future.plan = NULL)
[08:28:38.544]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:38.544]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[08:28:38.544]                     envir = parent.frame()) 
[08:28:38.544]                   {
[08:28:38.544]                     default_workers <- missing(workers)
[08:28:38.544]                     if (is.function(workers)) 
[08:28:38.544]                       workers <- workers()
[08:28:38.544]                     workers <- structure(as.integer(workers), 
[08:28:38.544]                       class = class(workers))
[08:28:38.544]                     stop_if_not(is.finite(workers), workers >= 
[08:28:38.544]                       1L)
[08:28:38.544]                     if ((workers == 1L && !inherits(workers, 
[08:28:38.544]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[08:28:38.544]                       if (default_workers) 
[08:28:38.544]                         supportsMulticore(warn = TRUE)
[08:28:38.544]                       return(sequential(..., envir = envir))
[08:28:38.544]                     }
[08:28:38.544]                     oopts <- options(mc.cores = workers)
[08:28:38.544]                     on.exit(options(oopts))
[08:28:38.544]                     future <- MulticoreFuture(..., workers = workers, 
[08:28:38.544]                       envir = envir)
[08:28:38.544]                     if (!future$lazy) 
[08:28:38.544]                       future <- run(future)
[08:28:38.544]                     invisible(future)
[08:28:38.544]                   }), .cleanup = FALSE, .init = FALSE)
[08:28:38.544]                 }
[08:28:38.544]                 ...future.workdir <- getwd()
[08:28:38.544]             }
[08:28:38.544]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:38.544]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:38.544]         }
[08:28:38.544]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:38.544]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:38.544]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:38.544]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:38.544]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:38.544]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:38.544]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:38.544]             base::names(...future.oldOptions))
[08:28:38.544]     }
[08:28:38.544]     if (FALSE) {
[08:28:38.544]     }
[08:28:38.544]     else {
[08:28:38.544]         if (TRUE) {
[08:28:38.544]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:38.544]                 open = "w")
[08:28:38.544]         }
[08:28:38.544]         else {
[08:28:38.544]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:38.544]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:38.544]         }
[08:28:38.544]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:38.544]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:38.544]             base::sink(type = "output", split = FALSE)
[08:28:38.544]             base::close(...future.stdout)
[08:28:38.544]         }, add = TRUE)
[08:28:38.544]     }
[08:28:38.544]     ...future.frame <- base::sys.nframe()
[08:28:38.544]     ...future.conditions <- base::list()
[08:28:38.544]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:38.544]     if (FALSE) {
[08:28:38.544]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:38.544]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:38.544]     }
[08:28:38.544]     ...future.result <- base::tryCatch({
[08:28:38.544]         base::withCallingHandlers({
[08:28:38.544]             ...future.value <- base::withVisible(base::local({
[08:28:38.544]                 value(future(subset(data, a == 2)))
[08:28:38.544]             }))
[08:28:38.544]             future::FutureResult(value = ...future.value$value, 
[08:28:38.544]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:38.544]                   ...future.rng), globalenv = if (FALSE) 
[08:28:38.544]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:38.544]                     ...future.globalenv.names))
[08:28:38.544]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:38.544]         }, condition = base::local({
[08:28:38.544]             c <- base::c
[08:28:38.544]             inherits <- base::inherits
[08:28:38.544]             invokeRestart <- base::invokeRestart
[08:28:38.544]             length <- base::length
[08:28:38.544]             list <- base::list
[08:28:38.544]             seq.int <- base::seq.int
[08:28:38.544]             signalCondition <- base::signalCondition
[08:28:38.544]             sys.calls <- base::sys.calls
[08:28:38.544]             `[[` <- base::`[[`
[08:28:38.544]             `+` <- base::`+`
[08:28:38.544]             `<<-` <- base::`<<-`
[08:28:38.544]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:38.544]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:38.544]                   3L)]
[08:28:38.544]             }
[08:28:38.544]             function(cond) {
[08:28:38.544]                 is_error <- inherits(cond, "error")
[08:28:38.544]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:38.544]                   NULL)
[08:28:38.544]                 if (is_error) {
[08:28:38.544]                   sessionInformation <- function() {
[08:28:38.544]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:38.544]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:38.544]                       search = base::search(), system = base::Sys.info())
[08:28:38.544]                   }
[08:28:38.544]                   ...future.conditions[[length(...future.conditions) + 
[08:28:38.544]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:38.544]                     cond$call), session = sessionInformation(), 
[08:28:38.544]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:38.544]                   signalCondition(cond)
[08:28:38.544]                 }
[08:28:38.544]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:38.544]                 "immediateCondition"))) {
[08:28:38.544]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:38.544]                   ...future.conditions[[length(...future.conditions) + 
[08:28:38.544]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:38.544]                   if (TRUE && !signal) {
[08:28:38.544]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:38.544]                     {
[08:28:38.544]                       inherits <- base::inherits
[08:28:38.544]                       invokeRestart <- base::invokeRestart
[08:28:38.544]                       is.null <- base::is.null
[08:28:38.544]                       muffled <- FALSE
[08:28:38.544]                       if (inherits(cond, "message")) {
[08:28:38.544]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:38.544]                         if (muffled) 
[08:28:38.544]                           invokeRestart("muffleMessage")
[08:28:38.544]                       }
[08:28:38.544]                       else if (inherits(cond, "warning")) {
[08:28:38.544]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:38.544]                         if (muffled) 
[08:28:38.544]                           invokeRestart("muffleWarning")
[08:28:38.544]                       }
[08:28:38.544]                       else if (inherits(cond, "condition")) {
[08:28:38.544]                         if (!is.null(pattern)) {
[08:28:38.544]                           computeRestarts <- base::computeRestarts
[08:28:38.544]                           grepl <- base::grepl
[08:28:38.544]                           restarts <- computeRestarts(cond)
[08:28:38.544]                           for (restart in restarts) {
[08:28:38.544]                             name <- restart$name
[08:28:38.544]                             if (is.null(name)) 
[08:28:38.544]                               next
[08:28:38.544]                             if (!grepl(pattern, name)) 
[08:28:38.544]                               next
[08:28:38.544]                             invokeRestart(restart)
[08:28:38.544]                             muffled <- TRUE
[08:28:38.544]                             break
[08:28:38.544]                           }
[08:28:38.544]                         }
[08:28:38.544]                       }
[08:28:38.544]                       invisible(muffled)
[08:28:38.544]                     }
[08:28:38.544]                     muffleCondition(cond, pattern = "^muffle")
[08:28:38.544]                   }
[08:28:38.544]                 }
[08:28:38.544]                 else {
[08:28:38.544]                   if (TRUE) {
[08:28:38.544]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:38.544]                     {
[08:28:38.544]                       inherits <- base::inherits
[08:28:38.544]                       invokeRestart <- base::invokeRestart
[08:28:38.544]                       is.null <- base::is.null
[08:28:38.544]                       muffled <- FALSE
[08:28:38.544]                       if (inherits(cond, "message")) {
[08:28:38.544]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:38.544]                         if (muffled) 
[08:28:38.544]                           invokeRestart("muffleMessage")
[08:28:38.544]                       }
[08:28:38.544]                       else if (inherits(cond, "warning")) {
[08:28:38.544]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:38.544]                         if (muffled) 
[08:28:38.544]                           invokeRestart("muffleWarning")
[08:28:38.544]                       }
[08:28:38.544]                       else if (inherits(cond, "condition")) {
[08:28:38.544]                         if (!is.null(pattern)) {
[08:28:38.544]                           computeRestarts <- base::computeRestarts
[08:28:38.544]                           grepl <- base::grepl
[08:28:38.544]                           restarts <- computeRestarts(cond)
[08:28:38.544]                           for (restart in restarts) {
[08:28:38.544]                             name <- restart$name
[08:28:38.544]                             if (is.null(name)) 
[08:28:38.544]                               next
[08:28:38.544]                             if (!grepl(pattern, name)) 
[08:28:38.544]                               next
[08:28:38.544]                             invokeRestart(restart)
[08:28:38.544]                             muffled <- TRUE
[08:28:38.544]                             break
[08:28:38.544]                           }
[08:28:38.544]                         }
[08:28:38.544]                       }
[08:28:38.544]                       invisible(muffled)
[08:28:38.544]                     }
[08:28:38.544]                     muffleCondition(cond, pattern = "^muffle")
[08:28:38.544]                   }
[08:28:38.544]                 }
[08:28:38.544]             }
[08:28:38.544]         }))
[08:28:38.544]     }, error = function(ex) {
[08:28:38.544]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:38.544]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:38.544]                 ...future.rng), started = ...future.startTime, 
[08:28:38.544]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:38.544]             version = "1.8"), class = "FutureResult")
[08:28:38.544]     }, finally = {
[08:28:38.544]         if (!identical(...future.workdir, getwd())) 
[08:28:38.544]             setwd(...future.workdir)
[08:28:38.544]         {
[08:28:38.544]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:38.544]                 ...future.oldOptions$nwarnings <- NULL
[08:28:38.544]             }
[08:28:38.544]             base::options(...future.oldOptions)
[08:28:38.544]             if (.Platform$OS.type == "windows") {
[08:28:38.544]                 old_names <- names(...future.oldEnvVars)
[08:28:38.544]                 envs <- base::Sys.getenv()
[08:28:38.544]                 names <- names(envs)
[08:28:38.544]                 common <- intersect(names, old_names)
[08:28:38.544]                 added <- setdiff(names, old_names)
[08:28:38.544]                 removed <- setdiff(old_names, names)
[08:28:38.544]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:38.544]                   envs[common]]
[08:28:38.544]                 NAMES <- toupper(changed)
[08:28:38.544]                 args <- list()
[08:28:38.544]                 for (kk in seq_along(NAMES)) {
[08:28:38.544]                   name <- changed[[kk]]
[08:28:38.544]                   NAME <- NAMES[[kk]]
[08:28:38.544]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:38.544]                     next
[08:28:38.544]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:38.544]                 }
[08:28:38.544]                 NAMES <- toupper(added)
[08:28:38.544]                 for (kk in seq_along(NAMES)) {
[08:28:38.544]                   name <- added[[kk]]
[08:28:38.544]                   NAME <- NAMES[[kk]]
[08:28:38.544]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:38.544]                     next
[08:28:38.544]                   args[[name]] <- ""
[08:28:38.544]                 }
[08:28:38.544]                 NAMES <- toupper(removed)
[08:28:38.544]                 for (kk in seq_along(NAMES)) {
[08:28:38.544]                   name <- removed[[kk]]
[08:28:38.544]                   NAME <- NAMES[[kk]]
[08:28:38.544]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:38.544]                     next
[08:28:38.544]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:38.544]                 }
[08:28:38.544]                 if (length(args) > 0) 
[08:28:38.544]                   base::do.call(base::Sys.setenv, args = args)
[08:28:38.544]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:38.544]             }
[08:28:38.544]             else {
[08:28:38.544]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:38.544]             }
[08:28:38.544]             {
[08:28:38.544]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:38.544]                   0L) {
[08:28:38.544]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:38.544]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:38.544]                   base::options(opts)
[08:28:38.544]                 }
[08:28:38.544]                 {
[08:28:38.544]                   {
[08:28:38.544]                     NULL
[08:28:38.544]                     RNGkind("Mersenne-Twister")
[08:28:38.544]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:38.544]                       inherits = FALSE)
[08:28:38.544]                   }
[08:28:38.544]                   options(future.plan = NULL)
[08:28:38.544]                   if (is.na(NA_character_)) 
[08:28:38.544]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:38.544]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:38.544]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:38.544]                     .init = FALSE)
[08:28:38.544]                 }
[08:28:38.544]             }
[08:28:38.544]         }
[08:28:38.544]     })
[08:28:38.544]     if (TRUE) {
[08:28:38.544]         base::sink(type = "output", split = FALSE)
[08:28:38.544]         if (TRUE) {
[08:28:38.544]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:38.544]         }
[08:28:38.544]         else {
[08:28:38.544]             ...future.result["stdout"] <- base::list(NULL)
[08:28:38.544]         }
[08:28:38.544]         base::close(...future.stdout)
[08:28:38.544]         ...future.stdout <- NULL
[08:28:38.544]     }
[08:28:38.544]     ...future.result$conditions <- ...future.conditions
[08:28:38.544]     ...future.result$finished <- base::Sys.time()
[08:28:38.544]     ...future.result
[08:28:38.544] }
[08:28:38.546] assign_globals() ...
[08:28:38.546] List of 1
[08:28:38.546]  $ data:'data.frame':	3 obs. of  2 variables:
[08:28:38.546]   ..$ a: int [1:3] 1 2 3
[08:28:38.546]   ..$ b: int [1:3] 3 2 1
[08:28:38.546]  - attr(*, "where")=List of 1
[08:28:38.546]   ..$ data:<environment: R_EmptyEnv> 
[08:28:38.546]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:38.546]  - attr(*, "resolved")= logi FALSE
[08:28:38.546]  - attr(*, "total_size")= num 356
[08:28:38.546]  - attr(*, "already-done")= logi TRUE
[08:28:38.549] - copied ‘data’ to environment
[08:28:38.549] assign_globals() ... done
[08:28:38.549] plan(): Setting new future strategy stack:
[08:28:38.550] List of future strategies:
[08:28:38.550] 1. multicore:
[08:28:38.550]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:38.550]    - tweaked: FALSE
[08:28:38.550]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:38.551] plan(): nbrOfWorkers() = 2
[08:28:38.597] plan(): Setting new future strategy stack:
[08:28:38.597] List of future strategies:
[08:28:38.597] 1. sequential:
[08:28:38.597]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:38.597]    - tweaked: FALSE
[08:28:38.597]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:38.597] 2. multicore:
[08:28:38.597]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:38.597]    - tweaked: FALSE
[08:28:38.597]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:38.598] plan(): nbrOfWorkers() = 1
[08:28:38.598] SequentialFuture started (and completed)
[08:28:38.598] signalConditions() ...
[08:28:38.598]  - include = ‘immediateCondition’
[08:28:38.598]  - exclude = 
[08:28:38.599]  - resignal = FALSE
[08:28:38.599]  - Number of conditions: 55
[08:28:38.599] signalConditions() ... done
[08:28:38.599] - Launch lazy future ... done
[08:28:38.599] run() for ‘SequentialFuture’ ... done
[08:28:38.599] signalConditions() ...
[08:28:38.600]  - include = ‘immediateCondition’
[08:28:38.600]  - exclude = 
[08:28:38.600]  - resignal = FALSE
[08:28:38.600]  - Number of conditions: 55
[08:28:38.600] signalConditions() ... done
[08:28:38.600] Future state: ‘finished’
[08:28:38.600] signalConditions() ...
[08:28:38.600]  - include = ‘condition’
[08:28:38.600]  - exclude = ‘immediateCondition’
[08:28:38.601]  - resignal = TRUE
[08:28:38.601]  - Number of conditions: 55
[08:28:38.601]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.552] getGlobalsAndPackages() ...
[08:28:38.601]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.552] Searching for globals...
[08:28:38.601]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.568] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[08:28:38.601]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.569] Searching for globals ... DONE
[08:28:38.601]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.569] Resolving globals: FALSE
[08:28:38.602]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.569] The total size of the 1 globals is 356 bytes (356 bytes)
[08:28:38.602]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.569] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[08:28:38.602]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.570] - globals: [1] ‘data’
[08:28:38.602]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.570] 
[08:28:38.602]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.570] getGlobalsAndPackages() ... DONE
[08:28:38.602]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.570] run() for ‘Future’ ...
[08:28:38.603]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.570] - state: ‘created’
[08:28:38.603]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.570] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:38.603]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.572] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:38.603]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.572] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:38.603]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.572]   - Field: ‘label’
[08:28:38.603]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.572]   - Field: ‘local’
[08:28:38.604]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.573]   - Field: ‘owner’
[08:28:38.604]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.573]   - Field: ‘envir’
[08:28:38.604]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.573]   - Field: ‘workers’
[08:28:38.604]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.573]   - Field: ‘packages’
[08:28:38.604]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.573]   - Field: ‘gc’
[08:28:38.604]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.573]   - Field: ‘job’
[08:28:38.604]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.573]   - Field: ‘conditions’
[08:28:38.605]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.573]   - Field: ‘expr’
[08:28:38.605]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.573]   - Field: ‘uuid’
[08:28:38.605]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.573]   - Field: ‘seed’
[08:28:38.605]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.574]   - Field: ‘version’
[08:28:38.605]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.574]   - Field: ‘result’
[08:28:38.605]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.574]   - Field: ‘asynchronous’
[08:28:38.605]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.574]   - Field: ‘calls’
[08:28:38.606]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.574]   - Field: ‘globals’
[08:28:38.606]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.574]   - Field: ‘stdout’
[08:28:38.606]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.574]   - Field: ‘earlySignal’
[08:28:38.606]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.574]   - Field: ‘lazy’
[08:28:38.606]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.574]   - Field: ‘state’
[08:28:38.606]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.574] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:38.607]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.575] - Launch lazy future ...
[08:28:38.607]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.575] Packages needed by the future expression (n = 0): <none>
[08:28:38.607]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.577] Packages needed by future strategies (n = 0): <none>
[08:28:38.607]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.577] {
[08:28:38.577]     {
[08:28:38.577]         {
[08:28:38.577]             ...future.startTime <- base::Sys.time()
[08:28:38.577]             {
[08:28:38.577]                 {
[08:28:38.577]                   {
[08:28:38.577]                     {
[08:28:38.577]                       base::local({
[08:28:38.577]                         has_future <- base::requireNamespace("future", 
[08:28:38.577]                           quietly = TRUE)
[08:28:38.577]                         if (has_future) {
[08:28:38.577]                           ns <- base::getNamespace("future")
[08:28:38.577]                           version <- ns[[".package"]][["version"]]
[08:28:38.577]                           if (is.null(version)) 
[08:28:38.577]                             version <- utils::packageVersion("future")
[08:28:38.577]                         }
[08:28:38.577]                         else {
[08:28:38.577]                           version <- NULL
[08:28:38.577]                         }
[08:28:38.577]                         if (!has_future || version < "1.8.0") {
[08:28:38.577]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:38.577]                             "", base::R.version$version.string), 
[08:28:38.577]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:38.577]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:38.577]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:38.577]                               "release", "version")], collapse = " "), 
[08:28:38.577]                             hostname = base::Sys.info()[["nodename"]])
[08:28:38.577]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:38.577]                             info)
[08:28:38.577]                           info <- base::paste(info, collapse = "; ")
[08:28:38.577]                           if (!has_future) {
[08:28:38.577]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:38.577]                               info)
[08:28:38.577]                           }
[08:28:38.577]                           else {
[08:28:38.577]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:38.577]                               info, version)
[08:28:38.577]                           }
[08:28:38.577]                           base::stop(msg)
[08:28:38.577]                         }
[08:28:38.577]                       })
[08:28:38.577]                     }
[08:28:38.577]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:38.577]                     base::options(mc.cores = 1L)
[08:28:38.577]                   }
[08:28:38.577]                   ...future.strategy.old <- future::plan("list")
[08:28:38.577]                   options(future.plan = NULL)
[08:28:38.577]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:38.577]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:38.577]                 }
[08:28:38.577]                 ...future.workdir <- getwd()
[08:28:38.577]             }
[08:28:38.577]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:38.577]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:38.577]         }
[08:28:38.577]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:38.577]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:38.577]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:38.577]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:38.577]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:38.577]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:38.577]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:38.577]             base::names(...future.oldOptions))
[08:28:38.577]     }
[08:28:38.577]     if (FALSE) {
[08:28:38.577]     }
[08:28:38.577]     else {
[08:28:38.577]         if (TRUE) {
[08:28:38.577]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:38.577]                 open = "w")
[08:28:38.577]         }
[08:28:38.577]         else {
[08:28:38.577]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:38.577]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:38.577]         }
[08:28:38.577]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:38.577]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:38.577]             base::sink(type = "output", split = FALSE)
[08:28:38.577]             base::close(...future.stdout)
[08:28:38.577]         }, add = TRUE)
[08:28:38.577]     }
[08:28:38.577]     ...future.frame <- base::sys.nframe()
[08:28:38.577]     ...future.conditions <- base::list()
[08:28:38.577]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:38.577]     if (FALSE) {
[08:28:38.577]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:38.577]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:38.577]     }
[08:28:38.577]     ...future.result <- base::tryCatch({
[08:28:38.577]         base::withCallingHandlers({
[08:28:38.577]             ...future.value <- base::withVisible(base::local({
[08:28:38.577]                 withCallingHandlers({
[08:28:38.577]                   subset(data, a == 2)
[08:28:38.577]                 }, immediateCondition = function(cond) {
[08:28:38.577]                   save_rds <- function (object, pathname, ...) 
[08:28:38.577]                   {
[08:28:38.577]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:38.577]                     if (file_test("-f", pathname_tmp)) {
[08:28:38.577]                       fi_tmp <- file.info(pathname_tmp)
[08:28:38.577]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:38.577]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:38.577]                         fi_tmp[["mtime"]])
[08:28:38.577]                     }
[08:28:38.577]                     tryCatch({
[08:28:38.577]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:38.577]                     }, error = function(ex) {
[08:28:38.577]                       msg <- conditionMessage(ex)
[08:28:38.577]                       fi_tmp <- file.info(pathname_tmp)
[08:28:38.577]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:38.577]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:38.577]                         fi_tmp[["mtime"]], msg)
[08:28:38.577]                       ex$message <- msg
[08:28:38.577]                       stop(ex)
[08:28:38.577]                     })
[08:28:38.577]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:38.577]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:38.577]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:38.577]                       fi_tmp <- file.info(pathname_tmp)
[08:28:38.577]                       fi <- file.info(pathname)
[08:28:38.577]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:38.577]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:38.577]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:38.577]                         fi[["size"]], fi[["mtime"]])
[08:28:38.577]                       stop(msg)
[08:28:38.577]                     }
[08:28:38.577]                     invisible(pathname)
[08:28:38.577]                   }
[08:28:38.577]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:38.577]                     rootPath = tempdir()) 
[08:28:38.577]                   {
[08:28:38.577]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:38.577]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:38.577]                       tmpdir = path, fileext = ".rds")
[08:28:38.577]                     save_rds(obj, file)
[08:28:38.577]                   }
[08:28:38.577]                   saveImmediateCondition(cond, path = "/tmp/RtmphjARvB/.future/immediateConditions")
[08:28:38.577]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:38.577]                   {
[08:28:38.577]                     inherits <- base::inherits
[08:28:38.577]                     invokeRestart <- base::invokeRestart
[08:28:38.577]                     is.null <- base::is.null
[08:28:38.577]                     muffled <- FALSE
[08:28:38.577]                     if (inherits(cond, "message")) {
[08:28:38.577]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:38.577]                       if (muffled) 
[08:28:38.577]                         invokeRestart("muffleMessage")
[08:28:38.577]                     }
[08:28:38.577]                     else if (inherits(cond, "warning")) {
[08:28:38.577]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:38.577]                       if (muffled) 
[08:28:38.577]                         invokeRestart("muffleWarning")
[08:28:38.577]                     }
[08:28:38.577]                     else if (inherits(cond, "condition")) {
[08:28:38.577]                       if (!is.null(pattern)) {
[08:28:38.577]                         computeRestarts <- base::computeRestarts
[08:28:38.577]                         grepl <- base::grepl
[08:28:38.577]                         restarts <- computeRestarts(cond)
[08:28:38.577]                         for (restart in restarts) {
[08:28:38.577]                           name <- restart$name
[08:28:38.577]                           if (is.null(name)) 
[08:28:38.577]                             next
[08:28:38.577]                           if (!grepl(pattern, name)) 
[08:28:38.577]                             next
[08:28:38.577]                           invokeRestart(restart)
[08:28:38.577]                           muffled <- TRUE
[08:28:38.577]                           break
[08:28:38.577]                         }
[08:28:38.577]                       }
[08:28:38.577]                     }
[08:28:38.577]                     invisible(muffled)
[08:28:38.577]                   }
[08:28:38.577]                   muffleCondition(cond)
[08:28:38.577]                 })
[08:28:38.577]             }))
[08:28:38.577]             future::FutureResult(value = ...future.value$value, 
[08:28:38.577]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:38.577]                   ...future.rng), globalenv = if (FALSE) 
[08:28:38.577]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:38.577]                     ...future.globalenv.names))
[08:28:38.577]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:38.577]         }, condition = base::local({
[08:28:38.577]             c <- base::c
[08:28:38.577]             inherits <- base::inherits
[08:28:38.577]             invokeRestart <- base::invokeRestart
[08:28:38.577]             length <- base::length
[08:28:38.577]             list <- base::list
[08:28:38.577]             seq.int <- base::seq.int
[08:28:38.577]             signalCondition <- base::signalCondition
[08:28:38.577]             sys.calls <- base::sys.calls
[08:28:38.577]             `[[` <- base::`[[`
[08:28:38.577]             `+` <- base::`+`
[08:28:38.577]             `<<-` <- base::`<<-`
[08:28:38.577]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:38.577]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:38.577]                   3L)]
[08:28:38.577]             }
[08:28:38.577]             function(cond) {
[08:28:38.577]                 is_error <- inherits(cond, "error")
[08:28:38.577]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:38.577]                   NULL)
[08:28:38.577]                 if (is_error) {
[08:28:38.577]                   sessionInformation <- function() {
[08:28:38.577]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:38.577]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:38.577]                       search = base::search(), system = base::Sys.info())
[08:28:38.577]                   }
[08:28:38.577]                   ...future.conditions[[length(...future.conditions) + 
[08:28:38.577]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:38.577]                     cond$call), session = sessionInformation(), 
[08:28:38.577]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:38.577]                   signalCondition(cond)
[08:28:38.577]                 }
[08:28:38.577]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:38.577]                 "immediateCondition"))) {
[08:28:38.577]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:38.577]                   ...future.conditions[[length(...future.conditions) + 
[08:28:38.577]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:38.577]                   if (TRUE && !signal) {
[08:28:38.577]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:38.577]                     {
[08:28:38.577]                       inherits <- base::inherits
[08:28:38.577]                       invokeRestart <- base::invokeRestart
[08:28:38.577]                       is.null <- base::is.null
[08:28:38.577]                       muffled <- FALSE
[08:28:38.577]                       if (inherits(cond, "message")) {
[08:28:38.577]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:38.577]                         if (muffled) 
[08:28:38.577]                           invokeRestart("muffleMessage")
[08:28:38.577]                       }
[08:28:38.577]                       else if (inherits(cond, "warning")) {
[08:28:38.577]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:38.577]                         if (muffled) 
[08:28:38.577]                           invokeRestart("muffleWarning")
[08:28:38.577]                       }
[08:28:38.577]                       else if (inherits(cond, "condition")) {
[08:28:38.577]                         if (!is.null(pattern)) {
[08:28:38.577]                           computeRestarts <- base::computeRestarts
[08:28:38.577]                           grepl <- base::grepl
[08:28:38.577]                           restarts <- computeRestarts(cond)
[08:28:38.577]                           for (restart in restarts) {
[08:28:38.577]                             name <- restart$name
[08:28:38.577]                             if (is.null(name)) 
[08:28:38.577]                               next
[08:28:38.577]                             if (!grepl(pattern, name)) 
[08:28:38.577]                               next
[08:28:38.577]                             invokeRestart(restart)
[08:28:38.577]                             muffled <- TRUE
[08:28:38.577]                             break
[08:28:38.577]                           }
[08:28:38.577]                         }
[08:28:38.577]                       }
[08:28:38.577]                       invisible(muffled)
[08:28:38.577]                     }
[08:28:38.577]                     muffleCondition(cond, pattern = "^muffle")
[08:28:38.577]                   }
[08:28:38.577]                 }
[08:28:38.577]                 else {
[08:28:38.577]                   if (TRUE) {
[08:28:38.577]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:38.577]                     {
[08:28:38.577]                       inherits <- base::inherits
[08:28:38.577]                       invokeRestart <- base::invokeRestart
[08:28:38.577]                       is.null <- base::is.null
[08:28:38.577]                       muffled <- FALSE
[08:28:38.577]                       if (inherits(cond, "message")) {
[08:28:38.577]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:38.577]                         if (muffled) 
[08:28:38.577]                           invokeRestart("muffleMessage")
[08:28:38.577]                       }
[08:28:38.577]                       else if (inherits(cond, "warning")) {
[08:28:38.577]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:38.577]                         if (muffled) 
[08:28:38.577]                           invokeRestart("muffleWarning")
[08:28:38.577]                       }
[08:28:38.577]                       else if (inherits(cond, "condition")) {
[08:28:38.577]                         if (!is.null(pattern)) {
[08:28:38.577]                           computeRestarts <- base::computeRestarts
[08:28:38.577]                           grepl <- base::grepl
[08:28:38.577]                           restarts <- computeRestarts(cond)
[08:28:38.577]                           for (restart in restarts) {
[08:28:38.577]                             name <- restart$name
[08:28:38.577]                             if (is.null(name)) 
[08:28:38.577]                               next
[08:28:38.577]                             if (!grepl(pattern, name)) 
[08:28:38.577]                               next
[08:28:38.577]                             invokeRestart(restart)
[08:28:38.577]                             muffled <- TRUE
[08:28:38.577]                             break
[08:28:38.577]                           }
[08:28:38.577]                         }
[08:28:38.577]                       }
[08:28:38.577]                       invisible(muffled)
[08:28:38.577]                     }
[08:28:38.577]                     muffleCondition(cond, pattern = "^muffle")
[08:28:38.577]                   }
[08:28:38.577]                 }
[08:28:38.577]             }
[08:28:38.577]         }))
[08:28:38.577]     }, error = function(ex) {
[08:28:38.577]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:38.577]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:38.577]                 ...future.rng), started = ...future.startTime, 
[08:28:38.577]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:38.577]             version = "1.8"), class = "FutureResult")
[08:28:38.577]     }, finally = {
[08:28:38.577]         if (!identical(...future.workdir, getwd())) 
[08:28:38.577]             setwd(...future.workdir)
[08:28:38.577]         {
[08:28:38.577]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:38.577]                 ...future.oldOptions$nwarnings <- NULL
[08:28:38.577]             }
[08:28:38.577]             base::options(...future.oldOptions)
[08:28:38.577]             if (.Platform$OS.type == "windows") {
[08:28:38.577]                 old_names <- names(...future.oldEnvVars)
[08:28:38.577]                 envs <- base::Sys.getenv()
[08:28:38.577]                 names <- names(envs)
[08:28:38.577]                 common <- intersect(names, old_names)
[08:28:38.577]                 added <- setdiff(names, old_names)
[08:28:38.577]                 removed <- setdiff(old_names, names)
[08:28:38.577]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:38.577]                   envs[common]]
[08:28:38.577]                 NAMES <- toupper(changed)
[08:28:38.577]                 args <- list()
[08:28:38.577]                 for (kk in seq_along(NAMES)) {
[08:28:38.577]                   name <- changed[[kk]]
[08:28:38.577]                   NAME <- NAMES[[kk]]
[08:28:38.577]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:38.577]                     next
[08:28:38.577]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:38.577]                 }
[08:28:38.577]                 NAMES <- toupper(added)
[08:28:38.577]                 for (kk in seq_along(NAMES)) {
[08:28:38.577]                   name <- added[[kk]]
[08:28:38.577]                   NAME <- NAMES[[kk]]
[08:28:38.577]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:38.577]                     next
[08:28:38.577]                   args[[name]] <- ""
[08:28:38.577]                 }
[08:28:38.577]                 NAMES <- toupper(removed)
[08:28:38.577]                 for (kk in seq_along(NAMES)) {
[08:28:38.577]                   name <- removed[[kk]]
[08:28:38.577]                   NAME <- NAMES[[kk]]
[08:28:38.577]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:38.577]                     next
[08:28:38.577]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:38.577]                 }
[08:28:38.577]                 if (length(args) > 0) 
[08:28:38.577]                   base::do.call(base::Sys.setenv, args = args)
[08:28:38.577]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:38.577]             }
[08:28:38.577]             else {
[08:28:38.577]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:38.577]             }
[08:28:38.577]             {
[08:28:38.577]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:38.577]                   0L) {
[08:28:38.577]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:38.577]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:38.577]                   base::options(opts)
[08:28:38.577]                 }
[08:28:38.577]                 {
[08:28:38.577]                   {
[08:28:38.577]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:38.577]                     NULL
[08:28:38.577]                   }
[08:28:38.577]                   options(future.plan = NULL)
[08:28:38.577]                   if (is.na(NA_character_)) 
[08:28:38.577]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:38.577]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:38.577]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:38.577]                     .init = FALSE)
[08:28:38.577]                 }
[08:28:38.577]             }
[08:28:38.577]         }
[08:28:38.577]     })
[08:28:38.577]     if (TRUE) {
[08:28:38.577]         base::sink(type = "output", split = FALSE)
[08:28:38.577]         if (TRUE) {
[08:28:38.577]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:38.577]         }
[08:28:38.577]         else {
[08:28:38.577]             ...future.result["stdout"] <- base::list(NULL)
[08:28:38.577]         }
[08:28:38.577]         base::close(...future.stdout)
[08:28:38.577]         ...future.stdout <- NULL
[08:28:38.577]     }
[08:28:38.577]     ...future.result$conditions <- ...future.conditions
[08:28:38.577]     ...future.result$finished <- base::Sys.time()
[08:28:38.577]     ...future.result
[08:28:38.577] }
[08:28:38.607]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.579] assign_globals() ...
[08:28:38.608]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.579] List of 1
[08:28:38.579]  $ data:'data.frame':	3 obs. of  2 variables:
[08:28:38.579]   ..$ a: int [1:3] 1 2 3
[08:28:38.579]   ..$ b: int [1:3] 3 2 1
[08:28:38.579]  - attr(*, "where")=List of 1
[08:28:38.579]   ..$ data:<environment: R_EmptyEnv> 
[08:28:38.579]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:38.579]  - attr(*, "resolved")= logi FALSE
[08:28:38.579]  - attr(*, "total_size")= num 356
[08:28:38.579]  - attr(*, "already-done")= logi TRUE
[08:28:38.608]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.583] - copied ‘data’ to environment
[08:28:38.608]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.583] assign_globals() ... done
[08:28:38.608]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.583] requestCore(): workers = 2
[08:28:38.608]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.585] MulticoreFuture started
[08:28:38.608]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.586] - Launch lazy future ... done
[08:28:38.609]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.586] run() for ‘MulticoreFuture’ ... done
[08:28:38.609]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.587] result() for MulticoreFuture ...
[08:28:38.609]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.595] result() for MulticoreFuture ...
[08:28:38.609]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.595] result() for MulticoreFuture ... done
[08:28:38.609]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.595] result() for MulticoreFuture ... done
[08:28:38.609]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.596] result() for MulticoreFuture ...
[08:28:38.609]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.596] result() for MulticoreFuture ... done
[08:28:38.610] signalConditions() ... done
- plan(list('sequential', 'multicore')) ... DONE
- plan(list('sequential', 'multisession')) ...
[08:28:38.610] plan(): Setting new future strategy stack:
[08:28:38.610] List of future strategies:
[08:28:38.610] 1. sequential:
[08:28:38.610]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:38.610]    - tweaked: FALSE
[08:28:38.610]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:38.610] 2. multisession:
[08:28:38.610]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:28:38.610]    - tweaked: FALSE
[08:28:38.610]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:38.611] plan(): nbrOfWorkers() = 1
[08:28:38.611] getGlobalsAndPackages() ...
[08:28:38.611] Searching for globals...
[08:28:38.633] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[08:28:38.634] Searching for globals ... DONE
[08:28:38.634] Resolving globals: FALSE
[08:28:38.635] The total size of the 2 globals is 7.45 KiB (7631 bytes)
[08:28:38.635] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 7.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (7.40 KiB of class ‘list’) and ‘strategy2’ (51 bytes of class ‘character’)
[08:28:38.635] - globals: [2] ‘nested’, ‘strategy2’
[08:28:38.636] - packages: [1] ‘future’
[08:28:38.636] getGlobalsAndPackages() ... DONE
[08:28:38.636] run() for ‘Future’ ...
[08:28:38.636] - state: ‘created’
[08:28:38.636] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:38.636] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:38.637] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:38.637]   - Field: ‘label’
[08:28:38.637]   - Field: ‘local’
[08:28:38.637]   - Field: ‘owner’
[08:28:38.637]   - Field: ‘envir’
[08:28:38.637]   - Field: ‘packages’
[08:28:38.637]   - Field: ‘gc’
[08:28:38.637]   - Field: ‘conditions’
[08:28:38.637]   - Field: ‘expr’
[08:28:38.637]   - Field: ‘uuid’
[08:28:38.638]   - Field: ‘seed’
[08:28:38.638]   - Field: ‘version’
[08:28:38.638]   - Field: ‘result’
[08:28:38.638]   - Field: ‘asynchronous’
[08:28:38.638]   - Field: ‘calls’
[08:28:38.638]   - Field: ‘globals’
[08:28:38.638]   - Field: ‘stdout’
[08:28:38.638]   - Field: ‘earlySignal’
[08:28:38.638]   - Field: ‘lazy’
[08:28:38.638]   - Field: ‘state’
[08:28:38.638] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:38.638] - Launch lazy future ...
[08:28:38.639] Packages needed by the future expression (n = 1): ‘future’
[08:28:38.639] Packages needed by future strategies (n = 1): ‘future’
[08:28:38.639] {
[08:28:38.639]     {
[08:28:38.639]         {
[08:28:38.639]             ...future.startTime <- base::Sys.time()
[08:28:38.639]             {
[08:28:38.639]                 {
[08:28:38.639]                   {
[08:28:38.639]                     {
[08:28:38.639]                       base::local({
[08:28:38.639]                         has_future <- base::requireNamespace("future", 
[08:28:38.639]                           quietly = TRUE)
[08:28:38.639]                         if (has_future) {
[08:28:38.639]                           ns <- base::getNamespace("future")
[08:28:38.639]                           version <- ns[[".package"]][["version"]]
[08:28:38.639]                           if (is.null(version)) 
[08:28:38.639]                             version <- utils::packageVersion("future")
[08:28:38.639]                         }
[08:28:38.639]                         else {
[08:28:38.639]                           version <- NULL
[08:28:38.639]                         }
[08:28:38.639]                         if (!has_future || version < "1.8.0") {
[08:28:38.639]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:38.639]                             "", base::R.version$version.string), 
[08:28:38.639]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:38.639]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:38.639]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:38.639]                               "release", "version")], collapse = " "), 
[08:28:38.639]                             hostname = base::Sys.info()[["nodename"]])
[08:28:38.639]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:38.639]                             info)
[08:28:38.639]                           info <- base::paste(info, collapse = "; ")
[08:28:38.639]                           if (!has_future) {
[08:28:38.639]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:38.639]                               info)
[08:28:38.639]                           }
[08:28:38.639]                           else {
[08:28:38.639]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:38.639]                               info, version)
[08:28:38.639]                           }
[08:28:38.639]                           base::stop(msg)
[08:28:38.639]                         }
[08:28:38.639]                       })
[08:28:38.639]                     }
[08:28:38.639]                     base::local({
[08:28:38.639]                       for (pkg in "future") {
[08:28:38.639]                         base::loadNamespace(pkg)
[08:28:38.639]                         base::library(pkg, character.only = TRUE)
[08:28:38.639]                       }
[08:28:38.639]                     })
[08:28:38.639]                   }
[08:28:38.639]                   ...future.strategy.old <- future::plan("list")
[08:28:38.639]                   options(future.plan = NULL)
[08:28:38.639]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:38.639]                   future::plan(list(b = function (..., workers = availableCores(), 
[08:28:38.639]                     lazy = FALSE, rscript_libs = .libPaths(), 
[08:28:38.639]                     envir = parent.frame()) 
[08:28:38.639]                   {
[08:28:38.639]                     if (is.function(workers)) 
[08:28:38.639]                       workers <- workers()
[08:28:38.639]                     workers <- structure(as.integer(workers), 
[08:28:38.639]                       class = class(workers))
[08:28:38.639]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[08:28:38.639]                       workers >= 1)
[08:28:38.639]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[08:28:38.639]                       return(sequential(..., lazy = TRUE, envir = envir))
[08:28:38.639]                     }
[08:28:38.639]                     future <- MultisessionFuture(..., workers = workers, 
[08:28:38.639]                       lazy = lazy, rscript_libs = rscript_libs, 
[08:28:38.639]                       envir = envir)
[08:28:38.639]                     if (!future$lazy) 
[08:28:38.639]                       future <- run(future)
[08:28:38.639]                     invisible(future)
[08:28:38.639]                   }), .cleanup = FALSE, .init = FALSE)
[08:28:38.639]                 }
[08:28:38.639]                 ...future.workdir <- getwd()
[08:28:38.639]             }
[08:28:38.639]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:38.639]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:38.639]         }
[08:28:38.639]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:38.639]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:38.639]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:38.639]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:38.639]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:38.639]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:38.639]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:38.639]             base::names(...future.oldOptions))
[08:28:38.639]     }
[08:28:38.639]     if (FALSE) {
[08:28:38.639]     }
[08:28:38.639]     else {
[08:28:38.639]         if (TRUE) {
[08:28:38.639]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:38.639]                 open = "w")
[08:28:38.639]         }
[08:28:38.639]         else {
[08:28:38.639]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:38.639]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:38.639]         }
[08:28:38.639]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:38.639]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:38.639]             base::sink(type = "output", split = FALSE)
[08:28:38.639]             base::close(...future.stdout)
[08:28:38.639]         }, add = TRUE)
[08:28:38.639]     }
[08:28:38.639]     ...future.frame <- base::sys.nframe()
[08:28:38.639]     ...future.conditions <- base::list()
[08:28:38.639]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:38.639]     if (FALSE) {
[08:28:38.639]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:38.639]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:38.639]     }
[08:28:38.639]     ...future.result <- base::tryCatch({
[08:28:38.639]         base::withCallingHandlers({
[08:28:38.639]             ...future.value <- base::withVisible(base::local({
[08:28:38.639]                 a <- 1L
[08:28:38.639]                 plan_a <- unclass(future::plan("list"))
[08:28:38.639]                 nested_a <- nested[-1]
[08:28:38.639]                 stopifnot(length(nested_a) == 1L, length(plan_a) == 
[08:28:38.639]                   1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[08:28:38.639]                   strategy2))
[08:28:38.639]                 for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[08:28:38.639]                   "init") <- NULL
[08:28:38.639]                 for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[08:28:38.639]                   "init") <- NULL
[08:28:38.639]                 stopifnot(all.equal(plan_a, nested_a))
[08:28:38.639]                 y %<-% {
[08:28:38.639]                   b <- 2L
[08:28:38.639]                   plan_b <- future::plan("list")
[08:28:38.639]                   nested_b <- nested_a[-1]
[08:28:38.639]                   stopifnot(length(nested_b) == 0L, length(plan_b) == 
[08:28:38.639]                     1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[08:28:38.639]                     "sequential"))
[08:28:38.639]                   list(a = a, nested_a = nested_a, plan_a = plan_a, 
[08:28:38.639]                     b = b, nested_b = nested_b, plan_b = plan_b)
[08:28:38.639]                 }
[08:28:38.639]                 y
[08:28:38.639]             }))
[08:28:38.639]             future::FutureResult(value = ...future.value$value, 
[08:28:38.639]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:38.639]                   ...future.rng), globalenv = if (FALSE) 
[08:28:38.639]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:38.639]                     ...future.globalenv.names))
[08:28:38.639]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:38.639]         }, condition = base::local({
[08:28:38.639]             c <- base::c
[08:28:38.639]             inherits <- base::inherits
[08:28:38.639]             invokeRestart <- base::invokeRestart
[08:28:38.639]             length <- base::length
[08:28:38.639]             list <- base::list
[08:28:38.639]             seq.int <- base::seq.int
[08:28:38.639]             signalCondition <- base::signalCondition
[08:28:38.639]             sys.calls <- base::sys.calls
[08:28:38.639]             `[[` <- base::`[[`
[08:28:38.639]             `+` <- base::`+`
[08:28:38.639]             `<<-` <- base::`<<-`
[08:28:38.639]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:38.639]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:38.639]                   3L)]
[08:28:38.639]             }
[08:28:38.639]             function(cond) {
[08:28:38.639]                 is_error <- inherits(cond, "error")
[08:28:38.639]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:38.639]                   NULL)
[08:28:38.639]                 if (is_error) {
[08:28:38.639]                   sessionInformation <- function() {
[08:28:38.639]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:38.639]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:38.639]                       search = base::search(), system = base::Sys.info())
[08:28:38.639]                   }
[08:28:38.639]                   ...future.conditions[[length(...future.conditions) + 
[08:28:38.639]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:38.639]                     cond$call), session = sessionInformation(), 
[08:28:38.639]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:38.639]                   signalCondition(cond)
[08:28:38.639]                 }
[08:28:38.639]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:38.639]                 "immediateCondition"))) {
[08:28:38.639]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:38.639]                   ...future.conditions[[length(...future.conditions) + 
[08:28:38.639]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:38.639]                   if (TRUE && !signal) {
[08:28:38.639]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:38.639]                     {
[08:28:38.639]                       inherits <- base::inherits
[08:28:38.639]                       invokeRestart <- base::invokeRestart
[08:28:38.639]                       is.null <- base::is.null
[08:28:38.639]                       muffled <- FALSE
[08:28:38.639]                       if (inherits(cond, "message")) {
[08:28:38.639]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:38.639]                         if (muffled) 
[08:28:38.639]                           invokeRestart("muffleMessage")
[08:28:38.639]                       }
[08:28:38.639]                       else if (inherits(cond, "warning")) {
[08:28:38.639]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:38.639]                         if (muffled) 
[08:28:38.639]                           invokeRestart("muffleWarning")
[08:28:38.639]                       }
[08:28:38.639]                       else if (inherits(cond, "condition")) {
[08:28:38.639]                         if (!is.null(pattern)) {
[08:28:38.639]                           computeRestarts <- base::computeRestarts
[08:28:38.639]                           grepl <- base::grepl
[08:28:38.639]                           restarts <- computeRestarts(cond)
[08:28:38.639]                           for (restart in restarts) {
[08:28:38.639]                             name <- restart$name
[08:28:38.639]                             if (is.null(name)) 
[08:28:38.639]                               next
[08:28:38.639]                             if (!grepl(pattern, name)) 
[08:28:38.639]                               next
[08:28:38.639]                             invokeRestart(restart)
[08:28:38.639]                             muffled <- TRUE
[08:28:38.639]                             break
[08:28:38.639]                           }
[08:28:38.639]                         }
[08:28:38.639]                       }
[08:28:38.639]                       invisible(muffled)
[08:28:38.639]                     }
[08:28:38.639]                     muffleCondition(cond, pattern = "^muffle")
[08:28:38.639]                   }
[08:28:38.639]                 }
[08:28:38.639]                 else {
[08:28:38.639]                   if (TRUE) {
[08:28:38.639]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:38.639]                     {
[08:28:38.639]                       inherits <- base::inherits
[08:28:38.639]                       invokeRestart <- base::invokeRestart
[08:28:38.639]                       is.null <- base::is.null
[08:28:38.639]                       muffled <- FALSE
[08:28:38.639]                       if (inherits(cond, "message")) {
[08:28:38.639]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:38.639]                         if (muffled) 
[08:28:38.639]                           invokeRestart("muffleMessage")
[08:28:38.639]                       }
[08:28:38.639]                       else if (inherits(cond, "warning")) {
[08:28:38.639]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:38.639]                         if (muffled) 
[08:28:38.639]                           invokeRestart("muffleWarning")
[08:28:38.639]                       }
[08:28:38.639]                       else if (inherits(cond, "condition")) {
[08:28:38.639]                         if (!is.null(pattern)) {
[08:28:38.639]                           computeRestarts <- base::computeRestarts
[08:28:38.639]                           grepl <- base::grepl
[08:28:38.639]                           restarts <- computeRestarts(cond)
[08:28:38.639]                           for (restart in restarts) {
[08:28:38.639]                             name <- restart$name
[08:28:38.639]                             if (is.null(name)) 
[08:28:38.639]                               next
[08:28:38.639]                             if (!grepl(pattern, name)) 
[08:28:38.639]                               next
[08:28:38.639]                             invokeRestart(restart)
[08:28:38.639]                             muffled <- TRUE
[08:28:38.639]                             break
[08:28:38.639]                           }
[08:28:38.639]                         }
[08:28:38.639]                       }
[08:28:38.639]                       invisible(muffled)
[08:28:38.639]                     }
[08:28:38.639]                     muffleCondition(cond, pattern = "^muffle")
[08:28:38.639]                   }
[08:28:38.639]                 }
[08:28:38.639]             }
[08:28:38.639]         }))
[08:28:38.639]     }, error = function(ex) {
[08:28:38.639]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:38.639]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:38.639]                 ...future.rng), started = ...future.startTime, 
[08:28:38.639]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:38.639]             version = "1.8"), class = "FutureResult")
[08:28:38.639]     }, finally = {
[08:28:38.639]         if (!identical(...future.workdir, getwd())) 
[08:28:38.639]             setwd(...future.workdir)
[08:28:38.639]         {
[08:28:38.639]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:38.639]                 ...future.oldOptions$nwarnings <- NULL
[08:28:38.639]             }
[08:28:38.639]             base::options(...future.oldOptions)
[08:28:38.639]             if (.Platform$OS.type == "windows") {
[08:28:38.639]                 old_names <- names(...future.oldEnvVars)
[08:28:38.639]                 envs <- base::Sys.getenv()
[08:28:38.639]                 names <- names(envs)
[08:28:38.639]                 common <- intersect(names, old_names)
[08:28:38.639]                 added <- setdiff(names, old_names)
[08:28:38.639]                 removed <- setdiff(old_names, names)
[08:28:38.639]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:38.639]                   envs[common]]
[08:28:38.639]                 NAMES <- toupper(changed)
[08:28:38.639]                 args <- list()
[08:28:38.639]                 for (kk in seq_along(NAMES)) {
[08:28:38.639]                   name <- changed[[kk]]
[08:28:38.639]                   NAME <- NAMES[[kk]]
[08:28:38.639]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:38.639]                     next
[08:28:38.639]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:38.639]                 }
[08:28:38.639]                 NAMES <- toupper(added)
[08:28:38.639]                 for (kk in seq_along(NAMES)) {
[08:28:38.639]                   name <- added[[kk]]
[08:28:38.639]                   NAME <- NAMES[[kk]]
[08:28:38.639]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:38.639]                     next
[08:28:38.639]                   args[[name]] <- ""
[08:28:38.639]                 }
[08:28:38.639]                 NAMES <- toupper(removed)
[08:28:38.639]                 for (kk in seq_along(NAMES)) {
[08:28:38.639]                   name <- removed[[kk]]
[08:28:38.639]                   NAME <- NAMES[[kk]]
[08:28:38.639]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:38.639]                     next
[08:28:38.639]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:38.639]                 }
[08:28:38.639]                 if (length(args) > 0) 
[08:28:38.639]                   base::do.call(base::Sys.setenv, args = args)
[08:28:38.639]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:38.639]             }
[08:28:38.639]             else {
[08:28:38.639]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:38.639]             }
[08:28:38.639]             {
[08:28:38.639]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:38.639]                   0L) {
[08:28:38.639]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:38.639]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:38.639]                   base::options(opts)
[08:28:38.639]                 }
[08:28:38.639]                 {
[08:28:38.639]                   {
[08:28:38.639]                     NULL
[08:28:38.639]                     RNGkind("Mersenne-Twister")
[08:28:38.639]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:38.639]                       inherits = FALSE)
[08:28:38.639]                   }
[08:28:38.639]                   options(future.plan = NULL)
[08:28:38.639]                   if (is.na(NA_character_)) 
[08:28:38.639]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:38.639]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:38.639]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:38.639]                     .init = FALSE)
[08:28:38.639]                 }
[08:28:38.639]             }
[08:28:38.639]         }
[08:28:38.639]     })
[08:28:38.639]     if (TRUE) {
[08:28:38.639]         base::sink(type = "output", split = FALSE)
[08:28:38.639]         if (TRUE) {
[08:28:38.639]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:38.639]         }
[08:28:38.639]         else {
[08:28:38.639]             ...future.result["stdout"] <- base::list(NULL)
[08:28:38.639]         }
[08:28:38.639]         base::close(...future.stdout)
[08:28:38.639]         ...future.stdout <- NULL
[08:28:38.639]     }
[08:28:38.639]     ...future.result$conditions <- ...future.conditions
[08:28:38.639]     ...future.result$finished <- base::Sys.time()
[08:28:38.639]     ...future.result
[08:28:38.639] }
[08:28:38.642] assign_globals() ...
[08:28:38.642] List of 2
[08:28:38.642]  $ nested   :List of 2
[08:28:38.642]   ..$ a:function (..., envir = parent.frame())  
[08:28:38.642]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[08:28:38.642]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[08:28:38.642]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[08:28:38.642]     envir = parent.frame())  
[08:28:38.642]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[08:28:38.642]   .. ..- attr(*, "init")= logi TRUE
[08:28:38.642]   .. ..- attr(*, "cleanup")=function ()  
[08:28:38.642]   .. ..- attr(*, "untweakable")= chr "persistent"
[08:28:38.642]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[08:28:38.642]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[08:28:38.642]  $ strategy2: chr "multisession"
[08:28:38.642]  - attr(*, "where")=List of 2
[08:28:38.642]   ..$ nested   :<environment: R_EmptyEnv> 
[08:28:38.642]   ..$ strategy2:<environment: R_EmptyEnv> 
[08:28:38.642]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:38.642]  - attr(*, "resolved")= logi FALSE
[08:28:38.642]  - attr(*, "total_size")= num 7631
[08:28:38.642]  - attr(*, "already-done")= logi TRUE
[08:28:38.647] - copied ‘nested’ to environment
[08:28:38.647] - copied ‘strategy2’ to environment
[08:28:38.647] assign_globals() ... done
[08:28:38.648] plan(): Setting new future strategy stack:
[08:28:38.648] List of future strategies:
[08:28:38.648] 1. multisession:
[08:28:38.648]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:28:38.648]    - tweaked: FALSE
[08:28:38.648]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:38.650] plan(): nbrOfWorkers() = 2
[08:28:39.349] plan(): Setting new future strategy stack:
[08:28:39.349] List of future strategies:
[08:28:39.349] 1. sequential:
[08:28:39.349]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:39.349]    - tweaked: FALSE
[08:28:39.349]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:39.349] 2. multisession:
[08:28:39.349]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:28:39.349]    - tweaked: FALSE
[08:28:39.349]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:39.349] plan(): nbrOfWorkers() = 1
[08:28:39.350] SequentialFuture started (and completed)
[08:28:39.350] signalConditions() ...
[08:28:39.350]  - include = ‘immediateCondition’
[08:28:39.350]  - exclude = 
[08:28:39.350]  - resignal = FALSE
[08:28:39.350]  - Number of conditions: 67
[08:28:39.350] signalConditions() ... done
[08:28:39.350] - Launch lazy future ... done
[08:28:39.350] run() for ‘SequentialFuture’ ... done
[08:28:39.351] signalConditions() ...
[08:28:39.351]  - include = ‘immediateCondition’
[08:28:39.351]  - exclude = 
[08:28:39.351]  - resignal = FALSE
[08:28:39.351]  - Number of conditions: 67
[08:28:39.351] signalConditions() ... done
[08:28:39.351] Future state: ‘finished’
[08:28:39.351] signalConditions() ...
[08:28:39.351]  - include = ‘condition’
[08:28:39.351]  - exclude = ‘immediateCondition’
[08:28:39.351]  - resignal = TRUE
[08:28:39.352]  - Number of conditions: 67
[08:28:39.352]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.651] getGlobalsAndPackages() ...
[08:28:39.352]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.651] Searching for globals...
[08:28:39.352]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.670] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[08:28:39.352]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.671] Searching for globals ... DONE
[08:28:39.352]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.671] Resolving globals: FALSE
[08:28:39.352]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.672] The total size of the 3 globals is 11.81 KiB (12089 bytes)
[08:28:39.352]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.672] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 11.81 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (5.89 KiB of class ‘list’), ‘plan_a’ (5.89 KiB of class ‘list’) and ‘a’ (35 bytes of class ‘numeric’)
[08:28:39.352]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.672] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[08:28:39.353]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.672] 
[08:28:39.353]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.672] getGlobalsAndPackages() ... DONE
[08:28:39.353]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.673] run() for ‘Future’ ...
[08:28:39.353]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.673] - state: ‘created’
[08:28:39.353]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:38.673] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:39.353]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.173] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:39.353]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.173] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:39.353]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.173]   - Field: ‘node’
[08:28:39.354]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.174]   - Field: ‘label’
[08:28:39.354]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.174]   - Field: ‘local’
[08:28:39.354]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.174]   - Field: ‘owner’
[08:28:39.354]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.174]   - Field: ‘envir’
[08:28:39.354]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.174]   - Field: ‘workers’
[08:28:39.354]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.174]   - Field: ‘packages’
[08:28:39.354]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.174]   - Field: ‘gc’
[08:28:39.354]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.174]   - Field: ‘conditions’
[08:28:39.355]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.174]   - Field: ‘persistent’
[08:28:39.355]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.175]   - Field: ‘expr’
[08:28:39.355]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.175]   - Field: ‘uuid’
[08:28:39.355]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.175]   - Field: ‘seed’
[08:28:39.355]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.175]   - Field: ‘version’
[08:28:39.355]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.175]   - Field: ‘result’
[08:28:39.355]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.175]   - Field: ‘asynchronous’
[08:28:39.355]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.175]   - Field: ‘calls’
[08:28:39.355]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.175]   - Field: ‘globals’
[08:28:39.356]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.175]   - Field: ‘stdout’
[08:28:39.356]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.176]   - Field: ‘earlySignal’
[08:28:39.356]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.176]   - Field: ‘lazy’
[08:28:39.356]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.176]   - Field: ‘state’
[08:28:39.356]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.176] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:39.356]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.176] - Launch lazy future ...
[08:28:39.356]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.177] Packages needed by the future expression (n = 0): <none>
[08:28:39.356]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.177] Packages needed by future strategies (n = 0): <none>
[08:28:39.357]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.177] {
[08:28:39.177]     {
[08:28:39.177]         {
[08:28:39.177]             ...future.startTime <- base::Sys.time()
[08:28:39.177]             {
[08:28:39.177]                 {
[08:28:39.177]                   {
[08:28:39.177]                     {
[08:28:39.177]                       base::local({
[08:28:39.177]                         has_future <- base::requireNamespace("future", 
[08:28:39.177]                           quietly = TRUE)
[08:28:39.177]                         if (has_future) {
[08:28:39.177]                           ns <- base::getNamespace("future")
[08:28:39.177]                           version <- ns[[".package"]][["version"]]
[08:28:39.177]                           if (is.null(version)) 
[08:28:39.177]                             version <- utils::packageVersion("future")
[08:28:39.177]                         }
[08:28:39.177]                         else {
[08:28:39.177]                           version <- NULL
[08:28:39.177]                         }
[08:28:39.177]                         if (!has_future || version < "1.8.0") {
[08:28:39.177]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:39.177]                             "", base::R.version$version.string), 
[08:28:39.177]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:39.177]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:39.177]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:39.177]                               "release", "version")], collapse = " "), 
[08:28:39.177]                             hostname = base::Sys.info()[["nodename"]])
[08:28:39.177]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:39.177]                             info)
[08:28:39.177]                           info <- base::paste(info, collapse = "; ")
[08:28:39.177]                           if (!has_future) {
[08:28:39.177]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:39.177]                               info)
[08:28:39.177]                           }
[08:28:39.177]                           else {
[08:28:39.177]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:39.177]                               info, version)
[08:28:39.177]                           }
[08:28:39.177]                           base::stop(msg)
[08:28:39.177]                         }
[08:28:39.177]                       })
[08:28:39.177]                     }
[08:28:39.177]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:39.177]                     base::options(mc.cores = 1L)
[08:28:39.177]                   }
[08:28:39.177]                   ...future.strategy.old <- future::plan("list")
[08:28:39.177]                   options(future.plan = NULL)
[08:28:39.177]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:39.177]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:39.177]                 }
[08:28:39.177]                 ...future.workdir <- getwd()
[08:28:39.177]             }
[08:28:39.177]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:39.177]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:39.177]         }
[08:28:39.177]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:39.177]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:39.177]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:39.177]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:39.177]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:39.177]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:39.177]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:39.177]             base::names(...future.oldOptions))
[08:28:39.177]     }
[08:28:39.177]     if (FALSE) {
[08:28:39.177]     }
[08:28:39.177]     else {
[08:28:39.177]         if (TRUE) {
[08:28:39.177]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:39.177]                 open = "w")
[08:28:39.177]         }
[08:28:39.177]         else {
[08:28:39.177]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:39.177]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:39.177]         }
[08:28:39.177]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:39.177]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:39.177]             base::sink(type = "output", split = FALSE)
[08:28:39.177]             base::close(...future.stdout)
[08:28:39.177]         }, add = TRUE)
[08:28:39.177]     }
[08:28:39.177]     ...future.frame <- base::sys.nframe()
[08:28:39.177]     ...future.conditions <- base::list()
[08:28:39.177]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:39.177]     if (FALSE) {
[08:28:39.177]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:39.177]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:39.177]     }
[08:28:39.177]     ...future.result <- base::tryCatch({
[08:28:39.177]         base::withCallingHandlers({
[08:28:39.177]             ...future.value <- base::withVisible(base::local({
[08:28:39.177]                 ...future.makeSendCondition <- base::local({
[08:28:39.177]                   sendCondition <- NULL
[08:28:39.177]                   function(frame = 1L) {
[08:28:39.177]                     if (is.function(sendCondition)) 
[08:28:39.177]                       return(sendCondition)
[08:28:39.177]                     ns <- getNamespace("parallel")
[08:28:39.177]                     if (exists("sendData", mode = "function", 
[08:28:39.177]                       envir = ns)) {
[08:28:39.177]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:39.177]                         envir = ns)
[08:28:39.177]                       envir <- sys.frame(frame)
[08:28:39.177]                       master <- NULL
[08:28:39.177]                       while (!identical(envir, .GlobalEnv) && 
[08:28:39.177]                         !identical(envir, emptyenv())) {
[08:28:39.177]                         if (exists("master", mode = "list", envir = envir, 
[08:28:39.177]                           inherits = FALSE)) {
[08:28:39.177]                           master <- get("master", mode = "list", 
[08:28:39.177]                             envir = envir, inherits = FALSE)
[08:28:39.177]                           if (inherits(master, c("SOCKnode", 
[08:28:39.177]                             "SOCK0node"))) {
[08:28:39.177]                             sendCondition <<- function(cond) {
[08:28:39.177]                               data <- list(type = "VALUE", value = cond, 
[08:28:39.177]                                 success = TRUE)
[08:28:39.177]                               parallel_sendData(master, data)
[08:28:39.177]                             }
[08:28:39.177]                             return(sendCondition)
[08:28:39.177]                           }
[08:28:39.177]                         }
[08:28:39.177]                         frame <- frame + 1L
[08:28:39.177]                         envir <- sys.frame(frame)
[08:28:39.177]                       }
[08:28:39.177]                     }
[08:28:39.177]                     sendCondition <<- function(cond) NULL
[08:28:39.177]                   }
[08:28:39.177]                 })
[08:28:39.177]                 withCallingHandlers({
[08:28:39.177]                   {
[08:28:39.177]                     b <- 2L
[08:28:39.177]                     plan_b <- future::plan("list")
[08:28:39.177]                     nested_b <- nested_a[-1]
[08:28:39.177]                     stopifnot(length(nested_b) == 0L, length(plan_b) == 
[08:28:39.177]                       1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[08:28:39.177]                       "sequential"))
[08:28:39.177]                     list(a = a, nested_a = nested_a, plan_a = plan_a, 
[08:28:39.177]                       b = b, nested_b = nested_b, plan_b = plan_b)
[08:28:39.177]                   }
[08:28:39.177]                 }, immediateCondition = function(cond) {
[08:28:39.177]                   sendCondition <- ...future.makeSendCondition()
[08:28:39.177]                   sendCondition(cond)
[08:28:39.177]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:39.177]                   {
[08:28:39.177]                     inherits <- base::inherits
[08:28:39.177]                     invokeRestart <- base::invokeRestart
[08:28:39.177]                     is.null <- base::is.null
[08:28:39.177]                     muffled <- FALSE
[08:28:39.177]                     if (inherits(cond, "message")) {
[08:28:39.177]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:39.177]                       if (muffled) 
[08:28:39.177]                         invokeRestart("muffleMessage")
[08:28:39.177]                     }
[08:28:39.177]                     else if (inherits(cond, "warning")) {
[08:28:39.177]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:39.177]                       if (muffled) 
[08:28:39.177]                         invokeRestart("muffleWarning")
[08:28:39.177]                     }
[08:28:39.177]                     else if (inherits(cond, "condition")) {
[08:28:39.177]                       if (!is.null(pattern)) {
[08:28:39.177]                         computeRestarts <- base::computeRestarts
[08:28:39.177]                         grepl <- base::grepl
[08:28:39.177]                         restarts <- computeRestarts(cond)
[08:28:39.177]                         for (restart in restarts) {
[08:28:39.177]                           name <- restart$name
[08:28:39.177]                           if (is.null(name)) 
[08:28:39.177]                             next
[08:28:39.177]                           if (!grepl(pattern, name)) 
[08:28:39.177]                             next
[08:28:39.177]                           invokeRestart(restart)
[08:28:39.177]                           muffled <- TRUE
[08:28:39.177]                           break
[08:28:39.177]                         }
[08:28:39.177]                       }
[08:28:39.177]                     }
[08:28:39.177]                     invisible(muffled)
[08:28:39.177]                   }
[08:28:39.177]                   muffleCondition(cond)
[08:28:39.177]                 })
[08:28:39.177]             }))
[08:28:39.177]             future::FutureResult(value = ...future.value$value, 
[08:28:39.177]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:39.177]                   ...future.rng), globalenv = if (FALSE) 
[08:28:39.177]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:39.177]                     ...future.globalenv.names))
[08:28:39.177]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:39.177]         }, condition = base::local({
[08:28:39.177]             c <- base::c
[08:28:39.177]             inherits <- base::inherits
[08:28:39.177]             invokeRestart <- base::invokeRestart
[08:28:39.177]             length <- base::length
[08:28:39.177]             list <- base::list
[08:28:39.177]             seq.int <- base::seq.int
[08:28:39.177]             signalCondition <- base::signalCondition
[08:28:39.177]             sys.calls <- base::sys.calls
[08:28:39.177]             `[[` <- base::`[[`
[08:28:39.177]             `+` <- base::`+`
[08:28:39.177]             `<<-` <- base::`<<-`
[08:28:39.177]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:39.177]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:39.177]                   3L)]
[08:28:39.177]             }
[08:28:39.177]             function(cond) {
[08:28:39.177]                 is_error <- inherits(cond, "error")
[08:28:39.177]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:39.177]                   NULL)
[08:28:39.177]                 if (is_error) {
[08:28:39.177]                   sessionInformation <- function() {
[08:28:39.177]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:39.177]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:39.177]                       search = base::search(), system = base::Sys.info())
[08:28:39.177]                   }
[08:28:39.177]                   ...future.conditions[[length(...future.conditions) + 
[08:28:39.177]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:39.177]                     cond$call), session = sessionInformation(), 
[08:28:39.177]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:39.177]                   signalCondition(cond)
[08:28:39.177]                 }
[08:28:39.177]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:39.177]                 "immediateCondition"))) {
[08:28:39.177]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:39.177]                   ...future.conditions[[length(...future.conditions) + 
[08:28:39.177]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:39.177]                   if (TRUE && !signal) {
[08:28:39.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:39.177]                     {
[08:28:39.177]                       inherits <- base::inherits
[08:28:39.177]                       invokeRestart <- base::invokeRestart
[08:28:39.177]                       is.null <- base::is.null
[08:28:39.177]                       muffled <- FALSE
[08:28:39.177]                       if (inherits(cond, "message")) {
[08:28:39.177]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:39.177]                         if (muffled) 
[08:28:39.177]                           invokeRestart("muffleMessage")
[08:28:39.177]                       }
[08:28:39.177]                       else if (inherits(cond, "warning")) {
[08:28:39.177]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:39.177]                         if (muffled) 
[08:28:39.177]                           invokeRestart("muffleWarning")
[08:28:39.177]                       }
[08:28:39.177]                       else if (inherits(cond, "condition")) {
[08:28:39.177]                         if (!is.null(pattern)) {
[08:28:39.177]                           computeRestarts <- base::computeRestarts
[08:28:39.177]                           grepl <- base::grepl
[08:28:39.177]                           restarts <- computeRestarts(cond)
[08:28:39.177]                           for (restart in restarts) {
[08:28:39.177]                             name <- restart$name
[08:28:39.177]                             if (is.null(name)) 
[08:28:39.177]                               next
[08:28:39.177]                             if (!grepl(pattern, name)) 
[08:28:39.177]                               next
[08:28:39.177]                             invokeRestart(restart)
[08:28:39.177]                             muffled <- TRUE
[08:28:39.177]                             break
[08:28:39.177]                           }
[08:28:39.177]                         }
[08:28:39.177]                       }
[08:28:39.177]                       invisible(muffled)
[08:28:39.177]                     }
[08:28:39.177]                     muffleCondition(cond, pattern = "^muffle")
[08:28:39.177]                   }
[08:28:39.177]                 }
[08:28:39.177]                 else {
[08:28:39.177]                   if (TRUE) {
[08:28:39.177]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:39.177]                     {
[08:28:39.177]                       inherits <- base::inherits
[08:28:39.177]                       invokeRestart <- base::invokeRestart
[08:28:39.177]                       is.null <- base::is.null
[08:28:39.177]                       muffled <- FALSE
[08:28:39.177]                       if (inherits(cond, "message")) {
[08:28:39.177]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:39.177]                         if (muffled) 
[08:28:39.177]                           invokeRestart("muffleMessage")
[08:28:39.177]                       }
[08:28:39.177]                       else if (inherits(cond, "warning")) {
[08:28:39.177]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:39.177]                         if (muffled) 
[08:28:39.177]                           invokeRestart("muffleWarning")
[08:28:39.177]                       }
[08:28:39.177]                       else if (inherits(cond, "condition")) {
[08:28:39.177]                         if (!is.null(pattern)) {
[08:28:39.177]                           computeRestarts <- base::computeRestarts
[08:28:39.177]                           grepl <- base::grepl
[08:28:39.177]                           restarts <- computeRestarts(cond)
[08:28:39.177]                           for (restart in restarts) {
[08:28:39.177]                             name <- restart$name
[08:28:39.177]                             if (is.null(name)) 
[08:28:39.177]                               next
[08:28:39.177]                             if (!grepl(pattern, name)) 
[08:28:39.177]                               next
[08:28:39.177]                             invokeRestart(restart)
[08:28:39.177]                             muffled <- TRUE
[08:28:39.177]                             break
[08:28:39.177]                           }
[08:28:39.177]                         }
[08:28:39.177]                       }
[08:28:39.177]                       invisible(muffled)
[08:28:39.177]                     }
[08:28:39.177]                     muffleCondition(cond, pattern = "^muffle")
[08:28:39.177]                   }
[08:28:39.177]                 }
[08:28:39.177]             }
[08:28:39.177]         }))
[08:28:39.177]     }, error = function(ex) {
[08:28:39.177]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:39.177]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:39.177]                 ...future.rng), started = ...future.startTime, 
[08:28:39.177]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:39.177]             version = "1.8"), class = "FutureResult")
[08:28:39.177]     }, finally = {
[08:28:39.177]         if (!identical(...future.workdir, getwd())) 
[08:28:39.177]             setwd(...future.workdir)
[08:28:39.177]         {
[08:28:39.177]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:39.177]                 ...future.oldOptions$nwarnings <- NULL
[08:28:39.177]             }
[08:28:39.177]             base::options(...future.oldOptions)
[08:28:39.177]             if (.Platform$OS.type == "windows") {
[08:28:39.177]                 old_names <- names(...future.oldEnvVars)
[08:28:39.177]                 envs <- base::Sys.getenv()
[08:28:39.177]                 names <- names(envs)
[08:28:39.177]                 common <- intersect(names, old_names)
[08:28:39.177]                 added <- setdiff(names, old_names)
[08:28:39.177]                 removed <- setdiff(old_names, names)
[08:28:39.177]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:39.177]                   envs[common]]
[08:28:39.177]                 NAMES <- toupper(changed)
[08:28:39.177]                 args <- list()
[08:28:39.177]                 for (kk in seq_along(NAMES)) {
[08:28:39.177]                   name <- changed[[kk]]
[08:28:39.177]                   NAME <- NAMES[[kk]]
[08:28:39.177]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.177]                     next
[08:28:39.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:39.177]                 }
[08:28:39.177]                 NAMES <- toupper(added)
[08:28:39.177]                 for (kk in seq_along(NAMES)) {
[08:28:39.177]                   name <- added[[kk]]
[08:28:39.177]                   NAME <- NAMES[[kk]]
[08:28:39.177]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.177]                     next
[08:28:39.177]                   args[[name]] <- ""
[08:28:39.177]                 }
[08:28:39.177]                 NAMES <- toupper(removed)
[08:28:39.177]                 for (kk in seq_along(NAMES)) {
[08:28:39.177]                   name <- removed[[kk]]
[08:28:39.177]                   NAME <- NAMES[[kk]]
[08:28:39.177]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.177]                     next
[08:28:39.177]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:39.177]                 }
[08:28:39.177]                 if (length(args) > 0) 
[08:28:39.177]                   base::do.call(base::Sys.setenv, args = args)
[08:28:39.177]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:39.177]             }
[08:28:39.177]             else {
[08:28:39.177]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:39.177]             }
[08:28:39.177]             {
[08:28:39.177]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:39.177]                   0L) {
[08:28:39.177]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:39.177]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:39.177]                   base::options(opts)
[08:28:39.177]                 }
[08:28:39.177]                 {
[08:28:39.177]                   {
[08:28:39.177]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:39.177]                     NULL
[08:28:39.177]                   }
[08:28:39.177]                   options(future.plan = NULL)
[08:28:39.177]                   if (is.na(NA_character_)) 
[08:28:39.177]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:39.177]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:39.177]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:39.177]                     .init = FALSE)
[08:28:39.177]                 }
[08:28:39.177]             }
[08:28:39.177]         }
[08:28:39.177]     })
[08:28:39.177]     if (TRUE) {
[08:28:39.177]         base::sink(type = "output", split = FALSE)
[08:28:39.177]         if (TRUE) {
[08:28:39.177]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:39.177]         }
[08:28:39.177]         else {
[08:28:39.177]             ...future.result["stdout"] <- base::list(NULL)
[08:28:39.177]         }
[08:28:39.177]         base::close(...future.stdout)
[08:28:39.177]         ...future.stdout <- NULL
[08:28:39.177]     }
[08:28:39.177]     ...future.result$conditions <- ...future.conditions
[08:28:39.177]     ...future.result$finished <- base::Sys.time()
[08:28:39.177]     ...future.result
[08:28:39.177] }
[08:28:39.357]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.230] Exporting 3 global objects (11.47 KiB) to cluster node #1 ...
[08:28:39.357]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.230] Exporting ‘nested_a’ (5.89 KiB) to cluster node #1 ...
[08:28:39.357]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.231] Exporting ‘nested_a’ (5.89 KiB) to cluster node #1 ... DONE
[08:28:39.357]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.231] Exporting ‘a’ (35 bytes) to cluster node #1 ...
[08:28:39.357]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.231] Exporting ‘a’ (35 bytes) to cluster node #1 ... DONE
[08:28:39.358]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.231] Exporting ‘plan_a’ (5.89 KiB) to cluster node #1 ...
[08:28:39.358]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.272] Exporting ‘plan_a’ (5.89 KiB) to cluster node #1 ... DONE
[08:28:39.358]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.273] Exporting 3 global objects (11.47 KiB) to cluster node #1 ... DONE
[08:28:39.358]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.273] MultisessionFuture started
[08:28:39.358]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.274] - Launch lazy future ... done
[08:28:39.358]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.274] run() for ‘MultisessionFuture’ ... done
[08:28:39.358]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.274] result() for ClusterFuture ...
[08:28:39.358]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.274] receiveMessageFromWorker() for ClusterFuture ...
[08:28:39.359]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.274] - Validating connection of MultisessionFuture
[08:28:39.359]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.347] - received message: FutureResult
[08:28:39.359]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.347] - Received FutureResult
[08:28:39.359]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.347] - Erased future from FutureRegistry
[08:28:39.359]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.347] result() for ClusterFuture ...
[08:28:39.359]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.347] - result already collected: FutureResult
[08:28:39.359]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.348] result() for ClusterFuture ... done
[08:28:39.359]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.348] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:39.360]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.348] result() for ClusterFuture ... done
[08:28:39.360]  - Condition #65: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.348] result() for ClusterFuture ...
[08:28:39.360]  - Condition #66: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.348] - result already collected: FutureResult
[08:28:39.360]  - Condition #67: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.348] result() for ClusterFuture ... done
[08:28:39.360] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "cleanup")=function ()  
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "cleanup")=function ()  
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[08:28:39.367] getGlobalsAndPackages() ...
[08:28:39.367] Searching for globals...
[08:28:39.369] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[08:28:39.369] Searching for globals ... DONE
[08:28:39.369] Resolving globals: FALSE
[08:28:39.370] The total size of the 1 globals is 356 bytes (356 bytes)
[08:28:39.370] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[08:28:39.370] - globals: [1] ‘data’
[08:28:39.371] - packages: [1] ‘future’
[08:28:39.371] getGlobalsAndPackages() ... DONE
[08:28:39.371] run() for ‘Future’ ...
[08:28:39.371] - state: ‘created’
[08:28:39.371] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:39.372] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:39.372] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:39.372]   - Field: ‘label’
[08:28:39.372]   - Field: ‘local’
[08:28:39.372]   - Field: ‘owner’
[08:28:39.372]   - Field: ‘envir’
[08:28:39.372]   - Field: ‘packages’
[08:28:39.372]   - Field: ‘gc’
[08:28:39.373]   - Field: ‘conditions’
[08:28:39.373]   - Field: ‘expr’
[08:28:39.373]   - Field: ‘uuid’
[08:28:39.373]   - Field: ‘seed’
[08:28:39.373]   - Field: ‘version’
[08:28:39.373]   - Field: ‘result’
[08:28:39.373]   - Field: ‘asynchronous’
[08:28:39.373]   - Field: ‘calls’
[08:28:39.373]   - Field: ‘globals’
[08:28:39.374]   - Field: ‘stdout’
[08:28:39.374]   - Field: ‘earlySignal’
[08:28:39.374]   - Field: ‘lazy’
[08:28:39.374]   - Field: ‘state’
[08:28:39.374] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:39.374] - Launch lazy future ...
[08:28:39.374] Packages needed by the future expression (n = 1): ‘future’
[08:28:39.374] Packages needed by future strategies (n = 1): ‘future’
[08:28:39.375] {
[08:28:39.375]     {
[08:28:39.375]         {
[08:28:39.375]             ...future.startTime <- base::Sys.time()
[08:28:39.375]             {
[08:28:39.375]                 {
[08:28:39.375]                   {
[08:28:39.375]                     {
[08:28:39.375]                       base::local({
[08:28:39.375]                         has_future <- base::requireNamespace("future", 
[08:28:39.375]                           quietly = TRUE)
[08:28:39.375]                         if (has_future) {
[08:28:39.375]                           ns <- base::getNamespace("future")
[08:28:39.375]                           version <- ns[[".package"]][["version"]]
[08:28:39.375]                           if (is.null(version)) 
[08:28:39.375]                             version <- utils::packageVersion("future")
[08:28:39.375]                         }
[08:28:39.375]                         else {
[08:28:39.375]                           version <- NULL
[08:28:39.375]                         }
[08:28:39.375]                         if (!has_future || version < "1.8.0") {
[08:28:39.375]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:39.375]                             "", base::R.version$version.string), 
[08:28:39.375]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:39.375]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:39.375]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:39.375]                               "release", "version")], collapse = " "), 
[08:28:39.375]                             hostname = base::Sys.info()[["nodename"]])
[08:28:39.375]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:39.375]                             info)
[08:28:39.375]                           info <- base::paste(info, collapse = "; ")
[08:28:39.375]                           if (!has_future) {
[08:28:39.375]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:39.375]                               info)
[08:28:39.375]                           }
[08:28:39.375]                           else {
[08:28:39.375]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:39.375]                               info, version)
[08:28:39.375]                           }
[08:28:39.375]                           base::stop(msg)
[08:28:39.375]                         }
[08:28:39.375]                       })
[08:28:39.375]                     }
[08:28:39.375]                     base::local({
[08:28:39.375]                       for (pkg in "future") {
[08:28:39.375]                         base::loadNamespace(pkg)
[08:28:39.375]                         base::library(pkg, character.only = TRUE)
[08:28:39.375]                       }
[08:28:39.375]                     })
[08:28:39.375]                   }
[08:28:39.375]                   ...future.strategy.old <- future::plan("list")
[08:28:39.375]                   options(future.plan = NULL)
[08:28:39.375]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:39.375]                   future::plan(list(b = function (..., workers = availableCores(), 
[08:28:39.375]                     lazy = FALSE, rscript_libs = .libPaths(), 
[08:28:39.375]                     envir = parent.frame()) 
[08:28:39.375]                   {
[08:28:39.375]                     if (is.function(workers)) 
[08:28:39.375]                       workers <- workers()
[08:28:39.375]                     workers <- structure(as.integer(workers), 
[08:28:39.375]                       class = class(workers))
[08:28:39.375]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[08:28:39.375]                       workers >= 1)
[08:28:39.375]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[08:28:39.375]                       return(sequential(..., lazy = TRUE, envir = envir))
[08:28:39.375]                     }
[08:28:39.375]                     future <- MultisessionFuture(..., workers = workers, 
[08:28:39.375]                       lazy = lazy, rscript_libs = rscript_libs, 
[08:28:39.375]                       envir = envir)
[08:28:39.375]                     if (!future$lazy) 
[08:28:39.375]                       future <- run(future)
[08:28:39.375]                     invisible(future)
[08:28:39.375]                   }), .cleanup = FALSE, .init = FALSE)
[08:28:39.375]                 }
[08:28:39.375]                 ...future.workdir <- getwd()
[08:28:39.375]             }
[08:28:39.375]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:39.375]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:39.375]         }
[08:28:39.375]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:39.375]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:39.375]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:39.375]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:39.375]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:39.375]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:39.375]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:39.375]             base::names(...future.oldOptions))
[08:28:39.375]     }
[08:28:39.375]     if (FALSE) {
[08:28:39.375]     }
[08:28:39.375]     else {
[08:28:39.375]         if (TRUE) {
[08:28:39.375]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:39.375]                 open = "w")
[08:28:39.375]         }
[08:28:39.375]         else {
[08:28:39.375]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:39.375]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:39.375]         }
[08:28:39.375]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:39.375]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:39.375]             base::sink(type = "output", split = FALSE)
[08:28:39.375]             base::close(...future.stdout)
[08:28:39.375]         }, add = TRUE)
[08:28:39.375]     }
[08:28:39.375]     ...future.frame <- base::sys.nframe()
[08:28:39.375]     ...future.conditions <- base::list()
[08:28:39.375]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:39.375]     if (FALSE) {
[08:28:39.375]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:39.375]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:39.375]     }
[08:28:39.375]     ...future.result <- base::tryCatch({
[08:28:39.375]         base::withCallingHandlers({
[08:28:39.375]             ...future.value <- base::withVisible(base::local({
[08:28:39.375]                 value(future(subset(data, a == 2)))
[08:28:39.375]             }))
[08:28:39.375]             future::FutureResult(value = ...future.value$value, 
[08:28:39.375]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:39.375]                   ...future.rng), globalenv = if (FALSE) 
[08:28:39.375]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:39.375]                     ...future.globalenv.names))
[08:28:39.375]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:39.375]         }, condition = base::local({
[08:28:39.375]             c <- base::c
[08:28:39.375]             inherits <- base::inherits
[08:28:39.375]             invokeRestart <- base::invokeRestart
[08:28:39.375]             length <- base::length
[08:28:39.375]             list <- base::list
[08:28:39.375]             seq.int <- base::seq.int
[08:28:39.375]             signalCondition <- base::signalCondition
[08:28:39.375]             sys.calls <- base::sys.calls
[08:28:39.375]             `[[` <- base::`[[`
[08:28:39.375]             `+` <- base::`+`
[08:28:39.375]             `<<-` <- base::`<<-`
[08:28:39.375]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:39.375]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:39.375]                   3L)]
[08:28:39.375]             }
[08:28:39.375]             function(cond) {
[08:28:39.375]                 is_error <- inherits(cond, "error")
[08:28:39.375]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:39.375]                   NULL)
[08:28:39.375]                 if (is_error) {
[08:28:39.375]                   sessionInformation <- function() {
[08:28:39.375]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:39.375]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:39.375]                       search = base::search(), system = base::Sys.info())
[08:28:39.375]                   }
[08:28:39.375]                   ...future.conditions[[length(...future.conditions) + 
[08:28:39.375]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:39.375]                     cond$call), session = sessionInformation(), 
[08:28:39.375]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:39.375]                   signalCondition(cond)
[08:28:39.375]                 }
[08:28:39.375]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:39.375]                 "immediateCondition"))) {
[08:28:39.375]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:39.375]                   ...future.conditions[[length(...future.conditions) + 
[08:28:39.375]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:39.375]                   if (TRUE && !signal) {
[08:28:39.375]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:39.375]                     {
[08:28:39.375]                       inherits <- base::inherits
[08:28:39.375]                       invokeRestart <- base::invokeRestart
[08:28:39.375]                       is.null <- base::is.null
[08:28:39.375]                       muffled <- FALSE
[08:28:39.375]                       if (inherits(cond, "message")) {
[08:28:39.375]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:39.375]                         if (muffled) 
[08:28:39.375]                           invokeRestart("muffleMessage")
[08:28:39.375]                       }
[08:28:39.375]                       else if (inherits(cond, "warning")) {
[08:28:39.375]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:39.375]                         if (muffled) 
[08:28:39.375]                           invokeRestart("muffleWarning")
[08:28:39.375]                       }
[08:28:39.375]                       else if (inherits(cond, "condition")) {
[08:28:39.375]                         if (!is.null(pattern)) {
[08:28:39.375]                           computeRestarts <- base::computeRestarts
[08:28:39.375]                           grepl <- base::grepl
[08:28:39.375]                           restarts <- computeRestarts(cond)
[08:28:39.375]                           for (restart in restarts) {
[08:28:39.375]                             name <- restart$name
[08:28:39.375]                             if (is.null(name)) 
[08:28:39.375]                               next
[08:28:39.375]                             if (!grepl(pattern, name)) 
[08:28:39.375]                               next
[08:28:39.375]                             invokeRestart(restart)
[08:28:39.375]                             muffled <- TRUE
[08:28:39.375]                             break
[08:28:39.375]                           }
[08:28:39.375]                         }
[08:28:39.375]                       }
[08:28:39.375]                       invisible(muffled)
[08:28:39.375]                     }
[08:28:39.375]                     muffleCondition(cond, pattern = "^muffle")
[08:28:39.375]                   }
[08:28:39.375]                 }
[08:28:39.375]                 else {
[08:28:39.375]                   if (TRUE) {
[08:28:39.375]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:39.375]                     {
[08:28:39.375]                       inherits <- base::inherits
[08:28:39.375]                       invokeRestart <- base::invokeRestart
[08:28:39.375]                       is.null <- base::is.null
[08:28:39.375]                       muffled <- FALSE
[08:28:39.375]                       if (inherits(cond, "message")) {
[08:28:39.375]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:39.375]                         if (muffled) 
[08:28:39.375]                           invokeRestart("muffleMessage")
[08:28:39.375]                       }
[08:28:39.375]                       else if (inherits(cond, "warning")) {
[08:28:39.375]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:39.375]                         if (muffled) 
[08:28:39.375]                           invokeRestart("muffleWarning")
[08:28:39.375]                       }
[08:28:39.375]                       else if (inherits(cond, "condition")) {
[08:28:39.375]                         if (!is.null(pattern)) {
[08:28:39.375]                           computeRestarts <- base::computeRestarts
[08:28:39.375]                           grepl <- base::grepl
[08:28:39.375]                           restarts <- computeRestarts(cond)
[08:28:39.375]                           for (restart in restarts) {
[08:28:39.375]                             name <- restart$name
[08:28:39.375]                             if (is.null(name)) 
[08:28:39.375]                               next
[08:28:39.375]                             if (!grepl(pattern, name)) 
[08:28:39.375]                               next
[08:28:39.375]                             invokeRestart(restart)
[08:28:39.375]                             muffled <- TRUE
[08:28:39.375]                             break
[08:28:39.375]                           }
[08:28:39.375]                         }
[08:28:39.375]                       }
[08:28:39.375]                       invisible(muffled)
[08:28:39.375]                     }
[08:28:39.375]                     muffleCondition(cond, pattern = "^muffle")
[08:28:39.375]                   }
[08:28:39.375]                 }
[08:28:39.375]             }
[08:28:39.375]         }))
[08:28:39.375]     }, error = function(ex) {
[08:28:39.375]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:39.375]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:39.375]                 ...future.rng), started = ...future.startTime, 
[08:28:39.375]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:39.375]             version = "1.8"), class = "FutureResult")
[08:28:39.375]     }, finally = {
[08:28:39.375]         if (!identical(...future.workdir, getwd())) 
[08:28:39.375]             setwd(...future.workdir)
[08:28:39.375]         {
[08:28:39.375]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:39.375]                 ...future.oldOptions$nwarnings <- NULL
[08:28:39.375]             }
[08:28:39.375]             base::options(...future.oldOptions)
[08:28:39.375]             if (.Platform$OS.type == "windows") {
[08:28:39.375]                 old_names <- names(...future.oldEnvVars)
[08:28:39.375]                 envs <- base::Sys.getenv()
[08:28:39.375]                 names <- names(envs)
[08:28:39.375]                 common <- intersect(names, old_names)
[08:28:39.375]                 added <- setdiff(names, old_names)
[08:28:39.375]                 removed <- setdiff(old_names, names)
[08:28:39.375]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:39.375]                   envs[common]]
[08:28:39.375]                 NAMES <- toupper(changed)
[08:28:39.375]                 args <- list()
[08:28:39.375]                 for (kk in seq_along(NAMES)) {
[08:28:39.375]                   name <- changed[[kk]]
[08:28:39.375]                   NAME <- NAMES[[kk]]
[08:28:39.375]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.375]                     next
[08:28:39.375]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:39.375]                 }
[08:28:39.375]                 NAMES <- toupper(added)
[08:28:39.375]                 for (kk in seq_along(NAMES)) {
[08:28:39.375]                   name <- added[[kk]]
[08:28:39.375]                   NAME <- NAMES[[kk]]
[08:28:39.375]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.375]                     next
[08:28:39.375]                   args[[name]] <- ""
[08:28:39.375]                 }
[08:28:39.375]                 NAMES <- toupper(removed)
[08:28:39.375]                 for (kk in seq_along(NAMES)) {
[08:28:39.375]                   name <- removed[[kk]]
[08:28:39.375]                   NAME <- NAMES[[kk]]
[08:28:39.375]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.375]                     next
[08:28:39.375]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:39.375]                 }
[08:28:39.375]                 if (length(args) > 0) 
[08:28:39.375]                   base::do.call(base::Sys.setenv, args = args)
[08:28:39.375]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:39.375]             }
[08:28:39.375]             else {
[08:28:39.375]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:39.375]             }
[08:28:39.375]             {
[08:28:39.375]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:39.375]                   0L) {
[08:28:39.375]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:39.375]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:39.375]                   base::options(opts)
[08:28:39.375]                 }
[08:28:39.375]                 {
[08:28:39.375]                   {
[08:28:39.375]                     NULL
[08:28:39.375]                     RNGkind("Mersenne-Twister")
[08:28:39.375]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:39.375]                       inherits = FALSE)
[08:28:39.375]                   }
[08:28:39.375]                   options(future.plan = NULL)
[08:28:39.375]                   if (is.na(NA_character_)) 
[08:28:39.375]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:39.375]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:39.375]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:39.375]                     .init = FALSE)
[08:28:39.375]                 }
[08:28:39.375]             }
[08:28:39.375]         }
[08:28:39.375]     })
[08:28:39.375]     if (TRUE) {
[08:28:39.375]         base::sink(type = "output", split = FALSE)
[08:28:39.375]         if (TRUE) {
[08:28:39.375]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:39.375]         }
[08:28:39.375]         else {
[08:28:39.375]             ...future.result["stdout"] <- base::list(NULL)
[08:28:39.375]         }
[08:28:39.375]         base::close(...future.stdout)
[08:28:39.375]         ...future.stdout <- NULL
[08:28:39.375]     }
[08:28:39.375]     ...future.result$conditions <- ...future.conditions
[08:28:39.375]     ...future.result$finished <- base::Sys.time()
[08:28:39.375]     ...future.result
[08:28:39.375] }
[08:28:39.377] assign_globals() ...
[08:28:39.377] List of 1
[08:28:39.377]  $ data:'data.frame':	3 obs. of  2 variables:
[08:28:39.377]   ..$ a: int [1:3] 1 2 3
[08:28:39.377]   ..$ b: int [1:3] 3 2 1
[08:28:39.377]  - attr(*, "where")=List of 1
[08:28:39.377]   ..$ data:<environment: R_EmptyEnv> 
[08:28:39.377]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:39.377]  - attr(*, "resolved")= logi FALSE
[08:28:39.377]  - attr(*, "total_size")= num 356
[08:28:39.377]  - attr(*, "already-done")= logi TRUE
[08:28:39.381] - copied ‘data’ to environment
[08:28:39.381] assign_globals() ... done
[08:28:39.382] plan(): Setting new future strategy stack:
[08:28:39.382] List of future strategies:
[08:28:39.382] 1. multisession:
[08:28:39.382]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:28:39.382]    - tweaked: FALSE
[08:28:39.382]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:39.384] plan(): nbrOfWorkers() = 2
[08:28:39.479] plan(): Setting new future strategy stack:
[08:28:39.479] List of future strategies:
[08:28:39.479] 1. sequential:
[08:28:39.479]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:39.479]    - tweaked: FALSE
[08:28:39.479]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:39.479] 2. multisession:
[08:28:39.479]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:28:39.479]    - tweaked: FALSE
[08:28:39.479]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:39.480] plan(): nbrOfWorkers() = 1
[08:28:39.480] SequentialFuture started (and completed)
[08:28:39.480] signalConditions() ...
[08:28:39.480]  - include = ‘immediateCondition’
[08:28:39.480]  - exclude = 
[08:28:39.480]  - resignal = FALSE
[08:28:39.480]  - Number of conditions: 63
[08:28:39.480] signalConditions() ... done
[08:28:39.481] - Launch lazy future ... done
[08:28:39.481] run() for ‘SequentialFuture’ ... done
[08:28:39.481] signalConditions() ...
[08:28:39.481]  - include = ‘immediateCondition’
[08:28:39.481]  - exclude = 
[08:28:39.481]  - resignal = FALSE
[08:28:39.481]  - Number of conditions: 63
[08:28:39.481] signalConditions() ... done
[08:28:39.481] Future state: ‘finished’
[08:28:39.481] signalConditions() ...
[08:28:39.482]  - include = ‘condition’
[08:28:39.482]  - exclude = ‘immediateCondition’
[08:28:39.482]  - resignal = TRUE
[08:28:39.482]  - Number of conditions: 63
[08:28:39.482]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.384] getGlobalsAndPackages() ...
[08:28:39.482]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.384] Searching for globals...
[08:28:39.482]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.402] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[08:28:39.482]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.402] Searching for globals ... DONE
[08:28:39.482]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.402] Resolving globals: FALSE
[08:28:39.482]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.403] The total size of the 1 globals is 356 bytes (356 bytes)
[08:28:39.483]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.403] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[08:28:39.483]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.403] - globals: [1] ‘data’
[08:28:39.483]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.404] 
[08:28:39.483]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.404] getGlobalsAndPackages() ... DONE
[08:28:39.483]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.404] run() for ‘Future’ ...
[08:28:39.483]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.404] - state: ‘created’
[08:28:39.483]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.404] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:39.483]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.419] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:39.484]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.419] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:39.484]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.419]   - Field: ‘node’
[08:28:39.484]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.419]   - Field: ‘label’
[08:28:39.484]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.420]   - Field: ‘local’
[08:28:39.484]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.420]   - Field: ‘owner’
[08:28:39.484]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.420]   - Field: ‘envir’
[08:28:39.484]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.420]   - Field: ‘workers’
[08:28:39.484]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.420]   - Field: ‘packages’
[08:28:39.484]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.420]   - Field: ‘gc’
[08:28:39.485]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.420]   - Field: ‘conditions’
[08:28:39.485]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.420]   - Field: ‘persistent’
[08:28:39.485]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.421]   - Field: ‘expr’
[08:28:39.485]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.421]   - Field: ‘uuid’
[08:28:39.485]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.421]   - Field: ‘seed’
[08:28:39.485]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.421]   - Field: ‘version’
[08:28:39.485]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.421]   - Field: ‘result’
[08:28:39.485]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.421]   - Field: ‘asynchronous’
[08:28:39.486]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.421]   - Field: ‘calls’
[08:28:39.486]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.421]   - Field: ‘globals’
[08:28:39.486]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.422]   - Field: ‘stdout’
[08:28:39.486]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.422]   - Field: ‘earlySignal’
[08:28:39.486]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.426]   - Field: ‘lazy’
[08:28:39.486]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.426]   - Field: ‘state’
[08:28:39.486]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.426] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:39.486]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.427] - Launch lazy future ...
[08:28:39.486]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.427] Packages needed by the future expression (n = 0): <none>
[08:28:39.487]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.427] Packages needed by future strategies (n = 0): <none>
[08:28:39.487]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.427] {
[08:28:39.427]     {
[08:28:39.427]         {
[08:28:39.427]             ...future.startTime <- base::Sys.time()
[08:28:39.427]             {
[08:28:39.427]                 {
[08:28:39.427]                   {
[08:28:39.427]                     {
[08:28:39.427]                       base::local({
[08:28:39.427]                         has_future <- base::requireNamespace("future", 
[08:28:39.427]                           quietly = TRUE)
[08:28:39.427]                         if (has_future) {
[08:28:39.427]                           ns <- base::getNamespace("future")
[08:28:39.427]                           version <- ns[[".package"]][["version"]]
[08:28:39.427]                           if (is.null(version)) 
[08:28:39.427]                             version <- utils::packageVersion("future")
[08:28:39.427]                         }
[08:28:39.427]                         else {
[08:28:39.427]                           version <- NULL
[08:28:39.427]                         }
[08:28:39.427]                         if (!has_future || version < "1.8.0") {
[08:28:39.427]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:39.427]                             "", base::R.version$version.string), 
[08:28:39.427]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:39.427]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:39.427]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:39.427]                               "release", "version")], collapse = " "), 
[08:28:39.427]                             hostname = base::Sys.info()[["nodename"]])
[08:28:39.427]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:39.427]                             info)
[08:28:39.427]                           info <- base::paste(info, collapse = "; ")
[08:28:39.427]                           if (!has_future) {
[08:28:39.427]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:39.427]                               info)
[08:28:39.427]                           }
[08:28:39.427]                           else {
[08:28:39.427]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:39.427]                               info, version)
[08:28:39.427]                           }
[08:28:39.427]                           base::stop(msg)
[08:28:39.427]                         }
[08:28:39.427]                       })
[08:28:39.427]                     }
[08:28:39.427]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:39.427]                     base::options(mc.cores = 1L)
[08:28:39.427]                   }
[08:28:39.427]                   ...future.strategy.old <- future::plan("list")
[08:28:39.427]                   options(future.plan = NULL)
[08:28:39.427]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:39.427]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:39.427]                 }
[08:28:39.427]                 ...future.workdir <- getwd()
[08:28:39.427]             }
[08:28:39.427]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:39.427]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:39.427]         }
[08:28:39.427]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:39.427]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:39.427]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:39.427]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:39.427]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:39.427]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:39.427]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:39.427]             base::names(...future.oldOptions))
[08:28:39.427]     }
[08:28:39.427]     if (FALSE) {
[08:28:39.427]     }
[08:28:39.427]     else {
[08:28:39.427]         if (TRUE) {
[08:28:39.427]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:39.427]                 open = "w")
[08:28:39.427]         }
[08:28:39.427]         else {
[08:28:39.427]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:39.427]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:39.427]         }
[08:28:39.427]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:39.427]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:39.427]             base::sink(type = "output", split = FALSE)
[08:28:39.427]             base::close(...future.stdout)
[08:28:39.427]         }, add = TRUE)
[08:28:39.427]     }
[08:28:39.427]     ...future.frame <- base::sys.nframe()
[08:28:39.427]     ...future.conditions <- base::list()
[08:28:39.427]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:39.427]     if (FALSE) {
[08:28:39.427]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:39.427]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:39.427]     }
[08:28:39.427]     ...future.result <- base::tryCatch({
[08:28:39.427]         base::withCallingHandlers({
[08:28:39.427]             ...future.value <- base::withVisible(base::local({
[08:28:39.427]                 ...future.makeSendCondition <- base::local({
[08:28:39.427]                   sendCondition <- NULL
[08:28:39.427]                   function(frame = 1L) {
[08:28:39.427]                     if (is.function(sendCondition)) 
[08:28:39.427]                       return(sendCondition)
[08:28:39.427]                     ns <- getNamespace("parallel")
[08:28:39.427]                     if (exists("sendData", mode = "function", 
[08:28:39.427]                       envir = ns)) {
[08:28:39.427]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:39.427]                         envir = ns)
[08:28:39.427]                       envir <- sys.frame(frame)
[08:28:39.427]                       master <- NULL
[08:28:39.427]                       while (!identical(envir, .GlobalEnv) && 
[08:28:39.427]                         !identical(envir, emptyenv())) {
[08:28:39.427]                         if (exists("master", mode = "list", envir = envir, 
[08:28:39.427]                           inherits = FALSE)) {
[08:28:39.427]                           master <- get("master", mode = "list", 
[08:28:39.427]                             envir = envir, inherits = FALSE)
[08:28:39.427]                           if (inherits(master, c("SOCKnode", 
[08:28:39.427]                             "SOCK0node"))) {
[08:28:39.427]                             sendCondition <<- function(cond) {
[08:28:39.427]                               data <- list(type = "VALUE", value = cond, 
[08:28:39.427]                                 success = TRUE)
[08:28:39.427]                               parallel_sendData(master, data)
[08:28:39.427]                             }
[08:28:39.427]                             return(sendCondition)
[08:28:39.427]                           }
[08:28:39.427]                         }
[08:28:39.427]                         frame <- frame + 1L
[08:28:39.427]                         envir <- sys.frame(frame)
[08:28:39.427]                       }
[08:28:39.427]                     }
[08:28:39.427]                     sendCondition <<- function(cond) NULL
[08:28:39.427]                   }
[08:28:39.427]                 })
[08:28:39.427]                 withCallingHandlers({
[08:28:39.427]                   subset(data, a == 2)
[08:28:39.427]                 }, immediateCondition = function(cond) {
[08:28:39.427]                   sendCondition <- ...future.makeSendCondition()
[08:28:39.427]                   sendCondition(cond)
[08:28:39.427]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:39.427]                   {
[08:28:39.427]                     inherits <- base::inherits
[08:28:39.427]                     invokeRestart <- base::invokeRestart
[08:28:39.427]                     is.null <- base::is.null
[08:28:39.427]                     muffled <- FALSE
[08:28:39.427]                     if (inherits(cond, "message")) {
[08:28:39.427]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:39.427]                       if (muffled) 
[08:28:39.427]                         invokeRestart("muffleMessage")
[08:28:39.427]                     }
[08:28:39.427]                     else if (inherits(cond, "warning")) {
[08:28:39.427]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:39.427]                       if (muffled) 
[08:28:39.427]                         invokeRestart("muffleWarning")
[08:28:39.427]                     }
[08:28:39.427]                     else if (inherits(cond, "condition")) {
[08:28:39.427]                       if (!is.null(pattern)) {
[08:28:39.427]                         computeRestarts <- base::computeRestarts
[08:28:39.427]                         grepl <- base::grepl
[08:28:39.427]                         restarts <- computeRestarts(cond)
[08:28:39.427]                         for (restart in restarts) {
[08:28:39.427]                           name <- restart$name
[08:28:39.427]                           if (is.null(name)) 
[08:28:39.427]                             next
[08:28:39.427]                           if (!grepl(pattern, name)) 
[08:28:39.427]                             next
[08:28:39.427]                           invokeRestart(restart)
[08:28:39.427]                           muffled <- TRUE
[08:28:39.427]                           break
[08:28:39.427]                         }
[08:28:39.427]                       }
[08:28:39.427]                     }
[08:28:39.427]                     invisible(muffled)
[08:28:39.427]                   }
[08:28:39.427]                   muffleCondition(cond)
[08:28:39.427]                 })
[08:28:39.427]             }))
[08:28:39.427]             future::FutureResult(value = ...future.value$value, 
[08:28:39.427]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:39.427]                   ...future.rng), globalenv = if (FALSE) 
[08:28:39.427]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:39.427]                     ...future.globalenv.names))
[08:28:39.427]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:39.427]         }, condition = base::local({
[08:28:39.427]             c <- base::c
[08:28:39.427]             inherits <- base::inherits
[08:28:39.427]             invokeRestart <- base::invokeRestart
[08:28:39.427]             length <- base::length
[08:28:39.427]             list <- base::list
[08:28:39.427]             seq.int <- base::seq.int
[08:28:39.427]             signalCondition <- base::signalCondition
[08:28:39.427]             sys.calls <- base::sys.calls
[08:28:39.427]             `[[` <- base::`[[`
[08:28:39.427]             `+` <- base::`+`
[08:28:39.427]             `<<-` <- base::`<<-`
[08:28:39.427]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:39.427]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:39.427]                   3L)]
[08:28:39.427]             }
[08:28:39.427]             function(cond) {
[08:28:39.427]                 is_error <- inherits(cond, "error")
[08:28:39.427]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:39.427]                   NULL)
[08:28:39.427]                 if (is_error) {
[08:28:39.427]                   sessionInformation <- function() {
[08:28:39.427]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:39.427]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:39.427]                       search = base::search(), system = base::Sys.info())
[08:28:39.427]                   }
[08:28:39.427]                   ...future.conditions[[length(...future.conditions) + 
[08:28:39.427]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:39.427]                     cond$call), session = sessionInformation(), 
[08:28:39.427]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:39.427]                   signalCondition(cond)
[08:28:39.427]                 }
[08:28:39.427]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:39.427]                 "immediateCondition"))) {
[08:28:39.427]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:39.427]                   ...future.conditions[[length(...future.conditions) + 
[08:28:39.427]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:39.427]                   if (TRUE && !signal) {
[08:28:39.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:39.427]                     {
[08:28:39.427]                       inherits <- base::inherits
[08:28:39.427]                       invokeRestart <- base::invokeRestart
[08:28:39.427]                       is.null <- base::is.null
[08:28:39.427]                       muffled <- FALSE
[08:28:39.427]                       if (inherits(cond, "message")) {
[08:28:39.427]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:39.427]                         if (muffled) 
[08:28:39.427]                           invokeRestart("muffleMessage")
[08:28:39.427]                       }
[08:28:39.427]                       else if (inherits(cond, "warning")) {
[08:28:39.427]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:39.427]                         if (muffled) 
[08:28:39.427]                           invokeRestart("muffleWarning")
[08:28:39.427]                       }
[08:28:39.427]                       else if (inherits(cond, "condition")) {
[08:28:39.427]                         if (!is.null(pattern)) {
[08:28:39.427]                           computeRestarts <- base::computeRestarts
[08:28:39.427]                           grepl <- base::grepl
[08:28:39.427]                           restarts <- computeRestarts(cond)
[08:28:39.427]                           for (restart in restarts) {
[08:28:39.427]                             name <- restart$name
[08:28:39.427]                             if (is.null(name)) 
[08:28:39.427]                               next
[08:28:39.427]                             if (!grepl(pattern, name)) 
[08:28:39.427]                               next
[08:28:39.427]                             invokeRestart(restart)
[08:28:39.427]                             muffled <- TRUE
[08:28:39.427]                             break
[08:28:39.427]                           }
[08:28:39.427]                         }
[08:28:39.427]                       }
[08:28:39.427]                       invisible(muffled)
[08:28:39.427]                     }
[08:28:39.427]                     muffleCondition(cond, pattern = "^muffle")
[08:28:39.427]                   }
[08:28:39.427]                 }
[08:28:39.427]                 else {
[08:28:39.427]                   if (TRUE) {
[08:28:39.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:39.427]                     {
[08:28:39.427]                       inherits <- base::inherits
[08:28:39.427]                       invokeRestart <- base::invokeRestart
[08:28:39.427]                       is.null <- base::is.null
[08:28:39.427]                       muffled <- FALSE
[08:28:39.427]                       if (inherits(cond, "message")) {
[08:28:39.427]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:39.427]                         if (muffled) 
[08:28:39.427]                           invokeRestart("muffleMessage")
[08:28:39.427]                       }
[08:28:39.427]                       else if (inherits(cond, "warning")) {
[08:28:39.427]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:39.427]                         if (muffled) 
[08:28:39.427]                           invokeRestart("muffleWarning")
[08:28:39.427]                       }
[08:28:39.427]                       else if (inherits(cond, "condition")) {
[08:28:39.427]                         if (!is.null(pattern)) {
[08:28:39.427]                           computeRestarts <- base::computeRestarts
[08:28:39.427]                           grepl <- base::grepl
[08:28:39.427]                           restarts <- computeRestarts(cond)
[08:28:39.427]                           for (restart in restarts) {
[08:28:39.427]                             name <- restart$name
[08:28:39.427]                             if (is.null(name)) 
[08:28:39.427]                               next
[08:28:39.427]                             if (!grepl(pattern, name)) 
[08:28:39.427]                               next
[08:28:39.427]                             invokeRestart(restart)
[08:28:39.427]                             muffled <- TRUE
[08:28:39.427]                             break
[08:28:39.427]                           }
[08:28:39.427]                         }
[08:28:39.427]                       }
[08:28:39.427]                       invisible(muffled)
[08:28:39.427]                     }
[08:28:39.427]                     muffleCondition(cond, pattern = "^muffle")
[08:28:39.427]                   }
[08:28:39.427]                 }
[08:28:39.427]             }
[08:28:39.427]         }))
[08:28:39.427]     }, error = function(ex) {
[08:28:39.427]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:39.427]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:39.427]                 ...future.rng), started = ...future.startTime, 
[08:28:39.427]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:39.427]             version = "1.8"), class = "FutureResult")
[08:28:39.427]     }, finally = {
[08:28:39.427]         if (!identical(...future.workdir, getwd())) 
[08:28:39.427]             setwd(...future.workdir)
[08:28:39.427]         {
[08:28:39.427]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:39.427]                 ...future.oldOptions$nwarnings <- NULL
[08:28:39.427]             }
[08:28:39.427]             base::options(...future.oldOptions)
[08:28:39.427]             if (.Platform$OS.type == "windows") {
[08:28:39.427]                 old_names <- names(...future.oldEnvVars)
[08:28:39.427]                 envs <- base::Sys.getenv()
[08:28:39.427]                 names <- names(envs)
[08:28:39.427]                 common <- intersect(names, old_names)
[08:28:39.427]                 added <- setdiff(names, old_names)
[08:28:39.427]                 removed <- setdiff(old_names, names)
[08:28:39.427]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:39.427]                   envs[common]]
[08:28:39.427]                 NAMES <- toupper(changed)
[08:28:39.427]                 args <- list()
[08:28:39.427]                 for (kk in seq_along(NAMES)) {
[08:28:39.427]                   name <- changed[[kk]]
[08:28:39.427]                   NAME <- NAMES[[kk]]
[08:28:39.427]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.427]                     next
[08:28:39.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:39.427]                 }
[08:28:39.427]                 NAMES <- toupper(added)
[08:28:39.427]                 for (kk in seq_along(NAMES)) {
[08:28:39.427]                   name <- added[[kk]]
[08:28:39.427]                   NAME <- NAMES[[kk]]
[08:28:39.427]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.427]                     next
[08:28:39.427]                   args[[name]] <- ""
[08:28:39.427]                 }
[08:28:39.427]                 NAMES <- toupper(removed)
[08:28:39.427]                 for (kk in seq_along(NAMES)) {
[08:28:39.427]                   name <- removed[[kk]]
[08:28:39.427]                   NAME <- NAMES[[kk]]
[08:28:39.427]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.427]                     next
[08:28:39.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:39.427]                 }
[08:28:39.427]                 if (length(args) > 0) 
[08:28:39.427]                   base::do.call(base::Sys.setenv, args = args)
[08:28:39.427]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:39.427]             }
[08:28:39.427]             else {
[08:28:39.427]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:39.427]             }
[08:28:39.427]             {
[08:28:39.427]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:39.427]                   0L) {
[08:28:39.427]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:39.427]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:39.427]                   base::options(opts)
[08:28:39.427]                 }
[08:28:39.427]                 {
[08:28:39.427]                   {
[08:28:39.427]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:39.427]                     NULL
[08:28:39.427]                   }
[08:28:39.427]                   options(future.plan = NULL)
[08:28:39.427]                   if (is.na(NA_character_)) 
[08:28:39.427]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:39.427]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:39.427]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:39.427]                     .init = FALSE)
[08:28:39.427]                 }
[08:28:39.427]             }
[08:28:39.427]         }
[08:28:39.427]     })
[08:28:39.427]     if (TRUE) {
[08:28:39.427]         base::sink(type = "output", split = FALSE)
[08:28:39.427]         if (TRUE) {
[08:28:39.427]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:39.427]         }
[08:28:39.427]         else {
[08:28:39.427]             ...future.result["stdout"] <- base::list(NULL)
[08:28:39.427]         }
[08:28:39.427]         base::close(...future.stdout)
[08:28:39.427]         ...future.stdout <- NULL
[08:28:39.427]     }
[08:28:39.427]     ...future.result$conditions <- ...future.conditions
[08:28:39.427]     ...future.result$finished <- base::Sys.time()
[08:28:39.427]     ...future.result
[08:28:39.427] }
[08:28:39.487]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.430] Exporting 1 global objects (643 bytes) to cluster node #1 ...
[08:28:39.487]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.430] Exporting ‘data’ (356 bytes) to cluster node #1 ...
[08:28:39.487]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.430] Exporting ‘data’ (356 bytes) to cluster node #1 ... DONE
[08:28:39.487]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.431] Exporting 1 global objects (643 bytes) to cluster node #1 ... DONE
[08:28:39.487]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.431] MultisessionFuture started
[08:28:39.488]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.431] - Launch lazy future ... done
[08:28:39.488]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.431] run() for ‘MultisessionFuture’ ... done
[08:28:39.488]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.431] result() for ClusterFuture ...
[08:28:39.488]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.431] receiveMessageFromWorker() for ClusterFuture ...
[08:28:39.488]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.432] - Validating connection of MultisessionFuture
[08:28:39.488]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.477] - received message: FutureResult
[08:28:39.488]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.477] - Received FutureResult
[08:28:39.488]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.478] - Erased future from FutureRegistry
[08:28:39.489]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.478] result() for ClusterFuture ...
[08:28:39.489]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.478] - result already collected: FutureResult
[08:28:39.489]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.478] result() for ClusterFuture ... done
[08:28:39.489]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.478] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:39.489]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.478] result() for ClusterFuture ... done
[08:28:39.489]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.478] result() for ClusterFuture ...
[08:28:39.489]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.478] - result already collected: FutureResult
[08:28:39.489]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.478] result() for ClusterFuture ... done
[08:28:39.489] signalConditions() ... done
- plan(list('sequential', 'multisession')) ... DONE
- plan(list('multicore', 'sequential')) ...
[08:28:39.490] plan(): Setting new future strategy stack:
[08:28:39.490] List of future strategies:
[08:28:39.490] 1. multicore:
[08:28:39.490]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:39.490]    - tweaked: FALSE
[08:28:39.490]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:39.490] 2. sequential:
[08:28:39.490]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:39.490]    - tweaked: FALSE
[08:28:39.490]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:39.492] plan(): nbrOfWorkers() = 2
[08:28:39.492] getGlobalsAndPackages() ...
[08:28:39.492] Searching for globals...
[08:28:39.508] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[08:28:39.508] Searching for globals ... DONE
[08:28:39.508] Resolving globals: FALSE
[08:28:39.509] The total size of the 2 globals is 7.79 KiB (7973 bytes)
[08:28:39.510] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 7.79 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (7.74 KiB of class ‘list’) and ‘strategy2’ (49 bytes of class ‘character’)
[08:28:39.510] - globals: [2] ‘nested’, ‘strategy2’
[08:28:39.510] - packages: [1] ‘future’
[08:28:39.510] getGlobalsAndPackages() ... DONE
[08:28:39.510] run() for ‘Future’ ...
[08:28:39.511] - state: ‘created’
[08:28:39.511] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:39.512] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:39.513] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:39.513]   - Field: ‘label’
[08:28:39.513]   - Field: ‘local’
[08:28:39.513]   - Field: ‘owner’
[08:28:39.513]   - Field: ‘envir’
[08:28:39.513]   - Field: ‘workers’
[08:28:39.513]   - Field: ‘packages’
[08:28:39.513]   - Field: ‘gc’
[08:28:39.513]   - Field: ‘job’
[08:28:39.513]   - Field: ‘conditions’
[08:28:39.513]   - Field: ‘expr’
[08:28:39.514]   - Field: ‘uuid’
[08:28:39.514]   - Field: ‘seed’
[08:28:39.514]   - Field: ‘version’
[08:28:39.514]   - Field: ‘result’
[08:28:39.514]   - Field: ‘asynchronous’
[08:28:39.514]   - Field: ‘calls’
[08:28:39.514]   - Field: ‘globals’
[08:28:39.514]   - Field: ‘stdout’
[08:28:39.514]   - Field: ‘earlySignal’
[08:28:39.514]   - Field: ‘lazy’
[08:28:39.514]   - Field: ‘state’
[08:28:39.514] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:39.515] - Launch lazy future ...
[08:28:39.515] Packages needed by the future expression (n = 1): ‘future’
[08:28:39.515] Packages needed by future strategies (n = 1): ‘future’
[08:28:39.515] {
[08:28:39.515]     {
[08:28:39.515]         {
[08:28:39.515]             ...future.startTime <- base::Sys.time()
[08:28:39.515]             {
[08:28:39.515]                 {
[08:28:39.515]                   {
[08:28:39.515]                     {
[08:28:39.515]                       {
[08:28:39.515]                         base::local({
[08:28:39.515]                           has_future <- base::requireNamespace("future", 
[08:28:39.515]                             quietly = TRUE)
[08:28:39.515]                           if (has_future) {
[08:28:39.515]                             ns <- base::getNamespace("future")
[08:28:39.515]                             version <- ns[[".package"]][["version"]]
[08:28:39.515]                             if (is.null(version)) 
[08:28:39.515]                               version <- utils::packageVersion("future")
[08:28:39.515]                           }
[08:28:39.515]                           else {
[08:28:39.515]                             version <- NULL
[08:28:39.515]                           }
[08:28:39.515]                           if (!has_future || version < "1.8.0") {
[08:28:39.515]                             info <- base::c(r_version = base::gsub("R version ", 
[08:28:39.515]                               "", base::R.version$version.string), 
[08:28:39.515]                               platform = base::sprintf("%s (%s-bit)", 
[08:28:39.515]                                 base::R.version$platform, 8 * 
[08:28:39.515]                                   base::.Machine$sizeof.pointer), 
[08:28:39.515]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:39.515]                                 "release", "version")], collapse = " "), 
[08:28:39.515]                               hostname = base::Sys.info()[["nodename"]])
[08:28:39.515]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:28:39.515]                               info)
[08:28:39.515]                             info <- base::paste(info, collapse = "; ")
[08:28:39.515]                             if (!has_future) {
[08:28:39.515]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:39.515]                                 info)
[08:28:39.515]                             }
[08:28:39.515]                             else {
[08:28:39.515]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:39.515]                                 info, version)
[08:28:39.515]                             }
[08:28:39.515]                             base::stop(msg)
[08:28:39.515]                           }
[08:28:39.515]                         })
[08:28:39.515]                       }
[08:28:39.515]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:39.515]                       base::options(mc.cores = 1L)
[08:28:39.515]                     }
[08:28:39.515]                     base::local({
[08:28:39.515]                       for (pkg in "future") {
[08:28:39.515]                         base::loadNamespace(pkg)
[08:28:39.515]                         base::library(pkg, character.only = TRUE)
[08:28:39.515]                       }
[08:28:39.515]                     })
[08:28:39.515]                   }
[08:28:39.515]                   ...future.strategy.old <- future::plan("list")
[08:28:39.515]                   options(future.plan = NULL)
[08:28:39.515]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:39.515]                   future::plan(list(b = function (..., envir = parent.frame()) 
[08:28:39.515]                   {
[08:28:39.515]                     future <- SequentialFuture(..., envir = envir)
[08:28:39.515]                     if (!future$lazy) 
[08:28:39.515]                       future <- run(future)
[08:28:39.515]                     invisible(future)
[08:28:39.515]                   }), .cleanup = FALSE, .init = FALSE)
[08:28:39.515]                 }
[08:28:39.515]                 ...future.workdir <- getwd()
[08:28:39.515]             }
[08:28:39.515]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:39.515]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:39.515]         }
[08:28:39.515]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:39.515]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:39.515]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:39.515]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:39.515]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:39.515]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:39.515]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:39.515]             base::names(...future.oldOptions))
[08:28:39.515]     }
[08:28:39.515]     if (FALSE) {
[08:28:39.515]     }
[08:28:39.515]     else {
[08:28:39.515]         if (TRUE) {
[08:28:39.515]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:39.515]                 open = "w")
[08:28:39.515]         }
[08:28:39.515]         else {
[08:28:39.515]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:39.515]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:39.515]         }
[08:28:39.515]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:39.515]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:39.515]             base::sink(type = "output", split = FALSE)
[08:28:39.515]             base::close(...future.stdout)
[08:28:39.515]         }, add = TRUE)
[08:28:39.515]     }
[08:28:39.515]     ...future.frame <- base::sys.nframe()
[08:28:39.515]     ...future.conditions <- base::list()
[08:28:39.515]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:39.515]     if (FALSE) {
[08:28:39.515]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:39.515]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:39.515]     }
[08:28:39.515]     ...future.result <- base::tryCatch({
[08:28:39.515]         base::withCallingHandlers({
[08:28:39.515]             ...future.value <- base::withVisible(base::local({
[08:28:39.515]                 withCallingHandlers({
[08:28:39.515]                   {
[08:28:39.515]                     a <- 1L
[08:28:39.515]                     plan_a <- unclass(future::plan("list"))
[08:28:39.515]                     nested_a <- nested[-1]
[08:28:39.515]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[08:28:39.515]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[08:28:39.515]                       strategy2))
[08:28:39.515]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[08:28:39.515]                       "init") <- NULL
[08:28:39.515]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[08:28:39.515]                       "init") <- NULL
[08:28:39.515]                     stopifnot(all.equal(plan_a, nested_a))
[08:28:39.515]                     y %<-% {
[08:28:39.515]                       b <- 2L
[08:28:39.515]                       plan_b <- future::plan("list")
[08:28:39.515]                       nested_b <- nested_a[-1]
[08:28:39.515]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[08:28:39.515]                         1L, inherits(plan_b[[1]], "future"), 
[08:28:39.515]                         inherits(future::plan("next"), "sequential"))
[08:28:39.515]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[08:28:39.515]                         b = b, nested_b = nested_b, plan_b = plan_b)
[08:28:39.515]                     }
[08:28:39.515]                     y
[08:28:39.515]                   }
[08:28:39.515]                 }, immediateCondition = function(cond) {
[08:28:39.515]                   save_rds <- function (object, pathname, ...) 
[08:28:39.515]                   {
[08:28:39.515]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:39.515]                     if (file_test("-f", pathname_tmp)) {
[08:28:39.515]                       fi_tmp <- file.info(pathname_tmp)
[08:28:39.515]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:39.515]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:39.515]                         fi_tmp[["mtime"]])
[08:28:39.515]                     }
[08:28:39.515]                     tryCatch({
[08:28:39.515]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:39.515]                     }, error = function(ex) {
[08:28:39.515]                       msg <- conditionMessage(ex)
[08:28:39.515]                       fi_tmp <- file.info(pathname_tmp)
[08:28:39.515]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:39.515]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:39.515]                         fi_tmp[["mtime"]], msg)
[08:28:39.515]                       ex$message <- msg
[08:28:39.515]                       stop(ex)
[08:28:39.515]                     })
[08:28:39.515]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:39.515]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:39.515]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:39.515]                       fi_tmp <- file.info(pathname_tmp)
[08:28:39.515]                       fi <- file.info(pathname)
[08:28:39.515]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:39.515]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:39.515]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:39.515]                         fi[["size"]], fi[["mtime"]])
[08:28:39.515]                       stop(msg)
[08:28:39.515]                     }
[08:28:39.515]                     invisible(pathname)
[08:28:39.515]                   }
[08:28:39.515]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:39.515]                     rootPath = tempdir()) 
[08:28:39.515]                   {
[08:28:39.515]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:39.515]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:39.515]                       tmpdir = path, fileext = ".rds")
[08:28:39.515]                     save_rds(obj, file)
[08:28:39.515]                   }
[08:28:39.515]                   saveImmediateCondition(cond, path = "/tmp/RtmphjARvB/.future/immediateConditions")
[08:28:39.515]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:39.515]                   {
[08:28:39.515]                     inherits <- base::inherits
[08:28:39.515]                     invokeRestart <- base::invokeRestart
[08:28:39.515]                     is.null <- base::is.null
[08:28:39.515]                     muffled <- FALSE
[08:28:39.515]                     if (inherits(cond, "message")) {
[08:28:39.515]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:39.515]                       if (muffled) 
[08:28:39.515]                         invokeRestart("muffleMessage")
[08:28:39.515]                     }
[08:28:39.515]                     else if (inherits(cond, "warning")) {
[08:28:39.515]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:39.515]                       if (muffled) 
[08:28:39.515]                         invokeRestart("muffleWarning")
[08:28:39.515]                     }
[08:28:39.515]                     else if (inherits(cond, "condition")) {
[08:28:39.515]                       if (!is.null(pattern)) {
[08:28:39.515]                         computeRestarts <- base::computeRestarts
[08:28:39.515]                         grepl <- base::grepl
[08:28:39.515]                         restarts <- computeRestarts(cond)
[08:28:39.515]                         for (restart in restarts) {
[08:28:39.515]                           name <- restart$name
[08:28:39.515]                           if (is.null(name)) 
[08:28:39.515]                             next
[08:28:39.515]                           if (!grepl(pattern, name)) 
[08:28:39.515]                             next
[08:28:39.515]                           invokeRestart(restart)
[08:28:39.515]                           muffled <- TRUE
[08:28:39.515]                           break
[08:28:39.515]                         }
[08:28:39.515]                       }
[08:28:39.515]                     }
[08:28:39.515]                     invisible(muffled)
[08:28:39.515]                   }
[08:28:39.515]                   muffleCondition(cond)
[08:28:39.515]                 })
[08:28:39.515]             }))
[08:28:39.515]             future::FutureResult(value = ...future.value$value, 
[08:28:39.515]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:39.515]                   ...future.rng), globalenv = if (FALSE) 
[08:28:39.515]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:39.515]                     ...future.globalenv.names))
[08:28:39.515]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:39.515]         }, condition = base::local({
[08:28:39.515]             c <- base::c
[08:28:39.515]             inherits <- base::inherits
[08:28:39.515]             invokeRestart <- base::invokeRestart
[08:28:39.515]             length <- base::length
[08:28:39.515]             list <- base::list
[08:28:39.515]             seq.int <- base::seq.int
[08:28:39.515]             signalCondition <- base::signalCondition
[08:28:39.515]             sys.calls <- base::sys.calls
[08:28:39.515]             `[[` <- base::`[[`
[08:28:39.515]             `+` <- base::`+`
[08:28:39.515]             `<<-` <- base::`<<-`
[08:28:39.515]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:39.515]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:39.515]                   3L)]
[08:28:39.515]             }
[08:28:39.515]             function(cond) {
[08:28:39.515]                 is_error <- inherits(cond, "error")
[08:28:39.515]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:39.515]                   NULL)
[08:28:39.515]                 if (is_error) {
[08:28:39.515]                   sessionInformation <- function() {
[08:28:39.515]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:39.515]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:39.515]                       search = base::search(), system = base::Sys.info())
[08:28:39.515]                   }
[08:28:39.515]                   ...future.conditions[[length(...future.conditions) + 
[08:28:39.515]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:39.515]                     cond$call), session = sessionInformation(), 
[08:28:39.515]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:39.515]                   signalCondition(cond)
[08:28:39.515]                 }
[08:28:39.515]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:39.515]                 "immediateCondition"))) {
[08:28:39.515]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:39.515]                   ...future.conditions[[length(...future.conditions) + 
[08:28:39.515]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:39.515]                   if (TRUE && !signal) {
[08:28:39.515]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:39.515]                     {
[08:28:39.515]                       inherits <- base::inherits
[08:28:39.515]                       invokeRestart <- base::invokeRestart
[08:28:39.515]                       is.null <- base::is.null
[08:28:39.515]                       muffled <- FALSE
[08:28:39.515]                       if (inherits(cond, "message")) {
[08:28:39.515]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:39.515]                         if (muffled) 
[08:28:39.515]                           invokeRestart("muffleMessage")
[08:28:39.515]                       }
[08:28:39.515]                       else if (inherits(cond, "warning")) {
[08:28:39.515]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:39.515]                         if (muffled) 
[08:28:39.515]                           invokeRestart("muffleWarning")
[08:28:39.515]                       }
[08:28:39.515]                       else if (inherits(cond, "condition")) {
[08:28:39.515]                         if (!is.null(pattern)) {
[08:28:39.515]                           computeRestarts <- base::computeRestarts
[08:28:39.515]                           grepl <- base::grepl
[08:28:39.515]                           restarts <- computeRestarts(cond)
[08:28:39.515]                           for (restart in restarts) {
[08:28:39.515]                             name <- restart$name
[08:28:39.515]                             if (is.null(name)) 
[08:28:39.515]                               next
[08:28:39.515]                             if (!grepl(pattern, name)) 
[08:28:39.515]                               next
[08:28:39.515]                             invokeRestart(restart)
[08:28:39.515]                             muffled <- TRUE
[08:28:39.515]                             break
[08:28:39.515]                           }
[08:28:39.515]                         }
[08:28:39.515]                       }
[08:28:39.515]                       invisible(muffled)
[08:28:39.515]                     }
[08:28:39.515]                     muffleCondition(cond, pattern = "^muffle")
[08:28:39.515]                   }
[08:28:39.515]                 }
[08:28:39.515]                 else {
[08:28:39.515]                   if (TRUE) {
[08:28:39.515]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:39.515]                     {
[08:28:39.515]                       inherits <- base::inherits
[08:28:39.515]                       invokeRestart <- base::invokeRestart
[08:28:39.515]                       is.null <- base::is.null
[08:28:39.515]                       muffled <- FALSE
[08:28:39.515]                       if (inherits(cond, "message")) {
[08:28:39.515]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:39.515]                         if (muffled) 
[08:28:39.515]                           invokeRestart("muffleMessage")
[08:28:39.515]                       }
[08:28:39.515]                       else if (inherits(cond, "warning")) {
[08:28:39.515]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:39.515]                         if (muffled) 
[08:28:39.515]                           invokeRestart("muffleWarning")
[08:28:39.515]                       }
[08:28:39.515]                       else if (inherits(cond, "condition")) {
[08:28:39.515]                         if (!is.null(pattern)) {
[08:28:39.515]                           computeRestarts <- base::computeRestarts
[08:28:39.515]                           grepl <- base::grepl
[08:28:39.515]                           restarts <- computeRestarts(cond)
[08:28:39.515]                           for (restart in restarts) {
[08:28:39.515]                             name <- restart$name
[08:28:39.515]                             if (is.null(name)) 
[08:28:39.515]                               next
[08:28:39.515]                             if (!grepl(pattern, name)) 
[08:28:39.515]                               next
[08:28:39.515]                             invokeRestart(restart)
[08:28:39.515]                             muffled <- TRUE
[08:28:39.515]                             break
[08:28:39.515]                           }
[08:28:39.515]                         }
[08:28:39.515]                       }
[08:28:39.515]                       invisible(muffled)
[08:28:39.515]                     }
[08:28:39.515]                     muffleCondition(cond, pattern = "^muffle")
[08:28:39.515]                   }
[08:28:39.515]                 }
[08:28:39.515]             }
[08:28:39.515]         }))
[08:28:39.515]     }, error = function(ex) {
[08:28:39.515]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:39.515]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:39.515]                 ...future.rng), started = ...future.startTime, 
[08:28:39.515]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:39.515]             version = "1.8"), class = "FutureResult")
[08:28:39.515]     }, finally = {
[08:28:39.515]         if (!identical(...future.workdir, getwd())) 
[08:28:39.515]             setwd(...future.workdir)
[08:28:39.515]         {
[08:28:39.515]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:39.515]                 ...future.oldOptions$nwarnings <- NULL
[08:28:39.515]             }
[08:28:39.515]             base::options(...future.oldOptions)
[08:28:39.515]             if (.Platform$OS.type == "windows") {
[08:28:39.515]                 old_names <- names(...future.oldEnvVars)
[08:28:39.515]                 envs <- base::Sys.getenv()
[08:28:39.515]                 names <- names(envs)
[08:28:39.515]                 common <- intersect(names, old_names)
[08:28:39.515]                 added <- setdiff(names, old_names)
[08:28:39.515]                 removed <- setdiff(old_names, names)
[08:28:39.515]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:39.515]                   envs[common]]
[08:28:39.515]                 NAMES <- toupper(changed)
[08:28:39.515]                 args <- list()
[08:28:39.515]                 for (kk in seq_along(NAMES)) {
[08:28:39.515]                   name <- changed[[kk]]
[08:28:39.515]                   NAME <- NAMES[[kk]]
[08:28:39.515]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.515]                     next
[08:28:39.515]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:39.515]                 }
[08:28:39.515]                 NAMES <- toupper(added)
[08:28:39.515]                 for (kk in seq_along(NAMES)) {
[08:28:39.515]                   name <- added[[kk]]
[08:28:39.515]                   NAME <- NAMES[[kk]]
[08:28:39.515]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.515]                     next
[08:28:39.515]                   args[[name]] <- ""
[08:28:39.515]                 }
[08:28:39.515]                 NAMES <- toupper(removed)
[08:28:39.515]                 for (kk in seq_along(NAMES)) {
[08:28:39.515]                   name <- removed[[kk]]
[08:28:39.515]                   NAME <- NAMES[[kk]]
[08:28:39.515]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.515]                     next
[08:28:39.515]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:39.515]                 }
[08:28:39.515]                 if (length(args) > 0) 
[08:28:39.515]                   base::do.call(base::Sys.setenv, args = args)
[08:28:39.515]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:39.515]             }
[08:28:39.515]             else {
[08:28:39.515]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:39.515]             }
[08:28:39.515]             {
[08:28:39.515]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:39.515]                   0L) {
[08:28:39.515]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:39.515]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:39.515]                   base::options(opts)
[08:28:39.515]                 }
[08:28:39.515]                 {
[08:28:39.515]                   {
[08:28:39.515]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:39.515]                     NULL
[08:28:39.515]                   }
[08:28:39.515]                   options(future.plan = NULL)
[08:28:39.515]                   if (is.na(NA_character_)) 
[08:28:39.515]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:39.515]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:39.515]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:39.515]                     .init = FALSE)
[08:28:39.515]                 }
[08:28:39.515]             }
[08:28:39.515]         }
[08:28:39.515]     })
[08:28:39.515]     if (TRUE) {
[08:28:39.515]         base::sink(type = "output", split = FALSE)
[08:28:39.515]         if (TRUE) {
[08:28:39.515]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:39.515]         }
[08:28:39.515]         else {
[08:28:39.515]             ...future.result["stdout"] <- base::list(NULL)
[08:28:39.515]         }
[08:28:39.515]         base::close(...future.stdout)
[08:28:39.515]         ...future.stdout <- NULL
[08:28:39.515]     }
[08:28:39.515]     ...future.result$conditions <- ...future.conditions
[08:28:39.515]     ...future.result$finished <- base::Sys.time()
[08:28:39.515]     ...future.result
[08:28:39.515] }
[08:28:39.518] assign_globals() ...
[08:28:39.518] List of 2
[08:28:39.518]  $ nested   :List of 2
[08:28:39.518]   ..$ a:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[08:28:39.518]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[08:28:39.518]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[08:28:39.518]   ..$ b:function (..., envir = parent.frame())  
[08:28:39.518]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[08:28:39.518]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[08:28:39.518]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[08:28:39.518]  $ strategy2: chr "sequential"
[08:28:39.518]  - attr(*, "where")=List of 2
[08:28:39.518]   ..$ nested   :<environment: R_EmptyEnv> 
[08:28:39.518]   ..$ strategy2:<environment: R_EmptyEnv> 
[08:28:39.518]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:39.518]  - attr(*, "resolved")= logi FALSE
[08:28:39.518]  - attr(*, "total_size")= num 7973
[08:28:39.518]  - attr(*, "already-done")= logi TRUE
[08:28:39.523] - copied ‘nested’ to environment
[08:28:39.523] - copied ‘strategy2’ to environment
[08:28:39.523] assign_globals() ... done
[08:28:39.523] requestCore(): workers = 2
[08:28:39.526] MulticoreFuture started
[08:28:39.527] - Launch lazy future ... done
[08:28:39.527] run() for ‘MulticoreFuture’ ... done
[08:28:39.527] result() for MulticoreFuture ...
[08:28:39.528] plan(): Setting new future strategy stack:
[08:28:39.528] List of future strategies:
[08:28:39.528] 1. sequential:
[08:28:39.528]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:39.528]    - tweaked: FALSE
[08:28:39.528]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:39.529] plan(): nbrOfWorkers() = 1
[08:28:39.571] plan(): Setting new future strategy stack:
[08:28:39.571] List of future strategies:
[08:28:39.571] 1. multicore:
[08:28:39.571]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:39.571]    - tweaked: FALSE
[08:28:39.571]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:39.571] 2. sequential:
[08:28:39.571]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:39.571]    - tweaked: FALSE
[08:28:39.571]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:39.574] plan(): nbrOfWorkers() = 2
[08:28:39.575] result() for MulticoreFuture ...
[08:28:39.575] result() for MulticoreFuture ... done
[08:28:39.576] signalConditions() ...
[08:28:39.576]  - include = ‘immediateCondition’
[08:28:39.576]  - exclude = 
[08:28:39.576]  - resignal = FALSE
[08:28:39.576]  - Number of conditions: 54
[08:28:39.576] signalConditions() ... done
[08:28:39.576] result() for MulticoreFuture ... done
[08:28:39.576] result() for MulticoreFuture ...
[08:28:39.576] result() for MulticoreFuture ... done
[08:28:39.577] signalConditions() ...
[08:28:39.577]  - include = ‘immediateCondition’
[08:28:39.577]  - exclude = 
[08:28:39.577]  - resignal = FALSE
[08:28:39.577]  - Number of conditions: 54
[08:28:39.577] signalConditions() ... done
[08:28:39.577] Future state: ‘finished’
[08:28:39.577] result() for MulticoreFuture ...
[08:28:39.577] result() for MulticoreFuture ... done
[08:28:39.578] signalConditions() ...
[08:28:39.578]  - include = ‘condition’
[08:28:39.578]  - exclude = ‘immediateCondition’
[08:28:39.578]  - resignal = TRUE
[08:28:39.578]  - Number of conditions: 54
[08:28:39.578]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.531] getGlobalsAndPackages() ...
[08:28:39.578]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.531] Searching for globals...
[08:28:39.578]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.540] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[08:28:39.579]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.540] Searching for globals ... DONE
[08:28:39.579]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.540] Resolving globals: FALSE
[08:28:39.579]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.542] The total size of the 3 globals is 3.58 KiB (3661 bytes)
[08:28:39.579]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.542] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 3.58 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (1.77 KiB of class ‘list’), ‘plan_a’ (1.77 KiB of class ‘list’) and ‘a’ (35 bytes of class ‘numeric’)
[08:28:39.579]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.543] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[08:28:39.579]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.543] 
[08:28:39.579]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.543] getGlobalsAndPackages() ... DONE
[08:28:39.580]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.544] run() for ‘Future’ ...
[08:28:39.580]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.544] - state: ‘created’
[08:28:39.580]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.544] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:39.580]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.545] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:39.580]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.545] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:39.580]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.545]   - Field: ‘label’
[08:28:39.580]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.545]   - Field: ‘local’
[08:28:39.581]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.546]   - Field: ‘owner’
[08:28:39.581]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.546]   - Field: ‘envir’
[08:28:39.581]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.546]   - Field: ‘packages’
[08:28:39.581]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.546]   - Field: ‘gc’
[08:28:39.581]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.546]   - Field: ‘conditions’
[08:28:39.581]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.546]   - Field: ‘expr’
[08:28:39.581]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.546]   - Field: ‘uuid’
[08:28:39.582]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.547]   - Field: ‘seed’
[08:28:39.582]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.547]   - Field: ‘version’
[08:28:39.582]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.547]   - Field: ‘result’
[08:28:39.582]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.547]   - Field: ‘asynchronous’
[08:28:39.582]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.547]   - Field: ‘calls’
[08:28:39.582]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.547]   - Field: ‘globals’
[08:28:39.582]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.548]   - Field: ‘stdout’
[08:28:39.583]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.548]   - Field: ‘earlySignal’
[08:28:39.583]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.548]   - Field: ‘lazy’
[08:28:39.583]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.548]   - Field: ‘state’
[08:28:39.583]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.548] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:39.583]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.548] - Launch lazy future ...
[08:28:39.583]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.549] Packages needed by the future expression (n = 0): <none>
[08:28:39.583]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.549] Packages needed by future strategies (n = 0): <none>
[08:28:39.584]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.550] {
[08:28:39.550]     {
[08:28:39.550]         {
[08:28:39.550]             ...future.startTime <- base::Sys.time()
[08:28:39.550]             {
[08:28:39.550]                 {
[08:28:39.550]                   {
[08:28:39.550]                     base::local({
[08:28:39.550]                       has_future <- base::requireNamespace("future", 
[08:28:39.550]                         quietly = TRUE)
[08:28:39.550]                       if (has_future) {
[08:28:39.550]                         ns <- base::getNamespace("future")
[08:28:39.550]                         version <- ns[[".package"]][["version"]]
[08:28:39.550]                         if (is.null(version)) 
[08:28:39.550]                           version <- utils::packageVersion("future")
[08:28:39.550]                       }
[08:28:39.550]                       else {
[08:28:39.550]                         version <- NULL
[08:28:39.550]                       }
[08:28:39.550]                       if (!has_future || version < "1.8.0") {
[08:28:39.550]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:39.550]                           "", base::R.version$version.string), 
[08:28:39.550]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:39.550]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:39.550]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:39.550]                             "release", "version")], collapse = " "), 
[08:28:39.550]                           hostname = base::Sys.info()[["nodename"]])
[08:28:39.550]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:39.550]                           info)
[08:28:39.550]                         info <- base::paste(info, collapse = "; ")
[08:28:39.550]                         if (!has_future) {
[08:28:39.550]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:39.550]                             info)
[08:28:39.550]                         }
[08:28:39.550]                         else {
[08:28:39.550]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:39.550]                             info, version)
[08:28:39.550]                         }
[08:28:39.550]                         base::stop(msg)
[08:28:39.550]                       }
[08:28:39.550]                     })
[08:28:39.550]                   }
[08:28:39.550]                   ...future.strategy.old <- future::plan("list")
[08:28:39.550]                   options(future.plan = NULL)
[08:28:39.550]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:39.550]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:39.550]                 }
[08:28:39.550]                 ...future.workdir <- getwd()
[08:28:39.550]             }
[08:28:39.550]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:39.550]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:39.550]         }
[08:28:39.550]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:39.550]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:39.550]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:39.550]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:39.550]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:39.550]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:39.550]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:39.550]             base::names(...future.oldOptions))
[08:28:39.550]     }
[08:28:39.550]     if (FALSE) {
[08:28:39.550]     }
[08:28:39.550]     else {
[08:28:39.550]         if (TRUE) {
[08:28:39.550]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:39.550]                 open = "w")
[08:28:39.550]         }
[08:28:39.550]         else {
[08:28:39.550]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:39.550]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:39.550]         }
[08:28:39.550]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:39.550]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:39.550]             base::sink(type = "output", split = FALSE)
[08:28:39.550]             base::close(...future.stdout)
[08:28:39.550]         }, add = TRUE)
[08:28:39.550]     }
[08:28:39.550]     ...future.frame <- base::sys.nframe()
[08:28:39.550]     ...future.conditions <- base::list()
[08:28:39.550]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:39.550]     if (FALSE) {
[08:28:39.550]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:39.550]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:39.550]     }
[08:28:39.550]     ...future.result <- base::tryCatch({
[08:28:39.550]         base::withCallingHandlers({
[08:28:39.550]             ...future.value <- base::withVisible(base::local({
[08:28:39.550]                 b <- 2L
[08:28:39.550]                 plan_b <- future::plan("list")
[08:28:39.550]                 nested_b <- nested_a[-1]
[08:28:39.550]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[08:28:39.550]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[08:28:39.550]                   "sequential"))
[08:28:39.550]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[08:28:39.550]                   b = b, nested_b = nested_b, plan_b = plan_b)
[08:28:39.550]             }))
[08:28:39.550]             future::FutureResult(value = ...future.value$value, 
[08:28:39.550]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:39.550]                   ...future.rng), globalenv = if (FALSE) 
[08:28:39.550]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:39.550]                     ...future.globalenv.names))
[08:28:39.550]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:39.550]         }, condition = base::local({
[08:28:39.550]             c <- base::c
[08:28:39.550]             inherits <- base::inherits
[08:28:39.550]             invokeRestart <- base::invokeRestart
[08:28:39.550]             length <- base::length
[08:28:39.550]             list <- base::list
[08:28:39.550]             seq.int <- base::seq.int
[08:28:39.550]             signalCondition <- base::signalCondition
[08:28:39.550]             sys.calls <- base::sys.calls
[08:28:39.550]             `[[` <- base::`[[`
[08:28:39.550]             `+` <- base::`+`
[08:28:39.550]             `<<-` <- base::`<<-`
[08:28:39.550]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:39.550]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:39.550]                   3L)]
[08:28:39.550]             }
[08:28:39.550]             function(cond) {
[08:28:39.550]                 is_error <- inherits(cond, "error")
[08:28:39.550]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:39.550]                   NULL)
[08:28:39.550]                 if (is_error) {
[08:28:39.550]                   sessionInformation <- function() {
[08:28:39.550]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:39.550]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:39.550]                       search = base::search(), system = base::Sys.info())
[08:28:39.550]                   }
[08:28:39.550]                   ...future.conditions[[length(...future.conditions) + 
[08:28:39.550]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:39.550]                     cond$call), session = sessionInformation(), 
[08:28:39.550]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:39.550]                   signalCondition(cond)
[08:28:39.550]                 }
[08:28:39.550]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:39.550]                 "immediateCondition"))) {
[08:28:39.550]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:39.550]                   ...future.conditions[[length(...future.conditions) + 
[08:28:39.550]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:39.550]                   if (TRUE && !signal) {
[08:28:39.550]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:39.550]                     {
[08:28:39.550]                       inherits <- base::inherits
[08:28:39.550]                       invokeRestart <- base::invokeRestart
[08:28:39.550]                       is.null <- base::is.null
[08:28:39.550]                       muffled <- FALSE
[08:28:39.550]                       if (inherits(cond, "message")) {
[08:28:39.550]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:39.550]                         if (muffled) 
[08:28:39.550]                           invokeRestart("muffleMessage")
[08:28:39.550]                       }
[08:28:39.550]                       else if (inherits(cond, "warning")) {
[08:28:39.550]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:39.550]                         if (muffled) 
[08:28:39.550]                           invokeRestart("muffleWarning")
[08:28:39.550]                       }
[08:28:39.550]                       else if (inherits(cond, "condition")) {
[08:28:39.550]                         if (!is.null(pattern)) {
[08:28:39.550]                           computeRestarts <- base::computeRestarts
[08:28:39.550]                           grepl <- base::grepl
[08:28:39.550]                           restarts <- computeRestarts(cond)
[08:28:39.550]                           for (restart in restarts) {
[08:28:39.550]                             name <- restart$name
[08:28:39.550]                             if (is.null(name)) 
[08:28:39.550]                               next
[08:28:39.550]                             if (!grepl(pattern, name)) 
[08:28:39.550]                               next
[08:28:39.550]                             invokeRestart(restart)
[08:28:39.550]                             muffled <- TRUE
[08:28:39.550]                             break
[08:28:39.550]                           }
[08:28:39.550]                         }
[08:28:39.550]                       }
[08:28:39.550]                       invisible(muffled)
[08:28:39.550]                     }
[08:28:39.550]                     muffleCondition(cond, pattern = "^muffle")
[08:28:39.550]                   }
[08:28:39.550]                 }
[08:28:39.550]                 else {
[08:28:39.550]                   if (TRUE) {
[08:28:39.550]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:39.550]                     {
[08:28:39.550]                       inherits <- base::inherits
[08:28:39.550]                       invokeRestart <- base::invokeRestart
[08:28:39.550]                       is.null <- base::is.null
[08:28:39.550]                       muffled <- FALSE
[08:28:39.550]                       if (inherits(cond, "message")) {
[08:28:39.550]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:39.550]                         if (muffled) 
[08:28:39.550]                           invokeRestart("muffleMessage")
[08:28:39.550]                       }
[08:28:39.550]                       else if (inherits(cond, "warning")) {
[08:28:39.550]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:39.550]                         if (muffled) 
[08:28:39.550]                           invokeRestart("muffleWarning")
[08:28:39.550]                       }
[08:28:39.550]                       else if (inherits(cond, "condition")) {
[08:28:39.550]                         if (!is.null(pattern)) {
[08:28:39.550]                           computeRestarts <- base::computeRestarts
[08:28:39.550]                           grepl <- base::grepl
[08:28:39.550]                           restarts <- computeRestarts(cond)
[08:28:39.550]                           for (restart in restarts) {
[08:28:39.550]                             name <- restart$name
[08:28:39.550]                             if (is.null(name)) 
[08:28:39.550]                               next
[08:28:39.550]                             if (!grepl(pattern, name)) 
[08:28:39.550]                               next
[08:28:39.550]                             invokeRestart(restart)
[08:28:39.550]                             muffled <- TRUE
[08:28:39.550]                             break
[08:28:39.550]                           }
[08:28:39.550]                         }
[08:28:39.550]                       }
[08:28:39.550]                       invisible(muffled)
[08:28:39.550]                     }
[08:28:39.550]                     muffleCondition(cond, pattern = "^muffle")
[08:28:39.550]                   }
[08:28:39.550]                 }
[08:28:39.550]             }
[08:28:39.550]         }))
[08:28:39.550]     }, error = function(ex) {
[08:28:39.550]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:39.550]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:39.550]                 ...future.rng), started = ...future.startTime, 
[08:28:39.550]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:39.550]             version = "1.8"), class = "FutureResult")
[08:28:39.550]     }, finally = {
[08:28:39.550]         if (!identical(...future.workdir, getwd())) 
[08:28:39.550]             setwd(...future.workdir)
[08:28:39.550]         {
[08:28:39.550]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:39.550]                 ...future.oldOptions$nwarnings <- NULL
[08:28:39.550]             }
[08:28:39.550]             base::options(...future.oldOptions)
[08:28:39.550]             if (.Platform$OS.type == "windows") {
[08:28:39.550]                 old_names <- names(...future.oldEnvVars)
[08:28:39.550]                 envs <- base::Sys.getenv()
[08:28:39.550]                 names <- names(envs)
[08:28:39.550]                 common <- intersect(names, old_names)
[08:28:39.550]                 added <- setdiff(names, old_names)
[08:28:39.550]                 removed <- setdiff(old_names, names)
[08:28:39.550]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:39.550]                   envs[common]]
[08:28:39.550]                 NAMES <- toupper(changed)
[08:28:39.550]                 args <- list()
[08:28:39.550]                 for (kk in seq_along(NAMES)) {
[08:28:39.550]                   name <- changed[[kk]]
[08:28:39.550]                   NAME <- NAMES[[kk]]
[08:28:39.550]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.550]                     next
[08:28:39.550]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:39.550]                 }
[08:28:39.550]                 NAMES <- toupper(added)
[08:28:39.550]                 for (kk in seq_along(NAMES)) {
[08:28:39.550]                   name <- added[[kk]]
[08:28:39.550]                   NAME <- NAMES[[kk]]
[08:28:39.550]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.550]                     next
[08:28:39.550]                   args[[name]] <- ""
[08:28:39.550]                 }
[08:28:39.550]                 NAMES <- toupper(removed)
[08:28:39.550]                 for (kk in seq_along(NAMES)) {
[08:28:39.550]                   name <- removed[[kk]]
[08:28:39.550]                   NAME <- NAMES[[kk]]
[08:28:39.550]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.550]                     next
[08:28:39.550]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:39.550]                 }
[08:28:39.550]                 if (length(args) > 0) 
[08:28:39.550]                   base::do.call(base::Sys.setenv, args = args)
[08:28:39.550]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:39.550]             }
[08:28:39.550]             else {
[08:28:39.550]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:39.550]             }
[08:28:39.550]             {
[08:28:39.550]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:39.550]                   0L) {
[08:28:39.550]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:39.550]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:39.550]                   base::options(opts)
[08:28:39.550]                 }
[08:28:39.550]                 {
[08:28:39.550]                   {
[08:28:39.550]                     NULL
[08:28:39.550]                     RNGkind("Mersenne-Twister")
[08:28:39.550]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:39.550]                       inherits = FALSE)
[08:28:39.550]                   }
[08:28:39.550]                   options(future.plan = NULL)
[08:28:39.550]                   if (is.na(NA_character_)) 
[08:28:39.550]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:39.550]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:39.550]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:39.550]                     .init = FALSE)
[08:28:39.550]                 }
[08:28:39.550]             }
[08:28:39.550]         }
[08:28:39.550]     })
[08:28:39.550]     if (TRUE) {
[08:28:39.550]         base::sink(type = "output", split = FALSE)
[08:28:39.550]         if (TRUE) {
[08:28:39.550]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:39.550]         }
[08:28:39.550]         else {
[08:28:39.550]             ...future.result["stdout"] <- base::list(NULL)
[08:28:39.550]         }
[08:28:39.550]         base::close(...future.stdout)
[08:28:39.550]         ...future.stdout <- NULL
[08:28:39.550]     }
[08:28:39.550]     ...future.result$conditions <- ...future.conditions
[08:28:39.550]     ...future.result$finished <- base::Sys.time()
[08:28:39.550]     ...future.result
[08:28:39.550] }
[08:28:39.584]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.552] assign_globals() ...
[08:28:39.584]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.552] List of 3
[08:28:39.552]  $ nested_a:List of 1
[08:28:39.552]   ..$ b:function (..., envir = parent.frame())  
[08:28:39.552]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[08:28:39.552]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[08:28:39.552]  $ a       : int 1
[08:28:39.552]  $ plan_a  :List of 1
[08:28:39.552]   ..$ b:function (..., envir = parent.frame())  
[08:28:39.552]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[08:28:39.552]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[08:28:39.552]  - attr(*, "where")=List of 3
[08:28:39.552]   ..$ nested_a:<environment: R_EmptyEnv> 
[08:28:39.552]   ..$ a       :<environment: R_EmptyEnv> 
[08:28:39.552]   ..$ plan_a  :<environment: R_EmptyEnv> 
[08:28:39.552]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:39.552]  - attr(*, "resolved")= logi FALSE
[08:28:39.552]  - attr(*, "total_size")= num 3661
[08:28:39.552]  - attr(*, "already-done")= logi TRUE
[08:28:39.584]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.566] - copied ‘nested_a’ to environment
[08:28:39.584]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.566] - copied ‘a’ to environment
[08:28:39.585]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.566] - copied ‘plan_a’ to environment
[08:28:39.585]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.566] assign_globals() ... done
[08:28:39.585]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.567] plan(): Setting new future strategy stack:
[08:28:39.585]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.567] List of future strategies:
[08:28:39.567] 1. sequential:
[08:28:39.567]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:39.567]    - tweaked: FALSE
[08:28:39.567]    - call: NULL
[08:28:39.585]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.567] plan(): nbrOfWorkers() = 1
[08:28:39.585]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.569] plan(): Setting new future strategy stack:
[08:28:39.585]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.569] List of future strategies:
[08:28:39.569] 1. sequential:
[08:28:39.569]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:39.569]    - tweaked: FALSE
[08:28:39.569]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:39.585]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.570] plan(): nbrOfWorkers() = 1
[08:28:39.586]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.570] SequentialFuture started (and completed)
[08:28:39.586]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.570] - Launch lazy future ... done
[08:28:39.586]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.570] run() for ‘SequentialFuture’ ... done
[08:28:39.586] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[08:28:39.596] getGlobalsAndPackages() ...
[08:28:39.596] Searching for globals...
[08:28:39.598] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[08:28:39.598] Searching for globals ... DONE
[08:28:39.598] Resolving globals: FALSE
[08:28:39.599] The total size of the 1 globals is 356 bytes (356 bytes)
[08:28:39.599] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[08:28:39.599] - globals: [1] ‘data’
[08:28:39.599] - packages: [1] ‘future’
[08:28:39.600] getGlobalsAndPackages() ... DONE
[08:28:39.600] run() for ‘Future’ ...
[08:28:39.600] - state: ‘created’
[08:28:39.600] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:39.602] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:39.602] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:39.603]   - Field: ‘label’
[08:28:39.603]   - Field: ‘local’
[08:28:39.603]   - Field: ‘owner’
[08:28:39.603]   - Field: ‘envir’
[08:28:39.603]   - Field: ‘workers’
[08:28:39.603]   - Field: ‘packages’
[08:28:39.604]   - Field: ‘gc’
[08:28:39.604]   - Field: ‘job’
[08:28:39.604]   - Field: ‘conditions’
[08:28:39.604]   - Field: ‘expr’
[08:28:39.604]   - Field: ‘uuid’
[08:28:39.605]   - Field: ‘seed’
[08:28:39.605]   - Field: ‘version’
[08:28:39.605]   - Field: ‘result’
[08:28:39.605]   - Field: ‘asynchronous’
[08:28:39.605]   - Field: ‘calls’
[08:28:39.606]   - Field: ‘globals’
[08:28:39.606]   - Field: ‘stdout’
[08:28:39.606]   - Field: ‘earlySignal’
[08:28:39.606]   - Field: ‘lazy’
[08:28:39.606]   - Field: ‘state’
[08:28:39.607] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:39.607] - Launch lazy future ...
[08:28:39.607] Packages needed by the future expression (n = 1): ‘future’
[08:28:39.607] Packages needed by future strategies (n = 1): ‘future’
[08:28:39.608] {
[08:28:39.608]     {
[08:28:39.608]         {
[08:28:39.608]             ...future.startTime <- base::Sys.time()
[08:28:39.608]             {
[08:28:39.608]                 {
[08:28:39.608]                   {
[08:28:39.608]                     {
[08:28:39.608]                       {
[08:28:39.608]                         base::local({
[08:28:39.608]                           has_future <- base::requireNamespace("future", 
[08:28:39.608]                             quietly = TRUE)
[08:28:39.608]                           if (has_future) {
[08:28:39.608]                             ns <- base::getNamespace("future")
[08:28:39.608]                             version <- ns[[".package"]][["version"]]
[08:28:39.608]                             if (is.null(version)) 
[08:28:39.608]                               version <- utils::packageVersion("future")
[08:28:39.608]                           }
[08:28:39.608]                           else {
[08:28:39.608]                             version <- NULL
[08:28:39.608]                           }
[08:28:39.608]                           if (!has_future || version < "1.8.0") {
[08:28:39.608]                             info <- base::c(r_version = base::gsub("R version ", 
[08:28:39.608]                               "", base::R.version$version.string), 
[08:28:39.608]                               platform = base::sprintf("%s (%s-bit)", 
[08:28:39.608]                                 base::R.version$platform, 8 * 
[08:28:39.608]                                   base::.Machine$sizeof.pointer), 
[08:28:39.608]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:39.608]                                 "release", "version")], collapse = " "), 
[08:28:39.608]                               hostname = base::Sys.info()[["nodename"]])
[08:28:39.608]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:28:39.608]                               info)
[08:28:39.608]                             info <- base::paste(info, collapse = "; ")
[08:28:39.608]                             if (!has_future) {
[08:28:39.608]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:39.608]                                 info)
[08:28:39.608]                             }
[08:28:39.608]                             else {
[08:28:39.608]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:39.608]                                 info, version)
[08:28:39.608]                             }
[08:28:39.608]                             base::stop(msg)
[08:28:39.608]                           }
[08:28:39.608]                         })
[08:28:39.608]                       }
[08:28:39.608]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:39.608]                       base::options(mc.cores = 1L)
[08:28:39.608]                     }
[08:28:39.608]                     base::local({
[08:28:39.608]                       for (pkg in "future") {
[08:28:39.608]                         base::loadNamespace(pkg)
[08:28:39.608]                         base::library(pkg, character.only = TRUE)
[08:28:39.608]                       }
[08:28:39.608]                     })
[08:28:39.608]                   }
[08:28:39.608]                   ...future.strategy.old <- future::plan("list")
[08:28:39.608]                   options(future.plan = NULL)
[08:28:39.608]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:39.608]                   future::plan(list(b = function (..., envir = parent.frame()) 
[08:28:39.608]                   {
[08:28:39.608]                     future <- SequentialFuture(..., envir = envir)
[08:28:39.608]                     if (!future$lazy) 
[08:28:39.608]                       future <- run(future)
[08:28:39.608]                     invisible(future)
[08:28:39.608]                   }), .cleanup = FALSE, .init = FALSE)
[08:28:39.608]                 }
[08:28:39.608]                 ...future.workdir <- getwd()
[08:28:39.608]             }
[08:28:39.608]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:39.608]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:39.608]         }
[08:28:39.608]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:39.608]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:39.608]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:39.608]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:39.608]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:39.608]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:39.608]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:39.608]             base::names(...future.oldOptions))
[08:28:39.608]     }
[08:28:39.608]     if (FALSE) {
[08:28:39.608]     }
[08:28:39.608]     else {
[08:28:39.608]         if (TRUE) {
[08:28:39.608]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:39.608]                 open = "w")
[08:28:39.608]         }
[08:28:39.608]         else {
[08:28:39.608]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:39.608]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:39.608]         }
[08:28:39.608]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:39.608]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:39.608]             base::sink(type = "output", split = FALSE)
[08:28:39.608]             base::close(...future.stdout)
[08:28:39.608]         }, add = TRUE)
[08:28:39.608]     }
[08:28:39.608]     ...future.frame <- base::sys.nframe()
[08:28:39.608]     ...future.conditions <- base::list()
[08:28:39.608]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:39.608]     if (FALSE) {
[08:28:39.608]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:39.608]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:39.608]     }
[08:28:39.608]     ...future.result <- base::tryCatch({
[08:28:39.608]         base::withCallingHandlers({
[08:28:39.608]             ...future.value <- base::withVisible(base::local({
[08:28:39.608]                 withCallingHandlers({
[08:28:39.608]                   {
[08:28:39.608]                     value(future(subset(data, a == 2)))
[08:28:39.608]                   }
[08:28:39.608]                 }, immediateCondition = function(cond) {
[08:28:39.608]                   save_rds <- function (object, pathname, ...) 
[08:28:39.608]                   {
[08:28:39.608]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:39.608]                     if (file_test("-f", pathname_tmp)) {
[08:28:39.608]                       fi_tmp <- file.info(pathname_tmp)
[08:28:39.608]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:39.608]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:39.608]                         fi_tmp[["mtime"]])
[08:28:39.608]                     }
[08:28:39.608]                     tryCatch({
[08:28:39.608]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:39.608]                     }, error = function(ex) {
[08:28:39.608]                       msg <- conditionMessage(ex)
[08:28:39.608]                       fi_tmp <- file.info(pathname_tmp)
[08:28:39.608]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:39.608]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:39.608]                         fi_tmp[["mtime"]], msg)
[08:28:39.608]                       ex$message <- msg
[08:28:39.608]                       stop(ex)
[08:28:39.608]                     })
[08:28:39.608]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:39.608]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:39.608]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:39.608]                       fi_tmp <- file.info(pathname_tmp)
[08:28:39.608]                       fi <- file.info(pathname)
[08:28:39.608]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:39.608]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:39.608]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:39.608]                         fi[["size"]], fi[["mtime"]])
[08:28:39.608]                       stop(msg)
[08:28:39.608]                     }
[08:28:39.608]                     invisible(pathname)
[08:28:39.608]                   }
[08:28:39.608]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:39.608]                     rootPath = tempdir()) 
[08:28:39.608]                   {
[08:28:39.608]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:39.608]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:39.608]                       tmpdir = path, fileext = ".rds")
[08:28:39.608]                     save_rds(obj, file)
[08:28:39.608]                   }
[08:28:39.608]                   saveImmediateCondition(cond, path = "/tmp/RtmphjARvB/.future/immediateConditions")
[08:28:39.608]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:39.608]                   {
[08:28:39.608]                     inherits <- base::inherits
[08:28:39.608]                     invokeRestart <- base::invokeRestart
[08:28:39.608]                     is.null <- base::is.null
[08:28:39.608]                     muffled <- FALSE
[08:28:39.608]                     if (inherits(cond, "message")) {
[08:28:39.608]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:39.608]                       if (muffled) 
[08:28:39.608]                         invokeRestart("muffleMessage")
[08:28:39.608]                     }
[08:28:39.608]                     else if (inherits(cond, "warning")) {
[08:28:39.608]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:39.608]                       if (muffled) 
[08:28:39.608]                         invokeRestart("muffleWarning")
[08:28:39.608]                     }
[08:28:39.608]                     else if (inherits(cond, "condition")) {
[08:28:39.608]                       if (!is.null(pattern)) {
[08:28:39.608]                         computeRestarts <- base::computeRestarts
[08:28:39.608]                         grepl <- base::grepl
[08:28:39.608]                         restarts <- computeRestarts(cond)
[08:28:39.608]                         for (restart in restarts) {
[08:28:39.608]                           name <- restart$name
[08:28:39.608]                           if (is.null(name)) 
[08:28:39.608]                             next
[08:28:39.608]                           if (!grepl(pattern, name)) 
[08:28:39.608]                             next
[08:28:39.608]                           invokeRestart(restart)
[08:28:39.608]                           muffled <- TRUE
[08:28:39.608]                           break
[08:28:39.608]                         }
[08:28:39.608]                       }
[08:28:39.608]                     }
[08:28:39.608]                     invisible(muffled)
[08:28:39.608]                   }
[08:28:39.608]                   muffleCondition(cond)
[08:28:39.608]                 })
[08:28:39.608]             }))
[08:28:39.608]             future::FutureResult(value = ...future.value$value, 
[08:28:39.608]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:39.608]                   ...future.rng), globalenv = if (FALSE) 
[08:28:39.608]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:39.608]                     ...future.globalenv.names))
[08:28:39.608]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:39.608]         }, condition = base::local({
[08:28:39.608]             c <- base::c
[08:28:39.608]             inherits <- base::inherits
[08:28:39.608]             invokeRestart <- base::invokeRestart
[08:28:39.608]             length <- base::length
[08:28:39.608]             list <- base::list
[08:28:39.608]             seq.int <- base::seq.int
[08:28:39.608]             signalCondition <- base::signalCondition
[08:28:39.608]             sys.calls <- base::sys.calls
[08:28:39.608]             `[[` <- base::`[[`
[08:28:39.608]             `+` <- base::`+`
[08:28:39.608]             `<<-` <- base::`<<-`
[08:28:39.608]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:39.608]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:39.608]                   3L)]
[08:28:39.608]             }
[08:28:39.608]             function(cond) {
[08:28:39.608]                 is_error <- inherits(cond, "error")
[08:28:39.608]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:39.608]                   NULL)
[08:28:39.608]                 if (is_error) {
[08:28:39.608]                   sessionInformation <- function() {
[08:28:39.608]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:39.608]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:39.608]                       search = base::search(), system = base::Sys.info())
[08:28:39.608]                   }
[08:28:39.608]                   ...future.conditions[[length(...future.conditions) + 
[08:28:39.608]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:39.608]                     cond$call), session = sessionInformation(), 
[08:28:39.608]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:39.608]                   signalCondition(cond)
[08:28:39.608]                 }
[08:28:39.608]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:39.608]                 "immediateCondition"))) {
[08:28:39.608]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:39.608]                   ...future.conditions[[length(...future.conditions) + 
[08:28:39.608]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:39.608]                   if (TRUE && !signal) {
[08:28:39.608]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:39.608]                     {
[08:28:39.608]                       inherits <- base::inherits
[08:28:39.608]                       invokeRestart <- base::invokeRestart
[08:28:39.608]                       is.null <- base::is.null
[08:28:39.608]                       muffled <- FALSE
[08:28:39.608]                       if (inherits(cond, "message")) {
[08:28:39.608]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:39.608]                         if (muffled) 
[08:28:39.608]                           invokeRestart("muffleMessage")
[08:28:39.608]                       }
[08:28:39.608]                       else if (inherits(cond, "warning")) {
[08:28:39.608]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:39.608]                         if (muffled) 
[08:28:39.608]                           invokeRestart("muffleWarning")
[08:28:39.608]                       }
[08:28:39.608]                       else if (inherits(cond, "condition")) {
[08:28:39.608]                         if (!is.null(pattern)) {
[08:28:39.608]                           computeRestarts <- base::computeRestarts
[08:28:39.608]                           grepl <- base::grepl
[08:28:39.608]                           restarts <- computeRestarts(cond)
[08:28:39.608]                           for (restart in restarts) {
[08:28:39.608]                             name <- restart$name
[08:28:39.608]                             if (is.null(name)) 
[08:28:39.608]                               next
[08:28:39.608]                             if (!grepl(pattern, name)) 
[08:28:39.608]                               next
[08:28:39.608]                             invokeRestart(restart)
[08:28:39.608]                             muffled <- TRUE
[08:28:39.608]                             break
[08:28:39.608]                           }
[08:28:39.608]                         }
[08:28:39.608]                       }
[08:28:39.608]                       invisible(muffled)
[08:28:39.608]                     }
[08:28:39.608]                     muffleCondition(cond, pattern = "^muffle")
[08:28:39.608]                   }
[08:28:39.608]                 }
[08:28:39.608]                 else {
[08:28:39.608]                   if (TRUE) {
[08:28:39.608]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:39.608]                     {
[08:28:39.608]                       inherits <- base::inherits
[08:28:39.608]                       invokeRestart <- base::invokeRestart
[08:28:39.608]                       is.null <- base::is.null
[08:28:39.608]                       muffled <- FALSE
[08:28:39.608]                       if (inherits(cond, "message")) {
[08:28:39.608]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:39.608]                         if (muffled) 
[08:28:39.608]                           invokeRestart("muffleMessage")
[08:28:39.608]                       }
[08:28:39.608]                       else if (inherits(cond, "warning")) {
[08:28:39.608]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:39.608]                         if (muffled) 
[08:28:39.608]                           invokeRestart("muffleWarning")
[08:28:39.608]                       }
[08:28:39.608]                       else if (inherits(cond, "condition")) {
[08:28:39.608]                         if (!is.null(pattern)) {
[08:28:39.608]                           computeRestarts <- base::computeRestarts
[08:28:39.608]                           grepl <- base::grepl
[08:28:39.608]                           restarts <- computeRestarts(cond)
[08:28:39.608]                           for (restart in restarts) {
[08:28:39.608]                             name <- restart$name
[08:28:39.608]                             if (is.null(name)) 
[08:28:39.608]                               next
[08:28:39.608]                             if (!grepl(pattern, name)) 
[08:28:39.608]                               next
[08:28:39.608]                             invokeRestart(restart)
[08:28:39.608]                             muffled <- TRUE
[08:28:39.608]                             break
[08:28:39.608]                           }
[08:28:39.608]                         }
[08:28:39.608]                       }
[08:28:39.608]                       invisible(muffled)
[08:28:39.608]                     }
[08:28:39.608]                     muffleCondition(cond, pattern = "^muffle")
[08:28:39.608]                   }
[08:28:39.608]                 }
[08:28:39.608]             }
[08:28:39.608]         }))
[08:28:39.608]     }, error = function(ex) {
[08:28:39.608]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:39.608]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:39.608]                 ...future.rng), started = ...future.startTime, 
[08:28:39.608]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:39.608]             version = "1.8"), class = "FutureResult")
[08:28:39.608]     }, finally = {
[08:28:39.608]         if (!identical(...future.workdir, getwd())) 
[08:28:39.608]             setwd(...future.workdir)
[08:28:39.608]         {
[08:28:39.608]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:39.608]                 ...future.oldOptions$nwarnings <- NULL
[08:28:39.608]             }
[08:28:39.608]             base::options(...future.oldOptions)
[08:28:39.608]             if (.Platform$OS.type == "windows") {
[08:28:39.608]                 old_names <- names(...future.oldEnvVars)
[08:28:39.608]                 envs <- base::Sys.getenv()
[08:28:39.608]                 names <- names(envs)
[08:28:39.608]                 common <- intersect(names, old_names)
[08:28:39.608]                 added <- setdiff(names, old_names)
[08:28:39.608]                 removed <- setdiff(old_names, names)
[08:28:39.608]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:39.608]                   envs[common]]
[08:28:39.608]                 NAMES <- toupper(changed)
[08:28:39.608]                 args <- list()
[08:28:39.608]                 for (kk in seq_along(NAMES)) {
[08:28:39.608]                   name <- changed[[kk]]
[08:28:39.608]                   NAME <- NAMES[[kk]]
[08:28:39.608]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.608]                     next
[08:28:39.608]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:39.608]                 }
[08:28:39.608]                 NAMES <- toupper(added)
[08:28:39.608]                 for (kk in seq_along(NAMES)) {
[08:28:39.608]                   name <- added[[kk]]
[08:28:39.608]                   NAME <- NAMES[[kk]]
[08:28:39.608]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.608]                     next
[08:28:39.608]                   args[[name]] <- ""
[08:28:39.608]                 }
[08:28:39.608]                 NAMES <- toupper(removed)
[08:28:39.608]                 for (kk in seq_along(NAMES)) {
[08:28:39.608]                   name <- removed[[kk]]
[08:28:39.608]                   NAME <- NAMES[[kk]]
[08:28:39.608]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.608]                     next
[08:28:39.608]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:39.608]                 }
[08:28:39.608]                 if (length(args) > 0) 
[08:28:39.608]                   base::do.call(base::Sys.setenv, args = args)
[08:28:39.608]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:39.608]             }
[08:28:39.608]             else {
[08:28:39.608]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:39.608]             }
[08:28:39.608]             {
[08:28:39.608]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:39.608]                   0L) {
[08:28:39.608]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:39.608]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:39.608]                   base::options(opts)
[08:28:39.608]                 }
[08:28:39.608]                 {
[08:28:39.608]                   {
[08:28:39.608]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:39.608]                     NULL
[08:28:39.608]                   }
[08:28:39.608]                   options(future.plan = NULL)
[08:28:39.608]                   if (is.na(NA_character_)) 
[08:28:39.608]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:39.608]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:39.608]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:39.608]                     .init = FALSE)
[08:28:39.608]                 }
[08:28:39.608]             }
[08:28:39.608]         }
[08:28:39.608]     })
[08:28:39.608]     if (TRUE) {
[08:28:39.608]         base::sink(type = "output", split = FALSE)
[08:28:39.608]         if (TRUE) {
[08:28:39.608]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:39.608]         }
[08:28:39.608]         else {
[08:28:39.608]             ...future.result["stdout"] <- base::list(NULL)
[08:28:39.608]         }
[08:28:39.608]         base::close(...future.stdout)
[08:28:39.608]         ...future.stdout <- NULL
[08:28:39.608]     }
[08:28:39.608]     ...future.result$conditions <- ...future.conditions
[08:28:39.608]     ...future.result$finished <- base::Sys.time()
[08:28:39.608]     ...future.result
[08:28:39.608] }
[08:28:39.611] assign_globals() ...
[08:28:39.611] List of 1
[08:28:39.611]  $ data:'data.frame':	3 obs. of  2 variables:
[08:28:39.611]   ..$ a: int [1:3] 1 2 3
[08:28:39.611]   ..$ b: int [1:3] 3 2 1
[08:28:39.611]  - attr(*, "where")=List of 1
[08:28:39.611]   ..$ data:<environment: R_EmptyEnv> 
[08:28:39.611]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:39.611]  - attr(*, "resolved")= logi FALSE
[08:28:39.611]  - attr(*, "total_size")= num 356
[08:28:39.611]  - attr(*, "already-done")= logi TRUE
[08:28:39.615] - copied ‘data’ to environment
[08:28:39.616] assign_globals() ... done
[08:28:39.616] requestCore(): workers = 2
[08:28:39.620] MulticoreFuture started
[08:28:39.621] - Launch lazy future ... done
[08:28:39.621] run() for ‘MulticoreFuture’ ... done
[08:28:39.621] result() for MulticoreFuture ...
[08:28:39.622] plan(): Setting new future strategy stack:
[08:28:39.622] List of future strategies:
[08:28:39.622] 1. sequential:
[08:28:39.622]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:39.622]    - tweaked: FALSE
[08:28:39.622]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:39.624] plan(): nbrOfWorkers() = 1
[08:28:39.655] plan(): Setting new future strategy stack:
[08:28:39.655] List of future strategies:
[08:28:39.655] 1. multicore:
[08:28:39.655]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:39.655]    - tweaked: FALSE
[08:28:39.655]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:39.655] 2. sequential:
[08:28:39.655]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:39.655]    - tweaked: FALSE
[08:28:39.655]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:39.658] plan(): nbrOfWorkers() = 2
[08:28:39.659] result() for MulticoreFuture ...
[08:28:39.659] result() for MulticoreFuture ... done
[08:28:39.659] signalConditions() ...
[08:28:39.660]  - include = ‘immediateCondition’
[08:28:39.660]  - exclude = 
[08:28:39.660]  - resignal = FALSE
[08:28:39.660]  - Number of conditions: 52
[08:28:39.660] signalConditions() ... done
[08:28:39.660] result() for MulticoreFuture ... done
[08:28:39.661] result() for MulticoreFuture ...
[08:28:39.661] result() for MulticoreFuture ... done
[08:28:39.661] signalConditions() ...
[08:28:39.661]  - include = ‘immediateCondition’
[08:28:39.661]  - exclude = 
[08:28:39.661]  - resignal = FALSE
[08:28:39.662]  - Number of conditions: 52
[08:28:39.662] signalConditions() ... done
[08:28:39.662] Future state: ‘finished’
[08:28:39.662] result() for MulticoreFuture ...
[08:28:39.662] result() for MulticoreFuture ... done
[08:28:39.662] signalConditions() ...
[08:28:39.663]  - include = ‘condition’
[08:28:39.663]  - exclude = ‘immediateCondition’
[08:28:39.663]  - resignal = TRUE
[08:28:39.663]  - Number of conditions: 52
[08:28:39.663]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.625] getGlobalsAndPackages() ...
[08:28:39.663]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.626] Searching for globals...
[08:28:39.664]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.629] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[08:28:39.664]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.629] Searching for globals ... DONE
[08:28:39.664]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.630] Resolving globals: FALSE
[08:28:39.664]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.631] The total size of the 1 globals is 356 bytes (356 bytes)
[08:28:39.665]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.632] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[08:28:39.665]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.632] - globals: [1] ‘data’
[08:28:39.665]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.633] 
[08:28:39.665]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.633] getGlobalsAndPackages() ... DONE
[08:28:39.665]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.634] run() for ‘Future’ ...
[08:28:39.666]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.634] - state: ‘created’
[08:28:39.666]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.634] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:39.666]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.635] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:39.666]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.635] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:39.666]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.635]   - Field: ‘label’
[08:28:39.666]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.635]   - Field: ‘local’
[08:28:39.667]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.635]   - Field: ‘owner’
[08:28:39.667]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.636]   - Field: ‘envir’
[08:28:39.667]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.636]   - Field: ‘packages’
[08:28:39.667]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.636]   - Field: ‘gc’
[08:28:39.667]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.636]   - Field: ‘conditions’
[08:28:39.667]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.636]   - Field: ‘expr’
[08:28:39.668]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.637]   - Field: ‘uuid’
[08:28:39.668]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.637]   - Field: ‘seed’
[08:28:39.668]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.637]   - Field: ‘version’
[08:28:39.668]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.637]   - Field: ‘result’
[08:28:39.668]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.637]   - Field: ‘asynchronous’
[08:28:39.668]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.638]   - Field: ‘calls’
[08:28:39.669]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.638]   - Field: ‘globals’
[08:28:39.669]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.638]   - Field: ‘stdout’
[08:28:39.669]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.638]   - Field: ‘earlySignal’
[08:28:39.669]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.639]   - Field: ‘lazy’
[08:28:39.669]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.639]   - Field: ‘state’
[08:28:39.669]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.639] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:39.670]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.639] - Launch lazy future ...
[08:28:39.670]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.640] Packages needed by the future expression (n = 0): <none>
[08:28:39.670]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.640] Packages needed by future strategies (n = 0): <none>
[08:28:39.670]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.641] {
[08:28:39.641]     {
[08:28:39.641]         {
[08:28:39.641]             ...future.startTime <- base::Sys.time()
[08:28:39.641]             {
[08:28:39.641]                 {
[08:28:39.641]                   {
[08:28:39.641]                     base::local({
[08:28:39.641]                       has_future <- base::requireNamespace("future", 
[08:28:39.641]                         quietly = TRUE)
[08:28:39.641]                       if (has_future) {
[08:28:39.641]                         ns <- base::getNamespace("future")
[08:28:39.641]                         version <- ns[[".package"]][["version"]]
[08:28:39.641]                         if (is.null(version)) 
[08:28:39.641]                           version <- utils::packageVersion("future")
[08:28:39.641]                       }
[08:28:39.641]                       else {
[08:28:39.641]                         version <- NULL
[08:28:39.641]                       }
[08:28:39.641]                       if (!has_future || version < "1.8.0") {
[08:28:39.641]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:39.641]                           "", base::R.version$version.string), 
[08:28:39.641]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:39.641]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:39.641]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:39.641]                             "release", "version")], collapse = " "), 
[08:28:39.641]                           hostname = base::Sys.info()[["nodename"]])
[08:28:39.641]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:39.641]                           info)
[08:28:39.641]                         info <- base::paste(info, collapse = "; ")
[08:28:39.641]                         if (!has_future) {
[08:28:39.641]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:39.641]                             info)
[08:28:39.641]                         }
[08:28:39.641]                         else {
[08:28:39.641]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:39.641]                             info, version)
[08:28:39.641]                         }
[08:28:39.641]                         base::stop(msg)
[08:28:39.641]                       }
[08:28:39.641]                     })
[08:28:39.641]                   }
[08:28:39.641]                   ...future.strategy.old <- future::plan("list")
[08:28:39.641]                   options(future.plan = NULL)
[08:28:39.641]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:39.641]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:39.641]                 }
[08:28:39.641]                 ...future.workdir <- getwd()
[08:28:39.641]             }
[08:28:39.641]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:39.641]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:39.641]         }
[08:28:39.641]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:39.641]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:39.641]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:39.641]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:39.641]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:39.641]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:39.641]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:39.641]             base::names(...future.oldOptions))
[08:28:39.641]     }
[08:28:39.641]     if (FALSE) {
[08:28:39.641]     }
[08:28:39.641]     else {
[08:28:39.641]         if (TRUE) {
[08:28:39.641]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:39.641]                 open = "w")
[08:28:39.641]         }
[08:28:39.641]         else {
[08:28:39.641]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:39.641]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:39.641]         }
[08:28:39.641]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:39.641]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:39.641]             base::sink(type = "output", split = FALSE)
[08:28:39.641]             base::close(...future.stdout)
[08:28:39.641]         }, add = TRUE)
[08:28:39.641]     }
[08:28:39.641]     ...future.frame <- base::sys.nframe()
[08:28:39.641]     ...future.conditions <- base::list()
[08:28:39.641]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:39.641]     if (FALSE) {
[08:28:39.641]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:39.641]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:39.641]     }
[08:28:39.641]     ...future.result <- base::tryCatch({
[08:28:39.641]         base::withCallingHandlers({
[08:28:39.641]             ...future.value <- base::withVisible(base::local(subset(data, 
[08:28:39.641]                 a == 2)))
[08:28:39.641]             future::FutureResult(value = ...future.value$value, 
[08:28:39.641]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:39.641]                   ...future.rng), globalenv = if (FALSE) 
[08:28:39.641]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:39.641]                     ...future.globalenv.names))
[08:28:39.641]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:39.641]         }, condition = base::local({
[08:28:39.641]             c <- base::c
[08:28:39.641]             inherits <- base::inherits
[08:28:39.641]             invokeRestart <- base::invokeRestart
[08:28:39.641]             length <- base::length
[08:28:39.641]             list <- base::list
[08:28:39.641]             seq.int <- base::seq.int
[08:28:39.641]             signalCondition <- base::signalCondition
[08:28:39.641]             sys.calls <- base::sys.calls
[08:28:39.641]             `[[` <- base::`[[`
[08:28:39.641]             `+` <- base::`+`
[08:28:39.641]             `<<-` <- base::`<<-`
[08:28:39.641]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:39.641]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:39.641]                   3L)]
[08:28:39.641]             }
[08:28:39.641]             function(cond) {
[08:28:39.641]                 is_error <- inherits(cond, "error")
[08:28:39.641]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:39.641]                   NULL)
[08:28:39.641]                 if (is_error) {
[08:28:39.641]                   sessionInformation <- function() {
[08:28:39.641]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:39.641]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:39.641]                       search = base::search(), system = base::Sys.info())
[08:28:39.641]                   }
[08:28:39.641]                   ...future.conditions[[length(...future.conditions) + 
[08:28:39.641]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:39.641]                     cond$call), session = sessionInformation(), 
[08:28:39.641]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:39.641]                   signalCondition(cond)
[08:28:39.641]                 }
[08:28:39.641]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:39.641]                 "immediateCondition"))) {
[08:28:39.641]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:39.641]                   ...future.conditions[[length(...future.conditions) + 
[08:28:39.641]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:39.641]                   if (TRUE && !signal) {
[08:28:39.641]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:39.641]                     {
[08:28:39.641]                       inherits <- base::inherits
[08:28:39.641]                       invokeRestart <- base::invokeRestart
[08:28:39.641]                       is.null <- base::is.null
[08:28:39.641]                       muffled <- FALSE
[08:28:39.641]                       if (inherits(cond, "message")) {
[08:28:39.641]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:39.641]                         if (muffled) 
[08:28:39.641]                           invokeRestart("muffleMessage")
[08:28:39.641]                       }
[08:28:39.641]                       else if (inherits(cond, "warning")) {
[08:28:39.641]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:39.641]                         if (muffled) 
[08:28:39.641]                           invokeRestart("muffleWarning")
[08:28:39.641]                       }
[08:28:39.641]                       else if (inherits(cond, "condition")) {
[08:28:39.641]                         if (!is.null(pattern)) {
[08:28:39.641]                           computeRestarts <- base::computeRestarts
[08:28:39.641]                           grepl <- base::grepl
[08:28:39.641]                           restarts <- computeRestarts(cond)
[08:28:39.641]                           for (restart in restarts) {
[08:28:39.641]                             name <- restart$name
[08:28:39.641]                             if (is.null(name)) 
[08:28:39.641]                               next
[08:28:39.641]                             if (!grepl(pattern, name)) 
[08:28:39.641]                               next
[08:28:39.641]                             invokeRestart(restart)
[08:28:39.641]                             muffled <- TRUE
[08:28:39.641]                             break
[08:28:39.641]                           }
[08:28:39.641]                         }
[08:28:39.641]                       }
[08:28:39.641]                       invisible(muffled)
[08:28:39.641]                     }
[08:28:39.641]                     muffleCondition(cond, pattern = "^muffle")
[08:28:39.641]                   }
[08:28:39.641]                 }
[08:28:39.641]                 else {
[08:28:39.641]                   if (TRUE) {
[08:28:39.641]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:39.641]                     {
[08:28:39.641]                       inherits <- base::inherits
[08:28:39.641]                       invokeRestart <- base::invokeRestart
[08:28:39.641]                       is.null <- base::is.null
[08:28:39.641]                       muffled <- FALSE
[08:28:39.641]                       if (inherits(cond, "message")) {
[08:28:39.641]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:39.641]                         if (muffled) 
[08:28:39.641]                           invokeRestart("muffleMessage")
[08:28:39.641]                       }
[08:28:39.641]                       else if (inherits(cond, "warning")) {
[08:28:39.641]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:39.641]                         if (muffled) 
[08:28:39.641]                           invokeRestart("muffleWarning")
[08:28:39.641]                       }
[08:28:39.641]                       else if (inherits(cond, "condition")) {
[08:28:39.641]                         if (!is.null(pattern)) {
[08:28:39.641]                           computeRestarts <- base::computeRestarts
[08:28:39.641]                           grepl <- base::grepl
[08:28:39.641]                           restarts <- computeRestarts(cond)
[08:28:39.641]                           for (restart in restarts) {
[08:28:39.641]                             name <- restart$name
[08:28:39.641]                             if (is.null(name)) 
[08:28:39.641]                               next
[08:28:39.641]                             if (!grepl(pattern, name)) 
[08:28:39.641]                               next
[08:28:39.641]                             invokeRestart(restart)
[08:28:39.641]                             muffled <- TRUE
[08:28:39.641]                             break
[08:28:39.641]                           }
[08:28:39.641]                         }
[08:28:39.641]                       }
[08:28:39.641]                       invisible(muffled)
[08:28:39.641]                     }
[08:28:39.641]                     muffleCondition(cond, pattern = "^muffle")
[08:28:39.641]                   }
[08:28:39.641]                 }
[08:28:39.641]             }
[08:28:39.641]         }))
[08:28:39.641]     }, error = function(ex) {
[08:28:39.641]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:39.641]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:39.641]                 ...future.rng), started = ...future.startTime, 
[08:28:39.641]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:39.641]             version = "1.8"), class = "FutureResult")
[08:28:39.641]     }, finally = {
[08:28:39.641]         if (!identical(...future.workdir, getwd())) 
[08:28:39.641]             setwd(...future.workdir)
[08:28:39.641]         {
[08:28:39.641]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:39.641]                 ...future.oldOptions$nwarnings <- NULL
[08:28:39.641]             }
[08:28:39.641]             base::options(...future.oldOptions)
[08:28:39.641]             if (.Platform$OS.type == "windows") {
[08:28:39.641]                 old_names <- names(...future.oldEnvVars)
[08:28:39.641]                 envs <- base::Sys.getenv()
[08:28:39.641]                 names <- names(envs)
[08:28:39.641]                 common <- intersect(names, old_names)
[08:28:39.641]                 added <- setdiff(names, old_names)
[08:28:39.641]                 removed <- setdiff(old_names, names)
[08:28:39.641]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:39.641]                   envs[common]]
[08:28:39.641]                 NAMES <- toupper(changed)
[08:28:39.641]                 args <- list()
[08:28:39.641]                 for (kk in seq_along(NAMES)) {
[08:28:39.641]                   name <- changed[[kk]]
[08:28:39.641]                   NAME <- NAMES[[kk]]
[08:28:39.641]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.641]                     next
[08:28:39.641]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:39.641]                 }
[08:28:39.641]                 NAMES <- toupper(added)
[08:28:39.641]                 for (kk in seq_along(NAMES)) {
[08:28:39.641]                   name <- added[[kk]]
[08:28:39.641]                   NAME <- NAMES[[kk]]
[08:28:39.641]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.641]                     next
[08:28:39.641]                   args[[name]] <- ""
[08:28:39.641]                 }
[08:28:39.641]                 NAMES <- toupper(removed)
[08:28:39.641]                 for (kk in seq_along(NAMES)) {
[08:28:39.641]                   name <- removed[[kk]]
[08:28:39.641]                   NAME <- NAMES[[kk]]
[08:28:39.641]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.641]                     next
[08:28:39.641]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:39.641]                 }
[08:28:39.641]                 if (length(args) > 0) 
[08:28:39.641]                   base::do.call(base::Sys.setenv, args = args)
[08:28:39.641]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:39.641]             }
[08:28:39.641]             else {
[08:28:39.641]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:39.641]             }
[08:28:39.641]             {
[08:28:39.641]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:39.641]                   0L) {
[08:28:39.641]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:39.641]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:39.641]                   base::options(opts)
[08:28:39.641]                 }
[08:28:39.641]                 {
[08:28:39.641]                   {
[08:28:39.641]                     NULL
[08:28:39.641]                     RNGkind("Mersenne-Twister")
[08:28:39.641]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:39.641]                       inherits = FALSE)
[08:28:39.641]                   }
[08:28:39.641]                   options(future.plan = NULL)
[08:28:39.641]                   if (is.na(NA_character_)) 
[08:28:39.641]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:39.641]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:39.641]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:39.641]                     .init = FALSE)
[08:28:39.641]                 }
[08:28:39.641]             }
[08:28:39.641]         }
[08:28:39.641]     })
[08:28:39.641]     if (TRUE) {
[08:28:39.641]         base::sink(type = "output", split = FALSE)
[08:28:39.641]         if (TRUE) {
[08:28:39.641]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:39.641]         }
[08:28:39.641]         else {
[08:28:39.641]             ...future.result["stdout"] <- base::list(NULL)
[08:28:39.641]         }
[08:28:39.641]         base::close(...future.stdout)
[08:28:39.641]         ...future.stdout <- NULL
[08:28:39.641]     }
[08:28:39.641]     ...future.result$conditions <- ...future.conditions
[08:28:39.641]     ...future.result$finished <- base::Sys.time()
[08:28:39.641]     ...future.result
[08:28:39.641] }
[08:28:39.671]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.643] assign_globals() ...
[08:28:39.671]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.644] List of 1
[08:28:39.644]  $ data:'data.frame':	3 obs. of  2 variables:
[08:28:39.644]   ..$ a: int [1:3] 1 2 3
[08:28:39.644]   ..$ b: int [1:3] 3 2 1
[08:28:39.644]  - attr(*, "where")=List of 1
[08:28:39.644]   ..$ data:<environment: R_EmptyEnv> 
[08:28:39.644]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:39.644]  - attr(*, "resolved")= logi FALSE
[08:28:39.644]  - attr(*, "total_size")= num 356
[08:28:39.644]  - attr(*, "already-done")= logi TRUE
[08:28:39.671]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.649] - copied ‘data’ to environment
[08:28:39.671]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.650] assign_globals() ... done
[08:28:39.671]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.650] plan(): Setting new future strategy stack:
[08:28:39.672]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.650] List of future strategies:
[08:28:39.650] 1. sequential:
[08:28:39.650]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:39.650]    - tweaked: FALSE
[08:28:39.650]    - call: NULL
[08:28:39.672]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.651] plan(): nbrOfWorkers() = 1
[08:28:39.672]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.652] plan(): Setting new future strategy stack:
[08:28:39.672]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.653] List of future strategies:
[08:28:39.653] 1. sequential:
[08:28:39.653]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:39.653]    - tweaked: FALSE
[08:28:39.653]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:39.672]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.653] plan(): nbrOfWorkers() = 1
[08:28:39.672]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.654] SequentialFuture started (and completed)
[08:28:39.673]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.654] - Launch lazy future ... done
[08:28:39.673]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.654] run() for ‘SequentialFuture’ ... done
[08:28:39.673] signalConditions() ... done
- plan(list('multicore', 'sequential')) ... DONE
- plan(list('multicore', 'multicore')) ...
[08:28:39.673] plan(): Setting new future strategy stack:
[08:28:39.674] List of future strategies:
[08:28:39.674] 1. multicore:
[08:28:39.674]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:39.674]    - tweaked: FALSE
[08:28:39.674]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:39.674] 2. multicore:
[08:28:39.674]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:39.674]    - tweaked: FALSE
[08:28:39.674]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:39.676] plan(): nbrOfWorkers() = 2
[08:28:39.677] getGlobalsAndPackages() ...
[08:28:39.677] Searching for globals...
[08:28:39.699] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[08:28:39.700] Searching for globals ... DONE
[08:28:39.700] Resolving globals: FALSE
[08:28:39.701] The total size of the 2 globals is 11.88 KiB (12162 bytes)
[08:28:39.701] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 11.88 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (11.83 KiB of class ‘list’) and ‘strategy2’ (48 bytes of class ‘character’)
[08:28:39.702] - globals: [2] ‘nested’, ‘strategy2’
[08:28:39.702] - packages: [1] ‘future’
[08:28:39.702] getGlobalsAndPackages() ... DONE
[08:28:39.702] run() for ‘Future’ ...
[08:28:39.702] - state: ‘created’
[08:28:39.702] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:39.704] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:39.704] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:39.705]   - Field: ‘label’
[08:28:39.705]   - Field: ‘local’
[08:28:39.705]   - Field: ‘owner’
[08:28:39.705]   - Field: ‘envir’
[08:28:39.705]   - Field: ‘workers’
[08:28:39.705]   - Field: ‘packages’
[08:28:39.705]   - Field: ‘gc’
[08:28:39.705]   - Field: ‘job’
[08:28:39.705]   - Field: ‘conditions’
[08:28:39.705]   - Field: ‘expr’
[08:28:39.706]   - Field: ‘uuid’
[08:28:39.706]   - Field: ‘seed’
[08:28:39.706]   - Field: ‘version’
[08:28:39.706]   - Field: ‘result’
[08:28:39.706]   - Field: ‘asynchronous’
[08:28:39.706]   - Field: ‘calls’
[08:28:39.706]   - Field: ‘globals’
[08:28:39.706]   - Field: ‘stdout’
[08:28:39.706]   - Field: ‘earlySignal’
[08:28:39.706]   - Field: ‘lazy’
[08:28:39.707]   - Field: ‘state’
[08:28:39.707] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:39.707] - Launch lazy future ...
[08:28:39.707] Packages needed by the future expression (n = 1): ‘future’
[08:28:39.707] Packages needed by future strategies (n = 1): ‘future’
[08:28:39.708] {
[08:28:39.708]     {
[08:28:39.708]         {
[08:28:39.708]             ...future.startTime <- base::Sys.time()
[08:28:39.708]             {
[08:28:39.708]                 {
[08:28:39.708]                   {
[08:28:39.708]                     {
[08:28:39.708]                       {
[08:28:39.708]                         base::local({
[08:28:39.708]                           has_future <- base::requireNamespace("future", 
[08:28:39.708]                             quietly = TRUE)
[08:28:39.708]                           if (has_future) {
[08:28:39.708]                             ns <- base::getNamespace("future")
[08:28:39.708]                             version <- ns[[".package"]][["version"]]
[08:28:39.708]                             if (is.null(version)) 
[08:28:39.708]                               version <- utils::packageVersion("future")
[08:28:39.708]                           }
[08:28:39.708]                           else {
[08:28:39.708]                             version <- NULL
[08:28:39.708]                           }
[08:28:39.708]                           if (!has_future || version < "1.8.0") {
[08:28:39.708]                             info <- base::c(r_version = base::gsub("R version ", 
[08:28:39.708]                               "", base::R.version$version.string), 
[08:28:39.708]                               platform = base::sprintf("%s (%s-bit)", 
[08:28:39.708]                                 base::R.version$platform, 8 * 
[08:28:39.708]                                   base::.Machine$sizeof.pointer), 
[08:28:39.708]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:39.708]                                 "release", "version")], collapse = " "), 
[08:28:39.708]                               hostname = base::Sys.info()[["nodename"]])
[08:28:39.708]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:28:39.708]                               info)
[08:28:39.708]                             info <- base::paste(info, collapse = "; ")
[08:28:39.708]                             if (!has_future) {
[08:28:39.708]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:39.708]                                 info)
[08:28:39.708]                             }
[08:28:39.708]                             else {
[08:28:39.708]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:39.708]                                 info, version)
[08:28:39.708]                             }
[08:28:39.708]                             base::stop(msg)
[08:28:39.708]                           }
[08:28:39.708]                         })
[08:28:39.708]                       }
[08:28:39.708]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:39.708]                       base::options(mc.cores = 1L)
[08:28:39.708]                     }
[08:28:39.708]                     base::local({
[08:28:39.708]                       for (pkg in "future") {
[08:28:39.708]                         base::loadNamespace(pkg)
[08:28:39.708]                         base::library(pkg, character.only = TRUE)
[08:28:39.708]                       }
[08:28:39.708]                     })
[08:28:39.708]                   }
[08:28:39.708]                   ...future.strategy.old <- future::plan("list")
[08:28:39.708]                   options(future.plan = NULL)
[08:28:39.708]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:39.708]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[08:28:39.708]                     envir = parent.frame()) 
[08:28:39.708]                   {
[08:28:39.708]                     default_workers <- missing(workers)
[08:28:39.708]                     if (is.function(workers)) 
[08:28:39.708]                       workers <- workers()
[08:28:39.708]                     workers <- structure(as.integer(workers), 
[08:28:39.708]                       class = class(workers))
[08:28:39.708]                     stop_if_not(is.finite(workers), workers >= 
[08:28:39.708]                       1L)
[08:28:39.708]                     if ((workers == 1L && !inherits(workers, 
[08:28:39.708]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[08:28:39.708]                       if (default_workers) 
[08:28:39.708]                         supportsMulticore(warn = TRUE)
[08:28:39.708]                       return(sequential(..., envir = envir))
[08:28:39.708]                     }
[08:28:39.708]                     oopts <- options(mc.cores = workers)
[08:28:39.708]                     on.exit(options(oopts))
[08:28:39.708]                     future <- MulticoreFuture(..., workers = workers, 
[08:28:39.708]                       envir = envir)
[08:28:39.708]                     if (!future$lazy) 
[08:28:39.708]                       future <- run(future)
[08:28:39.708]                     invisible(future)
[08:28:39.708]                   }), .cleanup = FALSE, .init = FALSE)
[08:28:39.708]                 }
[08:28:39.708]                 ...future.workdir <- getwd()
[08:28:39.708]             }
[08:28:39.708]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:39.708]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:39.708]         }
[08:28:39.708]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:39.708]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:39.708]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:39.708]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:39.708]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:39.708]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:39.708]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:39.708]             base::names(...future.oldOptions))
[08:28:39.708]     }
[08:28:39.708]     if (FALSE) {
[08:28:39.708]     }
[08:28:39.708]     else {
[08:28:39.708]         if (TRUE) {
[08:28:39.708]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:39.708]                 open = "w")
[08:28:39.708]         }
[08:28:39.708]         else {
[08:28:39.708]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:39.708]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:39.708]         }
[08:28:39.708]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:39.708]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:39.708]             base::sink(type = "output", split = FALSE)
[08:28:39.708]             base::close(...future.stdout)
[08:28:39.708]         }, add = TRUE)
[08:28:39.708]     }
[08:28:39.708]     ...future.frame <- base::sys.nframe()
[08:28:39.708]     ...future.conditions <- base::list()
[08:28:39.708]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:39.708]     if (FALSE) {
[08:28:39.708]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:39.708]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:39.708]     }
[08:28:39.708]     ...future.result <- base::tryCatch({
[08:28:39.708]         base::withCallingHandlers({
[08:28:39.708]             ...future.value <- base::withVisible(base::local({
[08:28:39.708]                 withCallingHandlers({
[08:28:39.708]                   {
[08:28:39.708]                     a <- 1L
[08:28:39.708]                     plan_a <- unclass(future::plan("list"))
[08:28:39.708]                     nested_a <- nested[-1]
[08:28:39.708]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[08:28:39.708]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[08:28:39.708]                       strategy2))
[08:28:39.708]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[08:28:39.708]                       "init") <- NULL
[08:28:39.708]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[08:28:39.708]                       "init") <- NULL
[08:28:39.708]                     stopifnot(all.equal(plan_a, nested_a))
[08:28:39.708]                     y %<-% {
[08:28:39.708]                       b <- 2L
[08:28:39.708]                       plan_b <- future::plan("list")
[08:28:39.708]                       nested_b <- nested_a[-1]
[08:28:39.708]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[08:28:39.708]                         1L, inherits(plan_b[[1]], "future"), 
[08:28:39.708]                         inherits(future::plan("next"), "sequential"))
[08:28:39.708]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[08:28:39.708]                         b = b, nested_b = nested_b, plan_b = plan_b)
[08:28:39.708]                     }
[08:28:39.708]                     y
[08:28:39.708]                   }
[08:28:39.708]                 }, immediateCondition = function(cond) {
[08:28:39.708]                   save_rds <- function (object, pathname, ...) 
[08:28:39.708]                   {
[08:28:39.708]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:39.708]                     if (file_test("-f", pathname_tmp)) {
[08:28:39.708]                       fi_tmp <- file.info(pathname_tmp)
[08:28:39.708]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:39.708]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:39.708]                         fi_tmp[["mtime"]])
[08:28:39.708]                     }
[08:28:39.708]                     tryCatch({
[08:28:39.708]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:39.708]                     }, error = function(ex) {
[08:28:39.708]                       msg <- conditionMessage(ex)
[08:28:39.708]                       fi_tmp <- file.info(pathname_tmp)
[08:28:39.708]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:39.708]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:39.708]                         fi_tmp[["mtime"]], msg)
[08:28:39.708]                       ex$message <- msg
[08:28:39.708]                       stop(ex)
[08:28:39.708]                     })
[08:28:39.708]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:39.708]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:39.708]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:39.708]                       fi_tmp <- file.info(pathname_tmp)
[08:28:39.708]                       fi <- file.info(pathname)
[08:28:39.708]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:39.708]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:39.708]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:39.708]                         fi[["size"]], fi[["mtime"]])
[08:28:39.708]                       stop(msg)
[08:28:39.708]                     }
[08:28:39.708]                     invisible(pathname)
[08:28:39.708]                   }
[08:28:39.708]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:39.708]                     rootPath = tempdir()) 
[08:28:39.708]                   {
[08:28:39.708]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:39.708]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:39.708]                       tmpdir = path, fileext = ".rds")
[08:28:39.708]                     save_rds(obj, file)
[08:28:39.708]                   }
[08:28:39.708]                   saveImmediateCondition(cond, path = "/tmp/RtmphjARvB/.future/immediateConditions")
[08:28:39.708]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:39.708]                   {
[08:28:39.708]                     inherits <- base::inherits
[08:28:39.708]                     invokeRestart <- base::invokeRestart
[08:28:39.708]                     is.null <- base::is.null
[08:28:39.708]                     muffled <- FALSE
[08:28:39.708]                     if (inherits(cond, "message")) {
[08:28:39.708]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:39.708]                       if (muffled) 
[08:28:39.708]                         invokeRestart("muffleMessage")
[08:28:39.708]                     }
[08:28:39.708]                     else if (inherits(cond, "warning")) {
[08:28:39.708]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:39.708]                       if (muffled) 
[08:28:39.708]                         invokeRestart("muffleWarning")
[08:28:39.708]                     }
[08:28:39.708]                     else if (inherits(cond, "condition")) {
[08:28:39.708]                       if (!is.null(pattern)) {
[08:28:39.708]                         computeRestarts <- base::computeRestarts
[08:28:39.708]                         grepl <- base::grepl
[08:28:39.708]                         restarts <- computeRestarts(cond)
[08:28:39.708]                         for (restart in restarts) {
[08:28:39.708]                           name <- restart$name
[08:28:39.708]                           if (is.null(name)) 
[08:28:39.708]                             next
[08:28:39.708]                           if (!grepl(pattern, name)) 
[08:28:39.708]                             next
[08:28:39.708]                           invokeRestart(restart)
[08:28:39.708]                           muffled <- TRUE
[08:28:39.708]                           break
[08:28:39.708]                         }
[08:28:39.708]                       }
[08:28:39.708]                     }
[08:28:39.708]                     invisible(muffled)
[08:28:39.708]                   }
[08:28:39.708]                   muffleCondition(cond)
[08:28:39.708]                 })
[08:28:39.708]             }))
[08:28:39.708]             future::FutureResult(value = ...future.value$value, 
[08:28:39.708]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:39.708]                   ...future.rng), globalenv = if (FALSE) 
[08:28:39.708]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:39.708]                     ...future.globalenv.names))
[08:28:39.708]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:39.708]         }, condition = base::local({
[08:28:39.708]             c <- base::c
[08:28:39.708]             inherits <- base::inherits
[08:28:39.708]             invokeRestart <- base::invokeRestart
[08:28:39.708]             length <- base::length
[08:28:39.708]             list <- base::list
[08:28:39.708]             seq.int <- base::seq.int
[08:28:39.708]             signalCondition <- base::signalCondition
[08:28:39.708]             sys.calls <- base::sys.calls
[08:28:39.708]             `[[` <- base::`[[`
[08:28:39.708]             `+` <- base::`+`
[08:28:39.708]             `<<-` <- base::`<<-`
[08:28:39.708]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:39.708]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:39.708]                   3L)]
[08:28:39.708]             }
[08:28:39.708]             function(cond) {
[08:28:39.708]                 is_error <- inherits(cond, "error")
[08:28:39.708]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:39.708]                   NULL)
[08:28:39.708]                 if (is_error) {
[08:28:39.708]                   sessionInformation <- function() {
[08:28:39.708]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:39.708]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:39.708]                       search = base::search(), system = base::Sys.info())
[08:28:39.708]                   }
[08:28:39.708]                   ...future.conditions[[length(...future.conditions) + 
[08:28:39.708]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:39.708]                     cond$call), session = sessionInformation(), 
[08:28:39.708]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:39.708]                   signalCondition(cond)
[08:28:39.708]                 }
[08:28:39.708]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:39.708]                 "immediateCondition"))) {
[08:28:39.708]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:39.708]                   ...future.conditions[[length(...future.conditions) + 
[08:28:39.708]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:39.708]                   if (TRUE && !signal) {
[08:28:39.708]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:39.708]                     {
[08:28:39.708]                       inherits <- base::inherits
[08:28:39.708]                       invokeRestart <- base::invokeRestart
[08:28:39.708]                       is.null <- base::is.null
[08:28:39.708]                       muffled <- FALSE
[08:28:39.708]                       if (inherits(cond, "message")) {
[08:28:39.708]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:39.708]                         if (muffled) 
[08:28:39.708]                           invokeRestart("muffleMessage")
[08:28:39.708]                       }
[08:28:39.708]                       else if (inherits(cond, "warning")) {
[08:28:39.708]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:39.708]                         if (muffled) 
[08:28:39.708]                           invokeRestart("muffleWarning")
[08:28:39.708]                       }
[08:28:39.708]                       else if (inherits(cond, "condition")) {
[08:28:39.708]                         if (!is.null(pattern)) {
[08:28:39.708]                           computeRestarts <- base::computeRestarts
[08:28:39.708]                           grepl <- base::grepl
[08:28:39.708]                           restarts <- computeRestarts(cond)
[08:28:39.708]                           for (restart in restarts) {
[08:28:39.708]                             name <- restart$name
[08:28:39.708]                             if (is.null(name)) 
[08:28:39.708]                               next
[08:28:39.708]                             if (!grepl(pattern, name)) 
[08:28:39.708]                               next
[08:28:39.708]                             invokeRestart(restart)
[08:28:39.708]                             muffled <- TRUE
[08:28:39.708]                             break
[08:28:39.708]                           }
[08:28:39.708]                         }
[08:28:39.708]                       }
[08:28:39.708]                       invisible(muffled)
[08:28:39.708]                     }
[08:28:39.708]                     muffleCondition(cond, pattern = "^muffle")
[08:28:39.708]                   }
[08:28:39.708]                 }
[08:28:39.708]                 else {
[08:28:39.708]                   if (TRUE) {
[08:28:39.708]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:39.708]                     {
[08:28:39.708]                       inherits <- base::inherits
[08:28:39.708]                       invokeRestart <- base::invokeRestart
[08:28:39.708]                       is.null <- base::is.null
[08:28:39.708]                       muffled <- FALSE
[08:28:39.708]                       if (inherits(cond, "message")) {
[08:28:39.708]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:39.708]                         if (muffled) 
[08:28:39.708]                           invokeRestart("muffleMessage")
[08:28:39.708]                       }
[08:28:39.708]                       else if (inherits(cond, "warning")) {
[08:28:39.708]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:39.708]                         if (muffled) 
[08:28:39.708]                           invokeRestart("muffleWarning")
[08:28:39.708]                       }
[08:28:39.708]                       else if (inherits(cond, "condition")) {
[08:28:39.708]                         if (!is.null(pattern)) {
[08:28:39.708]                           computeRestarts <- base::computeRestarts
[08:28:39.708]                           grepl <- base::grepl
[08:28:39.708]                           restarts <- computeRestarts(cond)
[08:28:39.708]                           for (restart in restarts) {
[08:28:39.708]                             name <- restart$name
[08:28:39.708]                             if (is.null(name)) 
[08:28:39.708]                               next
[08:28:39.708]                             if (!grepl(pattern, name)) 
[08:28:39.708]                               next
[08:28:39.708]                             invokeRestart(restart)
[08:28:39.708]                             muffled <- TRUE
[08:28:39.708]                             break
[08:28:39.708]                           }
[08:28:39.708]                         }
[08:28:39.708]                       }
[08:28:39.708]                       invisible(muffled)
[08:28:39.708]                     }
[08:28:39.708]                     muffleCondition(cond, pattern = "^muffle")
[08:28:39.708]                   }
[08:28:39.708]                 }
[08:28:39.708]             }
[08:28:39.708]         }))
[08:28:39.708]     }, error = function(ex) {
[08:28:39.708]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:39.708]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:39.708]                 ...future.rng), started = ...future.startTime, 
[08:28:39.708]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:39.708]             version = "1.8"), class = "FutureResult")
[08:28:39.708]     }, finally = {
[08:28:39.708]         if (!identical(...future.workdir, getwd())) 
[08:28:39.708]             setwd(...future.workdir)
[08:28:39.708]         {
[08:28:39.708]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:39.708]                 ...future.oldOptions$nwarnings <- NULL
[08:28:39.708]             }
[08:28:39.708]             base::options(...future.oldOptions)
[08:28:39.708]             if (.Platform$OS.type == "windows") {
[08:28:39.708]                 old_names <- names(...future.oldEnvVars)
[08:28:39.708]                 envs <- base::Sys.getenv()
[08:28:39.708]                 names <- names(envs)
[08:28:39.708]                 common <- intersect(names, old_names)
[08:28:39.708]                 added <- setdiff(names, old_names)
[08:28:39.708]                 removed <- setdiff(old_names, names)
[08:28:39.708]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:39.708]                   envs[common]]
[08:28:39.708]                 NAMES <- toupper(changed)
[08:28:39.708]                 args <- list()
[08:28:39.708]                 for (kk in seq_along(NAMES)) {
[08:28:39.708]                   name <- changed[[kk]]
[08:28:39.708]                   NAME <- NAMES[[kk]]
[08:28:39.708]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.708]                     next
[08:28:39.708]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:39.708]                 }
[08:28:39.708]                 NAMES <- toupper(added)
[08:28:39.708]                 for (kk in seq_along(NAMES)) {
[08:28:39.708]                   name <- added[[kk]]
[08:28:39.708]                   NAME <- NAMES[[kk]]
[08:28:39.708]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.708]                     next
[08:28:39.708]                   args[[name]] <- ""
[08:28:39.708]                 }
[08:28:39.708]                 NAMES <- toupper(removed)
[08:28:39.708]                 for (kk in seq_along(NAMES)) {
[08:28:39.708]                   name <- removed[[kk]]
[08:28:39.708]                   NAME <- NAMES[[kk]]
[08:28:39.708]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.708]                     next
[08:28:39.708]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:39.708]                 }
[08:28:39.708]                 if (length(args) > 0) 
[08:28:39.708]                   base::do.call(base::Sys.setenv, args = args)
[08:28:39.708]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:39.708]             }
[08:28:39.708]             else {
[08:28:39.708]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:39.708]             }
[08:28:39.708]             {
[08:28:39.708]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:39.708]                   0L) {
[08:28:39.708]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:39.708]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:39.708]                   base::options(opts)
[08:28:39.708]                 }
[08:28:39.708]                 {
[08:28:39.708]                   {
[08:28:39.708]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:39.708]                     NULL
[08:28:39.708]                   }
[08:28:39.708]                   options(future.plan = NULL)
[08:28:39.708]                   if (is.na(NA_character_)) 
[08:28:39.708]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:39.708]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:39.708]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:39.708]                     .init = FALSE)
[08:28:39.708]                 }
[08:28:39.708]             }
[08:28:39.708]         }
[08:28:39.708]     })
[08:28:39.708]     if (TRUE) {
[08:28:39.708]         base::sink(type = "output", split = FALSE)
[08:28:39.708]         if (TRUE) {
[08:28:39.708]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:39.708]         }
[08:28:39.708]         else {
[08:28:39.708]             ...future.result["stdout"] <- base::list(NULL)
[08:28:39.708]         }
[08:28:39.708]         base::close(...future.stdout)
[08:28:39.708]         ...future.stdout <- NULL
[08:28:39.708]     }
[08:28:39.708]     ...future.result$conditions <- ...future.conditions
[08:28:39.708]     ...future.result$finished <- base::Sys.time()
[08:28:39.708]     ...future.result
[08:28:39.708] }
[08:28:39.711] assign_globals() ...
[08:28:39.711] List of 2
[08:28:39.711]  $ nested   :List of 2
[08:28:39.711]   ..$ a:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[08:28:39.711]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[08:28:39.711]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[08:28:39.711]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[08:28:39.711]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[08:28:39.711]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[08:28:39.711]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[08:28:39.711]  $ strategy2: chr "multicore"
[08:28:39.711]  - attr(*, "where")=List of 2
[08:28:39.711]   ..$ nested   :<environment: R_EmptyEnv> 
[08:28:39.711]   ..$ strategy2:<environment: R_EmptyEnv> 
[08:28:39.711]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:39.711]  - attr(*, "resolved")= logi FALSE
[08:28:39.711]  - attr(*, "total_size")= num 12162
[08:28:39.711]  - attr(*, "already-done")= logi TRUE
[08:28:39.716] - copied ‘nested’ to environment
[08:28:39.717] - copied ‘strategy2’ to environment
[08:28:39.717] assign_globals() ... done
[08:28:39.717] requestCore(): workers = 2
[08:28:39.720] MulticoreFuture started
[08:28:39.720] - Launch lazy future ... done
[08:28:39.720] run() for ‘MulticoreFuture’ ... done
[08:28:39.721] result() for MulticoreFuture ...
[08:28:39.721] plan(): Setting new future strategy stack:
[08:28:39.722] List of future strategies:
[08:28:39.722] 1. multicore:
[08:28:39.722]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:39.722]    - tweaked: FALSE
[08:28:39.722]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:39.725] plan(): nbrOfWorkers() = 1
[08:28:39.768] plan(): Setting new future strategy stack:
[08:28:39.769] List of future strategies:
[08:28:39.769] 1. multicore:
[08:28:39.769]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:39.769]    - tweaked: FALSE
[08:28:39.769]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:39.769] 2. multicore:
[08:28:39.769]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:39.769]    - tweaked: FALSE
[08:28:39.769]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:39.771] plan(): nbrOfWorkers() = 2
[08:28:39.772] result() for MulticoreFuture ...
[08:28:39.773] result() for MulticoreFuture ... done
[08:28:39.773] signalConditions() ...
[08:28:39.773]  - include = ‘immediateCondition’
[08:28:39.773]  - exclude = 
[08:28:39.773]  - resignal = FALSE
[08:28:39.773]  - Number of conditions: 54
[08:28:39.773] signalConditions() ... done
[08:28:39.773] result() for MulticoreFuture ... done
[08:28:39.774] result() for MulticoreFuture ...
[08:28:39.774] result() for MulticoreFuture ... done
[08:28:39.774] signalConditions() ...
[08:28:39.774]  - include = ‘immediateCondition’
[08:28:39.774]  - exclude = 
[08:28:39.774]  - resignal = FALSE
[08:28:39.774]  - Number of conditions: 54
[08:28:39.774] signalConditions() ... done
[08:28:39.774] Future state: ‘finished’
[08:28:39.775] result() for MulticoreFuture ...
[08:28:39.775] result() for MulticoreFuture ... done
[08:28:39.775] signalConditions() ...
[08:28:39.775]  - include = ‘condition’
[08:28:39.775]  - exclude = ‘immediateCondition’
[08:28:39.775]  - resignal = TRUE
[08:28:39.775]  - Number of conditions: 54
[08:28:39.775]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.727] getGlobalsAndPackages() ...
[08:28:39.775]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.727] Searching for globals...
[08:28:39.775]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.740] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[08:28:39.776]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.741] Searching for globals ... DONE
[08:28:39.776]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.741] Resolving globals: FALSE
[08:28:39.776]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.742] The total size of the 3 globals is 12.54 KiB (12841 bytes)
[08:28:39.776]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.743] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 12.54 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (6.25 KiB of class ‘list’), ‘plan_a’ (6.25 KiB of class ‘list’) and ‘a’ (35 bytes of class ‘numeric’)
[08:28:39.776]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.743] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[08:28:39.776]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.743] 
[08:28:39.777]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.744] getGlobalsAndPackages() ... DONE
[08:28:39.777]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.744] run() for ‘Future’ ...
[08:28:39.777]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.745] - state: ‘created’
[08:28:39.777]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.745] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:39.777]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.747] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:39.777]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.747] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:39.777]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.748]   - Field: ‘label’
[08:28:39.778]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.748]   - Field: ‘local’
[08:28:39.778]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.748]   - Field: ‘owner’
[08:28:39.778]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.748]   - Field: ‘envir’
[08:28:39.778]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.748]   - Field: ‘packages’
[08:28:39.778]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.748]   - Field: ‘gc’
[08:28:39.778]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.749]   - Field: ‘conditions’
[08:28:39.778]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.749]   - Field: ‘expr’
[08:28:39.779]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.749]   - Field: ‘uuid’
[08:28:39.779]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.749]   - Field: ‘seed’
[08:28:39.779]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.749]   - Field: ‘version’
[08:28:39.779]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.749]   - Field: ‘result’
[08:28:39.779]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.749]   - Field: ‘asynchronous’
[08:28:39.779]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.750]   - Field: ‘calls’
[08:28:39.779]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.750]   - Field: ‘globals’
[08:28:39.783]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.750]   - Field: ‘stdout’
[08:28:39.783]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.750]   - Field: ‘earlySignal’
[08:28:39.783]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.750]   - Field: ‘lazy’
[08:28:39.783]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.750]   - Field: ‘state’
[08:28:39.783]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.751] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:39.784]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.751] - Launch lazy future ...
[08:28:39.784]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.751] Packages needed by the future expression (n = 0): <none>
[08:28:39.784]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.751] Packages needed by future strategies (n = 0): <none>
[08:28:39.784]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.752] {
[08:28:39.752]     {
[08:28:39.752]         {
[08:28:39.752]             ...future.startTime <- base::Sys.time()
[08:28:39.752]             {
[08:28:39.752]                 {
[08:28:39.752]                   {
[08:28:39.752]                     base::local({
[08:28:39.752]                       has_future <- base::requireNamespace("future", 
[08:28:39.752]                         quietly = TRUE)
[08:28:39.752]                       if (has_future) {
[08:28:39.752]                         ns <- base::getNamespace("future")
[08:28:39.752]                         version <- ns[[".package"]][["version"]]
[08:28:39.752]                         if (is.null(version)) 
[08:28:39.752]                           version <- utils::packageVersion("future")
[08:28:39.752]                       }
[08:28:39.752]                       else {
[08:28:39.752]                         version <- NULL
[08:28:39.752]                       }
[08:28:39.752]                       if (!has_future || version < "1.8.0") {
[08:28:39.752]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:39.752]                           "", base::R.version$version.string), 
[08:28:39.752]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:39.752]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:39.752]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:39.752]                             "release", "version")], collapse = " "), 
[08:28:39.752]                           hostname = base::Sys.info()[["nodename"]])
[08:28:39.752]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:39.752]                           info)
[08:28:39.752]                         info <- base::paste(info, collapse = "; ")
[08:28:39.752]                         if (!has_future) {
[08:28:39.752]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:39.752]                             info)
[08:28:39.752]                         }
[08:28:39.752]                         else {
[08:28:39.752]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:39.752]                             info, version)
[08:28:39.752]                         }
[08:28:39.752]                         base::stop(msg)
[08:28:39.752]                       }
[08:28:39.752]                     })
[08:28:39.752]                   }
[08:28:39.752]                   ...future.strategy.old <- future::plan("list")
[08:28:39.752]                   options(future.plan = NULL)
[08:28:39.752]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:39.752]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:39.752]                 }
[08:28:39.752]                 ...future.workdir <- getwd()
[08:28:39.752]             }
[08:28:39.752]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:39.752]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:39.752]         }
[08:28:39.752]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:39.752]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:39.752]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:39.752]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:39.752]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:39.752]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:39.752]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:39.752]             base::names(...future.oldOptions))
[08:28:39.752]     }
[08:28:39.752]     if (FALSE) {
[08:28:39.752]     }
[08:28:39.752]     else {
[08:28:39.752]         if (TRUE) {
[08:28:39.752]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:39.752]                 open = "w")
[08:28:39.752]         }
[08:28:39.752]         else {
[08:28:39.752]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:39.752]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:39.752]         }
[08:28:39.752]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:39.752]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:39.752]             base::sink(type = "output", split = FALSE)
[08:28:39.752]             base::close(...future.stdout)
[08:28:39.752]         }, add = TRUE)
[08:28:39.752]     }
[08:28:39.752]     ...future.frame <- base::sys.nframe()
[08:28:39.752]     ...future.conditions <- base::list()
[08:28:39.752]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:39.752]     if (FALSE) {
[08:28:39.752]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:39.752]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:39.752]     }
[08:28:39.752]     ...future.result <- base::tryCatch({
[08:28:39.752]         base::withCallingHandlers({
[08:28:39.752]             ...future.value <- base::withVisible(base::local({
[08:28:39.752]                 b <- 2L
[08:28:39.752]                 plan_b <- future::plan("list")
[08:28:39.752]                 nested_b <- nested_a[-1]
[08:28:39.752]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[08:28:39.752]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[08:28:39.752]                   "sequential"))
[08:28:39.752]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[08:28:39.752]                   b = b, nested_b = nested_b, plan_b = plan_b)
[08:28:39.752]             }))
[08:28:39.752]             future::FutureResult(value = ...future.value$value, 
[08:28:39.752]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:39.752]                   ...future.rng), globalenv = if (FALSE) 
[08:28:39.752]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:39.752]                     ...future.globalenv.names))
[08:28:39.752]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:39.752]         }, condition = base::local({
[08:28:39.752]             c <- base::c
[08:28:39.752]             inherits <- base::inherits
[08:28:39.752]             invokeRestart <- base::invokeRestart
[08:28:39.752]             length <- base::length
[08:28:39.752]             list <- base::list
[08:28:39.752]             seq.int <- base::seq.int
[08:28:39.752]             signalCondition <- base::signalCondition
[08:28:39.752]             sys.calls <- base::sys.calls
[08:28:39.752]             `[[` <- base::`[[`
[08:28:39.752]             `+` <- base::`+`
[08:28:39.752]             `<<-` <- base::`<<-`
[08:28:39.752]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:39.752]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:39.752]                   3L)]
[08:28:39.752]             }
[08:28:39.752]             function(cond) {
[08:28:39.752]                 is_error <- inherits(cond, "error")
[08:28:39.752]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:39.752]                   NULL)
[08:28:39.752]                 if (is_error) {
[08:28:39.752]                   sessionInformation <- function() {
[08:28:39.752]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:39.752]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:39.752]                       search = base::search(), system = base::Sys.info())
[08:28:39.752]                   }
[08:28:39.752]                   ...future.conditions[[length(...future.conditions) + 
[08:28:39.752]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:39.752]                     cond$call), session = sessionInformation(), 
[08:28:39.752]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:39.752]                   signalCondition(cond)
[08:28:39.752]                 }
[08:28:39.752]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:39.752]                 "immediateCondition"))) {
[08:28:39.752]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:39.752]                   ...future.conditions[[length(...future.conditions) + 
[08:28:39.752]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:39.752]                   if (TRUE && !signal) {
[08:28:39.752]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:39.752]                     {
[08:28:39.752]                       inherits <- base::inherits
[08:28:39.752]                       invokeRestart <- base::invokeRestart
[08:28:39.752]                       is.null <- base::is.null
[08:28:39.752]                       muffled <- FALSE
[08:28:39.752]                       if (inherits(cond, "message")) {
[08:28:39.752]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:39.752]                         if (muffled) 
[08:28:39.752]                           invokeRestart("muffleMessage")
[08:28:39.752]                       }
[08:28:39.752]                       else if (inherits(cond, "warning")) {
[08:28:39.752]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:39.752]                         if (muffled) 
[08:28:39.752]                           invokeRestart("muffleWarning")
[08:28:39.752]                       }
[08:28:39.752]                       else if (inherits(cond, "condition")) {
[08:28:39.752]                         if (!is.null(pattern)) {
[08:28:39.752]                           computeRestarts <- base::computeRestarts
[08:28:39.752]                           grepl <- base::grepl
[08:28:39.752]                           restarts <- computeRestarts(cond)
[08:28:39.752]                           for (restart in restarts) {
[08:28:39.752]                             name <- restart$name
[08:28:39.752]                             if (is.null(name)) 
[08:28:39.752]                               next
[08:28:39.752]                             if (!grepl(pattern, name)) 
[08:28:39.752]                               next
[08:28:39.752]                             invokeRestart(restart)
[08:28:39.752]                             muffled <- TRUE
[08:28:39.752]                             break
[08:28:39.752]                           }
[08:28:39.752]                         }
[08:28:39.752]                       }
[08:28:39.752]                       invisible(muffled)
[08:28:39.752]                     }
[08:28:39.752]                     muffleCondition(cond, pattern = "^muffle")
[08:28:39.752]                   }
[08:28:39.752]                 }
[08:28:39.752]                 else {
[08:28:39.752]                   if (TRUE) {
[08:28:39.752]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:39.752]                     {
[08:28:39.752]                       inherits <- base::inherits
[08:28:39.752]                       invokeRestart <- base::invokeRestart
[08:28:39.752]                       is.null <- base::is.null
[08:28:39.752]                       muffled <- FALSE
[08:28:39.752]                       if (inherits(cond, "message")) {
[08:28:39.752]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:39.752]                         if (muffled) 
[08:28:39.752]                           invokeRestart("muffleMessage")
[08:28:39.752]                       }
[08:28:39.752]                       else if (inherits(cond, "warning")) {
[08:28:39.752]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:39.752]                         if (muffled) 
[08:28:39.752]                           invokeRestart("muffleWarning")
[08:28:39.752]                       }
[08:28:39.752]                       else if (inherits(cond, "condition")) {
[08:28:39.752]                         if (!is.null(pattern)) {
[08:28:39.752]                           computeRestarts <- base::computeRestarts
[08:28:39.752]                           grepl <- base::grepl
[08:28:39.752]                           restarts <- computeRestarts(cond)
[08:28:39.752]                           for (restart in restarts) {
[08:28:39.752]                             name <- restart$name
[08:28:39.752]                             if (is.null(name)) 
[08:28:39.752]                               next
[08:28:39.752]                             if (!grepl(pattern, name)) 
[08:28:39.752]                               next
[08:28:39.752]                             invokeRestart(restart)
[08:28:39.752]                             muffled <- TRUE
[08:28:39.752]                             break
[08:28:39.752]                           }
[08:28:39.752]                         }
[08:28:39.752]                       }
[08:28:39.752]                       invisible(muffled)
[08:28:39.752]                     }
[08:28:39.752]                     muffleCondition(cond, pattern = "^muffle")
[08:28:39.752]                   }
[08:28:39.752]                 }
[08:28:39.752]             }
[08:28:39.752]         }))
[08:28:39.752]     }, error = function(ex) {
[08:28:39.752]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:39.752]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:39.752]                 ...future.rng), started = ...future.startTime, 
[08:28:39.752]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:39.752]             version = "1.8"), class = "FutureResult")
[08:28:39.752]     }, finally = {
[08:28:39.752]         if (!identical(...future.workdir, getwd())) 
[08:28:39.752]             setwd(...future.workdir)
[08:28:39.752]         {
[08:28:39.752]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:39.752]                 ...future.oldOptions$nwarnings <- NULL
[08:28:39.752]             }
[08:28:39.752]             base::options(...future.oldOptions)
[08:28:39.752]             if (.Platform$OS.type == "windows") {
[08:28:39.752]                 old_names <- names(...future.oldEnvVars)
[08:28:39.752]                 envs <- base::Sys.getenv()
[08:28:39.752]                 names <- names(envs)
[08:28:39.752]                 common <- intersect(names, old_names)
[08:28:39.752]                 added <- setdiff(names, old_names)
[08:28:39.752]                 removed <- setdiff(old_names, names)
[08:28:39.752]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:39.752]                   envs[common]]
[08:28:39.752]                 NAMES <- toupper(changed)
[08:28:39.752]                 args <- list()
[08:28:39.752]                 for (kk in seq_along(NAMES)) {
[08:28:39.752]                   name <- changed[[kk]]
[08:28:39.752]                   NAME <- NAMES[[kk]]
[08:28:39.752]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.752]                     next
[08:28:39.752]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:39.752]                 }
[08:28:39.752]                 NAMES <- toupper(added)
[08:28:39.752]                 for (kk in seq_along(NAMES)) {
[08:28:39.752]                   name <- added[[kk]]
[08:28:39.752]                   NAME <- NAMES[[kk]]
[08:28:39.752]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.752]                     next
[08:28:39.752]                   args[[name]] <- ""
[08:28:39.752]                 }
[08:28:39.752]                 NAMES <- toupper(removed)
[08:28:39.752]                 for (kk in seq_along(NAMES)) {
[08:28:39.752]                   name <- removed[[kk]]
[08:28:39.752]                   NAME <- NAMES[[kk]]
[08:28:39.752]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.752]                     next
[08:28:39.752]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:39.752]                 }
[08:28:39.752]                 if (length(args) > 0) 
[08:28:39.752]                   base::do.call(base::Sys.setenv, args = args)
[08:28:39.752]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:39.752]             }
[08:28:39.752]             else {
[08:28:39.752]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:39.752]             }
[08:28:39.752]             {
[08:28:39.752]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:39.752]                   0L) {
[08:28:39.752]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:39.752]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:39.752]                   base::options(opts)
[08:28:39.752]                 }
[08:28:39.752]                 {
[08:28:39.752]                   {
[08:28:39.752]                     NULL
[08:28:39.752]                     RNGkind("Mersenne-Twister")
[08:28:39.752]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:39.752]                       inherits = FALSE)
[08:28:39.752]                   }
[08:28:39.752]                   options(future.plan = NULL)
[08:28:39.752]                   if (is.na(NA_character_)) 
[08:28:39.752]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:39.752]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:39.752]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:39.752]                     .init = FALSE)
[08:28:39.752]                 }
[08:28:39.752]             }
[08:28:39.752]         }
[08:28:39.752]     })
[08:28:39.752]     if (TRUE) {
[08:28:39.752]         base::sink(type = "output", split = FALSE)
[08:28:39.752]         if (TRUE) {
[08:28:39.752]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:39.752]         }
[08:28:39.752]         else {
[08:28:39.752]             ...future.result["stdout"] <- base::list(NULL)
[08:28:39.752]         }
[08:28:39.752]         base::close(...future.stdout)
[08:28:39.752]         ...future.stdout <- NULL
[08:28:39.752]     }
[08:28:39.752]     ...future.result$conditions <- ...future.conditions
[08:28:39.752]     ...future.result$finished <- base::Sys.time()
[08:28:39.752]     ...future.result
[08:28:39.752] }
[08:28:39.784]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.754] assign_globals() ...
[08:28:39.785]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.754] List of 3
[08:28:39.754]  $ nested_a:List of 1
[08:28:39.754]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[08:28:39.754]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[08:28:39.754]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[08:28:39.754]  $ a       : int 1
[08:28:39.754]  $ plan_a  :List of 1
[08:28:39.754]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[08:28:39.754]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[08:28:39.754]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[08:28:39.754]  - attr(*, "where")=List of 3
[08:28:39.754]   ..$ nested_a:<environment: R_EmptyEnv> 
[08:28:39.754]   ..$ a       :<environment: R_EmptyEnv> 
[08:28:39.754]   ..$ plan_a  :<environment: R_EmptyEnv> 
[08:28:39.754]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:39.754]  - attr(*, "resolved")= logi FALSE
[08:28:39.754]  - attr(*, "total_size")= num 12841
[08:28:39.754]  - attr(*, "already-done")= logi TRUE
[08:28:39.785]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.761] - copied ‘nested_a’ to environment
[08:28:39.785]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.762] - copied ‘a’ to environment
[08:28:39.785]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.762] - copied ‘plan_a’ to environment
[08:28:39.785]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.762] assign_globals() ... done
[08:28:39.785]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.762] plan(): Setting new future strategy stack:
[08:28:39.785]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.763] List of future strategies:
[08:28:39.763] 1. sequential:
[08:28:39.763]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:39.763]    - tweaked: FALSE
[08:28:39.763]    - call: NULL
[08:28:39.786]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.763] plan(): nbrOfWorkers() = 1
[08:28:39.786]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.765] plan(): Setting new future strategy stack:
[08:28:39.786]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.765] List of future strategies:
[08:28:39.765] 1. multicore:
[08:28:39.765]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:39.765]    - tweaked: FALSE
[08:28:39.765]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:39.786]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.767] plan(): nbrOfWorkers() = 1
[08:28:39.786]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.767] SequentialFuture started (and completed)
[08:28:39.786]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.767] - Launch lazy future ... done
[08:28:39.786]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.768] run() for ‘SequentialFuture’ ... done
[08:28:39.787] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[08:28:39.793] getGlobalsAndPackages() ...
[08:28:39.793] Searching for globals...
[08:28:39.795] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[08:28:39.795] Searching for globals ... DONE
[08:28:39.795] Resolving globals: FALSE
[08:28:39.795] The total size of the 1 globals is 356 bytes (356 bytes)
[08:28:39.796] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[08:28:39.796] - globals: [1] ‘data’
[08:28:39.796] - packages: [1] ‘future’
[08:28:39.796] getGlobalsAndPackages() ... DONE
[08:28:39.797] run() for ‘Future’ ...
[08:28:39.797] - state: ‘created’
[08:28:39.797] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:39.799] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:39.799] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:39.799]   - Field: ‘label’
[08:28:39.799]   - Field: ‘local’
[08:28:39.800]   - Field: ‘owner’
[08:28:39.800]   - Field: ‘envir’
[08:28:39.800]   - Field: ‘workers’
[08:28:39.800]   - Field: ‘packages’
[08:28:39.800]   - Field: ‘gc’
[08:28:39.800]   - Field: ‘job’
[08:28:39.800]   - Field: ‘conditions’
[08:28:39.800]   - Field: ‘expr’
[08:28:39.800]   - Field: ‘uuid’
[08:28:39.800]   - Field: ‘seed’
[08:28:39.801]   - Field: ‘version’
[08:28:39.801]   - Field: ‘result’
[08:28:39.801]   - Field: ‘asynchronous’
[08:28:39.801]   - Field: ‘calls’
[08:28:39.801]   - Field: ‘globals’
[08:28:39.801]   - Field: ‘stdout’
[08:28:39.801]   - Field: ‘earlySignal’
[08:28:39.801]   - Field: ‘lazy’
[08:28:39.801]   - Field: ‘state’
[08:28:39.802] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:39.802] - Launch lazy future ...
[08:28:39.802] Packages needed by the future expression (n = 1): ‘future’
[08:28:39.802] Packages needed by future strategies (n = 1): ‘future’
[08:28:39.803] {
[08:28:39.803]     {
[08:28:39.803]         {
[08:28:39.803]             ...future.startTime <- base::Sys.time()
[08:28:39.803]             {
[08:28:39.803]                 {
[08:28:39.803]                   {
[08:28:39.803]                     {
[08:28:39.803]                       {
[08:28:39.803]                         base::local({
[08:28:39.803]                           has_future <- base::requireNamespace("future", 
[08:28:39.803]                             quietly = TRUE)
[08:28:39.803]                           if (has_future) {
[08:28:39.803]                             ns <- base::getNamespace("future")
[08:28:39.803]                             version <- ns[[".package"]][["version"]]
[08:28:39.803]                             if (is.null(version)) 
[08:28:39.803]                               version <- utils::packageVersion("future")
[08:28:39.803]                           }
[08:28:39.803]                           else {
[08:28:39.803]                             version <- NULL
[08:28:39.803]                           }
[08:28:39.803]                           if (!has_future || version < "1.8.0") {
[08:28:39.803]                             info <- base::c(r_version = base::gsub("R version ", 
[08:28:39.803]                               "", base::R.version$version.string), 
[08:28:39.803]                               platform = base::sprintf("%s (%s-bit)", 
[08:28:39.803]                                 base::R.version$platform, 8 * 
[08:28:39.803]                                   base::.Machine$sizeof.pointer), 
[08:28:39.803]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:39.803]                                 "release", "version")], collapse = " "), 
[08:28:39.803]                               hostname = base::Sys.info()[["nodename"]])
[08:28:39.803]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:28:39.803]                               info)
[08:28:39.803]                             info <- base::paste(info, collapse = "; ")
[08:28:39.803]                             if (!has_future) {
[08:28:39.803]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:39.803]                                 info)
[08:28:39.803]                             }
[08:28:39.803]                             else {
[08:28:39.803]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:39.803]                                 info, version)
[08:28:39.803]                             }
[08:28:39.803]                             base::stop(msg)
[08:28:39.803]                           }
[08:28:39.803]                         })
[08:28:39.803]                       }
[08:28:39.803]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:39.803]                       base::options(mc.cores = 1L)
[08:28:39.803]                     }
[08:28:39.803]                     base::local({
[08:28:39.803]                       for (pkg in "future") {
[08:28:39.803]                         base::loadNamespace(pkg)
[08:28:39.803]                         base::library(pkg, character.only = TRUE)
[08:28:39.803]                       }
[08:28:39.803]                     })
[08:28:39.803]                   }
[08:28:39.803]                   ...future.strategy.old <- future::plan("list")
[08:28:39.803]                   options(future.plan = NULL)
[08:28:39.803]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:39.803]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[08:28:39.803]                     envir = parent.frame()) 
[08:28:39.803]                   {
[08:28:39.803]                     default_workers <- missing(workers)
[08:28:39.803]                     if (is.function(workers)) 
[08:28:39.803]                       workers <- workers()
[08:28:39.803]                     workers <- structure(as.integer(workers), 
[08:28:39.803]                       class = class(workers))
[08:28:39.803]                     stop_if_not(is.finite(workers), workers >= 
[08:28:39.803]                       1L)
[08:28:39.803]                     if ((workers == 1L && !inherits(workers, 
[08:28:39.803]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[08:28:39.803]                       if (default_workers) 
[08:28:39.803]                         supportsMulticore(warn = TRUE)
[08:28:39.803]                       return(sequential(..., envir = envir))
[08:28:39.803]                     }
[08:28:39.803]                     oopts <- options(mc.cores = workers)
[08:28:39.803]                     on.exit(options(oopts))
[08:28:39.803]                     future <- MulticoreFuture(..., workers = workers, 
[08:28:39.803]                       envir = envir)
[08:28:39.803]                     if (!future$lazy) 
[08:28:39.803]                       future <- run(future)
[08:28:39.803]                     invisible(future)
[08:28:39.803]                   }), .cleanup = FALSE, .init = FALSE)
[08:28:39.803]                 }
[08:28:39.803]                 ...future.workdir <- getwd()
[08:28:39.803]             }
[08:28:39.803]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:39.803]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:39.803]         }
[08:28:39.803]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:39.803]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:39.803]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:39.803]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:39.803]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:39.803]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:39.803]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:39.803]             base::names(...future.oldOptions))
[08:28:39.803]     }
[08:28:39.803]     if (FALSE) {
[08:28:39.803]     }
[08:28:39.803]     else {
[08:28:39.803]         if (TRUE) {
[08:28:39.803]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:39.803]                 open = "w")
[08:28:39.803]         }
[08:28:39.803]         else {
[08:28:39.803]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:39.803]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:39.803]         }
[08:28:39.803]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:39.803]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:39.803]             base::sink(type = "output", split = FALSE)
[08:28:39.803]             base::close(...future.stdout)
[08:28:39.803]         }, add = TRUE)
[08:28:39.803]     }
[08:28:39.803]     ...future.frame <- base::sys.nframe()
[08:28:39.803]     ...future.conditions <- base::list()
[08:28:39.803]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:39.803]     if (FALSE) {
[08:28:39.803]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:39.803]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:39.803]     }
[08:28:39.803]     ...future.result <- base::tryCatch({
[08:28:39.803]         base::withCallingHandlers({
[08:28:39.803]             ...future.value <- base::withVisible(base::local({
[08:28:39.803]                 withCallingHandlers({
[08:28:39.803]                   {
[08:28:39.803]                     value(future(subset(data, a == 2)))
[08:28:39.803]                   }
[08:28:39.803]                 }, immediateCondition = function(cond) {
[08:28:39.803]                   save_rds <- function (object, pathname, ...) 
[08:28:39.803]                   {
[08:28:39.803]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:39.803]                     if (file_test("-f", pathname_tmp)) {
[08:28:39.803]                       fi_tmp <- file.info(pathname_tmp)
[08:28:39.803]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:39.803]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:39.803]                         fi_tmp[["mtime"]])
[08:28:39.803]                     }
[08:28:39.803]                     tryCatch({
[08:28:39.803]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:39.803]                     }, error = function(ex) {
[08:28:39.803]                       msg <- conditionMessage(ex)
[08:28:39.803]                       fi_tmp <- file.info(pathname_tmp)
[08:28:39.803]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:39.803]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:39.803]                         fi_tmp[["mtime"]], msg)
[08:28:39.803]                       ex$message <- msg
[08:28:39.803]                       stop(ex)
[08:28:39.803]                     })
[08:28:39.803]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:39.803]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:39.803]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:39.803]                       fi_tmp <- file.info(pathname_tmp)
[08:28:39.803]                       fi <- file.info(pathname)
[08:28:39.803]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:39.803]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:39.803]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:39.803]                         fi[["size"]], fi[["mtime"]])
[08:28:39.803]                       stop(msg)
[08:28:39.803]                     }
[08:28:39.803]                     invisible(pathname)
[08:28:39.803]                   }
[08:28:39.803]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:39.803]                     rootPath = tempdir()) 
[08:28:39.803]                   {
[08:28:39.803]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:39.803]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:39.803]                       tmpdir = path, fileext = ".rds")
[08:28:39.803]                     save_rds(obj, file)
[08:28:39.803]                   }
[08:28:39.803]                   saveImmediateCondition(cond, path = "/tmp/RtmphjARvB/.future/immediateConditions")
[08:28:39.803]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:39.803]                   {
[08:28:39.803]                     inherits <- base::inherits
[08:28:39.803]                     invokeRestart <- base::invokeRestart
[08:28:39.803]                     is.null <- base::is.null
[08:28:39.803]                     muffled <- FALSE
[08:28:39.803]                     if (inherits(cond, "message")) {
[08:28:39.803]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:39.803]                       if (muffled) 
[08:28:39.803]                         invokeRestart("muffleMessage")
[08:28:39.803]                     }
[08:28:39.803]                     else if (inherits(cond, "warning")) {
[08:28:39.803]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:39.803]                       if (muffled) 
[08:28:39.803]                         invokeRestart("muffleWarning")
[08:28:39.803]                     }
[08:28:39.803]                     else if (inherits(cond, "condition")) {
[08:28:39.803]                       if (!is.null(pattern)) {
[08:28:39.803]                         computeRestarts <- base::computeRestarts
[08:28:39.803]                         grepl <- base::grepl
[08:28:39.803]                         restarts <- computeRestarts(cond)
[08:28:39.803]                         for (restart in restarts) {
[08:28:39.803]                           name <- restart$name
[08:28:39.803]                           if (is.null(name)) 
[08:28:39.803]                             next
[08:28:39.803]                           if (!grepl(pattern, name)) 
[08:28:39.803]                             next
[08:28:39.803]                           invokeRestart(restart)
[08:28:39.803]                           muffled <- TRUE
[08:28:39.803]                           break
[08:28:39.803]                         }
[08:28:39.803]                       }
[08:28:39.803]                     }
[08:28:39.803]                     invisible(muffled)
[08:28:39.803]                   }
[08:28:39.803]                   muffleCondition(cond)
[08:28:39.803]                 })
[08:28:39.803]             }))
[08:28:39.803]             future::FutureResult(value = ...future.value$value, 
[08:28:39.803]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:39.803]                   ...future.rng), globalenv = if (FALSE) 
[08:28:39.803]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:39.803]                     ...future.globalenv.names))
[08:28:39.803]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:39.803]         }, condition = base::local({
[08:28:39.803]             c <- base::c
[08:28:39.803]             inherits <- base::inherits
[08:28:39.803]             invokeRestart <- base::invokeRestart
[08:28:39.803]             length <- base::length
[08:28:39.803]             list <- base::list
[08:28:39.803]             seq.int <- base::seq.int
[08:28:39.803]             signalCondition <- base::signalCondition
[08:28:39.803]             sys.calls <- base::sys.calls
[08:28:39.803]             `[[` <- base::`[[`
[08:28:39.803]             `+` <- base::`+`
[08:28:39.803]             `<<-` <- base::`<<-`
[08:28:39.803]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:39.803]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:39.803]                   3L)]
[08:28:39.803]             }
[08:28:39.803]             function(cond) {
[08:28:39.803]                 is_error <- inherits(cond, "error")
[08:28:39.803]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:39.803]                   NULL)
[08:28:39.803]                 if (is_error) {
[08:28:39.803]                   sessionInformation <- function() {
[08:28:39.803]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:39.803]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:39.803]                       search = base::search(), system = base::Sys.info())
[08:28:39.803]                   }
[08:28:39.803]                   ...future.conditions[[length(...future.conditions) + 
[08:28:39.803]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:39.803]                     cond$call), session = sessionInformation(), 
[08:28:39.803]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:39.803]                   signalCondition(cond)
[08:28:39.803]                 }
[08:28:39.803]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:39.803]                 "immediateCondition"))) {
[08:28:39.803]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:39.803]                   ...future.conditions[[length(...future.conditions) + 
[08:28:39.803]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:39.803]                   if (TRUE && !signal) {
[08:28:39.803]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:39.803]                     {
[08:28:39.803]                       inherits <- base::inherits
[08:28:39.803]                       invokeRestart <- base::invokeRestart
[08:28:39.803]                       is.null <- base::is.null
[08:28:39.803]                       muffled <- FALSE
[08:28:39.803]                       if (inherits(cond, "message")) {
[08:28:39.803]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:39.803]                         if (muffled) 
[08:28:39.803]                           invokeRestart("muffleMessage")
[08:28:39.803]                       }
[08:28:39.803]                       else if (inherits(cond, "warning")) {
[08:28:39.803]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:39.803]                         if (muffled) 
[08:28:39.803]                           invokeRestart("muffleWarning")
[08:28:39.803]                       }
[08:28:39.803]                       else if (inherits(cond, "condition")) {
[08:28:39.803]                         if (!is.null(pattern)) {
[08:28:39.803]                           computeRestarts <- base::computeRestarts
[08:28:39.803]                           grepl <- base::grepl
[08:28:39.803]                           restarts <- computeRestarts(cond)
[08:28:39.803]                           for (restart in restarts) {
[08:28:39.803]                             name <- restart$name
[08:28:39.803]                             if (is.null(name)) 
[08:28:39.803]                               next
[08:28:39.803]                             if (!grepl(pattern, name)) 
[08:28:39.803]                               next
[08:28:39.803]                             invokeRestart(restart)
[08:28:39.803]                             muffled <- TRUE
[08:28:39.803]                             break
[08:28:39.803]                           }
[08:28:39.803]                         }
[08:28:39.803]                       }
[08:28:39.803]                       invisible(muffled)
[08:28:39.803]                     }
[08:28:39.803]                     muffleCondition(cond, pattern = "^muffle")
[08:28:39.803]                   }
[08:28:39.803]                 }
[08:28:39.803]                 else {
[08:28:39.803]                   if (TRUE) {
[08:28:39.803]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:39.803]                     {
[08:28:39.803]                       inherits <- base::inherits
[08:28:39.803]                       invokeRestart <- base::invokeRestart
[08:28:39.803]                       is.null <- base::is.null
[08:28:39.803]                       muffled <- FALSE
[08:28:39.803]                       if (inherits(cond, "message")) {
[08:28:39.803]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:39.803]                         if (muffled) 
[08:28:39.803]                           invokeRestart("muffleMessage")
[08:28:39.803]                       }
[08:28:39.803]                       else if (inherits(cond, "warning")) {
[08:28:39.803]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:39.803]                         if (muffled) 
[08:28:39.803]                           invokeRestart("muffleWarning")
[08:28:39.803]                       }
[08:28:39.803]                       else if (inherits(cond, "condition")) {
[08:28:39.803]                         if (!is.null(pattern)) {
[08:28:39.803]                           computeRestarts <- base::computeRestarts
[08:28:39.803]                           grepl <- base::grepl
[08:28:39.803]                           restarts <- computeRestarts(cond)
[08:28:39.803]                           for (restart in restarts) {
[08:28:39.803]                             name <- restart$name
[08:28:39.803]                             if (is.null(name)) 
[08:28:39.803]                               next
[08:28:39.803]                             if (!grepl(pattern, name)) 
[08:28:39.803]                               next
[08:28:39.803]                             invokeRestart(restart)
[08:28:39.803]                             muffled <- TRUE
[08:28:39.803]                             break
[08:28:39.803]                           }
[08:28:39.803]                         }
[08:28:39.803]                       }
[08:28:39.803]                       invisible(muffled)
[08:28:39.803]                     }
[08:28:39.803]                     muffleCondition(cond, pattern = "^muffle")
[08:28:39.803]                   }
[08:28:39.803]                 }
[08:28:39.803]             }
[08:28:39.803]         }))
[08:28:39.803]     }, error = function(ex) {
[08:28:39.803]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:39.803]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:39.803]                 ...future.rng), started = ...future.startTime, 
[08:28:39.803]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:39.803]             version = "1.8"), class = "FutureResult")
[08:28:39.803]     }, finally = {
[08:28:39.803]         if (!identical(...future.workdir, getwd())) 
[08:28:39.803]             setwd(...future.workdir)
[08:28:39.803]         {
[08:28:39.803]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:39.803]                 ...future.oldOptions$nwarnings <- NULL
[08:28:39.803]             }
[08:28:39.803]             base::options(...future.oldOptions)
[08:28:39.803]             if (.Platform$OS.type == "windows") {
[08:28:39.803]                 old_names <- names(...future.oldEnvVars)
[08:28:39.803]                 envs <- base::Sys.getenv()
[08:28:39.803]                 names <- names(envs)
[08:28:39.803]                 common <- intersect(names, old_names)
[08:28:39.803]                 added <- setdiff(names, old_names)
[08:28:39.803]                 removed <- setdiff(old_names, names)
[08:28:39.803]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:39.803]                   envs[common]]
[08:28:39.803]                 NAMES <- toupper(changed)
[08:28:39.803]                 args <- list()
[08:28:39.803]                 for (kk in seq_along(NAMES)) {
[08:28:39.803]                   name <- changed[[kk]]
[08:28:39.803]                   NAME <- NAMES[[kk]]
[08:28:39.803]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.803]                     next
[08:28:39.803]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:39.803]                 }
[08:28:39.803]                 NAMES <- toupper(added)
[08:28:39.803]                 for (kk in seq_along(NAMES)) {
[08:28:39.803]                   name <- added[[kk]]
[08:28:39.803]                   NAME <- NAMES[[kk]]
[08:28:39.803]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.803]                     next
[08:28:39.803]                   args[[name]] <- ""
[08:28:39.803]                 }
[08:28:39.803]                 NAMES <- toupper(removed)
[08:28:39.803]                 for (kk in seq_along(NAMES)) {
[08:28:39.803]                   name <- removed[[kk]]
[08:28:39.803]                   NAME <- NAMES[[kk]]
[08:28:39.803]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.803]                     next
[08:28:39.803]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:39.803]                 }
[08:28:39.803]                 if (length(args) > 0) 
[08:28:39.803]                   base::do.call(base::Sys.setenv, args = args)
[08:28:39.803]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:39.803]             }
[08:28:39.803]             else {
[08:28:39.803]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:39.803]             }
[08:28:39.803]             {
[08:28:39.803]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:39.803]                   0L) {
[08:28:39.803]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:39.803]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:39.803]                   base::options(opts)
[08:28:39.803]                 }
[08:28:39.803]                 {
[08:28:39.803]                   {
[08:28:39.803]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:39.803]                     NULL
[08:28:39.803]                   }
[08:28:39.803]                   options(future.plan = NULL)
[08:28:39.803]                   if (is.na(NA_character_)) 
[08:28:39.803]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:39.803]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:39.803]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:39.803]                     .init = FALSE)
[08:28:39.803]                 }
[08:28:39.803]             }
[08:28:39.803]         }
[08:28:39.803]     })
[08:28:39.803]     if (TRUE) {
[08:28:39.803]         base::sink(type = "output", split = FALSE)
[08:28:39.803]         if (TRUE) {
[08:28:39.803]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:39.803]         }
[08:28:39.803]         else {
[08:28:39.803]             ...future.result["stdout"] <- base::list(NULL)
[08:28:39.803]         }
[08:28:39.803]         base::close(...future.stdout)
[08:28:39.803]         ...future.stdout <- NULL
[08:28:39.803]     }
[08:28:39.803]     ...future.result$conditions <- ...future.conditions
[08:28:39.803]     ...future.result$finished <- base::Sys.time()
[08:28:39.803]     ...future.result
[08:28:39.803] }
[08:28:39.805] assign_globals() ...
[08:28:39.805] List of 1
[08:28:39.805]  $ data:'data.frame':	3 obs. of  2 variables:
[08:28:39.805]   ..$ a: int [1:3] 1 2 3
[08:28:39.805]   ..$ b: int [1:3] 3 2 1
[08:28:39.805]  - attr(*, "where")=List of 1
[08:28:39.805]   ..$ data:<environment: R_EmptyEnv> 
[08:28:39.805]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:39.805]  - attr(*, "resolved")= logi FALSE
[08:28:39.805]  - attr(*, "total_size")= num 356
[08:28:39.805]  - attr(*, "already-done")= logi TRUE
[08:28:39.809] - copied ‘data’ to environment
[08:28:39.809] assign_globals() ... done
[08:28:39.810] requestCore(): workers = 2
[08:28:39.812] MulticoreFuture started
[08:28:39.813] - Launch lazy future ... done
[08:28:39.813] run() for ‘MulticoreFuture’ ... done
[08:28:39.813] result() for MulticoreFuture ...
[08:28:39.814] plan(): Setting new future strategy stack:
[08:28:39.814] List of future strategies:
[08:28:39.814] 1. multicore:
[08:28:39.814]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:39.814]    - tweaked: FALSE
[08:28:39.814]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:39.818] plan(): nbrOfWorkers() = 1
[08:28:39.847] plan(): Setting new future strategy stack:
[08:28:39.848] List of future strategies:
[08:28:39.848] 1. multicore:
[08:28:39.848]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:39.848]    - tweaked: FALSE
[08:28:39.848]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:39.848] 2. multicore:
[08:28:39.848]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:39.848]    - tweaked: FALSE
[08:28:39.848]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:39.850] plan(): nbrOfWorkers() = 2
[08:28:39.851] result() for MulticoreFuture ...
[08:28:39.851] result() for MulticoreFuture ... done
[08:28:39.851] signalConditions() ...
[08:28:39.852]  - include = ‘immediateCondition’
[08:28:39.852]  - exclude = 
[08:28:39.852]  - resignal = FALSE
[08:28:39.852]  - Number of conditions: 52
[08:28:39.852] signalConditions() ... done
[08:28:39.852] result() for MulticoreFuture ... done
[08:28:39.852] result() for MulticoreFuture ...
[08:28:39.853] result() for MulticoreFuture ... done
[08:28:39.853] signalConditions() ...
[08:28:39.853]  - include = ‘immediateCondition’
[08:28:39.853]  - exclude = 
[08:28:39.853]  - resignal = FALSE
[08:28:39.853]  - Number of conditions: 52
[08:28:39.853] signalConditions() ... done
[08:28:39.853] Future state: ‘finished’
[08:28:39.854] result() for MulticoreFuture ...
[08:28:39.854] result() for MulticoreFuture ... done
[08:28:39.854] signalConditions() ...
[08:28:39.854]  - include = ‘condition’
[08:28:39.854]  - exclude = ‘immediateCondition’
[08:28:39.854]  - resignal = TRUE
[08:28:39.854]  - Number of conditions: 52
[08:28:39.854]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.819] getGlobalsAndPackages() ...
[08:28:39.855]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.820] Searching for globals...
[08:28:39.855]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.822] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[08:28:39.855]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.822] Searching for globals ... DONE
[08:28:39.855]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.822] Resolving globals: FALSE
[08:28:39.855]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.823] The total size of the 1 globals is 356 bytes (356 bytes)
[08:28:39.856]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.824] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[08:28:39.856]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.824] - globals: [1] ‘data’
[08:28:39.856]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.824] 
[08:28:39.856]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.824] getGlobalsAndPackages() ... DONE
[08:28:39.856]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.825] run() for ‘Future’ ...
[08:28:39.856]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.825] - state: ‘created’
[08:28:39.857]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.826] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:39.857]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.828] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:39.857]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.828] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:39.857]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.829]   - Field: ‘label’
[08:28:39.857]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.829]   - Field: ‘local’
[08:28:39.857]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.829]   - Field: ‘owner’
[08:28:39.857]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.829]   - Field: ‘envir’
[08:28:39.858]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.829]   - Field: ‘packages’
[08:28:39.858]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.830]   - Field: ‘gc’
[08:28:39.858]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.830]   - Field: ‘conditions’
[08:28:39.858]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.830]   - Field: ‘expr’
[08:28:39.858]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.830]   - Field: ‘uuid’
[08:28:39.858]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.830]   - Field: ‘seed’
[08:28:39.859]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.831]   - Field: ‘version’
[08:28:39.859]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.831]   - Field: ‘result’
[08:28:39.859]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.831]   - Field: ‘asynchronous’
[08:28:39.859]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.831]   - Field: ‘calls’
[08:28:39.859]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.831]   - Field: ‘globals’
[08:28:39.859]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.832]   - Field: ‘stdout’
[08:28:39.860]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.832]   - Field: ‘earlySignal’
[08:28:39.860]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.832]   - Field: ‘lazy’
[08:28:39.860]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.832]   - Field: ‘state’
[08:28:39.860]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.832] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:39.860]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.832] - Launch lazy future ...
[08:28:39.860]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.833] Packages needed by the future expression (n = 0): <none>
[08:28:39.860]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.833] Packages needed by future strategies (n = 0): <none>
[08:28:39.861]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.834] {
[08:28:39.834]     {
[08:28:39.834]         {
[08:28:39.834]             ...future.startTime <- base::Sys.time()
[08:28:39.834]             {
[08:28:39.834]                 {
[08:28:39.834]                   {
[08:28:39.834]                     base::local({
[08:28:39.834]                       has_future <- base::requireNamespace("future", 
[08:28:39.834]                         quietly = TRUE)
[08:28:39.834]                       if (has_future) {
[08:28:39.834]                         ns <- base::getNamespace("future")
[08:28:39.834]                         version <- ns[[".package"]][["version"]]
[08:28:39.834]                         if (is.null(version)) 
[08:28:39.834]                           version <- utils::packageVersion("future")
[08:28:39.834]                       }
[08:28:39.834]                       else {
[08:28:39.834]                         version <- NULL
[08:28:39.834]                       }
[08:28:39.834]                       if (!has_future || version < "1.8.0") {
[08:28:39.834]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:39.834]                           "", base::R.version$version.string), 
[08:28:39.834]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:39.834]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:39.834]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:39.834]                             "release", "version")], collapse = " "), 
[08:28:39.834]                           hostname = base::Sys.info()[["nodename"]])
[08:28:39.834]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:39.834]                           info)
[08:28:39.834]                         info <- base::paste(info, collapse = "; ")
[08:28:39.834]                         if (!has_future) {
[08:28:39.834]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:39.834]                             info)
[08:28:39.834]                         }
[08:28:39.834]                         else {
[08:28:39.834]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:39.834]                             info, version)
[08:28:39.834]                         }
[08:28:39.834]                         base::stop(msg)
[08:28:39.834]                       }
[08:28:39.834]                     })
[08:28:39.834]                   }
[08:28:39.834]                   ...future.strategy.old <- future::plan("list")
[08:28:39.834]                   options(future.plan = NULL)
[08:28:39.834]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:39.834]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:39.834]                 }
[08:28:39.834]                 ...future.workdir <- getwd()
[08:28:39.834]             }
[08:28:39.834]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:39.834]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:39.834]         }
[08:28:39.834]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:39.834]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:39.834]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:39.834]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:39.834]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:39.834]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:39.834]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:39.834]             base::names(...future.oldOptions))
[08:28:39.834]     }
[08:28:39.834]     if (FALSE) {
[08:28:39.834]     }
[08:28:39.834]     else {
[08:28:39.834]         if (TRUE) {
[08:28:39.834]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:39.834]                 open = "w")
[08:28:39.834]         }
[08:28:39.834]         else {
[08:28:39.834]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:39.834]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:39.834]         }
[08:28:39.834]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:39.834]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:39.834]             base::sink(type = "output", split = FALSE)
[08:28:39.834]             base::close(...future.stdout)
[08:28:39.834]         }, add = TRUE)
[08:28:39.834]     }
[08:28:39.834]     ...future.frame <- base::sys.nframe()
[08:28:39.834]     ...future.conditions <- base::list()
[08:28:39.834]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:39.834]     if (FALSE) {
[08:28:39.834]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:39.834]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:39.834]     }
[08:28:39.834]     ...future.result <- base::tryCatch({
[08:28:39.834]         base::withCallingHandlers({
[08:28:39.834]             ...future.value <- base::withVisible(base::local(subset(data, 
[08:28:39.834]                 a == 2)))
[08:28:39.834]             future::FutureResult(value = ...future.value$value, 
[08:28:39.834]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:39.834]                   ...future.rng), globalenv = if (FALSE) 
[08:28:39.834]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:39.834]                     ...future.globalenv.names))
[08:28:39.834]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:39.834]         }, condition = base::local({
[08:28:39.834]             c <- base::c
[08:28:39.834]             inherits <- base::inherits
[08:28:39.834]             invokeRestart <- base::invokeRestart
[08:28:39.834]             length <- base::length
[08:28:39.834]             list <- base::list
[08:28:39.834]             seq.int <- base::seq.int
[08:28:39.834]             signalCondition <- base::signalCondition
[08:28:39.834]             sys.calls <- base::sys.calls
[08:28:39.834]             `[[` <- base::`[[`
[08:28:39.834]             `+` <- base::`+`
[08:28:39.834]             `<<-` <- base::`<<-`
[08:28:39.834]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:39.834]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:39.834]                   3L)]
[08:28:39.834]             }
[08:28:39.834]             function(cond) {
[08:28:39.834]                 is_error <- inherits(cond, "error")
[08:28:39.834]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:39.834]                   NULL)
[08:28:39.834]                 if (is_error) {
[08:28:39.834]                   sessionInformation <- function() {
[08:28:39.834]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:39.834]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:39.834]                       search = base::search(), system = base::Sys.info())
[08:28:39.834]                   }
[08:28:39.834]                   ...future.conditions[[length(...future.conditions) + 
[08:28:39.834]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:39.834]                     cond$call), session = sessionInformation(), 
[08:28:39.834]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:39.834]                   signalCondition(cond)
[08:28:39.834]                 }
[08:28:39.834]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:39.834]                 "immediateCondition"))) {
[08:28:39.834]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:39.834]                   ...future.conditions[[length(...future.conditions) + 
[08:28:39.834]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:39.834]                   if (TRUE && !signal) {
[08:28:39.834]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:39.834]                     {
[08:28:39.834]                       inherits <- base::inherits
[08:28:39.834]                       invokeRestart <- base::invokeRestart
[08:28:39.834]                       is.null <- base::is.null
[08:28:39.834]                       muffled <- FALSE
[08:28:39.834]                       if (inherits(cond, "message")) {
[08:28:39.834]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:39.834]                         if (muffled) 
[08:28:39.834]                           invokeRestart("muffleMessage")
[08:28:39.834]                       }
[08:28:39.834]                       else if (inherits(cond, "warning")) {
[08:28:39.834]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:39.834]                         if (muffled) 
[08:28:39.834]                           invokeRestart("muffleWarning")
[08:28:39.834]                       }
[08:28:39.834]                       else if (inherits(cond, "condition")) {
[08:28:39.834]                         if (!is.null(pattern)) {
[08:28:39.834]                           computeRestarts <- base::computeRestarts
[08:28:39.834]                           grepl <- base::grepl
[08:28:39.834]                           restarts <- computeRestarts(cond)
[08:28:39.834]                           for (restart in restarts) {
[08:28:39.834]                             name <- restart$name
[08:28:39.834]                             if (is.null(name)) 
[08:28:39.834]                               next
[08:28:39.834]                             if (!grepl(pattern, name)) 
[08:28:39.834]                               next
[08:28:39.834]                             invokeRestart(restart)
[08:28:39.834]                             muffled <- TRUE
[08:28:39.834]                             break
[08:28:39.834]                           }
[08:28:39.834]                         }
[08:28:39.834]                       }
[08:28:39.834]                       invisible(muffled)
[08:28:39.834]                     }
[08:28:39.834]                     muffleCondition(cond, pattern = "^muffle")
[08:28:39.834]                   }
[08:28:39.834]                 }
[08:28:39.834]                 else {
[08:28:39.834]                   if (TRUE) {
[08:28:39.834]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:39.834]                     {
[08:28:39.834]                       inherits <- base::inherits
[08:28:39.834]                       invokeRestart <- base::invokeRestart
[08:28:39.834]                       is.null <- base::is.null
[08:28:39.834]                       muffled <- FALSE
[08:28:39.834]                       if (inherits(cond, "message")) {
[08:28:39.834]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:39.834]                         if (muffled) 
[08:28:39.834]                           invokeRestart("muffleMessage")
[08:28:39.834]                       }
[08:28:39.834]                       else if (inherits(cond, "warning")) {
[08:28:39.834]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:39.834]                         if (muffled) 
[08:28:39.834]                           invokeRestart("muffleWarning")
[08:28:39.834]                       }
[08:28:39.834]                       else if (inherits(cond, "condition")) {
[08:28:39.834]                         if (!is.null(pattern)) {
[08:28:39.834]                           computeRestarts <- base::computeRestarts
[08:28:39.834]                           grepl <- base::grepl
[08:28:39.834]                           restarts <- computeRestarts(cond)
[08:28:39.834]                           for (restart in restarts) {
[08:28:39.834]                             name <- restart$name
[08:28:39.834]                             if (is.null(name)) 
[08:28:39.834]                               next
[08:28:39.834]                             if (!grepl(pattern, name)) 
[08:28:39.834]                               next
[08:28:39.834]                             invokeRestart(restart)
[08:28:39.834]                             muffled <- TRUE
[08:28:39.834]                             break
[08:28:39.834]                           }
[08:28:39.834]                         }
[08:28:39.834]                       }
[08:28:39.834]                       invisible(muffled)
[08:28:39.834]                     }
[08:28:39.834]                     muffleCondition(cond, pattern = "^muffle")
[08:28:39.834]                   }
[08:28:39.834]                 }
[08:28:39.834]             }
[08:28:39.834]         }))
[08:28:39.834]     }, error = function(ex) {
[08:28:39.834]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:39.834]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:39.834]                 ...future.rng), started = ...future.startTime, 
[08:28:39.834]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:39.834]             version = "1.8"), class = "FutureResult")
[08:28:39.834]     }, finally = {
[08:28:39.834]         if (!identical(...future.workdir, getwd())) 
[08:28:39.834]             setwd(...future.workdir)
[08:28:39.834]         {
[08:28:39.834]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:39.834]                 ...future.oldOptions$nwarnings <- NULL
[08:28:39.834]             }
[08:28:39.834]             base::options(...future.oldOptions)
[08:28:39.834]             if (.Platform$OS.type == "windows") {
[08:28:39.834]                 old_names <- names(...future.oldEnvVars)
[08:28:39.834]                 envs <- base::Sys.getenv()
[08:28:39.834]                 names <- names(envs)
[08:28:39.834]                 common <- intersect(names, old_names)
[08:28:39.834]                 added <- setdiff(names, old_names)
[08:28:39.834]                 removed <- setdiff(old_names, names)
[08:28:39.834]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:39.834]                   envs[common]]
[08:28:39.834]                 NAMES <- toupper(changed)
[08:28:39.834]                 args <- list()
[08:28:39.834]                 for (kk in seq_along(NAMES)) {
[08:28:39.834]                   name <- changed[[kk]]
[08:28:39.834]                   NAME <- NAMES[[kk]]
[08:28:39.834]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.834]                     next
[08:28:39.834]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:39.834]                 }
[08:28:39.834]                 NAMES <- toupper(added)
[08:28:39.834]                 for (kk in seq_along(NAMES)) {
[08:28:39.834]                   name <- added[[kk]]
[08:28:39.834]                   NAME <- NAMES[[kk]]
[08:28:39.834]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.834]                     next
[08:28:39.834]                   args[[name]] <- ""
[08:28:39.834]                 }
[08:28:39.834]                 NAMES <- toupper(removed)
[08:28:39.834]                 for (kk in seq_along(NAMES)) {
[08:28:39.834]                   name <- removed[[kk]]
[08:28:39.834]                   NAME <- NAMES[[kk]]
[08:28:39.834]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.834]                     next
[08:28:39.834]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:39.834]                 }
[08:28:39.834]                 if (length(args) > 0) 
[08:28:39.834]                   base::do.call(base::Sys.setenv, args = args)
[08:28:39.834]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:39.834]             }
[08:28:39.834]             else {
[08:28:39.834]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:39.834]             }
[08:28:39.834]             {
[08:28:39.834]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:39.834]                   0L) {
[08:28:39.834]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:39.834]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:39.834]                   base::options(opts)
[08:28:39.834]                 }
[08:28:39.834]                 {
[08:28:39.834]                   {
[08:28:39.834]                     NULL
[08:28:39.834]                     RNGkind("Mersenne-Twister")
[08:28:39.834]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:39.834]                       inherits = FALSE)
[08:28:39.834]                   }
[08:28:39.834]                   options(future.plan = NULL)
[08:28:39.834]                   if (is.na(NA_character_)) 
[08:28:39.834]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:39.834]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:39.834]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:39.834]                     .init = FALSE)
[08:28:39.834]                 }
[08:28:39.834]             }
[08:28:39.834]         }
[08:28:39.834]     })
[08:28:39.834]     if (TRUE) {
[08:28:39.834]         base::sink(type = "output", split = FALSE)
[08:28:39.834]         if (TRUE) {
[08:28:39.834]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:39.834]         }
[08:28:39.834]         else {
[08:28:39.834]             ...future.result["stdout"] <- base::list(NULL)
[08:28:39.834]         }
[08:28:39.834]         base::close(...future.stdout)
[08:28:39.834]         ...future.stdout <- NULL
[08:28:39.834]     }
[08:28:39.834]     ...future.result$conditions <- ...future.conditions
[08:28:39.834]     ...future.result$finished <- base::Sys.time()
[08:28:39.834]     ...future.result
[08:28:39.834] }
[08:28:39.861]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.836] assign_globals() ...
[08:28:39.861]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.836] List of 1
[08:28:39.836]  $ data:'data.frame':	3 obs. of  2 variables:
[08:28:39.836]   ..$ a: int [1:3] 1 2 3
[08:28:39.836]   ..$ b: int [1:3] 3 2 1
[08:28:39.836]  - attr(*, "where")=List of 1
[08:28:39.836]   ..$ data:<environment: R_EmptyEnv> 
[08:28:39.836]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:39.836]  - attr(*, "resolved")= logi FALSE
[08:28:39.836]  - attr(*, "total_size")= num 356
[08:28:39.836]  - attr(*, "already-done")= logi TRUE
[08:28:39.861]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.841] - copied ‘data’ to environment
[08:28:39.861]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.841] assign_globals() ... done
[08:28:39.861]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.842] plan(): Setting new future strategy stack:
[08:28:39.862]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.842] List of future strategies:
[08:28:39.842] 1. sequential:
[08:28:39.842]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:39.842]    - tweaked: FALSE
[08:28:39.842]    - call: NULL
[08:28:39.862]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.843] plan(): nbrOfWorkers() = 1
[08:28:39.862]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.844] plan(): Setting new future strategy stack:
[08:28:39.862]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.844] List of future strategies:
[08:28:39.844] 1. multicore:
[08:28:39.844]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:39.844]    - tweaked: FALSE
[08:28:39.844]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:39.862]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.846] plan(): nbrOfWorkers() = 1
[08:28:39.862]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.846] SequentialFuture started (and completed)
[08:28:39.862]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.847] - Launch lazy future ... done
[08:28:39.863]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.847] run() for ‘SequentialFuture’ ... done
[08:28:39.863] signalConditions() ... done
- plan(list('multicore', 'multicore')) ... DONE
- plan(list('multicore', 'multisession')) ...
[08:28:39.863] plan(): Setting new future strategy stack:
[08:28:39.863] List of future strategies:
[08:28:39.863] 1. multicore:
[08:28:39.863]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:39.863]    - tweaked: FALSE
[08:28:39.863]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:39.863] 2. multisession:
[08:28:39.863]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:28:39.863]    - tweaked: FALSE
[08:28:39.863]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:39.866] plan(): nbrOfWorkers() = 2
[08:28:39.866] getGlobalsAndPackages() ...
[08:28:39.866] Searching for globals...
[08:28:39.885] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[08:28:39.885] Searching for globals ... DONE
[08:28:39.885] Resolving globals: FALSE
[08:28:39.886] The total size of the 2 globals is 11.73 KiB (12016 bytes)
[08:28:39.887] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 11.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (11.68 KiB of class ‘list’) and ‘strategy2’ (51 bytes of class ‘character’)
[08:28:39.887] - globals: [2] ‘nested’, ‘strategy2’
[08:28:39.887] - packages: [1] ‘future’
[08:28:39.887] getGlobalsAndPackages() ... DONE
[08:28:39.888] run() for ‘Future’ ...
[08:28:39.888] - state: ‘created’
[08:28:39.888] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:39.890] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:39.890] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:39.890]   - Field: ‘label’
[08:28:39.890]   - Field: ‘local’
[08:28:39.890]   - Field: ‘owner’
[08:28:39.891]   - Field: ‘envir’
[08:28:39.891]   - Field: ‘workers’
[08:28:39.891]   - Field: ‘packages’
[08:28:39.891]   - Field: ‘gc’
[08:28:39.891]   - Field: ‘job’
[08:28:39.891]   - Field: ‘conditions’
[08:28:39.891]   - Field: ‘expr’
[08:28:39.891]   - Field: ‘uuid’
[08:28:39.891]   - Field: ‘seed’
[08:28:39.891]   - Field: ‘version’
[08:28:39.892]   - Field: ‘result’
[08:28:39.892]   - Field: ‘asynchronous’
[08:28:39.892]   - Field: ‘calls’
[08:28:39.892]   - Field: ‘globals’
[08:28:39.892]   - Field: ‘stdout’
[08:28:39.892]   - Field: ‘earlySignal’
[08:28:39.892]   - Field: ‘lazy’
[08:28:39.892]   - Field: ‘state’
[08:28:39.892] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:39.893] - Launch lazy future ...
[08:28:39.893] Packages needed by the future expression (n = 1): ‘future’
[08:28:39.893] Packages needed by future strategies (n = 1): ‘future’
[08:28:39.894] {
[08:28:39.894]     {
[08:28:39.894]         {
[08:28:39.894]             ...future.startTime <- base::Sys.time()
[08:28:39.894]             {
[08:28:39.894]                 {
[08:28:39.894]                   {
[08:28:39.894]                     {
[08:28:39.894]                       {
[08:28:39.894]                         base::local({
[08:28:39.894]                           has_future <- base::requireNamespace("future", 
[08:28:39.894]                             quietly = TRUE)
[08:28:39.894]                           if (has_future) {
[08:28:39.894]                             ns <- base::getNamespace("future")
[08:28:39.894]                             version <- ns[[".package"]][["version"]]
[08:28:39.894]                             if (is.null(version)) 
[08:28:39.894]                               version <- utils::packageVersion("future")
[08:28:39.894]                           }
[08:28:39.894]                           else {
[08:28:39.894]                             version <- NULL
[08:28:39.894]                           }
[08:28:39.894]                           if (!has_future || version < "1.8.0") {
[08:28:39.894]                             info <- base::c(r_version = base::gsub("R version ", 
[08:28:39.894]                               "", base::R.version$version.string), 
[08:28:39.894]                               platform = base::sprintf("%s (%s-bit)", 
[08:28:39.894]                                 base::R.version$platform, 8 * 
[08:28:39.894]                                   base::.Machine$sizeof.pointer), 
[08:28:39.894]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:39.894]                                 "release", "version")], collapse = " "), 
[08:28:39.894]                               hostname = base::Sys.info()[["nodename"]])
[08:28:39.894]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:28:39.894]                               info)
[08:28:39.894]                             info <- base::paste(info, collapse = "; ")
[08:28:39.894]                             if (!has_future) {
[08:28:39.894]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:39.894]                                 info)
[08:28:39.894]                             }
[08:28:39.894]                             else {
[08:28:39.894]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:39.894]                                 info, version)
[08:28:39.894]                             }
[08:28:39.894]                             base::stop(msg)
[08:28:39.894]                           }
[08:28:39.894]                         })
[08:28:39.894]                       }
[08:28:39.894]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:39.894]                       base::options(mc.cores = 1L)
[08:28:39.894]                     }
[08:28:39.894]                     base::local({
[08:28:39.894]                       for (pkg in "future") {
[08:28:39.894]                         base::loadNamespace(pkg)
[08:28:39.894]                         base::library(pkg, character.only = TRUE)
[08:28:39.894]                       }
[08:28:39.894]                     })
[08:28:39.894]                   }
[08:28:39.894]                   ...future.strategy.old <- future::plan("list")
[08:28:39.894]                   options(future.plan = NULL)
[08:28:39.894]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:39.894]                   future::plan(list(b = function (..., workers = availableCores(), 
[08:28:39.894]                     lazy = FALSE, rscript_libs = .libPaths(), 
[08:28:39.894]                     envir = parent.frame()) 
[08:28:39.894]                   {
[08:28:39.894]                     if (is.function(workers)) 
[08:28:39.894]                       workers <- workers()
[08:28:39.894]                     workers <- structure(as.integer(workers), 
[08:28:39.894]                       class = class(workers))
[08:28:39.894]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[08:28:39.894]                       workers >= 1)
[08:28:39.894]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[08:28:39.894]                       return(sequential(..., lazy = TRUE, envir = envir))
[08:28:39.894]                     }
[08:28:39.894]                     future <- MultisessionFuture(..., workers = workers, 
[08:28:39.894]                       lazy = lazy, rscript_libs = rscript_libs, 
[08:28:39.894]                       envir = envir)
[08:28:39.894]                     if (!future$lazy) 
[08:28:39.894]                       future <- run(future)
[08:28:39.894]                     invisible(future)
[08:28:39.894]                   }), .cleanup = FALSE, .init = FALSE)
[08:28:39.894]                 }
[08:28:39.894]                 ...future.workdir <- getwd()
[08:28:39.894]             }
[08:28:39.894]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:39.894]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:39.894]         }
[08:28:39.894]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:39.894]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:39.894]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:39.894]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:39.894]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:39.894]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:39.894]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:39.894]             base::names(...future.oldOptions))
[08:28:39.894]     }
[08:28:39.894]     if (FALSE) {
[08:28:39.894]     }
[08:28:39.894]     else {
[08:28:39.894]         if (TRUE) {
[08:28:39.894]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:39.894]                 open = "w")
[08:28:39.894]         }
[08:28:39.894]         else {
[08:28:39.894]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:39.894]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:39.894]         }
[08:28:39.894]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:39.894]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:39.894]             base::sink(type = "output", split = FALSE)
[08:28:39.894]             base::close(...future.stdout)
[08:28:39.894]         }, add = TRUE)
[08:28:39.894]     }
[08:28:39.894]     ...future.frame <- base::sys.nframe()
[08:28:39.894]     ...future.conditions <- base::list()
[08:28:39.894]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:39.894]     if (FALSE) {
[08:28:39.894]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:39.894]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:39.894]     }
[08:28:39.894]     ...future.result <- base::tryCatch({
[08:28:39.894]         base::withCallingHandlers({
[08:28:39.894]             ...future.value <- base::withVisible(base::local({
[08:28:39.894]                 withCallingHandlers({
[08:28:39.894]                   {
[08:28:39.894]                     a <- 1L
[08:28:39.894]                     plan_a <- unclass(future::plan("list"))
[08:28:39.894]                     nested_a <- nested[-1]
[08:28:39.894]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[08:28:39.894]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[08:28:39.894]                       strategy2))
[08:28:39.894]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[08:28:39.894]                       "init") <- NULL
[08:28:39.894]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[08:28:39.894]                       "init") <- NULL
[08:28:39.894]                     stopifnot(all.equal(plan_a, nested_a))
[08:28:39.894]                     y %<-% {
[08:28:39.894]                       b <- 2L
[08:28:39.894]                       plan_b <- future::plan("list")
[08:28:39.894]                       nested_b <- nested_a[-1]
[08:28:39.894]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[08:28:39.894]                         1L, inherits(plan_b[[1]], "future"), 
[08:28:39.894]                         inherits(future::plan("next"), "sequential"))
[08:28:39.894]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[08:28:39.894]                         b = b, nested_b = nested_b, plan_b = plan_b)
[08:28:39.894]                     }
[08:28:39.894]                     y
[08:28:39.894]                   }
[08:28:39.894]                 }, immediateCondition = function(cond) {
[08:28:39.894]                   save_rds <- function (object, pathname, ...) 
[08:28:39.894]                   {
[08:28:39.894]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:39.894]                     if (file_test("-f", pathname_tmp)) {
[08:28:39.894]                       fi_tmp <- file.info(pathname_tmp)
[08:28:39.894]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:39.894]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:39.894]                         fi_tmp[["mtime"]])
[08:28:39.894]                     }
[08:28:39.894]                     tryCatch({
[08:28:39.894]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:39.894]                     }, error = function(ex) {
[08:28:39.894]                       msg <- conditionMessage(ex)
[08:28:39.894]                       fi_tmp <- file.info(pathname_tmp)
[08:28:39.894]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:39.894]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:39.894]                         fi_tmp[["mtime"]], msg)
[08:28:39.894]                       ex$message <- msg
[08:28:39.894]                       stop(ex)
[08:28:39.894]                     })
[08:28:39.894]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:39.894]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:39.894]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:39.894]                       fi_tmp <- file.info(pathname_tmp)
[08:28:39.894]                       fi <- file.info(pathname)
[08:28:39.894]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:39.894]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:39.894]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:39.894]                         fi[["size"]], fi[["mtime"]])
[08:28:39.894]                       stop(msg)
[08:28:39.894]                     }
[08:28:39.894]                     invisible(pathname)
[08:28:39.894]                   }
[08:28:39.894]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:39.894]                     rootPath = tempdir()) 
[08:28:39.894]                   {
[08:28:39.894]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:39.894]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:39.894]                       tmpdir = path, fileext = ".rds")
[08:28:39.894]                     save_rds(obj, file)
[08:28:39.894]                   }
[08:28:39.894]                   saveImmediateCondition(cond, path = "/tmp/RtmphjARvB/.future/immediateConditions")
[08:28:39.894]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:39.894]                   {
[08:28:39.894]                     inherits <- base::inherits
[08:28:39.894]                     invokeRestart <- base::invokeRestart
[08:28:39.894]                     is.null <- base::is.null
[08:28:39.894]                     muffled <- FALSE
[08:28:39.894]                     if (inherits(cond, "message")) {
[08:28:39.894]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:39.894]                       if (muffled) 
[08:28:39.894]                         invokeRestart("muffleMessage")
[08:28:39.894]                     }
[08:28:39.894]                     else if (inherits(cond, "warning")) {
[08:28:39.894]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:39.894]                       if (muffled) 
[08:28:39.894]                         invokeRestart("muffleWarning")
[08:28:39.894]                     }
[08:28:39.894]                     else if (inherits(cond, "condition")) {
[08:28:39.894]                       if (!is.null(pattern)) {
[08:28:39.894]                         computeRestarts <- base::computeRestarts
[08:28:39.894]                         grepl <- base::grepl
[08:28:39.894]                         restarts <- computeRestarts(cond)
[08:28:39.894]                         for (restart in restarts) {
[08:28:39.894]                           name <- restart$name
[08:28:39.894]                           if (is.null(name)) 
[08:28:39.894]                             next
[08:28:39.894]                           if (!grepl(pattern, name)) 
[08:28:39.894]                             next
[08:28:39.894]                           invokeRestart(restart)
[08:28:39.894]                           muffled <- TRUE
[08:28:39.894]                           break
[08:28:39.894]                         }
[08:28:39.894]                       }
[08:28:39.894]                     }
[08:28:39.894]                     invisible(muffled)
[08:28:39.894]                   }
[08:28:39.894]                   muffleCondition(cond)
[08:28:39.894]                 })
[08:28:39.894]             }))
[08:28:39.894]             future::FutureResult(value = ...future.value$value, 
[08:28:39.894]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:39.894]                   ...future.rng), globalenv = if (FALSE) 
[08:28:39.894]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:39.894]                     ...future.globalenv.names))
[08:28:39.894]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:39.894]         }, condition = base::local({
[08:28:39.894]             c <- base::c
[08:28:39.894]             inherits <- base::inherits
[08:28:39.894]             invokeRestart <- base::invokeRestart
[08:28:39.894]             length <- base::length
[08:28:39.894]             list <- base::list
[08:28:39.894]             seq.int <- base::seq.int
[08:28:39.894]             signalCondition <- base::signalCondition
[08:28:39.894]             sys.calls <- base::sys.calls
[08:28:39.894]             `[[` <- base::`[[`
[08:28:39.894]             `+` <- base::`+`
[08:28:39.894]             `<<-` <- base::`<<-`
[08:28:39.894]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:39.894]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:39.894]                   3L)]
[08:28:39.894]             }
[08:28:39.894]             function(cond) {
[08:28:39.894]                 is_error <- inherits(cond, "error")
[08:28:39.894]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:39.894]                   NULL)
[08:28:39.894]                 if (is_error) {
[08:28:39.894]                   sessionInformation <- function() {
[08:28:39.894]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:39.894]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:39.894]                       search = base::search(), system = base::Sys.info())
[08:28:39.894]                   }
[08:28:39.894]                   ...future.conditions[[length(...future.conditions) + 
[08:28:39.894]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:39.894]                     cond$call), session = sessionInformation(), 
[08:28:39.894]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:39.894]                   signalCondition(cond)
[08:28:39.894]                 }
[08:28:39.894]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:39.894]                 "immediateCondition"))) {
[08:28:39.894]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:39.894]                   ...future.conditions[[length(...future.conditions) + 
[08:28:39.894]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:39.894]                   if (TRUE && !signal) {
[08:28:39.894]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:39.894]                     {
[08:28:39.894]                       inherits <- base::inherits
[08:28:39.894]                       invokeRestart <- base::invokeRestart
[08:28:39.894]                       is.null <- base::is.null
[08:28:39.894]                       muffled <- FALSE
[08:28:39.894]                       if (inherits(cond, "message")) {
[08:28:39.894]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:39.894]                         if (muffled) 
[08:28:39.894]                           invokeRestart("muffleMessage")
[08:28:39.894]                       }
[08:28:39.894]                       else if (inherits(cond, "warning")) {
[08:28:39.894]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:39.894]                         if (muffled) 
[08:28:39.894]                           invokeRestart("muffleWarning")
[08:28:39.894]                       }
[08:28:39.894]                       else if (inherits(cond, "condition")) {
[08:28:39.894]                         if (!is.null(pattern)) {
[08:28:39.894]                           computeRestarts <- base::computeRestarts
[08:28:39.894]                           grepl <- base::grepl
[08:28:39.894]                           restarts <- computeRestarts(cond)
[08:28:39.894]                           for (restart in restarts) {
[08:28:39.894]                             name <- restart$name
[08:28:39.894]                             if (is.null(name)) 
[08:28:39.894]                               next
[08:28:39.894]                             if (!grepl(pattern, name)) 
[08:28:39.894]                               next
[08:28:39.894]                             invokeRestart(restart)
[08:28:39.894]                             muffled <- TRUE
[08:28:39.894]                             break
[08:28:39.894]                           }
[08:28:39.894]                         }
[08:28:39.894]                       }
[08:28:39.894]                       invisible(muffled)
[08:28:39.894]                     }
[08:28:39.894]                     muffleCondition(cond, pattern = "^muffle")
[08:28:39.894]                   }
[08:28:39.894]                 }
[08:28:39.894]                 else {
[08:28:39.894]                   if (TRUE) {
[08:28:39.894]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:39.894]                     {
[08:28:39.894]                       inherits <- base::inherits
[08:28:39.894]                       invokeRestart <- base::invokeRestart
[08:28:39.894]                       is.null <- base::is.null
[08:28:39.894]                       muffled <- FALSE
[08:28:39.894]                       if (inherits(cond, "message")) {
[08:28:39.894]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:39.894]                         if (muffled) 
[08:28:39.894]                           invokeRestart("muffleMessage")
[08:28:39.894]                       }
[08:28:39.894]                       else if (inherits(cond, "warning")) {
[08:28:39.894]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:39.894]                         if (muffled) 
[08:28:39.894]                           invokeRestart("muffleWarning")
[08:28:39.894]                       }
[08:28:39.894]                       else if (inherits(cond, "condition")) {
[08:28:39.894]                         if (!is.null(pattern)) {
[08:28:39.894]                           computeRestarts <- base::computeRestarts
[08:28:39.894]                           grepl <- base::grepl
[08:28:39.894]                           restarts <- computeRestarts(cond)
[08:28:39.894]                           for (restart in restarts) {
[08:28:39.894]                             name <- restart$name
[08:28:39.894]                             if (is.null(name)) 
[08:28:39.894]                               next
[08:28:39.894]                             if (!grepl(pattern, name)) 
[08:28:39.894]                               next
[08:28:39.894]                             invokeRestart(restart)
[08:28:39.894]                             muffled <- TRUE
[08:28:39.894]                             break
[08:28:39.894]                           }
[08:28:39.894]                         }
[08:28:39.894]                       }
[08:28:39.894]                       invisible(muffled)
[08:28:39.894]                     }
[08:28:39.894]                     muffleCondition(cond, pattern = "^muffle")
[08:28:39.894]                   }
[08:28:39.894]                 }
[08:28:39.894]             }
[08:28:39.894]         }))
[08:28:39.894]     }, error = function(ex) {
[08:28:39.894]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:39.894]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:39.894]                 ...future.rng), started = ...future.startTime, 
[08:28:39.894]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:39.894]             version = "1.8"), class = "FutureResult")
[08:28:39.894]     }, finally = {
[08:28:39.894]         if (!identical(...future.workdir, getwd())) 
[08:28:39.894]             setwd(...future.workdir)
[08:28:39.894]         {
[08:28:39.894]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:39.894]                 ...future.oldOptions$nwarnings <- NULL
[08:28:39.894]             }
[08:28:39.894]             base::options(...future.oldOptions)
[08:28:39.894]             if (.Platform$OS.type == "windows") {
[08:28:39.894]                 old_names <- names(...future.oldEnvVars)
[08:28:39.894]                 envs <- base::Sys.getenv()
[08:28:39.894]                 names <- names(envs)
[08:28:39.894]                 common <- intersect(names, old_names)
[08:28:39.894]                 added <- setdiff(names, old_names)
[08:28:39.894]                 removed <- setdiff(old_names, names)
[08:28:39.894]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:39.894]                   envs[common]]
[08:28:39.894]                 NAMES <- toupper(changed)
[08:28:39.894]                 args <- list()
[08:28:39.894]                 for (kk in seq_along(NAMES)) {
[08:28:39.894]                   name <- changed[[kk]]
[08:28:39.894]                   NAME <- NAMES[[kk]]
[08:28:39.894]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.894]                     next
[08:28:39.894]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:39.894]                 }
[08:28:39.894]                 NAMES <- toupper(added)
[08:28:39.894]                 for (kk in seq_along(NAMES)) {
[08:28:39.894]                   name <- added[[kk]]
[08:28:39.894]                   NAME <- NAMES[[kk]]
[08:28:39.894]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.894]                     next
[08:28:39.894]                   args[[name]] <- ""
[08:28:39.894]                 }
[08:28:39.894]                 NAMES <- toupper(removed)
[08:28:39.894]                 for (kk in seq_along(NAMES)) {
[08:28:39.894]                   name <- removed[[kk]]
[08:28:39.894]                   NAME <- NAMES[[kk]]
[08:28:39.894]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.894]                     next
[08:28:39.894]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:39.894]                 }
[08:28:39.894]                 if (length(args) > 0) 
[08:28:39.894]                   base::do.call(base::Sys.setenv, args = args)
[08:28:39.894]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:39.894]             }
[08:28:39.894]             else {
[08:28:39.894]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:39.894]             }
[08:28:39.894]             {
[08:28:39.894]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:39.894]                   0L) {
[08:28:39.894]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:39.894]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:39.894]                   base::options(opts)
[08:28:39.894]                 }
[08:28:39.894]                 {
[08:28:39.894]                   {
[08:28:39.894]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:39.894]                     NULL
[08:28:39.894]                   }
[08:28:39.894]                   options(future.plan = NULL)
[08:28:39.894]                   if (is.na(NA_character_)) 
[08:28:39.894]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:39.894]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:39.894]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:39.894]                     .init = FALSE)
[08:28:39.894]                 }
[08:28:39.894]             }
[08:28:39.894]         }
[08:28:39.894]     })
[08:28:39.894]     if (TRUE) {
[08:28:39.894]         base::sink(type = "output", split = FALSE)
[08:28:39.894]         if (TRUE) {
[08:28:39.894]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:39.894]         }
[08:28:39.894]         else {
[08:28:39.894]             ...future.result["stdout"] <- base::list(NULL)
[08:28:39.894]         }
[08:28:39.894]         base::close(...future.stdout)
[08:28:39.894]         ...future.stdout <- NULL
[08:28:39.894]     }
[08:28:39.894]     ...future.result$conditions <- ...future.conditions
[08:28:39.894]     ...future.result$finished <- base::Sys.time()
[08:28:39.894]     ...future.result
[08:28:39.894] }
[08:28:39.897] assign_globals() ...
[08:28:39.897] List of 2
[08:28:39.897]  $ nested   :List of 2
[08:28:39.897]   ..$ a:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[08:28:39.897]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[08:28:39.897]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[08:28:39.897]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[08:28:39.897]     envir = parent.frame())  
[08:28:39.897]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[08:28:39.897]   .. ..- attr(*, "init")= logi TRUE
[08:28:39.897]   .. ..- attr(*, "cleanup")=function ()  
[08:28:39.897]   .. ..- attr(*, "untweakable")= chr "persistent"
[08:28:39.897]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[08:28:39.897]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[08:28:39.897]  $ strategy2: chr "multisession"
[08:28:39.897]  - attr(*, "where")=List of 2
[08:28:39.897]   ..$ nested   :<environment: R_EmptyEnv> 
[08:28:39.897]   ..$ strategy2:<environment: R_EmptyEnv> 
[08:28:39.897]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:39.897]  - attr(*, "resolved")= logi FALSE
[08:28:39.897]  - attr(*, "total_size")= num 12016
[08:28:39.897]  - attr(*, "already-done")= logi TRUE
[08:28:39.905] - copied ‘nested’ to environment
[08:28:39.906] - copied ‘strategy2’ to environment
[08:28:39.906] assign_globals() ... done
[08:28:39.906] requestCore(): workers = 2
[08:28:39.909] MulticoreFuture started
[08:28:39.909] - Launch lazy future ... done
[08:28:39.909] run() for ‘MulticoreFuture’ ... done
[08:28:39.910] result() for MulticoreFuture ...
[08:28:39.910] plan(): Setting new future strategy stack:
[08:28:39.911] List of future strategies:
[08:28:39.911] 1. multisession:
[08:28:39.911]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:28:39.911]    - tweaked: FALSE
[08:28:39.911]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:39.914] plan(): nbrOfWorkers() = 1
[08:28:39.958] plan(): Setting new future strategy stack:
[08:28:39.958] List of future strategies:
[08:28:39.958] 1. multicore:
[08:28:39.958]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:39.958]    - tweaked: FALSE
[08:28:39.958]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:39.958] 2. multisession:
[08:28:39.958]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:28:39.958]    - tweaked: FALSE
[08:28:39.958]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:39.960] plan(): nbrOfWorkers() = 2
[08:28:39.962] result() for MulticoreFuture ...
[08:28:39.962] result() for MulticoreFuture ... done
[08:28:39.962] signalConditions() ...
[08:28:39.962]  - include = ‘immediateCondition’
[08:28:39.962]  - exclude = 
[08:28:39.962]  - resignal = FALSE
[08:28:39.963]  - Number of conditions: 54
[08:28:39.963] signalConditions() ... done
[08:28:39.963] result() for MulticoreFuture ... done
[08:28:39.963] result() for MulticoreFuture ...
[08:28:39.963] result() for MulticoreFuture ... done
[08:28:39.963] signalConditions() ...
[08:28:39.963]  - include = ‘immediateCondition’
[08:28:39.963]  - exclude = 
[08:28:39.963]  - resignal = FALSE
[08:28:39.964]  - Number of conditions: 54
[08:28:39.964] signalConditions() ... done
[08:28:39.964] Future state: ‘finished’
[08:28:39.964] result() for MulticoreFuture ...
[08:28:39.964] result() for MulticoreFuture ... done
[08:28:39.964] signalConditions() ...
[08:28:39.964]  - include = ‘condition’
[08:28:39.964]  - exclude = ‘immediateCondition’
[08:28:39.964]  - resignal = TRUE
[08:28:39.965]  - Number of conditions: 54
[08:28:39.965]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.916] getGlobalsAndPackages() ...
[08:28:39.965]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.917] Searching for globals...
[08:28:39.965]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.925] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[08:28:39.965]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.926] Searching for globals ... DONE
[08:28:39.965]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.926] Resolving globals: FALSE
[08:28:39.966]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.927] The total size of the 3 globals is 11.81 KiB (12089 bytes)
[08:28:39.966]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.928] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 11.81 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (5.89 KiB of class ‘list’), ‘plan_a’ (5.89 KiB of class ‘list’) and ‘a’ (35 bytes of class ‘numeric’)
[08:28:39.966]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.928] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[08:28:39.966]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.928] 
[08:28:39.966]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.928] getGlobalsAndPackages() ... DONE
[08:28:39.966]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.929] run() for ‘Future’ ...
[08:28:39.966]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.929] - state: ‘created’
[08:28:39.967]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.930] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:39.967]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.932] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:39.967]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.932] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:39.967]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.932]   - Field: ‘label’
[08:28:39.967]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.933]   - Field: ‘local’
[08:28:39.967]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.933]   - Field: ‘owner’
[08:28:39.968]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.933]   - Field: ‘envir’
[08:28:39.968]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.933]   - Field: ‘packages’
[08:28:39.968]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.933]   - Field: ‘gc’
[08:28:39.968]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.934]   - Field: ‘conditions’
[08:28:39.968]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.934]   - Field: ‘expr’
[08:28:39.968]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.934]   - Field: ‘uuid’
[08:28:39.968]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.934]   - Field: ‘seed’
[08:28:39.969]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.934]   - Field: ‘version’
[08:28:39.969]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.934]   - Field: ‘result’
[08:28:39.969]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.935]   - Field: ‘asynchronous’
[08:28:39.969]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.935]   - Field: ‘calls’
[08:28:39.969]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.935]   - Field: ‘globals’
[08:28:39.969]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.935]   - Field: ‘stdout’
[08:28:39.969]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.935]   - Field: ‘earlySignal’
[08:28:39.970]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.935]   - Field: ‘lazy’
[08:28:39.970]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.936]   - Field: ‘state’
[08:28:39.970]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.936] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:39.970]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.936] - Launch lazy future ...
[08:28:39.970]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.936] Packages needed by the future expression (n = 0): <none>
[08:28:39.970]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.937] Packages needed by future strategies (n = 0): <none>
[08:28:39.971]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.937] {
[08:28:39.937]     {
[08:28:39.937]         {
[08:28:39.937]             ...future.startTime <- base::Sys.time()
[08:28:39.937]             {
[08:28:39.937]                 {
[08:28:39.937]                   {
[08:28:39.937]                     base::local({
[08:28:39.937]                       has_future <- base::requireNamespace("future", 
[08:28:39.937]                         quietly = TRUE)
[08:28:39.937]                       if (has_future) {
[08:28:39.937]                         ns <- base::getNamespace("future")
[08:28:39.937]                         version <- ns[[".package"]][["version"]]
[08:28:39.937]                         if (is.null(version)) 
[08:28:39.937]                           version <- utils::packageVersion("future")
[08:28:39.937]                       }
[08:28:39.937]                       else {
[08:28:39.937]                         version <- NULL
[08:28:39.937]                       }
[08:28:39.937]                       if (!has_future || version < "1.8.0") {
[08:28:39.937]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:39.937]                           "", base::R.version$version.string), 
[08:28:39.937]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:39.937]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:39.937]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:39.937]                             "release", "version")], collapse = " "), 
[08:28:39.937]                           hostname = base::Sys.info()[["nodename"]])
[08:28:39.937]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:39.937]                           info)
[08:28:39.937]                         info <- base::paste(info, collapse = "; ")
[08:28:39.937]                         if (!has_future) {
[08:28:39.937]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:39.937]                             info)
[08:28:39.937]                         }
[08:28:39.937]                         else {
[08:28:39.937]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:39.937]                             info, version)
[08:28:39.937]                         }
[08:28:39.937]                         base::stop(msg)
[08:28:39.937]                       }
[08:28:39.937]                     })
[08:28:39.937]                   }
[08:28:39.937]                   ...future.strategy.old <- future::plan("list")
[08:28:39.937]                   options(future.plan = NULL)
[08:28:39.937]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:39.937]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:39.937]                 }
[08:28:39.937]                 ...future.workdir <- getwd()
[08:28:39.937]             }
[08:28:39.937]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:39.937]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:39.937]         }
[08:28:39.937]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:39.937]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:39.937]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:39.937]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:39.937]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:39.937]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:39.937]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:39.937]             base::names(...future.oldOptions))
[08:28:39.937]     }
[08:28:39.937]     if (FALSE) {
[08:28:39.937]     }
[08:28:39.937]     else {
[08:28:39.937]         if (TRUE) {
[08:28:39.937]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:39.937]                 open = "w")
[08:28:39.937]         }
[08:28:39.937]         else {
[08:28:39.937]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:39.937]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:39.937]         }
[08:28:39.937]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:39.937]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:39.937]             base::sink(type = "output", split = FALSE)
[08:28:39.937]             base::close(...future.stdout)
[08:28:39.937]         }, add = TRUE)
[08:28:39.937]     }
[08:28:39.937]     ...future.frame <- base::sys.nframe()
[08:28:39.937]     ...future.conditions <- base::list()
[08:28:39.937]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:39.937]     if (FALSE) {
[08:28:39.937]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:39.937]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:39.937]     }
[08:28:39.937]     ...future.result <- base::tryCatch({
[08:28:39.937]         base::withCallingHandlers({
[08:28:39.937]             ...future.value <- base::withVisible(base::local({
[08:28:39.937]                 b <- 2L
[08:28:39.937]                 plan_b <- future::plan("list")
[08:28:39.937]                 nested_b <- nested_a[-1]
[08:28:39.937]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[08:28:39.937]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[08:28:39.937]                   "sequential"))
[08:28:39.937]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[08:28:39.937]                   b = b, nested_b = nested_b, plan_b = plan_b)
[08:28:39.937]             }))
[08:28:39.937]             future::FutureResult(value = ...future.value$value, 
[08:28:39.937]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:39.937]                   ...future.rng), globalenv = if (FALSE) 
[08:28:39.937]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:39.937]                     ...future.globalenv.names))
[08:28:39.937]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:39.937]         }, condition = base::local({
[08:28:39.937]             c <- base::c
[08:28:39.937]             inherits <- base::inherits
[08:28:39.937]             invokeRestart <- base::invokeRestart
[08:28:39.937]             length <- base::length
[08:28:39.937]             list <- base::list
[08:28:39.937]             seq.int <- base::seq.int
[08:28:39.937]             signalCondition <- base::signalCondition
[08:28:39.937]             sys.calls <- base::sys.calls
[08:28:39.937]             `[[` <- base::`[[`
[08:28:39.937]             `+` <- base::`+`
[08:28:39.937]             `<<-` <- base::`<<-`
[08:28:39.937]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:39.937]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:39.937]                   3L)]
[08:28:39.937]             }
[08:28:39.937]             function(cond) {
[08:28:39.937]                 is_error <- inherits(cond, "error")
[08:28:39.937]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:39.937]                   NULL)
[08:28:39.937]                 if (is_error) {
[08:28:39.937]                   sessionInformation <- function() {
[08:28:39.937]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:39.937]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:39.937]                       search = base::search(), system = base::Sys.info())
[08:28:39.937]                   }
[08:28:39.937]                   ...future.conditions[[length(...future.conditions) + 
[08:28:39.937]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:39.937]                     cond$call), session = sessionInformation(), 
[08:28:39.937]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:39.937]                   signalCondition(cond)
[08:28:39.937]                 }
[08:28:39.937]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:39.937]                 "immediateCondition"))) {
[08:28:39.937]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:39.937]                   ...future.conditions[[length(...future.conditions) + 
[08:28:39.937]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:39.937]                   if (TRUE && !signal) {
[08:28:39.937]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:39.937]                     {
[08:28:39.937]                       inherits <- base::inherits
[08:28:39.937]                       invokeRestart <- base::invokeRestart
[08:28:39.937]                       is.null <- base::is.null
[08:28:39.937]                       muffled <- FALSE
[08:28:39.937]                       if (inherits(cond, "message")) {
[08:28:39.937]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:39.937]                         if (muffled) 
[08:28:39.937]                           invokeRestart("muffleMessage")
[08:28:39.937]                       }
[08:28:39.937]                       else if (inherits(cond, "warning")) {
[08:28:39.937]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:39.937]                         if (muffled) 
[08:28:39.937]                           invokeRestart("muffleWarning")
[08:28:39.937]                       }
[08:28:39.937]                       else if (inherits(cond, "condition")) {
[08:28:39.937]                         if (!is.null(pattern)) {
[08:28:39.937]                           computeRestarts <- base::computeRestarts
[08:28:39.937]                           grepl <- base::grepl
[08:28:39.937]                           restarts <- computeRestarts(cond)
[08:28:39.937]                           for (restart in restarts) {
[08:28:39.937]                             name <- restart$name
[08:28:39.937]                             if (is.null(name)) 
[08:28:39.937]                               next
[08:28:39.937]                             if (!grepl(pattern, name)) 
[08:28:39.937]                               next
[08:28:39.937]                             invokeRestart(restart)
[08:28:39.937]                             muffled <- TRUE
[08:28:39.937]                             break
[08:28:39.937]                           }
[08:28:39.937]                         }
[08:28:39.937]                       }
[08:28:39.937]                       invisible(muffled)
[08:28:39.937]                     }
[08:28:39.937]                     muffleCondition(cond, pattern = "^muffle")
[08:28:39.937]                   }
[08:28:39.937]                 }
[08:28:39.937]                 else {
[08:28:39.937]                   if (TRUE) {
[08:28:39.937]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:39.937]                     {
[08:28:39.937]                       inherits <- base::inherits
[08:28:39.937]                       invokeRestart <- base::invokeRestart
[08:28:39.937]                       is.null <- base::is.null
[08:28:39.937]                       muffled <- FALSE
[08:28:39.937]                       if (inherits(cond, "message")) {
[08:28:39.937]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:39.937]                         if (muffled) 
[08:28:39.937]                           invokeRestart("muffleMessage")
[08:28:39.937]                       }
[08:28:39.937]                       else if (inherits(cond, "warning")) {
[08:28:39.937]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:39.937]                         if (muffled) 
[08:28:39.937]                           invokeRestart("muffleWarning")
[08:28:39.937]                       }
[08:28:39.937]                       else if (inherits(cond, "condition")) {
[08:28:39.937]                         if (!is.null(pattern)) {
[08:28:39.937]                           computeRestarts <- base::computeRestarts
[08:28:39.937]                           grepl <- base::grepl
[08:28:39.937]                           restarts <- computeRestarts(cond)
[08:28:39.937]                           for (restart in restarts) {
[08:28:39.937]                             name <- restart$name
[08:28:39.937]                             if (is.null(name)) 
[08:28:39.937]                               next
[08:28:39.937]                             if (!grepl(pattern, name)) 
[08:28:39.937]                               next
[08:28:39.937]                             invokeRestart(restart)
[08:28:39.937]                             muffled <- TRUE
[08:28:39.937]                             break
[08:28:39.937]                           }
[08:28:39.937]                         }
[08:28:39.937]                       }
[08:28:39.937]                       invisible(muffled)
[08:28:39.937]                     }
[08:28:39.937]                     muffleCondition(cond, pattern = "^muffle")
[08:28:39.937]                   }
[08:28:39.937]                 }
[08:28:39.937]             }
[08:28:39.937]         }))
[08:28:39.937]     }, error = function(ex) {
[08:28:39.937]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:39.937]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:39.937]                 ...future.rng), started = ...future.startTime, 
[08:28:39.937]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:39.937]             version = "1.8"), class = "FutureResult")
[08:28:39.937]     }, finally = {
[08:28:39.937]         if (!identical(...future.workdir, getwd())) 
[08:28:39.937]             setwd(...future.workdir)
[08:28:39.937]         {
[08:28:39.937]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:39.937]                 ...future.oldOptions$nwarnings <- NULL
[08:28:39.937]             }
[08:28:39.937]             base::options(...future.oldOptions)
[08:28:39.937]             if (.Platform$OS.type == "windows") {
[08:28:39.937]                 old_names <- names(...future.oldEnvVars)
[08:28:39.937]                 envs <- base::Sys.getenv()
[08:28:39.937]                 names <- names(envs)
[08:28:39.937]                 common <- intersect(names, old_names)
[08:28:39.937]                 added <- setdiff(names, old_names)
[08:28:39.937]                 removed <- setdiff(old_names, names)
[08:28:39.937]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:39.937]                   envs[common]]
[08:28:39.937]                 NAMES <- toupper(changed)
[08:28:39.937]                 args <- list()
[08:28:39.937]                 for (kk in seq_along(NAMES)) {
[08:28:39.937]                   name <- changed[[kk]]
[08:28:39.937]                   NAME <- NAMES[[kk]]
[08:28:39.937]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.937]                     next
[08:28:39.937]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:39.937]                 }
[08:28:39.937]                 NAMES <- toupper(added)
[08:28:39.937]                 for (kk in seq_along(NAMES)) {
[08:28:39.937]                   name <- added[[kk]]
[08:28:39.937]                   NAME <- NAMES[[kk]]
[08:28:39.937]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.937]                     next
[08:28:39.937]                   args[[name]] <- ""
[08:28:39.937]                 }
[08:28:39.937]                 NAMES <- toupper(removed)
[08:28:39.937]                 for (kk in seq_along(NAMES)) {
[08:28:39.937]                   name <- removed[[kk]]
[08:28:39.937]                   NAME <- NAMES[[kk]]
[08:28:39.937]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.937]                     next
[08:28:39.937]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:39.937]                 }
[08:28:39.937]                 if (length(args) > 0) 
[08:28:39.937]                   base::do.call(base::Sys.setenv, args = args)
[08:28:39.937]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:39.937]             }
[08:28:39.937]             else {
[08:28:39.937]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:39.937]             }
[08:28:39.937]             {
[08:28:39.937]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:39.937]                   0L) {
[08:28:39.937]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:39.937]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:39.937]                   base::options(opts)
[08:28:39.937]                 }
[08:28:39.937]                 {
[08:28:39.937]                   {
[08:28:39.937]                     NULL
[08:28:39.937]                     RNGkind("Mersenne-Twister")
[08:28:39.937]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:39.937]                       inherits = FALSE)
[08:28:39.937]                   }
[08:28:39.937]                   options(future.plan = NULL)
[08:28:39.937]                   if (is.na(NA_character_)) 
[08:28:39.937]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:39.937]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:39.937]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:39.937]                     .init = FALSE)
[08:28:39.937]                 }
[08:28:39.937]             }
[08:28:39.937]         }
[08:28:39.937]     })
[08:28:39.937]     if (TRUE) {
[08:28:39.937]         base::sink(type = "output", split = FALSE)
[08:28:39.937]         if (TRUE) {
[08:28:39.937]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:39.937]         }
[08:28:39.937]         else {
[08:28:39.937]             ...future.result["stdout"] <- base::list(NULL)
[08:28:39.937]         }
[08:28:39.937]         base::close(...future.stdout)
[08:28:39.937]         ...future.stdout <- NULL
[08:28:39.937]     }
[08:28:39.937]     ...future.result$conditions <- ...future.conditions
[08:28:39.937]     ...future.result$finished <- base::Sys.time()
[08:28:39.937]     ...future.result
[08:28:39.937] }
[08:28:39.971]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.940] assign_globals() ...
[08:28:39.971]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.940] List of 3
[08:28:39.940]  $ nested_a:List of 1
[08:28:39.940]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[08:28:39.940]     envir = parent.frame())  
[08:28:39.940]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[08:28:39.940]   .. ..- attr(*, "cleanup")=function ()  
[08:28:39.940]   .. ..- attr(*, "untweakable")= chr "persistent"
[08:28:39.940]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[08:28:39.940]  $ a       : int 1
[08:28:39.940]  $ plan_a  :List of 1
[08:28:39.940]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[08:28:39.940]     envir = parent.frame())  
[08:28:39.940]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[08:28:39.940]   .. ..- attr(*, "cleanup")=function ()  
[08:28:39.940]   .. ..- attr(*, "untweakable")= chr "persistent"
[08:28:39.940]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[08:28:39.940]  - attr(*, "where")=List of 3
[08:28:39.940]   ..$ nested_a:<environment: R_EmptyEnv> 
[08:28:39.940]   ..$ a       :<environment: R_EmptyEnv> 
[08:28:39.940]   ..$ plan_a  :<environment: R_EmptyEnv> 
[08:28:39.940]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:39.940]  - attr(*, "resolved")= logi FALSE
[08:28:39.940]  - attr(*, "total_size")= num 12089
[08:28:39.940]  - attr(*, "already-done")= logi TRUE
[08:28:39.971]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.950] - copied ‘nested_a’ to environment
[08:28:39.971]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.951] - copied ‘a’ to environment
[08:28:39.971]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.951] - copied ‘plan_a’ to environment
[08:28:39.972]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.951] assign_globals() ... done
[08:28:39.972]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.952] plan(): Setting new future strategy stack:
[08:28:39.972]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.952] List of future strategies:
[08:28:39.952] 1. sequential:
[08:28:39.952]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:39.952]    - tweaked: FALSE
[08:28:39.952]    - call: NULL
[08:28:39.972]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.953] plan(): nbrOfWorkers() = 1
[08:28:39.972]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.954] plan(): Setting new future strategy stack:
[08:28:39.972]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.954] List of future strategies:
[08:28:39.954] 1. multisession:
[08:28:39.954]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:28:39.954]    - tweaked: FALSE
[08:28:39.954]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:39.973]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.956] plan(): nbrOfWorkers() = 1
[08:28:39.973]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.957] SequentialFuture started (and completed)
[08:28:39.973]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.957] - Launch lazy future ... done
[08:28:39.973]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:39.957] run() for ‘SequentialFuture’ ... done
[08:28:39.973] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "cleanup")=function ()  
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "cleanup")=function ()  
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[08:28:39.981] getGlobalsAndPackages() ...
[08:28:39.981] Searching for globals...
[08:28:39.983] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[08:28:39.983] Searching for globals ... DONE
[08:28:39.983] Resolving globals: FALSE
[08:28:39.984] The total size of the 1 globals is 356 bytes (356 bytes)
[08:28:39.984] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[08:28:39.984] - globals: [1] ‘data’
[08:28:39.985] - packages: [1] ‘future’
[08:28:39.985] getGlobalsAndPackages() ... DONE
[08:28:39.985] run() for ‘Future’ ...
[08:28:39.985] - state: ‘created’
[08:28:39.985] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:39.988] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:39.988] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:39.988]   - Field: ‘label’
[08:28:39.988]   - Field: ‘local’
[08:28:39.988]   - Field: ‘owner’
[08:28:39.988]   - Field: ‘envir’
[08:28:39.988]   - Field: ‘workers’
[08:28:39.989]   - Field: ‘packages’
[08:28:39.989]   - Field: ‘gc’
[08:28:39.989]   - Field: ‘job’
[08:28:39.989]   - Field: ‘conditions’
[08:28:39.989]   - Field: ‘expr’
[08:28:39.989]   - Field: ‘uuid’
[08:28:39.989]   - Field: ‘seed’
[08:28:39.989]   - Field: ‘version’
[08:28:39.990]   - Field: ‘result’
[08:28:39.990]   - Field: ‘asynchronous’
[08:28:39.990]   - Field: ‘calls’
[08:28:39.990]   - Field: ‘globals’
[08:28:39.990]   - Field: ‘stdout’
[08:28:39.990]   - Field: ‘earlySignal’
[08:28:39.990]   - Field: ‘lazy’
[08:28:39.990]   - Field: ‘state’
[08:28:39.990] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:39.990] - Launch lazy future ...
[08:28:39.991] Packages needed by the future expression (n = 1): ‘future’
[08:28:39.991] Packages needed by future strategies (n = 1): ‘future’
[08:28:39.992] {
[08:28:39.992]     {
[08:28:39.992]         {
[08:28:39.992]             ...future.startTime <- base::Sys.time()
[08:28:39.992]             {
[08:28:39.992]                 {
[08:28:39.992]                   {
[08:28:39.992]                     {
[08:28:39.992]                       {
[08:28:39.992]                         base::local({
[08:28:39.992]                           has_future <- base::requireNamespace("future", 
[08:28:39.992]                             quietly = TRUE)
[08:28:39.992]                           if (has_future) {
[08:28:39.992]                             ns <- base::getNamespace("future")
[08:28:39.992]                             version <- ns[[".package"]][["version"]]
[08:28:39.992]                             if (is.null(version)) 
[08:28:39.992]                               version <- utils::packageVersion("future")
[08:28:39.992]                           }
[08:28:39.992]                           else {
[08:28:39.992]                             version <- NULL
[08:28:39.992]                           }
[08:28:39.992]                           if (!has_future || version < "1.8.0") {
[08:28:39.992]                             info <- base::c(r_version = base::gsub("R version ", 
[08:28:39.992]                               "", base::R.version$version.string), 
[08:28:39.992]                               platform = base::sprintf("%s (%s-bit)", 
[08:28:39.992]                                 base::R.version$platform, 8 * 
[08:28:39.992]                                   base::.Machine$sizeof.pointer), 
[08:28:39.992]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:39.992]                                 "release", "version")], collapse = " "), 
[08:28:39.992]                               hostname = base::Sys.info()[["nodename"]])
[08:28:39.992]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:28:39.992]                               info)
[08:28:39.992]                             info <- base::paste(info, collapse = "; ")
[08:28:39.992]                             if (!has_future) {
[08:28:39.992]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:39.992]                                 info)
[08:28:39.992]                             }
[08:28:39.992]                             else {
[08:28:39.992]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:39.992]                                 info, version)
[08:28:39.992]                             }
[08:28:39.992]                             base::stop(msg)
[08:28:39.992]                           }
[08:28:39.992]                         })
[08:28:39.992]                       }
[08:28:39.992]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:39.992]                       base::options(mc.cores = 1L)
[08:28:39.992]                     }
[08:28:39.992]                     base::local({
[08:28:39.992]                       for (pkg in "future") {
[08:28:39.992]                         base::loadNamespace(pkg)
[08:28:39.992]                         base::library(pkg, character.only = TRUE)
[08:28:39.992]                       }
[08:28:39.992]                     })
[08:28:39.992]                   }
[08:28:39.992]                   ...future.strategy.old <- future::plan("list")
[08:28:39.992]                   options(future.plan = NULL)
[08:28:39.992]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:39.992]                   future::plan(list(b = function (..., workers = availableCores(), 
[08:28:39.992]                     lazy = FALSE, rscript_libs = .libPaths(), 
[08:28:39.992]                     envir = parent.frame()) 
[08:28:39.992]                   {
[08:28:39.992]                     if (is.function(workers)) 
[08:28:39.992]                       workers <- workers()
[08:28:39.992]                     workers <- structure(as.integer(workers), 
[08:28:39.992]                       class = class(workers))
[08:28:39.992]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[08:28:39.992]                       workers >= 1)
[08:28:39.992]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[08:28:39.992]                       return(sequential(..., lazy = TRUE, envir = envir))
[08:28:39.992]                     }
[08:28:39.992]                     future <- MultisessionFuture(..., workers = workers, 
[08:28:39.992]                       lazy = lazy, rscript_libs = rscript_libs, 
[08:28:39.992]                       envir = envir)
[08:28:39.992]                     if (!future$lazy) 
[08:28:39.992]                       future <- run(future)
[08:28:39.992]                     invisible(future)
[08:28:39.992]                   }), .cleanup = FALSE, .init = FALSE)
[08:28:39.992]                 }
[08:28:39.992]                 ...future.workdir <- getwd()
[08:28:39.992]             }
[08:28:39.992]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:39.992]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:39.992]         }
[08:28:39.992]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:39.992]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:39.992]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:39.992]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:39.992]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:39.992]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:39.992]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:39.992]             base::names(...future.oldOptions))
[08:28:39.992]     }
[08:28:39.992]     if (FALSE) {
[08:28:39.992]     }
[08:28:39.992]     else {
[08:28:39.992]         if (TRUE) {
[08:28:39.992]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:39.992]                 open = "w")
[08:28:39.992]         }
[08:28:39.992]         else {
[08:28:39.992]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:39.992]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:39.992]         }
[08:28:39.992]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:39.992]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:39.992]             base::sink(type = "output", split = FALSE)
[08:28:39.992]             base::close(...future.stdout)
[08:28:39.992]         }, add = TRUE)
[08:28:39.992]     }
[08:28:39.992]     ...future.frame <- base::sys.nframe()
[08:28:39.992]     ...future.conditions <- base::list()
[08:28:39.992]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:39.992]     if (FALSE) {
[08:28:39.992]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:39.992]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:39.992]     }
[08:28:39.992]     ...future.result <- base::tryCatch({
[08:28:39.992]         base::withCallingHandlers({
[08:28:39.992]             ...future.value <- base::withVisible(base::local({
[08:28:39.992]                 withCallingHandlers({
[08:28:39.992]                   {
[08:28:39.992]                     value(future(subset(data, a == 2)))
[08:28:39.992]                   }
[08:28:39.992]                 }, immediateCondition = function(cond) {
[08:28:39.992]                   save_rds <- function (object, pathname, ...) 
[08:28:39.992]                   {
[08:28:39.992]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:39.992]                     if (file_test("-f", pathname_tmp)) {
[08:28:39.992]                       fi_tmp <- file.info(pathname_tmp)
[08:28:39.992]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:39.992]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:39.992]                         fi_tmp[["mtime"]])
[08:28:39.992]                     }
[08:28:39.992]                     tryCatch({
[08:28:39.992]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:39.992]                     }, error = function(ex) {
[08:28:39.992]                       msg <- conditionMessage(ex)
[08:28:39.992]                       fi_tmp <- file.info(pathname_tmp)
[08:28:39.992]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:39.992]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:39.992]                         fi_tmp[["mtime"]], msg)
[08:28:39.992]                       ex$message <- msg
[08:28:39.992]                       stop(ex)
[08:28:39.992]                     })
[08:28:39.992]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:39.992]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:39.992]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:39.992]                       fi_tmp <- file.info(pathname_tmp)
[08:28:39.992]                       fi <- file.info(pathname)
[08:28:39.992]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:39.992]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:39.992]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:39.992]                         fi[["size"]], fi[["mtime"]])
[08:28:39.992]                       stop(msg)
[08:28:39.992]                     }
[08:28:39.992]                     invisible(pathname)
[08:28:39.992]                   }
[08:28:39.992]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:39.992]                     rootPath = tempdir()) 
[08:28:39.992]                   {
[08:28:39.992]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:39.992]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:39.992]                       tmpdir = path, fileext = ".rds")
[08:28:39.992]                     save_rds(obj, file)
[08:28:39.992]                   }
[08:28:39.992]                   saveImmediateCondition(cond, path = "/tmp/RtmphjARvB/.future/immediateConditions")
[08:28:39.992]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:39.992]                   {
[08:28:39.992]                     inherits <- base::inherits
[08:28:39.992]                     invokeRestart <- base::invokeRestart
[08:28:39.992]                     is.null <- base::is.null
[08:28:39.992]                     muffled <- FALSE
[08:28:39.992]                     if (inherits(cond, "message")) {
[08:28:39.992]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:39.992]                       if (muffled) 
[08:28:39.992]                         invokeRestart("muffleMessage")
[08:28:39.992]                     }
[08:28:39.992]                     else if (inherits(cond, "warning")) {
[08:28:39.992]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:39.992]                       if (muffled) 
[08:28:39.992]                         invokeRestart("muffleWarning")
[08:28:39.992]                     }
[08:28:39.992]                     else if (inherits(cond, "condition")) {
[08:28:39.992]                       if (!is.null(pattern)) {
[08:28:39.992]                         computeRestarts <- base::computeRestarts
[08:28:39.992]                         grepl <- base::grepl
[08:28:39.992]                         restarts <- computeRestarts(cond)
[08:28:39.992]                         for (restart in restarts) {
[08:28:39.992]                           name <- restart$name
[08:28:39.992]                           if (is.null(name)) 
[08:28:39.992]                             next
[08:28:39.992]                           if (!grepl(pattern, name)) 
[08:28:39.992]                             next
[08:28:39.992]                           invokeRestart(restart)
[08:28:39.992]                           muffled <- TRUE
[08:28:39.992]                           break
[08:28:39.992]                         }
[08:28:39.992]                       }
[08:28:39.992]                     }
[08:28:39.992]                     invisible(muffled)
[08:28:39.992]                   }
[08:28:39.992]                   muffleCondition(cond)
[08:28:39.992]                 })
[08:28:39.992]             }))
[08:28:39.992]             future::FutureResult(value = ...future.value$value, 
[08:28:39.992]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:39.992]                   ...future.rng), globalenv = if (FALSE) 
[08:28:39.992]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:39.992]                     ...future.globalenv.names))
[08:28:39.992]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:39.992]         }, condition = base::local({
[08:28:39.992]             c <- base::c
[08:28:39.992]             inherits <- base::inherits
[08:28:39.992]             invokeRestart <- base::invokeRestart
[08:28:39.992]             length <- base::length
[08:28:39.992]             list <- base::list
[08:28:39.992]             seq.int <- base::seq.int
[08:28:39.992]             signalCondition <- base::signalCondition
[08:28:39.992]             sys.calls <- base::sys.calls
[08:28:39.992]             `[[` <- base::`[[`
[08:28:39.992]             `+` <- base::`+`
[08:28:39.992]             `<<-` <- base::`<<-`
[08:28:39.992]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:39.992]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:39.992]                   3L)]
[08:28:39.992]             }
[08:28:39.992]             function(cond) {
[08:28:39.992]                 is_error <- inherits(cond, "error")
[08:28:39.992]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:39.992]                   NULL)
[08:28:39.992]                 if (is_error) {
[08:28:39.992]                   sessionInformation <- function() {
[08:28:39.992]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:39.992]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:39.992]                       search = base::search(), system = base::Sys.info())
[08:28:39.992]                   }
[08:28:39.992]                   ...future.conditions[[length(...future.conditions) + 
[08:28:39.992]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:39.992]                     cond$call), session = sessionInformation(), 
[08:28:39.992]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:39.992]                   signalCondition(cond)
[08:28:39.992]                 }
[08:28:39.992]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:39.992]                 "immediateCondition"))) {
[08:28:39.992]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:39.992]                   ...future.conditions[[length(...future.conditions) + 
[08:28:39.992]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:39.992]                   if (TRUE && !signal) {
[08:28:39.992]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:39.992]                     {
[08:28:39.992]                       inherits <- base::inherits
[08:28:39.992]                       invokeRestart <- base::invokeRestart
[08:28:39.992]                       is.null <- base::is.null
[08:28:39.992]                       muffled <- FALSE
[08:28:39.992]                       if (inherits(cond, "message")) {
[08:28:39.992]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:39.992]                         if (muffled) 
[08:28:39.992]                           invokeRestart("muffleMessage")
[08:28:39.992]                       }
[08:28:39.992]                       else if (inherits(cond, "warning")) {
[08:28:39.992]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:39.992]                         if (muffled) 
[08:28:39.992]                           invokeRestart("muffleWarning")
[08:28:39.992]                       }
[08:28:39.992]                       else if (inherits(cond, "condition")) {
[08:28:39.992]                         if (!is.null(pattern)) {
[08:28:39.992]                           computeRestarts <- base::computeRestarts
[08:28:39.992]                           grepl <- base::grepl
[08:28:39.992]                           restarts <- computeRestarts(cond)
[08:28:39.992]                           for (restart in restarts) {
[08:28:39.992]                             name <- restart$name
[08:28:39.992]                             if (is.null(name)) 
[08:28:39.992]                               next
[08:28:39.992]                             if (!grepl(pattern, name)) 
[08:28:39.992]                               next
[08:28:39.992]                             invokeRestart(restart)
[08:28:39.992]                             muffled <- TRUE
[08:28:39.992]                             break
[08:28:39.992]                           }
[08:28:39.992]                         }
[08:28:39.992]                       }
[08:28:39.992]                       invisible(muffled)
[08:28:39.992]                     }
[08:28:39.992]                     muffleCondition(cond, pattern = "^muffle")
[08:28:39.992]                   }
[08:28:39.992]                 }
[08:28:39.992]                 else {
[08:28:39.992]                   if (TRUE) {
[08:28:39.992]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:39.992]                     {
[08:28:39.992]                       inherits <- base::inherits
[08:28:39.992]                       invokeRestart <- base::invokeRestart
[08:28:39.992]                       is.null <- base::is.null
[08:28:39.992]                       muffled <- FALSE
[08:28:39.992]                       if (inherits(cond, "message")) {
[08:28:39.992]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:39.992]                         if (muffled) 
[08:28:39.992]                           invokeRestart("muffleMessage")
[08:28:39.992]                       }
[08:28:39.992]                       else if (inherits(cond, "warning")) {
[08:28:39.992]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:39.992]                         if (muffled) 
[08:28:39.992]                           invokeRestart("muffleWarning")
[08:28:39.992]                       }
[08:28:39.992]                       else if (inherits(cond, "condition")) {
[08:28:39.992]                         if (!is.null(pattern)) {
[08:28:39.992]                           computeRestarts <- base::computeRestarts
[08:28:39.992]                           grepl <- base::grepl
[08:28:39.992]                           restarts <- computeRestarts(cond)
[08:28:39.992]                           for (restart in restarts) {
[08:28:39.992]                             name <- restart$name
[08:28:39.992]                             if (is.null(name)) 
[08:28:39.992]                               next
[08:28:39.992]                             if (!grepl(pattern, name)) 
[08:28:39.992]                               next
[08:28:39.992]                             invokeRestart(restart)
[08:28:39.992]                             muffled <- TRUE
[08:28:39.992]                             break
[08:28:39.992]                           }
[08:28:39.992]                         }
[08:28:39.992]                       }
[08:28:39.992]                       invisible(muffled)
[08:28:39.992]                     }
[08:28:39.992]                     muffleCondition(cond, pattern = "^muffle")
[08:28:39.992]                   }
[08:28:39.992]                 }
[08:28:39.992]             }
[08:28:39.992]         }))
[08:28:39.992]     }, error = function(ex) {
[08:28:39.992]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:39.992]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:39.992]                 ...future.rng), started = ...future.startTime, 
[08:28:39.992]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:39.992]             version = "1.8"), class = "FutureResult")
[08:28:39.992]     }, finally = {
[08:28:39.992]         if (!identical(...future.workdir, getwd())) 
[08:28:39.992]             setwd(...future.workdir)
[08:28:39.992]         {
[08:28:39.992]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:39.992]                 ...future.oldOptions$nwarnings <- NULL
[08:28:39.992]             }
[08:28:39.992]             base::options(...future.oldOptions)
[08:28:39.992]             if (.Platform$OS.type == "windows") {
[08:28:39.992]                 old_names <- names(...future.oldEnvVars)
[08:28:39.992]                 envs <- base::Sys.getenv()
[08:28:39.992]                 names <- names(envs)
[08:28:39.992]                 common <- intersect(names, old_names)
[08:28:39.992]                 added <- setdiff(names, old_names)
[08:28:39.992]                 removed <- setdiff(old_names, names)
[08:28:39.992]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:39.992]                   envs[common]]
[08:28:39.992]                 NAMES <- toupper(changed)
[08:28:39.992]                 args <- list()
[08:28:39.992]                 for (kk in seq_along(NAMES)) {
[08:28:39.992]                   name <- changed[[kk]]
[08:28:39.992]                   NAME <- NAMES[[kk]]
[08:28:39.992]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.992]                     next
[08:28:39.992]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:39.992]                 }
[08:28:39.992]                 NAMES <- toupper(added)
[08:28:39.992]                 for (kk in seq_along(NAMES)) {
[08:28:39.992]                   name <- added[[kk]]
[08:28:39.992]                   NAME <- NAMES[[kk]]
[08:28:39.992]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.992]                     next
[08:28:39.992]                   args[[name]] <- ""
[08:28:39.992]                 }
[08:28:39.992]                 NAMES <- toupper(removed)
[08:28:39.992]                 for (kk in seq_along(NAMES)) {
[08:28:39.992]                   name <- removed[[kk]]
[08:28:39.992]                   NAME <- NAMES[[kk]]
[08:28:39.992]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:39.992]                     next
[08:28:39.992]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:39.992]                 }
[08:28:39.992]                 if (length(args) > 0) 
[08:28:39.992]                   base::do.call(base::Sys.setenv, args = args)
[08:28:39.992]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:39.992]             }
[08:28:39.992]             else {
[08:28:39.992]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:39.992]             }
[08:28:39.992]             {
[08:28:39.992]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:39.992]                   0L) {
[08:28:39.992]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:39.992]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:39.992]                   base::options(opts)
[08:28:39.992]                 }
[08:28:39.992]                 {
[08:28:39.992]                   {
[08:28:39.992]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:39.992]                     NULL
[08:28:39.992]                   }
[08:28:39.992]                   options(future.plan = NULL)
[08:28:39.992]                   if (is.na(NA_character_)) 
[08:28:39.992]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:39.992]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:39.992]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:39.992]                     .init = FALSE)
[08:28:39.992]                 }
[08:28:39.992]             }
[08:28:39.992]         }
[08:28:39.992]     })
[08:28:39.992]     if (TRUE) {
[08:28:39.992]         base::sink(type = "output", split = FALSE)
[08:28:39.992]         if (TRUE) {
[08:28:39.992]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:39.992]         }
[08:28:39.992]         else {
[08:28:39.992]             ...future.result["stdout"] <- base::list(NULL)
[08:28:39.992]         }
[08:28:39.992]         base::close(...future.stdout)
[08:28:39.992]         ...future.stdout <- NULL
[08:28:39.992]     }
[08:28:39.992]     ...future.result$conditions <- ...future.conditions
[08:28:39.992]     ...future.result$finished <- base::Sys.time()
[08:28:39.992]     ...future.result
[08:28:39.992] }
[08:28:39.994] assign_globals() ...
[08:28:39.995] List of 1
[08:28:39.995]  $ data:'data.frame':	3 obs. of  2 variables:
[08:28:39.995]   ..$ a: int [1:3] 1 2 3
[08:28:39.995]   ..$ b: int [1:3] 3 2 1
[08:28:39.995]  - attr(*, "where")=List of 1
[08:28:39.995]   ..$ data:<environment: R_EmptyEnv> 
[08:28:39.995]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:39.995]  - attr(*, "resolved")= logi FALSE
[08:28:39.995]  - attr(*, "total_size")= num 356
[08:28:39.995]  - attr(*, "already-done")= logi TRUE
[08:28:39.998] - copied ‘data’ to environment
[08:28:39.998] assign_globals() ... done
[08:28:39.998] requestCore(): workers = 2
[08:28:40.001] MulticoreFuture started
[08:28:40.001] - Launch lazy future ... done
[08:28:40.002] run() for ‘MulticoreFuture’ ... done
[08:28:40.002] result() for MulticoreFuture ...
[08:28:40.003] plan(): Setting new future strategy stack:
[08:28:40.003] List of future strategies:
[08:28:40.003] 1. multisession:
[08:28:40.003]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:28:40.003]    - tweaked: FALSE
[08:28:40.003]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:40.006] plan(): nbrOfWorkers() = 1
[08:28:40.033] plan(): Setting new future strategy stack:
[08:28:40.034] List of future strategies:
[08:28:40.034] 1. multicore:
[08:28:40.034]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:40.034]    - tweaked: FALSE
[08:28:40.034]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:40.034] 2. multisession:
[08:28:40.034]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:28:40.034]    - tweaked: FALSE
[08:28:40.034]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:40.036] plan(): nbrOfWorkers() = 2
[08:28:40.037] result() for MulticoreFuture ...
[08:28:40.037] result() for MulticoreFuture ... done
[08:28:40.037] signalConditions() ...
[08:28:40.038]  - include = ‘immediateCondition’
[08:28:40.038]  - exclude = 
[08:28:40.038]  - resignal = FALSE
[08:28:40.038]  - Number of conditions: 52
[08:28:40.038] signalConditions() ... done
[08:28:40.038] result() for MulticoreFuture ... done
[08:28:40.038] result() for MulticoreFuture ...
[08:28:40.038] result() for MulticoreFuture ... done
[08:28:40.038] signalConditions() ...
[08:28:40.039]  - include = ‘immediateCondition’
[08:28:40.039]  - exclude = 
[08:28:40.039]  - resignal = FALSE
[08:28:40.039]  - Number of conditions: 52
[08:28:40.039] signalConditions() ... done
[08:28:40.039] Future state: ‘finished’
[08:28:40.039] result() for MulticoreFuture ...
[08:28:40.039] result() for MulticoreFuture ... done
[08:28:40.039] signalConditions() ...
[08:28:40.040]  - include = ‘condition’
[08:28:40.040]  - exclude = ‘immediateCondition’
[08:28:40.040]  - resignal = TRUE
[08:28:40.040]  - Number of conditions: 52
[08:28:40.040]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.007] getGlobalsAndPackages() ...
[08:28:40.040]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.008] Searching for globals...
[08:28:40.040]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.010] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[08:28:40.040]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.010] Searching for globals ... DONE
[08:28:40.041]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.010] Resolving globals: FALSE
[08:28:40.041]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.011] The total size of the 1 globals is 356 bytes (356 bytes)
[08:28:40.041]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.011] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[08:28:40.041]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.011] - globals: [1] ‘data’
[08:28:40.041]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.012] 
[08:28:40.041]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.012] getGlobalsAndPackages() ... DONE
[08:28:40.042]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.013] run() for ‘Future’ ...
[08:28:40.042]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.013] - state: ‘created’
[08:28:40.042]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.013] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:40.042]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.015] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:40.042]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.015] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:40.042]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.016]   - Field: ‘label’
[08:28:40.042]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.016]   - Field: ‘local’
[08:28:40.043]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.016]   - Field: ‘owner’
[08:28:40.043]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.016]   - Field: ‘envir’
[08:28:40.043]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.016]   - Field: ‘packages’
[08:28:40.043]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.016]   - Field: ‘gc’
[08:28:40.043]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.017]   - Field: ‘conditions’
[08:28:40.043]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.017]   - Field: ‘expr’
[08:28:40.043]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.017]   - Field: ‘uuid’
[08:28:40.044]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.017]   - Field: ‘seed’
[08:28:40.044]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.017]   - Field: ‘version’
[08:28:40.044]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.017]   - Field: ‘result’
[08:28:40.044]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.017]   - Field: ‘asynchronous’
[08:28:40.044]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.018]   - Field: ‘calls’
[08:28:40.044]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.018]   - Field: ‘globals’
[08:28:40.045]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.018]   - Field: ‘stdout’
[08:28:40.045]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.018]   - Field: ‘earlySignal’
[08:28:40.045]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.018]   - Field: ‘lazy’
[08:28:40.045]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.018]   - Field: ‘state’
[08:28:40.045]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.019] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:40.045]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.019] - Launch lazy future ...
[08:28:40.045]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.019] Packages needed by the future expression (n = 0): <none>
[08:28:40.046]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.019] Packages needed by future strategies (n = 0): <none>
[08:28:40.046]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.020] {
[08:28:40.020]     {
[08:28:40.020]         {
[08:28:40.020]             ...future.startTime <- base::Sys.time()
[08:28:40.020]             {
[08:28:40.020]                 {
[08:28:40.020]                   {
[08:28:40.020]                     base::local({
[08:28:40.020]                       has_future <- base::requireNamespace("future", 
[08:28:40.020]                         quietly = TRUE)
[08:28:40.020]                       if (has_future) {
[08:28:40.020]                         ns <- base::getNamespace("future")
[08:28:40.020]                         version <- ns[[".package"]][["version"]]
[08:28:40.020]                         if (is.null(version)) 
[08:28:40.020]                           version <- utils::packageVersion("future")
[08:28:40.020]                       }
[08:28:40.020]                       else {
[08:28:40.020]                         version <- NULL
[08:28:40.020]                       }
[08:28:40.020]                       if (!has_future || version < "1.8.0") {
[08:28:40.020]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:40.020]                           "", base::R.version$version.string), 
[08:28:40.020]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:40.020]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:40.020]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:40.020]                             "release", "version")], collapse = " "), 
[08:28:40.020]                           hostname = base::Sys.info()[["nodename"]])
[08:28:40.020]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:40.020]                           info)
[08:28:40.020]                         info <- base::paste(info, collapse = "; ")
[08:28:40.020]                         if (!has_future) {
[08:28:40.020]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:40.020]                             info)
[08:28:40.020]                         }
[08:28:40.020]                         else {
[08:28:40.020]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:40.020]                             info, version)
[08:28:40.020]                         }
[08:28:40.020]                         base::stop(msg)
[08:28:40.020]                       }
[08:28:40.020]                     })
[08:28:40.020]                   }
[08:28:40.020]                   ...future.strategy.old <- future::plan("list")
[08:28:40.020]                   options(future.plan = NULL)
[08:28:40.020]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:40.020]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:40.020]                 }
[08:28:40.020]                 ...future.workdir <- getwd()
[08:28:40.020]             }
[08:28:40.020]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:40.020]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:40.020]         }
[08:28:40.020]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:40.020]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:40.020]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:40.020]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:40.020]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:40.020]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:40.020]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:40.020]             base::names(...future.oldOptions))
[08:28:40.020]     }
[08:28:40.020]     if (FALSE) {
[08:28:40.020]     }
[08:28:40.020]     else {
[08:28:40.020]         if (TRUE) {
[08:28:40.020]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:40.020]                 open = "w")
[08:28:40.020]         }
[08:28:40.020]         else {
[08:28:40.020]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:40.020]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:40.020]         }
[08:28:40.020]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:40.020]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:40.020]             base::sink(type = "output", split = FALSE)
[08:28:40.020]             base::close(...future.stdout)
[08:28:40.020]         }, add = TRUE)
[08:28:40.020]     }
[08:28:40.020]     ...future.frame <- base::sys.nframe()
[08:28:40.020]     ...future.conditions <- base::list()
[08:28:40.020]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:40.020]     if (FALSE) {
[08:28:40.020]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:40.020]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:40.020]     }
[08:28:40.020]     ...future.result <- base::tryCatch({
[08:28:40.020]         base::withCallingHandlers({
[08:28:40.020]             ...future.value <- base::withVisible(base::local(subset(data, 
[08:28:40.020]                 a == 2)))
[08:28:40.020]             future::FutureResult(value = ...future.value$value, 
[08:28:40.020]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:40.020]                   ...future.rng), globalenv = if (FALSE) 
[08:28:40.020]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:40.020]                     ...future.globalenv.names))
[08:28:40.020]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:40.020]         }, condition = base::local({
[08:28:40.020]             c <- base::c
[08:28:40.020]             inherits <- base::inherits
[08:28:40.020]             invokeRestart <- base::invokeRestart
[08:28:40.020]             length <- base::length
[08:28:40.020]             list <- base::list
[08:28:40.020]             seq.int <- base::seq.int
[08:28:40.020]             signalCondition <- base::signalCondition
[08:28:40.020]             sys.calls <- base::sys.calls
[08:28:40.020]             `[[` <- base::`[[`
[08:28:40.020]             `+` <- base::`+`
[08:28:40.020]             `<<-` <- base::`<<-`
[08:28:40.020]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:40.020]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:40.020]                   3L)]
[08:28:40.020]             }
[08:28:40.020]             function(cond) {
[08:28:40.020]                 is_error <- inherits(cond, "error")
[08:28:40.020]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:40.020]                   NULL)
[08:28:40.020]                 if (is_error) {
[08:28:40.020]                   sessionInformation <- function() {
[08:28:40.020]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:40.020]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:40.020]                       search = base::search(), system = base::Sys.info())
[08:28:40.020]                   }
[08:28:40.020]                   ...future.conditions[[length(...future.conditions) + 
[08:28:40.020]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:40.020]                     cond$call), session = sessionInformation(), 
[08:28:40.020]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:40.020]                   signalCondition(cond)
[08:28:40.020]                 }
[08:28:40.020]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:40.020]                 "immediateCondition"))) {
[08:28:40.020]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:40.020]                   ...future.conditions[[length(...future.conditions) + 
[08:28:40.020]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:40.020]                   if (TRUE && !signal) {
[08:28:40.020]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:40.020]                     {
[08:28:40.020]                       inherits <- base::inherits
[08:28:40.020]                       invokeRestart <- base::invokeRestart
[08:28:40.020]                       is.null <- base::is.null
[08:28:40.020]                       muffled <- FALSE
[08:28:40.020]                       if (inherits(cond, "message")) {
[08:28:40.020]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:40.020]                         if (muffled) 
[08:28:40.020]                           invokeRestart("muffleMessage")
[08:28:40.020]                       }
[08:28:40.020]                       else if (inherits(cond, "warning")) {
[08:28:40.020]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:40.020]                         if (muffled) 
[08:28:40.020]                           invokeRestart("muffleWarning")
[08:28:40.020]                       }
[08:28:40.020]                       else if (inherits(cond, "condition")) {
[08:28:40.020]                         if (!is.null(pattern)) {
[08:28:40.020]                           computeRestarts <- base::computeRestarts
[08:28:40.020]                           grepl <- base::grepl
[08:28:40.020]                           restarts <- computeRestarts(cond)
[08:28:40.020]                           for (restart in restarts) {
[08:28:40.020]                             name <- restart$name
[08:28:40.020]                             if (is.null(name)) 
[08:28:40.020]                               next
[08:28:40.020]                             if (!grepl(pattern, name)) 
[08:28:40.020]                               next
[08:28:40.020]                             invokeRestart(restart)
[08:28:40.020]                             muffled <- TRUE
[08:28:40.020]                             break
[08:28:40.020]                           }
[08:28:40.020]                         }
[08:28:40.020]                       }
[08:28:40.020]                       invisible(muffled)
[08:28:40.020]                     }
[08:28:40.020]                     muffleCondition(cond, pattern = "^muffle")
[08:28:40.020]                   }
[08:28:40.020]                 }
[08:28:40.020]                 else {
[08:28:40.020]                   if (TRUE) {
[08:28:40.020]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:40.020]                     {
[08:28:40.020]                       inherits <- base::inherits
[08:28:40.020]                       invokeRestart <- base::invokeRestart
[08:28:40.020]                       is.null <- base::is.null
[08:28:40.020]                       muffled <- FALSE
[08:28:40.020]                       if (inherits(cond, "message")) {
[08:28:40.020]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:40.020]                         if (muffled) 
[08:28:40.020]                           invokeRestart("muffleMessage")
[08:28:40.020]                       }
[08:28:40.020]                       else if (inherits(cond, "warning")) {
[08:28:40.020]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:40.020]                         if (muffled) 
[08:28:40.020]                           invokeRestart("muffleWarning")
[08:28:40.020]                       }
[08:28:40.020]                       else if (inherits(cond, "condition")) {
[08:28:40.020]                         if (!is.null(pattern)) {
[08:28:40.020]                           computeRestarts <- base::computeRestarts
[08:28:40.020]                           grepl <- base::grepl
[08:28:40.020]                           restarts <- computeRestarts(cond)
[08:28:40.020]                           for (restart in restarts) {
[08:28:40.020]                             name <- restart$name
[08:28:40.020]                             if (is.null(name)) 
[08:28:40.020]                               next
[08:28:40.020]                             if (!grepl(pattern, name)) 
[08:28:40.020]                               next
[08:28:40.020]                             invokeRestart(restart)
[08:28:40.020]                             muffled <- TRUE
[08:28:40.020]                             break
[08:28:40.020]                           }
[08:28:40.020]                         }
[08:28:40.020]                       }
[08:28:40.020]                       invisible(muffled)
[08:28:40.020]                     }
[08:28:40.020]                     muffleCondition(cond, pattern = "^muffle")
[08:28:40.020]                   }
[08:28:40.020]                 }
[08:28:40.020]             }
[08:28:40.020]         }))
[08:28:40.020]     }, error = function(ex) {
[08:28:40.020]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:40.020]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:40.020]                 ...future.rng), started = ...future.startTime, 
[08:28:40.020]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:40.020]             version = "1.8"), class = "FutureResult")
[08:28:40.020]     }, finally = {
[08:28:40.020]         if (!identical(...future.workdir, getwd())) 
[08:28:40.020]             setwd(...future.workdir)
[08:28:40.020]         {
[08:28:40.020]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:40.020]                 ...future.oldOptions$nwarnings <- NULL
[08:28:40.020]             }
[08:28:40.020]             base::options(...future.oldOptions)
[08:28:40.020]             if (.Platform$OS.type == "windows") {
[08:28:40.020]                 old_names <- names(...future.oldEnvVars)
[08:28:40.020]                 envs <- base::Sys.getenv()
[08:28:40.020]                 names <- names(envs)
[08:28:40.020]                 common <- intersect(names, old_names)
[08:28:40.020]                 added <- setdiff(names, old_names)
[08:28:40.020]                 removed <- setdiff(old_names, names)
[08:28:40.020]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:40.020]                   envs[common]]
[08:28:40.020]                 NAMES <- toupper(changed)
[08:28:40.020]                 args <- list()
[08:28:40.020]                 for (kk in seq_along(NAMES)) {
[08:28:40.020]                   name <- changed[[kk]]
[08:28:40.020]                   NAME <- NAMES[[kk]]
[08:28:40.020]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:40.020]                     next
[08:28:40.020]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:40.020]                 }
[08:28:40.020]                 NAMES <- toupper(added)
[08:28:40.020]                 for (kk in seq_along(NAMES)) {
[08:28:40.020]                   name <- added[[kk]]
[08:28:40.020]                   NAME <- NAMES[[kk]]
[08:28:40.020]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:40.020]                     next
[08:28:40.020]                   args[[name]] <- ""
[08:28:40.020]                 }
[08:28:40.020]                 NAMES <- toupper(removed)
[08:28:40.020]                 for (kk in seq_along(NAMES)) {
[08:28:40.020]                   name <- removed[[kk]]
[08:28:40.020]                   NAME <- NAMES[[kk]]
[08:28:40.020]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:40.020]                     next
[08:28:40.020]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:40.020]                 }
[08:28:40.020]                 if (length(args) > 0) 
[08:28:40.020]                   base::do.call(base::Sys.setenv, args = args)
[08:28:40.020]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:40.020]             }
[08:28:40.020]             else {
[08:28:40.020]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:40.020]             }
[08:28:40.020]             {
[08:28:40.020]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:40.020]                   0L) {
[08:28:40.020]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:40.020]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:40.020]                   base::options(opts)
[08:28:40.020]                 }
[08:28:40.020]                 {
[08:28:40.020]                   {
[08:28:40.020]                     NULL
[08:28:40.020]                     RNGkind("Mersenne-Twister")
[08:28:40.020]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:40.020]                       inherits = FALSE)
[08:28:40.020]                   }
[08:28:40.020]                   options(future.plan = NULL)
[08:28:40.020]                   if (is.na(NA_character_)) 
[08:28:40.020]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:40.020]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:40.020]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:40.020]                     .init = FALSE)
[08:28:40.020]                 }
[08:28:40.020]             }
[08:28:40.020]         }
[08:28:40.020]     })
[08:28:40.020]     if (TRUE) {
[08:28:40.020]         base::sink(type = "output", split = FALSE)
[08:28:40.020]         if (TRUE) {
[08:28:40.020]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:40.020]         }
[08:28:40.020]         else {
[08:28:40.020]             ...future.result["stdout"] <- base::list(NULL)
[08:28:40.020]         }
[08:28:40.020]         base::close(...future.stdout)
[08:28:40.020]         ...future.stdout <- NULL
[08:28:40.020]     }
[08:28:40.020]     ...future.result$conditions <- ...future.conditions
[08:28:40.020]     ...future.result$finished <- base::Sys.time()
[08:28:40.020]     ...future.result
[08:28:40.020] }
[08:28:40.046]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.022] assign_globals() ...
[08:28:40.046]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.022] List of 1
[08:28:40.022]  $ data:'data.frame':	3 obs. of  2 variables:
[08:28:40.022]   ..$ a: int [1:3] 1 2 3
[08:28:40.022]   ..$ b: int [1:3] 3 2 1
[08:28:40.022]  - attr(*, "where")=List of 1
[08:28:40.022]   ..$ data:<environment: R_EmptyEnv> 
[08:28:40.022]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:40.022]  - attr(*, "resolved")= logi FALSE
[08:28:40.022]  - attr(*, "total_size")= num 356
[08:28:40.022]  - attr(*, "already-done")= logi TRUE
[08:28:40.046]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.027] - copied ‘data’ to environment
[08:28:40.046]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.027] assign_globals() ... done
[08:28:40.047]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.028] plan(): Setting new future strategy stack:
[08:28:40.047]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.028] List of future strategies:
[08:28:40.028] 1. sequential:
[08:28:40.028]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:40.028]    - tweaked: FALSE
[08:28:40.028]    - call: NULL
[08:28:40.047]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.029] plan(): nbrOfWorkers() = 1
[08:28:40.047]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.030] plan(): Setting new future strategy stack:
[08:28:40.047]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.030] List of future strategies:
[08:28:40.030] 1. multisession:
[08:28:40.030]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:28:40.030]    - tweaked: FALSE
[08:28:40.030]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:40.047]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.032] plan(): nbrOfWorkers() = 1
[08:28:40.047]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.032] SequentialFuture started (and completed)
[08:28:40.048]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.033] - Launch lazy future ... done
[08:28:40.048]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:40.033] run() for ‘SequentialFuture’ ... done
[08:28:40.048] signalConditions() ... done
- plan(list('multicore', 'multisession')) ... DONE
- plan(list('multisession', 'sequential')) ...
[08:28:40.048] plan(): Setting new future strategy stack:
[08:28:40.048] List of future strategies:
[08:28:40.048] 1. multisession:
[08:28:40.048]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:28:40.048]    - tweaked: FALSE
[08:28:40.048]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:40.048] 2. sequential:
[08:28:40.048]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:40.048]    - tweaked: FALSE
[08:28:40.048]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:40.049] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[08:28:40.049] multisession:
[08:28:40.049] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:28:40.049] - tweaked: FALSE
[08:28:40.049] - call: plan(list(a = strategy1, b = strategy2))
[08:28:40.052] getGlobalsAndPackages() ...
[08:28:40.052] Not searching for globals
[08:28:40.052] - globals: [0] <none>
[08:28:40.052] getGlobalsAndPackages() ... DONE
[08:28:40.066] Packages needed by the future expression (n = 0): <none>
[08:28:40.066] Packages needed by future strategies (n = 1): ‘future’
[08:28:40.067] {
[08:28:40.067]     {
[08:28:40.067]         {
[08:28:40.067]             ...future.startTime <- base::Sys.time()
[08:28:40.067]             {
[08:28:40.067]                 {
[08:28:40.067]                   {
[08:28:40.067]                     {
[08:28:40.067]                       {
[08:28:40.067]                         base::local({
[08:28:40.067]                           has_future <- base::requireNamespace("future", 
[08:28:40.067]                             quietly = TRUE)
[08:28:40.067]                           if (has_future) {
[08:28:40.067]                             ns <- base::getNamespace("future")
[08:28:40.067]                             version <- ns[[".package"]][["version"]]
[08:28:40.067]                             if (is.null(version)) 
[08:28:40.067]                               version <- utils::packageVersion("future")
[08:28:40.067]                           }
[08:28:40.067]                           else {
[08:28:40.067]                             version <- NULL
[08:28:40.067]                           }
[08:28:40.067]                           if (!has_future || version < "1.8.0") {
[08:28:40.067]                             info <- base::c(r_version = base::gsub("R version ", 
[08:28:40.067]                               "", base::R.version$version.string), 
[08:28:40.067]                               platform = base::sprintf("%s (%s-bit)", 
[08:28:40.067]                                 base::R.version$platform, 8 * 
[08:28:40.067]                                   base::.Machine$sizeof.pointer), 
[08:28:40.067]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:40.067]                                 "release", "version")], collapse = " "), 
[08:28:40.067]                               hostname = base::Sys.info()[["nodename"]])
[08:28:40.067]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:28:40.067]                               info)
[08:28:40.067]                             info <- base::paste(info, collapse = "; ")
[08:28:40.067]                             if (!has_future) {
[08:28:40.067]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:40.067]                                 info)
[08:28:40.067]                             }
[08:28:40.067]                             else {
[08:28:40.067]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:40.067]                                 info, version)
[08:28:40.067]                             }
[08:28:40.067]                             base::stop(msg)
[08:28:40.067]                           }
[08:28:40.067]                         })
[08:28:40.067]                       }
[08:28:40.067]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:40.067]                       base::options(mc.cores = 1L)
[08:28:40.067]                     }
[08:28:40.067]                     base::local({
[08:28:40.067]                       for (pkg in "future") {
[08:28:40.067]                         base::loadNamespace(pkg)
[08:28:40.067]                         base::library(pkg, character.only = TRUE)
[08:28:40.067]                       }
[08:28:40.067]                     })
[08:28:40.067]                   }
[08:28:40.067]                   ...future.strategy.old <- future::plan("list")
[08:28:40.067]                   options(future.plan = NULL)
[08:28:40.067]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:40.067]                   future::plan(list(b = function (..., envir = parent.frame()) 
[08:28:40.067]                   {
[08:28:40.067]                     future <- SequentialFuture(..., envir = envir)
[08:28:40.067]                     if (!future$lazy) 
[08:28:40.067]                       future <- run(future)
[08:28:40.067]                     invisible(future)
[08:28:40.067]                   }), .cleanup = FALSE, .init = FALSE)
[08:28:40.067]                 }
[08:28:40.067]                 ...future.workdir <- getwd()
[08:28:40.067]             }
[08:28:40.067]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:40.067]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:40.067]         }
[08:28:40.067]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:40.067]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:40.067]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:40.067]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:40.067]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:40.067]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:40.067]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:40.067]             base::names(...future.oldOptions))
[08:28:40.067]     }
[08:28:40.067]     if (FALSE) {
[08:28:40.067]     }
[08:28:40.067]     else {
[08:28:40.067]         if (TRUE) {
[08:28:40.067]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:40.067]                 open = "w")
[08:28:40.067]         }
[08:28:40.067]         else {
[08:28:40.067]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:40.067]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:40.067]         }
[08:28:40.067]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:40.067]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:40.067]             base::sink(type = "output", split = FALSE)
[08:28:40.067]             base::close(...future.stdout)
[08:28:40.067]         }, add = TRUE)
[08:28:40.067]     }
[08:28:40.067]     ...future.frame <- base::sys.nframe()
[08:28:40.067]     ...future.conditions <- base::list()
[08:28:40.067]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:40.067]     if (FALSE) {
[08:28:40.067]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:40.067]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:40.067]     }
[08:28:40.067]     ...future.result <- base::tryCatch({
[08:28:40.067]         base::withCallingHandlers({
[08:28:40.067]             ...future.value <- base::withVisible(base::local({
[08:28:40.067]                 ...future.makeSendCondition <- base::local({
[08:28:40.067]                   sendCondition <- NULL
[08:28:40.067]                   function(frame = 1L) {
[08:28:40.067]                     if (is.function(sendCondition)) 
[08:28:40.067]                       return(sendCondition)
[08:28:40.067]                     ns <- getNamespace("parallel")
[08:28:40.067]                     if (exists("sendData", mode = "function", 
[08:28:40.067]                       envir = ns)) {
[08:28:40.067]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:40.067]                         envir = ns)
[08:28:40.067]                       envir <- sys.frame(frame)
[08:28:40.067]                       master <- NULL
[08:28:40.067]                       while (!identical(envir, .GlobalEnv) && 
[08:28:40.067]                         !identical(envir, emptyenv())) {
[08:28:40.067]                         if (exists("master", mode = "list", envir = envir, 
[08:28:40.067]                           inherits = FALSE)) {
[08:28:40.067]                           master <- get("master", mode = "list", 
[08:28:40.067]                             envir = envir, inherits = FALSE)
[08:28:40.067]                           if (inherits(master, c("SOCKnode", 
[08:28:40.067]                             "SOCK0node"))) {
[08:28:40.067]                             sendCondition <<- function(cond) {
[08:28:40.067]                               data <- list(type = "VALUE", value = cond, 
[08:28:40.067]                                 success = TRUE)
[08:28:40.067]                               parallel_sendData(master, data)
[08:28:40.067]                             }
[08:28:40.067]                             return(sendCondition)
[08:28:40.067]                           }
[08:28:40.067]                         }
[08:28:40.067]                         frame <- frame + 1L
[08:28:40.067]                         envir <- sys.frame(frame)
[08:28:40.067]                       }
[08:28:40.067]                     }
[08:28:40.067]                     sendCondition <<- function(cond) NULL
[08:28:40.067]                   }
[08:28:40.067]                 })
[08:28:40.067]                 withCallingHandlers({
[08:28:40.067]                   NA
[08:28:40.067]                 }, immediateCondition = function(cond) {
[08:28:40.067]                   sendCondition <- ...future.makeSendCondition()
[08:28:40.067]                   sendCondition(cond)
[08:28:40.067]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:40.067]                   {
[08:28:40.067]                     inherits <- base::inherits
[08:28:40.067]                     invokeRestart <- base::invokeRestart
[08:28:40.067]                     is.null <- base::is.null
[08:28:40.067]                     muffled <- FALSE
[08:28:40.067]                     if (inherits(cond, "message")) {
[08:28:40.067]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:40.067]                       if (muffled) 
[08:28:40.067]                         invokeRestart("muffleMessage")
[08:28:40.067]                     }
[08:28:40.067]                     else if (inherits(cond, "warning")) {
[08:28:40.067]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:40.067]                       if (muffled) 
[08:28:40.067]                         invokeRestart("muffleWarning")
[08:28:40.067]                     }
[08:28:40.067]                     else if (inherits(cond, "condition")) {
[08:28:40.067]                       if (!is.null(pattern)) {
[08:28:40.067]                         computeRestarts <- base::computeRestarts
[08:28:40.067]                         grepl <- base::grepl
[08:28:40.067]                         restarts <- computeRestarts(cond)
[08:28:40.067]                         for (restart in restarts) {
[08:28:40.067]                           name <- restart$name
[08:28:40.067]                           if (is.null(name)) 
[08:28:40.067]                             next
[08:28:40.067]                           if (!grepl(pattern, name)) 
[08:28:40.067]                             next
[08:28:40.067]                           invokeRestart(restart)
[08:28:40.067]                           muffled <- TRUE
[08:28:40.067]                           break
[08:28:40.067]                         }
[08:28:40.067]                       }
[08:28:40.067]                     }
[08:28:40.067]                     invisible(muffled)
[08:28:40.067]                   }
[08:28:40.067]                   muffleCondition(cond)
[08:28:40.067]                 })
[08:28:40.067]             }))
[08:28:40.067]             future::FutureResult(value = ...future.value$value, 
[08:28:40.067]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:40.067]                   ...future.rng), globalenv = if (FALSE) 
[08:28:40.067]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:40.067]                     ...future.globalenv.names))
[08:28:40.067]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:40.067]         }, condition = base::local({
[08:28:40.067]             c <- base::c
[08:28:40.067]             inherits <- base::inherits
[08:28:40.067]             invokeRestart <- base::invokeRestart
[08:28:40.067]             length <- base::length
[08:28:40.067]             list <- base::list
[08:28:40.067]             seq.int <- base::seq.int
[08:28:40.067]             signalCondition <- base::signalCondition
[08:28:40.067]             sys.calls <- base::sys.calls
[08:28:40.067]             `[[` <- base::`[[`
[08:28:40.067]             `+` <- base::`+`
[08:28:40.067]             `<<-` <- base::`<<-`
[08:28:40.067]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:40.067]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:40.067]                   3L)]
[08:28:40.067]             }
[08:28:40.067]             function(cond) {
[08:28:40.067]                 is_error <- inherits(cond, "error")
[08:28:40.067]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:40.067]                   NULL)
[08:28:40.067]                 if (is_error) {
[08:28:40.067]                   sessionInformation <- function() {
[08:28:40.067]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:40.067]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:40.067]                       search = base::search(), system = base::Sys.info())
[08:28:40.067]                   }
[08:28:40.067]                   ...future.conditions[[length(...future.conditions) + 
[08:28:40.067]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:40.067]                     cond$call), session = sessionInformation(), 
[08:28:40.067]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:40.067]                   signalCondition(cond)
[08:28:40.067]                 }
[08:28:40.067]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:40.067]                 "immediateCondition"))) {
[08:28:40.067]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:40.067]                   ...future.conditions[[length(...future.conditions) + 
[08:28:40.067]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:40.067]                   if (TRUE && !signal) {
[08:28:40.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:40.067]                     {
[08:28:40.067]                       inherits <- base::inherits
[08:28:40.067]                       invokeRestart <- base::invokeRestart
[08:28:40.067]                       is.null <- base::is.null
[08:28:40.067]                       muffled <- FALSE
[08:28:40.067]                       if (inherits(cond, "message")) {
[08:28:40.067]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:40.067]                         if (muffled) 
[08:28:40.067]                           invokeRestart("muffleMessage")
[08:28:40.067]                       }
[08:28:40.067]                       else if (inherits(cond, "warning")) {
[08:28:40.067]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:40.067]                         if (muffled) 
[08:28:40.067]                           invokeRestart("muffleWarning")
[08:28:40.067]                       }
[08:28:40.067]                       else if (inherits(cond, "condition")) {
[08:28:40.067]                         if (!is.null(pattern)) {
[08:28:40.067]                           computeRestarts <- base::computeRestarts
[08:28:40.067]                           grepl <- base::grepl
[08:28:40.067]                           restarts <- computeRestarts(cond)
[08:28:40.067]                           for (restart in restarts) {
[08:28:40.067]                             name <- restart$name
[08:28:40.067]                             if (is.null(name)) 
[08:28:40.067]                               next
[08:28:40.067]                             if (!grepl(pattern, name)) 
[08:28:40.067]                               next
[08:28:40.067]                             invokeRestart(restart)
[08:28:40.067]                             muffled <- TRUE
[08:28:40.067]                             break
[08:28:40.067]                           }
[08:28:40.067]                         }
[08:28:40.067]                       }
[08:28:40.067]                       invisible(muffled)
[08:28:40.067]                     }
[08:28:40.067]                     muffleCondition(cond, pattern = "^muffle")
[08:28:40.067]                   }
[08:28:40.067]                 }
[08:28:40.067]                 else {
[08:28:40.067]                   if (TRUE) {
[08:28:40.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:40.067]                     {
[08:28:40.067]                       inherits <- base::inherits
[08:28:40.067]                       invokeRestart <- base::invokeRestart
[08:28:40.067]                       is.null <- base::is.null
[08:28:40.067]                       muffled <- FALSE
[08:28:40.067]                       if (inherits(cond, "message")) {
[08:28:40.067]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:40.067]                         if (muffled) 
[08:28:40.067]                           invokeRestart("muffleMessage")
[08:28:40.067]                       }
[08:28:40.067]                       else if (inherits(cond, "warning")) {
[08:28:40.067]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:40.067]                         if (muffled) 
[08:28:40.067]                           invokeRestart("muffleWarning")
[08:28:40.067]                       }
[08:28:40.067]                       else if (inherits(cond, "condition")) {
[08:28:40.067]                         if (!is.null(pattern)) {
[08:28:40.067]                           computeRestarts <- base::computeRestarts
[08:28:40.067]                           grepl <- base::grepl
[08:28:40.067]                           restarts <- computeRestarts(cond)
[08:28:40.067]                           for (restart in restarts) {
[08:28:40.067]                             name <- restart$name
[08:28:40.067]                             if (is.null(name)) 
[08:28:40.067]                               next
[08:28:40.067]                             if (!grepl(pattern, name)) 
[08:28:40.067]                               next
[08:28:40.067]                             invokeRestart(restart)
[08:28:40.067]                             muffled <- TRUE
[08:28:40.067]                             break
[08:28:40.067]                           }
[08:28:40.067]                         }
[08:28:40.067]                       }
[08:28:40.067]                       invisible(muffled)
[08:28:40.067]                     }
[08:28:40.067]                     muffleCondition(cond, pattern = "^muffle")
[08:28:40.067]                   }
[08:28:40.067]                 }
[08:28:40.067]             }
[08:28:40.067]         }))
[08:28:40.067]     }, error = function(ex) {
[08:28:40.067]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:40.067]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:40.067]                 ...future.rng), started = ...future.startTime, 
[08:28:40.067]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:40.067]             version = "1.8"), class = "FutureResult")
[08:28:40.067]     }, finally = {
[08:28:40.067]         if (!identical(...future.workdir, getwd())) 
[08:28:40.067]             setwd(...future.workdir)
[08:28:40.067]         {
[08:28:40.067]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:40.067]                 ...future.oldOptions$nwarnings <- NULL
[08:28:40.067]             }
[08:28:40.067]             base::options(...future.oldOptions)
[08:28:40.067]             if (.Platform$OS.type == "windows") {
[08:28:40.067]                 old_names <- names(...future.oldEnvVars)
[08:28:40.067]                 envs <- base::Sys.getenv()
[08:28:40.067]                 names <- names(envs)
[08:28:40.067]                 common <- intersect(names, old_names)
[08:28:40.067]                 added <- setdiff(names, old_names)
[08:28:40.067]                 removed <- setdiff(old_names, names)
[08:28:40.067]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:40.067]                   envs[common]]
[08:28:40.067]                 NAMES <- toupper(changed)
[08:28:40.067]                 args <- list()
[08:28:40.067]                 for (kk in seq_along(NAMES)) {
[08:28:40.067]                   name <- changed[[kk]]
[08:28:40.067]                   NAME <- NAMES[[kk]]
[08:28:40.067]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:40.067]                     next
[08:28:40.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:40.067]                 }
[08:28:40.067]                 NAMES <- toupper(added)
[08:28:40.067]                 for (kk in seq_along(NAMES)) {
[08:28:40.067]                   name <- added[[kk]]
[08:28:40.067]                   NAME <- NAMES[[kk]]
[08:28:40.067]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:40.067]                     next
[08:28:40.067]                   args[[name]] <- ""
[08:28:40.067]                 }
[08:28:40.067]                 NAMES <- toupper(removed)
[08:28:40.067]                 for (kk in seq_along(NAMES)) {
[08:28:40.067]                   name <- removed[[kk]]
[08:28:40.067]                   NAME <- NAMES[[kk]]
[08:28:40.067]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:40.067]                     next
[08:28:40.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:40.067]                 }
[08:28:40.067]                 if (length(args) > 0) 
[08:28:40.067]                   base::do.call(base::Sys.setenv, args = args)
[08:28:40.067]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:40.067]             }
[08:28:40.067]             else {
[08:28:40.067]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:40.067]             }
[08:28:40.067]             {
[08:28:40.067]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:40.067]                   0L) {
[08:28:40.067]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:40.067]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:40.067]                   base::options(opts)
[08:28:40.067]                 }
[08:28:40.067]                 {
[08:28:40.067]                   {
[08:28:40.067]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:40.067]                     NULL
[08:28:40.067]                   }
[08:28:40.067]                   options(future.plan = NULL)
[08:28:40.067]                   if (is.na(NA_character_)) 
[08:28:40.067]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:40.067]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:40.067]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:40.067]                     .init = FALSE)
[08:28:40.067]                 }
[08:28:40.067]             }
[08:28:40.067]         }
[08:28:40.067]     })
[08:28:40.067]     if (TRUE) {
[08:28:40.067]         base::sink(type = "output", split = FALSE)
[08:28:40.067]         if (TRUE) {
[08:28:40.067]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:40.067]         }
[08:28:40.067]         else {
[08:28:40.067]             ...future.result["stdout"] <- base::list(NULL)
[08:28:40.067]         }
[08:28:40.067]         base::close(...future.stdout)
[08:28:40.067]         ...future.stdout <- NULL
[08:28:40.067]     }
[08:28:40.067]     ...future.result$conditions <- ...future.conditions
[08:28:40.067]     ...future.result$finished <- base::Sys.time()
[08:28:40.067]     ...future.result
[08:28:40.067] }
[08:28:40.070] MultisessionFuture started
[08:28:40.071] result() for ClusterFuture ...
[08:28:40.071] receiveMessageFromWorker() for ClusterFuture ...
[08:28:40.071] - Validating connection of MultisessionFuture
[08:28:40.116] - received message: FutureResult
[08:28:40.116] - Received FutureResult
[08:28:40.116] - Erased future from FutureRegistry
[08:28:40.116] result() for ClusterFuture ...
[08:28:40.117] - result already collected: FutureResult
[08:28:40.117] result() for ClusterFuture ... done
[08:28:40.117] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:40.117] result() for ClusterFuture ... done
[08:28:40.117] result() for ClusterFuture ...
[08:28:40.117] - result already collected: FutureResult
[08:28:40.117] result() for ClusterFuture ... done
[08:28:40.117] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[08:28:40.119] plan(): nbrOfWorkers() = 2
[08:28:40.119] getGlobalsAndPackages() ...
[08:28:40.120] Searching for globals...
[08:28:40.142] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[08:28:40.142] Searching for globals ... DONE
[08:28:40.142] Resolving globals: FALSE
[08:28:40.143] The total size of the 2 globals is 7.46 KiB (7637 bytes)
[08:28:40.144] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 7.46 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (7.41 KiB of class ‘list’) and ‘strategy2’ (49 bytes of class ‘character’)
[08:28:40.144] - globals: [2] ‘nested’, ‘strategy2’
[08:28:40.144] - packages: [1] ‘future’
[08:28:40.144] getGlobalsAndPackages() ... DONE
[08:28:40.144] run() for ‘Future’ ...
[08:28:40.145] - state: ‘created’
[08:28:40.145] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:40.159] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:40.159] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:40.159]   - Field: ‘node’
[08:28:40.159]   - Field: ‘label’
[08:28:40.159]   - Field: ‘local’
[08:28:40.159]   - Field: ‘owner’
[08:28:40.160]   - Field: ‘envir’
[08:28:40.160]   - Field: ‘workers’
[08:28:40.160]   - Field: ‘packages’
[08:28:40.160]   - Field: ‘gc’
[08:28:40.160]   - Field: ‘conditions’
[08:28:40.160]   - Field: ‘persistent’
[08:28:40.160]   - Field: ‘expr’
[08:28:40.160]   - Field: ‘uuid’
[08:28:40.160]   - Field: ‘seed’
[08:28:40.160]   - Field: ‘version’
[08:28:40.160]   - Field: ‘result’
[08:28:40.161]   - Field: ‘asynchronous’
[08:28:40.161]   - Field: ‘calls’
[08:28:40.161]   - Field: ‘globals’
[08:28:40.161]   - Field: ‘stdout’
[08:28:40.161]   - Field: ‘earlySignal’
[08:28:40.161]   - Field: ‘lazy’
[08:28:40.161]   - Field: ‘state’
[08:28:40.161] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:40.161] - Launch lazy future ...
[08:28:40.162] Packages needed by the future expression (n = 1): ‘future’
[08:28:40.162] Packages needed by future strategies (n = 1): ‘future’
[08:28:40.162] {
[08:28:40.162]     {
[08:28:40.162]         {
[08:28:40.162]             ...future.startTime <- base::Sys.time()
[08:28:40.162]             {
[08:28:40.162]                 {
[08:28:40.162]                   {
[08:28:40.162]                     {
[08:28:40.162]                       {
[08:28:40.162]                         base::local({
[08:28:40.162]                           has_future <- base::requireNamespace("future", 
[08:28:40.162]                             quietly = TRUE)
[08:28:40.162]                           if (has_future) {
[08:28:40.162]                             ns <- base::getNamespace("future")
[08:28:40.162]                             version <- ns[[".package"]][["version"]]
[08:28:40.162]                             if (is.null(version)) 
[08:28:40.162]                               version <- utils::packageVersion("future")
[08:28:40.162]                           }
[08:28:40.162]                           else {
[08:28:40.162]                             version <- NULL
[08:28:40.162]                           }
[08:28:40.162]                           if (!has_future || version < "1.8.0") {
[08:28:40.162]                             info <- base::c(r_version = base::gsub("R version ", 
[08:28:40.162]                               "", base::R.version$version.string), 
[08:28:40.162]                               platform = base::sprintf("%s (%s-bit)", 
[08:28:40.162]                                 base::R.version$platform, 8 * 
[08:28:40.162]                                   base::.Machine$sizeof.pointer), 
[08:28:40.162]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:40.162]                                 "release", "version")], collapse = " "), 
[08:28:40.162]                               hostname = base::Sys.info()[["nodename"]])
[08:28:40.162]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:28:40.162]                               info)
[08:28:40.162]                             info <- base::paste(info, collapse = "; ")
[08:28:40.162]                             if (!has_future) {
[08:28:40.162]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:40.162]                                 info)
[08:28:40.162]                             }
[08:28:40.162]                             else {
[08:28:40.162]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:40.162]                                 info, version)
[08:28:40.162]                             }
[08:28:40.162]                             base::stop(msg)
[08:28:40.162]                           }
[08:28:40.162]                         })
[08:28:40.162]                       }
[08:28:40.162]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:40.162]                       base::options(mc.cores = 1L)
[08:28:40.162]                     }
[08:28:40.162]                     base::local({
[08:28:40.162]                       for (pkg in "future") {
[08:28:40.162]                         base::loadNamespace(pkg)
[08:28:40.162]                         base::library(pkg, character.only = TRUE)
[08:28:40.162]                       }
[08:28:40.162]                     })
[08:28:40.162]                   }
[08:28:40.162]                   ...future.strategy.old <- future::plan("list")
[08:28:40.162]                   options(future.plan = NULL)
[08:28:40.162]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:40.162]                   future::plan(list(b = function (..., envir = parent.frame()) 
[08:28:40.162]                   {
[08:28:40.162]                     future <- SequentialFuture(..., envir = envir)
[08:28:40.162]                     if (!future$lazy) 
[08:28:40.162]                       future <- run(future)
[08:28:40.162]                     invisible(future)
[08:28:40.162]                   }), .cleanup = FALSE, .init = FALSE)
[08:28:40.162]                 }
[08:28:40.162]                 ...future.workdir <- getwd()
[08:28:40.162]             }
[08:28:40.162]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:40.162]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:40.162]         }
[08:28:40.162]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:40.162]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:40.162]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:40.162]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:40.162]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:40.162]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:40.162]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:40.162]             base::names(...future.oldOptions))
[08:28:40.162]     }
[08:28:40.162]     if (FALSE) {
[08:28:40.162]     }
[08:28:40.162]     else {
[08:28:40.162]         if (TRUE) {
[08:28:40.162]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:40.162]                 open = "w")
[08:28:40.162]         }
[08:28:40.162]         else {
[08:28:40.162]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:40.162]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:40.162]         }
[08:28:40.162]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:40.162]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:40.162]             base::sink(type = "output", split = FALSE)
[08:28:40.162]             base::close(...future.stdout)
[08:28:40.162]         }, add = TRUE)
[08:28:40.162]     }
[08:28:40.162]     ...future.frame <- base::sys.nframe()
[08:28:40.162]     ...future.conditions <- base::list()
[08:28:40.162]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:40.162]     if (FALSE) {
[08:28:40.162]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:40.162]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:40.162]     }
[08:28:40.162]     ...future.result <- base::tryCatch({
[08:28:40.162]         base::withCallingHandlers({
[08:28:40.162]             ...future.value <- base::withVisible(base::local({
[08:28:40.162]                 ...future.makeSendCondition <- base::local({
[08:28:40.162]                   sendCondition <- NULL
[08:28:40.162]                   function(frame = 1L) {
[08:28:40.162]                     if (is.function(sendCondition)) 
[08:28:40.162]                       return(sendCondition)
[08:28:40.162]                     ns <- getNamespace("parallel")
[08:28:40.162]                     if (exists("sendData", mode = "function", 
[08:28:40.162]                       envir = ns)) {
[08:28:40.162]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:40.162]                         envir = ns)
[08:28:40.162]                       envir <- sys.frame(frame)
[08:28:40.162]                       master <- NULL
[08:28:40.162]                       while (!identical(envir, .GlobalEnv) && 
[08:28:40.162]                         !identical(envir, emptyenv())) {
[08:28:40.162]                         if (exists("master", mode = "list", envir = envir, 
[08:28:40.162]                           inherits = FALSE)) {
[08:28:40.162]                           master <- get("master", mode = "list", 
[08:28:40.162]                             envir = envir, inherits = FALSE)
[08:28:40.162]                           if (inherits(master, c("SOCKnode", 
[08:28:40.162]                             "SOCK0node"))) {
[08:28:40.162]                             sendCondition <<- function(cond) {
[08:28:40.162]                               data <- list(type = "VALUE", value = cond, 
[08:28:40.162]                                 success = TRUE)
[08:28:40.162]                               parallel_sendData(master, data)
[08:28:40.162]                             }
[08:28:40.162]                             return(sendCondition)
[08:28:40.162]                           }
[08:28:40.162]                         }
[08:28:40.162]                         frame <- frame + 1L
[08:28:40.162]                         envir <- sys.frame(frame)
[08:28:40.162]                       }
[08:28:40.162]                     }
[08:28:40.162]                     sendCondition <<- function(cond) NULL
[08:28:40.162]                   }
[08:28:40.162]                 })
[08:28:40.162]                 withCallingHandlers({
[08:28:40.162]                   {
[08:28:40.162]                     a <- 1L
[08:28:40.162]                     plan_a <- unclass(future::plan("list"))
[08:28:40.162]                     nested_a <- nested[-1]
[08:28:40.162]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[08:28:40.162]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[08:28:40.162]                       strategy2))
[08:28:40.162]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[08:28:40.162]                       "init") <- NULL
[08:28:40.162]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[08:28:40.162]                       "init") <- NULL
[08:28:40.162]                     stopifnot(all.equal(plan_a, nested_a))
[08:28:40.162]                     y %<-% {
[08:28:40.162]                       b <- 2L
[08:28:40.162]                       plan_b <- future::plan("list")
[08:28:40.162]                       nested_b <- nested_a[-1]
[08:28:40.162]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[08:28:40.162]                         1L, inherits(plan_b[[1]], "future"), 
[08:28:40.162]                         inherits(future::plan("next"), "sequential"))
[08:28:40.162]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[08:28:40.162]                         b = b, nested_b = nested_b, plan_b = plan_b)
[08:28:40.162]                     }
[08:28:40.162]                     y
[08:28:40.162]                   }
[08:28:40.162]                 }, immediateCondition = function(cond) {
[08:28:40.162]                   sendCondition <- ...future.makeSendCondition()
[08:28:40.162]                   sendCondition(cond)
[08:28:40.162]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:40.162]                   {
[08:28:40.162]                     inherits <- base::inherits
[08:28:40.162]                     invokeRestart <- base::invokeRestart
[08:28:40.162]                     is.null <- base::is.null
[08:28:40.162]                     muffled <- FALSE
[08:28:40.162]                     if (inherits(cond, "message")) {
[08:28:40.162]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:40.162]                       if (muffled) 
[08:28:40.162]                         invokeRestart("muffleMessage")
[08:28:40.162]                     }
[08:28:40.162]                     else if (inherits(cond, "warning")) {
[08:28:40.162]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:40.162]                       if (muffled) 
[08:28:40.162]                         invokeRestart("muffleWarning")
[08:28:40.162]                     }
[08:28:40.162]                     else if (inherits(cond, "condition")) {
[08:28:40.162]                       if (!is.null(pattern)) {
[08:28:40.162]                         computeRestarts <- base::computeRestarts
[08:28:40.162]                         grepl <- base::grepl
[08:28:40.162]                         restarts <- computeRestarts(cond)
[08:28:40.162]                         for (restart in restarts) {
[08:28:40.162]                           name <- restart$name
[08:28:40.162]                           if (is.null(name)) 
[08:28:40.162]                             next
[08:28:40.162]                           if (!grepl(pattern, name)) 
[08:28:40.162]                             next
[08:28:40.162]                           invokeRestart(restart)
[08:28:40.162]                           muffled <- TRUE
[08:28:40.162]                           break
[08:28:40.162]                         }
[08:28:40.162]                       }
[08:28:40.162]                     }
[08:28:40.162]                     invisible(muffled)
[08:28:40.162]                   }
[08:28:40.162]                   muffleCondition(cond)
[08:28:40.162]                 })
[08:28:40.162]             }))
[08:28:40.162]             future::FutureResult(value = ...future.value$value, 
[08:28:40.162]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:40.162]                   ...future.rng), globalenv = if (FALSE) 
[08:28:40.162]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:40.162]                     ...future.globalenv.names))
[08:28:40.162]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:40.162]         }, condition = base::local({
[08:28:40.162]             c <- base::c
[08:28:40.162]             inherits <- base::inherits
[08:28:40.162]             invokeRestart <- base::invokeRestart
[08:28:40.162]             length <- base::length
[08:28:40.162]             list <- base::list
[08:28:40.162]             seq.int <- base::seq.int
[08:28:40.162]             signalCondition <- base::signalCondition
[08:28:40.162]             sys.calls <- base::sys.calls
[08:28:40.162]             `[[` <- base::`[[`
[08:28:40.162]             `+` <- base::`+`
[08:28:40.162]             `<<-` <- base::`<<-`
[08:28:40.162]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:40.162]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:40.162]                   3L)]
[08:28:40.162]             }
[08:28:40.162]             function(cond) {
[08:28:40.162]                 is_error <- inherits(cond, "error")
[08:28:40.162]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:40.162]                   NULL)
[08:28:40.162]                 if (is_error) {
[08:28:40.162]                   sessionInformation <- function() {
[08:28:40.162]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:40.162]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:40.162]                       search = base::search(), system = base::Sys.info())
[08:28:40.162]                   }
[08:28:40.162]                   ...future.conditions[[length(...future.conditions) + 
[08:28:40.162]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:40.162]                     cond$call), session = sessionInformation(), 
[08:28:40.162]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:40.162]                   signalCondition(cond)
[08:28:40.162]                 }
[08:28:40.162]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:40.162]                 "immediateCondition"))) {
[08:28:40.162]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:40.162]                   ...future.conditions[[length(...future.conditions) + 
[08:28:40.162]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:40.162]                   if (TRUE && !signal) {
[08:28:40.162]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:40.162]                     {
[08:28:40.162]                       inherits <- base::inherits
[08:28:40.162]                       invokeRestart <- base::invokeRestart
[08:28:40.162]                       is.null <- base::is.null
[08:28:40.162]                       muffled <- FALSE
[08:28:40.162]                       if (inherits(cond, "message")) {
[08:28:40.162]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:40.162]                         if (muffled) 
[08:28:40.162]                           invokeRestart("muffleMessage")
[08:28:40.162]                       }
[08:28:40.162]                       else if (inherits(cond, "warning")) {
[08:28:40.162]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:40.162]                         if (muffled) 
[08:28:40.162]                           invokeRestart("muffleWarning")
[08:28:40.162]                       }
[08:28:40.162]                       else if (inherits(cond, "condition")) {
[08:28:40.162]                         if (!is.null(pattern)) {
[08:28:40.162]                           computeRestarts <- base::computeRestarts
[08:28:40.162]                           grepl <- base::grepl
[08:28:40.162]                           restarts <- computeRestarts(cond)
[08:28:40.162]                           for (restart in restarts) {
[08:28:40.162]                             name <- restart$name
[08:28:40.162]                             if (is.null(name)) 
[08:28:40.162]                               next
[08:28:40.162]                             if (!grepl(pattern, name)) 
[08:28:40.162]                               next
[08:28:40.162]                             invokeRestart(restart)
[08:28:40.162]                             muffled <- TRUE
[08:28:40.162]                             break
[08:28:40.162]                           }
[08:28:40.162]                         }
[08:28:40.162]                       }
[08:28:40.162]                       invisible(muffled)
[08:28:40.162]                     }
[08:28:40.162]                     muffleCondition(cond, pattern = "^muffle")
[08:28:40.162]                   }
[08:28:40.162]                 }
[08:28:40.162]                 else {
[08:28:40.162]                   if (TRUE) {
[08:28:40.162]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:40.162]                     {
[08:28:40.162]                       inherits <- base::inherits
[08:28:40.162]                       invokeRestart <- base::invokeRestart
[08:28:40.162]                       is.null <- base::is.null
[08:28:40.162]                       muffled <- FALSE
[08:28:40.162]                       if (inherits(cond, "message")) {
[08:28:40.162]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:40.162]                         if (muffled) 
[08:28:40.162]                           invokeRestart("muffleMessage")
[08:28:40.162]                       }
[08:28:40.162]                       else if (inherits(cond, "warning")) {
[08:28:40.162]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:40.162]                         if (muffled) 
[08:28:40.162]                           invokeRestart("muffleWarning")
[08:28:40.162]                       }
[08:28:40.162]                       else if (inherits(cond, "condition")) {
[08:28:40.162]                         if (!is.null(pattern)) {
[08:28:40.162]                           computeRestarts <- base::computeRestarts
[08:28:40.162]                           grepl <- base::grepl
[08:28:40.162]                           restarts <- computeRestarts(cond)
[08:28:40.162]                           for (restart in restarts) {
[08:28:40.162]                             name <- restart$name
[08:28:40.162]                             if (is.null(name)) 
[08:28:40.162]                               next
[08:28:40.162]                             if (!grepl(pattern, name)) 
[08:28:40.162]                               next
[08:28:40.162]                             invokeRestart(restart)
[08:28:40.162]                             muffled <- TRUE
[08:28:40.162]                             break
[08:28:40.162]                           }
[08:28:40.162]                         }
[08:28:40.162]                       }
[08:28:40.162]                       invisible(muffled)
[08:28:40.162]                     }
[08:28:40.162]                     muffleCondition(cond, pattern = "^muffle")
[08:28:40.162]                   }
[08:28:40.162]                 }
[08:28:40.162]             }
[08:28:40.162]         }))
[08:28:40.162]     }, error = function(ex) {
[08:28:40.162]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:40.162]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:40.162]                 ...future.rng), started = ...future.startTime, 
[08:28:40.162]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:40.162]             version = "1.8"), class = "FutureResult")
[08:28:40.162]     }, finally = {
[08:28:40.162]         if (!identical(...future.workdir, getwd())) 
[08:28:40.162]             setwd(...future.workdir)
[08:28:40.162]         {
[08:28:40.162]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:40.162]                 ...future.oldOptions$nwarnings <- NULL
[08:28:40.162]             }
[08:28:40.162]             base::options(...future.oldOptions)
[08:28:40.162]             if (.Platform$OS.type == "windows") {
[08:28:40.162]                 old_names <- names(...future.oldEnvVars)
[08:28:40.162]                 envs <- base::Sys.getenv()
[08:28:40.162]                 names <- names(envs)
[08:28:40.162]                 common <- intersect(names, old_names)
[08:28:40.162]                 added <- setdiff(names, old_names)
[08:28:40.162]                 removed <- setdiff(old_names, names)
[08:28:40.162]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:40.162]                   envs[common]]
[08:28:40.162]                 NAMES <- toupper(changed)
[08:28:40.162]                 args <- list()
[08:28:40.162]                 for (kk in seq_along(NAMES)) {
[08:28:40.162]                   name <- changed[[kk]]
[08:28:40.162]                   NAME <- NAMES[[kk]]
[08:28:40.162]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:40.162]                     next
[08:28:40.162]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:40.162]                 }
[08:28:40.162]                 NAMES <- toupper(added)
[08:28:40.162]                 for (kk in seq_along(NAMES)) {
[08:28:40.162]                   name <- added[[kk]]
[08:28:40.162]                   NAME <- NAMES[[kk]]
[08:28:40.162]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:40.162]                     next
[08:28:40.162]                   args[[name]] <- ""
[08:28:40.162]                 }
[08:28:40.162]                 NAMES <- toupper(removed)
[08:28:40.162]                 for (kk in seq_along(NAMES)) {
[08:28:40.162]                   name <- removed[[kk]]
[08:28:40.162]                   NAME <- NAMES[[kk]]
[08:28:40.162]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:40.162]                     next
[08:28:40.162]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:40.162]                 }
[08:28:40.162]                 if (length(args) > 0) 
[08:28:40.162]                   base::do.call(base::Sys.setenv, args = args)
[08:28:40.162]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:40.162]             }
[08:28:40.162]             else {
[08:28:40.162]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:40.162]             }
[08:28:40.162]             {
[08:28:40.162]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:40.162]                   0L) {
[08:28:40.162]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:40.162]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:40.162]                   base::options(opts)
[08:28:40.162]                 }
[08:28:40.162]                 {
[08:28:40.162]                   {
[08:28:40.162]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:40.162]                     NULL
[08:28:40.162]                   }
[08:28:40.162]                   options(future.plan = NULL)
[08:28:40.162]                   if (is.na(NA_character_)) 
[08:28:40.162]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:40.162]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:40.162]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:40.162]                     .init = FALSE)
[08:28:40.162]                 }
[08:28:40.162]             }
[08:28:40.162]         }
[08:28:40.162]     })
[08:28:40.162]     if (TRUE) {
[08:28:40.162]         base::sink(type = "output", split = FALSE)
[08:28:40.162]         if (TRUE) {
[08:28:40.162]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:40.162]         }
[08:28:40.162]         else {
[08:28:40.162]             ...future.result["stdout"] <- base::list(NULL)
[08:28:40.162]         }
[08:28:40.162]         base::close(...future.stdout)
[08:28:40.162]         ...future.stdout <- NULL
[08:28:40.162]     }
[08:28:40.162]     ...future.result$conditions <- ...future.conditions
[08:28:40.162]     ...future.result$finished <- base::Sys.time()
[08:28:40.162]     ...future.result
[08:28:40.162] }
[08:28:40.166] Exporting 2 global objects (7.76 KiB) to cluster node #1 ...
[08:28:40.166] Exporting ‘nested’ (7.41 KiB) to cluster node #1 ...
[08:28:40.207] Exporting ‘nested’ (7.41 KiB) to cluster node #1 ... DONE
[08:28:40.207] Exporting ‘strategy2’ (49 bytes) to cluster node #1 ...
[08:28:40.207] Exporting ‘strategy2’ (49 bytes) to cluster node #1 ... DONE
[08:28:40.207] Exporting 2 global objects (7.76 KiB) to cluster node #1 ... DONE
[08:28:40.208] MultisessionFuture started
[08:28:40.208] - Launch lazy future ... done
[08:28:40.208] run() for ‘MultisessionFuture’ ... done
[08:28:40.208] result() for ClusterFuture ...
[08:28:40.209] receiveMessageFromWorker() for ClusterFuture ...
[08:28:40.209] - Validating connection of MultisessionFuture
[08:28:40.268] - received message: FutureResult
[08:28:40.268] - Received FutureResult
[08:28:40.268] - Erased future from FutureRegistry
[08:28:40.269] result() for ClusterFuture ...
[08:28:40.269] - result already collected: FutureResult
[08:28:40.269] result() for ClusterFuture ... done
[08:28:40.269] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:40.269] result() for ClusterFuture ... done
[08:28:40.269] result() for ClusterFuture ...
[08:28:40.269] - result already collected: FutureResult
[08:28:40.269] result() for ClusterFuture ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[08:28:40.275] getGlobalsAndPackages() ...
[08:28:40.275] Searching for globals...
[08:28:40.277] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[08:28:40.277] Searching for globals ... DONE
[08:28:40.277] Resolving globals: FALSE
[08:28:40.278] The total size of the 1 globals is 356 bytes (356 bytes)
[08:28:40.278] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[08:28:40.278] - globals: [1] ‘data’
[08:28:40.278] - packages: [1] ‘future’
[08:28:40.279] getGlobalsAndPackages() ... DONE
[08:28:40.279] run() for ‘Future’ ...
[08:28:40.279] - state: ‘created’
[08:28:40.279] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:40.294] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:40.294] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:40.294]   - Field: ‘node’
[08:28:40.294]   - Field: ‘label’
[08:28:40.294]   - Field: ‘local’
[08:28:40.294]   - Field: ‘owner’
[08:28:40.294]   - Field: ‘envir’
[08:28:40.294]   - Field: ‘workers’
[08:28:40.295]   - Field: ‘packages’
[08:28:40.295]   - Field: ‘gc’
[08:28:40.295]   - Field: ‘conditions’
[08:28:40.295]   - Field: ‘persistent’
[08:28:40.295]   - Field: ‘expr’
[08:28:40.295]   - Field: ‘uuid’
[08:28:40.295]   - Field: ‘seed’
[08:28:40.295]   - Field: ‘version’
[08:28:40.295]   - Field: ‘result’
[08:28:40.295]   - Field: ‘asynchronous’
[08:28:40.295]   - Field: ‘calls’
[08:28:40.296]   - Field: ‘globals’
[08:28:40.296]   - Field: ‘stdout’
[08:28:40.296]   - Field: ‘earlySignal’
[08:28:40.296]   - Field: ‘lazy’
[08:28:40.296]   - Field: ‘state’
[08:28:40.296] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:40.296] - Launch lazy future ...
[08:28:40.296] Packages needed by the future expression (n = 1): ‘future’
[08:28:40.297] Packages needed by future strategies (n = 1): ‘future’
[08:28:40.297] {
[08:28:40.297]     {
[08:28:40.297]         {
[08:28:40.297]             ...future.startTime <- base::Sys.time()
[08:28:40.297]             {
[08:28:40.297]                 {
[08:28:40.297]                   {
[08:28:40.297]                     {
[08:28:40.297]                       {
[08:28:40.297]                         base::local({
[08:28:40.297]                           has_future <- base::requireNamespace("future", 
[08:28:40.297]                             quietly = TRUE)
[08:28:40.297]                           if (has_future) {
[08:28:40.297]                             ns <- base::getNamespace("future")
[08:28:40.297]                             version <- ns[[".package"]][["version"]]
[08:28:40.297]                             if (is.null(version)) 
[08:28:40.297]                               version <- utils::packageVersion("future")
[08:28:40.297]                           }
[08:28:40.297]                           else {
[08:28:40.297]                             version <- NULL
[08:28:40.297]                           }
[08:28:40.297]                           if (!has_future || version < "1.8.0") {
[08:28:40.297]                             info <- base::c(r_version = base::gsub("R version ", 
[08:28:40.297]                               "", base::R.version$version.string), 
[08:28:40.297]                               platform = base::sprintf("%s (%s-bit)", 
[08:28:40.297]                                 base::R.version$platform, 8 * 
[08:28:40.297]                                   base::.Machine$sizeof.pointer), 
[08:28:40.297]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:40.297]                                 "release", "version")], collapse = " "), 
[08:28:40.297]                               hostname = base::Sys.info()[["nodename"]])
[08:28:40.297]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:28:40.297]                               info)
[08:28:40.297]                             info <- base::paste(info, collapse = "; ")
[08:28:40.297]                             if (!has_future) {
[08:28:40.297]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:40.297]                                 info)
[08:28:40.297]                             }
[08:28:40.297]                             else {
[08:28:40.297]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:40.297]                                 info, version)
[08:28:40.297]                             }
[08:28:40.297]                             base::stop(msg)
[08:28:40.297]                           }
[08:28:40.297]                         })
[08:28:40.297]                       }
[08:28:40.297]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:40.297]                       base::options(mc.cores = 1L)
[08:28:40.297]                     }
[08:28:40.297]                     base::local({
[08:28:40.297]                       for (pkg in "future") {
[08:28:40.297]                         base::loadNamespace(pkg)
[08:28:40.297]                         base::library(pkg, character.only = TRUE)
[08:28:40.297]                       }
[08:28:40.297]                     })
[08:28:40.297]                   }
[08:28:40.297]                   ...future.strategy.old <- future::plan("list")
[08:28:40.297]                   options(future.plan = NULL)
[08:28:40.297]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:40.297]                   future::plan(list(b = function (..., envir = parent.frame()) 
[08:28:40.297]                   {
[08:28:40.297]                     future <- SequentialFuture(..., envir = envir)
[08:28:40.297]                     if (!future$lazy) 
[08:28:40.297]                       future <- run(future)
[08:28:40.297]                     invisible(future)
[08:28:40.297]                   }), .cleanup = FALSE, .init = FALSE)
[08:28:40.297]                 }
[08:28:40.297]                 ...future.workdir <- getwd()
[08:28:40.297]             }
[08:28:40.297]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:40.297]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:40.297]         }
[08:28:40.297]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:40.297]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:40.297]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:40.297]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:40.297]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:40.297]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:40.297]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:40.297]             base::names(...future.oldOptions))
[08:28:40.297]     }
[08:28:40.297]     if (FALSE) {
[08:28:40.297]     }
[08:28:40.297]     else {
[08:28:40.297]         if (TRUE) {
[08:28:40.297]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:40.297]                 open = "w")
[08:28:40.297]         }
[08:28:40.297]         else {
[08:28:40.297]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:40.297]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:40.297]         }
[08:28:40.297]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:40.297]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:40.297]             base::sink(type = "output", split = FALSE)
[08:28:40.297]             base::close(...future.stdout)
[08:28:40.297]         }, add = TRUE)
[08:28:40.297]     }
[08:28:40.297]     ...future.frame <- base::sys.nframe()
[08:28:40.297]     ...future.conditions <- base::list()
[08:28:40.297]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:40.297]     if (FALSE) {
[08:28:40.297]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:40.297]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:40.297]     }
[08:28:40.297]     ...future.result <- base::tryCatch({
[08:28:40.297]         base::withCallingHandlers({
[08:28:40.297]             ...future.value <- base::withVisible(base::local({
[08:28:40.297]                 ...future.makeSendCondition <- base::local({
[08:28:40.297]                   sendCondition <- NULL
[08:28:40.297]                   function(frame = 1L) {
[08:28:40.297]                     if (is.function(sendCondition)) 
[08:28:40.297]                       return(sendCondition)
[08:28:40.297]                     ns <- getNamespace("parallel")
[08:28:40.297]                     if (exists("sendData", mode = "function", 
[08:28:40.297]                       envir = ns)) {
[08:28:40.297]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:40.297]                         envir = ns)
[08:28:40.297]                       envir <- sys.frame(frame)
[08:28:40.297]                       master <- NULL
[08:28:40.297]                       while (!identical(envir, .GlobalEnv) && 
[08:28:40.297]                         !identical(envir, emptyenv())) {
[08:28:40.297]                         if (exists("master", mode = "list", envir = envir, 
[08:28:40.297]                           inherits = FALSE)) {
[08:28:40.297]                           master <- get("master", mode = "list", 
[08:28:40.297]                             envir = envir, inherits = FALSE)
[08:28:40.297]                           if (inherits(master, c("SOCKnode", 
[08:28:40.297]                             "SOCK0node"))) {
[08:28:40.297]                             sendCondition <<- function(cond) {
[08:28:40.297]                               data <- list(type = "VALUE", value = cond, 
[08:28:40.297]                                 success = TRUE)
[08:28:40.297]                               parallel_sendData(master, data)
[08:28:40.297]                             }
[08:28:40.297]                             return(sendCondition)
[08:28:40.297]                           }
[08:28:40.297]                         }
[08:28:40.297]                         frame <- frame + 1L
[08:28:40.297]                         envir <- sys.frame(frame)
[08:28:40.297]                       }
[08:28:40.297]                     }
[08:28:40.297]                     sendCondition <<- function(cond) NULL
[08:28:40.297]                   }
[08:28:40.297]                 })
[08:28:40.297]                 withCallingHandlers({
[08:28:40.297]                   {
[08:28:40.297]                     value(future(subset(data, a == 2)))
[08:28:40.297]                   }
[08:28:40.297]                 }, immediateCondition = function(cond) {
[08:28:40.297]                   sendCondition <- ...future.makeSendCondition()
[08:28:40.297]                   sendCondition(cond)
[08:28:40.297]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:40.297]                   {
[08:28:40.297]                     inherits <- base::inherits
[08:28:40.297]                     invokeRestart <- base::invokeRestart
[08:28:40.297]                     is.null <- base::is.null
[08:28:40.297]                     muffled <- FALSE
[08:28:40.297]                     if (inherits(cond, "message")) {
[08:28:40.297]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:40.297]                       if (muffled) 
[08:28:40.297]                         invokeRestart("muffleMessage")
[08:28:40.297]                     }
[08:28:40.297]                     else if (inherits(cond, "warning")) {
[08:28:40.297]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:40.297]                       if (muffled) 
[08:28:40.297]                         invokeRestart("muffleWarning")
[08:28:40.297]                     }
[08:28:40.297]                     else if (inherits(cond, "condition")) {
[08:28:40.297]                       if (!is.null(pattern)) {
[08:28:40.297]                         computeRestarts <- base::computeRestarts
[08:28:40.297]                         grepl <- base::grepl
[08:28:40.297]                         restarts <- computeRestarts(cond)
[08:28:40.297]                         for (restart in restarts) {
[08:28:40.297]                           name <- restart$name
[08:28:40.297]                           if (is.null(name)) 
[08:28:40.297]                             next
[08:28:40.297]                           if (!grepl(pattern, name)) 
[08:28:40.297]                             next
[08:28:40.297]                           invokeRestart(restart)
[08:28:40.297]                           muffled <- TRUE
[08:28:40.297]                           break
[08:28:40.297]                         }
[08:28:40.297]                       }
[08:28:40.297]                     }
[08:28:40.297]                     invisible(muffled)
[08:28:40.297]                   }
[08:28:40.297]                   muffleCondition(cond)
[08:28:40.297]                 })
[08:28:40.297]             }))
[08:28:40.297]             future::FutureResult(value = ...future.value$value, 
[08:28:40.297]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:40.297]                   ...future.rng), globalenv = if (FALSE) 
[08:28:40.297]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:40.297]                     ...future.globalenv.names))
[08:28:40.297]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:40.297]         }, condition = base::local({
[08:28:40.297]             c <- base::c
[08:28:40.297]             inherits <- base::inherits
[08:28:40.297]             invokeRestart <- base::invokeRestart
[08:28:40.297]             length <- base::length
[08:28:40.297]             list <- base::list
[08:28:40.297]             seq.int <- base::seq.int
[08:28:40.297]             signalCondition <- base::signalCondition
[08:28:40.297]             sys.calls <- base::sys.calls
[08:28:40.297]             `[[` <- base::`[[`
[08:28:40.297]             `+` <- base::`+`
[08:28:40.297]             `<<-` <- base::`<<-`
[08:28:40.297]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:40.297]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:40.297]                   3L)]
[08:28:40.297]             }
[08:28:40.297]             function(cond) {
[08:28:40.297]                 is_error <- inherits(cond, "error")
[08:28:40.297]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:40.297]                   NULL)
[08:28:40.297]                 if (is_error) {
[08:28:40.297]                   sessionInformation <- function() {
[08:28:40.297]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:40.297]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:40.297]                       search = base::search(), system = base::Sys.info())
[08:28:40.297]                   }
[08:28:40.297]                   ...future.conditions[[length(...future.conditions) + 
[08:28:40.297]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:40.297]                     cond$call), session = sessionInformation(), 
[08:28:40.297]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:40.297]                   signalCondition(cond)
[08:28:40.297]                 }
[08:28:40.297]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:40.297]                 "immediateCondition"))) {
[08:28:40.297]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:40.297]                   ...future.conditions[[length(...future.conditions) + 
[08:28:40.297]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:40.297]                   if (TRUE && !signal) {
[08:28:40.297]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:40.297]                     {
[08:28:40.297]                       inherits <- base::inherits
[08:28:40.297]                       invokeRestart <- base::invokeRestart
[08:28:40.297]                       is.null <- base::is.null
[08:28:40.297]                       muffled <- FALSE
[08:28:40.297]                       if (inherits(cond, "message")) {
[08:28:40.297]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:40.297]                         if (muffled) 
[08:28:40.297]                           invokeRestart("muffleMessage")
[08:28:40.297]                       }
[08:28:40.297]                       else if (inherits(cond, "warning")) {
[08:28:40.297]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:40.297]                         if (muffled) 
[08:28:40.297]                           invokeRestart("muffleWarning")
[08:28:40.297]                       }
[08:28:40.297]                       else if (inherits(cond, "condition")) {
[08:28:40.297]                         if (!is.null(pattern)) {
[08:28:40.297]                           computeRestarts <- base::computeRestarts
[08:28:40.297]                           grepl <- base::grepl
[08:28:40.297]                           restarts <- computeRestarts(cond)
[08:28:40.297]                           for (restart in restarts) {
[08:28:40.297]                             name <- restart$name
[08:28:40.297]                             if (is.null(name)) 
[08:28:40.297]                               next
[08:28:40.297]                             if (!grepl(pattern, name)) 
[08:28:40.297]                               next
[08:28:40.297]                             invokeRestart(restart)
[08:28:40.297]                             muffled <- TRUE
[08:28:40.297]                             break
[08:28:40.297]                           }
[08:28:40.297]                         }
[08:28:40.297]                       }
[08:28:40.297]                       invisible(muffled)
[08:28:40.297]                     }
[08:28:40.297]                     muffleCondition(cond, pattern = "^muffle")
[08:28:40.297]                   }
[08:28:40.297]                 }
[08:28:40.297]                 else {
[08:28:40.297]                   if (TRUE) {
[08:28:40.297]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:40.297]                     {
[08:28:40.297]                       inherits <- base::inherits
[08:28:40.297]                       invokeRestart <- base::invokeRestart
[08:28:40.297]                       is.null <- base::is.null
[08:28:40.297]                       muffled <- FALSE
[08:28:40.297]                       if (inherits(cond, "message")) {
[08:28:40.297]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:40.297]                         if (muffled) 
[08:28:40.297]                           invokeRestart("muffleMessage")
[08:28:40.297]                       }
[08:28:40.297]                       else if (inherits(cond, "warning")) {
[08:28:40.297]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:40.297]                         if (muffled) 
[08:28:40.297]                           invokeRestart("muffleWarning")
[08:28:40.297]                       }
[08:28:40.297]                       else if (inherits(cond, "condition")) {
[08:28:40.297]                         if (!is.null(pattern)) {
[08:28:40.297]                           computeRestarts <- base::computeRestarts
[08:28:40.297]                           grepl <- base::grepl
[08:28:40.297]                           restarts <- computeRestarts(cond)
[08:28:40.297]                           for (restart in restarts) {
[08:28:40.297]                             name <- restart$name
[08:28:40.297]                             if (is.null(name)) 
[08:28:40.297]                               next
[08:28:40.297]                             if (!grepl(pattern, name)) 
[08:28:40.297]                               next
[08:28:40.297]                             invokeRestart(restart)
[08:28:40.297]                             muffled <- TRUE
[08:28:40.297]                             break
[08:28:40.297]                           }
[08:28:40.297]                         }
[08:28:40.297]                       }
[08:28:40.297]                       invisible(muffled)
[08:28:40.297]                     }
[08:28:40.297]                     muffleCondition(cond, pattern = "^muffle")
[08:28:40.297]                   }
[08:28:40.297]                 }
[08:28:40.297]             }
[08:28:40.297]         }))
[08:28:40.297]     }, error = function(ex) {
[08:28:40.297]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:40.297]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:40.297]                 ...future.rng), started = ...future.startTime, 
[08:28:40.297]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:40.297]             version = "1.8"), class = "FutureResult")
[08:28:40.297]     }, finally = {
[08:28:40.297]         if (!identical(...future.workdir, getwd())) 
[08:28:40.297]             setwd(...future.workdir)
[08:28:40.297]         {
[08:28:40.297]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:40.297]                 ...future.oldOptions$nwarnings <- NULL
[08:28:40.297]             }
[08:28:40.297]             base::options(...future.oldOptions)
[08:28:40.297]             if (.Platform$OS.type == "windows") {
[08:28:40.297]                 old_names <- names(...future.oldEnvVars)
[08:28:40.297]                 envs <- base::Sys.getenv()
[08:28:40.297]                 names <- names(envs)
[08:28:40.297]                 common <- intersect(names, old_names)
[08:28:40.297]                 added <- setdiff(names, old_names)
[08:28:40.297]                 removed <- setdiff(old_names, names)
[08:28:40.297]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:40.297]                   envs[common]]
[08:28:40.297]                 NAMES <- toupper(changed)
[08:28:40.297]                 args <- list()
[08:28:40.297]                 for (kk in seq_along(NAMES)) {
[08:28:40.297]                   name <- changed[[kk]]
[08:28:40.297]                   NAME <- NAMES[[kk]]
[08:28:40.297]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:40.297]                     next
[08:28:40.297]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:40.297]                 }
[08:28:40.297]                 NAMES <- toupper(added)
[08:28:40.297]                 for (kk in seq_along(NAMES)) {
[08:28:40.297]                   name <- added[[kk]]
[08:28:40.297]                   NAME <- NAMES[[kk]]
[08:28:40.297]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:40.297]                     next
[08:28:40.297]                   args[[name]] <- ""
[08:28:40.297]                 }
[08:28:40.297]                 NAMES <- toupper(removed)
[08:28:40.297]                 for (kk in seq_along(NAMES)) {
[08:28:40.297]                   name <- removed[[kk]]
[08:28:40.297]                   NAME <- NAMES[[kk]]
[08:28:40.297]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:40.297]                     next
[08:28:40.297]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:40.297]                 }
[08:28:40.297]                 if (length(args) > 0) 
[08:28:40.297]                   base::do.call(base::Sys.setenv, args = args)
[08:28:40.297]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:40.297]             }
[08:28:40.297]             else {
[08:28:40.297]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:40.297]             }
[08:28:40.297]             {
[08:28:40.297]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:40.297]                   0L) {
[08:28:40.297]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:40.297]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:40.297]                   base::options(opts)
[08:28:40.297]                 }
[08:28:40.297]                 {
[08:28:40.297]                   {
[08:28:40.297]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:40.297]                     NULL
[08:28:40.297]                   }
[08:28:40.297]                   options(future.plan = NULL)
[08:28:40.297]                   if (is.na(NA_character_)) 
[08:28:40.297]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:40.297]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:40.297]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:40.297]                     .init = FALSE)
[08:28:40.297]                 }
[08:28:40.297]             }
[08:28:40.297]         }
[08:28:40.297]     })
[08:28:40.297]     if (TRUE) {
[08:28:40.297]         base::sink(type = "output", split = FALSE)
[08:28:40.297]         if (TRUE) {
[08:28:40.297]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:40.297]         }
[08:28:40.297]         else {
[08:28:40.297]             ...future.result["stdout"] <- base::list(NULL)
[08:28:40.297]         }
[08:28:40.297]         base::close(...future.stdout)
[08:28:40.297]         ...future.stdout <- NULL
[08:28:40.297]     }
[08:28:40.297]     ...future.result$conditions <- ...future.conditions
[08:28:40.297]     ...future.result$finished <- base::Sys.time()
[08:28:40.297]     ...future.result
[08:28:40.297] }
[08:28:40.300] Exporting 1 global objects (643 bytes) to cluster node #1 ...
[08:28:40.300] Exporting ‘data’ (356 bytes) to cluster node #1 ...
[08:28:40.300] Exporting ‘data’ (356 bytes) to cluster node #1 ... DONE
[08:28:40.301] Exporting 1 global objects (643 bytes) to cluster node #1 ... DONE
[08:28:40.301] MultisessionFuture started
[08:28:40.301] - Launch lazy future ... done
[08:28:40.301] run() for ‘MultisessionFuture’ ... done
[08:28:40.301] result() for ClusterFuture ...
[08:28:40.301] receiveMessageFromWorker() for ClusterFuture ...
[08:28:40.302] - Validating connection of MultisessionFuture
[08:28:40.347] - received message: FutureResult
[08:28:40.347] - Received FutureResult
[08:28:40.347] - Erased future from FutureRegistry
[08:28:40.348] result() for ClusterFuture ...
[08:28:40.348] - result already collected: FutureResult
[08:28:40.348] result() for ClusterFuture ... done
[08:28:40.348] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:40.348] result() for ClusterFuture ... done
[08:28:40.348] result() for ClusterFuture ...
[08:28:40.348] - result already collected: FutureResult
[08:28:40.348] result() for ClusterFuture ... done
- plan(list('multisession', 'sequential')) ... DONE
- plan(list('multisession', 'multicore')) ...
[08:28:40.349] plan(): Setting new future strategy stack:
[08:28:40.349] List of future strategies:
[08:28:40.349] 1. multisession:
[08:28:40.349]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:28:40.349]    - tweaked: FALSE
[08:28:40.349]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:40.349] 2. multicore:
[08:28:40.349]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:40.349]    - tweaked: FALSE
[08:28:40.349]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:40.349] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[08:28:40.350] multisession:
[08:28:40.350] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:28:40.350] - tweaked: FALSE
[08:28:40.350] - call: plan(list(a = strategy1, b = strategy2))
[08:28:40.352] getGlobalsAndPackages() ...
[08:28:40.353] Not searching for globals
[08:28:40.353] - globals: [0] <none>
[08:28:40.353] getGlobalsAndPackages() ... DONE
[08:28:40.621] Packages needed by the future expression (n = 0): <none>
[08:28:40.621] Packages needed by future strategies (n = 1): ‘future’
[08:28:40.622] {
[08:28:40.622]     {
[08:28:40.622]         {
[08:28:40.622]             ...future.startTime <- base::Sys.time()
[08:28:40.622]             {
[08:28:40.622]                 {
[08:28:40.622]                   {
[08:28:40.622]                     {
[08:28:40.622]                       {
[08:28:40.622]                         base::local({
[08:28:40.622]                           has_future <- base::requireNamespace("future", 
[08:28:40.622]                             quietly = TRUE)
[08:28:40.622]                           if (has_future) {
[08:28:40.622]                             ns <- base::getNamespace("future")
[08:28:40.622]                             version <- ns[[".package"]][["version"]]
[08:28:40.622]                             if (is.null(version)) 
[08:28:40.622]                               version <- utils::packageVersion("future")
[08:28:40.622]                           }
[08:28:40.622]                           else {
[08:28:40.622]                             version <- NULL
[08:28:40.622]                           }
[08:28:40.622]                           if (!has_future || version < "1.8.0") {
[08:28:40.622]                             info <- base::c(r_version = base::gsub("R version ", 
[08:28:40.622]                               "", base::R.version$version.string), 
[08:28:40.622]                               platform = base::sprintf("%s (%s-bit)", 
[08:28:40.622]                                 base::R.version$platform, 8 * 
[08:28:40.622]                                   base::.Machine$sizeof.pointer), 
[08:28:40.622]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:40.622]                                 "release", "version")], collapse = " "), 
[08:28:40.622]                               hostname = base::Sys.info()[["nodename"]])
[08:28:40.622]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:28:40.622]                               info)
[08:28:40.622]                             info <- base::paste(info, collapse = "; ")
[08:28:40.622]                             if (!has_future) {
[08:28:40.622]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:40.622]                                 info)
[08:28:40.622]                             }
[08:28:40.622]                             else {
[08:28:40.622]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:40.622]                                 info, version)
[08:28:40.622]                             }
[08:28:40.622]                             base::stop(msg)
[08:28:40.622]                           }
[08:28:40.622]                         })
[08:28:40.622]                       }
[08:28:40.622]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:40.622]                       base::options(mc.cores = 1L)
[08:28:40.622]                     }
[08:28:40.622]                     base::local({
[08:28:40.622]                       for (pkg in "future") {
[08:28:40.622]                         base::loadNamespace(pkg)
[08:28:40.622]                         base::library(pkg, character.only = TRUE)
[08:28:40.622]                       }
[08:28:40.622]                     })
[08:28:40.622]                   }
[08:28:40.622]                   ...future.strategy.old <- future::plan("list")
[08:28:40.622]                   options(future.plan = NULL)
[08:28:40.622]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:40.622]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[08:28:40.622]                     envir = parent.frame()) 
[08:28:40.622]                   {
[08:28:40.622]                     default_workers <- missing(workers)
[08:28:40.622]                     if (is.function(workers)) 
[08:28:40.622]                       workers <- workers()
[08:28:40.622]                     workers <- structure(as.integer(workers), 
[08:28:40.622]                       class = class(workers))
[08:28:40.622]                     stop_if_not(is.finite(workers), workers >= 
[08:28:40.622]                       1L)
[08:28:40.622]                     if ((workers == 1L && !inherits(workers, 
[08:28:40.622]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[08:28:40.622]                       if (default_workers) 
[08:28:40.622]                         supportsMulticore(warn = TRUE)
[08:28:40.622]                       return(sequential(..., envir = envir))
[08:28:40.622]                     }
[08:28:40.622]                     oopts <- options(mc.cores = workers)
[08:28:40.622]                     on.exit(options(oopts))
[08:28:40.622]                     future <- MulticoreFuture(..., workers = workers, 
[08:28:40.622]                       envir = envir)
[08:28:40.622]                     if (!future$lazy) 
[08:28:40.622]                       future <- run(future)
[08:28:40.622]                     invisible(future)
[08:28:40.622]                   }), .cleanup = FALSE, .init = FALSE)
[08:28:40.622]                 }
[08:28:40.622]                 ...future.workdir <- getwd()
[08:28:40.622]             }
[08:28:40.622]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:40.622]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:40.622]         }
[08:28:40.622]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:40.622]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:40.622]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:40.622]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:40.622]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:40.622]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:40.622]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:40.622]             base::names(...future.oldOptions))
[08:28:40.622]     }
[08:28:40.622]     if (FALSE) {
[08:28:40.622]     }
[08:28:40.622]     else {
[08:28:40.622]         if (TRUE) {
[08:28:40.622]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:40.622]                 open = "w")
[08:28:40.622]         }
[08:28:40.622]         else {
[08:28:40.622]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:40.622]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:40.622]         }
[08:28:40.622]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:40.622]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:40.622]             base::sink(type = "output", split = FALSE)
[08:28:40.622]             base::close(...future.stdout)
[08:28:40.622]         }, add = TRUE)
[08:28:40.622]     }
[08:28:40.622]     ...future.frame <- base::sys.nframe()
[08:28:40.622]     ...future.conditions <- base::list()
[08:28:40.622]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:40.622]     if (FALSE) {
[08:28:40.622]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:40.622]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:40.622]     }
[08:28:40.622]     ...future.result <- base::tryCatch({
[08:28:40.622]         base::withCallingHandlers({
[08:28:40.622]             ...future.value <- base::withVisible(base::local({
[08:28:40.622]                 ...future.makeSendCondition <- base::local({
[08:28:40.622]                   sendCondition <- NULL
[08:28:40.622]                   function(frame = 1L) {
[08:28:40.622]                     if (is.function(sendCondition)) 
[08:28:40.622]                       return(sendCondition)
[08:28:40.622]                     ns <- getNamespace("parallel")
[08:28:40.622]                     if (exists("sendData", mode = "function", 
[08:28:40.622]                       envir = ns)) {
[08:28:40.622]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:40.622]                         envir = ns)
[08:28:40.622]                       envir <- sys.frame(frame)
[08:28:40.622]                       master <- NULL
[08:28:40.622]                       while (!identical(envir, .GlobalEnv) && 
[08:28:40.622]                         !identical(envir, emptyenv())) {
[08:28:40.622]                         if (exists("master", mode = "list", envir = envir, 
[08:28:40.622]                           inherits = FALSE)) {
[08:28:40.622]                           master <- get("master", mode = "list", 
[08:28:40.622]                             envir = envir, inherits = FALSE)
[08:28:40.622]                           if (inherits(master, c("SOCKnode", 
[08:28:40.622]                             "SOCK0node"))) {
[08:28:40.622]                             sendCondition <<- function(cond) {
[08:28:40.622]                               data <- list(type = "VALUE", value = cond, 
[08:28:40.622]                                 success = TRUE)
[08:28:40.622]                               parallel_sendData(master, data)
[08:28:40.622]                             }
[08:28:40.622]                             return(sendCondition)
[08:28:40.622]                           }
[08:28:40.622]                         }
[08:28:40.622]                         frame <- frame + 1L
[08:28:40.622]                         envir <- sys.frame(frame)
[08:28:40.622]                       }
[08:28:40.622]                     }
[08:28:40.622]                     sendCondition <<- function(cond) NULL
[08:28:40.622]                   }
[08:28:40.622]                 })
[08:28:40.622]                 withCallingHandlers({
[08:28:40.622]                   NA
[08:28:40.622]                 }, immediateCondition = function(cond) {
[08:28:40.622]                   sendCondition <- ...future.makeSendCondition()
[08:28:40.622]                   sendCondition(cond)
[08:28:40.622]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:40.622]                   {
[08:28:40.622]                     inherits <- base::inherits
[08:28:40.622]                     invokeRestart <- base::invokeRestart
[08:28:40.622]                     is.null <- base::is.null
[08:28:40.622]                     muffled <- FALSE
[08:28:40.622]                     if (inherits(cond, "message")) {
[08:28:40.622]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:40.622]                       if (muffled) 
[08:28:40.622]                         invokeRestart("muffleMessage")
[08:28:40.622]                     }
[08:28:40.622]                     else if (inherits(cond, "warning")) {
[08:28:40.622]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:40.622]                       if (muffled) 
[08:28:40.622]                         invokeRestart("muffleWarning")
[08:28:40.622]                     }
[08:28:40.622]                     else if (inherits(cond, "condition")) {
[08:28:40.622]                       if (!is.null(pattern)) {
[08:28:40.622]                         computeRestarts <- base::computeRestarts
[08:28:40.622]                         grepl <- base::grepl
[08:28:40.622]                         restarts <- computeRestarts(cond)
[08:28:40.622]                         for (restart in restarts) {
[08:28:40.622]                           name <- restart$name
[08:28:40.622]                           if (is.null(name)) 
[08:28:40.622]                             next
[08:28:40.622]                           if (!grepl(pattern, name)) 
[08:28:40.622]                             next
[08:28:40.622]                           invokeRestart(restart)
[08:28:40.622]                           muffled <- TRUE
[08:28:40.622]                           break
[08:28:40.622]                         }
[08:28:40.622]                       }
[08:28:40.622]                     }
[08:28:40.622]                     invisible(muffled)
[08:28:40.622]                   }
[08:28:40.622]                   muffleCondition(cond)
[08:28:40.622]                 })
[08:28:40.622]             }))
[08:28:40.622]             future::FutureResult(value = ...future.value$value, 
[08:28:40.622]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:40.622]                   ...future.rng), globalenv = if (FALSE) 
[08:28:40.622]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:40.622]                     ...future.globalenv.names))
[08:28:40.622]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:40.622]         }, condition = base::local({
[08:28:40.622]             c <- base::c
[08:28:40.622]             inherits <- base::inherits
[08:28:40.622]             invokeRestart <- base::invokeRestart
[08:28:40.622]             length <- base::length
[08:28:40.622]             list <- base::list
[08:28:40.622]             seq.int <- base::seq.int
[08:28:40.622]             signalCondition <- base::signalCondition
[08:28:40.622]             sys.calls <- base::sys.calls
[08:28:40.622]             `[[` <- base::`[[`
[08:28:40.622]             `+` <- base::`+`
[08:28:40.622]             `<<-` <- base::`<<-`
[08:28:40.622]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:40.622]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:40.622]                   3L)]
[08:28:40.622]             }
[08:28:40.622]             function(cond) {
[08:28:40.622]                 is_error <- inherits(cond, "error")
[08:28:40.622]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:40.622]                   NULL)
[08:28:40.622]                 if (is_error) {
[08:28:40.622]                   sessionInformation <- function() {
[08:28:40.622]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:40.622]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:40.622]                       search = base::search(), system = base::Sys.info())
[08:28:40.622]                   }
[08:28:40.622]                   ...future.conditions[[length(...future.conditions) + 
[08:28:40.622]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:40.622]                     cond$call), session = sessionInformation(), 
[08:28:40.622]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:40.622]                   signalCondition(cond)
[08:28:40.622]                 }
[08:28:40.622]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:40.622]                 "immediateCondition"))) {
[08:28:40.622]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:40.622]                   ...future.conditions[[length(...future.conditions) + 
[08:28:40.622]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:40.622]                   if (TRUE && !signal) {
[08:28:40.622]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:40.622]                     {
[08:28:40.622]                       inherits <- base::inherits
[08:28:40.622]                       invokeRestart <- base::invokeRestart
[08:28:40.622]                       is.null <- base::is.null
[08:28:40.622]                       muffled <- FALSE
[08:28:40.622]                       if (inherits(cond, "message")) {
[08:28:40.622]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:40.622]                         if (muffled) 
[08:28:40.622]                           invokeRestart("muffleMessage")
[08:28:40.622]                       }
[08:28:40.622]                       else if (inherits(cond, "warning")) {
[08:28:40.622]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:40.622]                         if (muffled) 
[08:28:40.622]                           invokeRestart("muffleWarning")
[08:28:40.622]                       }
[08:28:40.622]                       else if (inherits(cond, "condition")) {
[08:28:40.622]                         if (!is.null(pattern)) {
[08:28:40.622]                           computeRestarts <- base::computeRestarts
[08:28:40.622]                           grepl <- base::grepl
[08:28:40.622]                           restarts <- computeRestarts(cond)
[08:28:40.622]                           for (restart in restarts) {
[08:28:40.622]                             name <- restart$name
[08:28:40.622]                             if (is.null(name)) 
[08:28:40.622]                               next
[08:28:40.622]                             if (!grepl(pattern, name)) 
[08:28:40.622]                               next
[08:28:40.622]                             invokeRestart(restart)
[08:28:40.622]                             muffled <- TRUE
[08:28:40.622]                             break
[08:28:40.622]                           }
[08:28:40.622]                         }
[08:28:40.622]                       }
[08:28:40.622]                       invisible(muffled)
[08:28:40.622]                     }
[08:28:40.622]                     muffleCondition(cond, pattern = "^muffle")
[08:28:40.622]                   }
[08:28:40.622]                 }
[08:28:40.622]                 else {
[08:28:40.622]                   if (TRUE) {
[08:28:40.622]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:40.622]                     {
[08:28:40.622]                       inherits <- base::inherits
[08:28:40.622]                       invokeRestart <- base::invokeRestart
[08:28:40.622]                       is.null <- base::is.null
[08:28:40.622]                       muffled <- FALSE
[08:28:40.622]                       if (inherits(cond, "message")) {
[08:28:40.622]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:40.622]                         if (muffled) 
[08:28:40.622]                           invokeRestart("muffleMessage")
[08:28:40.622]                       }
[08:28:40.622]                       else if (inherits(cond, "warning")) {
[08:28:40.622]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:40.622]                         if (muffled) 
[08:28:40.622]                           invokeRestart("muffleWarning")
[08:28:40.622]                       }
[08:28:40.622]                       else if (inherits(cond, "condition")) {
[08:28:40.622]                         if (!is.null(pattern)) {
[08:28:40.622]                           computeRestarts <- base::computeRestarts
[08:28:40.622]                           grepl <- base::grepl
[08:28:40.622]                           restarts <- computeRestarts(cond)
[08:28:40.622]                           for (restart in restarts) {
[08:28:40.622]                             name <- restart$name
[08:28:40.622]                             if (is.null(name)) 
[08:28:40.622]                               next
[08:28:40.622]                             if (!grepl(pattern, name)) 
[08:28:40.622]                               next
[08:28:40.622]                             invokeRestart(restart)
[08:28:40.622]                             muffled <- TRUE
[08:28:40.622]                             break
[08:28:40.622]                           }
[08:28:40.622]                         }
[08:28:40.622]                       }
[08:28:40.622]                       invisible(muffled)
[08:28:40.622]                     }
[08:28:40.622]                     muffleCondition(cond, pattern = "^muffle")
[08:28:40.622]                   }
[08:28:40.622]                 }
[08:28:40.622]             }
[08:28:40.622]         }))
[08:28:40.622]     }, error = function(ex) {
[08:28:40.622]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:40.622]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:40.622]                 ...future.rng), started = ...future.startTime, 
[08:28:40.622]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:40.622]             version = "1.8"), class = "FutureResult")
[08:28:40.622]     }, finally = {
[08:28:40.622]         if (!identical(...future.workdir, getwd())) 
[08:28:40.622]             setwd(...future.workdir)
[08:28:40.622]         {
[08:28:40.622]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:40.622]                 ...future.oldOptions$nwarnings <- NULL
[08:28:40.622]             }
[08:28:40.622]             base::options(...future.oldOptions)
[08:28:40.622]             if (.Platform$OS.type == "windows") {
[08:28:40.622]                 old_names <- names(...future.oldEnvVars)
[08:28:40.622]                 envs <- base::Sys.getenv()
[08:28:40.622]                 names <- names(envs)
[08:28:40.622]                 common <- intersect(names, old_names)
[08:28:40.622]                 added <- setdiff(names, old_names)
[08:28:40.622]                 removed <- setdiff(old_names, names)
[08:28:40.622]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:40.622]                   envs[common]]
[08:28:40.622]                 NAMES <- toupper(changed)
[08:28:40.622]                 args <- list()
[08:28:40.622]                 for (kk in seq_along(NAMES)) {
[08:28:40.622]                   name <- changed[[kk]]
[08:28:40.622]                   NAME <- NAMES[[kk]]
[08:28:40.622]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:40.622]                     next
[08:28:40.622]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:40.622]                 }
[08:28:40.622]                 NAMES <- toupper(added)
[08:28:40.622]                 for (kk in seq_along(NAMES)) {
[08:28:40.622]                   name <- added[[kk]]
[08:28:40.622]                   NAME <- NAMES[[kk]]
[08:28:40.622]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:40.622]                     next
[08:28:40.622]                   args[[name]] <- ""
[08:28:40.622]                 }
[08:28:40.622]                 NAMES <- toupper(removed)
[08:28:40.622]                 for (kk in seq_along(NAMES)) {
[08:28:40.622]                   name <- removed[[kk]]
[08:28:40.622]                   NAME <- NAMES[[kk]]
[08:28:40.622]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:40.622]                     next
[08:28:40.622]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:40.622]                 }
[08:28:40.622]                 if (length(args) > 0) 
[08:28:40.622]                   base::do.call(base::Sys.setenv, args = args)
[08:28:40.622]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:40.622]             }
[08:28:40.622]             else {
[08:28:40.622]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:40.622]             }
[08:28:40.622]             {
[08:28:40.622]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:40.622]                   0L) {
[08:28:40.622]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:40.622]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:40.622]                   base::options(opts)
[08:28:40.622]                 }
[08:28:40.622]                 {
[08:28:40.622]                   {
[08:28:40.622]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:40.622]                     NULL
[08:28:40.622]                   }
[08:28:40.622]                   options(future.plan = NULL)
[08:28:40.622]                   if (is.na(NA_character_)) 
[08:28:40.622]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:40.622]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:40.622]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:40.622]                     .init = FALSE)
[08:28:40.622]                 }
[08:28:40.622]             }
[08:28:40.622]         }
[08:28:40.622]     })
[08:28:40.622]     if (TRUE) {
[08:28:40.622]         base::sink(type = "output", split = FALSE)
[08:28:40.622]         if (TRUE) {
[08:28:40.622]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:40.622]         }
[08:28:40.622]         else {
[08:28:40.622]             ...future.result["stdout"] <- base::list(NULL)
[08:28:40.622]         }
[08:28:40.622]         base::close(...future.stdout)
[08:28:40.622]         ...future.stdout <- NULL
[08:28:40.622]     }
[08:28:40.622]     ...future.result$conditions <- ...future.conditions
[08:28:40.622]     ...future.result$finished <- base::Sys.time()
[08:28:40.622]     ...future.result
[08:28:40.622] }
[08:28:40.677] MultisessionFuture started
[08:28:40.677] result() for ClusterFuture ...
[08:28:40.677] receiveMessageFromWorker() for ClusterFuture ...
[08:28:40.677] - Validating connection of MultisessionFuture
[08:28:40.730] - received message: FutureResult
[08:28:40.730] - Received FutureResult
[08:28:40.730] - Erased future from FutureRegistry
[08:28:40.730] result() for ClusterFuture ...
[08:28:40.730] - result already collected: FutureResult
[08:28:40.730] result() for ClusterFuture ... done
[08:28:40.730] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:40.730] result() for ClusterFuture ... done
[08:28:40.730] result() for ClusterFuture ...
[08:28:40.731] - result already collected: FutureResult
[08:28:40.731] result() for ClusterFuture ... done
[08:28:40.731] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[08:28:40.732] plan(): nbrOfWorkers() = 2
[08:28:40.733] getGlobalsAndPackages() ...
[08:28:40.733] Searching for globals...
[08:28:40.748] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[08:28:40.748] Searching for globals ... DONE
[08:28:40.748] Resolving globals: FALSE
[08:28:40.749] The total size of the 2 globals is 11.74 KiB (12021 bytes)
[08:28:40.752] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 11.74 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (11.69 KiB of class ‘list’) and ‘strategy2’ (48 bytes of class ‘character’)
[08:28:40.752] - globals: [2] ‘nested’, ‘strategy2’
[08:28:40.752] - packages: [1] ‘future’
[08:28:40.752] getGlobalsAndPackages() ... DONE
[08:28:40.752] run() for ‘Future’ ...
[08:28:40.752] - state: ‘created’
[08:28:40.753] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:40.766] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:40.766] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:40.767]   - Field: ‘node’
[08:28:40.767]   - Field: ‘label’
[08:28:40.767]   - Field: ‘local’
[08:28:40.767]   - Field: ‘owner’
[08:28:40.767]   - Field: ‘envir’
[08:28:40.767]   - Field: ‘workers’
[08:28:40.767]   - Field: ‘packages’
[08:28:40.767]   - Field: ‘gc’
[08:28:40.767]   - Field: ‘conditions’
[08:28:40.767]   - Field: ‘persistent’
[08:28:40.767]   - Field: ‘expr’
[08:28:40.768]   - Field: ‘uuid’
[08:28:40.768]   - Field: ‘seed’
[08:28:40.768]   - Field: ‘version’
[08:28:40.768]   - Field: ‘result’
[08:28:40.768]   - Field: ‘asynchronous’
[08:28:40.768]   - Field: ‘calls’
[08:28:40.768]   - Field: ‘globals’
[08:28:40.768]   - Field: ‘stdout’
[08:28:40.768]   - Field: ‘earlySignal’
[08:28:40.768]   - Field: ‘lazy’
[08:28:40.768]   - Field: ‘state’
[08:28:40.768] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:40.769] - Launch lazy future ...
[08:28:40.769] Packages needed by the future expression (n = 1): ‘future’
[08:28:40.769] Packages needed by future strategies (n = 1): ‘future’
[08:28:40.769] {
[08:28:40.769]     {
[08:28:40.769]         {
[08:28:40.769]             ...future.startTime <- base::Sys.time()
[08:28:40.769]             {
[08:28:40.769]                 {
[08:28:40.769]                   {
[08:28:40.769]                     {
[08:28:40.769]                       {
[08:28:40.769]                         base::local({
[08:28:40.769]                           has_future <- base::requireNamespace("future", 
[08:28:40.769]                             quietly = TRUE)
[08:28:40.769]                           if (has_future) {
[08:28:40.769]                             ns <- base::getNamespace("future")
[08:28:40.769]                             version <- ns[[".package"]][["version"]]
[08:28:40.769]                             if (is.null(version)) 
[08:28:40.769]                               version <- utils::packageVersion("future")
[08:28:40.769]                           }
[08:28:40.769]                           else {
[08:28:40.769]                             version <- NULL
[08:28:40.769]                           }
[08:28:40.769]                           if (!has_future || version < "1.8.0") {
[08:28:40.769]                             info <- base::c(r_version = base::gsub("R version ", 
[08:28:40.769]                               "", base::R.version$version.string), 
[08:28:40.769]                               platform = base::sprintf("%s (%s-bit)", 
[08:28:40.769]                                 base::R.version$platform, 8 * 
[08:28:40.769]                                   base::.Machine$sizeof.pointer), 
[08:28:40.769]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:40.769]                                 "release", "version")], collapse = " "), 
[08:28:40.769]                               hostname = base::Sys.info()[["nodename"]])
[08:28:40.769]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:28:40.769]                               info)
[08:28:40.769]                             info <- base::paste(info, collapse = "; ")
[08:28:40.769]                             if (!has_future) {
[08:28:40.769]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:40.769]                                 info)
[08:28:40.769]                             }
[08:28:40.769]                             else {
[08:28:40.769]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:40.769]                                 info, version)
[08:28:40.769]                             }
[08:28:40.769]                             base::stop(msg)
[08:28:40.769]                           }
[08:28:40.769]                         })
[08:28:40.769]                       }
[08:28:40.769]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:40.769]                       base::options(mc.cores = 1L)
[08:28:40.769]                     }
[08:28:40.769]                     base::local({
[08:28:40.769]                       for (pkg in "future") {
[08:28:40.769]                         base::loadNamespace(pkg)
[08:28:40.769]                         base::library(pkg, character.only = TRUE)
[08:28:40.769]                       }
[08:28:40.769]                     })
[08:28:40.769]                   }
[08:28:40.769]                   ...future.strategy.old <- future::plan("list")
[08:28:40.769]                   options(future.plan = NULL)
[08:28:40.769]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:40.769]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[08:28:40.769]                     envir = parent.frame()) 
[08:28:40.769]                   {
[08:28:40.769]                     default_workers <- missing(workers)
[08:28:40.769]                     if (is.function(workers)) 
[08:28:40.769]                       workers <- workers()
[08:28:40.769]                     workers <- structure(as.integer(workers), 
[08:28:40.769]                       class = class(workers))
[08:28:40.769]                     stop_if_not(is.finite(workers), workers >= 
[08:28:40.769]                       1L)
[08:28:40.769]                     if ((workers == 1L && !inherits(workers, 
[08:28:40.769]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[08:28:40.769]                       if (default_workers) 
[08:28:40.769]                         supportsMulticore(warn = TRUE)
[08:28:40.769]                       return(sequential(..., envir = envir))
[08:28:40.769]                     }
[08:28:40.769]                     oopts <- options(mc.cores = workers)
[08:28:40.769]                     on.exit(options(oopts))
[08:28:40.769]                     future <- MulticoreFuture(..., workers = workers, 
[08:28:40.769]                       envir = envir)
[08:28:40.769]                     if (!future$lazy) 
[08:28:40.769]                       future <- run(future)
[08:28:40.769]                     invisible(future)
[08:28:40.769]                   }), .cleanup = FALSE, .init = FALSE)
[08:28:40.769]                 }
[08:28:40.769]                 ...future.workdir <- getwd()
[08:28:40.769]             }
[08:28:40.769]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:40.769]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:40.769]         }
[08:28:40.769]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:40.769]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:40.769]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:40.769]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:40.769]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:40.769]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:40.769]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:40.769]             base::names(...future.oldOptions))
[08:28:40.769]     }
[08:28:40.769]     if (FALSE) {
[08:28:40.769]     }
[08:28:40.769]     else {
[08:28:40.769]         if (TRUE) {
[08:28:40.769]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:40.769]                 open = "w")
[08:28:40.769]         }
[08:28:40.769]         else {
[08:28:40.769]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:40.769]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:40.769]         }
[08:28:40.769]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:40.769]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:40.769]             base::sink(type = "output", split = FALSE)
[08:28:40.769]             base::close(...future.stdout)
[08:28:40.769]         }, add = TRUE)
[08:28:40.769]     }
[08:28:40.769]     ...future.frame <- base::sys.nframe()
[08:28:40.769]     ...future.conditions <- base::list()
[08:28:40.769]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:40.769]     if (FALSE) {
[08:28:40.769]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:40.769]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:40.769]     }
[08:28:40.769]     ...future.result <- base::tryCatch({
[08:28:40.769]         base::withCallingHandlers({
[08:28:40.769]             ...future.value <- base::withVisible(base::local({
[08:28:40.769]                 ...future.makeSendCondition <- base::local({
[08:28:40.769]                   sendCondition <- NULL
[08:28:40.769]                   function(frame = 1L) {
[08:28:40.769]                     if (is.function(sendCondition)) 
[08:28:40.769]                       return(sendCondition)
[08:28:40.769]                     ns <- getNamespace("parallel")
[08:28:40.769]                     if (exists("sendData", mode = "function", 
[08:28:40.769]                       envir = ns)) {
[08:28:40.769]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:40.769]                         envir = ns)
[08:28:40.769]                       envir <- sys.frame(frame)
[08:28:40.769]                       master <- NULL
[08:28:40.769]                       while (!identical(envir, .GlobalEnv) && 
[08:28:40.769]                         !identical(envir, emptyenv())) {
[08:28:40.769]                         if (exists("master", mode = "list", envir = envir, 
[08:28:40.769]                           inherits = FALSE)) {
[08:28:40.769]                           master <- get("master", mode = "list", 
[08:28:40.769]                             envir = envir, inherits = FALSE)
[08:28:40.769]                           if (inherits(master, c("SOCKnode", 
[08:28:40.769]                             "SOCK0node"))) {
[08:28:40.769]                             sendCondition <<- function(cond) {
[08:28:40.769]                               data <- list(type = "VALUE", value = cond, 
[08:28:40.769]                                 success = TRUE)
[08:28:40.769]                               parallel_sendData(master, data)
[08:28:40.769]                             }
[08:28:40.769]                             return(sendCondition)
[08:28:40.769]                           }
[08:28:40.769]                         }
[08:28:40.769]                         frame <- frame + 1L
[08:28:40.769]                         envir <- sys.frame(frame)
[08:28:40.769]                       }
[08:28:40.769]                     }
[08:28:40.769]                     sendCondition <<- function(cond) NULL
[08:28:40.769]                   }
[08:28:40.769]                 })
[08:28:40.769]                 withCallingHandlers({
[08:28:40.769]                   {
[08:28:40.769]                     a <- 1L
[08:28:40.769]                     plan_a <- unclass(future::plan("list"))
[08:28:40.769]                     nested_a <- nested[-1]
[08:28:40.769]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[08:28:40.769]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[08:28:40.769]                       strategy2))
[08:28:40.769]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[08:28:40.769]                       "init") <- NULL
[08:28:40.769]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[08:28:40.769]                       "init") <- NULL
[08:28:40.769]                     stopifnot(all.equal(plan_a, nested_a))
[08:28:40.769]                     y %<-% {
[08:28:40.769]                       b <- 2L
[08:28:40.769]                       plan_b <- future::plan("list")
[08:28:40.769]                       nested_b <- nested_a[-1]
[08:28:40.769]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[08:28:40.769]                         1L, inherits(plan_b[[1]], "future"), 
[08:28:40.769]                         inherits(future::plan("next"), "sequential"))
[08:28:40.769]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[08:28:40.769]                         b = b, nested_b = nested_b, plan_b = plan_b)
[08:28:40.769]                     }
[08:28:40.769]                     y
[08:28:40.769]                   }
[08:28:40.769]                 }, immediateCondition = function(cond) {
[08:28:40.769]                   sendCondition <- ...future.makeSendCondition()
[08:28:40.769]                   sendCondition(cond)
[08:28:40.769]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:40.769]                   {
[08:28:40.769]                     inherits <- base::inherits
[08:28:40.769]                     invokeRestart <- base::invokeRestart
[08:28:40.769]                     is.null <- base::is.null
[08:28:40.769]                     muffled <- FALSE
[08:28:40.769]                     if (inherits(cond, "message")) {
[08:28:40.769]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:40.769]                       if (muffled) 
[08:28:40.769]                         invokeRestart("muffleMessage")
[08:28:40.769]                     }
[08:28:40.769]                     else if (inherits(cond, "warning")) {
[08:28:40.769]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:40.769]                       if (muffled) 
[08:28:40.769]                         invokeRestart("muffleWarning")
[08:28:40.769]                     }
[08:28:40.769]                     else if (inherits(cond, "condition")) {
[08:28:40.769]                       if (!is.null(pattern)) {
[08:28:40.769]                         computeRestarts <- base::computeRestarts
[08:28:40.769]                         grepl <- base::grepl
[08:28:40.769]                         restarts <- computeRestarts(cond)
[08:28:40.769]                         for (restart in restarts) {
[08:28:40.769]                           name <- restart$name
[08:28:40.769]                           if (is.null(name)) 
[08:28:40.769]                             next
[08:28:40.769]                           if (!grepl(pattern, name)) 
[08:28:40.769]                             next
[08:28:40.769]                           invokeRestart(restart)
[08:28:40.769]                           muffled <- TRUE
[08:28:40.769]                           break
[08:28:40.769]                         }
[08:28:40.769]                       }
[08:28:40.769]                     }
[08:28:40.769]                     invisible(muffled)
[08:28:40.769]                   }
[08:28:40.769]                   muffleCondition(cond)
[08:28:40.769]                 })
[08:28:40.769]             }))
[08:28:40.769]             future::FutureResult(value = ...future.value$value, 
[08:28:40.769]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:40.769]                   ...future.rng), globalenv = if (FALSE) 
[08:28:40.769]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:40.769]                     ...future.globalenv.names))
[08:28:40.769]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:40.769]         }, condition = base::local({
[08:28:40.769]             c <- base::c
[08:28:40.769]             inherits <- base::inherits
[08:28:40.769]             invokeRestart <- base::invokeRestart
[08:28:40.769]             length <- base::length
[08:28:40.769]             list <- base::list
[08:28:40.769]             seq.int <- base::seq.int
[08:28:40.769]             signalCondition <- base::signalCondition
[08:28:40.769]             sys.calls <- base::sys.calls
[08:28:40.769]             `[[` <- base::`[[`
[08:28:40.769]             `+` <- base::`+`
[08:28:40.769]             `<<-` <- base::`<<-`
[08:28:40.769]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:40.769]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:40.769]                   3L)]
[08:28:40.769]             }
[08:28:40.769]             function(cond) {
[08:28:40.769]                 is_error <- inherits(cond, "error")
[08:28:40.769]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:40.769]                   NULL)
[08:28:40.769]                 if (is_error) {
[08:28:40.769]                   sessionInformation <- function() {
[08:28:40.769]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:40.769]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:40.769]                       search = base::search(), system = base::Sys.info())
[08:28:40.769]                   }
[08:28:40.769]                   ...future.conditions[[length(...future.conditions) + 
[08:28:40.769]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:40.769]                     cond$call), session = sessionInformation(), 
[08:28:40.769]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:40.769]                   signalCondition(cond)
[08:28:40.769]                 }
[08:28:40.769]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:40.769]                 "immediateCondition"))) {
[08:28:40.769]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:40.769]                   ...future.conditions[[length(...future.conditions) + 
[08:28:40.769]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:40.769]                   if (TRUE && !signal) {
[08:28:40.769]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:40.769]                     {
[08:28:40.769]                       inherits <- base::inherits
[08:28:40.769]                       invokeRestart <- base::invokeRestart
[08:28:40.769]                       is.null <- base::is.null
[08:28:40.769]                       muffled <- FALSE
[08:28:40.769]                       if (inherits(cond, "message")) {
[08:28:40.769]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:40.769]                         if (muffled) 
[08:28:40.769]                           invokeRestart("muffleMessage")
[08:28:40.769]                       }
[08:28:40.769]                       else if (inherits(cond, "warning")) {
[08:28:40.769]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:40.769]                         if (muffled) 
[08:28:40.769]                           invokeRestart("muffleWarning")
[08:28:40.769]                       }
[08:28:40.769]                       else if (inherits(cond, "condition")) {
[08:28:40.769]                         if (!is.null(pattern)) {
[08:28:40.769]                           computeRestarts <- base::computeRestarts
[08:28:40.769]                           grepl <- base::grepl
[08:28:40.769]                           restarts <- computeRestarts(cond)
[08:28:40.769]                           for (restart in restarts) {
[08:28:40.769]                             name <- restart$name
[08:28:40.769]                             if (is.null(name)) 
[08:28:40.769]                               next
[08:28:40.769]                             if (!grepl(pattern, name)) 
[08:28:40.769]                               next
[08:28:40.769]                             invokeRestart(restart)
[08:28:40.769]                             muffled <- TRUE
[08:28:40.769]                             break
[08:28:40.769]                           }
[08:28:40.769]                         }
[08:28:40.769]                       }
[08:28:40.769]                       invisible(muffled)
[08:28:40.769]                     }
[08:28:40.769]                     muffleCondition(cond, pattern = "^muffle")
[08:28:40.769]                   }
[08:28:40.769]                 }
[08:28:40.769]                 else {
[08:28:40.769]                   if (TRUE) {
[08:28:40.769]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:40.769]                     {
[08:28:40.769]                       inherits <- base::inherits
[08:28:40.769]                       invokeRestart <- base::invokeRestart
[08:28:40.769]                       is.null <- base::is.null
[08:28:40.769]                       muffled <- FALSE
[08:28:40.769]                       if (inherits(cond, "message")) {
[08:28:40.769]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:40.769]                         if (muffled) 
[08:28:40.769]                           invokeRestart("muffleMessage")
[08:28:40.769]                       }
[08:28:40.769]                       else if (inherits(cond, "warning")) {
[08:28:40.769]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:40.769]                         if (muffled) 
[08:28:40.769]                           invokeRestart("muffleWarning")
[08:28:40.769]                       }
[08:28:40.769]                       else if (inherits(cond, "condition")) {
[08:28:40.769]                         if (!is.null(pattern)) {
[08:28:40.769]                           computeRestarts <- base::computeRestarts
[08:28:40.769]                           grepl <- base::grepl
[08:28:40.769]                           restarts <- computeRestarts(cond)
[08:28:40.769]                           for (restart in restarts) {
[08:28:40.769]                             name <- restart$name
[08:28:40.769]                             if (is.null(name)) 
[08:28:40.769]                               next
[08:28:40.769]                             if (!grepl(pattern, name)) 
[08:28:40.769]                               next
[08:28:40.769]                             invokeRestart(restart)
[08:28:40.769]                             muffled <- TRUE
[08:28:40.769]                             break
[08:28:40.769]                           }
[08:28:40.769]                         }
[08:28:40.769]                       }
[08:28:40.769]                       invisible(muffled)
[08:28:40.769]                     }
[08:28:40.769]                     muffleCondition(cond, pattern = "^muffle")
[08:28:40.769]                   }
[08:28:40.769]                 }
[08:28:40.769]             }
[08:28:40.769]         }))
[08:28:40.769]     }, error = function(ex) {
[08:28:40.769]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:40.769]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:40.769]                 ...future.rng), started = ...future.startTime, 
[08:28:40.769]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:40.769]             version = "1.8"), class = "FutureResult")
[08:28:40.769]     }, finally = {
[08:28:40.769]         if (!identical(...future.workdir, getwd())) 
[08:28:40.769]             setwd(...future.workdir)
[08:28:40.769]         {
[08:28:40.769]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:40.769]                 ...future.oldOptions$nwarnings <- NULL
[08:28:40.769]             }
[08:28:40.769]             base::options(...future.oldOptions)
[08:28:40.769]             if (.Platform$OS.type == "windows") {
[08:28:40.769]                 old_names <- names(...future.oldEnvVars)
[08:28:40.769]                 envs <- base::Sys.getenv()
[08:28:40.769]                 names <- names(envs)
[08:28:40.769]                 common <- intersect(names, old_names)
[08:28:40.769]                 added <- setdiff(names, old_names)
[08:28:40.769]                 removed <- setdiff(old_names, names)
[08:28:40.769]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:40.769]                   envs[common]]
[08:28:40.769]                 NAMES <- toupper(changed)
[08:28:40.769]                 args <- list()
[08:28:40.769]                 for (kk in seq_along(NAMES)) {
[08:28:40.769]                   name <- changed[[kk]]
[08:28:40.769]                   NAME <- NAMES[[kk]]
[08:28:40.769]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:40.769]                     next
[08:28:40.769]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:40.769]                 }
[08:28:40.769]                 NAMES <- toupper(added)
[08:28:40.769]                 for (kk in seq_along(NAMES)) {
[08:28:40.769]                   name <- added[[kk]]
[08:28:40.769]                   NAME <- NAMES[[kk]]
[08:28:40.769]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:40.769]                     next
[08:28:40.769]                   args[[name]] <- ""
[08:28:40.769]                 }
[08:28:40.769]                 NAMES <- toupper(removed)
[08:28:40.769]                 for (kk in seq_along(NAMES)) {
[08:28:40.769]                   name <- removed[[kk]]
[08:28:40.769]                   NAME <- NAMES[[kk]]
[08:28:40.769]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:40.769]                     next
[08:28:40.769]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:40.769]                 }
[08:28:40.769]                 if (length(args) > 0) 
[08:28:40.769]                   base::do.call(base::Sys.setenv, args = args)
[08:28:40.769]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:40.769]             }
[08:28:40.769]             else {
[08:28:40.769]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:40.769]             }
[08:28:40.769]             {
[08:28:40.769]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:40.769]                   0L) {
[08:28:40.769]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:40.769]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:40.769]                   base::options(opts)
[08:28:40.769]                 }
[08:28:40.769]                 {
[08:28:40.769]                   {
[08:28:40.769]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:40.769]                     NULL
[08:28:40.769]                   }
[08:28:40.769]                   options(future.plan = NULL)
[08:28:40.769]                   if (is.na(NA_character_)) 
[08:28:40.769]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:40.769]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:40.769]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:40.769]                     .init = FALSE)
[08:28:40.769]                 }
[08:28:40.769]             }
[08:28:40.769]         }
[08:28:40.769]     })
[08:28:40.769]     if (TRUE) {
[08:28:40.769]         base::sink(type = "output", split = FALSE)
[08:28:40.769]         if (TRUE) {
[08:28:40.769]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:40.769]         }
[08:28:40.769]         else {
[08:28:40.769]             ...future.result["stdout"] <- base::list(NULL)
[08:28:40.769]         }
[08:28:40.769]         base::close(...future.stdout)
[08:28:40.769]         ...future.stdout <- NULL
[08:28:40.769]     }
[08:28:40.769]     ...future.result$conditions <- ...future.conditions
[08:28:40.769]     ...future.result$finished <- base::Sys.time()
[08:28:40.769]     ...future.result
[08:28:40.769] }
[08:28:40.773] Exporting 2 global objects (12.04 KiB) to cluster node #1 ...
[08:28:40.773] Exporting ‘nested’ (11.69 KiB) to cluster node #1 ...
[08:28:40.813] Exporting ‘nested’ (11.69 KiB) to cluster node #1 ... DONE
[08:28:40.814] Exporting ‘strategy2’ (48 bytes) to cluster node #1 ...
[08:28:40.814] Exporting ‘strategy2’ (48 bytes) to cluster node #1 ... DONE
[08:28:40.814] Exporting 2 global objects (12.04 KiB) to cluster node #1 ... DONE
[08:28:40.815] MultisessionFuture started
[08:28:40.815] - Launch lazy future ... done
[08:28:40.815] run() for ‘MultisessionFuture’ ... done
[08:28:40.815] result() for ClusterFuture ...
[08:28:40.815] receiveMessageFromWorker() for ClusterFuture ...
[08:28:40.815] - Validating connection of MultisessionFuture
[08:28:40.879] - received message: FutureResult
[08:28:40.880] - Received FutureResult
[08:28:40.880] - Erased future from FutureRegistry
[08:28:40.880] result() for ClusterFuture ...
[08:28:40.880] - result already collected: FutureResult
[08:28:40.880] result() for ClusterFuture ... done
[08:28:40.880] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:40.880] result() for ClusterFuture ... done
[08:28:40.880] result() for ClusterFuture ...
[08:28:40.880] - result already collected: FutureResult
[08:28:40.880] result() for ClusterFuture ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[08:28:40.885] getGlobalsAndPackages() ...
[08:28:40.885] Searching for globals...
[08:28:40.887] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[08:28:40.887] Searching for globals ... DONE
[08:28:40.887] Resolving globals: FALSE
[08:28:40.887] The total size of the 1 globals is 356 bytes (356 bytes)
[08:28:40.888] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[08:28:40.888] - globals: [1] ‘data’
[08:28:40.888] - packages: [1] ‘future’
[08:28:40.888] getGlobalsAndPackages() ... DONE
[08:28:40.888] run() for ‘Future’ ...
[08:28:40.888] - state: ‘created’
[08:28:40.888] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:40.904] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:40.904] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:40.904]   - Field: ‘node’
[08:28:40.904]   - Field: ‘label’
[08:28:40.904]   - Field: ‘local’
[08:28:40.904]   - Field: ‘owner’
[08:28:40.904]   - Field: ‘envir’
[08:28:40.904]   - Field: ‘workers’
[08:28:40.905]   - Field: ‘packages’
[08:28:40.905]   - Field: ‘gc’
[08:28:40.905]   - Field: ‘conditions’
[08:28:40.905]   - Field: ‘persistent’
[08:28:40.905]   - Field: ‘expr’
[08:28:40.905]   - Field: ‘uuid’
[08:28:40.905]   - Field: ‘seed’
[08:28:40.905]   - Field: ‘version’
[08:28:40.905]   - Field: ‘result’
[08:28:40.905]   - Field: ‘asynchronous’
[08:28:40.905]   - Field: ‘calls’
[08:28:40.905]   - Field: ‘globals’
[08:28:40.906]   - Field: ‘stdout’
[08:28:40.906]   - Field: ‘earlySignal’
[08:28:40.906]   - Field: ‘lazy’
[08:28:40.906]   - Field: ‘state’
[08:28:40.906] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:40.906] - Launch lazy future ...
[08:28:40.906] Packages needed by the future expression (n = 1): ‘future’
[08:28:40.906] Packages needed by future strategies (n = 1): ‘future’
[08:28:40.907] {
[08:28:40.907]     {
[08:28:40.907]         {
[08:28:40.907]             ...future.startTime <- base::Sys.time()
[08:28:40.907]             {
[08:28:40.907]                 {
[08:28:40.907]                   {
[08:28:40.907]                     {
[08:28:40.907]                       {
[08:28:40.907]                         base::local({
[08:28:40.907]                           has_future <- base::requireNamespace("future", 
[08:28:40.907]                             quietly = TRUE)
[08:28:40.907]                           if (has_future) {
[08:28:40.907]                             ns <- base::getNamespace("future")
[08:28:40.907]                             version <- ns[[".package"]][["version"]]
[08:28:40.907]                             if (is.null(version)) 
[08:28:40.907]                               version <- utils::packageVersion("future")
[08:28:40.907]                           }
[08:28:40.907]                           else {
[08:28:40.907]                             version <- NULL
[08:28:40.907]                           }
[08:28:40.907]                           if (!has_future || version < "1.8.0") {
[08:28:40.907]                             info <- base::c(r_version = base::gsub("R version ", 
[08:28:40.907]                               "", base::R.version$version.string), 
[08:28:40.907]                               platform = base::sprintf("%s (%s-bit)", 
[08:28:40.907]                                 base::R.version$platform, 8 * 
[08:28:40.907]                                   base::.Machine$sizeof.pointer), 
[08:28:40.907]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:40.907]                                 "release", "version")], collapse = " "), 
[08:28:40.907]                               hostname = base::Sys.info()[["nodename"]])
[08:28:40.907]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:28:40.907]                               info)
[08:28:40.907]                             info <- base::paste(info, collapse = "; ")
[08:28:40.907]                             if (!has_future) {
[08:28:40.907]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:40.907]                                 info)
[08:28:40.907]                             }
[08:28:40.907]                             else {
[08:28:40.907]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:40.907]                                 info, version)
[08:28:40.907]                             }
[08:28:40.907]                             base::stop(msg)
[08:28:40.907]                           }
[08:28:40.907]                         })
[08:28:40.907]                       }
[08:28:40.907]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:40.907]                       base::options(mc.cores = 1L)
[08:28:40.907]                     }
[08:28:40.907]                     base::local({
[08:28:40.907]                       for (pkg in "future") {
[08:28:40.907]                         base::loadNamespace(pkg)
[08:28:40.907]                         base::library(pkg, character.only = TRUE)
[08:28:40.907]                       }
[08:28:40.907]                     })
[08:28:40.907]                   }
[08:28:40.907]                   ...future.strategy.old <- future::plan("list")
[08:28:40.907]                   options(future.plan = NULL)
[08:28:40.907]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:40.907]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[08:28:40.907]                     envir = parent.frame()) 
[08:28:40.907]                   {
[08:28:40.907]                     default_workers <- missing(workers)
[08:28:40.907]                     if (is.function(workers)) 
[08:28:40.907]                       workers <- workers()
[08:28:40.907]                     workers <- structure(as.integer(workers), 
[08:28:40.907]                       class = class(workers))
[08:28:40.907]                     stop_if_not(is.finite(workers), workers >= 
[08:28:40.907]                       1L)
[08:28:40.907]                     if ((workers == 1L && !inherits(workers, 
[08:28:40.907]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[08:28:40.907]                       if (default_workers) 
[08:28:40.907]                         supportsMulticore(warn = TRUE)
[08:28:40.907]                       return(sequential(..., envir = envir))
[08:28:40.907]                     }
[08:28:40.907]                     oopts <- options(mc.cores = workers)
[08:28:40.907]                     on.exit(options(oopts))
[08:28:40.907]                     future <- MulticoreFuture(..., workers = workers, 
[08:28:40.907]                       envir = envir)
[08:28:40.907]                     if (!future$lazy) 
[08:28:40.907]                       future <- run(future)
[08:28:40.907]                     invisible(future)
[08:28:40.907]                   }), .cleanup = FALSE, .init = FALSE)
[08:28:40.907]                 }
[08:28:40.907]                 ...future.workdir <- getwd()
[08:28:40.907]             }
[08:28:40.907]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:40.907]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:40.907]         }
[08:28:40.907]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:40.907]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:40.907]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:40.907]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:40.907]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:40.907]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:40.907]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:40.907]             base::names(...future.oldOptions))
[08:28:40.907]     }
[08:28:40.907]     if (FALSE) {
[08:28:40.907]     }
[08:28:40.907]     else {
[08:28:40.907]         if (TRUE) {
[08:28:40.907]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:40.907]                 open = "w")
[08:28:40.907]         }
[08:28:40.907]         else {
[08:28:40.907]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:40.907]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:40.907]         }
[08:28:40.907]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:40.907]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:40.907]             base::sink(type = "output", split = FALSE)
[08:28:40.907]             base::close(...future.stdout)
[08:28:40.907]         }, add = TRUE)
[08:28:40.907]     }
[08:28:40.907]     ...future.frame <- base::sys.nframe()
[08:28:40.907]     ...future.conditions <- base::list()
[08:28:40.907]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:40.907]     if (FALSE) {
[08:28:40.907]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:40.907]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:40.907]     }
[08:28:40.907]     ...future.result <- base::tryCatch({
[08:28:40.907]         base::withCallingHandlers({
[08:28:40.907]             ...future.value <- base::withVisible(base::local({
[08:28:40.907]                 ...future.makeSendCondition <- base::local({
[08:28:40.907]                   sendCondition <- NULL
[08:28:40.907]                   function(frame = 1L) {
[08:28:40.907]                     if (is.function(sendCondition)) 
[08:28:40.907]                       return(sendCondition)
[08:28:40.907]                     ns <- getNamespace("parallel")
[08:28:40.907]                     if (exists("sendData", mode = "function", 
[08:28:40.907]                       envir = ns)) {
[08:28:40.907]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:40.907]                         envir = ns)
[08:28:40.907]                       envir <- sys.frame(frame)
[08:28:40.907]                       master <- NULL
[08:28:40.907]                       while (!identical(envir, .GlobalEnv) && 
[08:28:40.907]                         !identical(envir, emptyenv())) {
[08:28:40.907]                         if (exists("master", mode = "list", envir = envir, 
[08:28:40.907]                           inherits = FALSE)) {
[08:28:40.907]                           master <- get("master", mode = "list", 
[08:28:40.907]                             envir = envir, inherits = FALSE)
[08:28:40.907]                           if (inherits(master, c("SOCKnode", 
[08:28:40.907]                             "SOCK0node"))) {
[08:28:40.907]                             sendCondition <<- function(cond) {
[08:28:40.907]                               data <- list(type = "VALUE", value = cond, 
[08:28:40.907]                                 success = TRUE)
[08:28:40.907]                               parallel_sendData(master, data)
[08:28:40.907]                             }
[08:28:40.907]                             return(sendCondition)
[08:28:40.907]                           }
[08:28:40.907]                         }
[08:28:40.907]                         frame <- frame + 1L
[08:28:40.907]                         envir <- sys.frame(frame)
[08:28:40.907]                       }
[08:28:40.907]                     }
[08:28:40.907]                     sendCondition <<- function(cond) NULL
[08:28:40.907]                   }
[08:28:40.907]                 })
[08:28:40.907]                 withCallingHandlers({
[08:28:40.907]                   {
[08:28:40.907]                     value(future(subset(data, a == 2)))
[08:28:40.907]                   }
[08:28:40.907]                 }, immediateCondition = function(cond) {
[08:28:40.907]                   sendCondition <- ...future.makeSendCondition()
[08:28:40.907]                   sendCondition(cond)
[08:28:40.907]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:40.907]                   {
[08:28:40.907]                     inherits <- base::inherits
[08:28:40.907]                     invokeRestart <- base::invokeRestart
[08:28:40.907]                     is.null <- base::is.null
[08:28:40.907]                     muffled <- FALSE
[08:28:40.907]                     if (inherits(cond, "message")) {
[08:28:40.907]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:40.907]                       if (muffled) 
[08:28:40.907]                         invokeRestart("muffleMessage")
[08:28:40.907]                     }
[08:28:40.907]                     else if (inherits(cond, "warning")) {
[08:28:40.907]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:40.907]                       if (muffled) 
[08:28:40.907]                         invokeRestart("muffleWarning")
[08:28:40.907]                     }
[08:28:40.907]                     else if (inherits(cond, "condition")) {
[08:28:40.907]                       if (!is.null(pattern)) {
[08:28:40.907]                         computeRestarts <- base::computeRestarts
[08:28:40.907]                         grepl <- base::grepl
[08:28:40.907]                         restarts <- computeRestarts(cond)
[08:28:40.907]                         for (restart in restarts) {
[08:28:40.907]                           name <- restart$name
[08:28:40.907]                           if (is.null(name)) 
[08:28:40.907]                             next
[08:28:40.907]                           if (!grepl(pattern, name)) 
[08:28:40.907]                             next
[08:28:40.907]                           invokeRestart(restart)
[08:28:40.907]                           muffled <- TRUE
[08:28:40.907]                           break
[08:28:40.907]                         }
[08:28:40.907]                       }
[08:28:40.907]                     }
[08:28:40.907]                     invisible(muffled)
[08:28:40.907]                   }
[08:28:40.907]                   muffleCondition(cond)
[08:28:40.907]                 })
[08:28:40.907]             }))
[08:28:40.907]             future::FutureResult(value = ...future.value$value, 
[08:28:40.907]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:40.907]                   ...future.rng), globalenv = if (FALSE) 
[08:28:40.907]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:40.907]                     ...future.globalenv.names))
[08:28:40.907]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:40.907]         }, condition = base::local({
[08:28:40.907]             c <- base::c
[08:28:40.907]             inherits <- base::inherits
[08:28:40.907]             invokeRestart <- base::invokeRestart
[08:28:40.907]             length <- base::length
[08:28:40.907]             list <- base::list
[08:28:40.907]             seq.int <- base::seq.int
[08:28:40.907]             signalCondition <- base::signalCondition
[08:28:40.907]             sys.calls <- base::sys.calls
[08:28:40.907]             `[[` <- base::`[[`
[08:28:40.907]             `+` <- base::`+`
[08:28:40.907]             `<<-` <- base::`<<-`
[08:28:40.907]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:40.907]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:40.907]                   3L)]
[08:28:40.907]             }
[08:28:40.907]             function(cond) {
[08:28:40.907]                 is_error <- inherits(cond, "error")
[08:28:40.907]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:40.907]                   NULL)
[08:28:40.907]                 if (is_error) {
[08:28:40.907]                   sessionInformation <- function() {
[08:28:40.907]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:40.907]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:40.907]                       search = base::search(), system = base::Sys.info())
[08:28:40.907]                   }
[08:28:40.907]                   ...future.conditions[[length(...future.conditions) + 
[08:28:40.907]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:40.907]                     cond$call), session = sessionInformation(), 
[08:28:40.907]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:40.907]                   signalCondition(cond)
[08:28:40.907]                 }
[08:28:40.907]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:40.907]                 "immediateCondition"))) {
[08:28:40.907]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:40.907]                   ...future.conditions[[length(...future.conditions) + 
[08:28:40.907]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:40.907]                   if (TRUE && !signal) {
[08:28:40.907]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:40.907]                     {
[08:28:40.907]                       inherits <- base::inherits
[08:28:40.907]                       invokeRestart <- base::invokeRestart
[08:28:40.907]                       is.null <- base::is.null
[08:28:40.907]                       muffled <- FALSE
[08:28:40.907]                       if (inherits(cond, "message")) {
[08:28:40.907]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:40.907]                         if (muffled) 
[08:28:40.907]                           invokeRestart("muffleMessage")
[08:28:40.907]                       }
[08:28:40.907]                       else if (inherits(cond, "warning")) {
[08:28:40.907]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:40.907]                         if (muffled) 
[08:28:40.907]                           invokeRestart("muffleWarning")
[08:28:40.907]                       }
[08:28:40.907]                       else if (inherits(cond, "condition")) {
[08:28:40.907]                         if (!is.null(pattern)) {
[08:28:40.907]                           computeRestarts <- base::computeRestarts
[08:28:40.907]                           grepl <- base::grepl
[08:28:40.907]                           restarts <- computeRestarts(cond)
[08:28:40.907]                           for (restart in restarts) {
[08:28:40.907]                             name <- restart$name
[08:28:40.907]                             if (is.null(name)) 
[08:28:40.907]                               next
[08:28:40.907]                             if (!grepl(pattern, name)) 
[08:28:40.907]                               next
[08:28:40.907]                             invokeRestart(restart)
[08:28:40.907]                             muffled <- TRUE
[08:28:40.907]                             break
[08:28:40.907]                           }
[08:28:40.907]                         }
[08:28:40.907]                       }
[08:28:40.907]                       invisible(muffled)
[08:28:40.907]                     }
[08:28:40.907]                     muffleCondition(cond, pattern = "^muffle")
[08:28:40.907]                   }
[08:28:40.907]                 }
[08:28:40.907]                 else {
[08:28:40.907]                   if (TRUE) {
[08:28:40.907]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:40.907]                     {
[08:28:40.907]                       inherits <- base::inherits
[08:28:40.907]                       invokeRestart <- base::invokeRestart
[08:28:40.907]                       is.null <- base::is.null
[08:28:40.907]                       muffled <- FALSE
[08:28:40.907]                       if (inherits(cond, "message")) {
[08:28:40.907]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:40.907]                         if (muffled) 
[08:28:40.907]                           invokeRestart("muffleMessage")
[08:28:40.907]                       }
[08:28:40.907]                       else if (inherits(cond, "warning")) {
[08:28:40.907]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:40.907]                         if (muffled) 
[08:28:40.907]                           invokeRestart("muffleWarning")
[08:28:40.907]                       }
[08:28:40.907]                       else if (inherits(cond, "condition")) {
[08:28:40.907]                         if (!is.null(pattern)) {
[08:28:40.907]                           computeRestarts <- base::computeRestarts
[08:28:40.907]                           grepl <- base::grepl
[08:28:40.907]                           restarts <- computeRestarts(cond)
[08:28:40.907]                           for (restart in restarts) {
[08:28:40.907]                             name <- restart$name
[08:28:40.907]                             if (is.null(name)) 
[08:28:40.907]                               next
[08:28:40.907]                             if (!grepl(pattern, name)) 
[08:28:40.907]                               next
[08:28:40.907]                             invokeRestart(restart)
[08:28:40.907]                             muffled <- TRUE
[08:28:40.907]                             break
[08:28:40.907]                           }
[08:28:40.907]                         }
[08:28:40.907]                       }
[08:28:40.907]                       invisible(muffled)
[08:28:40.907]                     }
[08:28:40.907]                     muffleCondition(cond, pattern = "^muffle")
[08:28:40.907]                   }
[08:28:40.907]                 }
[08:28:40.907]             }
[08:28:40.907]         }))
[08:28:40.907]     }, error = function(ex) {
[08:28:40.907]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:40.907]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:40.907]                 ...future.rng), started = ...future.startTime, 
[08:28:40.907]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:40.907]             version = "1.8"), class = "FutureResult")
[08:28:40.907]     }, finally = {
[08:28:40.907]         if (!identical(...future.workdir, getwd())) 
[08:28:40.907]             setwd(...future.workdir)
[08:28:40.907]         {
[08:28:40.907]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:40.907]                 ...future.oldOptions$nwarnings <- NULL
[08:28:40.907]             }
[08:28:40.907]             base::options(...future.oldOptions)
[08:28:40.907]             if (.Platform$OS.type == "windows") {
[08:28:40.907]                 old_names <- names(...future.oldEnvVars)
[08:28:40.907]                 envs <- base::Sys.getenv()
[08:28:40.907]                 names <- names(envs)
[08:28:40.907]                 common <- intersect(names, old_names)
[08:28:40.907]                 added <- setdiff(names, old_names)
[08:28:40.907]                 removed <- setdiff(old_names, names)
[08:28:40.907]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:40.907]                   envs[common]]
[08:28:40.907]                 NAMES <- toupper(changed)
[08:28:40.907]                 args <- list()
[08:28:40.907]                 for (kk in seq_along(NAMES)) {
[08:28:40.907]                   name <- changed[[kk]]
[08:28:40.907]                   NAME <- NAMES[[kk]]
[08:28:40.907]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:40.907]                     next
[08:28:40.907]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:40.907]                 }
[08:28:40.907]                 NAMES <- toupper(added)
[08:28:40.907]                 for (kk in seq_along(NAMES)) {
[08:28:40.907]                   name <- added[[kk]]
[08:28:40.907]                   NAME <- NAMES[[kk]]
[08:28:40.907]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:40.907]                     next
[08:28:40.907]                   args[[name]] <- ""
[08:28:40.907]                 }
[08:28:40.907]                 NAMES <- toupper(removed)
[08:28:40.907]                 for (kk in seq_along(NAMES)) {
[08:28:40.907]                   name <- removed[[kk]]
[08:28:40.907]                   NAME <- NAMES[[kk]]
[08:28:40.907]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:40.907]                     next
[08:28:40.907]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:40.907]                 }
[08:28:40.907]                 if (length(args) > 0) 
[08:28:40.907]                   base::do.call(base::Sys.setenv, args = args)
[08:28:40.907]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:40.907]             }
[08:28:40.907]             else {
[08:28:40.907]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:40.907]             }
[08:28:40.907]             {
[08:28:40.907]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:40.907]                   0L) {
[08:28:40.907]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:40.907]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:40.907]                   base::options(opts)
[08:28:40.907]                 }
[08:28:40.907]                 {
[08:28:40.907]                   {
[08:28:40.907]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:40.907]                     NULL
[08:28:40.907]                   }
[08:28:40.907]                   options(future.plan = NULL)
[08:28:40.907]                   if (is.na(NA_character_)) 
[08:28:40.907]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:40.907]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:40.907]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:40.907]                     .init = FALSE)
[08:28:40.907]                 }
[08:28:40.907]             }
[08:28:40.907]         }
[08:28:40.907]     })
[08:28:40.907]     if (TRUE) {
[08:28:40.907]         base::sink(type = "output", split = FALSE)
[08:28:40.907]         if (TRUE) {
[08:28:40.907]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:40.907]         }
[08:28:40.907]         else {
[08:28:40.907]             ...future.result["stdout"] <- base::list(NULL)
[08:28:40.907]         }
[08:28:40.907]         base::close(...future.stdout)
[08:28:40.907]         ...future.stdout <- NULL
[08:28:40.907]     }
[08:28:40.907]     ...future.result$conditions <- ...future.conditions
[08:28:40.907]     ...future.result$finished <- base::Sys.time()
[08:28:40.907]     ...future.result
[08:28:40.907] }
[08:28:40.910] Exporting 1 global objects (643 bytes) to cluster node #1 ...
[08:28:40.910] Exporting ‘data’ (356 bytes) to cluster node #1 ...
[08:28:40.910] Exporting ‘data’ (356 bytes) to cluster node #1 ... DONE
[08:28:40.911] Exporting 1 global objects (643 bytes) to cluster node #1 ... DONE
[08:28:40.911] MultisessionFuture started
[08:28:40.911] - Launch lazy future ... done
[08:28:40.911] run() for ‘MultisessionFuture’ ... done
[08:28:40.911] result() for ClusterFuture ...
[08:28:40.911] receiveMessageFromWorker() for ClusterFuture ...
[08:28:40.912] - Validating connection of MultisessionFuture
[08:28:40.961] - received message: FutureResult
[08:28:40.961] - Received FutureResult
[08:28:40.962] - Erased future from FutureRegistry
[08:28:40.962] result() for ClusterFuture ...
[08:28:40.962] - result already collected: FutureResult
[08:28:40.962] result() for ClusterFuture ... done
[08:28:40.962] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:40.962] result() for ClusterFuture ... done
[08:28:40.962] result() for ClusterFuture ...
[08:28:40.962] - result already collected: FutureResult
[08:28:40.962] result() for ClusterFuture ... done
- plan(list('multisession', 'multicore')) ... DONE
- plan(list('multisession', 'multisession')) ...
[08:28:40.963] plan(): Setting new future strategy stack:
[08:28:40.963] List of future strategies:
[08:28:40.963] 1. multisession:
[08:28:40.963]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:28:40.963]    - tweaked: FALSE
[08:28:40.963]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:40.963] 2. multisession:
[08:28:40.963]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:28:40.963]    - tweaked: FALSE
[08:28:40.963]    - call: plan(list(a = strategy1, b = strategy2))
[08:28:40.964] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[08:28:40.964] multisession:
[08:28:40.964] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:28:40.964] - tweaked: FALSE
[08:28:40.964] - call: plan(list(a = strategy1, b = strategy2))
[08:28:40.966] getGlobalsAndPackages() ...
[08:28:40.967] Not searching for globals
[08:28:40.967] - globals: [0] <none>
[08:28:40.967] getGlobalsAndPackages() ... DONE
[08:28:41.245] Packages needed by the future expression (n = 0): <none>
[08:28:41.245] Packages needed by future strategies (n = 1): ‘future’
[08:28:41.245] {
[08:28:41.245]     {
[08:28:41.245]         {
[08:28:41.245]             ...future.startTime <- base::Sys.time()
[08:28:41.245]             {
[08:28:41.245]                 {
[08:28:41.245]                   {
[08:28:41.245]                     {
[08:28:41.245]                       {
[08:28:41.245]                         base::local({
[08:28:41.245]                           has_future <- base::requireNamespace("future", 
[08:28:41.245]                             quietly = TRUE)
[08:28:41.245]                           if (has_future) {
[08:28:41.245]                             ns <- base::getNamespace("future")
[08:28:41.245]                             version <- ns[[".package"]][["version"]]
[08:28:41.245]                             if (is.null(version)) 
[08:28:41.245]                               version <- utils::packageVersion("future")
[08:28:41.245]                           }
[08:28:41.245]                           else {
[08:28:41.245]                             version <- NULL
[08:28:41.245]                           }
[08:28:41.245]                           if (!has_future || version < "1.8.0") {
[08:28:41.245]                             info <- base::c(r_version = base::gsub("R version ", 
[08:28:41.245]                               "", base::R.version$version.string), 
[08:28:41.245]                               platform = base::sprintf("%s (%s-bit)", 
[08:28:41.245]                                 base::R.version$platform, 8 * 
[08:28:41.245]                                   base::.Machine$sizeof.pointer), 
[08:28:41.245]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:41.245]                                 "release", "version")], collapse = " "), 
[08:28:41.245]                               hostname = base::Sys.info()[["nodename"]])
[08:28:41.245]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:28:41.245]                               info)
[08:28:41.245]                             info <- base::paste(info, collapse = "; ")
[08:28:41.245]                             if (!has_future) {
[08:28:41.245]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:41.245]                                 info)
[08:28:41.245]                             }
[08:28:41.245]                             else {
[08:28:41.245]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:41.245]                                 info, version)
[08:28:41.245]                             }
[08:28:41.245]                             base::stop(msg)
[08:28:41.245]                           }
[08:28:41.245]                         })
[08:28:41.245]                       }
[08:28:41.245]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:41.245]                       base::options(mc.cores = 1L)
[08:28:41.245]                     }
[08:28:41.245]                     base::local({
[08:28:41.245]                       for (pkg in "future") {
[08:28:41.245]                         base::loadNamespace(pkg)
[08:28:41.245]                         base::library(pkg, character.only = TRUE)
[08:28:41.245]                       }
[08:28:41.245]                     })
[08:28:41.245]                   }
[08:28:41.245]                   ...future.strategy.old <- future::plan("list")
[08:28:41.245]                   options(future.plan = NULL)
[08:28:41.245]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:41.245]                   future::plan(list(b = function (..., workers = availableCores(), 
[08:28:41.245]                     lazy = FALSE, rscript_libs = .libPaths(), 
[08:28:41.245]                     envir = parent.frame()) 
[08:28:41.245]                   {
[08:28:41.245]                     if (is.function(workers)) 
[08:28:41.245]                       workers <- workers()
[08:28:41.245]                     workers <- structure(as.integer(workers), 
[08:28:41.245]                       class = class(workers))
[08:28:41.245]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[08:28:41.245]                       workers >= 1)
[08:28:41.245]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[08:28:41.245]                       return(sequential(..., lazy = TRUE, envir = envir))
[08:28:41.245]                     }
[08:28:41.245]                     future <- MultisessionFuture(..., workers = workers, 
[08:28:41.245]                       lazy = lazy, rscript_libs = rscript_libs, 
[08:28:41.245]                       envir = envir)
[08:28:41.245]                     if (!future$lazy) 
[08:28:41.245]                       future <- run(future)
[08:28:41.245]                     invisible(future)
[08:28:41.245]                   }), .cleanup = FALSE, .init = FALSE)
[08:28:41.245]                 }
[08:28:41.245]                 ...future.workdir <- getwd()
[08:28:41.245]             }
[08:28:41.245]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:41.245]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:41.245]         }
[08:28:41.245]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:41.245]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:41.245]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:41.245]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:41.245]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:41.245]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:41.245]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:41.245]             base::names(...future.oldOptions))
[08:28:41.245]     }
[08:28:41.245]     if (FALSE) {
[08:28:41.245]     }
[08:28:41.245]     else {
[08:28:41.245]         if (TRUE) {
[08:28:41.245]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:41.245]                 open = "w")
[08:28:41.245]         }
[08:28:41.245]         else {
[08:28:41.245]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:41.245]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:41.245]         }
[08:28:41.245]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:41.245]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:41.245]             base::sink(type = "output", split = FALSE)
[08:28:41.245]             base::close(...future.stdout)
[08:28:41.245]         }, add = TRUE)
[08:28:41.245]     }
[08:28:41.245]     ...future.frame <- base::sys.nframe()
[08:28:41.245]     ...future.conditions <- base::list()
[08:28:41.245]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:41.245]     if (FALSE) {
[08:28:41.245]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:41.245]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:41.245]     }
[08:28:41.245]     ...future.result <- base::tryCatch({
[08:28:41.245]         base::withCallingHandlers({
[08:28:41.245]             ...future.value <- base::withVisible(base::local({
[08:28:41.245]                 ...future.makeSendCondition <- base::local({
[08:28:41.245]                   sendCondition <- NULL
[08:28:41.245]                   function(frame = 1L) {
[08:28:41.245]                     if (is.function(sendCondition)) 
[08:28:41.245]                       return(sendCondition)
[08:28:41.245]                     ns <- getNamespace("parallel")
[08:28:41.245]                     if (exists("sendData", mode = "function", 
[08:28:41.245]                       envir = ns)) {
[08:28:41.245]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:41.245]                         envir = ns)
[08:28:41.245]                       envir <- sys.frame(frame)
[08:28:41.245]                       master <- NULL
[08:28:41.245]                       while (!identical(envir, .GlobalEnv) && 
[08:28:41.245]                         !identical(envir, emptyenv())) {
[08:28:41.245]                         if (exists("master", mode = "list", envir = envir, 
[08:28:41.245]                           inherits = FALSE)) {
[08:28:41.245]                           master <- get("master", mode = "list", 
[08:28:41.245]                             envir = envir, inherits = FALSE)
[08:28:41.245]                           if (inherits(master, c("SOCKnode", 
[08:28:41.245]                             "SOCK0node"))) {
[08:28:41.245]                             sendCondition <<- function(cond) {
[08:28:41.245]                               data <- list(type = "VALUE", value = cond, 
[08:28:41.245]                                 success = TRUE)
[08:28:41.245]                               parallel_sendData(master, data)
[08:28:41.245]                             }
[08:28:41.245]                             return(sendCondition)
[08:28:41.245]                           }
[08:28:41.245]                         }
[08:28:41.245]                         frame <- frame + 1L
[08:28:41.245]                         envir <- sys.frame(frame)
[08:28:41.245]                       }
[08:28:41.245]                     }
[08:28:41.245]                     sendCondition <<- function(cond) NULL
[08:28:41.245]                   }
[08:28:41.245]                 })
[08:28:41.245]                 withCallingHandlers({
[08:28:41.245]                   NA
[08:28:41.245]                 }, immediateCondition = function(cond) {
[08:28:41.245]                   sendCondition <- ...future.makeSendCondition()
[08:28:41.245]                   sendCondition(cond)
[08:28:41.245]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:41.245]                   {
[08:28:41.245]                     inherits <- base::inherits
[08:28:41.245]                     invokeRestart <- base::invokeRestart
[08:28:41.245]                     is.null <- base::is.null
[08:28:41.245]                     muffled <- FALSE
[08:28:41.245]                     if (inherits(cond, "message")) {
[08:28:41.245]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:41.245]                       if (muffled) 
[08:28:41.245]                         invokeRestart("muffleMessage")
[08:28:41.245]                     }
[08:28:41.245]                     else if (inherits(cond, "warning")) {
[08:28:41.245]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:41.245]                       if (muffled) 
[08:28:41.245]                         invokeRestart("muffleWarning")
[08:28:41.245]                     }
[08:28:41.245]                     else if (inherits(cond, "condition")) {
[08:28:41.245]                       if (!is.null(pattern)) {
[08:28:41.245]                         computeRestarts <- base::computeRestarts
[08:28:41.245]                         grepl <- base::grepl
[08:28:41.245]                         restarts <- computeRestarts(cond)
[08:28:41.245]                         for (restart in restarts) {
[08:28:41.245]                           name <- restart$name
[08:28:41.245]                           if (is.null(name)) 
[08:28:41.245]                             next
[08:28:41.245]                           if (!grepl(pattern, name)) 
[08:28:41.245]                             next
[08:28:41.245]                           invokeRestart(restart)
[08:28:41.245]                           muffled <- TRUE
[08:28:41.245]                           break
[08:28:41.245]                         }
[08:28:41.245]                       }
[08:28:41.245]                     }
[08:28:41.245]                     invisible(muffled)
[08:28:41.245]                   }
[08:28:41.245]                   muffleCondition(cond)
[08:28:41.245]                 })
[08:28:41.245]             }))
[08:28:41.245]             future::FutureResult(value = ...future.value$value, 
[08:28:41.245]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:41.245]                   ...future.rng), globalenv = if (FALSE) 
[08:28:41.245]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:41.245]                     ...future.globalenv.names))
[08:28:41.245]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:41.245]         }, condition = base::local({
[08:28:41.245]             c <- base::c
[08:28:41.245]             inherits <- base::inherits
[08:28:41.245]             invokeRestart <- base::invokeRestart
[08:28:41.245]             length <- base::length
[08:28:41.245]             list <- base::list
[08:28:41.245]             seq.int <- base::seq.int
[08:28:41.245]             signalCondition <- base::signalCondition
[08:28:41.245]             sys.calls <- base::sys.calls
[08:28:41.245]             `[[` <- base::`[[`
[08:28:41.245]             `+` <- base::`+`
[08:28:41.245]             `<<-` <- base::`<<-`
[08:28:41.245]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:41.245]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:41.245]                   3L)]
[08:28:41.245]             }
[08:28:41.245]             function(cond) {
[08:28:41.245]                 is_error <- inherits(cond, "error")
[08:28:41.245]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:41.245]                   NULL)
[08:28:41.245]                 if (is_error) {
[08:28:41.245]                   sessionInformation <- function() {
[08:28:41.245]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:41.245]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:41.245]                       search = base::search(), system = base::Sys.info())
[08:28:41.245]                   }
[08:28:41.245]                   ...future.conditions[[length(...future.conditions) + 
[08:28:41.245]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:41.245]                     cond$call), session = sessionInformation(), 
[08:28:41.245]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:41.245]                   signalCondition(cond)
[08:28:41.245]                 }
[08:28:41.245]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:41.245]                 "immediateCondition"))) {
[08:28:41.245]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:41.245]                   ...future.conditions[[length(...future.conditions) + 
[08:28:41.245]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:41.245]                   if (TRUE && !signal) {
[08:28:41.245]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:41.245]                     {
[08:28:41.245]                       inherits <- base::inherits
[08:28:41.245]                       invokeRestart <- base::invokeRestart
[08:28:41.245]                       is.null <- base::is.null
[08:28:41.245]                       muffled <- FALSE
[08:28:41.245]                       if (inherits(cond, "message")) {
[08:28:41.245]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:41.245]                         if (muffled) 
[08:28:41.245]                           invokeRestart("muffleMessage")
[08:28:41.245]                       }
[08:28:41.245]                       else if (inherits(cond, "warning")) {
[08:28:41.245]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:41.245]                         if (muffled) 
[08:28:41.245]                           invokeRestart("muffleWarning")
[08:28:41.245]                       }
[08:28:41.245]                       else if (inherits(cond, "condition")) {
[08:28:41.245]                         if (!is.null(pattern)) {
[08:28:41.245]                           computeRestarts <- base::computeRestarts
[08:28:41.245]                           grepl <- base::grepl
[08:28:41.245]                           restarts <- computeRestarts(cond)
[08:28:41.245]                           for (restart in restarts) {
[08:28:41.245]                             name <- restart$name
[08:28:41.245]                             if (is.null(name)) 
[08:28:41.245]                               next
[08:28:41.245]                             if (!grepl(pattern, name)) 
[08:28:41.245]                               next
[08:28:41.245]                             invokeRestart(restart)
[08:28:41.245]                             muffled <- TRUE
[08:28:41.245]                             break
[08:28:41.245]                           }
[08:28:41.245]                         }
[08:28:41.245]                       }
[08:28:41.245]                       invisible(muffled)
[08:28:41.245]                     }
[08:28:41.245]                     muffleCondition(cond, pattern = "^muffle")
[08:28:41.245]                   }
[08:28:41.245]                 }
[08:28:41.245]                 else {
[08:28:41.245]                   if (TRUE) {
[08:28:41.245]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:41.245]                     {
[08:28:41.245]                       inherits <- base::inherits
[08:28:41.245]                       invokeRestart <- base::invokeRestart
[08:28:41.245]                       is.null <- base::is.null
[08:28:41.245]                       muffled <- FALSE
[08:28:41.245]                       if (inherits(cond, "message")) {
[08:28:41.245]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:41.245]                         if (muffled) 
[08:28:41.245]                           invokeRestart("muffleMessage")
[08:28:41.245]                       }
[08:28:41.245]                       else if (inherits(cond, "warning")) {
[08:28:41.245]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:41.245]                         if (muffled) 
[08:28:41.245]                           invokeRestart("muffleWarning")
[08:28:41.245]                       }
[08:28:41.245]                       else if (inherits(cond, "condition")) {
[08:28:41.245]                         if (!is.null(pattern)) {
[08:28:41.245]                           computeRestarts <- base::computeRestarts
[08:28:41.245]                           grepl <- base::grepl
[08:28:41.245]                           restarts <- computeRestarts(cond)
[08:28:41.245]                           for (restart in restarts) {
[08:28:41.245]                             name <- restart$name
[08:28:41.245]                             if (is.null(name)) 
[08:28:41.245]                               next
[08:28:41.245]                             if (!grepl(pattern, name)) 
[08:28:41.245]                               next
[08:28:41.245]                             invokeRestart(restart)
[08:28:41.245]                             muffled <- TRUE
[08:28:41.245]                             break
[08:28:41.245]                           }
[08:28:41.245]                         }
[08:28:41.245]                       }
[08:28:41.245]                       invisible(muffled)
[08:28:41.245]                     }
[08:28:41.245]                     muffleCondition(cond, pattern = "^muffle")
[08:28:41.245]                   }
[08:28:41.245]                 }
[08:28:41.245]             }
[08:28:41.245]         }))
[08:28:41.245]     }, error = function(ex) {
[08:28:41.245]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:41.245]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:41.245]                 ...future.rng), started = ...future.startTime, 
[08:28:41.245]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:41.245]             version = "1.8"), class = "FutureResult")
[08:28:41.245]     }, finally = {
[08:28:41.245]         if (!identical(...future.workdir, getwd())) 
[08:28:41.245]             setwd(...future.workdir)
[08:28:41.245]         {
[08:28:41.245]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:41.245]                 ...future.oldOptions$nwarnings <- NULL
[08:28:41.245]             }
[08:28:41.245]             base::options(...future.oldOptions)
[08:28:41.245]             if (.Platform$OS.type == "windows") {
[08:28:41.245]                 old_names <- names(...future.oldEnvVars)
[08:28:41.245]                 envs <- base::Sys.getenv()
[08:28:41.245]                 names <- names(envs)
[08:28:41.245]                 common <- intersect(names, old_names)
[08:28:41.245]                 added <- setdiff(names, old_names)
[08:28:41.245]                 removed <- setdiff(old_names, names)
[08:28:41.245]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:41.245]                   envs[common]]
[08:28:41.245]                 NAMES <- toupper(changed)
[08:28:41.245]                 args <- list()
[08:28:41.245]                 for (kk in seq_along(NAMES)) {
[08:28:41.245]                   name <- changed[[kk]]
[08:28:41.245]                   NAME <- NAMES[[kk]]
[08:28:41.245]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:41.245]                     next
[08:28:41.245]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:41.245]                 }
[08:28:41.245]                 NAMES <- toupper(added)
[08:28:41.245]                 for (kk in seq_along(NAMES)) {
[08:28:41.245]                   name <- added[[kk]]
[08:28:41.245]                   NAME <- NAMES[[kk]]
[08:28:41.245]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:41.245]                     next
[08:28:41.245]                   args[[name]] <- ""
[08:28:41.245]                 }
[08:28:41.245]                 NAMES <- toupper(removed)
[08:28:41.245]                 for (kk in seq_along(NAMES)) {
[08:28:41.245]                   name <- removed[[kk]]
[08:28:41.245]                   NAME <- NAMES[[kk]]
[08:28:41.245]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:41.245]                     next
[08:28:41.245]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:41.245]                 }
[08:28:41.245]                 if (length(args) > 0) 
[08:28:41.245]                   base::do.call(base::Sys.setenv, args = args)
[08:28:41.245]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:41.245]             }
[08:28:41.245]             else {
[08:28:41.245]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:41.245]             }
[08:28:41.245]             {
[08:28:41.245]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:41.245]                   0L) {
[08:28:41.245]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:41.245]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:41.245]                   base::options(opts)
[08:28:41.245]                 }
[08:28:41.245]                 {
[08:28:41.245]                   {
[08:28:41.245]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:41.245]                     NULL
[08:28:41.245]                   }
[08:28:41.245]                   options(future.plan = NULL)
[08:28:41.245]                   if (is.na(NA_character_)) 
[08:28:41.245]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:41.245]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:41.245]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:41.245]                     .init = FALSE)
[08:28:41.245]                 }
[08:28:41.245]             }
[08:28:41.245]         }
[08:28:41.245]     })
[08:28:41.245]     if (TRUE) {
[08:28:41.245]         base::sink(type = "output", split = FALSE)
[08:28:41.245]         if (TRUE) {
[08:28:41.245]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:41.245]         }
[08:28:41.245]         else {
[08:28:41.245]             ...future.result["stdout"] <- base::list(NULL)
[08:28:41.245]         }
[08:28:41.245]         base::close(...future.stdout)
[08:28:41.245]         ...future.stdout <- NULL
[08:28:41.245]     }
[08:28:41.245]     ...future.result$conditions <- ...future.conditions
[08:28:41.245]     ...future.result$finished <- base::Sys.time()
[08:28:41.245]     ...future.result
[08:28:41.245] }
[08:28:41.299] MultisessionFuture started
[08:28:41.299] result() for ClusterFuture ...
[08:28:41.300] receiveMessageFromWorker() for ClusterFuture ...
[08:28:41.300] - Validating connection of MultisessionFuture
[08:28:41.350] - received message: FutureResult
[08:28:41.351] - Received FutureResult
[08:28:41.351] - Erased future from FutureRegistry
[08:28:41.351] result() for ClusterFuture ...
[08:28:41.351] - result already collected: FutureResult
[08:28:41.351] result() for ClusterFuture ... done
[08:28:41.351] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:41.351] result() for ClusterFuture ... done
[08:28:41.351] result() for ClusterFuture ...
[08:28:41.351] - result already collected: FutureResult
[08:28:41.352] result() for ClusterFuture ... done
[08:28:41.352] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[08:28:41.353] plan(): nbrOfWorkers() = 2
[08:28:41.354] getGlobalsAndPackages() ...
[08:28:41.354] Searching for globals...
[08:28:41.369] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[08:28:41.369] Searching for globals ... DONE
[08:28:41.369] Resolving globals: FALSE
[08:28:41.370] The total size of the 2 globals is 11.25 KiB (11520 bytes)
[08:28:41.371] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 11.25 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (11.20 KiB of class ‘list’) and ‘strategy2’ (51 bytes of class ‘character’)
[08:28:41.371] - globals: [2] ‘nested’, ‘strategy2’
[08:28:41.371] - packages: [1] ‘future’
[08:28:41.371] getGlobalsAndPackages() ... DONE
[08:28:41.371] run() for ‘Future’ ...
[08:28:41.371] - state: ‘created’
[08:28:41.372] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:41.386] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:41.386] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:41.386]   - Field: ‘node’
[08:28:41.386]   - Field: ‘label’
[08:28:41.386]   - Field: ‘local’
[08:28:41.386]   - Field: ‘owner’
[08:28:41.386]   - Field: ‘envir’
[08:28:41.386]   - Field: ‘workers’
[08:28:41.386]   - Field: ‘packages’
[08:28:41.387]   - Field: ‘gc’
[08:28:41.387]   - Field: ‘conditions’
[08:28:41.387]   - Field: ‘persistent’
[08:28:41.387]   - Field: ‘expr’
[08:28:41.389]   - Field: ‘uuid’
[08:28:41.389]   - Field: ‘seed’
[08:28:41.389]   - Field: ‘version’
[08:28:41.389]   - Field: ‘result’
[08:28:41.389]   - Field: ‘asynchronous’
[08:28:41.389]   - Field: ‘calls’
[08:28:41.389]   - Field: ‘globals’
[08:28:41.390]   - Field: ‘stdout’
[08:28:41.390]   - Field: ‘earlySignal’
[08:28:41.390]   - Field: ‘lazy’
[08:28:41.390]   - Field: ‘state’
[08:28:41.390] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:41.390] - Launch lazy future ...
[08:28:41.390] Packages needed by the future expression (n = 1): ‘future’
[08:28:41.390] Packages needed by future strategies (n = 1): ‘future’
[08:28:41.391] {
[08:28:41.391]     {
[08:28:41.391]         {
[08:28:41.391]             ...future.startTime <- base::Sys.time()
[08:28:41.391]             {
[08:28:41.391]                 {
[08:28:41.391]                   {
[08:28:41.391]                     {
[08:28:41.391]                       {
[08:28:41.391]                         base::local({
[08:28:41.391]                           has_future <- base::requireNamespace("future", 
[08:28:41.391]                             quietly = TRUE)
[08:28:41.391]                           if (has_future) {
[08:28:41.391]                             ns <- base::getNamespace("future")
[08:28:41.391]                             version <- ns[[".package"]][["version"]]
[08:28:41.391]                             if (is.null(version)) 
[08:28:41.391]                               version <- utils::packageVersion("future")
[08:28:41.391]                           }
[08:28:41.391]                           else {
[08:28:41.391]                             version <- NULL
[08:28:41.391]                           }
[08:28:41.391]                           if (!has_future || version < "1.8.0") {
[08:28:41.391]                             info <- base::c(r_version = base::gsub("R version ", 
[08:28:41.391]                               "", base::R.version$version.string), 
[08:28:41.391]                               platform = base::sprintf("%s (%s-bit)", 
[08:28:41.391]                                 base::R.version$platform, 8 * 
[08:28:41.391]                                   base::.Machine$sizeof.pointer), 
[08:28:41.391]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:41.391]                                 "release", "version")], collapse = " "), 
[08:28:41.391]                               hostname = base::Sys.info()[["nodename"]])
[08:28:41.391]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:28:41.391]                               info)
[08:28:41.391]                             info <- base::paste(info, collapse = "; ")
[08:28:41.391]                             if (!has_future) {
[08:28:41.391]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:41.391]                                 info)
[08:28:41.391]                             }
[08:28:41.391]                             else {
[08:28:41.391]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:41.391]                                 info, version)
[08:28:41.391]                             }
[08:28:41.391]                             base::stop(msg)
[08:28:41.391]                           }
[08:28:41.391]                         })
[08:28:41.391]                       }
[08:28:41.391]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:41.391]                       base::options(mc.cores = 1L)
[08:28:41.391]                     }
[08:28:41.391]                     base::local({
[08:28:41.391]                       for (pkg in "future") {
[08:28:41.391]                         base::loadNamespace(pkg)
[08:28:41.391]                         base::library(pkg, character.only = TRUE)
[08:28:41.391]                       }
[08:28:41.391]                     })
[08:28:41.391]                   }
[08:28:41.391]                   ...future.strategy.old <- future::plan("list")
[08:28:41.391]                   options(future.plan = NULL)
[08:28:41.391]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:41.391]                   future::plan(list(b = function (..., workers = availableCores(), 
[08:28:41.391]                     lazy = FALSE, rscript_libs = .libPaths(), 
[08:28:41.391]                     envir = parent.frame()) 
[08:28:41.391]                   {
[08:28:41.391]                     if (is.function(workers)) 
[08:28:41.391]                       workers <- workers()
[08:28:41.391]                     workers <- structure(as.integer(workers), 
[08:28:41.391]                       class = class(workers))
[08:28:41.391]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[08:28:41.391]                       workers >= 1)
[08:28:41.391]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[08:28:41.391]                       return(sequential(..., lazy = TRUE, envir = envir))
[08:28:41.391]                     }
[08:28:41.391]                     future <- MultisessionFuture(..., workers = workers, 
[08:28:41.391]                       lazy = lazy, rscript_libs = rscript_libs, 
[08:28:41.391]                       envir = envir)
[08:28:41.391]                     if (!future$lazy) 
[08:28:41.391]                       future <- run(future)
[08:28:41.391]                     invisible(future)
[08:28:41.391]                   }), .cleanup = FALSE, .init = FALSE)
[08:28:41.391]                 }
[08:28:41.391]                 ...future.workdir <- getwd()
[08:28:41.391]             }
[08:28:41.391]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:41.391]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:41.391]         }
[08:28:41.391]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:41.391]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:41.391]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:41.391]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:41.391]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:41.391]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:41.391]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:41.391]             base::names(...future.oldOptions))
[08:28:41.391]     }
[08:28:41.391]     if (FALSE) {
[08:28:41.391]     }
[08:28:41.391]     else {
[08:28:41.391]         if (TRUE) {
[08:28:41.391]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:41.391]                 open = "w")
[08:28:41.391]         }
[08:28:41.391]         else {
[08:28:41.391]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:41.391]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:41.391]         }
[08:28:41.391]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:41.391]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:41.391]             base::sink(type = "output", split = FALSE)
[08:28:41.391]             base::close(...future.stdout)
[08:28:41.391]         }, add = TRUE)
[08:28:41.391]     }
[08:28:41.391]     ...future.frame <- base::sys.nframe()
[08:28:41.391]     ...future.conditions <- base::list()
[08:28:41.391]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:41.391]     if (FALSE) {
[08:28:41.391]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:41.391]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:41.391]     }
[08:28:41.391]     ...future.result <- base::tryCatch({
[08:28:41.391]         base::withCallingHandlers({
[08:28:41.391]             ...future.value <- base::withVisible(base::local({
[08:28:41.391]                 ...future.makeSendCondition <- base::local({
[08:28:41.391]                   sendCondition <- NULL
[08:28:41.391]                   function(frame = 1L) {
[08:28:41.391]                     if (is.function(sendCondition)) 
[08:28:41.391]                       return(sendCondition)
[08:28:41.391]                     ns <- getNamespace("parallel")
[08:28:41.391]                     if (exists("sendData", mode = "function", 
[08:28:41.391]                       envir = ns)) {
[08:28:41.391]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:41.391]                         envir = ns)
[08:28:41.391]                       envir <- sys.frame(frame)
[08:28:41.391]                       master <- NULL
[08:28:41.391]                       while (!identical(envir, .GlobalEnv) && 
[08:28:41.391]                         !identical(envir, emptyenv())) {
[08:28:41.391]                         if (exists("master", mode = "list", envir = envir, 
[08:28:41.391]                           inherits = FALSE)) {
[08:28:41.391]                           master <- get("master", mode = "list", 
[08:28:41.391]                             envir = envir, inherits = FALSE)
[08:28:41.391]                           if (inherits(master, c("SOCKnode", 
[08:28:41.391]                             "SOCK0node"))) {
[08:28:41.391]                             sendCondition <<- function(cond) {
[08:28:41.391]                               data <- list(type = "VALUE", value = cond, 
[08:28:41.391]                                 success = TRUE)
[08:28:41.391]                               parallel_sendData(master, data)
[08:28:41.391]                             }
[08:28:41.391]                             return(sendCondition)
[08:28:41.391]                           }
[08:28:41.391]                         }
[08:28:41.391]                         frame <- frame + 1L
[08:28:41.391]                         envir <- sys.frame(frame)
[08:28:41.391]                       }
[08:28:41.391]                     }
[08:28:41.391]                     sendCondition <<- function(cond) NULL
[08:28:41.391]                   }
[08:28:41.391]                 })
[08:28:41.391]                 withCallingHandlers({
[08:28:41.391]                   {
[08:28:41.391]                     a <- 1L
[08:28:41.391]                     plan_a <- unclass(future::plan("list"))
[08:28:41.391]                     nested_a <- nested[-1]
[08:28:41.391]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[08:28:41.391]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[08:28:41.391]                       strategy2))
[08:28:41.391]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[08:28:41.391]                       "init") <- NULL
[08:28:41.391]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[08:28:41.391]                       "init") <- NULL
[08:28:41.391]                     stopifnot(all.equal(plan_a, nested_a))
[08:28:41.391]                     y %<-% {
[08:28:41.391]                       b <- 2L
[08:28:41.391]                       plan_b <- future::plan("list")
[08:28:41.391]                       nested_b <- nested_a[-1]
[08:28:41.391]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[08:28:41.391]                         1L, inherits(plan_b[[1]], "future"), 
[08:28:41.391]                         inherits(future::plan("next"), "sequential"))
[08:28:41.391]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[08:28:41.391]                         b = b, nested_b = nested_b, plan_b = plan_b)
[08:28:41.391]                     }
[08:28:41.391]                     y
[08:28:41.391]                   }
[08:28:41.391]                 }, immediateCondition = function(cond) {
[08:28:41.391]                   sendCondition <- ...future.makeSendCondition()
[08:28:41.391]                   sendCondition(cond)
[08:28:41.391]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:41.391]                   {
[08:28:41.391]                     inherits <- base::inherits
[08:28:41.391]                     invokeRestart <- base::invokeRestart
[08:28:41.391]                     is.null <- base::is.null
[08:28:41.391]                     muffled <- FALSE
[08:28:41.391]                     if (inherits(cond, "message")) {
[08:28:41.391]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:41.391]                       if (muffled) 
[08:28:41.391]                         invokeRestart("muffleMessage")
[08:28:41.391]                     }
[08:28:41.391]                     else if (inherits(cond, "warning")) {
[08:28:41.391]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:41.391]                       if (muffled) 
[08:28:41.391]                         invokeRestart("muffleWarning")
[08:28:41.391]                     }
[08:28:41.391]                     else if (inherits(cond, "condition")) {
[08:28:41.391]                       if (!is.null(pattern)) {
[08:28:41.391]                         computeRestarts <- base::computeRestarts
[08:28:41.391]                         grepl <- base::grepl
[08:28:41.391]                         restarts <- computeRestarts(cond)
[08:28:41.391]                         for (restart in restarts) {
[08:28:41.391]                           name <- restart$name
[08:28:41.391]                           if (is.null(name)) 
[08:28:41.391]                             next
[08:28:41.391]                           if (!grepl(pattern, name)) 
[08:28:41.391]                             next
[08:28:41.391]                           invokeRestart(restart)
[08:28:41.391]                           muffled <- TRUE
[08:28:41.391]                           break
[08:28:41.391]                         }
[08:28:41.391]                       }
[08:28:41.391]                     }
[08:28:41.391]                     invisible(muffled)
[08:28:41.391]                   }
[08:28:41.391]                   muffleCondition(cond)
[08:28:41.391]                 })
[08:28:41.391]             }))
[08:28:41.391]             future::FutureResult(value = ...future.value$value, 
[08:28:41.391]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:41.391]                   ...future.rng), globalenv = if (FALSE) 
[08:28:41.391]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:41.391]                     ...future.globalenv.names))
[08:28:41.391]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:41.391]         }, condition = base::local({
[08:28:41.391]             c <- base::c
[08:28:41.391]             inherits <- base::inherits
[08:28:41.391]             invokeRestart <- base::invokeRestart
[08:28:41.391]             length <- base::length
[08:28:41.391]             list <- base::list
[08:28:41.391]             seq.int <- base::seq.int
[08:28:41.391]             signalCondition <- base::signalCondition
[08:28:41.391]             sys.calls <- base::sys.calls
[08:28:41.391]             `[[` <- base::`[[`
[08:28:41.391]             `+` <- base::`+`
[08:28:41.391]             `<<-` <- base::`<<-`
[08:28:41.391]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:41.391]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:41.391]                   3L)]
[08:28:41.391]             }
[08:28:41.391]             function(cond) {
[08:28:41.391]                 is_error <- inherits(cond, "error")
[08:28:41.391]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:41.391]                   NULL)
[08:28:41.391]                 if (is_error) {
[08:28:41.391]                   sessionInformation <- function() {
[08:28:41.391]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:41.391]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:41.391]                       search = base::search(), system = base::Sys.info())
[08:28:41.391]                   }
[08:28:41.391]                   ...future.conditions[[length(...future.conditions) + 
[08:28:41.391]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:41.391]                     cond$call), session = sessionInformation(), 
[08:28:41.391]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:41.391]                   signalCondition(cond)
[08:28:41.391]                 }
[08:28:41.391]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:41.391]                 "immediateCondition"))) {
[08:28:41.391]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:41.391]                   ...future.conditions[[length(...future.conditions) + 
[08:28:41.391]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:41.391]                   if (TRUE && !signal) {
[08:28:41.391]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:41.391]                     {
[08:28:41.391]                       inherits <- base::inherits
[08:28:41.391]                       invokeRestart <- base::invokeRestart
[08:28:41.391]                       is.null <- base::is.null
[08:28:41.391]                       muffled <- FALSE
[08:28:41.391]                       if (inherits(cond, "message")) {
[08:28:41.391]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:41.391]                         if (muffled) 
[08:28:41.391]                           invokeRestart("muffleMessage")
[08:28:41.391]                       }
[08:28:41.391]                       else if (inherits(cond, "warning")) {
[08:28:41.391]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:41.391]                         if (muffled) 
[08:28:41.391]                           invokeRestart("muffleWarning")
[08:28:41.391]                       }
[08:28:41.391]                       else if (inherits(cond, "condition")) {
[08:28:41.391]                         if (!is.null(pattern)) {
[08:28:41.391]                           computeRestarts <- base::computeRestarts
[08:28:41.391]                           grepl <- base::grepl
[08:28:41.391]                           restarts <- computeRestarts(cond)
[08:28:41.391]                           for (restart in restarts) {
[08:28:41.391]                             name <- restart$name
[08:28:41.391]                             if (is.null(name)) 
[08:28:41.391]                               next
[08:28:41.391]                             if (!grepl(pattern, name)) 
[08:28:41.391]                               next
[08:28:41.391]                             invokeRestart(restart)
[08:28:41.391]                             muffled <- TRUE
[08:28:41.391]                             break
[08:28:41.391]                           }
[08:28:41.391]                         }
[08:28:41.391]                       }
[08:28:41.391]                       invisible(muffled)
[08:28:41.391]                     }
[08:28:41.391]                     muffleCondition(cond, pattern = "^muffle")
[08:28:41.391]                   }
[08:28:41.391]                 }
[08:28:41.391]                 else {
[08:28:41.391]                   if (TRUE) {
[08:28:41.391]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:41.391]                     {
[08:28:41.391]                       inherits <- base::inherits
[08:28:41.391]                       invokeRestart <- base::invokeRestart
[08:28:41.391]                       is.null <- base::is.null
[08:28:41.391]                       muffled <- FALSE
[08:28:41.391]                       if (inherits(cond, "message")) {
[08:28:41.391]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:41.391]                         if (muffled) 
[08:28:41.391]                           invokeRestart("muffleMessage")
[08:28:41.391]                       }
[08:28:41.391]                       else if (inherits(cond, "warning")) {
[08:28:41.391]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:41.391]                         if (muffled) 
[08:28:41.391]                           invokeRestart("muffleWarning")
[08:28:41.391]                       }
[08:28:41.391]                       else if (inherits(cond, "condition")) {
[08:28:41.391]                         if (!is.null(pattern)) {
[08:28:41.391]                           computeRestarts <- base::computeRestarts
[08:28:41.391]                           grepl <- base::grepl
[08:28:41.391]                           restarts <- computeRestarts(cond)
[08:28:41.391]                           for (restart in restarts) {
[08:28:41.391]                             name <- restart$name
[08:28:41.391]                             if (is.null(name)) 
[08:28:41.391]                               next
[08:28:41.391]                             if (!grepl(pattern, name)) 
[08:28:41.391]                               next
[08:28:41.391]                             invokeRestart(restart)
[08:28:41.391]                             muffled <- TRUE
[08:28:41.391]                             break
[08:28:41.391]                           }
[08:28:41.391]                         }
[08:28:41.391]                       }
[08:28:41.391]                       invisible(muffled)
[08:28:41.391]                     }
[08:28:41.391]                     muffleCondition(cond, pattern = "^muffle")
[08:28:41.391]                   }
[08:28:41.391]                 }
[08:28:41.391]             }
[08:28:41.391]         }))
[08:28:41.391]     }, error = function(ex) {
[08:28:41.391]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:41.391]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:41.391]                 ...future.rng), started = ...future.startTime, 
[08:28:41.391]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:41.391]             version = "1.8"), class = "FutureResult")
[08:28:41.391]     }, finally = {
[08:28:41.391]         if (!identical(...future.workdir, getwd())) 
[08:28:41.391]             setwd(...future.workdir)
[08:28:41.391]         {
[08:28:41.391]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:41.391]                 ...future.oldOptions$nwarnings <- NULL
[08:28:41.391]             }
[08:28:41.391]             base::options(...future.oldOptions)
[08:28:41.391]             if (.Platform$OS.type == "windows") {
[08:28:41.391]                 old_names <- names(...future.oldEnvVars)
[08:28:41.391]                 envs <- base::Sys.getenv()
[08:28:41.391]                 names <- names(envs)
[08:28:41.391]                 common <- intersect(names, old_names)
[08:28:41.391]                 added <- setdiff(names, old_names)
[08:28:41.391]                 removed <- setdiff(old_names, names)
[08:28:41.391]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:41.391]                   envs[common]]
[08:28:41.391]                 NAMES <- toupper(changed)
[08:28:41.391]                 args <- list()
[08:28:41.391]                 for (kk in seq_along(NAMES)) {
[08:28:41.391]                   name <- changed[[kk]]
[08:28:41.391]                   NAME <- NAMES[[kk]]
[08:28:41.391]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:41.391]                     next
[08:28:41.391]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:41.391]                 }
[08:28:41.391]                 NAMES <- toupper(added)
[08:28:41.391]                 for (kk in seq_along(NAMES)) {
[08:28:41.391]                   name <- added[[kk]]
[08:28:41.391]                   NAME <- NAMES[[kk]]
[08:28:41.391]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:41.391]                     next
[08:28:41.391]                   args[[name]] <- ""
[08:28:41.391]                 }
[08:28:41.391]                 NAMES <- toupper(removed)
[08:28:41.391]                 for (kk in seq_along(NAMES)) {
[08:28:41.391]                   name <- removed[[kk]]
[08:28:41.391]                   NAME <- NAMES[[kk]]
[08:28:41.391]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:41.391]                     next
[08:28:41.391]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:41.391]                 }
[08:28:41.391]                 if (length(args) > 0) 
[08:28:41.391]                   base::do.call(base::Sys.setenv, args = args)
[08:28:41.391]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:41.391]             }
[08:28:41.391]             else {
[08:28:41.391]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:41.391]             }
[08:28:41.391]             {
[08:28:41.391]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:41.391]                   0L) {
[08:28:41.391]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:41.391]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:41.391]                   base::options(opts)
[08:28:41.391]                 }
[08:28:41.391]                 {
[08:28:41.391]                   {
[08:28:41.391]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:41.391]                     NULL
[08:28:41.391]                   }
[08:28:41.391]                   options(future.plan = NULL)
[08:28:41.391]                   if (is.na(NA_character_)) 
[08:28:41.391]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:41.391]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:41.391]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:41.391]                     .init = FALSE)
[08:28:41.391]                 }
[08:28:41.391]             }
[08:28:41.391]         }
[08:28:41.391]     })
[08:28:41.391]     if (TRUE) {
[08:28:41.391]         base::sink(type = "output", split = FALSE)
[08:28:41.391]         if (TRUE) {
[08:28:41.391]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:41.391]         }
[08:28:41.391]         else {
[08:28:41.391]             ...future.result["stdout"] <- base::list(NULL)
[08:28:41.391]         }
[08:28:41.391]         base::close(...future.stdout)
[08:28:41.391]         ...future.stdout <- NULL
[08:28:41.391]     }
[08:28:41.391]     ...future.result$conditions <- ...future.conditions
[08:28:41.391]     ...future.result$finished <- base::Sys.time()
[08:28:41.391]     ...future.result
[08:28:41.391] }
[08:28:41.394] Exporting 2 global objects (11.55 KiB) to cluster node #1 ...
[08:28:41.394] Exporting ‘nested’ (11.20 KiB) to cluster node #1 ...
[08:28:41.436] Exporting ‘nested’ (11.20 KiB) to cluster node #1 ... DONE
[08:28:41.436] Exporting ‘strategy2’ (51 bytes) to cluster node #1 ...
[08:28:41.436] Exporting ‘strategy2’ (51 bytes) to cluster node #1 ... DONE
[08:28:41.436] Exporting 2 global objects (11.55 KiB) to cluster node #1 ... DONE
[08:28:41.437] MultisessionFuture started
[08:28:41.437] - Launch lazy future ... done
[08:28:41.437] run() for ‘MultisessionFuture’ ... done
[08:28:41.438] result() for ClusterFuture ...
[08:28:41.438] receiveMessageFromWorker() for ClusterFuture ...
[08:28:41.438] - Validating connection of MultisessionFuture
[08:28:41.501] - received message: FutureResult
[08:28:41.501] - Received FutureResult
[08:28:41.501] - Erased future from FutureRegistry
[08:28:41.501] result() for ClusterFuture ...
[08:28:41.502] - result already collected: FutureResult
[08:28:41.502] result() for ClusterFuture ... done
[08:28:41.502] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:41.502] result() for ClusterFuture ... done
[08:28:41.502] result() for ClusterFuture ...
[08:28:41.502] - result already collected: FutureResult
[08:28:41.502] result() for ClusterFuture ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "cleanup")=function ()  
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "cleanup")=function ()  
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[08:28:41.508] getGlobalsAndPackages() ...
[08:28:41.508] Searching for globals...
[08:28:41.509] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[08:28:41.509] Searching for globals ... DONE
[08:28:41.509] Resolving globals: FALSE
[08:28:41.510] The total size of the 1 globals is 356 bytes (356 bytes)
[08:28:41.510] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[08:28:41.510] - globals: [1] ‘data’
[08:28:41.511] - packages: [1] ‘future’
[08:28:41.511] getGlobalsAndPackages() ... DONE
[08:28:41.511] run() for ‘Future’ ...
[08:28:41.511] - state: ‘created’
[08:28:41.511] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:41.525] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:41.526] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:41.526]   - Field: ‘node’
[08:28:41.526]   - Field: ‘label’
[08:28:41.526]   - Field: ‘local’
[08:28:41.526]   - Field: ‘owner’
[08:28:41.526]   - Field: ‘envir’
[08:28:41.526]   - Field: ‘workers’
[08:28:41.526]   - Field: ‘packages’
[08:28:41.527]   - Field: ‘gc’
[08:28:41.527]   - Field: ‘conditions’
[08:28:41.527]   - Field: ‘persistent’
[08:28:41.527]   - Field: ‘expr’
[08:28:41.527]   - Field: ‘uuid’
[08:28:41.527]   - Field: ‘seed’
[08:28:41.527]   - Field: ‘version’
[08:28:41.527]   - Field: ‘result’
[08:28:41.527]   - Field: ‘asynchronous’
[08:28:41.527]   - Field: ‘calls’
[08:28:41.527]   - Field: ‘globals’
[08:28:41.528]   - Field: ‘stdout’
[08:28:41.528]   - Field: ‘earlySignal’
[08:28:41.528]   - Field: ‘lazy’
[08:28:41.528]   - Field: ‘state’
[08:28:41.528] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:41.528] - Launch lazy future ...
[08:28:41.528] Packages needed by the future expression (n = 1): ‘future’
[08:28:41.528] Packages needed by future strategies (n = 1): ‘future’
[08:28:41.529] {
[08:28:41.529]     {
[08:28:41.529]         {
[08:28:41.529]             ...future.startTime <- base::Sys.time()
[08:28:41.529]             {
[08:28:41.529]                 {
[08:28:41.529]                   {
[08:28:41.529]                     {
[08:28:41.529]                       {
[08:28:41.529]                         base::local({
[08:28:41.529]                           has_future <- base::requireNamespace("future", 
[08:28:41.529]                             quietly = TRUE)
[08:28:41.529]                           if (has_future) {
[08:28:41.529]                             ns <- base::getNamespace("future")
[08:28:41.529]                             version <- ns[[".package"]][["version"]]
[08:28:41.529]                             if (is.null(version)) 
[08:28:41.529]                               version <- utils::packageVersion("future")
[08:28:41.529]                           }
[08:28:41.529]                           else {
[08:28:41.529]                             version <- NULL
[08:28:41.529]                           }
[08:28:41.529]                           if (!has_future || version < "1.8.0") {
[08:28:41.529]                             info <- base::c(r_version = base::gsub("R version ", 
[08:28:41.529]                               "", base::R.version$version.string), 
[08:28:41.529]                               platform = base::sprintf("%s (%s-bit)", 
[08:28:41.529]                                 base::R.version$platform, 8 * 
[08:28:41.529]                                   base::.Machine$sizeof.pointer), 
[08:28:41.529]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:41.529]                                 "release", "version")], collapse = " "), 
[08:28:41.529]                               hostname = base::Sys.info()[["nodename"]])
[08:28:41.529]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:28:41.529]                               info)
[08:28:41.529]                             info <- base::paste(info, collapse = "; ")
[08:28:41.529]                             if (!has_future) {
[08:28:41.529]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:41.529]                                 info)
[08:28:41.529]                             }
[08:28:41.529]                             else {
[08:28:41.529]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:41.529]                                 info, version)
[08:28:41.529]                             }
[08:28:41.529]                             base::stop(msg)
[08:28:41.529]                           }
[08:28:41.529]                         })
[08:28:41.529]                       }
[08:28:41.529]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:41.529]                       base::options(mc.cores = 1L)
[08:28:41.529]                     }
[08:28:41.529]                     base::local({
[08:28:41.529]                       for (pkg in "future") {
[08:28:41.529]                         base::loadNamespace(pkg)
[08:28:41.529]                         base::library(pkg, character.only = TRUE)
[08:28:41.529]                       }
[08:28:41.529]                     })
[08:28:41.529]                   }
[08:28:41.529]                   ...future.strategy.old <- future::plan("list")
[08:28:41.529]                   options(future.plan = NULL)
[08:28:41.529]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:41.529]                   future::plan(list(b = function (..., workers = availableCores(), 
[08:28:41.529]                     lazy = FALSE, rscript_libs = .libPaths(), 
[08:28:41.529]                     envir = parent.frame()) 
[08:28:41.529]                   {
[08:28:41.529]                     if (is.function(workers)) 
[08:28:41.529]                       workers <- workers()
[08:28:41.529]                     workers <- structure(as.integer(workers), 
[08:28:41.529]                       class = class(workers))
[08:28:41.529]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[08:28:41.529]                       workers >= 1)
[08:28:41.529]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[08:28:41.529]                       return(sequential(..., lazy = TRUE, envir = envir))
[08:28:41.529]                     }
[08:28:41.529]                     future <- MultisessionFuture(..., workers = workers, 
[08:28:41.529]                       lazy = lazy, rscript_libs = rscript_libs, 
[08:28:41.529]                       envir = envir)
[08:28:41.529]                     if (!future$lazy) 
[08:28:41.529]                       future <- run(future)
[08:28:41.529]                     invisible(future)
[08:28:41.529]                   }), .cleanup = FALSE, .init = FALSE)
[08:28:41.529]                 }
[08:28:41.529]                 ...future.workdir <- getwd()
[08:28:41.529]             }
[08:28:41.529]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:41.529]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:41.529]         }
[08:28:41.529]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:28:41.529]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:28:41.529]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:28:41.529]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:28:41.529]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:41.529]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:41.529]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:41.529]             base::names(...future.oldOptions))
[08:28:41.529]     }
[08:28:41.529]     if (FALSE) {
[08:28:41.529]     }
[08:28:41.529]     else {
[08:28:41.529]         if (TRUE) {
[08:28:41.529]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:41.529]                 open = "w")
[08:28:41.529]         }
[08:28:41.529]         else {
[08:28:41.529]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:41.529]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:41.529]         }
[08:28:41.529]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:41.529]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:41.529]             base::sink(type = "output", split = FALSE)
[08:28:41.529]             base::close(...future.stdout)
[08:28:41.529]         }, add = TRUE)
[08:28:41.529]     }
[08:28:41.529]     ...future.frame <- base::sys.nframe()
[08:28:41.529]     ...future.conditions <- base::list()
[08:28:41.529]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:41.529]     if (FALSE) {
[08:28:41.529]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:41.529]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:41.529]     }
[08:28:41.529]     ...future.result <- base::tryCatch({
[08:28:41.529]         base::withCallingHandlers({
[08:28:41.529]             ...future.value <- base::withVisible(base::local({
[08:28:41.529]                 ...future.makeSendCondition <- base::local({
[08:28:41.529]                   sendCondition <- NULL
[08:28:41.529]                   function(frame = 1L) {
[08:28:41.529]                     if (is.function(sendCondition)) 
[08:28:41.529]                       return(sendCondition)
[08:28:41.529]                     ns <- getNamespace("parallel")
[08:28:41.529]                     if (exists("sendData", mode = "function", 
[08:28:41.529]                       envir = ns)) {
[08:28:41.529]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:41.529]                         envir = ns)
[08:28:41.529]                       envir <- sys.frame(frame)
[08:28:41.529]                       master <- NULL
[08:28:41.529]                       while (!identical(envir, .GlobalEnv) && 
[08:28:41.529]                         !identical(envir, emptyenv())) {
[08:28:41.529]                         if (exists("master", mode = "list", envir = envir, 
[08:28:41.529]                           inherits = FALSE)) {
[08:28:41.529]                           master <- get("master", mode = "list", 
[08:28:41.529]                             envir = envir, inherits = FALSE)
[08:28:41.529]                           if (inherits(master, c("SOCKnode", 
[08:28:41.529]                             "SOCK0node"))) {
[08:28:41.529]                             sendCondition <<- function(cond) {
[08:28:41.529]                               data <- list(type = "VALUE", value = cond, 
[08:28:41.529]                                 success = TRUE)
[08:28:41.529]                               parallel_sendData(master, data)
[08:28:41.529]                             }
[08:28:41.529]                             return(sendCondition)
[08:28:41.529]                           }
[08:28:41.529]                         }
[08:28:41.529]                         frame <- frame + 1L
[08:28:41.529]                         envir <- sys.frame(frame)
[08:28:41.529]                       }
[08:28:41.529]                     }
[08:28:41.529]                     sendCondition <<- function(cond) NULL
[08:28:41.529]                   }
[08:28:41.529]                 })
[08:28:41.529]                 withCallingHandlers({
[08:28:41.529]                   {
[08:28:41.529]                     value(future(subset(data, a == 2)))
[08:28:41.529]                   }
[08:28:41.529]                 }, immediateCondition = function(cond) {
[08:28:41.529]                   sendCondition <- ...future.makeSendCondition()
[08:28:41.529]                   sendCondition(cond)
[08:28:41.529]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:41.529]                   {
[08:28:41.529]                     inherits <- base::inherits
[08:28:41.529]                     invokeRestart <- base::invokeRestart
[08:28:41.529]                     is.null <- base::is.null
[08:28:41.529]                     muffled <- FALSE
[08:28:41.529]                     if (inherits(cond, "message")) {
[08:28:41.529]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:41.529]                       if (muffled) 
[08:28:41.529]                         invokeRestart("muffleMessage")
[08:28:41.529]                     }
[08:28:41.529]                     else if (inherits(cond, "warning")) {
[08:28:41.529]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:41.529]                       if (muffled) 
[08:28:41.529]                         invokeRestart("muffleWarning")
[08:28:41.529]                     }
[08:28:41.529]                     else if (inherits(cond, "condition")) {
[08:28:41.529]                       if (!is.null(pattern)) {
[08:28:41.529]                         computeRestarts <- base::computeRestarts
[08:28:41.529]                         grepl <- base::grepl
[08:28:41.529]                         restarts <- computeRestarts(cond)
[08:28:41.529]                         for (restart in restarts) {
[08:28:41.529]                           name <- restart$name
[08:28:41.529]                           if (is.null(name)) 
[08:28:41.529]                             next
[08:28:41.529]                           if (!grepl(pattern, name)) 
[08:28:41.529]                             next
[08:28:41.529]                           invokeRestart(restart)
[08:28:41.529]                           muffled <- TRUE
[08:28:41.529]                           break
[08:28:41.529]                         }
[08:28:41.529]                       }
[08:28:41.529]                     }
[08:28:41.529]                     invisible(muffled)
[08:28:41.529]                   }
[08:28:41.529]                   muffleCondition(cond)
[08:28:41.529]                 })
[08:28:41.529]             }))
[08:28:41.529]             future::FutureResult(value = ...future.value$value, 
[08:28:41.529]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:41.529]                   ...future.rng), globalenv = if (FALSE) 
[08:28:41.529]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:41.529]                     ...future.globalenv.names))
[08:28:41.529]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:41.529]         }, condition = base::local({
[08:28:41.529]             c <- base::c
[08:28:41.529]             inherits <- base::inherits
[08:28:41.529]             invokeRestart <- base::invokeRestart
[08:28:41.529]             length <- base::length
[08:28:41.529]             list <- base::list
[08:28:41.529]             seq.int <- base::seq.int
[08:28:41.529]             signalCondition <- base::signalCondition
[08:28:41.529]             sys.calls <- base::sys.calls
[08:28:41.529]             `[[` <- base::`[[`
[08:28:41.529]             `+` <- base::`+`
[08:28:41.529]             `<<-` <- base::`<<-`
[08:28:41.529]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:41.529]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:41.529]                   3L)]
[08:28:41.529]             }
[08:28:41.529]             function(cond) {
[08:28:41.529]                 is_error <- inherits(cond, "error")
[08:28:41.529]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:41.529]                   NULL)
[08:28:41.529]                 if (is_error) {
[08:28:41.529]                   sessionInformation <- function() {
[08:28:41.529]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:41.529]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:41.529]                       search = base::search(), system = base::Sys.info())
[08:28:41.529]                   }
[08:28:41.529]                   ...future.conditions[[length(...future.conditions) + 
[08:28:41.529]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:41.529]                     cond$call), session = sessionInformation(), 
[08:28:41.529]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:41.529]                   signalCondition(cond)
[08:28:41.529]                 }
[08:28:41.529]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:41.529]                 "immediateCondition"))) {
[08:28:41.529]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:41.529]                   ...future.conditions[[length(...future.conditions) + 
[08:28:41.529]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:41.529]                   if (TRUE && !signal) {
[08:28:41.529]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:41.529]                     {
[08:28:41.529]                       inherits <- base::inherits
[08:28:41.529]                       invokeRestart <- base::invokeRestart
[08:28:41.529]                       is.null <- base::is.null
[08:28:41.529]                       muffled <- FALSE
[08:28:41.529]                       if (inherits(cond, "message")) {
[08:28:41.529]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:41.529]                         if (muffled) 
[08:28:41.529]                           invokeRestart("muffleMessage")
[08:28:41.529]                       }
[08:28:41.529]                       else if (inherits(cond, "warning")) {
[08:28:41.529]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:41.529]                         if (muffled) 
[08:28:41.529]                           invokeRestart("muffleWarning")
[08:28:41.529]                       }
[08:28:41.529]                       else if (inherits(cond, "condition")) {
[08:28:41.529]                         if (!is.null(pattern)) {
[08:28:41.529]                           computeRestarts <- base::computeRestarts
[08:28:41.529]                           grepl <- base::grepl
[08:28:41.529]                           restarts <- computeRestarts(cond)
[08:28:41.529]                           for (restart in restarts) {
[08:28:41.529]                             name <- restart$name
[08:28:41.529]                             if (is.null(name)) 
[08:28:41.529]                               next
[08:28:41.529]                             if (!grepl(pattern, name)) 
[08:28:41.529]                               next
[08:28:41.529]                             invokeRestart(restart)
[08:28:41.529]                             muffled <- TRUE
[08:28:41.529]                             break
[08:28:41.529]                           }
[08:28:41.529]                         }
[08:28:41.529]                       }
[08:28:41.529]                       invisible(muffled)
[08:28:41.529]                     }
[08:28:41.529]                     muffleCondition(cond, pattern = "^muffle")
[08:28:41.529]                   }
[08:28:41.529]                 }
[08:28:41.529]                 else {
[08:28:41.529]                   if (TRUE) {
[08:28:41.529]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:41.529]                     {
[08:28:41.529]                       inherits <- base::inherits
[08:28:41.529]                       invokeRestart <- base::invokeRestart
[08:28:41.529]                       is.null <- base::is.null
[08:28:41.529]                       muffled <- FALSE
[08:28:41.529]                       if (inherits(cond, "message")) {
[08:28:41.529]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:41.529]                         if (muffled) 
[08:28:41.529]                           invokeRestart("muffleMessage")
[08:28:41.529]                       }
[08:28:41.529]                       else if (inherits(cond, "warning")) {
[08:28:41.529]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:41.529]                         if (muffled) 
[08:28:41.529]                           invokeRestart("muffleWarning")
[08:28:41.529]                       }
[08:28:41.529]                       else if (inherits(cond, "condition")) {
[08:28:41.529]                         if (!is.null(pattern)) {
[08:28:41.529]                           computeRestarts <- base::computeRestarts
[08:28:41.529]                           grepl <- base::grepl
[08:28:41.529]                           restarts <- computeRestarts(cond)
[08:28:41.529]                           for (restart in restarts) {
[08:28:41.529]                             name <- restart$name
[08:28:41.529]                             if (is.null(name)) 
[08:28:41.529]                               next
[08:28:41.529]                             if (!grepl(pattern, name)) 
[08:28:41.529]                               next
[08:28:41.529]                             invokeRestart(restart)
[08:28:41.529]                             muffled <- TRUE
[08:28:41.529]                             break
[08:28:41.529]                           }
[08:28:41.529]                         }
[08:28:41.529]                       }
[08:28:41.529]                       invisible(muffled)
[08:28:41.529]                     }
[08:28:41.529]                     muffleCondition(cond, pattern = "^muffle")
[08:28:41.529]                   }
[08:28:41.529]                 }
[08:28:41.529]             }
[08:28:41.529]         }))
[08:28:41.529]     }, error = function(ex) {
[08:28:41.529]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:41.529]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:41.529]                 ...future.rng), started = ...future.startTime, 
[08:28:41.529]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:41.529]             version = "1.8"), class = "FutureResult")
[08:28:41.529]     }, finally = {
[08:28:41.529]         if (!identical(...future.workdir, getwd())) 
[08:28:41.529]             setwd(...future.workdir)
[08:28:41.529]         {
[08:28:41.529]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:41.529]                 ...future.oldOptions$nwarnings <- NULL
[08:28:41.529]             }
[08:28:41.529]             base::options(...future.oldOptions)
[08:28:41.529]             if (.Platform$OS.type == "windows") {
[08:28:41.529]                 old_names <- names(...future.oldEnvVars)
[08:28:41.529]                 envs <- base::Sys.getenv()
[08:28:41.529]                 names <- names(envs)
[08:28:41.529]                 common <- intersect(names, old_names)
[08:28:41.529]                 added <- setdiff(names, old_names)
[08:28:41.529]                 removed <- setdiff(old_names, names)
[08:28:41.529]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:41.529]                   envs[common]]
[08:28:41.529]                 NAMES <- toupper(changed)
[08:28:41.529]                 args <- list()
[08:28:41.529]                 for (kk in seq_along(NAMES)) {
[08:28:41.529]                   name <- changed[[kk]]
[08:28:41.529]                   NAME <- NAMES[[kk]]
[08:28:41.529]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:41.529]                     next
[08:28:41.529]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:41.529]                 }
[08:28:41.529]                 NAMES <- toupper(added)
[08:28:41.529]                 for (kk in seq_along(NAMES)) {
[08:28:41.529]                   name <- added[[kk]]
[08:28:41.529]                   NAME <- NAMES[[kk]]
[08:28:41.529]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:41.529]                     next
[08:28:41.529]                   args[[name]] <- ""
[08:28:41.529]                 }
[08:28:41.529]                 NAMES <- toupper(removed)
[08:28:41.529]                 for (kk in seq_along(NAMES)) {
[08:28:41.529]                   name <- removed[[kk]]
[08:28:41.529]                   NAME <- NAMES[[kk]]
[08:28:41.529]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:41.529]                     next
[08:28:41.529]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:41.529]                 }
[08:28:41.529]                 if (length(args) > 0) 
[08:28:41.529]                   base::do.call(base::Sys.setenv, args = args)
[08:28:41.529]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:41.529]             }
[08:28:41.529]             else {
[08:28:41.529]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:41.529]             }
[08:28:41.529]             {
[08:28:41.529]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:41.529]                   0L) {
[08:28:41.529]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:41.529]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:41.529]                   base::options(opts)
[08:28:41.529]                 }
[08:28:41.529]                 {
[08:28:41.529]                   {
[08:28:41.529]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:41.529]                     NULL
[08:28:41.529]                   }
[08:28:41.529]                   options(future.plan = NULL)
[08:28:41.529]                   if (is.na(NA_character_)) 
[08:28:41.529]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:41.529]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:41.529]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:41.529]                     .init = FALSE)
[08:28:41.529]                 }
[08:28:41.529]             }
[08:28:41.529]         }
[08:28:41.529]     })
[08:28:41.529]     if (TRUE) {
[08:28:41.529]         base::sink(type = "output", split = FALSE)
[08:28:41.529]         if (TRUE) {
[08:28:41.529]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:41.529]         }
[08:28:41.529]         else {
[08:28:41.529]             ...future.result["stdout"] <- base::list(NULL)
[08:28:41.529]         }
[08:28:41.529]         base::close(...future.stdout)
[08:28:41.529]         ...future.stdout <- NULL
[08:28:41.529]     }
[08:28:41.529]     ...future.result$conditions <- ...future.conditions
[08:28:41.529]     ...future.result$finished <- base::Sys.time()
[08:28:41.529]     ...future.result
[08:28:41.529] }
[08:28:41.532] Exporting 1 global objects (643 bytes) to cluster node #1 ...
[08:28:41.532] Exporting ‘data’ (356 bytes) to cluster node #1 ...
[08:28:41.533] Exporting ‘data’ (356 bytes) to cluster node #1 ... DONE
[08:28:41.533] Exporting 1 global objects (643 bytes) to cluster node #1 ... DONE
[08:28:41.533] MultisessionFuture started
[08:28:41.533] - Launch lazy future ... done
[08:28:41.534] run() for ‘MultisessionFuture’ ... done
[08:28:41.534] result() for ClusterFuture ...
[08:28:41.534] receiveMessageFromWorker() for ClusterFuture ...
[08:28:41.534] - Validating connection of MultisessionFuture
[08:28:41.583] - received message: FutureResult
[08:28:41.583] - Received FutureResult
[08:28:41.583] - Erased future from FutureRegistry
[08:28:41.583] result() for ClusterFuture ...
[08:28:41.584] - result already collected: FutureResult
[08:28:41.584] result() for ClusterFuture ... done
[08:28:41.584] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:41.584] result() for ClusterFuture ... done
[08:28:41.584] result() for ClusterFuture ...
[08:28:41.584] - result already collected: FutureResult
[08:28:41.584] result() for ClusterFuture ... done
- plan(list('multisession', 'multisession')) ... DONE
> 
> message("*** Nested futures ... DONE")
*** Nested futures ... DONE
> 
> source("incl/end.R")
[08:28:41.585] plan(): Setting new future strategy stack:
[08:28:41.585] List of future strategies:
[08:28:41.585] 1. FutureStrategy:
[08:28:41.585]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:41.585]    - tweaked: FALSE
[08:28:41.585]    - call: future::plan(oplan)
[08:28:41.586] plan(): nbrOfWorkers() = 1
> 
