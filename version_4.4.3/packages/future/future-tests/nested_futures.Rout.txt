
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[11:02:15.189] plan(): Setting new future strategy stack:
[11:02:15.189] List of future strategies:
[11:02:15.189] 1. sequential:
[11:02:15.189]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:15.189]    - tweaked: FALSE
[11:02:15.189]    - call: future::plan("sequential")
[11:02:15.203] plan(): nbrOfWorkers() = 1
> 
> strategies <- supportedStrategies()
> 
> message("*** Nested futures ...")
*** Nested futures ...
> 
> for (strategy1 in strategies) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   for (strategy2 in strategies) {
+     message(sprintf("- plan(list('%s', '%s')) ...", strategy1, strategy2))
+     plan(list(a = strategy1, b = strategy2))
+     
+     nested <- plan("list")
+     stopifnot(
+       length(nested) == 2L,
+       all(names(nested) == c("a", "b")),
+       inherits(plan("next"), strategy1)
+     )
+ 
+     x %<-% {
+       a <- 1L
+ 
+       ## IMPORTANT: Use future::plan() - not just plan() - otherwise
+       ## we're exporting the plan() function including its local stack!
+       plan_a <- unclass(future::plan("list"))
+       nested_a <- nested[-1]
+ 
+       stopifnot(
+         length(nested_a) == 1L,
+         length(plan_a) == 1L,
+         inherits(plan_a[[1]], "future"),
+         inherits(future::plan("next"), strategy2)
+       )
+ 
+       ## Attribute 'init' is modified at run time
+       for (kk in seq_along(plan_a)) attr(plan_a[[kk]], "init") <- NULL
+       for (kk in seq_along(nested_a)) attr(nested_a[[kk]], "init") <- NULL
+       stopifnot(all.equal(plan_a, nested_a))
+ 
+       y %<-% {
+         b <- 2L
+         
+         ## IMPORTANT: Use future::plan() - not just plan() - otherwise
+         ## we're exporting the plan() function including its local stack!
+         plan_b <- future::plan("list")
+         nested_b <- nested_a[-1]
+ 
+         stopifnot(
+           length(nested_b) == 0L,
+           length(plan_b) == 1L,
+           inherits(plan_b[[1]], "future"),
+           inherits(future::plan("next"), "sequential")
+         )
+ 
+         list(a = a, nested_a = nested_a, plan_a = plan_a,
+              b = b, nested_b = nested_b, plan_b = plan_b)
+       }
+       y
+     }
+ 
+     str(x)
+ 
+     stopifnot(
+       length(x) == 3 * length(nested),
+       all(names(x) == c("a", "nested_a", "plan_a",
+                         "b", "nested_b", "plan_b")),
+ 
+       x$a == 1L,
+       length(x$nested_a) == 1L,
+       is.list(x$plan_a),
+       length(x$plan_a) == 1L,
+       inherits(x$plan_a[[1]], "future"),
+ 
+       x$b == 2L,
+       length(x$nested_b) == 0L,
+       is.list(x$plan_b),
+       length(x$plan_b) == 1L,
+       inherits(x$plan_b[[1]], "future"),
+       inherits(x$plan_b[[1]], "sequential")
+     )
+ 
+     ## Attribute 'init' is modified at run time
+     for (kk in seq_along(x$plan_a)) attr(x$plan_a[[kk]], "init") <- NULL
+     for (kk in seq_along(nested)) attr(nested[[kk]], "init") <- NULL
+     stopifnot(all.equal(x$plan_a, nested[-1L]))
+ 
+     rm(list = c("nested", "x"))
+ 
+ 
+     ## Nested futures and globals
+     ## In future (<= 1.7.0), the below would produce an error saying
+     ## "Failed to locate global object in the relevant environments: 'a'"
+     ## Related to https://github.com/HenrikBengtsson/globals/issues/35
+     data <- data.frame(a = 1:3, b = 3:1)
+     y_truth <- subset(data, a == 2)
+     f <- future({
+       value(future( subset(data, a == 2) ))
+     })
+     y <- value(f)
+     stopifnot(identical(y, y_truth))
+     
+     message(sprintf("- plan(list('%s', '%s')) ... DONE", strategy1, strategy2))
+   }
+ }
- plan(list('sequential', 'sequential')) ...
[11:02:15.258] plan(): Setting new future strategy stack:
[11:02:15.258] List of future strategies:
[11:02:15.258] 1. sequential:
[11:02:15.258]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:15.258]    - tweaked: FALSE
[11:02:15.258]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:15.258] 2. sequential:
[11:02:15.258]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:15.258]    - tweaked: FALSE
[11:02:15.258]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:15.269] plan(): nbrOfWorkers() = 1
[11:02:15.271] getGlobalsAndPackages() ...
[11:02:15.271] Searching for globals...
[11:02:15.291] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[11:02:15.291] Searching for globals ... DONE
[11:02:15.291] Resolving globals: FALSE
[11:02:15.292] The total size of the 2 globals is 3.28 KiB (3359 bytes)
[11:02:15.293] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 3.28 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (3.23 KiB of class ‘list’) and ‘strategy2’ (49 bytes of class ‘character’)
[11:02:15.293] - globals: [2] ‘nested’, ‘strategy2’
[11:02:15.293] - packages: [1] ‘future’
[11:02:15.293] getGlobalsAndPackages() ... DONE
[11:02:15.294] run() for ‘Future’ ...
[11:02:15.294] - state: ‘created’
[11:02:15.294] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:02:15.294] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:15.294] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:15.295]   - Field: ‘label’
[11:02:15.295]   - Field: ‘local’
[11:02:15.295]   - Field: ‘owner’
[11:02:15.295]   - Field: ‘envir’
[11:02:15.295]   - Field: ‘packages’
[11:02:15.295]   - Field: ‘gc’
[11:02:15.295]   - Field: ‘conditions’
[11:02:15.295]   - Field: ‘expr’
[11:02:15.295]   - Field: ‘uuid’
[11:02:15.295]   - Field: ‘seed’
[11:02:15.295]   - Field: ‘version’
[11:02:15.295]   - Field: ‘result’
[11:02:15.295]   - Field: ‘asynchronous’
[11:02:15.296]   - Field: ‘calls’
[11:02:15.296]   - Field: ‘globals’
[11:02:15.296]   - Field: ‘stdout’
[11:02:15.296]   - Field: ‘earlySignal’
[11:02:15.296]   - Field: ‘lazy’
[11:02:15.296]   - Field: ‘state’
[11:02:15.296] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:15.296] - Launch lazy future ...
[11:02:15.297] Packages needed by the future expression (n = 1): ‘future’
[11:02:15.297] Packages needed by future strategies (n = 1): ‘future’
[11:02:15.298] {
[11:02:15.298]     {
[11:02:15.298]         {
[11:02:15.298]             ...future.startTime <- base::Sys.time()
[11:02:15.298]             {
[11:02:15.298]                 {
[11:02:15.298]                   {
[11:02:15.298]                     {
[11:02:15.298]                       base::local({
[11:02:15.298]                         has_future <- base::requireNamespace("future", 
[11:02:15.298]                           quietly = TRUE)
[11:02:15.298]                         if (has_future) {
[11:02:15.298]                           ns <- base::getNamespace("future")
[11:02:15.298]                           version <- ns[[".package"]][["version"]]
[11:02:15.298]                           if (is.null(version)) 
[11:02:15.298]                             version <- utils::packageVersion("future")
[11:02:15.298]                         }
[11:02:15.298]                         else {
[11:02:15.298]                           version <- NULL
[11:02:15.298]                         }
[11:02:15.298]                         if (!has_future || version < "1.8.0") {
[11:02:15.298]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:15.298]                             "", base::R.version$version.string), 
[11:02:15.298]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:15.298]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:15.298]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:15.298]                               "release", "version")], collapse = " "), 
[11:02:15.298]                             hostname = base::Sys.info()[["nodename"]])
[11:02:15.298]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:15.298]                             info)
[11:02:15.298]                           info <- base::paste(info, collapse = "; ")
[11:02:15.298]                           if (!has_future) {
[11:02:15.298]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:15.298]                               info)
[11:02:15.298]                           }
[11:02:15.298]                           else {
[11:02:15.298]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:15.298]                               info, version)
[11:02:15.298]                           }
[11:02:15.298]                           base::stop(msg)
[11:02:15.298]                         }
[11:02:15.298]                       })
[11:02:15.298]                     }
[11:02:15.298]                     base::local({
[11:02:15.298]                       for (pkg in "future") {
[11:02:15.298]                         base::loadNamespace(pkg)
[11:02:15.298]                         base::library(pkg, character.only = TRUE)
[11:02:15.298]                       }
[11:02:15.298]                     })
[11:02:15.298]                   }
[11:02:15.298]                   ...future.strategy.old <- future::plan("list")
[11:02:15.298]                   options(future.plan = NULL)
[11:02:15.298]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:15.298]                   future::plan(list(b = function (..., envir = parent.frame()) 
[11:02:15.298]                   {
[11:02:15.298]                     future <- SequentialFuture(..., envir = envir)
[11:02:15.298]                     if (!future$lazy) 
[11:02:15.298]                       future <- run(future)
[11:02:15.298]                     invisible(future)
[11:02:15.298]                   }), .cleanup = FALSE, .init = FALSE)
[11:02:15.298]                 }
[11:02:15.298]                 ...future.workdir <- getwd()
[11:02:15.298]             }
[11:02:15.298]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:15.298]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:15.298]         }
[11:02:15.298]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:15.298]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:15.298]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:15.298]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:15.298]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:15.298]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:15.298]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:15.298]             base::names(...future.oldOptions))
[11:02:15.298]     }
[11:02:15.298]     if (FALSE) {
[11:02:15.298]     }
[11:02:15.298]     else {
[11:02:15.298]         if (TRUE) {
[11:02:15.298]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:15.298]                 open = "w")
[11:02:15.298]         }
[11:02:15.298]         else {
[11:02:15.298]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:15.298]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:15.298]         }
[11:02:15.298]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:15.298]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:15.298]             base::sink(type = "output", split = FALSE)
[11:02:15.298]             base::close(...future.stdout)
[11:02:15.298]         }, add = TRUE)
[11:02:15.298]     }
[11:02:15.298]     ...future.frame <- base::sys.nframe()
[11:02:15.298]     ...future.conditions <- base::list()
[11:02:15.298]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:15.298]     if (FALSE) {
[11:02:15.298]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:15.298]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:15.298]     }
[11:02:15.298]     ...future.result <- base::tryCatch({
[11:02:15.298]         base::withCallingHandlers({
[11:02:15.298]             ...future.value <- base::withVisible(base::local({
[11:02:15.298]                 a <- 1L
[11:02:15.298]                 plan_a <- unclass(future::plan("list"))
[11:02:15.298]                 nested_a <- nested[-1]
[11:02:15.298]                 stopifnot(length(nested_a) == 1L, length(plan_a) == 
[11:02:15.298]                   1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[11:02:15.298]                   strategy2))
[11:02:15.298]                 for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[11:02:15.298]                   "init") <- NULL
[11:02:15.298]                 for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[11:02:15.298]                   "init") <- NULL
[11:02:15.298]                 stopifnot(all.equal(plan_a, nested_a))
[11:02:15.298]                 y %<-% {
[11:02:15.298]                   b <- 2L
[11:02:15.298]                   plan_b <- future::plan("list")
[11:02:15.298]                   nested_b <- nested_a[-1]
[11:02:15.298]                   stopifnot(length(nested_b) == 0L, length(plan_b) == 
[11:02:15.298]                     1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[11:02:15.298]                     "sequential"))
[11:02:15.298]                   list(a = a, nested_a = nested_a, plan_a = plan_a, 
[11:02:15.298]                     b = b, nested_b = nested_b, plan_b = plan_b)
[11:02:15.298]                 }
[11:02:15.298]                 y
[11:02:15.298]             }))
[11:02:15.298]             future::FutureResult(value = ...future.value$value, 
[11:02:15.298]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:15.298]                   ...future.rng), globalenv = if (FALSE) 
[11:02:15.298]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:15.298]                     ...future.globalenv.names))
[11:02:15.298]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:15.298]         }, condition = base::local({
[11:02:15.298]             c <- base::c
[11:02:15.298]             inherits <- base::inherits
[11:02:15.298]             invokeRestart <- base::invokeRestart
[11:02:15.298]             length <- base::length
[11:02:15.298]             list <- base::list
[11:02:15.298]             seq.int <- base::seq.int
[11:02:15.298]             signalCondition <- base::signalCondition
[11:02:15.298]             sys.calls <- base::sys.calls
[11:02:15.298]             `[[` <- base::`[[`
[11:02:15.298]             `+` <- base::`+`
[11:02:15.298]             `<<-` <- base::`<<-`
[11:02:15.298]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:15.298]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:15.298]                   3L)]
[11:02:15.298]             }
[11:02:15.298]             function(cond) {
[11:02:15.298]                 is_error <- inherits(cond, "error")
[11:02:15.298]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:15.298]                   NULL)
[11:02:15.298]                 if (is_error) {
[11:02:15.298]                   sessionInformation <- function() {
[11:02:15.298]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:15.298]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:15.298]                       search = base::search(), system = base::Sys.info())
[11:02:15.298]                   }
[11:02:15.298]                   ...future.conditions[[length(...future.conditions) + 
[11:02:15.298]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:15.298]                     cond$call), session = sessionInformation(), 
[11:02:15.298]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:15.298]                   signalCondition(cond)
[11:02:15.298]                 }
[11:02:15.298]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:15.298]                 "immediateCondition"))) {
[11:02:15.298]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:15.298]                   ...future.conditions[[length(...future.conditions) + 
[11:02:15.298]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:15.298]                   if (TRUE && !signal) {
[11:02:15.298]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:15.298]                     {
[11:02:15.298]                       inherits <- base::inherits
[11:02:15.298]                       invokeRestart <- base::invokeRestart
[11:02:15.298]                       is.null <- base::is.null
[11:02:15.298]                       muffled <- FALSE
[11:02:15.298]                       if (inherits(cond, "message")) {
[11:02:15.298]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:15.298]                         if (muffled) 
[11:02:15.298]                           invokeRestart("muffleMessage")
[11:02:15.298]                       }
[11:02:15.298]                       else if (inherits(cond, "warning")) {
[11:02:15.298]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:15.298]                         if (muffled) 
[11:02:15.298]                           invokeRestart("muffleWarning")
[11:02:15.298]                       }
[11:02:15.298]                       else if (inherits(cond, "condition")) {
[11:02:15.298]                         if (!is.null(pattern)) {
[11:02:15.298]                           computeRestarts <- base::computeRestarts
[11:02:15.298]                           grepl <- base::grepl
[11:02:15.298]                           restarts <- computeRestarts(cond)
[11:02:15.298]                           for (restart in restarts) {
[11:02:15.298]                             name <- restart$name
[11:02:15.298]                             if (is.null(name)) 
[11:02:15.298]                               next
[11:02:15.298]                             if (!grepl(pattern, name)) 
[11:02:15.298]                               next
[11:02:15.298]                             invokeRestart(restart)
[11:02:15.298]                             muffled <- TRUE
[11:02:15.298]                             break
[11:02:15.298]                           }
[11:02:15.298]                         }
[11:02:15.298]                       }
[11:02:15.298]                       invisible(muffled)
[11:02:15.298]                     }
[11:02:15.298]                     muffleCondition(cond, pattern = "^muffle")
[11:02:15.298]                   }
[11:02:15.298]                 }
[11:02:15.298]                 else {
[11:02:15.298]                   if (TRUE) {
[11:02:15.298]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:15.298]                     {
[11:02:15.298]                       inherits <- base::inherits
[11:02:15.298]                       invokeRestart <- base::invokeRestart
[11:02:15.298]                       is.null <- base::is.null
[11:02:15.298]                       muffled <- FALSE
[11:02:15.298]                       if (inherits(cond, "message")) {
[11:02:15.298]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:15.298]                         if (muffled) 
[11:02:15.298]                           invokeRestart("muffleMessage")
[11:02:15.298]                       }
[11:02:15.298]                       else if (inherits(cond, "warning")) {
[11:02:15.298]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:15.298]                         if (muffled) 
[11:02:15.298]                           invokeRestart("muffleWarning")
[11:02:15.298]                       }
[11:02:15.298]                       else if (inherits(cond, "condition")) {
[11:02:15.298]                         if (!is.null(pattern)) {
[11:02:15.298]                           computeRestarts <- base::computeRestarts
[11:02:15.298]                           grepl <- base::grepl
[11:02:15.298]                           restarts <- computeRestarts(cond)
[11:02:15.298]                           for (restart in restarts) {
[11:02:15.298]                             name <- restart$name
[11:02:15.298]                             if (is.null(name)) 
[11:02:15.298]                               next
[11:02:15.298]                             if (!grepl(pattern, name)) 
[11:02:15.298]                               next
[11:02:15.298]                             invokeRestart(restart)
[11:02:15.298]                             muffled <- TRUE
[11:02:15.298]                             break
[11:02:15.298]                           }
[11:02:15.298]                         }
[11:02:15.298]                       }
[11:02:15.298]                       invisible(muffled)
[11:02:15.298]                     }
[11:02:15.298]                     muffleCondition(cond, pattern = "^muffle")
[11:02:15.298]                   }
[11:02:15.298]                 }
[11:02:15.298]             }
[11:02:15.298]         }))
[11:02:15.298]     }, error = function(ex) {
[11:02:15.298]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:15.298]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:15.298]                 ...future.rng), started = ...future.startTime, 
[11:02:15.298]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:15.298]             version = "1.8"), class = "FutureResult")
[11:02:15.298]     }, finally = {
[11:02:15.298]         if (!identical(...future.workdir, getwd())) 
[11:02:15.298]             setwd(...future.workdir)
[11:02:15.298]         {
[11:02:15.298]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:15.298]                 ...future.oldOptions$nwarnings <- NULL
[11:02:15.298]             }
[11:02:15.298]             base::options(...future.oldOptions)
[11:02:15.298]             if (.Platform$OS.type == "windows") {
[11:02:15.298]                 old_names <- names(...future.oldEnvVars)
[11:02:15.298]                 envs <- base::Sys.getenv()
[11:02:15.298]                 names <- names(envs)
[11:02:15.298]                 common <- intersect(names, old_names)
[11:02:15.298]                 added <- setdiff(names, old_names)
[11:02:15.298]                 removed <- setdiff(old_names, names)
[11:02:15.298]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:15.298]                   envs[common]]
[11:02:15.298]                 NAMES <- toupper(changed)
[11:02:15.298]                 args <- list()
[11:02:15.298]                 for (kk in seq_along(NAMES)) {
[11:02:15.298]                   name <- changed[[kk]]
[11:02:15.298]                   NAME <- NAMES[[kk]]
[11:02:15.298]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:15.298]                     next
[11:02:15.298]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:15.298]                 }
[11:02:15.298]                 NAMES <- toupper(added)
[11:02:15.298]                 for (kk in seq_along(NAMES)) {
[11:02:15.298]                   name <- added[[kk]]
[11:02:15.298]                   NAME <- NAMES[[kk]]
[11:02:15.298]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:15.298]                     next
[11:02:15.298]                   args[[name]] <- ""
[11:02:15.298]                 }
[11:02:15.298]                 NAMES <- toupper(removed)
[11:02:15.298]                 for (kk in seq_along(NAMES)) {
[11:02:15.298]                   name <- removed[[kk]]
[11:02:15.298]                   NAME <- NAMES[[kk]]
[11:02:15.298]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:15.298]                     next
[11:02:15.298]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:15.298]                 }
[11:02:15.298]                 if (length(args) > 0) 
[11:02:15.298]                   base::do.call(base::Sys.setenv, args = args)
[11:02:15.298]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:15.298]             }
[11:02:15.298]             else {
[11:02:15.298]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:15.298]             }
[11:02:15.298]             {
[11:02:15.298]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:15.298]                   0L) {
[11:02:15.298]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:15.298]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:15.298]                   base::options(opts)
[11:02:15.298]                 }
[11:02:15.298]                 {
[11:02:15.298]                   {
[11:02:15.298]                     NULL
[11:02:15.298]                     RNGkind("Mersenne-Twister")
[11:02:15.298]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:15.298]                       inherits = FALSE)
[11:02:15.298]                   }
[11:02:15.298]                   options(future.plan = NULL)
[11:02:15.298]                   if (is.na(NA_character_)) 
[11:02:15.298]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:15.298]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:15.298]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:15.298]                     .init = FALSE)
[11:02:15.298]                 }
[11:02:15.298]             }
[11:02:15.298]         }
[11:02:15.298]     })
[11:02:15.298]     if (TRUE) {
[11:02:15.298]         base::sink(type = "output", split = FALSE)
[11:02:15.298]         if (TRUE) {
[11:02:15.298]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:15.298]         }
[11:02:15.298]         else {
[11:02:15.298]             ...future.result["stdout"] <- base::list(NULL)
[11:02:15.298]         }
[11:02:15.298]         base::close(...future.stdout)
[11:02:15.298]         ...future.stdout <- NULL
[11:02:15.298]     }
[11:02:15.298]     ...future.result$conditions <- ...future.conditions
[11:02:15.298]     ...future.result$finished <- base::Sys.time()
[11:02:15.298]     ...future.result
[11:02:15.298] }
[11:02:15.300] assign_globals() ...
[11:02:15.300] List of 2
[11:02:15.300]  $ nested   :List of 2
[11:02:15.300]   ..$ a:function (..., envir = parent.frame())  
[11:02:15.300]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[11:02:15.300]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[11:02:15.300]   ..$ b:function (..., envir = parent.frame())  
[11:02:15.300]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[11:02:15.300]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[11:02:15.300]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[11:02:15.300]  $ strategy2: chr "sequential"
[11:02:15.300]  - attr(*, "where")=List of 2
[11:02:15.300]   ..$ nested   :<environment: R_EmptyEnv> 
[11:02:15.300]   ..$ strategy2:<environment: R_EmptyEnv> 
[11:02:15.300]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:02:15.300]  - attr(*, "resolved")= logi FALSE
[11:02:15.300]  - attr(*, "total_size")= num 3359
[11:02:15.300]  - attr(*, "already-done")= logi TRUE
[11:02:15.306] - copied ‘nested’ to environment
[11:02:15.306] - copied ‘strategy2’ to environment
[11:02:15.306] assign_globals() ... done
[11:02:15.306] plan(): Setting new future strategy stack:
[11:02:15.306] List of future strategies:
[11:02:15.306] 1. sequential:
[11:02:15.306]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:15.306]    - tweaked: FALSE
[11:02:15.306]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:15.307] plan(): nbrOfWorkers() = 1
[11:02:15.342] plan(): Setting new future strategy stack:
[11:02:15.342] List of future strategies:
[11:02:15.342] 1. sequential:
[11:02:15.342]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:15.342]    - tweaked: FALSE
[11:02:15.342]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:15.342] 2. sequential:
[11:02:15.342]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:15.342]    - tweaked: FALSE
[11:02:15.342]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:15.343] plan(): nbrOfWorkers() = 1
[11:02:15.343] SequentialFuture started (and completed)
[11:02:15.343] signalConditions() ...
[11:02:15.343]  - include = ‘immediateCondition’
[11:02:15.344]  - exclude = 
[11:02:15.344]  - resignal = FALSE
[11:02:15.344]  - Number of conditions: 54
[11:02:15.344] signalConditions() ... done
[11:02:15.344] - Launch lazy future ... done
[11:02:15.344] run() for ‘SequentialFuture’ ... done
[11:02:15.344] signalConditions() ...
[11:02:15.344]  - include = ‘immediateCondition’
[11:02:15.344]  - exclude = 
[11:02:15.344]  - resignal = FALSE
[11:02:15.344]  - Number of conditions: 54
[11:02:15.345] signalConditions() ... done
[11:02:15.345] Future state: ‘finished’
[11:02:15.345] signalConditions() ...
[11:02:15.345]  - include = ‘condition’
[11:02:15.345]  - exclude = ‘immediateCondition’
[11:02:15.345]  - resignal = TRUE
[11:02:15.345]  - Number of conditions: 54
[11:02:15.345]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.308] getGlobalsAndPackages() ...
[11:02:15.345]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.308] Searching for globals...
[11:02:15.345]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.326] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[11:02:15.345]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.326] Searching for globals ... DONE
[11:02:15.346]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.326] Resolving globals: FALSE
[11:02:15.346]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.327] The total size of the 3 globals is 3.58 KiB (3661 bytes)
[11:02:15.346]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.327] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 3.58 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (1.77 KiB of class ‘list’), ‘plan_a’ (1.77 KiB of class ‘list’) and ‘a’ (35 bytes of class ‘numeric’)
[11:02:15.346]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.327] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[11:02:15.346]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.327] 
[11:02:15.346]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.328] getGlobalsAndPackages() ... DONE
[11:02:15.346]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.328] run() for ‘Future’ ...
[11:02:15.346]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.328] - state: ‘created’
[11:02:15.346]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.328] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:02:15.347]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.328] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:15.347]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.328] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:15.347]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.328]   - Field: ‘label’
[11:02:15.347]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.329]   - Field: ‘local’
[11:02:15.347]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.329]   - Field: ‘owner’
[11:02:15.347]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.329]   - Field: ‘envir’
[11:02:15.347]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.329]   - Field: ‘packages’
[11:02:15.347]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.329]   - Field: ‘gc’
[11:02:15.347]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.329]   - Field: ‘conditions’
[11:02:15.348]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.329]   - Field: ‘expr’
[11:02:15.348]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.329]   - Field: ‘uuid’
[11:02:15.348]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.329]   - Field: ‘seed’
[11:02:15.348]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.329]   - Field: ‘version’
[11:02:15.348]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.330]   - Field: ‘result’
[11:02:15.348]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.330]   - Field: ‘asynchronous’
[11:02:15.348]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.330]   - Field: ‘calls’
[11:02:15.348]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.330]   - Field: ‘globals’
[11:02:15.348]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.330]   - Field: ‘stdout’
[11:02:15.349]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.330]   - Field: ‘earlySignal’
[11:02:15.349]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.330]   - Field: ‘lazy’
[11:02:15.349]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.330]   - Field: ‘state’
[11:02:15.349]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.330] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:15.349]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.330] - Launch lazy future ...
[11:02:15.349]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.331] Packages needed by the future expression (n = 0): <none>
[11:02:15.349]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.331] Packages needed by future strategies (n = 0): <none>
[11:02:15.349]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.331] {
[11:02:15.331]     {
[11:02:15.331]         {
[11:02:15.331]             ...future.startTime <- base::Sys.time()
[11:02:15.331]             {
[11:02:15.331]                 {
[11:02:15.331]                   {
[11:02:15.331]                     base::local({
[11:02:15.331]                       has_future <- base::requireNamespace("future", 
[11:02:15.331]                         quietly = TRUE)
[11:02:15.331]                       if (has_future) {
[11:02:15.331]                         ns <- base::getNamespace("future")
[11:02:15.331]                         version <- ns[[".package"]][["version"]]
[11:02:15.331]                         if (is.null(version)) 
[11:02:15.331]                           version <- utils::packageVersion("future")
[11:02:15.331]                       }
[11:02:15.331]                       else {
[11:02:15.331]                         version <- NULL
[11:02:15.331]                       }
[11:02:15.331]                       if (!has_future || version < "1.8.0") {
[11:02:15.331]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:15.331]                           "", base::R.version$version.string), 
[11:02:15.331]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:15.331]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:15.331]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:15.331]                             "release", "version")], collapse = " "), 
[11:02:15.331]                           hostname = base::Sys.info()[["nodename"]])
[11:02:15.331]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:15.331]                           info)
[11:02:15.331]                         info <- base::paste(info, collapse = "; ")
[11:02:15.331]                         if (!has_future) {
[11:02:15.331]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:15.331]                             info)
[11:02:15.331]                         }
[11:02:15.331]                         else {
[11:02:15.331]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:15.331]                             info, version)
[11:02:15.331]                         }
[11:02:15.331]                         base::stop(msg)
[11:02:15.331]                       }
[11:02:15.331]                     })
[11:02:15.331]                   }
[11:02:15.331]                   ...future.strategy.old <- future::plan("list")
[11:02:15.331]                   options(future.plan = NULL)
[11:02:15.331]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:15.331]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:15.331]                 }
[11:02:15.331]                 ...future.workdir <- getwd()
[11:02:15.331]             }
[11:02:15.331]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:15.331]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:15.331]         }
[11:02:15.331]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:15.331]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:15.331]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:15.331]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:15.331]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:15.331]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:15.331]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:15.331]             base::names(...future.oldOptions))
[11:02:15.331]     }
[11:02:15.331]     if (FALSE) {
[11:02:15.331]     }
[11:02:15.331]     else {
[11:02:15.331]         if (TRUE) {
[11:02:15.331]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:15.331]                 open = "w")
[11:02:15.331]         }
[11:02:15.331]         else {
[11:02:15.331]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:15.331]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:15.331]         }
[11:02:15.331]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:15.331]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:15.331]             base::sink(type = "output", split = FALSE)
[11:02:15.331]             base::close(...future.stdout)
[11:02:15.331]         }, add = TRUE)
[11:02:15.331]     }
[11:02:15.331]     ...future.frame <- base::sys.nframe()
[11:02:15.331]     ...future.conditions <- base::list()
[11:02:15.331]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:15.331]     if (FALSE) {
[11:02:15.331]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:15.331]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:15.331]     }
[11:02:15.331]     ...future.result <- base::tryCatch({
[11:02:15.331]         base::withCallingHandlers({
[11:02:15.331]             ...future.value <- base::withVisible(base::local({
[11:02:15.331]                 b <- 2L
[11:02:15.331]                 plan_b <- future::plan("list")
[11:02:15.331]                 nested_b <- nested_a[-1]
[11:02:15.331]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[11:02:15.331]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[11:02:15.331]                   "sequential"))
[11:02:15.331]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[11:02:15.331]                   b = b, nested_b = nested_b, plan_b = plan_b)
[11:02:15.331]             }))
[11:02:15.331]             future::FutureResult(value = ...future.value$value, 
[11:02:15.331]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:15.331]                   ...future.rng), globalenv = if (FALSE) 
[11:02:15.331]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:15.331]                     ...future.globalenv.names))
[11:02:15.331]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:15.331]         }, condition = base::local({
[11:02:15.331]             c <- base::c
[11:02:15.331]             inherits <- base::inherits
[11:02:15.331]             invokeRestart <- base::invokeRestart
[11:02:15.331]             length <- base::length
[11:02:15.331]             list <- base::list
[11:02:15.331]             seq.int <- base::seq.int
[11:02:15.331]             signalCondition <- base::signalCondition
[11:02:15.331]             sys.calls <- base::sys.calls
[11:02:15.331]             `[[` <- base::`[[`
[11:02:15.331]             `+` <- base::`+`
[11:02:15.331]             `<<-` <- base::`<<-`
[11:02:15.331]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:15.331]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:15.331]                   3L)]
[11:02:15.331]             }
[11:02:15.331]             function(cond) {
[11:02:15.331]                 is_error <- inherits(cond, "error")
[11:02:15.331]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:15.331]                   NULL)
[11:02:15.331]                 if (is_error) {
[11:02:15.331]                   sessionInformation <- function() {
[11:02:15.331]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:15.331]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:15.331]                       search = base::search(), system = base::Sys.info())
[11:02:15.331]                   }
[11:02:15.331]                   ...future.conditions[[length(...future.conditions) + 
[11:02:15.331]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:15.331]                     cond$call), session = sessionInformation(), 
[11:02:15.331]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:15.331]                   signalCondition(cond)
[11:02:15.331]                 }
[11:02:15.331]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:15.331]                 "immediateCondition"))) {
[11:02:15.331]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:15.331]                   ...future.conditions[[length(...future.conditions) + 
[11:02:15.331]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:15.331]                   if (TRUE && !signal) {
[11:02:15.331]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:15.331]                     {
[11:02:15.331]                       inherits <- base::inherits
[11:02:15.331]                       invokeRestart <- base::invokeRestart
[11:02:15.331]                       is.null <- base::is.null
[11:02:15.331]                       muffled <- FALSE
[11:02:15.331]                       if (inherits(cond, "message")) {
[11:02:15.331]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:15.331]                         if (muffled) 
[11:02:15.331]                           invokeRestart("muffleMessage")
[11:02:15.331]                       }
[11:02:15.331]                       else if (inherits(cond, "warning")) {
[11:02:15.331]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:15.331]                         if (muffled) 
[11:02:15.331]                           invokeRestart("muffleWarning")
[11:02:15.331]                       }
[11:02:15.331]                       else if (inherits(cond, "condition")) {
[11:02:15.331]                         if (!is.null(pattern)) {
[11:02:15.331]                           computeRestarts <- base::computeRestarts
[11:02:15.331]                           grepl <- base::grepl
[11:02:15.331]                           restarts <- computeRestarts(cond)
[11:02:15.331]                           for (restart in restarts) {
[11:02:15.331]                             name <- restart$name
[11:02:15.331]                             if (is.null(name)) 
[11:02:15.331]                               next
[11:02:15.331]                             if (!grepl(pattern, name)) 
[11:02:15.331]                               next
[11:02:15.331]                             invokeRestart(restart)
[11:02:15.331]                             muffled <- TRUE
[11:02:15.331]                             break
[11:02:15.331]                           }
[11:02:15.331]                         }
[11:02:15.331]                       }
[11:02:15.331]                       invisible(muffled)
[11:02:15.331]                     }
[11:02:15.331]                     muffleCondition(cond, pattern = "^muffle")
[11:02:15.331]                   }
[11:02:15.331]                 }
[11:02:15.331]                 else {
[11:02:15.331]                   if (TRUE) {
[11:02:15.331]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:15.331]                     {
[11:02:15.331]                       inherits <- base::inherits
[11:02:15.331]                       invokeRestart <- base::invokeRestart
[11:02:15.331]                       is.null <- base::is.null
[11:02:15.331]                       muffled <- FALSE
[11:02:15.331]                       if (inherits(cond, "message")) {
[11:02:15.331]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:15.331]                         if (muffled) 
[11:02:15.331]                           invokeRestart("muffleMessage")
[11:02:15.331]                       }
[11:02:15.331]                       else if (inherits(cond, "warning")) {
[11:02:15.331]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:15.331]                         if (muffled) 
[11:02:15.331]                           invokeRestart("muffleWarning")
[11:02:15.331]                       }
[11:02:15.331]                       else if (inherits(cond, "condition")) {
[11:02:15.331]                         if (!is.null(pattern)) {
[11:02:15.331]                           computeRestarts <- base::computeRestarts
[11:02:15.331]                           grepl <- base::grepl
[11:02:15.331]                           restarts <- computeRestarts(cond)
[11:02:15.331]                           for (restart in restarts) {
[11:02:15.331]                             name <- restart$name
[11:02:15.331]                             if (is.null(name)) 
[11:02:15.331]                               next
[11:02:15.331]                             if (!grepl(pattern, name)) 
[11:02:15.331]                               next
[11:02:15.331]                             invokeRestart(restart)
[11:02:15.331]                             muffled <- TRUE
[11:02:15.331]                             break
[11:02:15.331]                           }
[11:02:15.331]                         }
[11:02:15.331]                       }
[11:02:15.331]                       invisible(muffled)
[11:02:15.331]                     }
[11:02:15.331]                     muffleCondition(cond, pattern = "^muffle")
[11:02:15.331]                   }
[11:02:15.331]                 }
[11:02:15.331]             }
[11:02:15.331]         }))
[11:02:15.331]     }, error = function(ex) {
[11:02:15.331]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:15.331]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:15.331]                 ...future.rng), started = ...future.startTime, 
[11:02:15.331]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:15.331]             version = "1.8"), class = "FutureResult")
[11:02:15.331]     }, finally = {
[11:02:15.331]         if (!identical(...future.workdir, getwd())) 
[11:02:15.331]             setwd(...future.workdir)
[11:02:15.331]         {
[11:02:15.331]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:15.331]                 ...future.oldOptions$nwarnings <- NULL
[11:02:15.331]             }
[11:02:15.331]             base::options(...future.oldOptions)
[11:02:15.331]             if (.Platform$OS.type == "windows") {
[11:02:15.331]                 old_names <- names(...future.oldEnvVars)
[11:02:15.331]                 envs <- base::Sys.getenv()
[11:02:15.331]                 names <- names(envs)
[11:02:15.331]                 common <- intersect(names, old_names)
[11:02:15.331]                 added <- setdiff(names, old_names)
[11:02:15.331]                 removed <- setdiff(old_names, names)
[11:02:15.331]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:15.331]                   envs[common]]
[11:02:15.331]                 NAMES <- toupper(changed)
[11:02:15.331]                 args <- list()
[11:02:15.331]                 for (kk in seq_along(NAMES)) {
[11:02:15.331]                   name <- changed[[kk]]
[11:02:15.331]                   NAME <- NAMES[[kk]]
[11:02:15.331]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:15.331]                     next
[11:02:15.331]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:15.331]                 }
[11:02:15.331]                 NAMES <- toupper(added)
[11:02:15.331]                 for (kk in seq_along(NAMES)) {
[11:02:15.331]                   name <- added[[kk]]
[11:02:15.331]                   NAME <- NAMES[[kk]]
[11:02:15.331]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:15.331]                     next
[11:02:15.331]                   args[[name]] <- ""
[11:02:15.331]                 }
[11:02:15.331]                 NAMES <- toupper(removed)
[11:02:15.331]                 for (kk in seq_along(NAMES)) {
[11:02:15.331]                   name <- removed[[kk]]
[11:02:15.331]                   NAME <- NAMES[[kk]]
[11:02:15.331]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:15.331]                     next
[11:02:15.331]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:15.331]                 }
[11:02:15.331]                 if (length(args) > 0) 
[11:02:15.331]                   base::do.call(base::Sys.setenv, args = args)
[11:02:15.331]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:15.331]             }
[11:02:15.331]             else {
[11:02:15.331]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:15.331]             }
[11:02:15.331]             {
[11:02:15.331]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:15.331]                   0L) {
[11:02:15.331]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:15.331]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:15.331]                   base::options(opts)
[11:02:15.331]                 }
[11:02:15.331]                 {
[11:02:15.331]                   {
[11:02:15.331]                     NULL
[11:02:15.331]                     RNGkind("Mersenne-Twister")
[11:02:15.331]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:15.331]                       inherits = FALSE)
[11:02:15.331]                   }
[11:02:15.331]                   options(future.plan = NULL)
[11:02:15.331]                   if (is.na(NA_character_)) 
[11:02:15.331]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:15.331]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:15.331]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:15.331]                     .init = FALSE)
[11:02:15.331]                 }
[11:02:15.331]             }
[11:02:15.331]         }
[11:02:15.331]     })
[11:02:15.331]     if (TRUE) {
[11:02:15.331]         base::sink(type = "output", split = FALSE)
[11:02:15.331]         if (TRUE) {
[11:02:15.331]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:15.331]         }
[11:02:15.331]         else {
[11:02:15.331]             ...future.result["stdout"] <- base::list(NULL)
[11:02:15.331]         }
[11:02:15.331]         base::close(...future.stdout)
[11:02:15.331]         ...future.stdout <- NULL
[11:02:15.331]     }
[11:02:15.331]     ...future.result$conditions <- ...future.conditions
[11:02:15.331]     ...future.result$finished <- base::Sys.time()
[11:02:15.331]     ...future.result
[11:02:15.331] }
[11:02:15.350]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.333] assign_globals() ...
[11:02:15.350]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.333] List of 3
[11:02:15.333]  $ nested_a:List of 1
[11:02:15.333]   ..$ b:function (..., envir = parent.frame())  
[11:02:15.333]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[11:02:15.333]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[11:02:15.333]  $ a       : int 1
[11:02:15.333]  $ plan_a  :List of 1
[11:02:15.333]   ..$ b:function (..., envir = parent.frame())  
[11:02:15.333]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[11:02:15.333]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[11:02:15.333]  - attr(*, "where")=List of 3
[11:02:15.333]   ..$ nested_a:<environment: R_EmptyEnv> 
[11:02:15.333]   ..$ a       :<environment: R_EmptyEnv> 
[11:02:15.333]   ..$ plan_a  :<environment: R_EmptyEnv> 
[11:02:15.333]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:02:15.333]  - attr(*, "resolved")= logi FALSE
[11:02:15.333]  - attr(*, "total_size")= num 3661
[11:02:15.333]  - attr(*, "already-done")= logi TRUE
[11:02:15.350]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.338] - copied ‘nested_a’ to environment
[11:02:15.350]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.338] - copied ‘a’ to environment
[11:02:15.350]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.339] - copied ‘plan_a’ to environment
[11:02:15.350]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.339] assign_globals() ... done
[11:02:15.350]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.339] plan(): Setting new future strategy stack:
[11:02:15.350]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.339] List of future strategies:
[11:02:15.339] 1. sequential:
[11:02:15.339]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:15.339]    - tweaked: FALSE
[11:02:15.339]    - call: NULL
[11:02:15.351]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.339] plan(): nbrOfWorkers() = 1
[11:02:15.351]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.340] plan(): Setting new future strategy stack:
[11:02:15.351]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.341] List of future strategies:
[11:02:15.341] 1. sequential:
[11:02:15.341]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:15.341]    - tweaked: FALSE
[11:02:15.341]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:15.351]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.341] plan(): nbrOfWorkers() = 1
[11:02:15.351]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.341] SequentialFuture started (and completed)
[11:02:15.351]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.342] - Launch lazy future ... done
[11:02:15.351]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.342] run() for ‘SequentialFuture’ ... done
[11:02:15.351] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[11:02:15.356] getGlobalsAndPackages() ...
[11:02:15.356] Searching for globals...
[11:02:15.357] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[11:02:15.357] Searching for globals ... DONE
[11:02:15.357] Resolving globals: FALSE
[11:02:15.358] The total size of the 1 globals is 356 bytes (356 bytes)
[11:02:15.358] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[11:02:15.358] - globals: [1] ‘data’
[11:02:15.358] - packages: [1] ‘future’
[11:02:15.358] getGlobalsAndPackages() ... DONE
[11:02:15.358] run() for ‘Future’ ...
[11:02:15.358] - state: ‘created’
[11:02:15.359] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:02:15.360] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:15.360] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:15.360]   - Field: ‘label’
[11:02:15.360]   - Field: ‘local’
[11:02:15.360]   - Field: ‘owner’
[11:02:15.360]   - Field: ‘envir’
[11:02:15.360]   - Field: ‘packages’
[11:02:15.360]   - Field: ‘gc’
[11:02:15.360]   - Field: ‘conditions’
[11:02:15.360]   - Field: ‘expr’
[11:02:15.361]   - Field: ‘uuid’
[11:02:15.361]   - Field: ‘seed’
[11:02:15.361]   - Field: ‘version’
[11:02:15.361]   - Field: ‘result’
[11:02:15.361]   - Field: ‘asynchronous’
[11:02:15.361]   - Field: ‘calls’
[11:02:15.361]   - Field: ‘globals’
[11:02:15.361]   - Field: ‘stdout’
[11:02:15.361]   - Field: ‘earlySignal’
[11:02:15.361]   - Field: ‘lazy’
[11:02:15.361]   - Field: ‘state’
[11:02:15.361] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:15.361] - Launch lazy future ...
[11:02:15.362] Packages needed by the future expression (n = 1): ‘future’
[11:02:15.362] Packages needed by future strategies (n = 1): ‘future’
[11:02:15.362] {
[11:02:15.362]     {
[11:02:15.362]         {
[11:02:15.362]             ...future.startTime <- base::Sys.time()
[11:02:15.362]             {
[11:02:15.362]                 {
[11:02:15.362]                   {
[11:02:15.362]                     {
[11:02:15.362]                       base::local({
[11:02:15.362]                         has_future <- base::requireNamespace("future", 
[11:02:15.362]                           quietly = TRUE)
[11:02:15.362]                         if (has_future) {
[11:02:15.362]                           ns <- base::getNamespace("future")
[11:02:15.362]                           version <- ns[[".package"]][["version"]]
[11:02:15.362]                           if (is.null(version)) 
[11:02:15.362]                             version <- utils::packageVersion("future")
[11:02:15.362]                         }
[11:02:15.362]                         else {
[11:02:15.362]                           version <- NULL
[11:02:15.362]                         }
[11:02:15.362]                         if (!has_future || version < "1.8.0") {
[11:02:15.362]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:15.362]                             "", base::R.version$version.string), 
[11:02:15.362]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:15.362]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:15.362]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:15.362]                               "release", "version")], collapse = " "), 
[11:02:15.362]                             hostname = base::Sys.info()[["nodename"]])
[11:02:15.362]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:15.362]                             info)
[11:02:15.362]                           info <- base::paste(info, collapse = "; ")
[11:02:15.362]                           if (!has_future) {
[11:02:15.362]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:15.362]                               info)
[11:02:15.362]                           }
[11:02:15.362]                           else {
[11:02:15.362]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:15.362]                               info, version)
[11:02:15.362]                           }
[11:02:15.362]                           base::stop(msg)
[11:02:15.362]                         }
[11:02:15.362]                       })
[11:02:15.362]                     }
[11:02:15.362]                     base::local({
[11:02:15.362]                       for (pkg in "future") {
[11:02:15.362]                         base::loadNamespace(pkg)
[11:02:15.362]                         base::library(pkg, character.only = TRUE)
[11:02:15.362]                       }
[11:02:15.362]                     })
[11:02:15.362]                   }
[11:02:15.362]                   ...future.strategy.old <- future::plan("list")
[11:02:15.362]                   options(future.plan = NULL)
[11:02:15.362]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:15.362]                   future::plan(list(b = function (..., envir = parent.frame()) 
[11:02:15.362]                   {
[11:02:15.362]                     future <- SequentialFuture(..., envir = envir)
[11:02:15.362]                     if (!future$lazy) 
[11:02:15.362]                       future <- run(future)
[11:02:15.362]                     invisible(future)
[11:02:15.362]                   }), .cleanup = FALSE, .init = FALSE)
[11:02:15.362]                 }
[11:02:15.362]                 ...future.workdir <- getwd()
[11:02:15.362]             }
[11:02:15.362]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:15.362]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:15.362]         }
[11:02:15.362]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:15.362]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:15.362]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:15.362]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:15.362]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:15.362]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:15.362]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:15.362]             base::names(...future.oldOptions))
[11:02:15.362]     }
[11:02:15.362]     if (FALSE) {
[11:02:15.362]     }
[11:02:15.362]     else {
[11:02:15.362]         if (TRUE) {
[11:02:15.362]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:15.362]                 open = "w")
[11:02:15.362]         }
[11:02:15.362]         else {
[11:02:15.362]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:15.362]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:15.362]         }
[11:02:15.362]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:15.362]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:15.362]             base::sink(type = "output", split = FALSE)
[11:02:15.362]             base::close(...future.stdout)
[11:02:15.362]         }, add = TRUE)
[11:02:15.362]     }
[11:02:15.362]     ...future.frame <- base::sys.nframe()
[11:02:15.362]     ...future.conditions <- base::list()
[11:02:15.362]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:15.362]     if (FALSE) {
[11:02:15.362]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:15.362]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:15.362]     }
[11:02:15.362]     ...future.result <- base::tryCatch({
[11:02:15.362]         base::withCallingHandlers({
[11:02:15.362]             ...future.value <- base::withVisible(base::local({
[11:02:15.362]                 value(future(subset(data, a == 2)))
[11:02:15.362]             }))
[11:02:15.362]             future::FutureResult(value = ...future.value$value, 
[11:02:15.362]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:15.362]                   ...future.rng), globalenv = if (FALSE) 
[11:02:15.362]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:15.362]                     ...future.globalenv.names))
[11:02:15.362]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:15.362]         }, condition = base::local({
[11:02:15.362]             c <- base::c
[11:02:15.362]             inherits <- base::inherits
[11:02:15.362]             invokeRestart <- base::invokeRestart
[11:02:15.362]             length <- base::length
[11:02:15.362]             list <- base::list
[11:02:15.362]             seq.int <- base::seq.int
[11:02:15.362]             signalCondition <- base::signalCondition
[11:02:15.362]             sys.calls <- base::sys.calls
[11:02:15.362]             `[[` <- base::`[[`
[11:02:15.362]             `+` <- base::`+`
[11:02:15.362]             `<<-` <- base::`<<-`
[11:02:15.362]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:15.362]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:15.362]                   3L)]
[11:02:15.362]             }
[11:02:15.362]             function(cond) {
[11:02:15.362]                 is_error <- inherits(cond, "error")
[11:02:15.362]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:15.362]                   NULL)
[11:02:15.362]                 if (is_error) {
[11:02:15.362]                   sessionInformation <- function() {
[11:02:15.362]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:15.362]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:15.362]                       search = base::search(), system = base::Sys.info())
[11:02:15.362]                   }
[11:02:15.362]                   ...future.conditions[[length(...future.conditions) + 
[11:02:15.362]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:15.362]                     cond$call), session = sessionInformation(), 
[11:02:15.362]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:15.362]                   signalCondition(cond)
[11:02:15.362]                 }
[11:02:15.362]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:15.362]                 "immediateCondition"))) {
[11:02:15.362]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:15.362]                   ...future.conditions[[length(...future.conditions) + 
[11:02:15.362]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:15.362]                   if (TRUE && !signal) {
[11:02:15.362]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:15.362]                     {
[11:02:15.362]                       inherits <- base::inherits
[11:02:15.362]                       invokeRestart <- base::invokeRestart
[11:02:15.362]                       is.null <- base::is.null
[11:02:15.362]                       muffled <- FALSE
[11:02:15.362]                       if (inherits(cond, "message")) {
[11:02:15.362]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:15.362]                         if (muffled) 
[11:02:15.362]                           invokeRestart("muffleMessage")
[11:02:15.362]                       }
[11:02:15.362]                       else if (inherits(cond, "warning")) {
[11:02:15.362]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:15.362]                         if (muffled) 
[11:02:15.362]                           invokeRestart("muffleWarning")
[11:02:15.362]                       }
[11:02:15.362]                       else if (inherits(cond, "condition")) {
[11:02:15.362]                         if (!is.null(pattern)) {
[11:02:15.362]                           computeRestarts <- base::computeRestarts
[11:02:15.362]                           grepl <- base::grepl
[11:02:15.362]                           restarts <- computeRestarts(cond)
[11:02:15.362]                           for (restart in restarts) {
[11:02:15.362]                             name <- restart$name
[11:02:15.362]                             if (is.null(name)) 
[11:02:15.362]                               next
[11:02:15.362]                             if (!grepl(pattern, name)) 
[11:02:15.362]                               next
[11:02:15.362]                             invokeRestart(restart)
[11:02:15.362]                             muffled <- TRUE
[11:02:15.362]                             break
[11:02:15.362]                           }
[11:02:15.362]                         }
[11:02:15.362]                       }
[11:02:15.362]                       invisible(muffled)
[11:02:15.362]                     }
[11:02:15.362]                     muffleCondition(cond, pattern = "^muffle")
[11:02:15.362]                   }
[11:02:15.362]                 }
[11:02:15.362]                 else {
[11:02:15.362]                   if (TRUE) {
[11:02:15.362]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:15.362]                     {
[11:02:15.362]                       inherits <- base::inherits
[11:02:15.362]                       invokeRestart <- base::invokeRestart
[11:02:15.362]                       is.null <- base::is.null
[11:02:15.362]                       muffled <- FALSE
[11:02:15.362]                       if (inherits(cond, "message")) {
[11:02:15.362]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:15.362]                         if (muffled) 
[11:02:15.362]                           invokeRestart("muffleMessage")
[11:02:15.362]                       }
[11:02:15.362]                       else if (inherits(cond, "warning")) {
[11:02:15.362]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:15.362]                         if (muffled) 
[11:02:15.362]                           invokeRestart("muffleWarning")
[11:02:15.362]                       }
[11:02:15.362]                       else if (inherits(cond, "condition")) {
[11:02:15.362]                         if (!is.null(pattern)) {
[11:02:15.362]                           computeRestarts <- base::computeRestarts
[11:02:15.362]                           grepl <- base::grepl
[11:02:15.362]                           restarts <- computeRestarts(cond)
[11:02:15.362]                           for (restart in restarts) {
[11:02:15.362]                             name <- restart$name
[11:02:15.362]                             if (is.null(name)) 
[11:02:15.362]                               next
[11:02:15.362]                             if (!grepl(pattern, name)) 
[11:02:15.362]                               next
[11:02:15.362]                             invokeRestart(restart)
[11:02:15.362]                             muffled <- TRUE
[11:02:15.362]                             break
[11:02:15.362]                           }
[11:02:15.362]                         }
[11:02:15.362]                       }
[11:02:15.362]                       invisible(muffled)
[11:02:15.362]                     }
[11:02:15.362]                     muffleCondition(cond, pattern = "^muffle")
[11:02:15.362]                   }
[11:02:15.362]                 }
[11:02:15.362]             }
[11:02:15.362]         }))
[11:02:15.362]     }, error = function(ex) {
[11:02:15.362]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:15.362]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:15.362]                 ...future.rng), started = ...future.startTime, 
[11:02:15.362]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:15.362]             version = "1.8"), class = "FutureResult")
[11:02:15.362]     }, finally = {
[11:02:15.362]         if (!identical(...future.workdir, getwd())) 
[11:02:15.362]             setwd(...future.workdir)
[11:02:15.362]         {
[11:02:15.362]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:15.362]                 ...future.oldOptions$nwarnings <- NULL
[11:02:15.362]             }
[11:02:15.362]             base::options(...future.oldOptions)
[11:02:15.362]             if (.Platform$OS.type == "windows") {
[11:02:15.362]                 old_names <- names(...future.oldEnvVars)
[11:02:15.362]                 envs <- base::Sys.getenv()
[11:02:15.362]                 names <- names(envs)
[11:02:15.362]                 common <- intersect(names, old_names)
[11:02:15.362]                 added <- setdiff(names, old_names)
[11:02:15.362]                 removed <- setdiff(old_names, names)
[11:02:15.362]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:15.362]                   envs[common]]
[11:02:15.362]                 NAMES <- toupper(changed)
[11:02:15.362]                 args <- list()
[11:02:15.362]                 for (kk in seq_along(NAMES)) {
[11:02:15.362]                   name <- changed[[kk]]
[11:02:15.362]                   NAME <- NAMES[[kk]]
[11:02:15.362]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:15.362]                     next
[11:02:15.362]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:15.362]                 }
[11:02:15.362]                 NAMES <- toupper(added)
[11:02:15.362]                 for (kk in seq_along(NAMES)) {
[11:02:15.362]                   name <- added[[kk]]
[11:02:15.362]                   NAME <- NAMES[[kk]]
[11:02:15.362]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:15.362]                     next
[11:02:15.362]                   args[[name]] <- ""
[11:02:15.362]                 }
[11:02:15.362]                 NAMES <- toupper(removed)
[11:02:15.362]                 for (kk in seq_along(NAMES)) {
[11:02:15.362]                   name <- removed[[kk]]
[11:02:15.362]                   NAME <- NAMES[[kk]]
[11:02:15.362]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:15.362]                     next
[11:02:15.362]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:15.362]                 }
[11:02:15.362]                 if (length(args) > 0) 
[11:02:15.362]                   base::do.call(base::Sys.setenv, args = args)
[11:02:15.362]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:15.362]             }
[11:02:15.362]             else {
[11:02:15.362]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:15.362]             }
[11:02:15.362]             {
[11:02:15.362]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:15.362]                   0L) {
[11:02:15.362]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:15.362]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:15.362]                   base::options(opts)
[11:02:15.362]                 }
[11:02:15.362]                 {
[11:02:15.362]                   {
[11:02:15.362]                     NULL
[11:02:15.362]                     RNGkind("Mersenne-Twister")
[11:02:15.362]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:15.362]                       inherits = FALSE)
[11:02:15.362]                   }
[11:02:15.362]                   options(future.plan = NULL)
[11:02:15.362]                   if (is.na(NA_character_)) 
[11:02:15.362]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:15.362]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:15.362]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:15.362]                     .init = FALSE)
[11:02:15.362]                 }
[11:02:15.362]             }
[11:02:15.362]         }
[11:02:15.362]     })
[11:02:15.362]     if (TRUE) {
[11:02:15.362]         base::sink(type = "output", split = FALSE)
[11:02:15.362]         if (TRUE) {
[11:02:15.362]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:15.362]         }
[11:02:15.362]         else {
[11:02:15.362]             ...future.result["stdout"] <- base::list(NULL)
[11:02:15.362]         }
[11:02:15.362]         base::close(...future.stdout)
[11:02:15.362]         ...future.stdout <- NULL
[11:02:15.362]     }
[11:02:15.362]     ...future.result$conditions <- ...future.conditions
[11:02:15.362]     ...future.result$finished <- base::Sys.time()
[11:02:15.362]     ...future.result
[11:02:15.362] }
[11:02:15.364] assign_globals() ...
[11:02:15.364] List of 1
[11:02:15.364]  $ data:'data.frame':	3 obs. of  2 variables:
[11:02:15.364]   ..$ a: int [1:3] 1 2 3
[11:02:15.364]   ..$ b: int [1:3] 3 2 1
[11:02:15.364]  - attr(*, "where")=List of 1
[11:02:15.364]   ..$ data:<environment: R_EmptyEnv> 
[11:02:15.364]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:02:15.364]  - attr(*, "resolved")= logi FALSE
[11:02:15.364]  - attr(*, "total_size")= num 356
[11:02:15.364]  - attr(*, "already-done")= logi TRUE
[11:02:15.367] - copied ‘data’ to environment
[11:02:15.367] assign_globals() ... done
[11:02:15.367] plan(): Setting new future strategy stack:
[11:02:15.367] List of future strategies:
[11:02:15.367] 1. sequential:
[11:02:15.367]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:15.367]    - tweaked: FALSE
[11:02:15.367]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:15.368] plan(): nbrOfWorkers() = 1
[11:02:15.394] plan(): Setting new future strategy stack:
[11:02:15.394] List of future strategies:
[11:02:15.394] 1. sequential:
[11:02:15.394]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:15.394]    - tweaked: FALSE
[11:02:15.394]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:15.394] 2. sequential:
[11:02:15.394]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:15.394]    - tweaked: FALSE
[11:02:15.394]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:15.395] plan(): nbrOfWorkers() = 1
[11:02:15.395] SequentialFuture started (and completed)
[11:02:15.395] signalConditions() ...
[11:02:15.395]  - include = ‘immediateCondition’
[11:02:15.395]  - exclude = 
[11:02:15.396]  - resignal = FALSE
[11:02:15.396]  - Number of conditions: 52
[11:02:15.396] signalConditions() ... done
[11:02:15.396] - Launch lazy future ... done
[11:02:15.396] run() for ‘SequentialFuture’ ... done
[11:02:15.396] signalConditions() ...
[11:02:15.396]  - include = ‘immediateCondition’
[11:02:15.396]  - exclude = 
[11:02:15.396]  - resignal = FALSE
[11:02:15.396]  - Number of conditions: 52
[11:02:15.396] signalConditions() ... done
[11:02:15.397] Future state: ‘finished’
[11:02:15.397] signalConditions() ...
[11:02:15.397]  - include = ‘condition’
[11:02:15.397]  - exclude = ‘immediateCondition’
[11:02:15.397]  - resignal = TRUE
[11:02:15.397]  - Number of conditions: 52
[11:02:15.397]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.368] getGlobalsAndPackages() ...
[11:02:15.397]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.368] Searching for globals...
[11:02:15.397]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.382] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[11:02:15.397]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.382] Searching for globals ... DONE
[11:02:15.397]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.382] Resolving globals: FALSE
[11:02:15.398]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.383] The total size of the 1 globals is 356 bytes (356 bytes)
[11:02:15.398]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.383] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[11:02:15.398]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.383] - globals: [1] ‘data’
[11:02:15.398]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.383] 
[11:02:15.398]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.383] getGlobalsAndPackages() ... DONE
[11:02:15.398]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.384] run() for ‘Future’ ...
[11:02:15.398]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.384] - state: ‘created’
[11:02:15.398]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.384] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:02:15.398]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.384] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:15.399]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.384] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:15.399]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.384]   - Field: ‘label’
[11:02:15.399]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.384]   - Field: ‘local’
[11:02:15.399]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.385]   - Field: ‘owner’
[11:02:15.399]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.385]   - Field: ‘envir’
[11:02:15.399]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.385]   - Field: ‘packages’
[11:02:15.399]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.385]   - Field: ‘gc’
[11:02:15.399]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.385]   - Field: ‘conditions’
[11:02:15.399]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.385]   - Field: ‘expr’
[11:02:15.400]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.385]   - Field: ‘uuid’
[11:02:15.400]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.385]   - Field: ‘seed’
[11:02:15.400]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.385]   - Field: ‘version’
[11:02:15.400]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.385]   - Field: ‘result’
[11:02:15.400]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.386]   - Field: ‘asynchronous’
[11:02:15.400]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.386]   - Field: ‘calls’
[11:02:15.400]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.386]   - Field: ‘globals’
[11:02:15.400]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.386]   - Field: ‘stdout’
[11:02:15.400]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.386]   - Field: ‘earlySignal’
[11:02:15.401]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.386]   - Field: ‘lazy’
[11:02:15.401]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.386]   - Field: ‘state’
[11:02:15.401]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.386] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:15.401]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.386] - Launch lazy future ...
[11:02:15.401]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.386] Packages needed by the future expression (n = 0): <none>
[11:02:15.401]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.387] Packages needed by future strategies (n = 0): <none>
[11:02:15.401]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.387] {
[11:02:15.387]     {
[11:02:15.387]         {
[11:02:15.387]             ...future.startTime <- base::Sys.time()
[11:02:15.387]             {
[11:02:15.387]                 {
[11:02:15.387]                   {
[11:02:15.387]                     base::local({
[11:02:15.387]                       has_future <- base::requireNamespace("future", 
[11:02:15.387]                         quietly = TRUE)
[11:02:15.387]                       if (has_future) {
[11:02:15.387]                         ns <- base::getNamespace("future")
[11:02:15.387]                         version <- ns[[".package"]][["version"]]
[11:02:15.387]                         if (is.null(version)) 
[11:02:15.387]                           version <- utils::packageVersion("future")
[11:02:15.387]                       }
[11:02:15.387]                       else {
[11:02:15.387]                         version <- NULL
[11:02:15.387]                       }
[11:02:15.387]                       if (!has_future || version < "1.8.0") {
[11:02:15.387]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:15.387]                           "", base::R.version$version.string), 
[11:02:15.387]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:15.387]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:15.387]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:15.387]                             "release", "version")], collapse = " "), 
[11:02:15.387]                           hostname = base::Sys.info()[["nodename"]])
[11:02:15.387]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:15.387]                           info)
[11:02:15.387]                         info <- base::paste(info, collapse = "; ")
[11:02:15.387]                         if (!has_future) {
[11:02:15.387]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:15.387]                             info)
[11:02:15.387]                         }
[11:02:15.387]                         else {
[11:02:15.387]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:15.387]                             info, version)
[11:02:15.387]                         }
[11:02:15.387]                         base::stop(msg)
[11:02:15.387]                       }
[11:02:15.387]                     })
[11:02:15.387]                   }
[11:02:15.387]                   ...future.strategy.old <- future::plan("list")
[11:02:15.387]                   options(future.plan = NULL)
[11:02:15.387]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:15.387]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:15.387]                 }
[11:02:15.387]                 ...future.workdir <- getwd()
[11:02:15.387]             }
[11:02:15.387]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:15.387]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:15.387]         }
[11:02:15.387]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:15.387]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:15.387]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:15.387]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:15.387]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:15.387]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:15.387]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:15.387]             base::names(...future.oldOptions))
[11:02:15.387]     }
[11:02:15.387]     if (FALSE) {
[11:02:15.387]     }
[11:02:15.387]     else {
[11:02:15.387]         if (TRUE) {
[11:02:15.387]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:15.387]                 open = "w")
[11:02:15.387]         }
[11:02:15.387]         else {
[11:02:15.387]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:15.387]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:15.387]         }
[11:02:15.387]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:15.387]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:15.387]             base::sink(type = "output", split = FALSE)
[11:02:15.387]             base::close(...future.stdout)
[11:02:15.387]         }, add = TRUE)
[11:02:15.387]     }
[11:02:15.387]     ...future.frame <- base::sys.nframe()
[11:02:15.387]     ...future.conditions <- base::list()
[11:02:15.387]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:15.387]     if (FALSE) {
[11:02:15.387]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:15.387]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:15.387]     }
[11:02:15.387]     ...future.result <- base::tryCatch({
[11:02:15.387]         base::withCallingHandlers({
[11:02:15.387]             ...future.value <- base::withVisible(base::local(subset(data, 
[11:02:15.387]                 a == 2)))
[11:02:15.387]             future::FutureResult(value = ...future.value$value, 
[11:02:15.387]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:15.387]                   ...future.rng), globalenv = if (FALSE) 
[11:02:15.387]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:15.387]                     ...future.globalenv.names))
[11:02:15.387]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:15.387]         }, condition = base::local({
[11:02:15.387]             c <- base::c
[11:02:15.387]             inherits <- base::inherits
[11:02:15.387]             invokeRestart <- base::invokeRestart
[11:02:15.387]             length <- base::length
[11:02:15.387]             list <- base::list
[11:02:15.387]             seq.int <- base::seq.int
[11:02:15.387]             signalCondition <- base::signalCondition
[11:02:15.387]             sys.calls <- base::sys.calls
[11:02:15.387]             `[[` <- base::`[[`
[11:02:15.387]             `+` <- base::`+`
[11:02:15.387]             `<<-` <- base::`<<-`
[11:02:15.387]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:15.387]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:15.387]                   3L)]
[11:02:15.387]             }
[11:02:15.387]             function(cond) {
[11:02:15.387]                 is_error <- inherits(cond, "error")
[11:02:15.387]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:15.387]                   NULL)
[11:02:15.387]                 if (is_error) {
[11:02:15.387]                   sessionInformation <- function() {
[11:02:15.387]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:15.387]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:15.387]                       search = base::search(), system = base::Sys.info())
[11:02:15.387]                   }
[11:02:15.387]                   ...future.conditions[[length(...future.conditions) + 
[11:02:15.387]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:15.387]                     cond$call), session = sessionInformation(), 
[11:02:15.387]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:15.387]                   signalCondition(cond)
[11:02:15.387]                 }
[11:02:15.387]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:15.387]                 "immediateCondition"))) {
[11:02:15.387]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:15.387]                   ...future.conditions[[length(...future.conditions) + 
[11:02:15.387]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:15.387]                   if (TRUE && !signal) {
[11:02:15.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:15.387]                     {
[11:02:15.387]                       inherits <- base::inherits
[11:02:15.387]                       invokeRestart <- base::invokeRestart
[11:02:15.387]                       is.null <- base::is.null
[11:02:15.387]                       muffled <- FALSE
[11:02:15.387]                       if (inherits(cond, "message")) {
[11:02:15.387]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:15.387]                         if (muffled) 
[11:02:15.387]                           invokeRestart("muffleMessage")
[11:02:15.387]                       }
[11:02:15.387]                       else if (inherits(cond, "warning")) {
[11:02:15.387]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:15.387]                         if (muffled) 
[11:02:15.387]                           invokeRestart("muffleWarning")
[11:02:15.387]                       }
[11:02:15.387]                       else if (inherits(cond, "condition")) {
[11:02:15.387]                         if (!is.null(pattern)) {
[11:02:15.387]                           computeRestarts <- base::computeRestarts
[11:02:15.387]                           grepl <- base::grepl
[11:02:15.387]                           restarts <- computeRestarts(cond)
[11:02:15.387]                           for (restart in restarts) {
[11:02:15.387]                             name <- restart$name
[11:02:15.387]                             if (is.null(name)) 
[11:02:15.387]                               next
[11:02:15.387]                             if (!grepl(pattern, name)) 
[11:02:15.387]                               next
[11:02:15.387]                             invokeRestart(restart)
[11:02:15.387]                             muffled <- TRUE
[11:02:15.387]                             break
[11:02:15.387]                           }
[11:02:15.387]                         }
[11:02:15.387]                       }
[11:02:15.387]                       invisible(muffled)
[11:02:15.387]                     }
[11:02:15.387]                     muffleCondition(cond, pattern = "^muffle")
[11:02:15.387]                   }
[11:02:15.387]                 }
[11:02:15.387]                 else {
[11:02:15.387]                   if (TRUE) {
[11:02:15.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:15.387]                     {
[11:02:15.387]                       inherits <- base::inherits
[11:02:15.387]                       invokeRestart <- base::invokeRestart
[11:02:15.387]                       is.null <- base::is.null
[11:02:15.387]                       muffled <- FALSE
[11:02:15.387]                       if (inherits(cond, "message")) {
[11:02:15.387]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:15.387]                         if (muffled) 
[11:02:15.387]                           invokeRestart("muffleMessage")
[11:02:15.387]                       }
[11:02:15.387]                       else if (inherits(cond, "warning")) {
[11:02:15.387]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:15.387]                         if (muffled) 
[11:02:15.387]                           invokeRestart("muffleWarning")
[11:02:15.387]                       }
[11:02:15.387]                       else if (inherits(cond, "condition")) {
[11:02:15.387]                         if (!is.null(pattern)) {
[11:02:15.387]                           computeRestarts <- base::computeRestarts
[11:02:15.387]                           grepl <- base::grepl
[11:02:15.387]                           restarts <- computeRestarts(cond)
[11:02:15.387]                           for (restart in restarts) {
[11:02:15.387]                             name <- restart$name
[11:02:15.387]                             if (is.null(name)) 
[11:02:15.387]                               next
[11:02:15.387]                             if (!grepl(pattern, name)) 
[11:02:15.387]                               next
[11:02:15.387]                             invokeRestart(restart)
[11:02:15.387]                             muffled <- TRUE
[11:02:15.387]                             break
[11:02:15.387]                           }
[11:02:15.387]                         }
[11:02:15.387]                       }
[11:02:15.387]                       invisible(muffled)
[11:02:15.387]                     }
[11:02:15.387]                     muffleCondition(cond, pattern = "^muffle")
[11:02:15.387]                   }
[11:02:15.387]                 }
[11:02:15.387]             }
[11:02:15.387]         }))
[11:02:15.387]     }, error = function(ex) {
[11:02:15.387]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:15.387]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:15.387]                 ...future.rng), started = ...future.startTime, 
[11:02:15.387]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:15.387]             version = "1.8"), class = "FutureResult")
[11:02:15.387]     }, finally = {
[11:02:15.387]         if (!identical(...future.workdir, getwd())) 
[11:02:15.387]             setwd(...future.workdir)
[11:02:15.387]         {
[11:02:15.387]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:15.387]                 ...future.oldOptions$nwarnings <- NULL
[11:02:15.387]             }
[11:02:15.387]             base::options(...future.oldOptions)
[11:02:15.387]             if (.Platform$OS.type == "windows") {
[11:02:15.387]                 old_names <- names(...future.oldEnvVars)
[11:02:15.387]                 envs <- base::Sys.getenv()
[11:02:15.387]                 names <- names(envs)
[11:02:15.387]                 common <- intersect(names, old_names)
[11:02:15.387]                 added <- setdiff(names, old_names)
[11:02:15.387]                 removed <- setdiff(old_names, names)
[11:02:15.387]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:15.387]                   envs[common]]
[11:02:15.387]                 NAMES <- toupper(changed)
[11:02:15.387]                 args <- list()
[11:02:15.387]                 for (kk in seq_along(NAMES)) {
[11:02:15.387]                   name <- changed[[kk]]
[11:02:15.387]                   NAME <- NAMES[[kk]]
[11:02:15.387]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:15.387]                     next
[11:02:15.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:15.387]                 }
[11:02:15.387]                 NAMES <- toupper(added)
[11:02:15.387]                 for (kk in seq_along(NAMES)) {
[11:02:15.387]                   name <- added[[kk]]
[11:02:15.387]                   NAME <- NAMES[[kk]]
[11:02:15.387]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:15.387]                     next
[11:02:15.387]                   args[[name]] <- ""
[11:02:15.387]                 }
[11:02:15.387]                 NAMES <- toupper(removed)
[11:02:15.387]                 for (kk in seq_along(NAMES)) {
[11:02:15.387]                   name <- removed[[kk]]
[11:02:15.387]                   NAME <- NAMES[[kk]]
[11:02:15.387]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:15.387]                     next
[11:02:15.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:15.387]                 }
[11:02:15.387]                 if (length(args) > 0) 
[11:02:15.387]                   base::do.call(base::Sys.setenv, args = args)
[11:02:15.387]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:15.387]             }
[11:02:15.387]             else {
[11:02:15.387]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:15.387]             }
[11:02:15.387]             {
[11:02:15.387]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:15.387]                   0L) {
[11:02:15.387]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:15.387]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:15.387]                   base::options(opts)
[11:02:15.387]                 }
[11:02:15.387]                 {
[11:02:15.387]                   {
[11:02:15.387]                     NULL
[11:02:15.387]                     RNGkind("Mersenne-Twister")
[11:02:15.387]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:15.387]                       inherits = FALSE)
[11:02:15.387]                   }
[11:02:15.387]                   options(future.plan = NULL)
[11:02:15.387]                   if (is.na(NA_character_)) 
[11:02:15.387]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:15.387]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:15.387]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:15.387]                     .init = FALSE)
[11:02:15.387]                 }
[11:02:15.387]             }
[11:02:15.387]         }
[11:02:15.387]     })
[11:02:15.387]     if (TRUE) {
[11:02:15.387]         base::sink(type = "output", split = FALSE)
[11:02:15.387]         if (TRUE) {
[11:02:15.387]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:15.387]         }
[11:02:15.387]         else {
[11:02:15.387]             ...future.result["stdout"] <- base::list(NULL)
[11:02:15.387]         }
[11:02:15.387]         base::close(...future.stdout)
[11:02:15.387]         ...future.stdout <- NULL
[11:02:15.387]     }
[11:02:15.387]     ...future.result$conditions <- ...future.conditions
[11:02:15.387]     ...future.result$finished <- base::Sys.time()
[11:02:15.387]     ...future.result
[11:02:15.387] }
[11:02:15.402]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.388] assign_globals() ...
[11:02:15.402]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.389] List of 1
[11:02:15.389]  $ data:'data.frame':	3 obs. of  2 variables:
[11:02:15.389]   ..$ a: int [1:3] 1 2 3
[11:02:15.389]   ..$ b: int [1:3] 3 2 1
[11:02:15.389]  - attr(*, "where")=List of 1
[11:02:15.389]   ..$ data:<environment: R_EmptyEnv> 
[11:02:15.389]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:02:15.389]  - attr(*, "resolved")= logi FALSE
[11:02:15.389]  - attr(*, "total_size")= num 356
[11:02:15.389]  - attr(*, "already-done")= logi TRUE
[11:02:15.403]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.391] - copied ‘data’ to environment
[11:02:15.403]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.391] assign_globals() ... done
[11:02:15.403]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.392] plan(): Setting new future strategy stack:
[11:02:15.403]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.392] List of future strategies:
[11:02:15.392] 1. sequential:
[11:02:15.392]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:15.392]    - tweaked: FALSE
[11:02:15.392]    - call: NULL
[11:02:15.403]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.392] plan(): nbrOfWorkers() = 1
[11:02:15.403]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.393] plan(): Setting new future strategy stack:
[11:02:15.404]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.393] List of future strategies:
[11:02:15.393] 1. sequential:
[11:02:15.393]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:15.393]    - tweaked: FALSE
[11:02:15.393]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:15.404]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.394] plan(): nbrOfWorkers() = 1
[11:02:15.404]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.394] SequentialFuture started (and completed)
[11:02:15.404]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.394] - Launch lazy future ... done
[11:02:15.404]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.394] run() for ‘SequentialFuture’ ... done
[11:02:15.404] signalConditions() ... done
- plan(list('sequential', 'sequential')) ... DONE
- plan(list('sequential', 'multicore')) ...
[11:02:15.404] plan(): Setting new future strategy stack:
[11:02:15.405] List of future strategies:
[11:02:15.405] 1. sequential:
[11:02:15.405]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:15.405]    - tweaked: FALSE
[11:02:15.405]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:15.405] 2. multicore:
[11:02:15.405]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:15.405]    - tweaked: FALSE
[11:02:15.405]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:15.405] plan(): nbrOfWorkers() = 1
[11:02:15.405] getGlobalsAndPackages() ...
[11:02:15.406] Searching for globals...
[11:02:15.421] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[11:02:15.421] Searching for globals ... DONE
[11:02:15.421] Resolving globals: FALSE
[11:02:15.421] The total size of the 2 globals is 7.79 KiB (7972 bytes)
[11:02:15.422] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 7.79 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (7.74 KiB of class ‘list’) and ‘strategy2’ (48 bytes of class ‘character’)
[11:02:15.422] - globals: [2] ‘nested’, ‘strategy2’
[11:02:15.422] - packages: [1] ‘future’
[11:02:15.422] getGlobalsAndPackages() ... DONE
[11:02:15.422] run() for ‘Future’ ...
[11:02:15.423] - state: ‘created’
[11:02:15.423] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:02:15.423] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:15.423] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:15.423]   - Field: ‘label’
[11:02:15.423]   - Field: ‘local’
[11:02:15.423]   - Field: ‘owner’
[11:02:15.423]   - Field: ‘envir’
[11:02:15.423]   - Field: ‘packages’
[11:02:15.424]   - Field: ‘gc’
[11:02:15.424]   - Field: ‘conditions’
[11:02:15.424]   - Field: ‘expr’
[11:02:15.424]   - Field: ‘uuid’
[11:02:15.424]   - Field: ‘seed’
[11:02:15.424]   - Field: ‘version’
[11:02:15.424]   - Field: ‘result’
[11:02:15.424]   - Field: ‘asynchronous’
[11:02:15.424]   - Field: ‘calls’
[11:02:15.424]   - Field: ‘globals’
[11:02:15.424]   - Field: ‘stdout’
[11:02:15.424]   - Field: ‘earlySignal’
[11:02:15.424]   - Field: ‘lazy’
[11:02:15.425]   - Field: ‘state’
[11:02:15.425] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:15.425] - Launch lazy future ...
[11:02:15.425] Packages needed by the future expression (n = 1): ‘future’
[11:02:15.425] Packages needed by future strategies (n = 1): ‘future’
[11:02:15.425] {
[11:02:15.425]     {
[11:02:15.425]         {
[11:02:15.425]             ...future.startTime <- base::Sys.time()
[11:02:15.425]             {
[11:02:15.425]                 {
[11:02:15.425]                   {
[11:02:15.425]                     {
[11:02:15.425]                       base::local({
[11:02:15.425]                         has_future <- base::requireNamespace("future", 
[11:02:15.425]                           quietly = TRUE)
[11:02:15.425]                         if (has_future) {
[11:02:15.425]                           ns <- base::getNamespace("future")
[11:02:15.425]                           version <- ns[[".package"]][["version"]]
[11:02:15.425]                           if (is.null(version)) 
[11:02:15.425]                             version <- utils::packageVersion("future")
[11:02:15.425]                         }
[11:02:15.425]                         else {
[11:02:15.425]                           version <- NULL
[11:02:15.425]                         }
[11:02:15.425]                         if (!has_future || version < "1.8.0") {
[11:02:15.425]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:15.425]                             "", base::R.version$version.string), 
[11:02:15.425]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:15.425]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:15.425]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:15.425]                               "release", "version")], collapse = " "), 
[11:02:15.425]                             hostname = base::Sys.info()[["nodename"]])
[11:02:15.425]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:15.425]                             info)
[11:02:15.425]                           info <- base::paste(info, collapse = "; ")
[11:02:15.425]                           if (!has_future) {
[11:02:15.425]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:15.425]                               info)
[11:02:15.425]                           }
[11:02:15.425]                           else {
[11:02:15.425]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:15.425]                               info, version)
[11:02:15.425]                           }
[11:02:15.425]                           base::stop(msg)
[11:02:15.425]                         }
[11:02:15.425]                       })
[11:02:15.425]                     }
[11:02:15.425]                     base::local({
[11:02:15.425]                       for (pkg in "future") {
[11:02:15.425]                         base::loadNamespace(pkg)
[11:02:15.425]                         base::library(pkg, character.only = TRUE)
[11:02:15.425]                       }
[11:02:15.425]                     })
[11:02:15.425]                   }
[11:02:15.425]                   ...future.strategy.old <- future::plan("list")
[11:02:15.425]                   options(future.plan = NULL)
[11:02:15.425]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:15.425]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[11:02:15.425]                     envir = parent.frame()) 
[11:02:15.425]                   {
[11:02:15.425]                     default_workers <- missing(workers)
[11:02:15.425]                     if (is.function(workers)) 
[11:02:15.425]                       workers <- workers()
[11:02:15.425]                     workers <- structure(as.integer(workers), 
[11:02:15.425]                       class = class(workers))
[11:02:15.425]                     stop_if_not(is.finite(workers), workers >= 
[11:02:15.425]                       1L)
[11:02:15.425]                     if ((workers == 1L && !inherits(workers, 
[11:02:15.425]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[11:02:15.425]                       if (default_workers) 
[11:02:15.425]                         supportsMulticore(warn = TRUE)
[11:02:15.425]                       return(sequential(..., envir = envir))
[11:02:15.425]                     }
[11:02:15.425]                     oopts <- options(mc.cores = workers)
[11:02:15.425]                     on.exit(options(oopts))
[11:02:15.425]                     future <- MulticoreFuture(..., workers = workers, 
[11:02:15.425]                       envir = envir)
[11:02:15.425]                     if (!future$lazy) 
[11:02:15.425]                       future <- run(future)
[11:02:15.425]                     invisible(future)
[11:02:15.425]                   }), .cleanup = FALSE, .init = FALSE)
[11:02:15.425]                 }
[11:02:15.425]                 ...future.workdir <- getwd()
[11:02:15.425]             }
[11:02:15.425]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:15.425]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:15.425]         }
[11:02:15.425]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:15.425]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:15.425]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:15.425]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:15.425]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:15.425]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:15.425]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:15.425]             base::names(...future.oldOptions))
[11:02:15.425]     }
[11:02:15.425]     if (FALSE) {
[11:02:15.425]     }
[11:02:15.425]     else {
[11:02:15.425]         if (TRUE) {
[11:02:15.425]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:15.425]                 open = "w")
[11:02:15.425]         }
[11:02:15.425]         else {
[11:02:15.425]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:15.425]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:15.425]         }
[11:02:15.425]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:15.425]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:15.425]             base::sink(type = "output", split = FALSE)
[11:02:15.425]             base::close(...future.stdout)
[11:02:15.425]         }, add = TRUE)
[11:02:15.425]     }
[11:02:15.425]     ...future.frame <- base::sys.nframe()
[11:02:15.425]     ...future.conditions <- base::list()
[11:02:15.425]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:15.425]     if (FALSE) {
[11:02:15.425]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:15.425]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:15.425]     }
[11:02:15.425]     ...future.result <- base::tryCatch({
[11:02:15.425]         base::withCallingHandlers({
[11:02:15.425]             ...future.value <- base::withVisible(base::local({
[11:02:15.425]                 a <- 1L
[11:02:15.425]                 plan_a <- unclass(future::plan("list"))
[11:02:15.425]                 nested_a <- nested[-1]
[11:02:15.425]                 stopifnot(length(nested_a) == 1L, length(plan_a) == 
[11:02:15.425]                   1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[11:02:15.425]                   strategy2))
[11:02:15.425]                 for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[11:02:15.425]                   "init") <- NULL
[11:02:15.425]                 for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[11:02:15.425]                   "init") <- NULL
[11:02:15.425]                 stopifnot(all.equal(plan_a, nested_a))
[11:02:15.425]                 y %<-% {
[11:02:15.425]                   b <- 2L
[11:02:15.425]                   plan_b <- future::plan("list")
[11:02:15.425]                   nested_b <- nested_a[-1]
[11:02:15.425]                   stopifnot(length(nested_b) == 0L, length(plan_b) == 
[11:02:15.425]                     1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[11:02:15.425]                     "sequential"))
[11:02:15.425]                   list(a = a, nested_a = nested_a, plan_a = plan_a, 
[11:02:15.425]                     b = b, nested_b = nested_b, plan_b = plan_b)
[11:02:15.425]                 }
[11:02:15.425]                 y
[11:02:15.425]             }))
[11:02:15.425]             future::FutureResult(value = ...future.value$value, 
[11:02:15.425]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:15.425]                   ...future.rng), globalenv = if (FALSE) 
[11:02:15.425]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:15.425]                     ...future.globalenv.names))
[11:02:15.425]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:15.425]         }, condition = base::local({
[11:02:15.425]             c <- base::c
[11:02:15.425]             inherits <- base::inherits
[11:02:15.425]             invokeRestart <- base::invokeRestart
[11:02:15.425]             length <- base::length
[11:02:15.425]             list <- base::list
[11:02:15.425]             seq.int <- base::seq.int
[11:02:15.425]             signalCondition <- base::signalCondition
[11:02:15.425]             sys.calls <- base::sys.calls
[11:02:15.425]             `[[` <- base::`[[`
[11:02:15.425]             `+` <- base::`+`
[11:02:15.425]             `<<-` <- base::`<<-`
[11:02:15.425]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:15.425]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:15.425]                   3L)]
[11:02:15.425]             }
[11:02:15.425]             function(cond) {
[11:02:15.425]                 is_error <- inherits(cond, "error")
[11:02:15.425]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:15.425]                   NULL)
[11:02:15.425]                 if (is_error) {
[11:02:15.425]                   sessionInformation <- function() {
[11:02:15.425]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:15.425]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:15.425]                       search = base::search(), system = base::Sys.info())
[11:02:15.425]                   }
[11:02:15.425]                   ...future.conditions[[length(...future.conditions) + 
[11:02:15.425]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:15.425]                     cond$call), session = sessionInformation(), 
[11:02:15.425]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:15.425]                   signalCondition(cond)
[11:02:15.425]                 }
[11:02:15.425]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:15.425]                 "immediateCondition"))) {
[11:02:15.425]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:15.425]                   ...future.conditions[[length(...future.conditions) + 
[11:02:15.425]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:15.425]                   if (TRUE && !signal) {
[11:02:15.425]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:15.425]                     {
[11:02:15.425]                       inherits <- base::inherits
[11:02:15.425]                       invokeRestart <- base::invokeRestart
[11:02:15.425]                       is.null <- base::is.null
[11:02:15.425]                       muffled <- FALSE
[11:02:15.425]                       if (inherits(cond, "message")) {
[11:02:15.425]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:15.425]                         if (muffled) 
[11:02:15.425]                           invokeRestart("muffleMessage")
[11:02:15.425]                       }
[11:02:15.425]                       else if (inherits(cond, "warning")) {
[11:02:15.425]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:15.425]                         if (muffled) 
[11:02:15.425]                           invokeRestart("muffleWarning")
[11:02:15.425]                       }
[11:02:15.425]                       else if (inherits(cond, "condition")) {
[11:02:15.425]                         if (!is.null(pattern)) {
[11:02:15.425]                           computeRestarts <- base::computeRestarts
[11:02:15.425]                           grepl <- base::grepl
[11:02:15.425]                           restarts <- computeRestarts(cond)
[11:02:15.425]                           for (restart in restarts) {
[11:02:15.425]                             name <- restart$name
[11:02:15.425]                             if (is.null(name)) 
[11:02:15.425]                               next
[11:02:15.425]                             if (!grepl(pattern, name)) 
[11:02:15.425]                               next
[11:02:15.425]                             invokeRestart(restart)
[11:02:15.425]                             muffled <- TRUE
[11:02:15.425]                             break
[11:02:15.425]                           }
[11:02:15.425]                         }
[11:02:15.425]                       }
[11:02:15.425]                       invisible(muffled)
[11:02:15.425]                     }
[11:02:15.425]                     muffleCondition(cond, pattern = "^muffle")
[11:02:15.425]                   }
[11:02:15.425]                 }
[11:02:15.425]                 else {
[11:02:15.425]                   if (TRUE) {
[11:02:15.425]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:15.425]                     {
[11:02:15.425]                       inherits <- base::inherits
[11:02:15.425]                       invokeRestart <- base::invokeRestart
[11:02:15.425]                       is.null <- base::is.null
[11:02:15.425]                       muffled <- FALSE
[11:02:15.425]                       if (inherits(cond, "message")) {
[11:02:15.425]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:15.425]                         if (muffled) 
[11:02:15.425]                           invokeRestart("muffleMessage")
[11:02:15.425]                       }
[11:02:15.425]                       else if (inherits(cond, "warning")) {
[11:02:15.425]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:15.425]                         if (muffled) 
[11:02:15.425]                           invokeRestart("muffleWarning")
[11:02:15.425]                       }
[11:02:15.425]                       else if (inherits(cond, "condition")) {
[11:02:15.425]                         if (!is.null(pattern)) {
[11:02:15.425]                           computeRestarts <- base::computeRestarts
[11:02:15.425]                           grepl <- base::grepl
[11:02:15.425]                           restarts <- computeRestarts(cond)
[11:02:15.425]                           for (restart in restarts) {
[11:02:15.425]                             name <- restart$name
[11:02:15.425]                             if (is.null(name)) 
[11:02:15.425]                               next
[11:02:15.425]                             if (!grepl(pattern, name)) 
[11:02:15.425]                               next
[11:02:15.425]                             invokeRestart(restart)
[11:02:15.425]                             muffled <- TRUE
[11:02:15.425]                             break
[11:02:15.425]                           }
[11:02:15.425]                         }
[11:02:15.425]                       }
[11:02:15.425]                       invisible(muffled)
[11:02:15.425]                     }
[11:02:15.425]                     muffleCondition(cond, pattern = "^muffle")
[11:02:15.425]                   }
[11:02:15.425]                 }
[11:02:15.425]             }
[11:02:15.425]         }))
[11:02:15.425]     }, error = function(ex) {
[11:02:15.425]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:15.425]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:15.425]                 ...future.rng), started = ...future.startTime, 
[11:02:15.425]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:15.425]             version = "1.8"), class = "FutureResult")
[11:02:15.425]     }, finally = {
[11:02:15.425]         if (!identical(...future.workdir, getwd())) 
[11:02:15.425]             setwd(...future.workdir)
[11:02:15.425]         {
[11:02:15.425]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:15.425]                 ...future.oldOptions$nwarnings <- NULL
[11:02:15.425]             }
[11:02:15.425]             base::options(...future.oldOptions)
[11:02:15.425]             if (.Platform$OS.type == "windows") {
[11:02:15.425]                 old_names <- names(...future.oldEnvVars)
[11:02:15.425]                 envs <- base::Sys.getenv()
[11:02:15.425]                 names <- names(envs)
[11:02:15.425]                 common <- intersect(names, old_names)
[11:02:15.425]                 added <- setdiff(names, old_names)
[11:02:15.425]                 removed <- setdiff(old_names, names)
[11:02:15.425]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:15.425]                   envs[common]]
[11:02:15.425]                 NAMES <- toupper(changed)
[11:02:15.425]                 args <- list()
[11:02:15.425]                 for (kk in seq_along(NAMES)) {
[11:02:15.425]                   name <- changed[[kk]]
[11:02:15.425]                   NAME <- NAMES[[kk]]
[11:02:15.425]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:15.425]                     next
[11:02:15.425]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:15.425]                 }
[11:02:15.425]                 NAMES <- toupper(added)
[11:02:15.425]                 for (kk in seq_along(NAMES)) {
[11:02:15.425]                   name <- added[[kk]]
[11:02:15.425]                   NAME <- NAMES[[kk]]
[11:02:15.425]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:15.425]                     next
[11:02:15.425]                   args[[name]] <- ""
[11:02:15.425]                 }
[11:02:15.425]                 NAMES <- toupper(removed)
[11:02:15.425]                 for (kk in seq_along(NAMES)) {
[11:02:15.425]                   name <- removed[[kk]]
[11:02:15.425]                   NAME <- NAMES[[kk]]
[11:02:15.425]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:15.425]                     next
[11:02:15.425]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:15.425]                 }
[11:02:15.425]                 if (length(args) > 0) 
[11:02:15.425]                   base::do.call(base::Sys.setenv, args = args)
[11:02:15.425]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:15.425]             }
[11:02:15.425]             else {
[11:02:15.425]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:15.425]             }
[11:02:15.425]             {
[11:02:15.425]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:15.425]                   0L) {
[11:02:15.425]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:15.425]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:15.425]                   base::options(opts)
[11:02:15.425]                 }
[11:02:15.425]                 {
[11:02:15.425]                   {
[11:02:15.425]                     NULL
[11:02:15.425]                     RNGkind("Mersenne-Twister")
[11:02:15.425]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:15.425]                       inherits = FALSE)
[11:02:15.425]                   }
[11:02:15.425]                   options(future.plan = NULL)
[11:02:15.425]                   if (is.na(NA_character_)) 
[11:02:15.425]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:15.425]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:15.425]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:15.425]                     .init = FALSE)
[11:02:15.425]                 }
[11:02:15.425]             }
[11:02:15.425]         }
[11:02:15.425]     })
[11:02:15.425]     if (TRUE) {
[11:02:15.425]         base::sink(type = "output", split = FALSE)
[11:02:15.425]         if (TRUE) {
[11:02:15.425]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:15.425]         }
[11:02:15.425]         else {
[11:02:15.425]             ...future.result["stdout"] <- base::list(NULL)
[11:02:15.425]         }
[11:02:15.425]         base::close(...future.stdout)
[11:02:15.425]         ...future.stdout <- NULL
[11:02:15.425]     }
[11:02:15.425]     ...future.result$conditions <- ...future.conditions
[11:02:15.425]     ...future.result$finished <- base::Sys.time()
[11:02:15.425]     ...future.result
[11:02:15.425] }
[11:02:15.427] assign_globals() ...
[11:02:15.427] List of 2
[11:02:15.427]  $ nested   :List of 2
[11:02:15.427]   ..$ a:function (..., envir = parent.frame())  
[11:02:15.427]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[11:02:15.427]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[11:02:15.427]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[11:02:15.427]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[11:02:15.427]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[11:02:15.427]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[11:02:15.427]  $ strategy2: chr "multicore"
[11:02:15.427]  - attr(*, "where")=List of 2
[11:02:15.427]   ..$ nested   :<environment: R_EmptyEnv> 
[11:02:15.427]   ..$ strategy2:<environment: R_EmptyEnv> 
[11:02:15.427]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:02:15.427]  - attr(*, "resolved")= logi FALSE
[11:02:15.427]  - attr(*, "total_size")= num 7972
[11:02:15.427]  - attr(*, "already-done")= logi TRUE
[11:02:15.432] - copied ‘nested’ to environment
[11:02:15.432] - copied ‘strategy2’ to environment
[11:02:15.432] assign_globals() ... done
[11:02:15.432] plan(): Setting new future strategy stack:
[11:02:15.432] List of future strategies:
[11:02:15.432] 1. multicore:
[11:02:15.432]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:15.432]    - tweaked: FALSE
[11:02:15.432]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:15.434] plan(): nbrOfWorkers() = 2
[11:02:15.483] plan(): Setting new future strategy stack:
[11:02:15.483] List of future strategies:
[11:02:15.483] 1. sequential:
[11:02:15.483]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:15.483]    - tweaked: FALSE
[11:02:15.483]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:15.483] 2. multicore:
[11:02:15.483]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:15.483]    - tweaked: FALSE
[11:02:15.483]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:15.484] plan(): nbrOfWorkers() = 1
[11:02:15.484] SequentialFuture started (and completed)
[11:02:15.484] signalConditions() ...
[11:02:15.484]  - include = ‘immediateCondition’
[11:02:15.485]  - exclude = 
[11:02:15.485]  - resignal = FALSE
[11:02:15.485]  - Number of conditions: 57
[11:02:15.485] signalConditions() ... done
[11:02:15.485] - Launch lazy future ... done
[11:02:15.485] run() for ‘SequentialFuture’ ... done
[11:02:15.485] signalConditions() ...
[11:02:15.485]  - include = ‘immediateCondition’
[11:02:15.486]  - exclude = 
[11:02:15.486]  - resignal = FALSE
[11:02:15.486]  - Number of conditions: 57
[11:02:15.486] signalConditions() ... done
[11:02:15.486] Future state: ‘finished’
[11:02:15.486] signalConditions() ...
[11:02:15.486]  - include = ‘condition’
[11:02:15.486]  - exclude = ‘immediateCondition’
[11:02:15.486]  - resignal = TRUE
[11:02:15.487]  - Number of conditions: 57
[11:02:15.487]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.435] getGlobalsAndPackages() ...
[11:02:15.487]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.435] Searching for globals...
[11:02:15.487]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.452] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[11:02:15.487]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.452] Searching for globals ... DONE
[11:02:15.487]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.452] Resolving globals: FALSE
[11:02:15.487]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.453] The total size of the 3 globals is 12.54 KiB (12841 bytes)
[11:02:15.488]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.453] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 12.54 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (6.25 KiB of class ‘list’), ‘plan_a’ (6.25 KiB of class ‘list’) and ‘a’ (35 bytes of class ‘numeric’)
[11:02:15.488]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.453] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[11:02:15.488]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.453] 
[11:02:15.488]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.453] getGlobalsAndPackages() ... DONE
[11:02:15.488]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.454] run() for ‘Future’ ...
[11:02:15.488]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.454] - state: ‘created’
[11:02:15.488]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.454] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:02:15.489]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.455] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:15.489]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.456] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:02:15.489]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.456]   - Field: ‘label’
[11:02:15.489]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.456]   - Field: ‘local’
[11:02:15.489]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.456]   - Field: ‘owner’
[11:02:15.489]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.456]   - Field: ‘envir’
[11:02:15.489]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.456]   - Field: ‘workers’
[11:02:15.490]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.456]   - Field: ‘packages’
[11:02:15.490]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.456]   - Field: ‘gc’
[11:02:15.490]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.456]   - Field: ‘job’
[11:02:15.490]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.457]   - Field: ‘conditions’
[11:02:15.490]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.457]   - Field: ‘expr’
[11:02:15.490]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.457]   - Field: ‘uuid’
[11:02:15.490]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.457]   - Field: ‘seed’
[11:02:15.491]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.457]   - Field: ‘version’
[11:02:15.491]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.458]   - Field: ‘result’
[11:02:15.491]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.458]   - Field: ‘asynchronous’
[11:02:15.491]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.458]   - Field: ‘calls’
[11:02:15.491]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.458]   - Field: ‘globals’
[11:02:15.491]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.458]   - Field: ‘stdout’
[11:02:15.492]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.458]   - Field: ‘earlySignal’
[11:02:15.492]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.458]   - Field: ‘lazy’
[11:02:15.492]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.458]   - Field: ‘state’
[11:02:15.492]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.459] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:02:15.492]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.459] - Launch lazy future ...
[11:02:15.492]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.459] Packages needed by the future expression (n = 0): <none>
[11:02:15.492]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.460] Packages needed by future strategies (n = 0): <none>
[11:02:15.492]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.460] {
[11:02:15.460]     {
[11:02:15.460]         {
[11:02:15.460]             ...future.startTime <- base::Sys.time()
[11:02:15.460]             {
[11:02:15.460]                 {
[11:02:15.460]                   {
[11:02:15.460]                     {
[11:02:15.460]                       base::local({
[11:02:15.460]                         has_future <- base::requireNamespace("future", 
[11:02:15.460]                           quietly = TRUE)
[11:02:15.460]                         if (has_future) {
[11:02:15.460]                           ns <- base::getNamespace("future")
[11:02:15.460]                           version <- ns[[".package"]][["version"]]
[11:02:15.460]                           if (is.null(version)) 
[11:02:15.460]                             version <- utils::packageVersion("future")
[11:02:15.460]                         }
[11:02:15.460]                         else {
[11:02:15.460]                           version <- NULL
[11:02:15.460]                         }
[11:02:15.460]                         if (!has_future || version < "1.8.0") {
[11:02:15.460]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:15.460]                             "", base::R.version$version.string), 
[11:02:15.460]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:15.460]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:15.460]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:15.460]                               "release", "version")], collapse = " "), 
[11:02:15.460]                             hostname = base::Sys.info()[["nodename"]])
[11:02:15.460]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:15.460]                             info)
[11:02:15.460]                           info <- base::paste(info, collapse = "; ")
[11:02:15.460]                           if (!has_future) {
[11:02:15.460]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:15.460]                               info)
[11:02:15.460]                           }
[11:02:15.460]                           else {
[11:02:15.460]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:15.460]                               info, version)
[11:02:15.460]                           }
[11:02:15.460]                           base::stop(msg)
[11:02:15.460]                         }
[11:02:15.460]                       })
[11:02:15.460]                     }
[11:02:15.460]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:15.460]                     base::options(mc.cores = 1L)
[11:02:15.460]                   }
[11:02:15.460]                   ...future.strategy.old <- future::plan("list")
[11:02:15.460]                   options(future.plan = NULL)
[11:02:15.460]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:15.460]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:15.460]                 }
[11:02:15.460]                 ...future.workdir <- getwd()
[11:02:15.460]             }
[11:02:15.460]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:15.460]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:15.460]         }
[11:02:15.460]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:15.460]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:15.460]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:15.460]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:15.460]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:15.460]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:15.460]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:15.460]             base::names(...future.oldOptions))
[11:02:15.460]     }
[11:02:15.460]     if (FALSE) {
[11:02:15.460]     }
[11:02:15.460]     else {
[11:02:15.460]         if (TRUE) {
[11:02:15.460]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:15.460]                 open = "w")
[11:02:15.460]         }
[11:02:15.460]         else {
[11:02:15.460]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:15.460]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:15.460]         }
[11:02:15.460]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:15.460]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:15.460]             base::sink(type = "output", split = FALSE)
[11:02:15.460]             base::close(...future.stdout)
[11:02:15.460]         }, add = TRUE)
[11:02:15.460]     }
[11:02:15.460]     ...future.frame <- base::sys.nframe()
[11:02:15.460]     ...future.conditions <- base::list()
[11:02:15.460]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:15.460]     if (FALSE) {
[11:02:15.460]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:15.460]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:15.460]     }
[11:02:15.460]     ...future.result <- base::tryCatch({
[11:02:15.460]         base::withCallingHandlers({
[11:02:15.460]             ...future.value <- base::withVisible(base::local({
[11:02:15.460]                 withCallingHandlers({
[11:02:15.460]                   {
[11:02:15.460]                     b <- 2L
[11:02:15.460]                     plan_b <- future::plan("list")
[11:02:15.460]                     nested_b <- nested_a[-1]
[11:02:15.460]                     stopifnot(length(nested_b) == 0L, length(plan_b) == 
[11:02:15.460]                       1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[11:02:15.460]                       "sequential"))
[11:02:15.460]                     list(a = a, nested_a = nested_a, plan_a = plan_a, 
[11:02:15.460]                       b = b, nested_b = nested_b, plan_b = plan_b)
[11:02:15.460]                   }
[11:02:15.460]                 }, immediateCondition = function(cond) {
[11:02:15.460]                   save_rds <- function (object, pathname, ...) 
[11:02:15.460]                   {
[11:02:15.460]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:02:15.460]                     if (file_test("-f", pathname_tmp)) {
[11:02:15.460]                       fi_tmp <- file.info(pathname_tmp)
[11:02:15.460]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:02:15.460]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:15.460]                         fi_tmp[["mtime"]])
[11:02:15.460]                     }
[11:02:15.460]                     tryCatch({
[11:02:15.460]                       saveRDS(object, file = pathname_tmp, ...)
[11:02:15.460]                     }, error = function(ex) {
[11:02:15.460]                       msg <- conditionMessage(ex)
[11:02:15.460]                       fi_tmp <- file.info(pathname_tmp)
[11:02:15.460]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:02:15.460]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:15.460]                         fi_tmp[["mtime"]], msg)
[11:02:15.460]                       ex$message <- msg
[11:02:15.460]                       stop(ex)
[11:02:15.460]                     })
[11:02:15.460]                     stopifnot(file_test("-f", pathname_tmp))
[11:02:15.460]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:02:15.460]                     if (!res || file_test("-f", pathname_tmp)) {
[11:02:15.460]                       fi_tmp <- file.info(pathname_tmp)
[11:02:15.460]                       fi <- file.info(pathname)
[11:02:15.460]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:02:15.460]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:15.460]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:02:15.460]                         fi[["size"]], fi[["mtime"]])
[11:02:15.460]                       stop(msg)
[11:02:15.460]                     }
[11:02:15.460]                     invisible(pathname)
[11:02:15.460]                   }
[11:02:15.460]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:02:15.460]                     rootPath = tempdir()) 
[11:02:15.460]                   {
[11:02:15.460]                     obj <- list(time = Sys.time(), condition = cond)
[11:02:15.460]                     file <- tempfile(pattern = class(cond)[1], 
[11:02:15.460]                       tmpdir = path, fileext = ".rds")
[11:02:15.460]                     save_rds(obj, file)
[11:02:15.460]                   }
[11:02:15.460]                   saveImmediateCondition(cond, path = "/tmp/RtmpVZPEla/.future/immediateConditions")
[11:02:15.460]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:15.460]                   {
[11:02:15.460]                     inherits <- base::inherits
[11:02:15.460]                     invokeRestart <- base::invokeRestart
[11:02:15.460]                     is.null <- base::is.null
[11:02:15.460]                     muffled <- FALSE
[11:02:15.460]                     if (inherits(cond, "message")) {
[11:02:15.460]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:15.460]                       if (muffled) 
[11:02:15.460]                         invokeRestart("muffleMessage")
[11:02:15.460]                     }
[11:02:15.460]                     else if (inherits(cond, "warning")) {
[11:02:15.460]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:15.460]                       if (muffled) 
[11:02:15.460]                         invokeRestart("muffleWarning")
[11:02:15.460]                     }
[11:02:15.460]                     else if (inherits(cond, "condition")) {
[11:02:15.460]                       if (!is.null(pattern)) {
[11:02:15.460]                         computeRestarts <- base::computeRestarts
[11:02:15.460]                         grepl <- base::grepl
[11:02:15.460]                         restarts <- computeRestarts(cond)
[11:02:15.460]                         for (restart in restarts) {
[11:02:15.460]                           name <- restart$name
[11:02:15.460]                           if (is.null(name)) 
[11:02:15.460]                             next
[11:02:15.460]                           if (!grepl(pattern, name)) 
[11:02:15.460]                             next
[11:02:15.460]                           invokeRestart(restart)
[11:02:15.460]                           muffled <- TRUE
[11:02:15.460]                           break
[11:02:15.460]                         }
[11:02:15.460]                       }
[11:02:15.460]                     }
[11:02:15.460]                     invisible(muffled)
[11:02:15.460]                   }
[11:02:15.460]                   muffleCondition(cond)
[11:02:15.460]                 })
[11:02:15.460]             }))
[11:02:15.460]             future::FutureResult(value = ...future.value$value, 
[11:02:15.460]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:15.460]                   ...future.rng), globalenv = if (FALSE) 
[11:02:15.460]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:15.460]                     ...future.globalenv.names))
[11:02:15.460]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:15.460]         }, condition = base::local({
[11:02:15.460]             c <- base::c
[11:02:15.460]             inherits <- base::inherits
[11:02:15.460]             invokeRestart <- base::invokeRestart
[11:02:15.460]             length <- base::length
[11:02:15.460]             list <- base::list
[11:02:15.460]             seq.int <- base::seq.int
[11:02:15.460]             signalCondition <- base::signalCondition
[11:02:15.460]             sys.calls <- base::sys.calls
[11:02:15.460]             `[[` <- base::`[[`
[11:02:15.460]             `+` <- base::`+`
[11:02:15.460]             `<<-` <- base::`<<-`
[11:02:15.460]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:15.460]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:15.460]                   3L)]
[11:02:15.460]             }
[11:02:15.460]             function(cond) {
[11:02:15.460]                 is_error <- inherits(cond, "error")
[11:02:15.460]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:15.460]                   NULL)
[11:02:15.460]                 if (is_error) {
[11:02:15.460]                   sessionInformation <- function() {
[11:02:15.460]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:15.460]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:15.460]                       search = base::search(), system = base::Sys.info())
[11:02:15.460]                   }
[11:02:15.460]                   ...future.conditions[[length(...future.conditions) + 
[11:02:15.460]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:15.460]                     cond$call), session = sessionInformation(), 
[11:02:15.460]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:15.460]                   signalCondition(cond)
[11:02:15.460]                 }
[11:02:15.460]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:15.460]                 "immediateCondition"))) {
[11:02:15.460]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:15.460]                   ...future.conditions[[length(...future.conditions) + 
[11:02:15.460]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:15.460]                   if (TRUE && !signal) {
[11:02:15.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:15.460]                     {
[11:02:15.460]                       inherits <- base::inherits
[11:02:15.460]                       invokeRestart <- base::invokeRestart
[11:02:15.460]                       is.null <- base::is.null
[11:02:15.460]                       muffled <- FALSE
[11:02:15.460]                       if (inherits(cond, "message")) {
[11:02:15.460]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:15.460]                         if (muffled) 
[11:02:15.460]                           invokeRestart("muffleMessage")
[11:02:15.460]                       }
[11:02:15.460]                       else if (inherits(cond, "warning")) {
[11:02:15.460]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:15.460]                         if (muffled) 
[11:02:15.460]                           invokeRestart("muffleWarning")
[11:02:15.460]                       }
[11:02:15.460]                       else if (inherits(cond, "condition")) {
[11:02:15.460]                         if (!is.null(pattern)) {
[11:02:15.460]                           computeRestarts <- base::computeRestarts
[11:02:15.460]                           grepl <- base::grepl
[11:02:15.460]                           restarts <- computeRestarts(cond)
[11:02:15.460]                           for (restart in restarts) {
[11:02:15.460]                             name <- restart$name
[11:02:15.460]                             if (is.null(name)) 
[11:02:15.460]                               next
[11:02:15.460]                             if (!grepl(pattern, name)) 
[11:02:15.460]                               next
[11:02:15.460]                             invokeRestart(restart)
[11:02:15.460]                             muffled <- TRUE
[11:02:15.460]                             break
[11:02:15.460]                           }
[11:02:15.460]                         }
[11:02:15.460]                       }
[11:02:15.460]                       invisible(muffled)
[11:02:15.460]                     }
[11:02:15.460]                     muffleCondition(cond, pattern = "^muffle")
[11:02:15.460]                   }
[11:02:15.460]                 }
[11:02:15.460]                 else {
[11:02:15.460]                   if (TRUE) {
[11:02:15.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:15.460]                     {
[11:02:15.460]                       inherits <- base::inherits
[11:02:15.460]                       invokeRestart <- base::invokeRestart
[11:02:15.460]                       is.null <- base::is.null
[11:02:15.460]                       muffled <- FALSE
[11:02:15.460]                       if (inherits(cond, "message")) {
[11:02:15.460]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:15.460]                         if (muffled) 
[11:02:15.460]                           invokeRestart("muffleMessage")
[11:02:15.460]                       }
[11:02:15.460]                       else if (inherits(cond, "warning")) {
[11:02:15.460]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:15.460]                         if (muffled) 
[11:02:15.460]                           invokeRestart("muffleWarning")
[11:02:15.460]                       }
[11:02:15.460]                       else if (inherits(cond, "condition")) {
[11:02:15.460]                         if (!is.null(pattern)) {
[11:02:15.460]                           computeRestarts <- base::computeRestarts
[11:02:15.460]                           grepl <- base::grepl
[11:02:15.460]                           restarts <- computeRestarts(cond)
[11:02:15.460]                           for (restart in restarts) {
[11:02:15.460]                             name <- restart$name
[11:02:15.460]                             if (is.null(name)) 
[11:02:15.460]                               next
[11:02:15.460]                             if (!grepl(pattern, name)) 
[11:02:15.460]                               next
[11:02:15.460]                             invokeRestart(restart)
[11:02:15.460]                             muffled <- TRUE
[11:02:15.460]                             break
[11:02:15.460]                           }
[11:02:15.460]                         }
[11:02:15.460]                       }
[11:02:15.460]                       invisible(muffled)
[11:02:15.460]                     }
[11:02:15.460]                     muffleCondition(cond, pattern = "^muffle")
[11:02:15.460]                   }
[11:02:15.460]                 }
[11:02:15.460]             }
[11:02:15.460]         }))
[11:02:15.460]     }, error = function(ex) {
[11:02:15.460]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:15.460]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:15.460]                 ...future.rng), started = ...future.startTime, 
[11:02:15.460]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:15.460]             version = "1.8"), class = "FutureResult")
[11:02:15.460]     }, finally = {
[11:02:15.460]         if (!identical(...future.workdir, getwd())) 
[11:02:15.460]             setwd(...future.workdir)
[11:02:15.460]         {
[11:02:15.460]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:15.460]                 ...future.oldOptions$nwarnings <- NULL
[11:02:15.460]             }
[11:02:15.460]             base::options(...future.oldOptions)
[11:02:15.460]             if (.Platform$OS.type == "windows") {
[11:02:15.460]                 old_names <- names(...future.oldEnvVars)
[11:02:15.460]                 envs <- base::Sys.getenv()
[11:02:15.460]                 names <- names(envs)
[11:02:15.460]                 common <- intersect(names, old_names)
[11:02:15.460]                 added <- setdiff(names, old_names)
[11:02:15.460]                 removed <- setdiff(old_names, names)
[11:02:15.460]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:15.460]                   envs[common]]
[11:02:15.460]                 NAMES <- toupper(changed)
[11:02:15.460]                 args <- list()
[11:02:15.460]                 for (kk in seq_along(NAMES)) {
[11:02:15.460]                   name <- changed[[kk]]
[11:02:15.460]                   NAME <- NAMES[[kk]]
[11:02:15.460]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:15.460]                     next
[11:02:15.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:15.460]                 }
[11:02:15.460]                 NAMES <- toupper(added)
[11:02:15.460]                 for (kk in seq_along(NAMES)) {
[11:02:15.460]                   name <- added[[kk]]
[11:02:15.460]                   NAME <- NAMES[[kk]]
[11:02:15.460]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:15.460]                     next
[11:02:15.460]                   args[[name]] <- ""
[11:02:15.460]                 }
[11:02:15.460]                 NAMES <- toupper(removed)
[11:02:15.460]                 for (kk in seq_along(NAMES)) {
[11:02:15.460]                   name <- removed[[kk]]
[11:02:15.460]                   NAME <- NAMES[[kk]]
[11:02:15.460]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:15.460]                     next
[11:02:15.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:15.460]                 }
[11:02:15.460]                 if (length(args) > 0) 
[11:02:15.460]                   base::do.call(base::Sys.setenv, args = args)
[11:02:15.460]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:15.460]             }
[11:02:15.460]             else {
[11:02:15.460]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:15.460]             }
[11:02:15.460]             {
[11:02:15.460]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:15.460]                   0L) {
[11:02:15.460]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:15.460]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:15.460]                   base::options(opts)
[11:02:15.460]                 }
[11:02:15.460]                 {
[11:02:15.460]                   {
[11:02:15.460]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:15.460]                     NULL
[11:02:15.460]                   }
[11:02:15.460]                   options(future.plan = NULL)
[11:02:15.460]                   if (is.na(NA_character_)) 
[11:02:15.460]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:15.460]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:15.460]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:15.460]                     .init = FALSE)
[11:02:15.460]                 }
[11:02:15.460]             }
[11:02:15.460]         }
[11:02:15.460]     })
[11:02:15.460]     if (TRUE) {
[11:02:15.460]         base::sink(type = "output", split = FALSE)
[11:02:15.460]         if (TRUE) {
[11:02:15.460]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:15.460]         }
[11:02:15.460]         else {
[11:02:15.460]             ...future.result["stdout"] <- base::list(NULL)
[11:02:15.460]         }
[11:02:15.460]         base::close(...future.stdout)
[11:02:15.460]         ...future.stdout <- NULL
[11:02:15.460]     }
[11:02:15.460]     ...future.result$conditions <- ...future.conditions
[11:02:15.460]     ...future.result$finished <- base::Sys.time()
[11:02:15.460]     ...future.result
[11:02:15.460] }
[11:02:15.493]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.462] assign_globals() ...
[11:02:15.493]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.462] List of 3
[11:02:15.462]  $ nested_a:List of 1
[11:02:15.462]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[11:02:15.462]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[11:02:15.462]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[11:02:15.462]  $ a       : int 1
[11:02:15.462]  $ plan_a  :List of 1
[11:02:15.462]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[11:02:15.462]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[11:02:15.462]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[11:02:15.462]  - attr(*, "where")=List of 3
[11:02:15.462]   ..$ nested_a:<environment: R_EmptyEnv> 
[11:02:15.462]   ..$ a       :<environment: R_EmptyEnv> 
[11:02:15.462]   ..$ plan_a  :<environment: R_EmptyEnv> 
[11:02:15.462]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:02:15.462]  - attr(*, "resolved")= logi FALSE
[11:02:15.462]  - attr(*, "total_size")= num 12841
[11:02:15.462]  - attr(*, "already-done")= logi TRUE
[11:02:15.495]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.467] - copied ‘nested_a’ to environment
[11:02:15.496]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.467] - copied ‘a’ to environment
[11:02:15.496]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.467] - copied ‘plan_a’ to environment
[11:02:15.496]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.467] assign_globals() ... done
[11:02:15.496]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.467] requestCore(): workers = 2
[11:02:15.496]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.470] MulticoreFuture started
[11:02:15.496]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.471] - Launch lazy future ... done
[11:02:15.497]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.471] run() for ‘MulticoreFuture’ ... done
[11:02:15.497]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.472] result() for MulticoreFuture ...
[11:02:15.497]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.482] result() for MulticoreFuture ...
[11:02:15.497]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.482] result() for MulticoreFuture ... done
[11:02:15.497]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.482] result() for MulticoreFuture ... done
[11:02:15.497]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.482] result() for MulticoreFuture ...
[11:02:15.497]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.482] result() for MulticoreFuture ... done
[11:02:15.498] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[11:02:15.503] getGlobalsAndPackages() ...
[11:02:15.503] Searching for globals...
[11:02:15.505] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[11:02:15.505] Searching for globals ... DONE
[11:02:15.505] Resolving globals: FALSE
[11:02:15.506] The total size of the 1 globals is 356 bytes (356 bytes)
[11:02:15.506] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[11:02:15.506] - globals: [1] ‘data’
[11:02:15.506] - packages: [1] ‘future’
[11:02:15.506] getGlobalsAndPackages() ... DONE
[11:02:15.507] run() for ‘Future’ ...
[11:02:15.507] - state: ‘created’
[11:02:15.507] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:02:15.507] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:15.507] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:15.507]   - Field: ‘label’
[11:02:15.507]   - Field: ‘local’
[11:02:15.507]   - Field: ‘owner’
[11:02:15.507]   - Field: ‘envir’
[11:02:15.508]   - Field: ‘packages’
[11:02:15.508]   - Field: ‘gc’
[11:02:15.508]   - Field: ‘conditions’
[11:02:15.508]   - Field: ‘expr’
[11:02:15.508]   - Field: ‘uuid’
[11:02:15.508]   - Field: ‘seed’
[11:02:15.508]   - Field: ‘version’
[11:02:15.508]   - Field: ‘result’
[11:02:15.508]   - Field: ‘asynchronous’
[11:02:15.508]   - Field: ‘calls’
[11:02:15.508]   - Field: ‘globals’
[11:02:15.508]   - Field: ‘stdout’
[11:02:15.508]   - Field: ‘earlySignal’
[11:02:15.509]   - Field: ‘lazy’
[11:02:15.509]   - Field: ‘state’
[11:02:15.509] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:15.509] - Launch lazy future ...
[11:02:15.509] Packages needed by the future expression (n = 1): ‘future’
[11:02:15.509] Packages needed by future strategies (n = 1): ‘future’
[11:02:15.510] {
[11:02:15.510]     {
[11:02:15.510]         {
[11:02:15.510]             ...future.startTime <- base::Sys.time()
[11:02:15.510]             {
[11:02:15.510]                 {
[11:02:15.510]                   {
[11:02:15.510]                     {
[11:02:15.510]                       base::local({
[11:02:15.510]                         has_future <- base::requireNamespace("future", 
[11:02:15.510]                           quietly = TRUE)
[11:02:15.510]                         if (has_future) {
[11:02:15.510]                           ns <- base::getNamespace("future")
[11:02:15.510]                           version <- ns[[".package"]][["version"]]
[11:02:15.510]                           if (is.null(version)) 
[11:02:15.510]                             version <- utils::packageVersion("future")
[11:02:15.510]                         }
[11:02:15.510]                         else {
[11:02:15.510]                           version <- NULL
[11:02:15.510]                         }
[11:02:15.510]                         if (!has_future || version < "1.8.0") {
[11:02:15.510]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:15.510]                             "", base::R.version$version.string), 
[11:02:15.510]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:15.510]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:15.510]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:15.510]                               "release", "version")], collapse = " "), 
[11:02:15.510]                             hostname = base::Sys.info()[["nodename"]])
[11:02:15.510]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:15.510]                             info)
[11:02:15.510]                           info <- base::paste(info, collapse = "; ")
[11:02:15.510]                           if (!has_future) {
[11:02:15.510]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:15.510]                               info)
[11:02:15.510]                           }
[11:02:15.510]                           else {
[11:02:15.510]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:15.510]                               info, version)
[11:02:15.510]                           }
[11:02:15.510]                           base::stop(msg)
[11:02:15.510]                         }
[11:02:15.510]                       })
[11:02:15.510]                     }
[11:02:15.510]                     base::local({
[11:02:15.510]                       for (pkg in "future") {
[11:02:15.510]                         base::loadNamespace(pkg)
[11:02:15.510]                         base::library(pkg, character.only = TRUE)
[11:02:15.510]                       }
[11:02:15.510]                     })
[11:02:15.510]                   }
[11:02:15.510]                   ...future.strategy.old <- future::plan("list")
[11:02:15.510]                   options(future.plan = NULL)
[11:02:15.510]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:15.510]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[11:02:15.510]                     envir = parent.frame()) 
[11:02:15.510]                   {
[11:02:15.510]                     default_workers <- missing(workers)
[11:02:15.510]                     if (is.function(workers)) 
[11:02:15.510]                       workers <- workers()
[11:02:15.510]                     workers <- structure(as.integer(workers), 
[11:02:15.510]                       class = class(workers))
[11:02:15.510]                     stop_if_not(is.finite(workers), workers >= 
[11:02:15.510]                       1L)
[11:02:15.510]                     if ((workers == 1L && !inherits(workers, 
[11:02:15.510]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[11:02:15.510]                       if (default_workers) 
[11:02:15.510]                         supportsMulticore(warn = TRUE)
[11:02:15.510]                       return(sequential(..., envir = envir))
[11:02:15.510]                     }
[11:02:15.510]                     oopts <- options(mc.cores = workers)
[11:02:15.510]                     on.exit(options(oopts))
[11:02:15.510]                     future <- MulticoreFuture(..., workers = workers, 
[11:02:15.510]                       envir = envir)
[11:02:15.510]                     if (!future$lazy) 
[11:02:15.510]                       future <- run(future)
[11:02:15.510]                     invisible(future)
[11:02:15.510]                   }), .cleanup = FALSE, .init = FALSE)
[11:02:15.510]                 }
[11:02:15.510]                 ...future.workdir <- getwd()
[11:02:15.510]             }
[11:02:15.510]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:15.510]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:15.510]         }
[11:02:15.510]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:15.510]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:15.510]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:15.510]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:15.510]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:15.510]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:15.510]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:15.510]             base::names(...future.oldOptions))
[11:02:15.510]     }
[11:02:15.510]     if (FALSE) {
[11:02:15.510]     }
[11:02:15.510]     else {
[11:02:15.510]         if (TRUE) {
[11:02:15.510]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:15.510]                 open = "w")
[11:02:15.510]         }
[11:02:15.510]         else {
[11:02:15.510]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:15.510]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:15.510]         }
[11:02:15.510]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:15.510]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:15.510]             base::sink(type = "output", split = FALSE)
[11:02:15.510]             base::close(...future.stdout)
[11:02:15.510]         }, add = TRUE)
[11:02:15.510]     }
[11:02:15.510]     ...future.frame <- base::sys.nframe()
[11:02:15.510]     ...future.conditions <- base::list()
[11:02:15.510]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:15.510]     if (FALSE) {
[11:02:15.510]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:15.510]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:15.510]     }
[11:02:15.510]     ...future.result <- base::tryCatch({
[11:02:15.510]         base::withCallingHandlers({
[11:02:15.510]             ...future.value <- base::withVisible(base::local({
[11:02:15.510]                 value(future(subset(data, a == 2)))
[11:02:15.510]             }))
[11:02:15.510]             future::FutureResult(value = ...future.value$value, 
[11:02:15.510]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:15.510]                   ...future.rng), globalenv = if (FALSE) 
[11:02:15.510]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:15.510]                     ...future.globalenv.names))
[11:02:15.510]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:15.510]         }, condition = base::local({
[11:02:15.510]             c <- base::c
[11:02:15.510]             inherits <- base::inherits
[11:02:15.510]             invokeRestart <- base::invokeRestart
[11:02:15.510]             length <- base::length
[11:02:15.510]             list <- base::list
[11:02:15.510]             seq.int <- base::seq.int
[11:02:15.510]             signalCondition <- base::signalCondition
[11:02:15.510]             sys.calls <- base::sys.calls
[11:02:15.510]             `[[` <- base::`[[`
[11:02:15.510]             `+` <- base::`+`
[11:02:15.510]             `<<-` <- base::`<<-`
[11:02:15.510]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:15.510]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:15.510]                   3L)]
[11:02:15.510]             }
[11:02:15.510]             function(cond) {
[11:02:15.510]                 is_error <- inherits(cond, "error")
[11:02:15.510]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:15.510]                   NULL)
[11:02:15.510]                 if (is_error) {
[11:02:15.510]                   sessionInformation <- function() {
[11:02:15.510]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:15.510]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:15.510]                       search = base::search(), system = base::Sys.info())
[11:02:15.510]                   }
[11:02:15.510]                   ...future.conditions[[length(...future.conditions) + 
[11:02:15.510]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:15.510]                     cond$call), session = sessionInformation(), 
[11:02:15.510]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:15.510]                   signalCondition(cond)
[11:02:15.510]                 }
[11:02:15.510]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:15.510]                 "immediateCondition"))) {
[11:02:15.510]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:15.510]                   ...future.conditions[[length(...future.conditions) + 
[11:02:15.510]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:15.510]                   if (TRUE && !signal) {
[11:02:15.510]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:15.510]                     {
[11:02:15.510]                       inherits <- base::inherits
[11:02:15.510]                       invokeRestart <- base::invokeRestart
[11:02:15.510]                       is.null <- base::is.null
[11:02:15.510]                       muffled <- FALSE
[11:02:15.510]                       if (inherits(cond, "message")) {
[11:02:15.510]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:15.510]                         if (muffled) 
[11:02:15.510]                           invokeRestart("muffleMessage")
[11:02:15.510]                       }
[11:02:15.510]                       else if (inherits(cond, "warning")) {
[11:02:15.510]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:15.510]                         if (muffled) 
[11:02:15.510]                           invokeRestart("muffleWarning")
[11:02:15.510]                       }
[11:02:15.510]                       else if (inherits(cond, "condition")) {
[11:02:15.510]                         if (!is.null(pattern)) {
[11:02:15.510]                           computeRestarts <- base::computeRestarts
[11:02:15.510]                           grepl <- base::grepl
[11:02:15.510]                           restarts <- computeRestarts(cond)
[11:02:15.510]                           for (restart in restarts) {
[11:02:15.510]                             name <- restart$name
[11:02:15.510]                             if (is.null(name)) 
[11:02:15.510]                               next
[11:02:15.510]                             if (!grepl(pattern, name)) 
[11:02:15.510]                               next
[11:02:15.510]                             invokeRestart(restart)
[11:02:15.510]                             muffled <- TRUE
[11:02:15.510]                             break
[11:02:15.510]                           }
[11:02:15.510]                         }
[11:02:15.510]                       }
[11:02:15.510]                       invisible(muffled)
[11:02:15.510]                     }
[11:02:15.510]                     muffleCondition(cond, pattern = "^muffle")
[11:02:15.510]                   }
[11:02:15.510]                 }
[11:02:15.510]                 else {
[11:02:15.510]                   if (TRUE) {
[11:02:15.510]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:15.510]                     {
[11:02:15.510]                       inherits <- base::inherits
[11:02:15.510]                       invokeRestart <- base::invokeRestart
[11:02:15.510]                       is.null <- base::is.null
[11:02:15.510]                       muffled <- FALSE
[11:02:15.510]                       if (inherits(cond, "message")) {
[11:02:15.510]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:15.510]                         if (muffled) 
[11:02:15.510]                           invokeRestart("muffleMessage")
[11:02:15.510]                       }
[11:02:15.510]                       else if (inherits(cond, "warning")) {
[11:02:15.510]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:15.510]                         if (muffled) 
[11:02:15.510]                           invokeRestart("muffleWarning")
[11:02:15.510]                       }
[11:02:15.510]                       else if (inherits(cond, "condition")) {
[11:02:15.510]                         if (!is.null(pattern)) {
[11:02:15.510]                           computeRestarts <- base::computeRestarts
[11:02:15.510]                           grepl <- base::grepl
[11:02:15.510]                           restarts <- computeRestarts(cond)
[11:02:15.510]                           for (restart in restarts) {
[11:02:15.510]                             name <- restart$name
[11:02:15.510]                             if (is.null(name)) 
[11:02:15.510]                               next
[11:02:15.510]                             if (!grepl(pattern, name)) 
[11:02:15.510]                               next
[11:02:15.510]                             invokeRestart(restart)
[11:02:15.510]                             muffled <- TRUE
[11:02:15.510]                             break
[11:02:15.510]                           }
[11:02:15.510]                         }
[11:02:15.510]                       }
[11:02:15.510]                       invisible(muffled)
[11:02:15.510]                     }
[11:02:15.510]                     muffleCondition(cond, pattern = "^muffle")
[11:02:15.510]                   }
[11:02:15.510]                 }
[11:02:15.510]             }
[11:02:15.510]         }))
[11:02:15.510]     }, error = function(ex) {
[11:02:15.510]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:15.510]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:15.510]                 ...future.rng), started = ...future.startTime, 
[11:02:15.510]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:15.510]             version = "1.8"), class = "FutureResult")
[11:02:15.510]     }, finally = {
[11:02:15.510]         if (!identical(...future.workdir, getwd())) 
[11:02:15.510]             setwd(...future.workdir)
[11:02:15.510]         {
[11:02:15.510]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:15.510]                 ...future.oldOptions$nwarnings <- NULL
[11:02:15.510]             }
[11:02:15.510]             base::options(...future.oldOptions)
[11:02:15.510]             if (.Platform$OS.type == "windows") {
[11:02:15.510]                 old_names <- names(...future.oldEnvVars)
[11:02:15.510]                 envs <- base::Sys.getenv()
[11:02:15.510]                 names <- names(envs)
[11:02:15.510]                 common <- intersect(names, old_names)
[11:02:15.510]                 added <- setdiff(names, old_names)
[11:02:15.510]                 removed <- setdiff(old_names, names)
[11:02:15.510]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:15.510]                   envs[common]]
[11:02:15.510]                 NAMES <- toupper(changed)
[11:02:15.510]                 args <- list()
[11:02:15.510]                 for (kk in seq_along(NAMES)) {
[11:02:15.510]                   name <- changed[[kk]]
[11:02:15.510]                   NAME <- NAMES[[kk]]
[11:02:15.510]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:15.510]                     next
[11:02:15.510]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:15.510]                 }
[11:02:15.510]                 NAMES <- toupper(added)
[11:02:15.510]                 for (kk in seq_along(NAMES)) {
[11:02:15.510]                   name <- added[[kk]]
[11:02:15.510]                   NAME <- NAMES[[kk]]
[11:02:15.510]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:15.510]                     next
[11:02:15.510]                   args[[name]] <- ""
[11:02:15.510]                 }
[11:02:15.510]                 NAMES <- toupper(removed)
[11:02:15.510]                 for (kk in seq_along(NAMES)) {
[11:02:15.510]                   name <- removed[[kk]]
[11:02:15.510]                   NAME <- NAMES[[kk]]
[11:02:15.510]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:15.510]                     next
[11:02:15.510]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:15.510]                 }
[11:02:15.510]                 if (length(args) > 0) 
[11:02:15.510]                   base::do.call(base::Sys.setenv, args = args)
[11:02:15.510]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:15.510]             }
[11:02:15.510]             else {
[11:02:15.510]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:15.510]             }
[11:02:15.510]             {
[11:02:15.510]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:15.510]                   0L) {
[11:02:15.510]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:15.510]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:15.510]                   base::options(opts)
[11:02:15.510]                 }
[11:02:15.510]                 {
[11:02:15.510]                   {
[11:02:15.510]                     NULL
[11:02:15.510]                     RNGkind("Mersenne-Twister")
[11:02:15.510]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:15.510]                       inherits = FALSE)
[11:02:15.510]                   }
[11:02:15.510]                   options(future.plan = NULL)
[11:02:15.510]                   if (is.na(NA_character_)) 
[11:02:15.510]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:15.510]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:15.510]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:15.510]                     .init = FALSE)
[11:02:15.510]                 }
[11:02:15.510]             }
[11:02:15.510]         }
[11:02:15.510]     })
[11:02:15.510]     if (TRUE) {
[11:02:15.510]         base::sink(type = "output", split = FALSE)
[11:02:15.510]         if (TRUE) {
[11:02:15.510]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:15.510]         }
[11:02:15.510]         else {
[11:02:15.510]             ...future.result["stdout"] <- base::list(NULL)
[11:02:15.510]         }
[11:02:15.510]         base::close(...future.stdout)
[11:02:15.510]         ...future.stdout <- NULL
[11:02:15.510]     }
[11:02:15.510]     ...future.result$conditions <- ...future.conditions
[11:02:15.510]     ...future.result$finished <- base::Sys.time()
[11:02:15.510]     ...future.result
[11:02:15.510] }
[11:02:15.511] assign_globals() ...
[11:02:15.512] List of 1
[11:02:15.512]  $ data:'data.frame':	3 obs. of  2 variables:
[11:02:15.512]   ..$ a: int [1:3] 1 2 3
[11:02:15.512]   ..$ b: int [1:3] 3 2 1
[11:02:15.512]  - attr(*, "where")=List of 1
[11:02:15.512]   ..$ data:<environment: R_EmptyEnv> 
[11:02:15.512]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:02:15.512]  - attr(*, "resolved")= logi FALSE
[11:02:15.512]  - attr(*, "total_size")= num 356
[11:02:15.512]  - attr(*, "already-done")= logi TRUE
[11:02:15.514] - copied ‘data’ to environment
[11:02:15.515] assign_globals() ... done
[11:02:15.515] plan(): Setting new future strategy stack:
[11:02:15.515] List of future strategies:
[11:02:15.515] 1. multicore:
[11:02:15.515]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:15.515]    - tweaked: FALSE
[11:02:15.515]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:15.517] plan(): nbrOfWorkers() = 2
[11:02:15.558] plan(): Setting new future strategy stack:
[11:02:15.559] List of future strategies:
[11:02:15.559] 1. sequential:
[11:02:15.559]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:15.559]    - tweaked: FALSE
[11:02:15.559]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:15.559] 2. multicore:
[11:02:15.559]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:15.559]    - tweaked: FALSE
[11:02:15.559]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:15.559] plan(): nbrOfWorkers() = 1
[11:02:15.560] SequentialFuture started (and completed)
[11:02:15.560] signalConditions() ...
[11:02:15.560]  - include = ‘immediateCondition’
[11:02:15.560]  - exclude = 
[11:02:15.560]  - resignal = FALSE
[11:02:15.560]  - Number of conditions: 55
[11:02:15.560] signalConditions() ... done
[11:02:15.561] - Launch lazy future ... done
[11:02:15.561] run() for ‘SequentialFuture’ ... done
[11:02:15.561] signalConditions() ...
[11:02:15.561]  - include = ‘immediateCondition’
[11:02:15.561]  - exclude = 
[11:02:15.561]  - resignal = FALSE
[11:02:15.561]  - Number of conditions: 55
[11:02:15.561] signalConditions() ... done
[11:02:15.561] Future state: ‘finished’
[11:02:15.562] signalConditions() ...
[11:02:15.562]  - include = ‘condition’
[11:02:15.562]  - exclude = ‘immediateCondition’
[11:02:15.562]  - resignal = TRUE
[11:02:15.562]  - Number of conditions: 55
[11:02:15.562]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.517] getGlobalsAndPackages() ...
[11:02:15.562]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.517] Searching for globals...
[11:02:15.562]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.532] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[11:02:15.563]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.532] Searching for globals ... DONE
[11:02:15.563]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.532] Resolving globals: FALSE
[11:02:15.563]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.532] The total size of the 1 globals is 356 bytes (356 bytes)
[11:02:15.563]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.533] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[11:02:15.563]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.533] - globals: [1] ‘data’
[11:02:15.563]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.533] 
[11:02:15.564]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.533] getGlobalsAndPackages() ... DONE
[11:02:15.564]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.533] run() for ‘Future’ ...
[11:02:15.564]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.533] - state: ‘created’
[11:02:15.564]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.533] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:02:15.564]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.535] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:15.564]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.535] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:02:15.564]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.535]   - Field: ‘label’
[11:02:15.565]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.535]   - Field: ‘local’
[11:02:15.565]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.535]   - Field: ‘owner’
[11:02:15.565]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.535]   - Field: ‘envir’
[11:02:15.565]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.536]   - Field: ‘workers’
[11:02:15.565]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.536]   - Field: ‘packages’
[11:02:15.565]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.536]   - Field: ‘gc’
[11:02:15.565]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.536]   - Field: ‘job’
[11:02:15.566]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.536]   - Field: ‘conditions’
[11:02:15.566]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.536]   - Field: ‘expr’
[11:02:15.566]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.536]   - Field: ‘uuid’
[11:02:15.566]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.536]   - Field: ‘seed’
[11:02:15.566]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.536]   - Field: ‘version’
[11:02:15.566]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.536]   - Field: ‘result’
[11:02:15.566]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.536]   - Field: ‘asynchronous’
[11:02:15.567]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.537]   - Field: ‘calls’
[11:02:15.567]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.537]   - Field: ‘globals’
[11:02:15.567]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.537]   - Field: ‘stdout’
[11:02:15.567]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.537]   - Field: ‘earlySignal’
[11:02:15.567]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.537]   - Field: ‘lazy’
[11:02:15.567]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.537]   - Field: ‘state’
[11:02:15.567]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.537] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:02:15.568]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.537] - Launch lazy future ...
[11:02:15.568]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.538] Packages needed by the future expression (n = 0): <none>
[11:02:15.568]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.539] Packages needed by future strategies (n = 0): <none>
[11:02:15.568]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.539] {
[11:02:15.539]     {
[11:02:15.539]         {
[11:02:15.539]             ...future.startTime <- base::Sys.time()
[11:02:15.539]             {
[11:02:15.539]                 {
[11:02:15.539]                   {
[11:02:15.539]                     {
[11:02:15.539]                       base::local({
[11:02:15.539]                         has_future <- base::requireNamespace("future", 
[11:02:15.539]                           quietly = TRUE)
[11:02:15.539]                         if (has_future) {
[11:02:15.539]                           ns <- base::getNamespace("future")
[11:02:15.539]                           version <- ns[[".package"]][["version"]]
[11:02:15.539]                           if (is.null(version)) 
[11:02:15.539]                             version <- utils::packageVersion("future")
[11:02:15.539]                         }
[11:02:15.539]                         else {
[11:02:15.539]                           version <- NULL
[11:02:15.539]                         }
[11:02:15.539]                         if (!has_future || version < "1.8.0") {
[11:02:15.539]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:15.539]                             "", base::R.version$version.string), 
[11:02:15.539]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:15.539]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:15.539]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:15.539]                               "release", "version")], collapse = " "), 
[11:02:15.539]                             hostname = base::Sys.info()[["nodename"]])
[11:02:15.539]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:15.539]                             info)
[11:02:15.539]                           info <- base::paste(info, collapse = "; ")
[11:02:15.539]                           if (!has_future) {
[11:02:15.539]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:15.539]                               info)
[11:02:15.539]                           }
[11:02:15.539]                           else {
[11:02:15.539]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:15.539]                               info, version)
[11:02:15.539]                           }
[11:02:15.539]                           base::stop(msg)
[11:02:15.539]                         }
[11:02:15.539]                       })
[11:02:15.539]                     }
[11:02:15.539]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:15.539]                     base::options(mc.cores = 1L)
[11:02:15.539]                   }
[11:02:15.539]                   ...future.strategy.old <- future::plan("list")
[11:02:15.539]                   options(future.plan = NULL)
[11:02:15.539]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:15.539]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:15.539]                 }
[11:02:15.539]                 ...future.workdir <- getwd()
[11:02:15.539]             }
[11:02:15.539]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:15.539]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:15.539]         }
[11:02:15.539]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:15.539]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:15.539]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:15.539]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:15.539]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:15.539]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:15.539]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:15.539]             base::names(...future.oldOptions))
[11:02:15.539]     }
[11:02:15.539]     if (FALSE) {
[11:02:15.539]     }
[11:02:15.539]     else {
[11:02:15.539]         if (TRUE) {
[11:02:15.539]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:15.539]                 open = "w")
[11:02:15.539]         }
[11:02:15.539]         else {
[11:02:15.539]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:15.539]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:15.539]         }
[11:02:15.539]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:15.539]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:15.539]             base::sink(type = "output", split = FALSE)
[11:02:15.539]             base::close(...future.stdout)
[11:02:15.539]         }, add = TRUE)
[11:02:15.539]     }
[11:02:15.539]     ...future.frame <- base::sys.nframe()
[11:02:15.539]     ...future.conditions <- base::list()
[11:02:15.539]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:15.539]     if (FALSE) {
[11:02:15.539]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:15.539]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:15.539]     }
[11:02:15.539]     ...future.result <- base::tryCatch({
[11:02:15.539]         base::withCallingHandlers({
[11:02:15.539]             ...future.value <- base::withVisible(base::local({
[11:02:15.539]                 withCallingHandlers({
[11:02:15.539]                   subset(data, a == 2)
[11:02:15.539]                 }, immediateCondition = function(cond) {
[11:02:15.539]                   save_rds <- function (object, pathname, ...) 
[11:02:15.539]                   {
[11:02:15.539]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:02:15.539]                     if (file_test("-f", pathname_tmp)) {
[11:02:15.539]                       fi_tmp <- file.info(pathname_tmp)
[11:02:15.539]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:02:15.539]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:15.539]                         fi_tmp[["mtime"]])
[11:02:15.539]                     }
[11:02:15.539]                     tryCatch({
[11:02:15.539]                       saveRDS(object, file = pathname_tmp, ...)
[11:02:15.539]                     }, error = function(ex) {
[11:02:15.539]                       msg <- conditionMessage(ex)
[11:02:15.539]                       fi_tmp <- file.info(pathname_tmp)
[11:02:15.539]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:02:15.539]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:15.539]                         fi_tmp[["mtime"]], msg)
[11:02:15.539]                       ex$message <- msg
[11:02:15.539]                       stop(ex)
[11:02:15.539]                     })
[11:02:15.539]                     stopifnot(file_test("-f", pathname_tmp))
[11:02:15.539]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:02:15.539]                     if (!res || file_test("-f", pathname_tmp)) {
[11:02:15.539]                       fi_tmp <- file.info(pathname_tmp)
[11:02:15.539]                       fi <- file.info(pathname)
[11:02:15.539]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:02:15.539]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:15.539]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:02:15.539]                         fi[["size"]], fi[["mtime"]])
[11:02:15.539]                       stop(msg)
[11:02:15.539]                     }
[11:02:15.539]                     invisible(pathname)
[11:02:15.539]                   }
[11:02:15.539]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:02:15.539]                     rootPath = tempdir()) 
[11:02:15.539]                   {
[11:02:15.539]                     obj <- list(time = Sys.time(), condition = cond)
[11:02:15.539]                     file <- tempfile(pattern = class(cond)[1], 
[11:02:15.539]                       tmpdir = path, fileext = ".rds")
[11:02:15.539]                     save_rds(obj, file)
[11:02:15.539]                   }
[11:02:15.539]                   saveImmediateCondition(cond, path = "/tmp/RtmpVZPEla/.future/immediateConditions")
[11:02:15.539]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:15.539]                   {
[11:02:15.539]                     inherits <- base::inherits
[11:02:15.539]                     invokeRestart <- base::invokeRestart
[11:02:15.539]                     is.null <- base::is.null
[11:02:15.539]                     muffled <- FALSE
[11:02:15.539]                     if (inherits(cond, "message")) {
[11:02:15.539]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:15.539]                       if (muffled) 
[11:02:15.539]                         invokeRestart("muffleMessage")
[11:02:15.539]                     }
[11:02:15.539]                     else if (inherits(cond, "warning")) {
[11:02:15.539]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:15.539]                       if (muffled) 
[11:02:15.539]                         invokeRestart("muffleWarning")
[11:02:15.539]                     }
[11:02:15.539]                     else if (inherits(cond, "condition")) {
[11:02:15.539]                       if (!is.null(pattern)) {
[11:02:15.539]                         computeRestarts <- base::computeRestarts
[11:02:15.539]                         grepl <- base::grepl
[11:02:15.539]                         restarts <- computeRestarts(cond)
[11:02:15.539]                         for (restart in restarts) {
[11:02:15.539]                           name <- restart$name
[11:02:15.539]                           if (is.null(name)) 
[11:02:15.539]                             next
[11:02:15.539]                           if (!grepl(pattern, name)) 
[11:02:15.539]                             next
[11:02:15.539]                           invokeRestart(restart)
[11:02:15.539]                           muffled <- TRUE
[11:02:15.539]                           break
[11:02:15.539]                         }
[11:02:15.539]                       }
[11:02:15.539]                     }
[11:02:15.539]                     invisible(muffled)
[11:02:15.539]                   }
[11:02:15.539]                   muffleCondition(cond)
[11:02:15.539]                 })
[11:02:15.539]             }))
[11:02:15.539]             future::FutureResult(value = ...future.value$value, 
[11:02:15.539]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:15.539]                   ...future.rng), globalenv = if (FALSE) 
[11:02:15.539]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:15.539]                     ...future.globalenv.names))
[11:02:15.539]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:15.539]         }, condition = base::local({
[11:02:15.539]             c <- base::c
[11:02:15.539]             inherits <- base::inherits
[11:02:15.539]             invokeRestart <- base::invokeRestart
[11:02:15.539]             length <- base::length
[11:02:15.539]             list <- base::list
[11:02:15.539]             seq.int <- base::seq.int
[11:02:15.539]             signalCondition <- base::signalCondition
[11:02:15.539]             sys.calls <- base::sys.calls
[11:02:15.539]             `[[` <- base::`[[`
[11:02:15.539]             `+` <- base::`+`
[11:02:15.539]             `<<-` <- base::`<<-`
[11:02:15.539]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:15.539]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:15.539]                   3L)]
[11:02:15.539]             }
[11:02:15.539]             function(cond) {
[11:02:15.539]                 is_error <- inherits(cond, "error")
[11:02:15.539]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:15.539]                   NULL)
[11:02:15.539]                 if (is_error) {
[11:02:15.539]                   sessionInformation <- function() {
[11:02:15.539]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:15.539]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:15.539]                       search = base::search(), system = base::Sys.info())
[11:02:15.539]                   }
[11:02:15.539]                   ...future.conditions[[length(...future.conditions) + 
[11:02:15.539]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:15.539]                     cond$call), session = sessionInformation(), 
[11:02:15.539]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:15.539]                   signalCondition(cond)
[11:02:15.539]                 }
[11:02:15.539]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:15.539]                 "immediateCondition"))) {
[11:02:15.539]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:15.539]                   ...future.conditions[[length(...future.conditions) + 
[11:02:15.539]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:15.539]                   if (TRUE && !signal) {
[11:02:15.539]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:15.539]                     {
[11:02:15.539]                       inherits <- base::inherits
[11:02:15.539]                       invokeRestart <- base::invokeRestart
[11:02:15.539]                       is.null <- base::is.null
[11:02:15.539]                       muffled <- FALSE
[11:02:15.539]                       if (inherits(cond, "message")) {
[11:02:15.539]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:15.539]                         if (muffled) 
[11:02:15.539]                           invokeRestart("muffleMessage")
[11:02:15.539]                       }
[11:02:15.539]                       else if (inherits(cond, "warning")) {
[11:02:15.539]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:15.539]                         if (muffled) 
[11:02:15.539]                           invokeRestart("muffleWarning")
[11:02:15.539]                       }
[11:02:15.539]                       else if (inherits(cond, "condition")) {
[11:02:15.539]                         if (!is.null(pattern)) {
[11:02:15.539]                           computeRestarts <- base::computeRestarts
[11:02:15.539]                           grepl <- base::grepl
[11:02:15.539]                           restarts <- computeRestarts(cond)
[11:02:15.539]                           for (restart in restarts) {
[11:02:15.539]                             name <- restart$name
[11:02:15.539]                             if (is.null(name)) 
[11:02:15.539]                               next
[11:02:15.539]                             if (!grepl(pattern, name)) 
[11:02:15.539]                               next
[11:02:15.539]                             invokeRestart(restart)
[11:02:15.539]                             muffled <- TRUE
[11:02:15.539]                             break
[11:02:15.539]                           }
[11:02:15.539]                         }
[11:02:15.539]                       }
[11:02:15.539]                       invisible(muffled)
[11:02:15.539]                     }
[11:02:15.539]                     muffleCondition(cond, pattern = "^muffle")
[11:02:15.539]                   }
[11:02:15.539]                 }
[11:02:15.539]                 else {
[11:02:15.539]                   if (TRUE) {
[11:02:15.539]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:15.539]                     {
[11:02:15.539]                       inherits <- base::inherits
[11:02:15.539]                       invokeRestart <- base::invokeRestart
[11:02:15.539]                       is.null <- base::is.null
[11:02:15.539]                       muffled <- FALSE
[11:02:15.539]                       if (inherits(cond, "message")) {
[11:02:15.539]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:15.539]                         if (muffled) 
[11:02:15.539]                           invokeRestart("muffleMessage")
[11:02:15.539]                       }
[11:02:15.539]                       else if (inherits(cond, "warning")) {
[11:02:15.539]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:15.539]                         if (muffled) 
[11:02:15.539]                           invokeRestart("muffleWarning")
[11:02:15.539]                       }
[11:02:15.539]                       else if (inherits(cond, "condition")) {
[11:02:15.539]                         if (!is.null(pattern)) {
[11:02:15.539]                           computeRestarts <- base::computeRestarts
[11:02:15.539]                           grepl <- base::grepl
[11:02:15.539]                           restarts <- computeRestarts(cond)
[11:02:15.539]                           for (restart in restarts) {
[11:02:15.539]                             name <- restart$name
[11:02:15.539]                             if (is.null(name)) 
[11:02:15.539]                               next
[11:02:15.539]                             if (!grepl(pattern, name)) 
[11:02:15.539]                               next
[11:02:15.539]                             invokeRestart(restart)
[11:02:15.539]                             muffled <- TRUE
[11:02:15.539]                             break
[11:02:15.539]                           }
[11:02:15.539]                         }
[11:02:15.539]                       }
[11:02:15.539]                       invisible(muffled)
[11:02:15.539]                     }
[11:02:15.539]                     muffleCondition(cond, pattern = "^muffle")
[11:02:15.539]                   }
[11:02:15.539]                 }
[11:02:15.539]             }
[11:02:15.539]         }))
[11:02:15.539]     }, error = function(ex) {
[11:02:15.539]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:15.539]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:15.539]                 ...future.rng), started = ...future.startTime, 
[11:02:15.539]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:15.539]             version = "1.8"), class = "FutureResult")
[11:02:15.539]     }, finally = {
[11:02:15.539]         if (!identical(...future.workdir, getwd())) 
[11:02:15.539]             setwd(...future.workdir)
[11:02:15.539]         {
[11:02:15.539]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:15.539]                 ...future.oldOptions$nwarnings <- NULL
[11:02:15.539]             }
[11:02:15.539]             base::options(...future.oldOptions)
[11:02:15.539]             if (.Platform$OS.type == "windows") {
[11:02:15.539]                 old_names <- names(...future.oldEnvVars)
[11:02:15.539]                 envs <- base::Sys.getenv()
[11:02:15.539]                 names <- names(envs)
[11:02:15.539]                 common <- intersect(names, old_names)
[11:02:15.539]                 added <- setdiff(names, old_names)
[11:02:15.539]                 removed <- setdiff(old_names, names)
[11:02:15.539]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:15.539]                   envs[common]]
[11:02:15.539]                 NAMES <- toupper(changed)
[11:02:15.539]                 args <- list()
[11:02:15.539]                 for (kk in seq_along(NAMES)) {
[11:02:15.539]                   name <- changed[[kk]]
[11:02:15.539]                   NAME <- NAMES[[kk]]
[11:02:15.539]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:15.539]                     next
[11:02:15.539]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:15.539]                 }
[11:02:15.539]                 NAMES <- toupper(added)
[11:02:15.539]                 for (kk in seq_along(NAMES)) {
[11:02:15.539]                   name <- added[[kk]]
[11:02:15.539]                   NAME <- NAMES[[kk]]
[11:02:15.539]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:15.539]                     next
[11:02:15.539]                   args[[name]] <- ""
[11:02:15.539]                 }
[11:02:15.539]                 NAMES <- toupper(removed)
[11:02:15.539]                 for (kk in seq_along(NAMES)) {
[11:02:15.539]                   name <- removed[[kk]]
[11:02:15.539]                   NAME <- NAMES[[kk]]
[11:02:15.539]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:15.539]                     next
[11:02:15.539]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:15.539]                 }
[11:02:15.539]                 if (length(args) > 0) 
[11:02:15.539]                   base::do.call(base::Sys.setenv, args = args)
[11:02:15.539]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:15.539]             }
[11:02:15.539]             else {
[11:02:15.539]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:15.539]             }
[11:02:15.539]             {
[11:02:15.539]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:15.539]                   0L) {
[11:02:15.539]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:15.539]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:15.539]                   base::options(opts)
[11:02:15.539]                 }
[11:02:15.539]                 {
[11:02:15.539]                   {
[11:02:15.539]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:15.539]                     NULL
[11:02:15.539]                   }
[11:02:15.539]                   options(future.plan = NULL)
[11:02:15.539]                   if (is.na(NA_character_)) 
[11:02:15.539]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:15.539]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:15.539]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:15.539]                     .init = FALSE)
[11:02:15.539]                 }
[11:02:15.539]             }
[11:02:15.539]         }
[11:02:15.539]     })
[11:02:15.539]     if (TRUE) {
[11:02:15.539]         base::sink(type = "output", split = FALSE)
[11:02:15.539]         if (TRUE) {
[11:02:15.539]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:15.539]         }
[11:02:15.539]         else {
[11:02:15.539]             ...future.result["stdout"] <- base::list(NULL)
[11:02:15.539]         }
[11:02:15.539]         base::close(...future.stdout)
[11:02:15.539]         ...future.stdout <- NULL
[11:02:15.539]     }
[11:02:15.539]     ...future.result$conditions <- ...future.conditions
[11:02:15.539]     ...future.result$finished <- base::Sys.time()
[11:02:15.539]     ...future.result
[11:02:15.539] }
[11:02:15.568]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.541] assign_globals() ...
[11:02:15.569]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.541] List of 1
[11:02:15.541]  $ data:'data.frame':	3 obs. of  2 variables:
[11:02:15.541]   ..$ a: int [1:3] 1 2 3
[11:02:15.541]   ..$ b: int [1:3] 3 2 1
[11:02:15.541]  - attr(*, "where")=List of 1
[11:02:15.541]   ..$ data:<environment: R_EmptyEnv> 
[11:02:15.541]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:02:15.541]  - attr(*, "resolved")= logi FALSE
[11:02:15.541]  - attr(*, "total_size")= num 356
[11:02:15.541]  - attr(*, "already-done")= logi TRUE
[11:02:15.569]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.544] - copied ‘data’ to environment
[11:02:15.569]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.544] assign_globals() ... done
[11:02:15.569]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.544] requestCore(): workers = 2
[11:02:15.569]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.546] MulticoreFuture started
[11:02:15.569]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.547] - Launch lazy future ... done
[11:02:15.569]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.547] run() for ‘MulticoreFuture’ ... done
[11:02:15.570]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.547] result() for MulticoreFuture ...
[11:02:15.570]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.557] result() for MulticoreFuture ...
[11:02:15.570]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.557] result() for MulticoreFuture ... done
[11:02:15.570]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.557] result() for MulticoreFuture ... done
[11:02:15.570]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.557] result() for MulticoreFuture ...
[11:02:15.570]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.558] result() for MulticoreFuture ... done
[11:02:15.570] signalConditions() ... done
- plan(list('sequential', 'multicore')) ... DONE
- plan(list('sequential', 'multisession')) ...
[11:02:15.571] plan(): Setting new future strategy stack:
[11:02:15.571] List of future strategies:
[11:02:15.571] 1. sequential:
[11:02:15.571]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:15.571]    - tweaked: FALSE
[11:02:15.571]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:15.571] 2. multisession:
[11:02:15.571]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:02:15.571]    - tweaked: FALSE
[11:02:15.571]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:15.572] plan(): nbrOfWorkers() = 1
[11:02:15.572] getGlobalsAndPackages() ...
[11:02:15.572] Searching for globals...
[11:02:15.591] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[11:02:15.592] Searching for globals ... DONE
[11:02:15.592] Resolving globals: FALSE
[11:02:15.593] The total size of the 2 globals is 7.45 KiB (7631 bytes)
[11:02:15.594] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 7.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (7.40 KiB of class ‘list’) and ‘strategy2’ (51 bytes of class ‘character’)
[11:02:15.594] - globals: [2] ‘nested’, ‘strategy2’
[11:02:15.594] - packages: [1] ‘future’
[11:02:15.594] getGlobalsAndPackages() ... DONE
[11:02:15.594] run() for ‘Future’ ...
[11:02:15.594] - state: ‘created’
[11:02:15.595] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:02:15.595] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:15.595] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:15.595]   - Field: ‘label’
[11:02:15.595]   - Field: ‘local’
[11:02:15.595]   - Field: ‘owner’
[11:02:15.595]   - Field: ‘envir’
[11:02:15.595]   - Field: ‘packages’
[11:02:15.596]   - Field: ‘gc’
[11:02:15.596]   - Field: ‘conditions’
[11:02:15.596]   - Field: ‘expr’
[11:02:15.596]   - Field: ‘uuid’
[11:02:15.596]   - Field: ‘seed’
[11:02:15.596]   - Field: ‘version’
[11:02:15.596]   - Field: ‘result’
[11:02:15.596]   - Field: ‘asynchronous’
[11:02:15.596]   - Field: ‘calls’
[11:02:15.596]   - Field: ‘globals’
[11:02:15.596]   - Field: ‘stdout’
[11:02:15.596]   - Field: ‘earlySignal’
[11:02:15.597]   - Field: ‘lazy’
[11:02:15.597]   - Field: ‘state’
[11:02:15.597] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:15.597] - Launch lazy future ...
[11:02:15.597] Packages needed by the future expression (n = 1): ‘future’
[11:02:15.597] Packages needed by future strategies (n = 1): ‘future’
[11:02:15.598] {
[11:02:15.598]     {
[11:02:15.598]         {
[11:02:15.598]             ...future.startTime <- base::Sys.time()
[11:02:15.598]             {
[11:02:15.598]                 {
[11:02:15.598]                   {
[11:02:15.598]                     {
[11:02:15.598]                       base::local({
[11:02:15.598]                         has_future <- base::requireNamespace("future", 
[11:02:15.598]                           quietly = TRUE)
[11:02:15.598]                         if (has_future) {
[11:02:15.598]                           ns <- base::getNamespace("future")
[11:02:15.598]                           version <- ns[[".package"]][["version"]]
[11:02:15.598]                           if (is.null(version)) 
[11:02:15.598]                             version <- utils::packageVersion("future")
[11:02:15.598]                         }
[11:02:15.598]                         else {
[11:02:15.598]                           version <- NULL
[11:02:15.598]                         }
[11:02:15.598]                         if (!has_future || version < "1.8.0") {
[11:02:15.598]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:15.598]                             "", base::R.version$version.string), 
[11:02:15.598]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:15.598]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:15.598]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:15.598]                               "release", "version")], collapse = " "), 
[11:02:15.598]                             hostname = base::Sys.info()[["nodename"]])
[11:02:15.598]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:15.598]                             info)
[11:02:15.598]                           info <- base::paste(info, collapse = "; ")
[11:02:15.598]                           if (!has_future) {
[11:02:15.598]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:15.598]                               info)
[11:02:15.598]                           }
[11:02:15.598]                           else {
[11:02:15.598]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:15.598]                               info, version)
[11:02:15.598]                           }
[11:02:15.598]                           base::stop(msg)
[11:02:15.598]                         }
[11:02:15.598]                       })
[11:02:15.598]                     }
[11:02:15.598]                     base::local({
[11:02:15.598]                       for (pkg in "future") {
[11:02:15.598]                         base::loadNamespace(pkg)
[11:02:15.598]                         base::library(pkg, character.only = TRUE)
[11:02:15.598]                       }
[11:02:15.598]                     })
[11:02:15.598]                   }
[11:02:15.598]                   ...future.strategy.old <- future::plan("list")
[11:02:15.598]                   options(future.plan = NULL)
[11:02:15.598]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:15.598]                   future::plan(list(b = function (..., workers = availableCores(), 
[11:02:15.598]                     lazy = FALSE, rscript_libs = .libPaths(), 
[11:02:15.598]                     envir = parent.frame()) 
[11:02:15.598]                   {
[11:02:15.598]                     if (is.function(workers)) 
[11:02:15.598]                       workers <- workers()
[11:02:15.598]                     workers <- structure(as.integer(workers), 
[11:02:15.598]                       class = class(workers))
[11:02:15.598]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[11:02:15.598]                       workers >= 1)
[11:02:15.598]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[11:02:15.598]                       return(sequential(..., lazy = TRUE, envir = envir))
[11:02:15.598]                     }
[11:02:15.598]                     future <- MultisessionFuture(..., workers = workers, 
[11:02:15.598]                       lazy = lazy, rscript_libs = rscript_libs, 
[11:02:15.598]                       envir = envir)
[11:02:15.598]                     if (!future$lazy) 
[11:02:15.598]                       future <- run(future)
[11:02:15.598]                     invisible(future)
[11:02:15.598]                   }), .cleanup = FALSE, .init = FALSE)
[11:02:15.598]                 }
[11:02:15.598]                 ...future.workdir <- getwd()
[11:02:15.598]             }
[11:02:15.598]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:15.598]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:15.598]         }
[11:02:15.598]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:15.598]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:15.598]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:15.598]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:15.598]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:15.598]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:15.598]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:15.598]             base::names(...future.oldOptions))
[11:02:15.598]     }
[11:02:15.598]     if (FALSE) {
[11:02:15.598]     }
[11:02:15.598]     else {
[11:02:15.598]         if (TRUE) {
[11:02:15.598]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:15.598]                 open = "w")
[11:02:15.598]         }
[11:02:15.598]         else {
[11:02:15.598]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:15.598]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:15.598]         }
[11:02:15.598]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:15.598]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:15.598]             base::sink(type = "output", split = FALSE)
[11:02:15.598]             base::close(...future.stdout)
[11:02:15.598]         }, add = TRUE)
[11:02:15.598]     }
[11:02:15.598]     ...future.frame <- base::sys.nframe()
[11:02:15.598]     ...future.conditions <- base::list()
[11:02:15.598]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:15.598]     if (FALSE) {
[11:02:15.598]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:15.598]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:15.598]     }
[11:02:15.598]     ...future.result <- base::tryCatch({
[11:02:15.598]         base::withCallingHandlers({
[11:02:15.598]             ...future.value <- base::withVisible(base::local({
[11:02:15.598]                 a <- 1L
[11:02:15.598]                 plan_a <- unclass(future::plan("list"))
[11:02:15.598]                 nested_a <- nested[-1]
[11:02:15.598]                 stopifnot(length(nested_a) == 1L, length(plan_a) == 
[11:02:15.598]                   1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[11:02:15.598]                   strategy2))
[11:02:15.598]                 for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[11:02:15.598]                   "init") <- NULL
[11:02:15.598]                 for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[11:02:15.598]                   "init") <- NULL
[11:02:15.598]                 stopifnot(all.equal(plan_a, nested_a))
[11:02:15.598]                 y %<-% {
[11:02:15.598]                   b <- 2L
[11:02:15.598]                   plan_b <- future::plan("list")
[11:02:15.598]                   nested_b <- nested_a[-1]
[11:02:15.598]                   stopifnot(length(nested_b) == 0L, length(plan_b) == 
[11:02:15.598]                     1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[11:02:15.598]                     "sequential"))
[11:02:15.598]                   list(a = a, nested_a = nested_a, plan_a = plan_a, 
[11:02:15.598]                     b = b, nested_b = nested_b, plan_b = plan_b)
[11:02:15.598]                 }
[11:02:15.598]                 y
[11:02:15.598]             }))
[11:02:15.598]             future::FutureResult(value = ...future.value$value, 
[11:02:15.598]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:15.598]                   ...future.rng), globalenv = if (FALSE) 
[11:02:15.598]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:15.598]                     ...future.globalenv.names))
[11:02:15.598]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:15.598]         }, condition = base::local({
[11:02:15.598]             c <- base::c
[11:02:15.598]             inherits <- base::inherits
[11:02:15.598]             invokeRestart <- base::invokeRestart
[11:02:15.598]             length <- base::length
[11:02:15.598]             list <- base::list
[11:02:15.598]             seq.int <- base::seq.int
[11:02:15.598]             signalCondition <- base::signalCondition
[11:02:15.598]             sys.calls <- base::sys.calls
[11:02:15.598]             `[[` <- base::`[[`
[11:02:15.598]             `+` <- base::`+`
[11:02:15.598]             `<<-` <- base::`<<-`
[11:02:15.598]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:15.598]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:15.598]                   3L)]
[11:02:15.598]             }
[11:02:15.598]             function(cond) {
[11:02:15.598]                 is_error <- inherits(cond, "error")
[11:02:15.598]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:15.598]                   NULL)
[11:02:15.598]                 if (is_error) {
[11:02:15.598]                   sessionInformation <- function() {
[11:02:15.598]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:15.598]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:15.598]                       search = base::search(), system = base::Sys.info())
[11:02:15.598]                   }
[11:02:15.598]                   ...future.conditions[[length(...future.conditions) + 
[11:02:15.598]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:15.598]                     cond$call), session = sessionInformation(), 
[11:02:15.598]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:15.598]                   signalCondition(cond)
[11:02:15.598]                 }
[11:02:15.598]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:15.598]                 "immediateCondition"))) {
[11:02:15.598]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:15.598]                   ...future.conditions[[length(...future.conditions) + 
[11:02:15.598]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:15.598]                   if (TRUE && !signal) {
[11:02:15.598]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:15.598]                     {
[11:02:15.598]                       inherits <- base::inherits
[11:02:15.598]                       invokeRestart <- base::invokeRestart
[11:02:15.598]                       is.null <- base::is.null
[11:02:15.598]                       muffled <- FALSE
[11:02:15.598]                       if (inherits(cond, "message")) {
[11:02:15.598]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:15.598]                         if (muffled) 
[11:02:15.598]                           invokeRestart("muffleMessage")
[11:02:15.598]                       }
[11:02:15.598]                       else if (inherits(cond, "warning")) {
[11:02:15.598]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:15.598]                         if (muffled) 
[11:02:15.598]                           invokeRestart("muffleWarning")
[11:02:15.598]                       }
[11:02:15.598]                       else if (inherits(cond, "condition")) {
[11:02:15.598]                         if (!is.null(pattern)) {
[11:02:15.598]                           computeRestarts <- base::computeRestarts
[11:02:15.598]                           grepl <- base::grepl
[11:02:15.598]                           restarts <- computeRestarts(cond)
[11:02:15.598]                           for (restart in restarts) {
[11:02:15.598]                             name <- restart$name
[11:02:15.598]                             if (is.null(name)) 
[11:02:15.598]                               next
[11:02:15.598]                             if (!grepl(pattern, name)) 
[11:02:15.598]                               next
[11:02:15.598]                             invokeRestart(restart)
[11:02:15.598]                             muffled <- TRUE
[11:02:15.598]                             break
[11:02:15.598]                           }
[11:02:15.598]                         }
[11:02:15.598]                       }
[11:02:15.598]                       invisible(muffled)
[11:02:15.598]                     }
[11:02:15.598]                     muffleCondition(cond, pattern = "^muffle")
[11:02:15.598]                   }
[11:02:15.598]                 }
[11:02:15.598]                 else {
[11:02:15.598]                   if (TRUE) {
[11:02:15.598]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:15.598]                     {
[11:02:15.598]                       inherits <- base::inherits
[11:02:15.598]                       invokeRestart <- base::invokeRestart
[11:02:15.598]                       is.null <- base::is.null
[11:02:15.598]                       muffled <- FALSE
[11:02:15.598]                       if (inherits(cond, "message")) {
[11:02:15.598]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:15.598]                         if (muffled) 
[11:02:15.598]                           invokeRestart("muffleMessage")
[11:02:15.598]                       }
[11:02:15.598]                       else if (inherits(cond, "warning")) {
[11:02:15.598]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:15.598]                         if (muffled) 
[11:02:15.598]                           invokeRestart("muffleWarning")
[11:02:15.598]                       }
[11:02:15.598]                       else if (inherits(cond, "condition")) {
[11:02:15.598]                         if (!is.null(pattern)) {
[11:02:15.598]                           computeRestarts <- base::computeRestarts
[11:02:15.598]                           grepl <- base::grepl
[11:02:15.598]                           restarts <- computeRestarts(cond)
[11:02:15.598]                           for (restart in restarts) {
[11:02:15.598]                             name <- restart$name
[11:02:15.598]                             if (is.null(name)) 
[11:02:15.598]                               next
[11:02:15.598]                             if (!grepl(pattern, name)) 
[11:02:15.598]                               next
[11:02:15.598]                             invokeRestart(restart)
[11:02:15.598]                             muffled <- TRUE
[11:02:15.598]                             break
[11:02:15.598]                           }
[11:02:15.598]                         }
[11:02:15.598]                       }
[11:02:15.598]                       invisible(muffled)
[11:02:15.598]                     }
[11:02:15.598]                     muffleCondition(cond, pattern = "^muffle")
[11:02:15.598]                   }
[11:02:15.598]                 }
[11:02:15.598]             }
[11:02:15.598]         }))
[11:02:15.598]     }, error = function(ex) {
[11:02:15.598]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:15.598]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:15.598]                 ...future.rng), started = ...future.startTime, 
[11:02:15.598]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:15.598]             version = "1.8"), class = "FutureResult")
[11:02:15.598]     }, finally = {
[11:02:15.598]         if (!identical(...future.workdir, getwd())) 
[11:02:15.598]             setwd(...future.workdir)
[11:02:15.598]         {
[11:02:15.598]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:15.598]                 ...future.oldOptions$nwarnings <- NULL
[11:02:15.598]             }
[11:02:15.598]             base::options(...future.oldOptions)
[11:02:15.598]             if (.Platform$OS.type == "windows") {
[11:02:15.598]                 old_names <- names(...future.oldEnvVars)
[11:02:15.598]                 envs <- base::Sys.getenv()
[11:02:15.598]                 names <- names(envs)
[11:02:15.598]                 common <- intersect(names, old_names)
[11:02:15.598]                 added <- setdiff(names, old_names)
[11:02:15.598]                 removed <- setdiff(old_names, names)
[11:02:15.598]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:15.598]                   envs[common]]
[11:02:15.598]                 NAMES <- toupper(changed)
[11:02:15.598]                 args <- list()
[11:02:15.598]                 for (kk in seq_along(NAMES)) {
[11:02:15.598]                   name <- changed[[kk]]
[11:02:15.598]                   NAME <- NAMES[[kk]]
[11:02:15.598]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:15.598]                     next
[11:02:15.598]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:15.598]                 }
[11:02:15.598]                 NAMES <- toupper(added)
[11:02:15.598]                 for (kk in seq_along(NAMES)) {
[11:02:15.598]                   name <- added[[kk]]
[11:02:15.598]                   NAME <- NAMES[[kk]]
[11:02:15.598]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:15.598]                     next
[11:02:15.598]                   args[[name]] <- ""
[11:02:15.598]                 }
[11:02:15.598]                 NAMES <- toupper(removed)
[11:02:15.598]                 for (kk in seq_along(NAMES)) {
[11:02:15.598]                   name <- removed[[kk]]
[11:02:15.598]                   NAME <- NAMES[[kk]]
[11:02:15.598]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:15.598]                     next
[11:02:15.598]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:15.598]                 }
[11:02:15.598]                 if (length(args) > 0) 
[11:02:15.598]                   base::do.call(base::Sys.setenv, args = args)
[11:02:15.598]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:15.598]             }
[11:02:15.598]             else {
[11:02:15.598]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:15.598]             }
[11:02:15.598]             {
[11:02:15.598]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:15.598]                   0L) {
[11:02:15.598]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:15.598]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:15.598]                   base::options(opts)
[11:02:15.598]                 }
[11:02:15.598]                 {
[11:02:15.598]                   {
[11:02:15.598]                     NULL
[11:02:15.598]                     RNGkind("Mersenne-Twister")
[11:02:15.598]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:15.598]                       inherits = FALSE)
[11:02:15.598]                   }
[11:02:15.598]                   options(future.plan = NULL)
[11:02:15.598]                   if (is.na(NA_character_)) 
[11:02:15.598]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:15.598]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:15.598]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:15.598]                     .init = FALSE)
[11:02:15.598]                 }
[11:02:15.598]             }
[11:02:15.598]         }
[11:02:15.598]     })
[11:02:15.598]     if (TRUE) {
[11:02:15.598]         base::sink(type = "output", split = FALSE)
[11:02:15.598]         if (TRUE) {
[11:02:15.598]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:15.598]         }
[11:02:15.598]         else {
[11:02:15.598]             ...future.result["stdout"] <- base::list(NULL)
[11:02:15.598]         }
[11:02:15.598]         base::close(...future.stdout)
[11:02:15.598]         ...future.stdout <- NULL
[11:02:15.598]     }
[11:02:15.598]     ...future.result$conditions <- ...future.conditions
[11:02:15.598]     ...future.result$finished <- base::Sys.time()
[11:02:15.598]     ...future.result
[11:02:15.598] }
[11:02:15.600] assign_globals() ...
[11:02:15.600] List of 2
[11:02:15.600]  $ nested   :List of 2
[11:02:15.600]   ..$ a:function (..., envir = parent.frame())  
[11:02:15.600]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[11:02:15.600]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[11:02:15.600]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[11:02:15.600]     envir = parent.frame())  
[11:02:15.600]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[11:02:15.600]   .. ..- attr(*, "init")= logi TRUE
[11:02:15.600]   .. ..- attr(*, "cleanup")=function ()  
[11:02:15.600]   .. ..- attr(*, "untweakable")= chr "persistent"
[11:02:15.600]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[11:02:15.600]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[11:02:15.600]  $ strategy2: chr "multisession"
[11:02:15.600]  - attr(*, "where")=List of 2
[11:02:15.600]   ..$ nested   :<environment: R_EmptyEnv> 
[11:02:15.600]   ..$ strategy2:<environment: R_EmptyEnv> 
[11:02:15.600]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:02:15.600]  - attr(*, "resolved")= logi FALSE
[11:02:15.600]  - attr(*, "total_size")= num 7631
[11:02:15.600]  - attr(*, "already-done")= logi TRUE
[11:02:15.605] - copied ‘nested’ to environment
[11:02:15.605] - copied ‘strategy2’ to environment
[11:02:15.605] assign_globals() ... done
[11:02:15.606] plan(): Setting new future strategy stack:
[11:02:15.606] List of future strategies:
[11:02:15.606] 1. multisession:
[11:02:15.606]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:02:15.606]    - tweaked: FALSE
[11:02:15.606]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:15.607] plan(): nbrOfWorkers() = 2
[11:02:16.280] plan(): Setting new future strategy stack:
[11:02:16.281] List of future strategies:
[11:02:16.281] 1. sequential:
[11:02:16.281]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:16.281]    - tweaked: FALSE
[11:02:16.281]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:16.281] 2. multisession:
[11:02:16.281]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:02:16.281]    - tweaked: FALSE
[11:02:16.281]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:16.281] plan(): nbrOfWorkers() = 1
[11:02:16.281] SequentialFuture started (and completed)
[11:02:16.281] signalConditions() ...
[11:02:16.282]  - include = ‘immediateCondition’
[11:02:16.282]  - exclude = 
[11:02:16.282]  - resignal = FALSE
[11:02:16.282]  - Number of conditions: 67
[11:02:16.282] signalConditions() ... done
[11:02:16.282] - Launch lazy future ... done
[11:02:16.282] run() for ‘SequentialFuture’ ... done
[11:02:16.282] signalConditions() ...
[11:02:16.282]  - include = ‘immediateCondition’
[11:02:16.282]  - exclude = 
[11:02:16.283]  - resignal = FALSE
[11:02:16.283]  - Number of conditions: 67
[11:02:16.283] signalConditions() ... done
[11:02:16.283] Future state: ‘finished’
[11:02:16.283] signalConditions() ...
[11:02:16.283]  - include = ‘condition’
[11:02:16.283]  - exclude = ‘immediateCondition’
[11:02:16.283]  - resignal = TRUE
[11:02:16.283]  - Number of conditions: 67
[11:02:16.283]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.608] getGlobalsAndPackages() ...
[11:02:16.283]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.608] Searching for globals...
[11:02:16.284]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.626] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[11:02:16.284]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.627] Searching for globals ... DONE
[11:02:16.284]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.627] Resolving globals: FALSE
[11:02:16.284]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.627] The total size of the 3 globals is 11.81 KiB (12089 bytes)
[11:02:16.284]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.628] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 11.81 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (5.89 KiB of class ‘list’), ‘plan_a’ (5.89 KiB of class ‘list’) and ‘a’ (35 bytes of class ‘numeric’)
[11:02:16.284]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.628] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[11:02:16.284]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.628] 
[11:02:16.284]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.628] getGlobalsAndPackages() ... DONE
[11:02:16.285]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.628] run() for ‘Future’ ...
[11:02:16.285]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.628] - state: ‘created’
[11:02:16.285]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:15.629] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:16.285]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.110] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:16.285]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.110] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:16.285]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.110]   - Field: ‘node’
[11:02:16.285]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.111]   - Field: ‘label’
[11:02:16.285]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.111]   - Field: ‘local’
[11:02:16.286]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.111]   - Field: ‘owner’
[11:02:16.286]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.111]   - Field: ‘envir’
[11:02:16.286]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.111]   - Field: ‘workers’
[11:02:16.286]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.111]   - Field: ‘packages’
[11:02:16.286]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.111]   - Field: ‘gc’
[11:02:16.286]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.111]   - Field: ‘conditions’
[11:02:16.286]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.111]   - Field: ‘persistent’
[11:02:16.286]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.111]   - Field: ‘expr’
[11:02:16.286]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.112]   - Field: ‘uuid’
[11:02:16.287]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.112]   - Field: ‘seed’
[11:02:16.287]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.112]   - Field: ‘version’
[11:02:16.287]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.112]   - Field: ‘result’
[11:02:16.287]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.112]   - Field: ‘asynchronous’
[11:02:16.287]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.112]   - Field: ‘calls’
[11:02:16.287]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.112]   - Field: ‘globals’
[11:02:16.287]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.112]   - Field: ‘stdout’
[11:02:16.287]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.112]   - Field: ‘earlySignal’
[11:02:16.288]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.112]   - Field: ‘lazy’
[11:02:16.288]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.113]   - Field: ‘state’
[11:02:16.288]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.113] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:16.288]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.113] - Launch lazy future ...
[11:02:16.288]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.113] Packages needed by the future expression (n = 0): <none>
[11:02:16.288]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.114] Packages needed by future strategies (n = 0): <none>
[11:02:16.288]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.114] {
[11:02:16.114]     {
[11:02:16.114]         {
[11:02:16.114]             ...future.startTime <- base::Sys.time()
[11:02:16.114]             {
[11:02:16.114]                 {
[11:02:16.114]                   {
[11:02:16.114]                     {
[11:02:16.114]                       base::local({
[11:02:16.114]                         has_future <- base::requireNamespace("future", 
[11:02:16.114]                           quietly = TRUE)
[11:02:16.114]                         if (has_future) {
[11:02:16.114]                           ns <- base::getNamespace("future")
[11:02:16.114]                           version <- ns[[".package"]][["version"]]
[11:02:16.114]                           if (is.null(version)) 
[11:02:16.114]                             version <- utils::packageVersion("future")
[11:02:16.114]                         }
[11:02:16.114]                         else {
[11:02:16.114]                           version <- NULL
[11:02:16.114]                         }
[11:02:16.114]                         if (!has_future || version < "1.8.0") {
[11:02:16.114]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:16.114]                             "", base::R.version$version.string), 
[11:02:16.114]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:16.114]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:16.114]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:16.114]                               "release", "version")], collapse = " "), 
[11:02:16.114]                             hostname = base::Sys.info()[["nodename"]])
[11:02:16.114]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:16.114]                             info)
[11:02:16.114]                           info <- base::paste(info, collapse = "; ")
[11:02:16.114]                           if (!has_future) {
[11:02:16.114]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:16.114]                               info)
[11:02:16.114]                           }
[11:02:16.114]                           else {
[11:02:16.114]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:16.114]                               info, version)
[11:02:16.114]                           }
[11:02:16.114]                           base::stop(msg)
[11:02:16.114]                         }
[11:02:16.114]                       })
[11:02:16.114]                     }
[11:02:16.114]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:16.114]                     base::options(mc.cores = 1L)
[11:02:16.114]                   }
[11:02:16.114]                   ...future.strategy.old <- future::plan("list")
[11:02:16.114]                   options(future.plan = NULL)
[11:02:16.114]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:16.114]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:16.114]                 }
[11:02:16.114]                 ...future.workdir <- getwd()
[11:02:16.114]             }
[11:02:16.114]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:16.114]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:16.114]         }
[11:02:16.114]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:16.114]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:16.114]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:16.114]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:16.114]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:16.114]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:16.114]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:16.114]             base::names(...future.oldOptions))
[11:02:16.114]     }
[11:02:16.114]     if (FALSE) {
[11:02:16.114]     }
[11:02:16.114]     else {
[11:02:16.114]         if (TRUE) {
[11:02:16.114]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:16.114]                 open = "w")
[11:02:16.114]         }
[11:02:16.114]         else {
[11:02:16.114]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:16.114]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:16.114]         }
[11:02:16.114]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:16.114]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:16.114]             base::sink(type = "output", split = FALSE)
[11:02:16.114]             base::close(...future.stdout)
[11:02:16.114]         }, add = TRUE)
[11:02:16.114]     }
[11:02:16.114]     ...future.frame <- base::sys.nframe()
[11:02:16.114]     ...future.conditions <- base::list()
[11:02:16.114]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:16.114]     if (FALSE) {
[11:02:16.114]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:16.114]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:16.114]     }
[11:02:16.114]     ...future.result <- base::tryCatch({
[11:02:16.114]         base::withCallingHandlers({
[11:02:16.114]             ...future.value <- base::withVisible(base::local({
[11:02:16.114]                 ...future.makeSendCondition <- base::local({
[11:02:16.114]                   sendCondition <- NULL
[11:02:16.114]                   function(frame = 1L) {
[11:02:16.114]                     if (is.function(sendCondition)) 
[11:02:16.114]                       return(sendCondition)
[11:02:16.114]                     ns <- getNamespace("parallel")
[11:02:16.114]                     if (exists("sendData", mode = "function", 
[11:02:16.114]                       envir = ns)) {
[11:02:16.114]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:16.114]                         envir = ns)
[11:02:16.114]                       envir <- sys.frame(frame)
[11:02:16.114]                       master <- NULL
[11:02:16.114]                       while (!identical(envir, .GlobalEnv) && 
[11:02:16.114]                         !identical(envir, emptyenv())) {
[11:02:16.114]                         if (exists("master", mode = "list", envir = envir, 
[11:02:16.114]                           inherits = FALSE)) {
[11:02:16.114]                           master <- get("master", mode = "list", 
[11:02:16.114]                             envir = envir, inherits = FALSE)
[11:02:16.114]                           if (inherits(master, c("SOCKnode", 
[11:02:16.114]                             "SOCK0node"))) {
[11:02:16.114]                             sendCondition <<- function(cond) {
[11:02:16.114]                               data <- list(type = "VALUE", value = cond, 
[11:02:16.114]                                 success = TRUE)
[11:02:16.114]                               parallel_sendData(master, data)
[11:02:16.114]                             }
[11:02:16.114]                             return(sendCondition)
[11:02:16.114]                           }
[11:02:16.114]                         }
[11:02:16.114]                         frame <- frame + 1L
[11:02:16.114]                         envir <- sys.frame(frame)
[11:02:16.114]                       }
[11:02:16.114]                     }
[11:02:16.114]                     sendCondition <<- function(cond) NULL
[11:02:16.114]                   }
[11:02:16.114]                 })
[11:02:16.114]                 withCallingHandlers({
[11:02:16.114]                   {
[11:02:16.114]                     b <- 2L
[11:02:16.114]                     plan_b <- future::plan("list")
[11:02:16.114]                     nested_b <- nested_a[-1]
[11:02:16.114]                     stopifnot(length(nested_b) == 0L, length(plan_b) == 
[11:02:16.114]                       1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[11:02:16.114]                       "sequential"))
[11:02:16.114]                     list(a = a, nested_a = nested_a, plan_a = plan_a, 
[11:02:16.114]                       b = b, nested_b = nested_b, plan_b = plan_b)
[11:02:16.114]                   }
[11:02:16.114]                 }, immediateCondition = function(cond) {
[11:02:16.114]                   sendCondition <- ...future.makeSendCondition()
[11:02:16.114]                   sendCondition(cond)
[11:02:16.114]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.114]                   {
[11:02:16.114]                     inherits <- base::inherits
[11:02:16.114]                     invokeRestart <- base::invokeRestart
[11:02:16.114]                     is.null <- base::is.null
[11:02:16.114]                     muffled <- FALSE
[11:02:16.114]                     if (inherits(cond, "message")) {
[11:02:16.114]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:16.114]                       if (muffled) 
[11:02:16.114]                         invokeRestart("muffleMessage")
[11:02:16.114]                     }
[11:02:16.114]                     else if (inherits(cond, "warning")) {
[11:02:16.114]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:16.114]                       if (muffled) 
[11:02:16.114]                         invokeRestart("muffleWarning")
[11:02:16.114]                     }
[11:02:16.114]                     else if (inherits(cond, "condition")) {
[11:02:16.114]                       if (!is.null(pattern)) {
[11:02:16.114]                         computeRestarts <- base::computeRestarts
[11:02:16.114]                         grepl <- base::grepl
[11:02:16.114]                         restarts <- computeRestarts(cond)
[11:02:16.114]                         for (restart in restarts) {
[11:02:16.114]                           name <- restart$name
[11:02:16.114]                           if (is.null(name)) 
[11:02:16.114]                             next
[11:02:16.114]                           if (!grepl(pattern, name)) 
[11:02:16.114]                             next
[11:02:16.114]                           invokeRestart(restart)
[11:02:16.114]                           muffled <- TRUE
[11:02:16.114]                           break
[11:02:16.114]                         }
[11:02:16.114]                       }
[11:02:16.114]                     }
[11:02:16.114]                     invisible(muffled)
[11:02:16.114]                   }
[11:02:16.114]                   muffleCondition(cond)
[11:02:16.114]                 })
[11:02:16.114]             }))
[11:02:16.114]             future::FutureResult(value = ...future.value$value, 
[11:02:16.114]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:16.114]                   ...future.rng), globalenv = if (FALSE) 
[11:02:16.114]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:16.114]                     ...future.globalenv.names))
[11:02:16.114]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:16.114]         }, condition = base::local({
[11:02:16.114]             c <- base::c
[11:02:16.114]             inherits <- base::inherits
[11:02:16.114]             invokeRestart <- base::invokeRestart
[11:02:16.114]             length <- base::length
[11:02:16.114]             list <- base::list
[11:02:16.114]             seq.int <- base::seq.int
[11:02:16.114]             signalCondition <- base::signalCondition
[11:02:16.114]             sys.calls <- base::sys.calls
[11:02:16.114]             `[[` <- base::`[[`
[11:02:16.114]             `+` <- base::`+`
[11:02:16.114]             `<<-` <- base::`<<-`
[11:02:16.114]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:16.114]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:16.114]                   3L)]
[11:02:16.114]             }
[11:02:16.114]             function(cond) {
[11:02:16.114]                 is_error <- inherits(cond, "error")
[11:02:16.114]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:16.114]                   NULL)
[11:02:16.114]                 if (is_error) {
[11:02:16.114]                   sessionInformation <- function() {
[11:02:16.114]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:16.114]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:16.114]                       search = base::search(), system = base::Sys.info())
[11:02:16.114]                   }
[11:02:16.114]                   ...future.conditions[[length(...future.conditions) + 
[11:02:16.114]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:16.114]                     cond$call), session = sessionInformation(), 
[11:02:16.114]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:16.114]                   signalCondition(cond)
[11:02:16.114]                 }
[11:02:16.114]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:16.114]                 "immediateCondition"))) {
[11:02:16.114]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:16.114]                   ...future.conditions[[length(...future.conditions) + 
[11:02:16.114]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:16.114]                   if (TRUE && !signal) {
[11:02:16.114]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.114]                     {
[11:02:16.114]                       inherits <- base::inherits
[11:02:16.114]                       invokeRestart <- base::invokeRestart
[11:02:16.114]                       is.null <- base::is.null
[11:02:16.114]                       muffled <- FALSE
[11:02:16.114]                       if (inherits(cond, "message")) {
[11:02:16.114]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:16.114]                         if (muffled) 
[11:02:16.114]                           invokeRestart("muffleMessage")
[11:02:16.114]                       }
[11:02:16.114]                       else if (inherits(cond, "warning")) {
[11:02:16.114]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:16.114]                         if (muffled) 
[11:02:16.114]                           invokeRestart("muffleWarning")
[11:02:16.114]                       }
[11:02:16.114]                       else if (inherits(cond, "condition")) {
[11:02:16.114]                         if (!is.null(pattern)) {
[11:02:16.114]                           computeRestarts <- base::computeRestarts
[11:02:16.114]                           grepl <- base::grepl
[11:02:16.114]                           restarts <- computeRestarts(cond)
[11:02:16.114]                           for (restart in restarts) {
[11:02:16.114]                             name <- restart$name
[11:02:16.114]                             if (is.null(name)) 
[11:02:16.114]                               next
[11:02:16.114]                             if (!grepl(pattern, name)) 
[11:02:16.114]                               next
[11:02:16.114]                             invokeRestart(restart)
[11:02:16.114]                             muffled <- TRUE
[11:02:16.114]                             break
[11:02:16.114]                           }
[11:02:16.114]                         }
[11:02:16.114]                       }
[11:02:16.114]                       invisible(muffled)
[11:02:16.114]                     }
[11:02:16.114]                     muffleCondition(cond, pattern = "^muffle")
[11:02:16.114]                   }
[11:02:16.114]                 }
[11:02:16.114]                 else {
[11:02:16.114]                   if (TRUE) {
[11:02:16.114]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.114]                     {
[11:02:16.114]                       inherits <- base::inherits
[11:02:16.114]                       invokeRestart <- base::invokeRestart
[11:02:16.114]                       is.null <- base::is.null
[11:02:16.114]                       muffled <- FALSE
[11:02:16.114]                       if (inherits(cond, "message")) {
[11:02:16.114]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:16.114]                         if (muffled) 
[11:02:16.114]                           invokeRestart("muffleMessage")
[11:02:16.114]                       }
[11:02:16.114]                       else if (inherits(cond, "warning")) {
[11:02:16.114]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:16.114]                         if (muffled) 
[11:02:16.114]                           invokeRestart("muffleWarning")
[11:02:16.114]                       }
[11:02:16.114]                       else if (inherits(cond, "condition")) {
[11:02:16.114]                         if (!is.null(pattern)) {
[11:02:16.114]                           computeRestarts <- base::computeRestarts
[11:02:16.114]                           grepl <- base::grepl
[11:02:16.114]                           restarts <- computeRestarts(cond)
[11:02:16.114]                           for (restart in restarts) {
[11:02:16.114]                             name <- restart$name
[11:02:16.114]                             if (is.null(name)) 
[11:02:16.114]                               next
[11:02:16.114]                             if (!grepl(pattern, name)) 
[11:02:16.114]                               next
[11:02:16.114]                             invokeRestart(restart)
[11:02:16.114]                             muffled <- TRUE
[11:02:16.114]                             break
[11:02:16.114]                           }
[11:02:16.114]                         }
[11:02:16.114]                       }
[11:02:16.114]                       invisible(muffled)
[11:02:16.114]                     }
[11:02:16.114]                     muffleCondition(cond, pattern = "^muffle")
[11:02:16.114]                   }
[11:02:16.114]                 }
[11:02:16.114]             }
[11:02:16.114]         }))
[11:02:16.114]     }, error = function(ex) {
[11:02:16.114]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:16.114]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:16.114]                 ...future.rng), started = ...future.startTime, 
[11:02:16.114]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:16.114]             version = "1.8"), class = "FutureResult")
[11:02:16.114]     }, finally = {
[11:02:16.114]         if (!identical(...future.workdir, getwd())) 
[11:02:16.114]             setwd(...future.workdir)
[11:02:16.114]         {
[11:02:16.114]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:16.114]                 ...future.oldOptions$nwarnings <- NULL
[11:02:16.114]             }
[11:02:16.114]             base::options(...future.oldOptions)
[11:02:16.114]             if (.Platform$OS.type == "windows") {
[11:02:16.114]                 old_names <- names(...future.oldEnvVars)
[11:02:16.114]                 envs <- base::Sys.getenv()
[11:02:16.114]                 names <- names(envs)
[11:02:16.114]                 common <- intersect(names, old_names)
[11:02:16.114]                 added <- setdiff(names, old_names)
[11:02:16.114]                 removed <- setdiff(old_names, names)
[11:02:16.114]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:16.114]                   envs[common]]
[11:02:16.114]                 NAMES <- toupper(changed)
[11:02:16.114]                 args <- list()
[11:02:16.114]                 for (kk in seq_along(NAMES)) {
[11:02:16.114]                   name <- changed[[kk]]
[11:02:16.114]                   NAME <- NAMES[[kk]]
[11:02:16.114]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.114]                     next
[11:02:16.114]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:16.114]                 }
[11:02:16.114]                 NAMES <- toupper(added)
[11:02:16.114]                 for (kk in seq_along(NAMES)) {
[11:02:16.114]                   name <- added[[kk]]
[11:02:16.114]                   NAME <- NAMES[[kk]]
[11:02:16.114]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.114]                     next
[11:02:16.114]                   args[[name]] <- ""
[11:02:16.114]                 }
[11:02:16.114]                 NAMES <- toupper(removed)
[11:02:16.114]                 for (kk in seq_along(NAMES)) {
[11:02:16.114]                   name <- removed[[kk]]
[11:02:16.114]                   NAME <- NAMES[[kk]]
[11:02:16.114]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.114]                     next
[11:02:16.114]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:16.114]                 }
[11:02:16.114]                 if (length(args) > 0) 
[11:02:16.114]                   base::do.call(base::Sys.setenv, args = args)
[11:02:16.114]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:16.114]             }
[11:02:16.114]             else {
[11:02:16.114]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:16.114]             }
[11:02:16.114]             {
[11:02:16.114]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:16.114]                   0L) {
[11:02:16.114]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:16.114]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:16.114]                   base::options(opts)
[11:02:16.114]                 }
[11:02:16.114]                 {
[11:02:16.114]                   {
[11:02:16.114]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:16.114]                     NULL
[11:02:16.114]                   }
[11:02:16.114]                   options(future.plan = NULL)
[11:02:16.114]                   if (is.na(NA_character_)) 
[11:02:16.114]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:16.114]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:16.114]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:16.114]                     .init = FALSE)
[11:02:16.114]                 }
[11:02:16.114]             }
[11:02:16.114]         }
[11:02:16.114]     })
[11:02:16.114]     if (TRUE) {
[11:02:16.114]         base::sink(type = "output", split = FALSE)
[11:02:16.114]         if (TRUE) {
[11:02:16.114]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:16.114]         }
[11:02:16.114]         else {
[11:02:16.114]             ...future.result["stdout"] <- base::list(NULL)
[11:02:16.114]         }
[11:02:16.114]         base::close(...future.stdout)
[11:02:16.114]         ...future.stdout <- NULL
[11:02:16.114]     }
[11:02:16.114]     ...future.result$conditions <- ...future.conditions
[11:02:16.114]     ...future.result$finished <- base::Sys.time()
[11:02:16.114]     ...future.result
[11:02:16.114] }
[11:02:16.289]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.165] Exporting 3 global objects (11.47 KiB) to cluster node #1 ...
[11:02:16.289]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.165] Exporting ‘nested_a’ (5.89 KiB) to cluster node #1 ...
[11:02:16.289]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.165] Exporting ‘nested_a’ (5.89 KiB) to cluster node #1 ... DONE
[11:02:16.289]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.166] Exporting ‘a’ (35 bytes) to cluster node #1 ...
[11:02:16.289]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.166] Exporting ‘a’ (35 bytes) to cluster node #1 ... DONE
[11:02:16.289]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.166] Exporting ‘plan_a’ (5.89 KiB) to cluster node #1 ...
[11:02:16.289]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.207] Exporting ‘plan_a’ (5.89 KiB) to cluster node #1 ... DONE
[11:02:16.289]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.207] Exporting 3 global objects (11.47 KiB) to cluster node #1 ... DONE
[11:02:16.290]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.207] MultisessionFuture started
[11:02:16.290]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.208] - Launch lazy future ... done
[11:02:16.290]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.208] run() for ‘MultisessionFuture’ ... done
[11:02:16.290]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.208] result() for ClusterFuture ...
[11:02:16.290]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.208] receiveMessageFromWorker() for ClusterFuture ...
[11:02:16.290]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.208] - Validating connection of MultisessionFuture
[11:02:16.290]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.279] - received message: FutureResult
[11:02:16.291]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.279] - Received FutureResult
[11:02:16.291]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.279] - Erased future from FutureRegistry
[11:02:16.291]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.279] result() for ClusterFuture ...
[11:02:16.291]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.279] - result already collected: FutureResult
[11:02:16.291]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.279] result() for ClusterFuture ... done
[11:02:16.291]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.280] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:16.291]  - Condition #64: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.280] result() for ClusterFuture ... done
[11:02:16.291]  - Condition #65: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.280] result() for ClusterFuture ...
[11:02:16.292]  - Condition #66: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.280] - result already collected: FutureResult
[11:02:16.292]  - Condition #67: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.280] result() for ClusterFuture ... done
[11:02:16.292] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "cleanup")=function ()  
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "cleanup")=function ()  
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[11:02:16.299] getGlobalsAndPackages() ...
[11:02:16.299] Searching for globals...
[11:02:16.301] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[11:02:16.301] Searching for globals ... DONE
[11:02:16.301] Resolving globals: FALSE
[11:02:16.301] The total size of the 1 globals is 356 bytes (356 bytes)
[11:02:16.302] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[11:02:16.302] - globals: [1] ‘data’
[11:02:16.302] - packages: [1] ‘future’
[11:02:16.302] getGlobalsAndPackages() ... DONE
[11:02:16.303] run() for ‘Future’ ...
[11:02:16.303] - state: ‘created’
[11:02:16.303] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:02:16.303] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:16.303] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:16.303]   - Field: ‘label’
[11:02:16.304]   - Field: ‘local’
[11:02:16.304]   - Field: ‘owner’
[11:02:16.304]   - Field: ‘envir’
[11:02:16.304]   - Field: ‘packages’
[11:02:16.304]   - Field: ‘gc’
[11:02:16.304]   - Field: ‘conditions’
[11:02:16.304]   - Field: ‘expr’
[11:02:16.304]   - Field: ‘uuid’
[11:02:16.304]   - Field: ‘seed’
[11:02:16.304]   - Field: ‘version’
[11:02:16.305]   - Field: ‘result’
[11:02:16.305]   - Field: ‘asynchronous’
[11:02:16.305]   - Field: ‘calls’
[11:02:16.305]   - Field: ‘globals’
[11:02:16.305]   - Field: ‘stdout’
[11:02:16.305]   - Field: ‘earlySignal’
[11:02:16.305]   - Field: ‘lazy’
[11:02:16.305]   - Field: ‘state’
[11:02:16.305] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:16.306] - Launch lazy future ...
[11:02:16.306] Packages needed by the future expression (n = 1): ‘future’
[11:02:16.306] Packages needed by future strategies (n = 1): ‘future’
[11:02:16.307] {
[11:02:16.307]     {
[11:02:16.307]         {
[11:02:16.307]             ...future.startTime <- base::Sys.time()
[11:02:16.307]             {
[11:02:16.307]                 {
[11:02:16.307]                   {
[11:02:16.307]                     {
[11:02:16.307]                       base::local({
[11:02:16.307]                         has_future <- base::requireNamespace("future", 
[11:02:16.307]                           quietly = TRUE)
[11:02:16.307]                         if (has_future) {
[11:02:16.307]                           ns <- base::getNamespace("future")
[11:02:16.307]                           version <- ns[[".package"]][["version"]]
[11:02:16.307]                           if (is.null(version)) 
[11:02:16.307]                             version <- utils::packageVersion("future")
[11:02:16.307]                         }
[11:02:16.307]                         else {
[11:02:16.307]                           version <- NULL
[11:02:16.307]                         }
[11:02:16.307]                         if (!has_future || version < "1.8.0") {
[11:02:16.307]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:16.307]                             "", base::R.version$version.string), 
[11:02:16.307]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:16.307]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:16.307]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:16.307]                               "release", "version")], collapse = " "), 
[11:02:16.307]                             hostname = base::Sys.info()[["nodename"]])
[11:02:16.307]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:16.307]                             info)
[11:02:16.307]                           info <- base::paste(info, collapse = "; ")
[11:02:16.307]                           if (!has_future) {
[11:02:16.307]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:16.307]                               info)
[11:02:16.307]                           }
[11:02:16.307]                           else {
[11:02:16.307]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:16.307]                               info, version)
[11:02:16.307]                           }
[11:02:16.307]                           base::stop(msg)
[11:02:16.307]                         }
[11:02:16.307]                       })
[11:02:16.307]                     }
[11:02:16.307]                     base::local({
[11:02:16.307]                       for (pkg in "future") {
[11:02:16.307]                         base::loadNamespace(pkg)
[11:02:16.307]                         base::library(pkg, character.only = TRUE)
[11:02:16.307]                       }
[11:02:16.307]                     })
[11:02:16.307]                   }
[11:02:16.307]                   ...future.strategy.old <- future::plan("list")
[11:02:16.307]                   options(future.plan = NULL)
[11:02:16.307]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:16.307]                   future::plan(list(b = function (..., workers = availableCores(), 
[11:02:16.307]                     lazy = FALSE, rscript_libs = .libPaths(), 
[11:02:16.307]                     envir = parent.frame()) 
[11:02:16.307]                   {
[11:02:16.307]                     if (is.function(workers)) 
[11:02:16.307]                       workers <- workers()
[11:02:16.307]                     workers <- structure(as.integer(workers), 
[11:02:16.307]                       class = class(workers))
[11:02:16.307]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[11:02:16.307]                       workers >= 1)
[11:02:16.307]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[11:02:16.307]                       return(sequential(..., lazy = TRUE, envir = envir))
[11:02:16.307]                     }
[11:02:16.307]                     future <- MultisessionFuture(..., workers = workers, 
[11:02:16.307]                       lazy = lazy, rscript_libs = rscript_libs, 
[11:02:16.307]                       envir = envir)
[11:02:16.307]                     if (!future$lazy) 
[11:02:16.307]                       future <- run(future)
[11:02:16.307]                     invisible(future)
[11:02:16.307]                   }), .cleanup = FALSE, .init = FALSE)
[11:02:16.307]                 }
[11:02:16.307]                 ...future.workdir <- getwd()
[11:02:16.307]             }
[11:02:16.307]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:16.307]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:16.307]         }
[11:02:16.307]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:16.307]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:16.307]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:16.307]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:16.307]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:16.307]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:16.307]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:16.307]             base::names(...future.oldOptions))
[11:02:16.307]     }
[11:02:16.307]     if (FALSE) {
[11:02:16.307]     }
[11:02:16.307]     else {
[11:02:16.307]         if (TRUE) {
[11:02:16.307]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:16.307]                 open = "w")
[11:02:16.307]         }
[11:02:16.307]         else {
[11:02:16.307]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:16.307]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:16.307]         }
[11:02:16.307]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:16.307]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:16.307]             base::sink(type = "output", split = FALSE)
[11:02:16.307]             base::close(...future.stdout)
[11:02:16.307]         }, add = TRUE)
[11:02:16.307]     }
[11:02:16.307]     ...future.frame <- base::sys.nframe()
[11:02:16.307]     ...future.conditions <- base::list()
[11:02:16.307]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:16.307]     if (FALSE) {
[11:02:16.307]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:16.307]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:16.307]     }
[11:02:16.307]     ...future.result <- base::tryCatch({
[11:02:16.307]         base::withCallingHandlers({
[11:02:16.307]             ...future.value <- base::withVisible(base::local({
[11:02:16.307]                 value(future(subset(data, a == 2)))
[11:02:16.307]             }))
[11:02:16.307]             future::FutureResult(value = ...future.value$value, 
[11:02:16.307]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:16.307]                   ...future.rng), globalenv = if (FALSE) 
[11:02:16.307]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:16.307]                     ...future.globalenv.names))
[11:02:16.307]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:16.307]         }, condition = base::local({
[11:02:16.307]             c <- base::c
[11:02:16.307]             inherits <- base::inherits
[11:02:16.307]             invokeRestart <- base::invokeRestart
[11:02:16.307]             length <- base::length
[11:02:16.307]             list <- base::list
[11:02:16.307]             seq.int <- base::seq.int
[11:02:16.307]             signalCondition <- base::signalCondition
[11:02:16.307]             sys.calls <- base::sys.calls
[11:02:16.307]             `[[` <- base::`[[`
[11:02:16.307]             `+` <- base::`+`
[11:02:16.307]             `<<-` <- base::`<<-`
[11:02:16.307]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:16.307]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:16.307]                   3L)]
[11:02:16.307]             }
[11:02:16.307]             function(cond) {
[11:02:16.307]                 is_error <- inherits(cond, "error")
[11:02:16.307]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:16.307]                   NULL)
[11:02:16.307]                 if (is_error) {
[11:02:16.307]                   sessionInformation <- function() {
[11:02:16.307]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:16.307]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:16.307]                       search = base::search(), system = base::Sys.info())
[11:02:16.307]                   }
[11:02:16.307]                   ...future.conditions[[length(...future.conditions) + 
[11:02:16.307]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:16.307]                     cond$call), session = sessionInformation(), 
[11:02:16.307]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:16.307]                   signalCondition(cond)
[11:02:16.307]                 }
[11:02:16.307]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:16.307]                 "immediateCondition"))) {
[11:02:16.307]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:16.307]                   ...future.conditions[[length(...future.conditions) + 
[11:02:16.307]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:16.307]                   if (TRUE && !signal) {
[11:02:16.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.307]                     {
[11:02:16.307]                       inherits <- base::inherits
[11:02:16.307]                       invokeRestart <- base::invokeRestart
[11:02:16.307]                       is.null <- base::is.null
[11:02:16.307]                       muffled <- FALSE
[11:02:16.307]                       if (inherits(cond, "message")) {
[11:02:16.307]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:16.307]                         if (muffled) 
[11:02:16.307]                           invokeRestart("muffleMessage")
[11:02:16.307]                       }
[11:02:16.307]                       else if (inherits(cond, "warning")) {
[11:02:16.307]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:16.307]                         if (muffled) 
[11:02:16.307]                           invokeRestart("muffleWarning")
[11:02:16.307]                       }
[11:02:16.307]                       else if (inherits(cond, "condition")) {
[11:02:16.307]                         if (!is.null(pattern)) {
[11:02:16.307]                           computeRestarts <- base::computeRestarts
[11:02:16.307]                           grepl <- base::grepl
[11:02:16.307]                           restarts <- computeRestarts(cond)
[11:02:16.307]                           for (restart in restarts) {
[11:02:16.307]                             name <- restart$name
[11:02:16.307]                             if (is.null(name)) 
[11:02:16.307]                               next
[11:02:16.307]                             if (!grepl(pattern, name)) 
[11:02:16.307]                               next
[11:02:16.307]                             invokeRestart(restart)
[11:02:16.307]                             muffled <- TRUE
[11:02:16.307]                             break
[11:02:16.307]                           }
[11:02:16.307]                         }
[11:02:16.307]                       }
[11:02:16.307]                       invisible(muffled)
[11:02:16.307]                     }
[11:02:16.307]                     muffleCondition(cond, pattern = "^muffle")
[11:02:16.307]                   }
[11:02:16.307]                 }
[11:02:16.307]                 else {
[11:02:16.307]                   if (TRUE) {
[11:02:16.307]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.307]                     {
[11:02:16.307]                       inherits <- base::inherits
[11:02:16.307]                       invokeRestart <- base::invokeRestart
[11:02:16.307]                       is.null <- base::is.null
[11:02:16.307]                       muffled <- FALSE
[11:02:16.307]                       if (inherits(cond, "message")) {
[11:02:16.307]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:16.307]                         if (muffled) 
[11:02:16.307]                           invokeRestart("muffleMessage")
[11:02:16.307]                       }
[11:02:16.307]                       else if (inherits(cond, "warning")) {
[11:02:16.307]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:16.307]                         if (muffled) 
[11:02:16.307]                           invokeRestart("muffleWarning")
[11:02:16.307]                       }
[11:02:16.307]                       else if (inherits(cond, "condition")) {
[11:02:16.307]                         if (!is.null(pattern)) {
[11:02:16.307]                           computeRestarts <- base::computeRestarts
[11:02:16.307]                           grepl <- base::grepl
[11:02:16.307]                           restarts <- computeRestarts(cond)
[11:02:16.307]                           for (restart in restarts) {
[11:02:16.307]                             name <- restart$name
[11:02:16.307]                             if (is.null(name)) 
[11:02:16.307]                               next
[11:02:16.307]                             if (!grepl(pattern, name)) 
[11:02:16.307]                               next
[11:02:16.307]                             invokeRestart(restart)
[11:02:16.307]                             muffled <- TRUE
[11:02:16.307]                             break
[11:02:16.307]                           }
[11:02:16.307]                         }
[11:02:16.307]                       }
[11:02:16.307]                       invisible(muffled)
[11:02:16.307]                     }
[11:02:16.307]                     muffleCondition(cond, pattern = "^muffle")
[11:02:16.307]                   }
[11:02:16.307]                 }
[11:02:16.307]             }
[11:02:16.307]         }))
[11:02:16.307]     }, error = function(ex) {
[11:02:16.307]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:16.307]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:16.307]                 ...future.rng), started = ...future.startTime, 
[11:02:16.307]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:16.307]             version = "1.8"), class = "FutureResult")
[11:02:16.307]     }, finally = {
[11:02:16.307]         if (!identical(...future.workdir, getwd())) 
[11:02:16.307]             setwd(...future.workdir)
[11:02:16.307]         {
[11:02:16.307]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:16.307]                 ...future.oldOptions$nwarnings <- NULL
[11:02:16.307]             }
[11:02:16.307]             base::options(...future.oldOptions)
[11:02:16.307]             if (.Platform$OS.type == "windows") {
[11:02:16.307]                 old_names <- names(...future.oldEnvVars)
[11:02:16.307]                 envs <- base::Sys.getenv()
[11:02:16.307]                 names <- names(envs)
[11:02:16.307]                 common <- intersect(names, old_names)
[11:02:16.307]                 added <- setdiff(names, old_names)
[11:02:16.307]                 removed <- setdiff(old_names, names)
[11:02:16.307]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:16.307]                   envs[common]]
[11:02:16.307]                 NAMES <- toupper(changed)
[11:02:16.307]                 args <- list()
[11:02:16.307]                 for (kk in seq_along(NAMES)) {
[11:02:16.307]                   name <- changed[[kk]]
[11:02:16.307]                   NAME <- NAMES[[kk]]
[11:02:16.307]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.307]                     next
[11:02:16.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:16.307]                 }
[11:02:16.307]                 NAMES <- toupper(added)
[11:02:16.307]                 for (kk in seq_along(NAMES)) {
[11:02:16.307]                   name <- added[[kk]]
[11:02:16.307]                   NAME <- NAMES[[kk]]
[11:02:16.307]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.307]                     next
[11:02:16.307]                   args[[name]] <- ""
[11:02:16.307]                 }
[11:02:16.307]                 NAMES <- toupper(removed)
[11:02:16.307]                 for (kk in seq_along(NAMES)) {
[11:02:16.307]                   name <- removed[[kk]]
[11:02:16.307]                   NAME <- NAMES[[kk]]
[11:02:16.307]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.307]                     next
[11:02:16.307]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:16.307]                 }
[11:02:16.307]                 if (length(args) > 0) 
[11:02:16.307]                   base::do.call(base::Sys.setenv, args = args)
[11:02:16.307]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:16.307]             }
[11:02:16.307]             else {
[11:02:16.307]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:16.307]             }
[11:02:16.307]             {
[11:02:16.307]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:16.307]                   0L) {
[11:02:16.307]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:16.307]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:16.307]                   base::options(opts)
[11:02:16.307]                 }
[11:02:16.307]                 {
[11:02:16.307]                   {
[11:02:16.307]                     NULL
[11:02:16.307]                     RNGkind("Mersenne-Twister")
[11:02:16.307]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:16.307]                       inherits = FALSE)
[11:02:16.307]                   }
[11:02:16.307]                   options(future.plan = NULL)
[11:02:16.307]                   if (is.na(NA_character_)) 
[11:02:16.307]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:16.307]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:16.307]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:16.307]                     .init = FALSE)
[11:02:16.307]                 }
[11:02:16.307]             }
[11:02:16.307]         }
[11:02:16.307]     })
[11:02:16.307]     if (TRUE) {
[11:02:16.307]         base::sink(type = "output", split = FALSE)
[11:02:16.307]         if (TRUE) {
[11:02:16.307]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:16.307]         }
[11:02:16.307]         else {
[11:02:16.307]             ...future.result["stdout"] <- base::list(NULL)
[11:02:16.307]         }
[11:02:16.307]         base::close(...future.stdout)
[11:02:16.307]         ...future.stdout <- NULL
[11:02:16.307]     }
[11:02:16.307]     ...future.result$conditions <- ...future.conditions
[11:02:16.307]     ...future.result$finished <- base::Sys.time()
[11:02:16.307]     ...future.result
[11:02:16.307] }
[11:02:16.309] assign_globals() ...
[11:02:16.309] List of 1
[11:02:16.309]  $ data:'data.frame':	3 obs. of  2 variables:
[11:02:16.309]   ..$ a: int [1:3] 1 2 3
[11:02:16.309]   ..$ b: int [1:3] 3 2 1
[11:02:16.309]  - attr(*, "where")=List of 1
[11:02:16.309]   ..$ data:<environment: R_EmptyEnv> 
[11:02:16.309]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:02:16.309]  - attr(*, "resolved")= logi FALSE
[11:02:16.309]  - attr(*, "total_size")= num 356
[11:02:16.309]  - attr(*, "already-done")= logi TRUE
[11:02:16.313] - copied ‘data’ to environment
[11:02:16.313] assign_globals() ... done
[11:02:16.313] plan(): Setting new future strategy stack:
[11:02:16.313] List of future strategies:
[11:02:16.313] 1. multisession:
[11:02:16.313]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:02:16.313]    - tweaked: FALSE
[11:02:16.313]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:16.315] plan(): nbrOfWorkers() = 2
[11:02:16.409] plan(): Setting new future strategy stack:
[11:02:16.409] List of future strategies:
[11:02:16.409] 1. sequential:
[11:02:16.409]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:16.409]    - tweaked: FALSE
[11:02:16.409]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:16.409] 2. multisession:
[11:02:16.409]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:02:16.409]    - tweaked: FALSE
[11:02:16.409]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:16.410] plan(): nbrOfWorkers() = 1
[11:02:16.410] SequentialFuture started (and completed)
[11:02:16.410] signalConditions() ...
[11:02:16.410]  - include = ‘immediateCondition’
[11:02:16.411]  - exclude = 
[11:02:16.411]  - resignal = FALSE
[11:02:16.411]  - Number of conditions: 63
[11:02:16.411] signalConditions() ... done
[11:02:16.411] - Launch lazy future ... done
[11:02:16.411] run() for ‘SequentialFuture’ ... done
[11:02:16.411] signalConditions() ...
[11:02:16.411]  - include = ‘immediateCondition’
[11:02:16.411]  - exclude = 
[11:02:16.411]  - resignal = FALSE
[11:02:16.411]  - Number of conditions: 63
[11:02:16.412] signalConditions() ... done
[11:02:16.412] Future state: ‘finished’
[11:02:16.412] signalConditions() ...
[11:02:16.412]  - include = ‘condition’
[11:02:16.412]  - exclude = ‘immediateCondition’
[11:02:16.412]  - resignal = TRUE
[11:02:16.412]  - Number of conditions: 63
[11:02:16.412]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.316] getGlobalsAndPackages() ...
[11:02:16.412]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.316] Searching for globals...
[11:02:16.412]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.334] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[11:02:16.413]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.334] Searching for globals ... DONE
[11:02:16.413]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.334] Resolving globals: FALSE
[11:02:16.413]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.335] The total size of the 1 globals is 356 bytes (356 bytes)
[11:02:16.413]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.335] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[11:02:16.413]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.335] - globals: [1] ‘data’
[11:02:16.413]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.335] 
[11:02:16.413]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.335] getGlobalsAndPackages() ... DONE
[11:02:16.413]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.336] run() for ‘Future’ ...
[11:02:16.413]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.336] - state: ‘created’
[11:02:16.414]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.336] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:16.414]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.351] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:16.414]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.351] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:16.414]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.351]   - Field: ‘node’
[11:02:16.414]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.351]   - Field: ‘label’
[11:02:16.414]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.351]   - Field: ‘local’
[11:02:16.414]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.351]   - Field: ‘owner’
[11:02:16.414]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.351]   - Field: ‘envir’
[11:02:16.414]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.352]   - Field: ‘workers’
[11:02:16.415]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.352]   - Field: ‘packages’
[11:02:16.415]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.352]   - Field: ‘gc’
[11:02:16.415]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.352]   - Field: ‘conditions’
[11:02:16.415]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.352]   - Field: ‘persistent’
[11:02:16.415]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.352]   - Field: ‘expr’
[11:02:16.415]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.352]   - Field: ‘uuid’
[11:02:16.415]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.352]   - Field: ‘seed’
[11:02:16.415]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.353]   - Field: ‘version’
[11:02:16.416]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.353]   - Field: ‘result’
[11:02:16.416]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.353]   - Field: ‘asynchronous’
[11:02:16.416]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.353]   - Field: ‘calls’
[11:02:16.416]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.353]   - Field: ‘globals’
[11:02:16.416]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.353]   - Field: ‘stdout’
[11:02:16.416]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.353]   - Field: ‘earlySignal’
[11:02:16.416]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.357]   - Field: ‘lazy’
[11:02:16.416]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.358]   - Field: ‘state’
[11:02:16.416]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.358] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:16.417]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.358] - Launch lazy future ...
[11:02:16.417]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.358] Packages needed by the future expression (n = 0): <none>
[11:02:16.417]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.358] Packages needed by future strategies (n = 0): <none>
[11:02:16.417]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.359] {
[11:02:16.359]     {
[11:02:16.359]         {
[11:02:16.359]             ...future.startTime <- base::Sys.time()
[11:02:16.359]             {
[11:02:16.359]                 {
[11:02:16.359]                   {
[11:02:16.359]                     {
[11:02:16.359]                       base::local({
[11:02:16.359]                         has_future <- base::requireNamespace("future", 
[11:02:16.359]                           quietly = TRUE)
[11:02:16.359]                         if (has_future) {
[11:02:16.359]                           ns <- base::getNamespace("future")
[11:02:16.359]                           version <- ns[[".package"]][["version"]]
[11:02:16.359]                           if (is.null(version)) 
[11:02:16.359]                             version <- utils::packageVersion("future")
[11:02:16.359]                         }
[11:02:16.359]                         else {
[11:02:16.359]                           version <- NULL
[11:02:16.359]                         }
[11:02:16.359]                         if (!has_future || version < "1.8.0") {
[11:02:16.359]                           info <- base::c(r_version = base::gsub("R version ", 
[11:02:16.359]                             "", base::R.version$version.string), 
[11:02:16.359]                             platform = base::sprintf("%s (%s-bit)", 
[11:02:16.359]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:16.359]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:16.359]                               "release", "version")], collapse = " "), 
[11:02:16.359]                             hostname = base::Sys.info()[["nodename"]])
[11:02:16.359]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:02:16.359]                             info)
[11:02:16.359]                           info <- base::paste(info, collapse = "; ")
[11:02:16.359]                           if (!has_future) {
[11:02:16.359]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:16.359]                               info)
[11:02:16.359]                           }
[11:02:16.359]                           else {
[11:02:16.359]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:16.359]                               info, version)
[11:02:16.359]                           }
[11:02:16.359]                           base::stop(msg)
[11:02:16.359]                         }
[11:02:16.359]                       })
[11:02:16.359]                     }
[11:02:16.359]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:16.359]                     base::options(mc.cores = 1L)
[11:02:16.359]                   }
[11:02:16.359]                   ...future.strategy.old <- future::plan("list")
[11:02:16.359]                   options(future.plan = NULL)
[11:02:16.359]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:16.359]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:16.359]                 }
[11:02:16.359]                 ...future.workdir <- getwd()
[11:02:16.359]             }
[11:02:16.359]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:16.359]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:16.359]         }
[11:02:16.359]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:16.359]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:16.359]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:16.359]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:16.359]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:16.359]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:16.359]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:16.359]             base::names(...future.oldOptions))
[11:02:16.359]     }
[11:02:16.359]     if (FALSE) {
[11:02:16.359]     }
[11:02:16.359]     else {
[11:02:16.359]         if (TRUE) {
[11:02:16.359]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:16.359]                 open = "w")
[11:02:16.359]         }
[11:02:16.359]         else {
[11:02:16.359]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:16.359]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:16.359]         }
[11:02:16.359]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:16.359]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:16.359]             base::sink(type = "output", split = FALSE)
[11:02:16.359]             base::close(...future.stdout)
[11:02:16.359]         }, add = TRUE)
[11:02:16.359]     }
[11:02:16.359]     ...future.frame <- base::sys.nframe()
[11:02:16.359]     ...future.conditions <- base::list()
[11:02:16.359]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:16.359]     if (FALSE) {
[11:02:16.359]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:16.359]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:16.359]     }
[11:02:16.359]     ...future.result <- base::tryCatch({
[11:02:16.359]         base::withCallingHandlers({
[11:02:16.359]             ...future.value <- base::withVisible(base::local({
[11:02:16.359]                 ...future.makeSendCondition <- base::local({
[11:02:16.359]                   sendCondition <- NULL
[11:02:16.359]                   function(frame = 1L) {
[11:02:16.359]                     if (is.function(sendCondition)) 
[11:02:16.359]                       return(sendCondition)
[11:02:16.359]                     ns <- getNamespace("parallel")
[11:02:16.359]                     if (exists("sendData", mode = "function", 
[11:02:16.359]                       envir = ns)) {
[11:02:16.359]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:16.359]                         envir = ns)
[11:02:16.359]                       envir <- sys.frame(frame)
[11:02:16.359]                       master <- NULL
[11:02:16.359]                       while (!identical(envir, .GlobalEnv) && 
[11:02:16.359]                         !identical(envir, emptyenv())) {
[11:02:16.359]                         if (exists("master", mode = "list", envir = envir, 
[11:02:16.359]                           inherits = FALSE)) {
[11:02:16.359]                           master <- get("master", mode = "list", 
[11:02:16.359]                             envir = envir, inherits = FALSE)
[11:02:16.359]                           if (inherits(master, c("SOCKnode", 
[11:02:16.359]                             "SOCK0node"))) {
[11:02:16.359]                             sendCondition <<- function(cond) {
[11:02:16.359]                               data <- list(type = "VALUE", value = cond, 
[11:02:16.359]                                 success = TRUE)
[11:02:16.359]                               parallel_sendData(master, data)
[11:02:16.359]                             }
[11:02:16.359]                             return(sendCondition)
[11:02:16.359]                           }
[11:02:16.359]                         }
[11:02:16.359]                         frame <- frame + 1L
[11:02:16.359]                         envir <- sys.frame(frame)
[11:02:16.359]                       }
[11:02:16.359]                     }
[11:02:16.359]                     sendCondition <<- function(cond) NULL
[11:02:16.359]                   }
[11:02:16.359]                 })
[11:02:16.359]                 withCallingHandlers({
[11:02:16.359]                   subset(data, a == 2)
[11:02:16.359]                 }, immediateCondition = function(cond) {
[11:02:16.359]                   sendCondition <- ...future.makeSendCondition()
[11:02:16.359]                   sendCondition(cond)
[11:02:16.359]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.359]                   {
[11:02:16.359]                     inherits <- base::inherits
[11:02:16.359]                     invokeRestart <- base::invokeRestart
[11:02:16.359]                     is.null <- base::is.null
[11:02:16.359]                     muffled <- FALSE
[11:02:16.359]                     if (inherits(cond, "message")) {
[11:02:16.359]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:16.359]                       if (muffled) 
[11:02:16.359]                         invokeRestart("muffleMessage")
[11:02:16.359]                     }
[11:02:16.359]                     else if (inherits(cond, "warning")) {
[11:02:16.359]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:16.359]                       if (muffled) 
[11:02:16.359]                         invokeRestart("muffleWarning")
[11:02:16.359]                     }
[11:02:16.359]                     else if (inherits(cond, "condition")) {
[11:02:16.359]                       if (!is.null(pattern)) {
[11:02:16.359]                         computeRestarts <- base::computeRestarts
[11:02:16.359]                         grepl <- base::grepl
[11:02:16.359]                         restarts <- computeRestarts(cond)
[11:02:16.359]                         for (restart in restarts) {
[11:02:16.359]                           name <- restart$name
[11:02:16.359]                           if (is.null(name)) 
[11:02:16.359]                             next
[11:02:16.359]                           if (!grepl(pattern, name)) 
[11:02:16.359]                             next
[11:02:16.359]                           invokeRestart(restart)
[11:02:16.359]                           muffled <- TRUE
[11:02:16.359]                           break
[11:02:16.359]                         }
[11:02:16.359]                       }
[11:02:16.359]                     }
[11:02:16.359]                     invisible(muffled)
[11:02:16.359]                   }
[11:02:16.359]                   muffleCondition(cond)
[11:02:16.359]                 })
[11:02:16.359]             }))
[11:02:16.359]             future::FutureResult(value = ...future.value$value, 
[11:02:16.359]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:16.359]                   ...future.rng), globalenv = if (FALSE) 
[11:02:16.359]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:16.359]                     ...future.globalenv.names))
[11:02:16.359]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:16.359]         }, condition = base::local({
[11:02:16.359]             c <- base::c
[11:02:16.359]             inherits <- base::inherits
[11:02:16.359]             invokeRestart <- base::invokeRestart
[11:02:16.359]             length <- base::length
[11:02:16.359]             list <- base::list
[11:02:16.359]             seq.int <- base::seq.int
[11:02:16.359]             signalCondition <- base::signalCondition
[11:02:16.359]             sys.calls <- base::sys.calls
[11:02:16.359]             `[[` <- base::`[[`
[11:02:16.359]             `+` <- base::`+`
[11:02:16.359]             `<<-` <- base::`<<-`
[11:02:16.359]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:16.359]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:16.359]                   3L)]
[11:02:16.359]             }
[11:02:16.359]             function(cond) {
[11:02:16.359]                 is_error <- inherits(cond, "error")
[11:02:16.359]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:16.359]                   NULL)
[11:02:16.359]                 if (is_error) {
[11:02:16.359]                   sessionInformation <- function() {
[11:02:16.359]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:16.359]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:16.359]                       search = base::search(), system = base::Sys.info())
[11:02:16.359]                   }
[11:02:16.359]                   ...future.conditions[[length(...future.conditions) + 
[11:02:16.359]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:16.359]                     cond$call), session = sessionInformation(), 
[11:02:16.359]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:16.359]                   signalCondition(cond)
[11:02:16.359]                 }
[11:02:16.359]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:16.359]                 "immediateCondition"))) {
[11:02:16.359]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:16.359]                   ...future.conditions[[length(...future.conditions) + 
[11:02:16.359]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:16.359]                   if (TRUE && !signal) {
[11:02:16.359]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.359]                     {
[11:02:16.359]                       inherits <- base::inherits
[11:02:16.359]                       invokeRestart <- base::invokeRestart
[11:02:16.359]                       is.null <- base::is.null
[11:02:16.359]                       muffled <- FALSE
[11:02:16.359]                       if (inherits(cond, "message")) {
[11:02:16.359]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:16.359]                         if (muffled) 
[11:02:16.359]                           invokeRestart("muffleMessage")
[11:02:16.359]                       }
[11:02:16.359]                       else if (inherits(cond, "warning")) {
[11:02:16.359]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:16.359]                         if (muffled) 
[11:02:16.359]                           invokeRestart("muffleWarning")
[11:02:16.359]                       }
[11:02:16.359]                       else if (inherits(cond, "condition")) {
[11:02:16.359]                         if (!is.null(pattern)) {
[11:02:16.359]                           computeRestarts <- base::computeRestarts
[11:02:16.359]                           grepl <- base::grepl
[11:02:16.359]                           restarts <- computeRestarts(cond)
[11:02:16.359]                           for (restart in restarts) {
[11:02:16.359]                             name <- restart$name
[11:02:16.359]                             if (is.null(name)) 
[11:02:16.359]                               next
[11:02:16.359]                             if (!grepl(pattern, name)) 
[11:02:16.359]                               next
[11:02:16.359]                             invokeRestart(restart)
[11:02:16.359]                             muffled <- TRUE
[11:02:16.359]                             break
[11:02:16.359]                           }
[11:02:16.359]                         }
[11:02:16.359]                       }
[11:02:16.359]                       invisible(muffled)
[11:02:16.359]                     }
[11:02:16.359]                     muffleCondition(cond, pattern = "^muffle")
[11:02:16.359]                   }
[11:02:16.359]                 }
[11:02:16.359]                 else {
[11:02:16.359]                   if (TRUE) {
[11:02:16.359]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.359]                     {
[11:02:16.359]                       inherits <- base::inherits
[11:02:16.359]                       invokeRestart <- base::invokeRestart
[11:02:16.359]                       is.null <- base::is.null
[11:02:16.359]                       muffled <- FALSE
[11:02:16.359]                       if (inherits(cond, "message")) {
[11:02:16.359]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:16.359]                         if (muffled) 
[11:02:16.359]                           invokeRestart("muffleMessage")
[11:02:16.359]                       }
[11:02:16.359]                       else if (inherits(cond, "warning")) {
[11:02:16.359]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:16.359]                         if (muffled) 
[11:02:16.359]                           invokeRestart("muffleWarning")
[11:02:16.359]                       }
[11:02:16.359]                       else if (inherits(cond, "condition")) {
[11:02:16.359]                         if (!is.null(pattern)) {
[11:02:16.359]                           computeRestarts <- base::computeRestarts
[11:02:16.359]                           grepl <- base::grepl
[11:02:16.359]                           restarts <- computeRestarts(cond)
[11:02:16.359]                           for (restart in restarts) {
[11:02:16.359]                             name <- restart$name
[11:02:16.359]                             if (is.null(name)) 
[11:02:16.359]                               next
[11:02:16.359]                             if (!grepl(pattern, name)) 
[11:02:16.359]                               next
[11:02:16.359]                             invokeRestart(restart)
[11:02:16.359]                             muffled <- TRUE
[11:02:16.359]                             break
[11:02:16.359]                           }
[11:02:16.359]                         }
[11:02:16.359]                       }
[11:02:16.359]                       invisible(muffled)
[11:02:16.359]                     }
[11:02:16.359]                     muffleCondition(cond, pattern = "^muffle")
[11:02:16.359]                   }
[11:02:16.359]                 }
[11:02:16.359]             }
[11:02:16.359]         }))
[11:02:16.359]     }, error = function(ex) {
[11:02:16.359]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:16.359]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:16.359]                 ...future.rng), started = ...future.startTime, 
[11:02:16.359]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:16.359]             version = "1.8"), class = "FutureResult")
[11:02:16.359]     }, finally = {
[11:02:16.359]         if (!identical(...future.workdir, getwd())) 
[11:02:16.359]             setwd(...future.workdir)
[11:02:16.359]         {
[11:02:16.359]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:16.359]                 ...future.oldOptions$nwarnings <- NULL
[11:02:16.359]             }
[11:02:16.359]             base::options(...future.oldOptions)
[11:02:16.359]             if (.Platform$OS.type == "windows") {
[11:02:16.359]                 old_names <- names(...future.oldEnvVars)
[11:02:16.359]                 envs <- base::Sys.getenv()
[11:02:16.359]                 names <- names(envs)
[11:02:16.359]                 common <- intersect(names, old_names)
[11:02:16.359]                 added <- setdiff(names, old_names)
[11:02:16.359]                 removed <- setdiff(old_names, names)
[11:02:16.359]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:16.359]                   envs[common]]
[11:02:16.359]                 NAMES <- toupper(changed)
[11:02:16.359]                 args <- list()
[11:02:16.359]                 for (kk in seq_along(NAMES)) {
[11:02:16.359]                   name <- changed[[kk]]
[11:02:16.359]                   NAME <- NAMES[[kk]]
[11:02:16.359]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.359]                     next
[11:02:16.359]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:16.359]                 }
[11:02:16.359]                 NAMES <- toupper(added)
[11:02:16.359]                 for (kk in seq_along(NAMES)) {
[11:02:16.359]                   name <- added[[kk]]
[11:02:16.359]                   NAME <- NAMES[[kk]]
[11:02:16.359]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.359]                     next
[11:02:16.359]                   args[[name]] <- ""
[11:02:16.359]                 }
[11:02:16.359]                 NAMES <- toupper(removed)
[11:02:16.359]                 for (kk in seq_along(NAMES)) {
[11:02:16.359]                   name <- removed[[kk]]
[11:02:16.359]                   NAME <- NAMES[[kk]]
[11:02:16.359]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.359]                     next
[11:02:16.359]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:16.359]                 }
[11:02:16.359]                 if (length(args) > 0) 
[11:02:16.359]                   base::do.call(base::Sys.setenv, args = args)
[11:02:16.359]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:16.359]             }
[11:02:16.359]             else {
[11:02:16.359]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:16.359]             }
[11:02:16.359]             {
[11:02:16.359]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:16.359]                   0L) {
[11:02:16.359]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:16.359]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:16.359]                   base::options(opts)
[11:02:16.359]                 }
[11:02:16.359]                 {
[11:02:16.359]                   {
[11:02:16.359]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:16.359]                     NULL
[11:02:16.359]                   }
[11:02:16.359]                   options(future.plan = NULL)
[11:02:16.359]                   if (is.na(NA_character_)) 
[11:02:16.359]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:16.359]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:16.359]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:16.359]                     .init = FALSE)
[11:02:16.359]                 }
[11:02:16.359]             }
[11:02:16.359]         }
[11:02:16.359]     })
[11:02:16.359]     if (TRUE) {
[11:02:16.359]         base::sink(type = "output", split = FALSE)
[11:02:16.359]         if (TRUE) {
[11:02:16.359]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:16.359]         }
[11:02:16.359]         else {
[11:02:16.359]             ...future.result["stdout"] <- base::list(NULL)
[11:02:16.359]         }
[11:02:16.359]         base::close(...future.stdout)
[11:02:16.359]         ...future.stdout <- NULL
[11:02:16.359]     }
[11:02:16.359]     ...future.result$conditions <- ...future.conditions
[11:02:16.359]     ...future.result$finished <- base::Sys.time()
[11:02:16.359]     ...future.result
[11:02:16.359] }
[11:02:16.417]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.361] Exporting 1 global objects (643 bytes) to cluster node #1 ...
[11:02:16.417]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.361] Exporting ‘data’ (356 bytes) to cluster node #1 ...
[11:02:16.417]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.362] Exporting ‘data’ (356 bytes) to cluster node #1 ... DONE
[11:02:16.418]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.362] Exporting 1 global objects (643 bytes) to cluster node #1 ... DONE
[11:02:16.418]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.362] MultisessionFuture started
[11:02:16.418]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.362] - Launch lazy future ... done
[11:02:16.418]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.362] run() for ‘MultisessionFuture’ ... done
[11:02:16.418]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.363] result() for ClusterFuture ...
[11:02:16.418]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.363] receiveMessageFromWorker() for ClusterFuture ...
[11:02:16.418]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.363] - Validating connection of MultisessionFuture
[11:02:16.418]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.408] - received message: FutureResult
[11:02:16.419]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.408] - Received FutureResult
[11:02:16.419]  - Condition #55: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.408] - Erased future from FutureRegistry
[11:02:16.419]  - Condition #56: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.408] result() for ClusterFuture ...
[11:02:16.419]  - Condition #57: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.408] - result already collected: FutureResult
[11:02:16.419]  - Condition #58: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.408] result() for ClusterFuture ... done
[11:02:16.419]  - Condition #59: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.409] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:16.419]  - Condition #60: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.409] result() for ClusterFuture ... done
[11:02:16.419]  - Condition #61: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.409] result() for ClusterFuture ...
[11:02:16.419]  - Condition #62: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.409] - result already collected: FutureResult
[11:02:16.420]  - Condition #63: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.409] result() for ClusterFuture ... done
[11:02:16.420] signalConditions() ... done
- plan(list('sequential', 'multisession')) ... DONE
- plan(list('multicore', 'sequential')) ...
[11:02:16.420] plan(): Setting new future strategy stack:
[11:02:16.420] List of future strategies:
[11:02:16.420] 1. multicore:
[11:02:16.420]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:16.420]    - tweaked: FALSE
[11:02:16.420]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:16.420] 2. sequential:
[11:02:16.420]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:16.420]    - tweaked: FALSE
[11:02:16.420]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:16.422] plan(): nbrOfWorkers() = 2
[11:02:16.422] getGlobalsAndPackages() ...
[11:02:16.422] Searching for globals...
[11:02:16.438] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[11:02:16.438] Searching for globals ... DONE
[11:02:16.438] Resolving globals: FALSE
[11:02:16.439] The total size of the 2 globals is 7.79 KiB (7973 bytes)
[11:02:16.439] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 7.79 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (7.74 KiB of class ‘list’) and ‘strategy2’ (49 bytes of class ‘character’)
[11:02:16.439] - globals: [2] ‘nested’, ‘strategy2’
[11:02:16.439] - packages: [1] ‘future’
[11:02:16.439] getGlobalsAndPackages() ... DONE
[11:02:16.440] run() for ‘Future’ ...
[11:02:16.440] - state: ‘created’
[11:02:16.440] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:02:16.441] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:16.442] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:02:16.442]   - Field: ‘label’
[11:02:16.442]   - Field: ‘local’
[11:02:16.442]   - Field: ‘owner’
[11:02:16.442]   - Field: ‘envir’
[11:02:16.442]   - Field: ‘workers’
[11:02:16.442]   - Field: ‘packages’
[11:02:16.442]   - Field: ‘gc’
[11:02:16.442]   - Field: ‘job’
[11:02:16.442]   - Field: ‘conditions’
[11:02:16.442]   - Field: ‘expr’
[11:02:16.443]   - Field: ‘uuid’
[11:02:16.443]   - Field: ‘seed’
[11:02:16.443]   - Field: ‘version’
[11:02:16.443]   - Field: ‘result’
[11:02:16.443]   - Field: ‘asynchronous’
[11:02:16.443]   - Field: ‘calls’
[11:02:16.443]   - Field: ‘globals’
[11:02:16.443]   - Field: ‘stdout’
[11:02:16.443]   - Field: ‘earlySignal’
[11:02:16.443]   - Field: ‘lazy’
[11:02:16.443]   - Field: ‘state’
[11:02:16.443] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:02:16.444] - Launch lazy future ...
[11:02:16.444] Packages needed by the future expression (n = 1): ‘future’
[11:02:16.444] Packages needed by future strategies (n = 1): ‘future’
[11:02:16.444] {
[11:02:16.444]     {
[11:02:16.444]         {
[11:02:16.444]             ...future.startTime <- base::Sys.time()
[11:02:16.444]             {
[11:02:16.444]                 {
[11:02:16.444]                   {
[11:02:16.444]                     {
[11:02:16.444]                       {
[11:02:16.444]                         base::local({
[11:02:16.444]                           has_future <- base::requireNamespace("future", 
[11:02:16.444]                             quietly = TRUE)
[11:02:16.444]                           if (has_future) {
[11:02:16.444]                             ns <- base::getNamespace("future")
[11:02:16.444]                             version <- ns[[".package"]][["version"]]
[11:02:16.444]                             if (is.null(version)) 
[11:02:16.444]                               version <- utils::packageVersion("future")
[11:02:16.444]                           }
[11:02:16.444]                           else {
[11:02:16.444]                             version <- NULL
[11:02:16.444]                           }
[11:02:16.444]                           if (!has_future || version < "1.8.0") {
[11:02:16.444]                             info <- base::c(r_version = base::gsub("R version ", 
[11:02:16.444]                               "", base::R.version$version.string), 
[11:02:16.444]                               platform = base::sprintf("%s (%s-bit)", 
[11:02:16.444]                                 base::R.version$platform, 8 * 
[11:02:16.444]                                   base::.Machine$sizeof.pointer), 
[11:02:16.444]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:16.444]                                 "release", "version")], collapse = " "), 
[11:02:16.444]                               hostname = base::Sys.info()[["nodename"]])
[11:02:16.444]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:02:16.444]                               info)
[11:02:16.444]                             info <- base::paste(info, collapse = "; ")
[11:02:16.444]                             if (!has_future) {
[11:02:16.444]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:16.444]                                 info)
[11:02:16.444]                             }
[11:02:16.444]                             else {
[11:02:16.444]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:16.444]                                 info, version)
[11:02:16.444]                             }
[11:02:16.444]                             base::stop(msg)
[11:02:16.444]                           }
[11:02:16.444]                         })
[11:02:16.444]                       }
[11:02:16.444]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:16.444]                       base::options(mc.cores = 1L)
[11:02:16.444]                     }
[11:02:16.444]                     base::local({
[11:02:16.444]                       for (pkg in "future") {
[11:02:16.444]                         base::loadNamespace(pkg)
[11:02:16.444]                         base::library(pkg, character.only = TRUE)
[11:02:16.444]                       }
[11:02:16.444]                     })
[11:02:16.444]                   }
[11:02:16.444]                   ...future.strategy.old <- future::plan("list")
[11:02:16.444]                   options(future.plan = NULL)
[11:02:16.444]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:16.444]                   future::plan(list(b = function (..., envir = parent.frame()) 
[11:02:16.444]                   {
[11:02:16.444]                     future <- SequentialFuture(..., envir = envir)
[11:02:16.444]                     if (!future$lazy) 
[11:02:16.444]                       future <- run(future)
[11:02:16.444]                     invisible(future)
[11:02:16.444]                   }), .cleanup = FALSE, .init = FALSE)
[11:02:16.444]                 }
[11:02:16.444]                 ...future.workdir <- getwd()
[11:02:16.444]             }
[11:02:16.444]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:16.444]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:16.444]         }
[11:02:16.444]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:16.444]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:16.444]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:16.444]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:16.444]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:16.444]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:16.444]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:16.444]             base::names(...future.oldOptions))
[11:02:16.444]     }
[11:02:16.444]     if (FALSE) {
[11:02:16.444]     }
[11:02:16.444]     else {
[11:02:16.444]         if (TRUE) {
[11:02:16.444]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:16.444]                 open = "w")
[11:02:16.444]         }
[11:02:16.444]         else {
[11:02:16.444]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:16.444]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:16.444]         }
[11:02:16.444]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:16.444]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:16.444]             base::sink(type = "output", split = FALSE)
[11:02:16.444]             base::close(...future.stdout)
[11:02:16.444]         }, add = TRUE)
[11:02:16.444]     }
[11:02:16.444]     ...future.frame <- base::sys.nframe()
[11:02:16.444]     ...future.conditions <- base::list()
[11:02:16.444]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:16.444]     if (FALSE) {
[11:02:16.444]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:16.444]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:16.444]     }
[11:02:16.444]     ...future.result <- base::tryCatch({
[11:02:16.444]         base::withCallingHandlers({
[11:02:16.444]             ...future.value <- base::withVisible(base::local({
[11:02:16.444]                 withCallingHandlers({
[11:02:16.444]                   {
[11:02:16.444]                     a <- 1L
[11:02:16.444]                     plan_a <- unclass(future::plan("list"))
[11:02:16.444]                     nested_a <- nested[-1]
[11:02:16.444]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[11:02:16.444]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[11:02:16.444]                       strategy2))
[11:02:16.444]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[11:02:16.444]                       "init") <- NULL
[11:02:16.444]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[11:02:16.444]                       "init") <- NULL
[11:02:16.444]                     stopifnot(all.equal(plan_a, nested_a))
[11:02:16.444]                     y %<-% {
[11:02:16.444]                       b <- 2L
[11:02:16.444]                       plan_b <- future::plan("list")
[11:02:16.444]                       nested_b <- nested_a[-1]
[11:02:16.444]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[11:02:16.444]                         1L, inherits(plan_b[[1]], "future"), 
[11:02:16.444]                         inherits(future::plan("next"), "sequential"))
[11:02:16.444]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[11:02:16.444]                         b = b, nested_b = nested_b, plan_b = plan_b)
[11:02:16.444]                     }
[11:02:16.444]                     y
[11:02:16.444]                   }
[11:02:16.444]                 }, immediateCondition = function(cond) {
[11:02:16.444]                   save_rds <- function (object, pathname, ...) 
[11:02:16.444]                   {
[11:02:16.444]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:02:16.444]                     if (file_test("-f", pathname_tmp)) {
[11:02:16.444]                       fi_tmp <- file.info(pathname_tmp)
[11:02:16.444]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:02:16.444]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:16.444]                         fi_tmp[["mtime"]])
[11:02:16.444]                     }
[11:02:16.444]                     tryCatch({
[11:02:16.444]                       saveRDS(object, file = pathname_tmp, ...)
[11:02:16.444]                     }, error = function(ex) {
[11:02:16.444]                       msg <- conditionMessage(ex)
[11:02:16.444]                       fi_tmp <- file.info(pathname_tmp)
[11:02:16.444]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:02:16.444]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:16.444]                         fi_tmp[["mtime"]], msg)
[11:02:16.444]                       ex$message <- msg
[11:02:16.444]                       stop(ex)
[11:02:16.444]                     })
[11:02:16.444]                     stopifnot(file_test("-f", pathname_tmp))
[11:02:16.444]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:02:16.444]                     if (!res || file_test("-f", pathname_tmp)) {
[11:02:16.444]                       fi_tmp <- file.info(pathname_tmp)
[11:02:16.444]                       fi <- file.info(pathname)
[11:02:16.444]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:02:16.444]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:16.444]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:02:16.444]                         fi[["size"]], fi[["mtime"]])
[11:02:16.444]                       stop(msg)
[11:02:16.444]                     }
[11:02:16.444]                     invisible(pathname)
[11:02:16.444]                   }
[11:02:16.444]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:02:16.444]                     rootPath = tempdir()) 
[11:02:16.444]                   {
[11:02:16.444]                     obj <- list(time = Sys.time(), condition = cond)
[11:02:16.444]                     file <- tempfile(pattern = class(cond)[1], 
[11:02:16.444]                       tmpdir = path, fileext = ".rds")
[11:02:16.444]                     save_rds(obj, file)
[11:02:16.444]                   }
[11:02:16.444]                   saveImmediateCondition(cond, path = "/tmp/RtmpVZPEla/.future/immediateConditions")
[11:02:16.444]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.444]                   {
[11:02:16.444]                     inherits <- base::inherits
[11:02:16.444]                     invokeRestart <- base::invokeRestart
[11:02:16.444]                     is.null <- base::is.null
[11:02:16.444]                     muffled <- FALSE
[11:02:16.444]                     if (inherits(cond, "message")) {
[11:02:16.444]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:16.444]                       if (muffled) 
[11:02:16.444]                         invokeRestart("muffleMessage")
[11:02:16.444]                     }
[11:02:16.444]                     else if (inherits(cond, "warning")) {
[11:02:16.444]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:16.444]                       if (muffled) 
[11:02:16.444]                         invokeRestart("muffleWarning")
[11:02:16.444]                     }
[11:02:16.444]                     else if (inherits(cond, "condition")) {
[11:02:16.444]                       if (!is.null(pattern)) {
[11:02:16.444]                         computeRestarts <- base::computeRestarts
[11:02:16.444]                         grepl <- base::grepl
[11:02:16.444]                         restarts <- computeRestarts(cond)
[11:02:16.444]                         for (restart in restarts) {
[11:02:16.444]                           name <- restart$name
[11:02:16.444]                           if (is.null(name)) 
[11:02:16.444]                             next
[11:02:16.444]                           if (!grepl(pattern, name)) 
[11:02:16.444]                             next
[11:02:16.444]                           invokeRestart(restart)
[11:02:16.444]                           muffled <- TRUE
[11:02:16.444]                           break
[11:02:16.444]                         }
[11:02:16.444]                       }
[11:02:16.444]                     }
[11:02:16.444]                     invisible(muffled)
[11:02:16.444]                   }
[11:02:16.444]                   muffleCondition(cond)
[11:02:16.444]                 })
[11:02:16.444]             }))
[11:02:16.444]             future::FutureResult(value = ...future.value$value, 
[11:02:16.444]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:16.444]                   ...future.rng), globalenv = if (FALSE) 
[11:02:16.444]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:16.444]                     ...future.globalenv.names))
[11:02:16.444]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:16.444]         }, condition = base::local({
[11:02:16.444]             c <- base::c
[11:02:16.444]             inherits <- base::inherits
[11:02:16.444]             invokeRestart <- base::invokeRestart
[11:02:16.444]             length <- base::length
[11:02:16.444]             list <- base::list
[11:02:16.444]             seq.int <- base::seq.int
[11:02:16.444]             signalCondition <- base::signalCondition
[11:02:16.444]             sys.calls <- base::sys.calls
[11:02:16.444]             `[[` <- base::`[[`
[11:02:16.444]             `+` <- base::`+`
[11:02:16.444]             `<<-` <- base::`<<-`
[11:02:16.444]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:16.444]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:16.444]                   3L)]
[11:02:16.444]             }
[11:02:16.444]             function(cond) {
[11:02:16.444]                 is_error <- inherits(cond, "error")
[11:02:16.444]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:16.444]                   NULL)
[11:02:16.444]                 if (is_error) {
[11:02:16.444]                   sessionInformation <- function() {
[11:02:16.444]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:16.444]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:16.444]                       search = base::search(), system = base::Sys.info())
[11:02:16.444]                   }
[11:02:16.444]                   ...future.conditions[[length(...future.conditions) + 
[11:02:16.444]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:16.444]                     cond$call), session = sessionInformation(), 
[11:02:16.444]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:16.444]                   signalCondition(cond)
[11:02:16.444]                 }
[11:02:16.444]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:16.444]                 "immediateCondition"))) {
[11:02:16.444]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:16.444]                   ...future.conditions[[length(...future.conditions) + 
[11:02:16.444]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:16.444]                   if (TRUE && !signal) {
[11:02:16.444]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.444]                     {
[11:02:16.444]                       inherits <- base::inherits
[11:02:16.444]                       invokeRestart <- base::invokeRestart
[11:02:16.444]                       is.null <- base::is.null
[11:02:16.444]                       muffled <- FALSE
[11:02:16.444]                       if (inherits(cond, "message")) {
[11:02:16.444]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:16.444]                         if (muffled) 
[11:02:16.444]                           invokeRestart("muffleMessage")
[11:02:16.444]                       }
[11:02:16.444]                       else if (inherits(cond, "warning")) {
[11:02:16.444]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:16.444]                         if (muffled) 
[11:02:16.444]                           invokeRestart("muffleWarning")
[11:02:16.444]                       }
[11:02:16.444]                       else if (inherits(cond, "condition")) {
[11:02:16.444]                         if (!is.null(pattern)) {
[11:02:16.444]                           computeRestarts <- base::computeRestarts
[11:02:16.444]                           grepl <- base::grepl
[11:02:16.444]                           restarts <- computeRestarts(cond)
[11:02:16.444]                           for (restart in restarts) {
[11:02:16.444]                             name <- restart$name
[11:02:16.444]                             if (is.null(name)) 
[11:02:16.444]                               next
[11:02:16.444]                             if (!grepl(pattern, name)) 
[11:02:16.444]                               next
[11:02:16.444]                             invokeRestart(restart)
[11:02:16.444]                             muffled <- TRUE
[11:02:16.444]                             break
[11:02:16.444]                           }
[11:02:16.444]                         }
[11:02:16.444]                       }
[11:02:16.444]                       invisible(muffled)
[11:02:16.444]                     }
[11:02:16.444]                     muffleCondition(cond, pattern = "^muffle")
[11:02:16.444]                   }
[11:02:16.444]                 }
[11:02:16.444]                 else {
[11:02:16.444]                   if (TRUE) {
[11:02:16.444]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.444]                     {
[11:02:16.444]                       inherits <- base::inherits
[11:02:16.444]                       invokeRestart <- base::invokeRestart
[11:02:16.444]                       is.null <- base::is.null
[11:02:16.444]                       muffled <- FALSE
[11:02:16.444]                       if (inherits(cond, "message")) {
[11:02:16.444]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:16.444]                         if (muffled) 
[11:02:16.444]                           invokeRestart("muffleMessage")
[11:02:16.444]                       }
[11:02:16.444]                       else if (inherits(cond, "warning")) {
[11:02:16.444]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:16.444]                         if (muffled) 
[11:02:16.444]                           invokeRestart("muffleWarning")
[11:02:16.444]                       }
[11:02:16.444]                       else if (inherits(cond, "condition")) {
[11:02:16.444]                         if (!is.null(pattern)) {
[11:02:16.444]                           computeRestarts <- base::computeRestarts
[11:02:16.444]                           grepl <- base::grepl
[11:02:16.444]                           restarts <- computeRestarts(cond)
[11:02:16.444]                           for (restart in restarts) {
[11:02:16.444]                             name <- restart$name
[11:02:16.444]                             if (is.null(name)) 
[11:02:16.444]                               next
[11:02:16.444]                             if (!grepl(pattern, name)) 
[11:02:16.444]                               next
[11:02:16.444]                             invokeRestart(restart)
[11:02:16.444]                             muffled <- TRUE
[11:02:16.444]                             break
[11:02:16.444]                           }
[11:02:16.444]                         }
[11:02:16.444]                       }
[11:02:16.444]                       invisible(muffled)
[11:02:16.444]                     }
[11:02:16.444]                     muffleCondition(cond, pattern = "^muffle")
[11:02:16.444]                   }
[11:02:16.444]                 }
[11:02:16.444]             }
[11:02:16.444]         }))
[11:02:16.444]     }, error = function(ex) {
[11:02:16.444]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:16.444]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:16.444]                 ...future.rng), started = ...future.startTime, 
[11:02:16.444]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:16.444]             version = "1.8"), class = "FutureResult")
[11:02:16.444]     }, finally = {
[11:02:16.444]         if (!identical(...future.workdir, getwd())) 
[11:02:16.444]             setwd(...future.workdir)
[11:02:16.444]         {
[11:02:16.444]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:16.444]                 ...future.oldOptions$nwarnings <- NULL
[11:02:16.444]             }
[11:02:16.444]             base::options(...future.oldOptions)
[11:02:16.444]             if (.Platform$OS.type == "windows") {
[11:02:16.444]                 old_names <- names(...future.oldEnvVars)
[11:02:16.444]                 envs <- base::Sys.getenv()
[11:02:16.444]                 names <- names(envs)
[11:02:16.444]                 common <- intersect(names, old_names)
[11:02:16.444]                 added <- setdiff(names, old_names)
[11:02:16.444]                 removed <- setdiff(old_names, names)
[11:02:16.444]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:16.444]                   envs[common]]
[11:02:16.444]                 NAMES <- toupper(changed)
[11:02:16.444]                 args <- list()
[11:02:16.444]                 for (kk in seq_along(NAMES)) {
[11:02:16.444]                   name <- changed[[kk]]
[11:02:16.444]                   NAME <- NAMES[[kk]]
[11:02:16.444]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.444]                     next
[11:02:16.444]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:16.444]                 }
[11:02:16.444]                 NAMES <- toupper(added)
[11:02:16.444]                 for (kk in seq_along(NAMES)) {
[11:02:16.444]                   name <- added[[kk]]
[11:02:16.444]                   NAME <- NAMES[[kk]]
[11:02:16.444]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.444]                     next
[11:02:16.444]                   args[[name]] <- ""
[11:02:16.444]                 }
[11:02:16.444]                 NAMES <- toupper(removed)
[11:02:16.444]                 for (kk in seq_along(NAMES)) {
[11:02:16.444]                   name <- removed[[kk]]
[11:02:16.444]                   NAME <- NAMES[[kk]]
[11:02:16.444]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.444]                     next
[11:02:16.444]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:16.444]                 }
[11:02:16.444]                 if (length(args) > 0) 
[11:02:16.444]                   base::do.call(base::Sys.setenv, args = args)
[11:02:16.444]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:16.444]             }
[11:02:16.444]             else {
[11:02:16.444]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:16.444]             }
[11:02:16.444]             {
[11:02:16.444]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:16.444]                   0L) {
[11:02:16.444]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:16.444]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:16.444]                   base::options(opts)
[11:02:16.444]                 }
[11:02:16.444]                 {
[11:02:16.444]                   {
[11:02:16.444]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:16.444]                     NULL
[11:02:16.444]                   }
[11:02:16.444]                   options(future.plan = NULL)
[11:02:16.444]                   if (is.na(NA_character_)) 
[11:02:16.444]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:16.444]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:16.444]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:16.444]                     .init = FALSE)
[11:02:16.444]                 }
[11:02:16.444]             }
[11:02:16.444]         }
[11:02:16.444]     })
[11:02:16.444]     if (TRUE) {
[11:02:16.444]         base::sink(type = "output", split = FALSE)
[11:02:16.444]         if (TRUE) {
[11:02:16.444]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:16.444]         }
[11:02:16.444]         else {
[11:02:16.444]             ...future.result["stdout"] <- base::list(NULL)
[11:02:16.444]         }
[11:02:16.444]         base::close(...future.stdout)
[11:02:16.444]         ...future.stdout <- NULL
[11:02:16.444]     }
[11:02:16.444]     ...future.result$conditions <- ...future.conditions
[11:02:16.444]     ...future.result$finished <- base::Sys.time()
[11:02:16.444]     ...future.result
[11:02:16.444] }
[11:02:16.447] assign_globals() ...
[11:02:16.447] List of 2
[11:02:16.447]  $ nested   :List of 2
[11:02:16.447]   ..$ a:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[11:02:16.447]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[11:02:16.447]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[11:02:16.447]   ..$ b:function (..., envir = parent.frame())  
[11:02:16.447]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[11:02:16.447]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[11:02:16.447]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[11:02:16.447]  $ strategy2: chr "sequential"
[11:02:16.447]  - attr(*, "where")=List of 2
[11:02:16.447]   ..$ nested   :<environment: R_EmptyEnv> 
[11:02:16.447]   ..$ strategy2:<environment: R_EmptyEnv> 
[11:02:16.447]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:02:16.447]  - attr(*, "resolved")= logi FALSE
[11:02:16.447]  - attr(*, "total_size")= num 7973
[11:02:16.447]  - attr(*, "already-done")= logi TRUE
[11:02:16.451] - copied ‘nested’ to environment
[11:02:16.452] - copied ‘strategy2’ to environment
[11:02:16.452] assign_globals() ... done
[11:02:16.452] requestCore(): workers = 2
[11:02:16.455] MulticoreFuture started
[11:02:16.455] - Launch lazy future ... done
[11:02:16.455] run() for ‘MulticoreFuture’ ... done
[11:02:16.455] result() for MulticoreFuture ...
[11:02:16.456] plan(): Setting new future strategy stack:
[11:02:16.456] List of future strategies:
[11:02:16.456] 1. sequential:
[11:02:16.456]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:16.456]    - tweaked: FALSE
[11:02:16.456]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:16.457] plan(): nbrOfWorkers() = 1
[11:02:16.498] plan(): Setting new future strategy stack:
[11:02:16.499] List of future strategies:
[11:02:16.499] 1. multicore:
[11:02:16.499]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:16.499]    - tweaked: FALSE
[11:02:16.499]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:16.499] 2. sequential:
[11:02:16.499]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:16.499]    - tweaked: FALSE
[11:02:16.499]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:16.501] plan(): nbrOfWorkers() = 2
[11:02:16.503] result() for MulticoreFuture ...
[11:02:16.503] result() for MulticoreFuture ... done
[11:02:16.503] signalConditions() ...
[11:02:16.503]  - include = ‘immediateCondition’
[11:02:16.503]  - exclude = 
[11:02:16.503]  - resignal = FALSE
[11:02:16.503]  - Number of conditions: 54
[11:02:16.503] signalConditions() ... done
[11:02:16.504] result() for MulticoreFuture ... done
[11:02:16.504] result() for MulticoreFuture ...
[11:02:16.504] result() for MulticoreFuture ... done
[11:02:16.504] signalConditions() ...
[11:02:16.504]  - include = ‘immediateCondition’
[11:02:16.504]  - exclude = 
[11:02:16.504]  - resignal = FALSE
[11:02:16.504]  - Number of conditions: 54
[11:02:16.504] signalConditions() ... done
[11:02:16.505] Future state: ‘finished’
[11:02:16.505] result() for MulticoreFuture ...
[11:02:16.505] result() for MulticoreFuture ... done
[11:02:16.505] signalConditions() ...
[11:02:16.505]  - include = ‘condition’
[11:02:16.505]  - exclude = ‘immediateCondition’
[11:02:16.505]  - resignal = TRUE
[11:02:16.505]  - Number of conditions: 54
[11:02:16.505]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.459] getGlobalsAndPackages() ...
[11:02:16.506]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.459] Searching for globals...
[11:02:16.506]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.466] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[11:02:16.506]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.466] Searching for globals ... DONE
[11:02:16.506]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.467] Resolving globals: FALSE
[11:02:16.506]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.468] The total size of the 3 globals is 3.58 KiB (3661 bytes)
[11:02:16.506]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.469] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 3.58 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (1.77 KiB of class ‘list’), ‘plan_a’ (1.77 KiB of class ‘list’) and ‘a’ (35 bytes of class ‘numeric’)
[11:02:16.506]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.469] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[11:02:16.507]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.469] 
[11:02:16.507]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.469] getGlobalsAndPackages() ... DONE
[11:02:16.507]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.470] run() for ‘Future’ ...
[11:02:16.507]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.470] - state: ‘created’
[11:02:16.507]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.470] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:02:16.507]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.471] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:16.507]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.471] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:16.508]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.471]   - Field: ‘label’
[11:02:16.508]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.471]   - Field: ‘local’
[11:02:16.508]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.471]   - Field: ‘owner’
[11:02:16.508]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.471]   - Field: ‘envir’
[11:02:16.508]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.472]   - Field: ‘packages’
[11:02:16.508]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.472]   - Field: ‘gc’
[11:02:16.508]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.472]   - Field: ‘conditions’
[11:02:16.509]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.472]   - Field: ‘expr’
[11:02:16.509]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.472]   - Field: ‘uuid’
[11:02:16.509]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.472]   - Field: ‘seed’
[11:02:16.509]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.472]   - Field: ‘version’
[11:02:16.509]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.473]   - Field: ‘result’
[11:02:16.509]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.473]   - Field: ‘asynchronous’
[11:02:16.509]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.473]   - Field: ‘calls’
[11:02:16.510]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.473]   - Field: ‘globals’
[11:02:16.510]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.473]   - Field: ‘stdout’
[11:02:16.510]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.473]   - Field: ‘earlySignal’
[11:02:16.510]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.474]   - Field: ‘lazy’
[11:02:16.510]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.474]   - Field: ‘state’
[11:02:16.510]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.474] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:16.510]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.474] - Launch lazy future ...
[11:02:16.511]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.474] Packages needed by the future expression (n = 0): <none>
[11:02:16.511]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.475] Packages needed by future strategies (n = 0): <none>
[11:02:16.511]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.475] {
[11:02:16.475]     {
[11:02:16.475]         {
[11:02:16.475]             ...future.startTime <- base::Sys.time()
[11:02:16.475]             {
[11:02:16.475]                 {
[11:02:16.475]                   {
[11:02:16.475]                     base::local({
[11:02:16.475]                       has_future <- base::requireNamespace("future", 
[11:02:16.475]                         quietly = TRUE)
[11:02:16.475]                       if (has_future) {
[11:02:16.475]                         ns <- base::getNamespace("future")
[11:02:16.475]                         version <- ns[[".package"]][["version"]]
[11:02:16.475]                         if (is.null(version)) 
[11:02:16.475]                           version <- utils::packageVersion("future")
[11:02:16.475]                       }
[11:02:16.475]                       else {
[11:02:16.475]                         version <- NULL
[11:02:16.475]                       }
[11:02:16.475]                       if (!has_future || version < "1.8.0") {
[11:02:16.475]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:16.475]                           "", base::R.version$version.string), 
[11:02:16.475]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:16.475]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:16.475]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:16.475]                             "release", "version")], collapse = " "), 
[11:02:16.475]                           hostname = base::Sys.info()[["nodename"]])
[11:02:16.475]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:16.475]                           info)
[11:02:16.475]                         info <- base::paste(info, collapse = "; ")
[11:02:16.475]                         if (!has_future) {
[11:02:16.475]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:16.475]                             info)
[11:02:16.475]                         }
[11:02:16.475]                         else {
[11:02:16.475]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:16.475]                             info, version)
[11:02:16.475]                         }
[11:02:16.475]                         base::stop(msg)
[11:02:16.475]                       }
[11:02:16.475]                     })
[11:02:16.475]                   }
[11:02:16.475]                   ...future.strategy.old <- future::plan("list")
[11:02:16.475]                   options(future.plan = NULL)
[11:02:16.475]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:16.475]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:16.475]                 }
[11:02:16.475]                 ...future.workdir <- getwd()
[11:02:16.475]             }
[11:02:16.475]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:16.475]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:16.475]         }
[11:02:16.475]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:16.475]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:16.475]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:16.475]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:16.475]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:16.475]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:16.475]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:16.475]             base::names(...future.oldOptions))
[11:02:16.475]     }
[11:02:16.475]     if (FALSE) {
[11:02:16.475]     }
[11:02:16.475]     else {
[11:02:16.475]         if (TRUE) {
[11:02:16.475]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:16.475]                 open = "w")
[11:02:16.475]         }
[11:02:16.475]         else {
[11:02:16.475]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:16.475]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:16.475]         }
[11:02:16.475]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:16.475]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:16.475]             base::sink(type = "output", split = FALSE)
[11:02:16.475]             base::close(...future.stdout)
[11:02:16.475]         }, add = TRUE)
[11:02:16.475]     }
[11:02:16.475]     ...future.frame <- base::sys.nframe()
[11:02:16.475]     ...future.conditions <- base::list()
[11:02:16.475]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:16.475]     if (FALSE) {
[11:02:16.475]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:16.475]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:16.475]     }
[11:02:16.475]     ...future.result <- base::tryCatch({
[11:02:16.475]         base::withCallingHandlers({
[11:02:16.475]             ...future.value <- base::withVisible(base::local({
[11:02:16.475]                 b <- 2L
[11:02:16.475]                 plan_b <- future::plan("list")
[11:02:16.475]                 nested_b <- nested_a[-1]
[11:02:16.475]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[11:02:16.475]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[11:02:16.475]                   "sequential"))
[11:02:16.475]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[11:02:16.475]                   b = b, nested_b = nested_b, plan_b = plan_b)
[11:02:16.475]             }))
[11:02:16.475]             future::FutureResult(value = ...future.value$value, 
[11:02:16.475]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:16.475]                   ...future.rng), globalenv = if (FALSE) 
[11:02:16.475]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:16.475]                     ...future.globalenv.names))
[11:02:16.475]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:16.475]         }, condition = base::local({
[11:02:16.475]             c <- base::c
[11:02:16.475]             inherits <- base::inherits
[11:02:16.475]             invokeRestart <- base::invokeRestart
[11:02:16.475]             length <- base::length
[11:02:16.475]             list <- base::list
[11:02:16.475]             seq.int <- base::seq.int
[11:02:16.475]             signalCondition <- base::signalCondition
[11:02:16.475]             sys.calls <- base::sys.calls
[11:02:16.475]             `[[` <- base::`[[`
[11:02:16.475]             `+` <- base::`+`
[11:02:16.475]             `<<-` <- base::`<<-`
[11:02:16.475]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:16.475]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:16.475]                   3L)]
[11:02:16.475]             }
[11:02:16.475]             function(cond) {
[11:02:16.475]                 is_error <- inherits(cond, "error")
[11:02:16.475]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:16.475]                   NULL)
[11:02:16.475]                 if (is_error) {
[11:02:16.475]                   sessionInformation <- function() {
[11:02:16.475]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:16.475]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:16.475]                       search = base::search(), system = base::Sys.info())
[11:02:16.475]                   }
[11:02:16.475]                   ...future.conditions[[length(...future.conditions) + 
[11:02:16.475]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:16.475]                     cond$call), session = sessionInformation(), 
[11:02:16.475]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:16.475]                   signalCondition(cond)
[11:02:16.475]                 }
[11:02:16.475]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:16.475]                 "immediateCondition"))) {
[11:02:16.475]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:16.475]                   ...future.conditions[[length(...future.conditions) + 
[11:02:16.475]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:16.475]                   if (TRUE && !signal) {
[11:02:16.475]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.475]                     {
[11:02:16.475]                       inherits <- base::inherits
[11:02:16.475]                       invokeRestart <- base::invokeRestart
[11:02:16.475]                       is.null <- base::is.null
[11:02:16.475]                       muffled <- FALSE
[11:02:16.475]                       if (inherits(cond, "message")) {
[11:02:16.475]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:16.475]                         if (muffled) 
[11:02:16.475]                           invokeRestart("muffleMessage")
[11:02:16.475]                       }
[11:02:16.475]                       else if (inherits(cond, "warning")) {
[11:02:16.475]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:16.475]                         if (muffled) 
[11:02:16.475]                           invokeRestart("muffleWarning")
[11:02:16.475]                       }
[11:02:16.475]                       else if (inherits(cond, "condition")) {
[11:02:16.475]                         if (!is.null(pattern)) {
[11:02:16.475]                           computeRestarts <- base::computeRestarts
[11:02:16.475]                           grepl <- base::grepl
[11:02:16.475]                           restarts <- computeRestarts(cond)
[11:02:16.475]                           for (restart in restarts) {
[11:02:16.475]                             name <- restart$name
[11:02:16.475]                             if (is.null(name)) 
[11:02:16.475]                               next
[11:02:16.475]                             if (!grepl(pattern, name)) 
[11:02:16.475]                               next
[11:02:16.475]                             invokeRestart(restart)
[11:02:16.475]                             muffled <- TRUE
[11:02:16.475]                             break
[11:02:16.475]                           }
[11:02:16.475]                         }
[11:02:16.475]                       }
[11:02:16.475]                       invisible(muffled)
[11:02:16.475]                     }
[11:02:16.475]                     muffleCondition(cond, pattern = "^muffle")
[11:02:16.475]                   }
[11:02:16.475]                 }
[11:02:16.475]                 else {
[11:02:16.475]                   if (TRUE) {
[11:02:16.475]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.475]                     {
[11:02:16.475]                       inherits <- base::inherits
[11:02:16.475]                       invokeRestart <- base::invokeRestart
[11:02:16.475]                       is.null <- base::is.null
[11:02:16.475]                       muffled <- FALSE
[11:02:16.475]                       if (inherits(cond, "message")) {
[11:02:16.475]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:16.475]                         if (muffled) 
[11:02:16.475]                           invokeRestart("muffleMessage")
[11:02:16.475]                       }
[11:02:16.475]                       else if (inherits(cond, "warning")) {
[11:02:16.475]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:16.475]                         if (muffled) 
[11:02:16.475]                           invokeRestart("muffleWarning")
[11:02:16.475]                       }
[11:02:16.475]                       else if (inherits(cond, "condition")) {
[11:02:16.475]                         if (!is.null(pattern)) {
[11:02:16.475]                           computeRestarts <- base::computeRestarts
[11:02:16.475]                           grepl <- base::grepl
[11:02:16.475]                           restarts <- computeRestarts(cond)
[11:02:16.475]                           for (restart in restarts) {
[11:02:16.475]                             name <- restart$name
[11:02:16.475]                             if (is.null(name)) 
[11:02:16.475]                               next
[11:02:16.475]                             if (!grepl(pattern, name)) 
[11:02:16.475]                               next
[11:02:16.475]                             invokeRestart(restart)
[11:02:16.475]                             muffled <- TRUE
[11:02:16.475]                             break
[11:02:16.475]                           }
[11:02:16.475]                         }
[11:02:16.475]                       }
[11:02:16.475]                       invisible(muffled)
[11:02:16.475]                     }
[11:02:16.475]                     muffleCondition(cond, pattern = "^muffle")
[11:02:16.475]                   }
[11:02:16.475]                 }
[11:02:16.475]             }
[11:02:16.475]         }))
[11:02:16.475]     }, error = function(ex) {
[11:02:16.475]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:16.475]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:16.475]                 ...future.rng), started = ...future.startTime, 
[11:02:16.475]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:16.475]             version = "1.8"), class = "FutureResult")
[11:02:16.475]     }, finally = {
[11:02:16.475]         if (!identical(...future.workdir, getwd())) 
[11:02:16.475]             setwd(...future.workdir)
[11:02:16.475]         {
[11:02:16.475]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:16.475]                 ...future.oldOptions$nwarnings <- NULL
[11:02:16.475]             }
[11:02:16.475]             base::options(...future.oldOptions)
[11:02:16.475]             if (.Platform$OS.type == "windows") {
[11:02:16.475]                 old_names <- names(...future.oldEnvVars)
[11:02:16.475]                 envs <- base::Sys.getenv()
[11:02:16.475]                 names <- names(envs)
[11:02:16.475]                 common <- intersect(names, old_names)
[11:02:16.475]                 added <- setdiff(names, old_names)
[11:02:16.475]                 removed <- setdiff(old_names, names)
[11:02:16.475]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:16.475]                   envs[common]]
[11:02:16.475]                 NAMES <- toupper(changed)
[11:02:16.475]                 args <- list()
[11:02:16.475]                 for (kk in seq_along(NAMES)) {
[11:02:16.475]                   name <- changed[[kk]]
[11:02:16.475]                   NAME <- NAMES[[kk]]
[11:02:16.475]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.475]                     next
[11:02:16.475]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:16.475]                 }
[11:02:16.475]                 NAMES <- toupper(added)
[11:02:16.475]                 for (kk in seq_along(NAMES)) {
[11:02:16.475]                   name <- added[[kk]]
[11:02:16.475]                   NAME <- NAMES[[kk]]
[11:02:16.475]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.475]                     next
[11:02:16.475]                   args[[name]] <- ""
[11:02:16.475]                 }
[11:02:16.475]                 NAMES <- toupper(removed)
[11:02:16.475]                 for (kk in seq_along(NAMES)) {
[11:02:16.475]                   name <- removed[[kk]]
[11:02:16.475]                   NAME <- NAMES[[kk]]
[11:02:16.475]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.475]                     next
[11:02:16.475]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:16.475]                 }
[11:02:16.475]                 if (length(args) > 0) 
[11:02:16.475]                   base::do.call(base::Sys.setenv, args = args)
[11:02:16.475]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:16.475]             }
[11:02:16.475]             else {
[11:02:16.475]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:16.475]             }
[11:02:16.475]             {
[11:02:16.475]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:16.475]                   0L) {
[11:02:16.475]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:16.475]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:16.475]                   base::options(opts)
[11:02:16.475]                 }
[11:02:16.475]                 {
[11:02:16.475]                   {
[11:02:16.475]                     NULL
[11:02:16.475]                     RNGkind("Mersenne-Twister")
[11:02:16.475]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:16.475]                       inherits = FALSE)
[11:02:16.475]                   }
[11:02:16.475]                   options(future.plan = NULL)
[11:02:16.475]                   if (is.na(NA_character_)) 
[11:02:16.475]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:16.475]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:16.475]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:16.475]                     .init = FALSE)
[11:02:16.475]                 }
[11:02:16.475]             }
[11:02:16.475]         }
[11:02:16.475]     })
[11:02:16.475]     if (TRUE) {
[11:02:16.475]         base::sink(type = "output", split = FALSE)
[11:02:16.475]         if (TRUE) {
[11:02:16.475]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:16.475]         }
[11:02:16.475]         else {
[11:02:16.475]             ...future.result["stdout"] <- base::list(NULL)
[11:02:16.475]         }
[11:02:16.475]         base::close(...future.stdout)
[11:02:16.475]         ...future.stdout <- NULL
[11:02:16.475]     }
[11:02:16.475]     ...future.result$conditions <- ...future.conditions
[11:02:16.475]     ...future.result$finished <- base::Sys.time()
[11:02:16.475]     ...future.result
[11:02:16.475] }
[11:02:16.511]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.478] assign_globals() ...
[11:02:16.511]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.478] List of 3
[11:02:16.478]  $ nested_a:List of 1
[11:02:16.478]   ..$ b:function (..., envir = parent.frame())  
[11:02:16.478]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[11:02:16.478]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[11:02:16.478]  $ a       : int 1
[11:02:16.478]  $ plan_a  :List of 1
[11:02:16.478]   ..$ b:function (..., envir = parent.frame())  
[11:02:16.478]   .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
[11:02:16.478]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[11:02:16.478]  - attr(*, "where")=List of 3
[11:02:16.478]   ..$ nested_a:<environment: R_EmptyEnv> 
[11:02:16.478]   ..$ a       :<environment: R_EmptyEnv> 
[11:02:16.478]   ..$ plan_a  :<environment: R_EmptyEnv> 
[11:02:16.478]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:02:16.478]  - attr(*, "resolved")= logi FALSE
[11:02:16.478]  - attr(*, "total_size")= num 3661
[11:02:16.478]  - attr(*, "already-done")= logi TRUE
[11:02:16.512]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.494] - copied ‘nested_a’ to environment
[11:02:16.512]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.494] - copied ‘a’ to environment
[11:02:16.512]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.494] - copied ‘plan_a’ to environment
[11:02:16.512]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.494] assign_globals() ... done
[11:02:16.512]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.494] plan(): Setting new future strategy stack:
[11:02:16.512]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.495] List of future strategies:
[11:02:16.495] 1. sequential:
[11:02:16.495]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:16.495]    - tweaked: FALSE
[11:02:16.495]    - call: NULL
[11:02:16.512]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.495] plan(): nbrOfWorkers() = 1
[11:02:16.512]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.496] plan(): Setting new future strategy stack:
[11:02:16.513]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.496] List of future strategies:
[11:02:16.496] 1. sequential:
[11:02:16.496]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:16.496]    - tweaked: FALSE
[11:02:16.496]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:16.513]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.497] plan(): nbrOfWorkers() = 1
[11:02:16.513]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.497] SequentialFuture started (and completed)
[11:02:16.513]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.498] - Launch lazy future ... done
[11:02:16.513]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.498] run() for ‘SequentialFuture’ ... done
[11:02:16.513] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[11:02:16.522] getGlobalsAndPackages() ...
[11:02:16.522] Searching for globals...
[11:02:16.524] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[11:02:16.524] Searching for globals ... DONE
[11:02:16.524] Resolving globals: FALSE
[11:02:16.525] The total size of the 1 globals is 356 bytes (356 bytes)
[11:02:16.525] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[11:02:16.525] - globals: [1] ‘data’
[11:02:16.525] - packages: [1] ‘future’
[11:02:16.526] getGlobalsAndPackages() ... DONE
[11:02:16.526] run() for ‘Future’ ...
[11:02:16.526] - state: ‘created’
[11:02:16.526] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:02:16.528] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:16.528] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:02:16.528]   - Field: ‘label’
[11:02:16.529]   - Field: ‘local’
[11:02:16.529]   - Field: ‘owner’
[11:02:16.529]   - Field: ‘envir’
[11:02:16.529]   - Field: ‘workers’
[11:02:16.529]   - Field: ‘packages’
[11:02:16.529]   - Field: ‘gc’
[11:02:16.529]   - Field: ‘job’
[11:02:16.529]   - Field: ‘conditions’
[11:02:16.529]   - Field: ‘expr’
[11:02:16.529]   - Field: ‘uuid’
[11:02:16.529]   - Field: ‘seed’
[11:02:16.530]   - Field: ‘version’
[11:02:16.530]   - Field: ‘result’
[11:02:16.530]   - Field: ‘asynchronous’
[11:02:16.530]   - Field: ‘calls’
[11:02:16.530]   - Field: ‘globals’
[11:02:16.530]   - Field: ‘stdout’
[11:02:16.530]   - Field: ‘earlySignal’
[11:02:16.530]   - Field: ‘lazy’
[11:02:16.530]   - Field: ‘state’
[11:02:16.531] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:02:16.531] - Launch lazy future ...
[11:02:16.531] Packages needed by the future expression (n = 1): ‘future’
[11:02:16.531] Packages needed by future strategies (n = 1): ‘future’
[11:02:16.532] {
[11:02:16.532]     {
[11:02:16.532]         {
[11:02:16.532]             ...future.startTime <- base::Sys.time()
[11:02:16.532]             {
[11:02:16.532]                 {
[11:02:16.532]                   {
[11:02:16.532]                     {
[11:02:16.532]                       {
[11:02:16.532]                         base::local({
[11:02:16.532]                           has_future <- base::requireNamespace("future", 
[11:02:16.532]                             quietly = TRUE)
[11:02:16.532]                           if (has_future) {
[11:02:16.532]                             ns <- base::getNamespace("future")
[11:02:16.532]                             version <- ns[[".package"]][["version"]]
[11:02:16.532]                             if (is.null(version)) 
[11:02:16.532]                               version <- utils::packageVersion("future")
[11:02:16.532]                           }
[11:02:16.532]                           else {
[11:02:16.532]                             version <- NULL
[11:02:16.532]                           }
[11:02:16.532]                           if (!has_future || version < "1.8.0") {
[11:02:16.532]                             info <- base::c(r_version = base::gsub("R version ", 
[11:02:16.532]                               "", base::R.version$version.string), 
[11:02:16.532]                               platform = base::sprintf("%s (%s-bit)", 
[11:02:16.532]                                 base::R.version$platform, 8 * 
[11:02:16.532]                                   base::.Machine$sizeof.pointer), 
[11:02:16.532]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:16.532]                                 "release", "version")], collapse = " "), 
[11:02:16.532]                               hostname = base::Sys.info()[["nodename"]])
[11:02:16.532]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:02:16.532]                               info)
[11:02:16.532]                             info <- base::paste(info, collapse = "; ")
[11:02:16.532]                             if (!has_future) {
[11:02:16.532]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:16.532]                                 info)
[11:02:16.532]                             }
[11:02:16.532]                             else {
[11:02:16.532]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:16.532]                                 info, version)
[11:02:16.532]                             }
[11:02:16.532]                             base::stop(msg)
[11:02:16.532]                           }
[11:02:16.532]                         })
[11:02:16.532]                       }
[11:02:16.532]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:16.532]                       base::options(mc.cores = 1L)
[11:02:16.532]                     }
[11:02:16.532]                     base::local({
[11:02:16.532]                       for (pkg in "future") {
[11:02:16.532]                         base::loadNamespace(pkg)
[11:02:16.532]                         base::library(pkg, character.only = TRUE)
[11:02:16.532]                       }
[11:02:16.532]                     })
[11:02:16.532]                   }
[11:02:16.532]                   ...future.strategy.old <- future::plan("list")
[11:02:16.532]                   options(future.plan = NULL)
[11:02:16.532]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:16.532]                   future::plan(list(b = function (..., envir = parent.frame()) 
[11:02:16.532]                   {
[11:02:16.532]                     future <- SequentialFuture(..., envir = envir)
[11:02:16.532]                     if (!future$lazy) 
[11:02:16.532]                       future <- run(future)
[11:02:16.532]                     invisible(future)
[11:02:16.532]                   }), .cleanup = FALSE, .init = FALSE)
[11:02:16.532]                 }
[11:02:16.532]                 ...future.workdir <- getwd()
[11:02:16.532]             }
[11:02:16.532]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:16.532]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:16.532]         }
[11:02:16.532]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:16.532]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:16.532]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:16.532]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:16.532]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:16.532]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:16.532]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:16.532]             base::names(...future.oldOptions))
[11:02:16.532]     }
[11:02:16.532]     if (FALSE) {
[11:02:16.532]     }
[11:02:16.532]     else {
[11:02:16.532]         if (TRUE) {
[11:02:16.532]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:16.532]                 open = "w")
[11:02:16.532]         }
[11:02:16.532]         else {
[11:02:16.532]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:16.532]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:16.532]         }
[11:02:16.532]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:16.532]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:16.532]             base::sink(type = "output", split = FALSE)
[11:02:16.532]             base::close(...future.stdout)
[11:02:16.532]         }, add = TRUE)
[11:02:16.532]     }
[11:02:16.532]     ...future.frame <- base::sys.nframe()
[11:02:16.532]     ...future.conditions <- base::list()
[11:02:16.532]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:16.532]     if (FALSE) {
[11:02:16.532]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:16.532]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:16.532]     }
[11:02:16.532]     ...future.result <- base::tryCatch({
[11:02:16.532]         base::withCallingHandlers({
[11:02:16.532]             ...future.value <- base::withVisible(base::local({
[11:02:16.532]                 withCallingHandlers({
[11:02:16.532]                   {
[11:02:16.532]                     value(future(subset(data, a == 2)))
[11:02:16.532]                   }
[11:02:16.532]                 }, immediateCondition = function(cond) {
[11:02:16.532]                   save_rds <- function (object, pathname, ...) 
[11:02:16.532]                   {
[11:02:16.532]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:02:16.532]                     if (file_test("-f", pathname_tmp)) {
[11:02:16.532]                       fi_tmp <- file.info(pathname_tmp)
[11:02:16.532]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:02:16.532]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:16.532]                         fi_tmp[["mtime"]])
[11:02:16.532]                     }
[11:02:16.532]                     tryCatch({
[11:02:16.532]                       saveRDS(object, file = pathname_tmp, ...)
[11:02:16.532]                     }, error = function(ex) {
[11:02:16.532]                       msg <- conditionMessage(ex)
[11:02:16.532]                       fi_tmp <- file.info(pathname_tmp)
[11:02:16.532]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:02:16.532]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:16.532]                         fi_tmp[["mtime"]], msg)
[11:02:16.532]                       ex$message <- msg
[11:02:16.532]                       stop(ex)
[11:02:16.532]                     })
[11:02:16.532]                     stopifnot(file_test("-f", pathname_tmp))
[11:02:16.532]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:02:16.532]                     if (!res || file_test("-f", pathname_tmp)) {
[11:02:16.532]                       fi_tmp <- file.info(pathname_tmp)
[11:02:16.532]                       fi <- file.info(pathname)
[11:02:16.532]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:02:16.532]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:16.532]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:02:16.532]                         fi[["size"]], fi[["mtime"]])
[11:02:16.532]                       stop(msg)
[11:02:16.532]                     }
[11:02:16.532]                     invisible(pathname)
[11:02:16.532]                   }
[11:02:16.532]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:02:16.532]                     rootPath = tempdir()) 
[11:02:16.532]                   {
[11:02:16.532]                     obj <- list(time = Sys.time(), condition = cond)
[11:02:16.532]                     file <- tempfile(pattern = class(cond)[1], 
[11:02:16.532]                       tmpdir = path, fileext = ".rds")
[11:02:16.532]                     save_rds(obj, file)
[11:02:16.532]                   }
[11:02:16.532]                   saveImmediateCondition(cond, path = "/tmp/RtmpVZPEla/.future/immediateConditions")
[11:02:16.532]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.532]                   {
[11:02:16.532]                     inherits <- base::inherits
[11:02:16.532]                     invokeRestart <- base::invokeRestart
[11:02:16.532]                     is.null <- base::is.null
[11:02:16.532]                     muffled <- FALSE
[11:02:16.532]                     if (inherits(cond, "message")) {
[11:02:16.532]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:16.532]                       if (muffled) 
[11:02:16.532]                         invokeRestart("muffleMessage")
[11:02:16.532]                     }
[11:02:16.532]                     else if (inherits(cond, "warning")) {
[11:02:16.532]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:16.532]                       if (muffled) 
[11:02:16.532]                         invokeRestart("muffleWarning")
[11:02:16.532]                     }
[11:02:16.532]                     else if (inherits(cond, "condition")) {
[11:02:16.532]                       if (!is.null(pattern)) {
[11:02:16.532]                         computeRestarts <- base::computeRestarts
[11:02:16.532]                         grepl <- base::grepl
[11:02:16.532]                         restarts <- computeRestarts(cond)
[11:02:16.532]                         for (restart in restarts) {
[11:02:16.532]                           name <- restart$name
[11:02:16.532]                           if (is.null(name)) 
[11:02:16.532]                             next
[11:02:16.532]                           if (!grepl(pattern, name)) 
[11:02:16.532]                             next
[11:02:16.532]                           invokeRestart(restart)
[11:02:16.532]                           muffled <- TRUE
[11:02:16.532]                           break
[11:02:16.532]                         }
[11:02:16.532]                       }
[11:02:16.532]                     }
[11:02:16.532]                     invisible(muffled)
[11:02:16.532]                   }
[11:02:16.532]                   muffleCondition(cond)
[11:02:16.532]                 })
[11:02:16.532]             }))
[11:02:16.532]             future::FutureResult(value = ...future.value$value, 
[11:02:16.532]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:16.532]                   ...future.rng), globalenv = if (FALSE) 
[11:02:16.532]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:16.532]                     ...future.globalenv.names))
[11:02:16.532]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:16.532]         }, condition = base::local({
[11:02:16.532]             c <- base::c
[11:02:16.532]             inherits <- base::inherits
[11:02:16.532]             invokeRestart <- base::invokeRestart
[11:02:16.532]             length <- base::length
[11:02:16.532]             list <- base::list
[11:02:16.532]             seq.int <- base::seq.int
[11:02:16.532]             signalCondition <- base::signalCondition
[11:02:16.532]             sys.calls <- base::sys.calls
[11:02:16.532]             `[[` <- base::`[[`
[11:02:16.532]             `+` <- base::`+`
[11:02:16.532]             `<<-` <- base::`<<-`
[11:02:16.532]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:16.532]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:16.532]                   3L)]
[11:02:16.532]             }
[11:02:16.532]             function(cond) {
[11:02:16.532]                 is_error <- inherits(cond, "error")
[11:02:16.532]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:16.532]                   NULL)
[11:02:16.532]                 if (is_error) {
[11:02:16.532]                   sessionInformation <- function() {
[11:02:16.532]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:16.532]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:16.532]                       search = base::search(), system = base::Sys.info())
[11:02:16.532]                   }
[11:02:16.532]                   ...future.conditions[[length(...future.conditions) + 
[11:02:16.532]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:16.532]                     cond$call), session = sessionInformation(), 
[11:02:16.532]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:16.532]                   signalCondition(cond)
[11:02:16.532]                 }
[11:02:16.532]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:16.532]                 "immediateCondition"))) {
[11:02:16.532]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:16.532]                   ...future.conditions[[length(...future.conditions) + 
[11:02:16.532]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:16.532]                   if (TRUE && !signal) {
[11:02:16.532]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.532]                     {
[11:02:16.532]                       inherits <- base::inherits
[11:02:16.532]                       invokeRestart <- base::invokeRestart
[11:02:16.532]                       is.null <- base::is.null
[11:02:16.532]                       muffled <- FALSE
[11:02:16.532]                       if (inherits(cond, "message")) {
[11:02:16.532]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:16.532]                         if (muffled) 
[11:02:16.532]                           invokeRestart("muffleMessage")
[11:02:16.532]                       }
[11:02:16.532]                       else if (inherits(cond, "warning")) {
[11:02:16.532]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:16.532]                         if (muffled) 
[11:02:16.532]                           invokeRestart("muffleWarning")
[11:02:16.532]                       }
[11:02:16.532]                       else if (inherits(cond, "condition")) {
[11:02:16.532]                         if (!is.null(pattern)) {
[11:02:16.532]                           computeRestarts <- base::computeRestarts
[11:02:16.532]                           grepl <- base::grepl
[11:02:16.532]                           restarts <- computeRestarts(cond)
[11:02:16.532]                           for (restart in restarts) {
[11:02:16.532]                             name <- restart$name
[11:02:16.532]                             if (is.null(name)) 
[11:02:16.532]                               next
[11:02:16.532]                             if (!grepl(pattern, name)) 
[11:02:16.532]                               next
[11:02:16.532]                             invokeRestart(restart)
[11:02:16.532]                             muffled <- TRUE
[11:02:16.532]                             break
[11:02:16.532]                           }
[11:02:16.532]                         }
[11:02:16.532]                       }
[11:02:16.532]                       invisible(muffled)
[11:02:16.532]                     }
[11:02:16.532]                     muffleCondition(cond, pattern = "^muffle")
[11:02:16.532]                   }
[11:02:16.532]                 }
[11:02:16.532]                 else {
[11:02:16.532]                   if (TRUE) {
[11:02:16.532]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.532]                     {
[11:02:16.532]                       inherits <- base::inherits
[11:02:16.532]                       invokeRestart <- base::invokeRestart
[11:02:16.532]                       is.null <- base::is.null
[11:02:16.532]                       muffled <- FALSE
[11:02:16.532]                       if (inherits(cond, "message")) {
[11:02:16.532]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:16.532]                         if (muffled) 
[11:02:16.532]                           invokeRestart("muffleMessage")
[11:02:16.532]                       }
[11:02:16.532]                       else if (inherits(cond, "warning")) {
[11:02:16.532]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:16.532]                         if (muffled) 
[11:02:16.532]                           invokeRestart("muffleWarning")
[11:02:16.532]                       }
[11:02:16.532]                       else if (inherits(cond, "condition")) {
[11:02:16.532]                         if (!is.null(pattern)) {
[11:02:16.532]                           computeRestarts <- base::computeRestarts
[11:02:16.532]                           grepl <- base::grepl
[11:02:16.532]                           restarts <- computeRestarts(cond)
[11:02:16.532]                           for (restart in restarts) {
[11:02:16.532]                             name <- restart$name
[11:02:16.532]                             if (is.null(name)) 
[11:02:16.532]                               next
[11:02:16.532]                             if (!grepl(pattern, name)) 
[11:02:16.532]                               next
[11:02:16.532]                             invokeRestart(restart)
[11:02:16.532]                             muffled <- TRUE
[11:02:16.532]                             break
[11:02:16.532]                           }
[11:02:16.532]                         }
[11:02:16.532]                       }
[11:02:16.532]                       invisible(muffled)
[11:02:16.532]                     }
[11:02:16.532]                     muffleCondition(cond, pattern = "^muffle")
[11:02:16.532]                   }
[11:02:16.532]                 }
[11:02:16.532]             }
[11:02:16.532]         }))
[11:02:16.532]     }, error = function(ex) {
[11:02:16.532]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:16.532]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:16.532]                 ...future.rng), started = ...future.startTime, 
[11:02:16.532]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:16.532]             version = "1.8"), class = "FutureResult")
[11:02:16.532]     }, finally = {
[11:02:16.532]         if (!identical(...future.workdir, getwd())) 
[11:02:16.532]             setwd(...future.workdir)
[11:02:16.532]         {
[11:02:16.532]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:16.532]                 ...future.oldOptions$nwarnings <- NULL
[11:02:16.532]             }
[11:02:16.532]             base::options(...future.oldOptions)
[11:02:16.532]             if (.Platform$OS.type == "windows") {
[11:02:16.532]                 old_names <- names(...future.oldEnvVars)
[11:02:16.532]                 envs <- base::Sys.getenv()
[11:02:16.532]                 names <- names(envs)
[11:02:16.532]                 common <- intersect(names, old_names)
[11:02:16.532]                 added <- setdiff(names, old_names)
[11:02:16.532]                 removed <- setdiff(old_names, names)
[11:02:16.532]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:16.532]                   envs[common]]
[11:02:16.532]                 NAMES <- toupper(changed)
[11:02:16.532]                 args <- list()
[11:02:16.532]                 for (kk in seq_along(NAMES)) {
[11:02:16.532]                   name <- changed[[kk]]
[11:02:16.532]                   NAME <- NAMES[[kk]]
[11:02:16.532]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.532]                     next
[11:02:16.532]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:16.532]                 }
[11:02:16.532]                 NAMES <- toupper(added)
[11:02:16.532]                 for (kk in seq_along(NAMES)) {
[11:02:16.532]                   name <- added[[kk]]
[11:02:16.532]                   NAME <- NAMES[[kk]]
[11:02:16.532]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.532]                     next
[11:02:16.532]                   args[[name]] <- ""
[11:02:16.532]                 }
[11:02:16.532]                 NAMES <- toupper(removed)
[11:02:16.532]                 for (kk in seq_along(NAMES)) {
[11:02:16.532]                   name <- removed[[kk]]
[11:02:16.532]                   NAME <- NAMES[[kk]]
[11:02:16.532]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.532]                     next
[11:02:16.532]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:16.532]                 }
[11:02:16.532]                 if (length(args) > 0) 
[11:02:16.532]                   base::do.call(base::Sys.setenv, args = args)
[11:02:16.532]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:16.532]             }
[11:02:16.532]             else {
[11:02:16.532]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:16.532]             }
[11:02:16.532]             {
[11:02:16.532]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:16.532]                   0L) {
[11:02:16.532]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:16.532]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:16.532]                   base::options(opts)
[11:02:16.532]                 }
[11:02:16.532]                 {
[11:02:16.532]                   {
[11:02:16.532]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:16.532]                     NULL
[11:02:16.532]                   }
[11:02:16.532]                   options(future.plan = NULL)
[11:02:16.532]                   if (is.na(NA_character_)) 
[11:02:16.532]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:16.532]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:16.532]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:16.532]                     .init = FALSE)
[11:02:16.532]                 }
[11:02:16.532]             }
[11:02:16.532]         }
[11:02:16.532]     })
[11:02:16.532]     if (TRUE) {
[11:02:16.532]         base::sink(type = "output", split = FALSE)
[11:02:16.532]         if (TRUE) {
[11:02:16.532]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:16.532]         }
[11:02:16.532]         else {
[11:02:16.532]             ...future.result["stdout"] <- base::list(NULL)
[11:02:16.532]         }
[11:02:16.532]         base::close(...future.stdout)
[11:02:16.532]         ...future.stdout <- NULL
[11:02:16.532]     }
[11:02:16.532]     ...future.result$conditions <- ...future.conditions
[11:02:16.532]     ...future.result$finished <- base::Sys.time()
[11:02:16.532]     ...future.result
[11:02:16.532] }
[11:02:16.534] assign_globals() ...
[11:02:16.534] List of 1
[11:02:16.534]  $ data:'data.frame':	3 obs. of  2 variables:
[11:02:16.534]   ..$ a: int [1:3] 1 2 3
[11:02:16.534]   ..$ b: int [1:3] 3 2 1
[11:02:16.534]  - attr(*, "where")=List of 1
[11:02:16.534]   ..$ data:<environment: R_EmptyEnv> 
[11:02:16.534]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:02:16.534]  - attr(*, "resolved")= logi FALSE
[11:02:16.534]  - attr(*, "total_size")= num 356
[11:02:16.534]  - attr(*, "already-done")= logi TRUE
[11:02:16.538] - copied ‘data’ to environment
[11:02:16.538] assign_globals() ... done
[11:02:16.538] requestCore(): workers = 2
[11:02:16.540] MulticoreFuture started
[11:02:16.540] - Launch lazy future ... done
[11:02:16.541] run() for ‘MulticoreFuture’ ... done
[11:02:16.541] result() for MulticoreFuture ...
[11:02:16.542] plan(): Setting new future strategy stack:
[11:02:16.542] List of future strategies:
[11:02:16.542] 1. sequential:
[11:02:16.542]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:16.542]    - tweaked: FALSE
[11:02:16.542]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:16.544] plan(): nbrOfWorkers() = 1
[11:02:16.570] plan(): Setting new future strategy stack:
[11:02:16.570] List of future strategies:
[11:02:16.570] 1. multicore:
[11:02:16.570]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:16.570]    - tweaked: FALSE
[11:02:16.570]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:16.570] 2. sequential:
[11:02:16.570]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:16.570]    - tweaked: FALSE
[11:02:16.570]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:16.572] plan(): nbrOfWorkers() = 2
[11:02:16.574] result() for MulticoreFuture ...
[11:02:16.574] result() for MulticoreFuture ... done
[11:02:16.574] signalConditions() ...
[11:02:16.574]  - include = ‘immediateCondition’
[11:02:16.574]  - exclude = 
[11:02:16.574]  - resignal = FALSE
[11:02:16.574]  - Number of conditions: 52
[11:02:16.575] signalConditions() ... done
[11:02:16.575] result() for MulticoreFuture ... done
[11:02:16.575] result() for MulticoreFuture ...
[11:02:16.575] result() for MulticoreFuture ... done
[11:02:16.575] signalConditions() ...
[11:02:16.575]  - include = ‘immediateCondition’
[11:02:16.575]  - exclude = 
[11:02:16.575]  - resignal = FALSE
[11:02:16.575]  - Number of conditions: 52
[11:02:16.576] signalConditions() ... done
[11:02:16.576] Future state: ‘finished’
[11:02:16.576] result() for MulticoreFuture ...
[11:02:16.576] result() for MulticoreFuture ... done
[11:02:16.576] signalConditions() ...
[11:02:16.576]  - include = ‘condition’
[11:02:16.576]  - exclude = ‘immediateCondition’
[11:02:16.576]  - resignal = TRUE
[11:02:16.576]  - Number of conditions: 52
[11:02:16.577]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.545] getGlobalsAndPackages() ...
[11:02:16.577]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.545] Searching for globals...
[11:02:16.577]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.547] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[11:02:16.577]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.548] Searching for globals ... DONE
[11:02:16.577]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.548] Resolving globals: FALSE
[11:02:16.577]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.549] The total size of the 1 globals is 356 bytes (356 bytes)
[11:02:16.578]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.549] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[11:02:16.578]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.550] - globals: [1] ‘data’
[11:02:16.578]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.550] 
[11:02:16.578]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.550] getGlobalsAndPackages() ... DONE
[11:02:16.578]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.551] run() for ‘Future’ ...
[11:02:16.578]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.551] - state: ‘created’
[11:02:16.578]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.551] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:02:16.579]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.552] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:16.579]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.552] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:16.579]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.552]   - Field: ‘label’
[11:02:16.579]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.552]   - Field: ‘local’
[11:02:16.579]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.552]   - Field: ‘owner’
[11:02:16.579]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.552]   - Field: ‘envir’
[11:02:16.580]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.553]   - Field: ‘packages’
[11:02:16.580]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.553]   - Field: ‘gc’
[11:02:16.580]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.553]   - Field: ‘conditions’
[11:02:16.580]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.553]   - Field: ‘expr’
[11:02:16.580]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.553]   - Field: ‘uuid’
[11:02:16.580]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.554]   - Field: ‘seed’
[11:02:16.581]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.554]   - Field: ‘version’
[11:02:16.581]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.554]   - Field: ‘result’
[11:02:16.581]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.554]   - Field: ‘asynchronous’
[11:02:16.581]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.554]   - Field: ‘calls’
[11:02:16.581]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.555]   - Field: ‘globals’
[11:02:16.581]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.555]   - Field: ‘stdout’
[11:02:16.582]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.555]   - Field: ‘earlySignal’
[11:02:16.582]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.555]   - Field: ‘lazy’
[11:02:16.582]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.555]   - Field: ‘state’
[11:02:16.582]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.556] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:16.582]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.556] - Launch lazy future ...
[11:02:16.582]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.556] Packages needed by the future expression (n = 0): <none>
[11:02:16.583]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.556] Packages needed by future strategies (n = 0): <none>
[11:02:16.583]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.557] {
[11:02:16.557]     {
[11:02:16.557]         {
[11:02:16.557]             ...future.startTime <- base::Sys.time()
[11:02:16.557]             {
[11:02:16.557]                 {
[11:02:16.557]                   {
[11:02:16.557]                     base::local({
[11:02:16.557]                       has_future <- base::requireNamespace("future", 
[11:02:16.557]                         quietly = TRUE)
[11:02:16.557]                       if (has_future) {
[11:02:16.557]                         ns <- base::getNamespace("future")
[11:02:16.557]                         version <- ns[[".package"]][["version"]]
[11:02:16.557]                         if (is.null(version)) 
[11:02:16.557]                           version <- utils::packageVersion("future")
[11:02:16.557]                       }
[11:02:16.557]                       else {
[11:02:16.557]                         version <- NULL
[11:02:16.557]                       }
[11:02:16.557]                       if (!has_future || version < "1.8.0") {
[11:02:16.557]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:16.557]                           "", base::R.version$version.string), 
[11:02:16.557]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:16.557]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:16.557]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:16.557]                             "release", "version")], collapse = " "), 
[11:02:16.557]                           hostname = base::Sys.info()[["nodename"]])
[11:02:16.557]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:16.557]                           info)
[11:02:16.557]                         info <- base::paste(info, collapse = "; ")
[11:02:16.557]                         if (!has_future) {
[11:02:16.557]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:16.557]                             info)
[11:02:16.557]                         }
[11:02:16.557]                         else {
[11:02:16.557]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:16.557]                             info, version)
[11:02:16.557]                         }
[11:02:16.557]                         base::stop(msg)
[11:02:16.557]                       }
[11:02:16.557]                     })
[11:02:16.557]                   }
[11:02:16.557]                   ...future.strategy.old <- future::plan("list")
[11:02:16.557]                   options(future.plan = NULL)
[11:02:16.557]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:16.557]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:16.557]                 }
[11:02:16.557]                 ...future.workdir <- getwd()
[11:02:16.557]             }
[11:02:16.557]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:16.557]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:16.557]         }
[11:02:16.557]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:16.557]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:16.557]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:16.557]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:16.557]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:16.557]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:16.557]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:16.557]             base::names(...future.oldOptions))
[11:02:16.557]     }
[11:02:16.557]     if (FALSE) {
[11:02:16.557]     }
[11:02:16.557]     else {
[11:02:16.557]         if (TRUE) {
[11:02:16.557]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:16.557]                 open = "w")
[11:02:16.557]         }
[11:02:16.557]         else {
[11:02:16.557]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:16.557]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:16.557]         }
[11:02:16.557]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:16.557]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:16.557]             base::sink(type = "output", split = FALSE)
[11:02:16.557]             base::close(...future.stdout)
[11:02:16.557]         }, add = TRUE)
[11:02:16.557]     }
[11:02:16.557]     ...future.frame <- base::sys.nframe()
[11:02:16.557]     ...future.conditions <- base::list()
[11:02:16.557]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:16.557]     if (FALSE) {
[11:02:16.557]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:16.557]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:16.557]     }
[11:02:16.557]     ...future.result <- base::tryCatch({
[11:02:16.557]         base::withCallingHandlers({
[11:02:16.557]             ...future.value <- base::withVisible(base::local(subset(data, 
[11:02:16.557]                 a == 2)))
[11:02:16.557]             future::FutureResult(value = ...future.value$value, 
[11:02:16.557]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:16.557]                   ...future.rng), globalenv = if (FALSE) 
[11:02:16.557]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:16.557]                     ...future.globalenv.names))
[11:02:16.557]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:16.557]         }, condition = base::local({
[11:02:16.557]             c <- base::c
[11:02:16.557]             inherits <- base::inherits
[11:02:16.557]             invokeRestart <- base::invokeRestart
[11:02:16.557]             length <- base::length
[11:02:16.557]             list <- base::list
[11:02:16.557]             seq.int <- base::seq.int
[11:02:16.557]             signalCondition <- base::signalCondition
[11:02:16.557]             sys.calls <- base::sys.calls
[11:02:16.557]             `[[` <- base::`[[`
[11:02:16.557]             `+` <- base::`+`
[11:02:16.557]             `<<-` <- base::`<<-`
[11:02:16.557]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:16.557]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:16.557]                   3L)]
[11:02:16.557]             }
[11:02:16.557]             function(cond) {
[11:02:16.557]                 is_error <- inherits(cond, "error")
[11:02:16.557]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:16.557]                   NULL)
[11:02:16.557]                 if (is_error) {
[11:02:16.557]                   sessionInformation <- function() {
[11:02:16.557]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:16.557]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:16.557]                       search = base::search(), system = base::Sys.info())
[11:02:16.557]                   }
[11:02:16.557]                   ...future.conditions[[length(...future.conditions) + 
[11:02:16.557]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:16.557]                     cond$call), session = sessionInformation(), 
[11:02:16.557]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:16.557]                   signalCondition(cond)
[11:02:16.557]                 }
[11:02:16.557]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:16.557]                 "immediateCondition"))) {
[11:02:16.557]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:16.557]                   ...future.conditions[[length(...future.conditions) + 
[11:02:16.557]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:16.557]                   if (TRUE && !signal) {
[11:02:16.557]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.557]                     {
[11:02:16.557]                       inherits <- base::inherits
[11:02:16.557]                       invokeRestart <- base::invokeRestart
[11:02:16.557]                       is.null <- base::is.null
[11:02:16.557]                       muffled <- FALSE
[11:02:16.557]                       if (inherits(cond, "message")) {
[11:02:16.557]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:16.557]                         if (muffled) 
[11:02:16.557]                           invokeRestart("muffleMessage")
[11:02:16.557]                       }
[11:02:16.557]                       else if (inherits(cond, "warning")) {
[11:02:16.557]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:16.557]                         if (muffled) 
[11:02:16.557]                           invokeRestart("muffleWarning")
[11:02:16.557]                       }
[11:02:16.557]                       else if (inherits(cond, "condition")) {
[11:02:16.557]                         if (!is.null(pattern)) {
[11:02:16.557]                           computeRestarts <- base::computeRestarts
[11:02:16.557]                           grepl <- base::grepl
[11:02:16.557]                           restarts <- computeRestarts(cond)
[11:02:16.557]                           for (restart in restarts) {
[11:02:16.557]                             name <- restart$name
[11:02:16.557]                             if (is.null(name)) 
[11:02:16.557]                               next
[11:02:16.557]                             if (!grepl(pattern, name)) 
[11:02:16.557]                               next
[11:02:16.557]                             invokeRestart(restart)
[11:02:16.557]                             muffled <- TRUE
[11:02:16.557]                             break
[11:02:16.557]                           }
[11:02:16.557]                         }
[11:02:16.557]                       }
[11:02:16.557]                       invisible(muffled)
[11:02:16.557]                     }
[11:02:16.557]                     muffleCondition(cond, pattern = "^muffle")
[11:02:16.557]                   }
[11:02:16.557]                 }
[11:02:16.557]                 else {
[11:02:16.557]                   if (TRUE) {
[11:02:16.557]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.557]                     {
[11:02:16.557]                       inherits <- base::inherits
[11:02:16.557]                       invokeRestart <- base::invokeRestart
[11:02:16.557]                       is.null <- base::is.null
[11:02:16.557]                       muffled <- FALSE
[11:02:16.557]                       if (inherits(cond, "message")) {
[11:02:16.557]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:16.557]                         if (muffled) 
[11:02:16.557]                           invokeRestart("muffleMessage")
[11:02:16.557]                       }
[11:02:16.557]                       else if (inherits(cond, "warning")) {
[11:02:16.557]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:16.557]                         if (muffled) 
[11:02:16.557]                           invokeRestart("muffleWarning")
[11:02:16.557]                       }
[11:02:16.557]                       else if (inherits(cond, "condition")) {
[11:02:16.557]                         if (!is.null(pattern)) {
[11:02:16.557]                           computeRestarts <- base::computeRestarts
[11:02:16.557]                           grepl <- base::grepl
[11:02:16.557]                           restarts <- computeRestarts(cond)
[11:02:16.557]                           for (restart in restarts) {
[11:02:16.557]                             name <- restart$name
[11:02:16.557]                             if (is.null(name)) 
[11:02:16.557]                               next
[11:02:16.557]                             if (!grepl(pattern, name)) 
[11:02:16.557]                               next
[11:02:16.557]                             invokeRestart(restart)
[11:02:16.557]                             muffled <- TRUE
[11:02:16.557]                             break
[11:02:16.557]                           }
[11:02:16.557]                         }
[11:02:16.557]                       }
[11:02:16.557]                       invisible(muffled)
[11:02:16.557]                     }
[11:02:16.557]                     muffleCondition(cond, pattern = "^muffle")
[11:02:16.557]                   }
[11:02:16.557]                 }
[11:02:16.557]             }
[11:02:16.557]         }))
[11:02:16.557]     }, error = function(ex) {
[11:02:16.557]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:16.557]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:16.557]                 ...future.rng), started = ...future.startTime, 
[11:02:16.557]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:16.557]             version = "1.8"), class = "FutureResult")
[11:02:16.557]     }, finally = {
[11:02:16.557]         if (!identical(...future.workdir, getwd())) 
[11:02:16.557]             setwd(...future.workdir)
[11:02:16.557]         {
[11:02:16.557]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:16.557]                 ...future.oldOptions$nwarnings <- NULL
[11:02:16.557]             }
[11:02:16.557]             base::options(...future.oldOptions)
[11:02:16.557]             if (.Platform$OS.type == "windows") {
[11:02:16.557]                 old_names <- names(...future.oldEnvVars)
[11:02:16.557]                 envs <- base::Sys.getenv()
[11:02:16.557]                 names <- names(envs)
[11:02:16.557]                 common <- intersect(names, old_names)
[11:02:16.557]                 added <- setdiff(names, old_names)
[11:02:16.557]                 removed <- setdiff(old_names, names)
[11:02:16.557]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:16.557]                   envs[common]]
[11:02:16.557]                 NAMES <- toupper(changed)
[11:02:16.557]                 args <- list()
[11:02:16.557]                 for (kk in seq_along(NAMES)) {
[11:02:16.557]                   name <- changed[[kk]]
[11:02:16.557]                   NAME <- NAMES[[kk]]
[11:02:16.557]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.557]                     next
[11:02:16.557]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:16.557]                 }
[11:02:16.557]                 NAMES <- toupper(added)
[11:02:16.557]                 for (kk in seq_along(NAMES)) {
[11:02:16.557]                   name <- added[[kk]]
[11:02:16.557]                   NAME <- NAMES[[kk]]
[11:02:16.557]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.557]                     next
[11:02:16.557]                   args[[name]] <- ""
[11:02:16.557]                 }
[11:02:16.557]                 NAMES <- toupper(removed)
[11:02:16.557]                 for (kk in seq_along(NAMES)) {
[11:02:16.557]                   name <- removed[[kk]]
[11:02:16.557]                   NAME <- NAMES[[kk]]
[11:02:16.557]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.557]                     next
[11:02:16.557]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:16.557]                 }
[11:02:16.557]                 if (length(args) > 0) 
[11:02:16.557]                   base::do.call(base::Sys.setenv, args = args)
[11:02:16.557]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:16.557]             }
[11:02:16.557]             else {
[11:02:16.557]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:16.557]             }
[11:02:16.557]             {
[11:02:16.557]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:16.557]                   0L) {
[11:02:16.557]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:16.557]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:16.557]                   base::options(opts)
[11:02:16.557]                 }
[11:02:16.557]                 {
[11:02:16.557]                   {
[11:02:16.557]                     NULL
[11:02:16.557]                     RNGkind("Mersenne-Twister")
[11:02:16.557]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:16.557]                       inherits = FALSE)
[11:02:16.557]                   }
[11:02:16.557]                   options(future.plan = NULL)
[11:02:16.557]                   if (is.na(NA_character_)) 
[11:02:16.557]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:16.557]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:16.557]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:16.557]                     .init = FALSE)
[11:02:16.557]                 }
[11:02:16.557]             }
[11:02:16.557]         }
[11:02:16.557]     })
[11:02:16.557]     if (TRUE) {
[11:02:16.557]         base::sink(type = "output", split = FALSE)
[11:02:16.557]         if (TRUE) {
[11:02:16.557]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:16.557]         }
[11:02:16.557]         else {
[11:02:16.557]             ...future.result["stdout"] <- base::list(NULL)
[11:02:16.557]         }
[11:02:16.557]         base::close(...future.stdout)
[11:02:16.557]         ...future.stdout <- NULL
[11:02:16.557]     }
[11:02:16.557]     ...future.result$conditions <- ...future.conditions
[11:02:16.557]     ...future.result$finished <- base::Sys.time()
[11:02:16.557]     ...future.result
[11:02:16.557] }
[11:02:16.583]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.559] assign_globals() ...
[11:02:16.583]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.560] List of 1
[11:02:16.560]  $ data:'data.frame':	3 obs. of  2 variables:
[11:02:16.560]   ..$ a: int [1:3] 1 2 3
[11:02:16.560]   ..$ b: int [1:3] 3 2 1
[11:02:16.560]  - attr(*, "where")=List of 1
[11:02:16.560]   ..$ data:<environment: R_EmptyEnv> 
[11:02:16.560]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:02:16.560]  - attr(*, "resolved")= logi FALSE
[11:02:16.560]  - attr(*, "total_size")= num 356
[11:02:16.560]  - attr(*, "already-done")= logi TRUE
[11:02:16.583]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.565] - copied ‘data’ to environment
[11:02:16.584]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.565] assign_globals() ... done
[11:02:16.584]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.566] plan(): Setting new future strategy stack:
[11:02:16.584]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.566] List of future strategies:
[11:02:16.566] 1. sequential:
[11:02:16.566]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:16.566]    - tweaked: FALSE
[11:02:16.566]    - call: NULL
[11:02:16.584]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.566] plan(): nbrOfWorkers() = 1
[11:02:16.584]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.568] plan(): Setting new future strategy stack:
[11:02:16.585]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.568] List of future strategies:
[11:02:16.568] 1. sequential:
[11:02:16.568]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:16.568]    - tweaked: FALSE
[11:02:16.568]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:16.585]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.568] plan(): nbrOfWorkers() = 1
[11:02:16.585]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.569] SequentialFuture started (and completed)
[11:02:16.585]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.569] - Launch lazy future ... done
[11:02:16.585]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.569] run() for ‘SequentialFuture’ ... done
[11:02:16.585] signalConditions() ... done
- plan(list('multicore', 'sequential')) ... DONE
- plan(list('multicore', 'multicore')) ...
[11:02:16.586] plan(): Setting new future strategy stack:
[11:02:16.586] List of future strategies:
[11:02:16.586] 1. multicore:
[11:02:16.586]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:16.586]    - tweaked: FALSE
[11:02:16.586]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:16.586] 2. multicore:
[11:02:16.586]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:16.586]    - tweaked: FALSE
[11:02:16.586]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:16.588] plan(): nbrOfWorkers() = 2
[11:02:16.589] getGlobalsAndPackages() ...
[11:02:16.589] Searching for globals...
[11:02:16.608] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[11:02:16.608] Searching for globals ... DONE
[11:02:16.608] Resolving globals: FALSE
[11:02:16.609] The total size of the 2 globals is 11.88 KiB (12162 bytes)
[11:02:16.609] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 11.88 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (11.83 KiB of class ‘list’) and ‘strategy2’ (48 bytes of class ‘character’)
[11:02:16.610] - globals: [2] ‘nested’, ‘strategy2’
[11:02:16.610] - packages: [1] ‘future’
[11:02:16.610] getGlobalsAndPackages() ... DONE
[11:02:16.610] run() for ‘Future’ ...
[11:02:16.610] - state: ‘created’
[11:02:16.610] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:02:16.612] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:16.612] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:02:16.612]   - Field: ‘label’
[11:02:16.613]   - Field: ‘local’
[11:02:16.613]   - Field: ‘owner’
[11:02:16.613]   - Field: ‘envir’
[11:02:16.613]   - Field: ‘workers’
[11:02:16.613]   - Field: ‘packages’
[11:02:16.613]   - Field: ‘gc’
[11:02:16.613]   - Field: ‘job’
[11:02:16.613]   - Field: ‘conditions’
[11:02:16.613]   - Field: ‘expr’
[11:02:16.613]   - Field: ‘uuid’
[11:02:16.614]   - Field: ‘seed’
[11:02:16.614]   - Field: ‘version’
[11:02:16.614]   - Field: ‘result’
[11:02:16.614]   - Field: ‘asynchronous’
[11:02:16.614]   - Field: ‘calls’
[11:02:16.614]   - Field: ‘globals’
[11:02:16.614]   - Field: ‘stdout’
[11:02:16.614]   - Field: ‘earlySignal’
[11:02:16.614]   - Field: ‘lazy’
[11:02:16.614]   - Field: ‘state’
[11:02:16.615] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:02:16.615] - Launch lazy future ...
[11:02:16.615] Packages needed by the future expression (n = 1): ‘future’
[11:02:16.615] Packages needed by future strategies (n = 1): ‘future’
[11:02:16.616] {
[11:02:16.616]     {
[11:02:16.616]         {
[11:02:16.616]             ...future.startTime <- base::Sys.time()
[11:02:16.616]             {
[11:02:16.616]                 {
[11:02:16.616]                   {
[11:02:16.616]                     {
[11:02:16.616]                       {
[11:02:16.616]                         base::local({
[11:02:16.616]                           has_future <- base::requireNamespace("future", 
[11:02:16.616]                             quietly = TRUE)
[11:02:16.616]                           if (has_future) {
[11:02:16.616]                             ns <- base::getNamespace("future")
[11:02:16.616]                             version <- ns[[".package"]][["version"]]
[11:02:16.616]                             if (is.null(version)) 
[11:02:16.616]                               version <- utils::packageVersion("future")
[11:02:16.616]                           }
[11:02:16.616]                           else {
[11:02:16.616]                             version <- NULL
[11:02:16.616]                           }
[11:02:16.616]                           if (!has_future || version < "1.8.0") {
[11:02:16.616]                             info <- base::c(r_version = base::gsub("R version ", 
[11:02:16.616]                               "", base::R.version$version.string), 
[11:02:16.616]                               platform = base::sprintf("%s (%s-bit)", 
[11:02:16.616]                                 base::R.version$platform, 8 * 
[11:02:16.616]                                   base::.Machine$sizeof.pointer), 
[11:02:16.616]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:16.616]                                 "release", "version")], collapse = " "), 
[11:02:16.616]                               hostname = base::Sys.info()[["nodename"]])
[11:02:16.616]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:02:16.616]                               info)
[11:02:16.616]                             info <- base::paste(info, collapse = "; ")
[11:02:16.616]                             if (!has_future) {
[11:02:16.616]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:16.616]                                 info)
[11:02:16.616]                             }
[11:02:16.616]                             else {
[11:02:16.616]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:16.616]                                 info, version)
[11:02:16.616]                             }
[11:02:16.616]                             base::stop(msg)
[11:02:16.616]                           }
[11:02:16.616]                         })
[11:02:16.616]                       }
[11:02:16.616]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:16.616]                       base::options(mc.cores = 1L)
[11:02:16.616]                     }
[11:02:16.616]                     base::local({
[11:02:16.616]                       for (pkg in "future") {
[11:02:16.616]                         base::loadNamespace(pkg)
[11:02:16.616]                         base::library(pkg, character.only = TRUE)
[11:02:16.616]                       }
[11:02:16.616]                     })
[11:02:16.616]                   }
[11:02:16.616]                   ...future.strategy.old <- future::plan("list")
[11:02:16.616]                   options(future.plan = NULL)
[11:02:16.616]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:16.616]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[11:02:16.616]                     envir = parent.frame()) 
[11:02:16.616]                   {
[11:02:16.616]                     default_workers <- missing(workers)
[11:02:16.616]                     if (is.function(workers)) 
[11:02:16.616]                       workers <- workers()
[11:02:16.616]                     workers <- structure(as.integer(workers), 
[11:02:16.616]                       class = class(workers))
[11:02:16.616]                     stop_if_not(is.finite(workers), workers >= 
[11:02:16.616]                       1L)
[11:02:16.616]                     if ((workers == 1L && !inherits(workers, 
[11:02:16.616]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[11:02:16.616]                       if (default_workers) 
[11:02:16.616]                         supportsMulticore(warn = TRUE)
[11:02:16.616]                       return(sequential(..., envir = envir))
[11:02:16.616]                     }
[11:02:16.616]                     oopts <- options(mc.cores = workers)
[11:02:16.616]                     on.exit(options(oopts))
[11:02:16.616]                     future <- MulticoreFuture(..., workers = workers, 
[11:02:16.616]                       envir = envir)
[11:02:16.616]                     if (!future$lazy) 
[11:02:16.616]                       future <- run(future)
[11:02:16.616]                     invisible(future)
[11:02:16.616]                   }), .cleanup = FALSE, .init = FALSE)
[11:02:16.616]                 }
[11:02:16.616]                 ...future.workdir <- getwd()
[11:02:16.616]             }
[11:02:16.616]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:16.616]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:16.616]         }
[11:02:16.616]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:16.616]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:16.616]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:16.616]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:16.616]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:16.616]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:16.616]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:16.616]             base::names(...future.oldOptions))
[11:02:16.616]     }
[11:02:16.616]     if (FALSE) {
[11:02:16.616]     }
[11:02:16.616]     else {
[11:02:16.616]         if (TRUE) {
[11:02:16.616]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:16.616]                 open = "w")
[11:02:16.616]         }
[11:02:16.616]         else {
[11:02:16.616]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:16.616]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:16.616]         }
[11:02:16.616]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:16.616]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:16.616]             base::sink(type = "output", split = FALSE)
[11:02:16.616]             base::close(...future.stdout)
[11:02:16.616]         }, add = TRUE)
[11:02:16.616]     }
[11:02:16.616]     ...future.frame <- base::sys.nframe()
[11:02:16.616]     ...future.conditions <- base::list()
[11:02:16.616]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:16.616]     if (FALSE) {
[11:02:16.616]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:16.616]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:16.616]     }
[11:02:16.616]     ...future.result <- base::tryCatch({
[11:02:16.616]         base::withCallingHandlers({
[11:02:16.616]             ...future.value <- base::withVisible(base::local({
[11:02:16.616]                 withCallingHandlers({
[11:02:16.616]                   {
[11:02:16.616]                     a <- 1L
[11:02:16.616]                     plan_a <- unclass(future::plan("list"))
[11:02:16.616]                     nested_a <- nested[-1]
[11:02:16.616]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[11:02:16.616]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[11:02:16.616]                       strategy2))
[11:02:16.616]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[11:02:16.616]                       "init") <- NULL
[11:02:16.616]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[11:02:16.616]                       "init") <- NULL
[11:02:16.616]                     stopifnot(all.equal(plan_a, nested_a))
[11:02:16.616]                     y %<-% {
[11:02:16.616]                       b <- 2L
[11:02:16.616]                       plan_b <- future::plan("list")
[11:02:16.616]                       nested_b <- nested_a[-1]
[11:02:16.616]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[11:02:16.616]                         1L, inherits(plan_b[[1]], "future"), 
[11:02:16.616]                         inherits(future::plan("next"), "sequential"))
[11:02:16.616]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[11:02:16.616]                         b = b, nested_b = nested_b, plan_b = plan_b)
[11:02:16.616]                     }
[11:02:16.616]                     y
[11:02:16.616]                   }
[11:02:16.616]                 }, immediateCondition = function(cond) {
[11:02:16.616]                   save_rds <- function (object, pathname, ...) 
[11:02:16.616]                   {
[11:02:16.616]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:02:16.616]                     if (file_test("-f", pathname_tmp)) {
[11:02:16.616]                       fi_tmp <- file.info(pathname_tmp)
[11:02:16.616]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:02:16.616]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:16.616]                         fi_tmp[["mtime"]])
[11:02:16.616]                     }
[11:02:16.616]                     tryCatch({
[11:02:16.616]                       saveRDS(object, file = pathname_tmp, ...)
[11:02:16.616]                     }, error = function(ex) {
[11:02:16.616]                       msg <- conditionMessage(ex)
[11:02:16.616]                       fi_tmp <- file.info(pathname_tmp)
[11:02:16.616]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:02:16.616]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:16.616]                         fi_tmp[["mtime"]], msg)
[11:02:16.616]                       ex$message <- msg
[11:02:16.616]                       stop(ex)
[11:02:16.616]                     })
[11:02:16.616]                     stopifnot(file_test("-f", pathname_tmp))
[11:02:16.616]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:02:16.616]                     if (!res || file_test("-f", pathname_tmp)) {
[11:02:16.616]                       fi_tmp <- file.info(pathname_tmp)
[11:02:16.616]                       fi <- file.info(pathname)
[11:02:16.616]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:02:16.616]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:16.616]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:02:16.616]                         fi[["size"]], fi[["mtime"]])
[11:02:16.616]                       stop(msg)
[11:02:16.616]                     }
[11:02:16.616]                     invisible(pathname)
[11:02:16.616]                   }
[11:02:16.616]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:02:16.616]                     rootPath = tempdir()) 
[11:02:16.616]                   {
[11:02:16.616]                     obj <- list(time = Sys.time(), condition = cond)
[11:02:16.616]                     file <- tempfile(pattern = class(cond)[1], 
[11:02:16.616]                       tmpdir = path, fileext = ".rds")
[11:02:16.616]                     save_rds(obj, file)
[11:02:16.616]                   }
[11:02:16.616]                   saveImmediateCondition(cond, path = "/tmp/RtmpVZPEla/.future/immediateConditions")
[11:02:16.616]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.616]                   {
[11:02:16.616]                     inherits <- base::inherits
[11:02:16.616]                     invokeRestart <- base::invokeRestart
[11:02:16.616]                     is.null <- base::is.null
[11:02:16.616]                     muffled <- FALSE
[11:02:16.616]                     if (inherits(cond, "message")) {
[11:02:16.616]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:16.616]                       if (muffled) 
[11:02:16.616]                         invokeRestart("muffleMessage")
[11:02:16.616]                     }
[11:02:16.616]                     else if (inherits(cond, "warning")) {
[11:02:16.616]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:16.616]                       if (muffled) 
[11:02:16.616]                         invokeRestart("muffleWarning")
[11:02:16.616]                     }
[11:02:16.616]                     else if (inherits(cond, "condition")) {
[11:02:16.616]                       if (!is.null(pattern)) {
[11:02:16.616]                         computeRestarts <- base::computeRestarts
[11:02:16.616]                         grepl <- base::grepl
[11:02:16.616]                         restarts <- computeRestarts(cond)
[11:02:16.616]                         for (restart in restarts) {
[11:02:16.616]                           name <- restart$name
[11:02:16.616]                           if (is.null(name)) 
[11:02:16.616]                             next
[11:02:16.616]                           if (!grepl(pattern, name)) 
[11:02:16.616]                             next
[11:02:16.616]                           invokeRestart(restart)
[11:02:16.616]                           muffled <- TRUE
[11:02:16.616]                           break
[11:02:16.616]                         }
[11:02:16.616]                       }
[11:02:16.616]                     }
[11:02:16.616]                     invisible(muffled)
[11:02:16.616]                   }
[11:02:16.616]                   muffleCondition(cond)
[11:02:16.616]                 })
[11:02:16.616]             }))
[11:02:16.616]             future::FutureResult(value = ...future.value$value, 
[11:02:16.616]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:16.616]                   ...future.rng), globalenv = if (FALSE) 
[11:02:16.616]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:16.616]                     ...future.globalenv.names))
[11:02:16.616]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:16.616]         }, condition = base::local({
[11:02:16.616]             c <- base::c
[11:02:16.616]             inherits <- base::inherits
[11:02:16.616]             invokeRestart <- base::invokeRestart
[11:02:16.616]             length <- base::length
[11:02:16.616]             list <- base::list
[11:02:16.616]             seq.int <- base::seq.int
[11:02:16.616]             signalCondition <- base::signalCondition
[11:02:16.616]             sys.calls <- base::sys.calls
[11:02:16.616]             `[[` <- base::`[[`
[11:02:16.616]             `+` <- base::`+`
[11:02:16.616]             `<<-` <- base::`<<-`
[11:02:16.616]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:16.616]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:16.616]                   3L)]
[11:02:16.616]             }
[11:02:16.616]             function(cond) {
[11:02:16.616]                 is_error <- inherits(cond, "error")
[11:02:16.616]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:16.616]                   NULL)
[11:02:16.616]                 if (is_error) {
[11:02:16.616]                   sessionInformation <- function() {
[11:02:16.616]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:16.616]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:16.616]                       search = base::search(), system = base::Sys.info())
[11:02:16.616]                   }
[11:02:16.616]                   ...future.conditions[[length(...future.conditions) + 
[11:02:16.616]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:16.616]                     cond$call), session = sessionInformation(), 
[11:02:16.616]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:16.616]                   signalCondition(cond)
[11:02:16.616]                 }
[11:02:16.616]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:16.616]                 "immediateCondition"))) {
[11:02:16.616]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:16.616]                   ...future.conditions[[length(...future.conditions) + 
[11:02:16.616]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:16.616]                   if (TRUE && !signal) {
[11:02:16.616]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.616]                     {
[11:02:16.616]                       inherits <- base::inherits
[11:02:16.616]                       invokeRestart <- base::invokeRestart
[11:02:16.616]                       is.null <- base::is.null
[11:02:16.616]                       muffled <- FALSE
[11:02:16.616]                       if (inherits(cond, "message")) {
[11:02:16.616]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:16.616]                         if (muffled) 
[11:02:16.616]                           invokeRestart("muffleMessage")
[11:02:16.616]                       }
[11:02:16.616]                       else if (inherits(cond, "warning")) {
[11:02:16.616]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:16.616]                         if (muffled) 
[11:02:16.616]                           invokeRestart("muffleWarning")
[11:02:16.616]                       }
[11:02:16.616]                       else if (inherits(cond, "condition")) {
[11:02:16.616]                         if (!is.null(pattern)) {
[11:02:16.616]                           computeRestarts <- base::computeRestarts
[11:02:16.616]                           grepl <- base::grepl
[11:02:16.616]                           restarts <- computeRestarts(cond)
[11:02:16.616]                           for (restart in restarts) {
[11:02:16.616]                             name <- restart$name
[11:02:16.616]                             if (is.null(name)) 
[11:02:16.616]                               next
[11:02:16.616]                             if (!grepl(pattern, name)) 
[11:02:16.616]                               next
[11:02:16.616]                             invokeRestart(restart)
[11:02:16.616]                             muffled <- TRUE
[11:02:16.616]                             break
[11:02:16.616]                           }
[11:02:16.616]                         }
[11:02:16.616]                       }
[11:02:16.616]                       invisible(muffled)
[11:02:16.616]                     }
[11:02:16.616]                     muffleCondition(cond, pattern = "^muffle")
[11:02:16.616]                   }
[11:02:16.616]                 }
[11:02:16.616]                 else {
[11:02:16.616]                   if (TRUE) {
[11:02:16.616]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.616]                     {
[11:02:16.616]                       inherits <- base::inherits
[11:02:16.616]                       invokeRestart <- base::invokeRestart
[11:02:16.616]                       is.null <- base::is.null
[11:02:16.616]                       muffled <- FALSE
[11:02:16.616]                       if (inherits(cond, "message")) {
[11:02:16.616]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:16.616]                         if (muffled) 
[11:02:16.616]                           invokeRestart("muffleMessage")
[11:02:16.616]                       }
[11:02:16.616]                       else if (inherits(cond, "warning")) {
[11:02:16.616]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:16.616]                         if (muffled) 
[11:02:16.616]                           invokeRestart("muffleWarning")
[11:02:16.616]                       }
[11:02:16.616]                       else if (inherits(cond, "condition")) {
[11:02:16.616]                         if (!is.null(pattern)) {
[11:02:16.616]                           computeRestarts <- base::computeRestarts
[11:02:16.616]                           grepl <- base::grepl
[11:02:16.616]                           restarts <- computeRestarts(cond)
[11:02:16.616]                           for (restart in restarts) {
[11:02:16.616]                             name <- restart$name
[11:02:16.616]                             if (is.null(name)) 
[11:02:16.616]                               next
[11:02:16.616]                             if (!grepl(pattern, name)) 
[11:02:16.616]                               next
[11:02:16.616]                             invokeRestart(restart)
[11:02:16.616]                             muffled <- TRUE
[11:02:16.616]                             break
[11:02:16.616]                           }
[11:02:16.616]                         }
[11:02:16.616]                       }
[11:02:16.616]                       invisible(muffled)
[11:02:16.616]                     }
[11:02:16.616]                     muffleCondition(cond, pattern = "^muffle")
[11:02:16.616]                   }
[11:02:16.616]                 }
[11:02:16.616]             }
[11:02:16.616]         }))
[11:02:16.616]     }, error = function(ex) {
[11:02:16.616]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:16.616]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:16.616]                 ...future.rng), started = ...future.startTime, 
[11:02:16.616]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:16.616]             version = "1.8"), class = "FutureResult")
[11:02:16.616]     }, finally = {
[11:02:16.616]         if (!identical(...future.workdir, getwd())) 
[11:02:16.616]             setwd(...future.workdir)
[11:02:16.616]         {
[11:02:16.616]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:16.616]                 ...future.oldOptions$nwarnings <- NULL
[11:02:16.616]             }
[11:02:16.616]             base::options(...future.oldOptions)
[11:02:16.616]             if (.Platform$OS.type == "windows") {
[11:02:16.616]                 old_names <- names(...future.oldEnvVars)
[11:02:16.616]                 envs <- base::Sys.getenv()
[11:02:16.616]                 names <- names(envs)
[11:02:16.616]                 common <- intersect(names, old_names)
[11:02:16.616]                 added <- setdiff(names, old_names)
[11:02:16.616]                 removed <- setdiff(old_names, names)
[11:02:16.616]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:16.616]                   envs[common]]
[11:02:16.616]                 NAMES <- toupper(changed)
[11:02:16.616]                 args <- list()
[11:02:16.616]                 for (kk in seq_along(NAMES)) {
[11:02:16.616]                   name <- changed[[kk]]
[11:02:16.616]                   NAME <- NAMES[[kk]]
[11:02:16.616]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.616]                     next
[11:02:16.616]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:16.616]                 }
[11:02:16.616]                 NAMES <- toupper(added)
[11:02:16.616]                 for (kk in seq_along(NAMES)) {
[11:02:16.616]                   name <- added[[kk]]
[11:02:16.616]                   NAME <- NAMES[[kk]]
[11:02:16.616]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.616]                     next
[11:02:16.616]                   args[[name]] <- ""
[11:02:16.616]                 }
[11:02:16.616]                 NAMES <- toupper(removed)
[11:02:16.616]                 for (kk in seq_along(NAMES)) {
[11:02:16.616]                   name <- removed[[kk]]
[11:02:16.616]                   NAME <- NAMES[[kk]]
[11:02:16.616]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.616]                     next
[11:02:16.616]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:16.616]                 }
[11:02:16.616]                 if (length(args) > 0) 
[11:02:16.616]                   base::do.call(base::Sys.setenv, args = args)
[11:02:16.616]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:16.616]             }
[11:02:16.616]             else {
[11:02:16.616]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:16.616]             }
[11:02:16.616]             {
[11:02:16.616]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:16.616]                   0L) {
[11:02:16.616]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:16.616]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:16.616]                   base::options(opts)
[11:02:16.616]                 }
[11:02:16.616]                 {
[11:02:16.616]                   {
[11:02:16.616]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:16.616]                     NULL
[11:02:16.616]                   }
[11:02:16.616]                   options(future.plan = NULL)
[11:02:16.616]                   if (is.na(NA_character_)) 
[11:02:16.616]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:16.616]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:16.616]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:16.616]                     .init = FALSE)
[11:02:16.616]                 }
[11:02:16.616]             }
[11:02:16.616]         }
[11:02:16.616]     })
[11:02:16.616]     if (TRUE) {
[11:02:16.616]         base::sink(type = "output", split = FALSE)
[11:02:16.616]         if (TRUE) {
[11:02:16.616]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:16.616]         }
[11:02:16.616]         else {
[11:02:16.616]             ...future.result["stdout"] <- base::list(NULL)
[11:02:16.616]         }
[11:02:16.616]         base::close(...future.stdout)
[11:02:16.616]         ...future.stdout <- NULL
[11:02:16.616]     }
[11:02:16.616]     ...future.result$conditions <- ...future.conditions
[11:02:16.616]     ...future.result$finished <- base::Sys.time()
[11:02:16.616]     ...future.result
[11:02:16.616] }
[11:02:16.619] assign_globals() ...
[11:02:16.619] List of 2
[11:02:16.619]  $ nested   :List of 2
[11:02:16.619]   ..$ a:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[11:02:16.619]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[11:02:16.619]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[11:02:16.619]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[11:02:16.619]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[11:02:16.619]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[11:02:16.619]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[11:02:16.619]  $ strategy2: chr "multicore"
[11:02:16.619]  - attr(*, "where")=List of 2
[11:02:16.619]   ..$ nested   :<environment: R_EmptyEnv> 
[11:02:16.619]   ..$ strategy2:<environment: R_EmptyEnv> 
[11:02:16.619]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:02:16.619]  - attr(*, "resolved")= logi FALSE
[11:02:16.619]  - attr(*, "total_size")= num 12162
[11:02:16.619]  - attr(*, "already-done")= logi TRUE
[11:02:16.624] - copied ‘nested’ to environment
[11:02:16.624] - copied ‘strategy2’ to environment
[11:02:16.624] assign_globals() ... done
[11:02:16.624] requestCore(): workers = 2
[11:02:16.627] MulticoreFuture started
[11:02:16.627] - Launch lazy future ... done
[11:02:16.627] run() for ‘MulticoreFuture’ ... done
[11:02:16.627] result() for MulticoreFuture ...
[11:02:16.628] plan(): Setting new future strategy stack:
[11:02:16.628] List of future strategies:
[11:02:16.628] 1. multicore:
[11:02:16.628]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:16.628]    - tweaked: FALSE
[11:02:16.628]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:16.632] plan(): nbrOfWorkers() = 1
[11:02:16.672] plan(): Setting new future strategy stack:
[11:02:16.672] List of future strategies:
[11:02:16.672] 1. multicore:
[11:02:16.672]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:16.672]    - tweaked: FALSE
[11:02:16.672]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:16.672] 2. multicore:
[11:02:16.672]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:16.672]    - tweaked: FALSE
[11:02:16.672]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:16.674] plan(): nbrOfWorkers() = 2
[11:02:16.676] result() for MulticoreFuture ...
[11:02:16.676] result() for MulticoreFuture ... done
[11:02:16.676] signalConditions() ...
[11:02:16.676]  - include = ‘immediateCondition’
[11:02:16.676]  - exclude = 
[11:02:16.676]  - resignal = FALSE
[11:02:16.676]  - Number of conditions: 54
[11:02:16.676] signalConditions() ... done
[11:02:16.677] result() for MulticoreFuture ... done
[11:02:16.677] result() for MulticoreFuture ...
[11:02:16.677] result() for MulticoreFuture ... done
[11:02:16.677] signalConditions() ...
[11:02:16.677]  - include = ‘immediateCondition’
[11:02:16.677]  - exclude = 
[11:02:16.677]  - resignal = FALSE
[11:02:16.677]  - Number of conditions: 54
[11:02:16.677] signalConditions() ... done
[11:02:16.678] Future state: ‘finished’
[11:02:16.678] result() for MulticoreFuture ...
[11:02:16.678] result() for MulticoreFuture ... done
[11:02:16.678] signalConditions() ...
[11:02:16.678]  - include = ‘condition’
[11:02:16.678]  - exclude = ‘immediateCondition’
[11:02:16.678]  - resignal = TRUE
[11:02:16.678]  - Number of conditions: 54
[11:02:16.678]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.633] getGlobalsAndPackages() ...
[11:02:16.678]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.633] Searching for globals...
[11:02:16.679]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.646] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[11:02:16.679]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.646] Searching for globals ... DONE
[11:02:16.679]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.646] Resolving globals: FALSE
[11:02:16.679]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.647] The total size of the 3 globals is 12.54 KiB (12841 bytes)
[11:02:16.679]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.648] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 12.54 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (6.25 KiB of class ‘list’), ‘plan_a’ (6.25 KiB of class ‘list’) and ‘a’ (35 bytes of class ‘numeric’)
[11:02:16.679]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.648] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[11:02:16.680]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.648] 
[11:02:16.680]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.648] getGlobalsAndPackages() ... DONE
[11:02:16.680]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.649] run() for ‘Future’ ...
[11:02:16.680]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.649] - state: ‘created’
[11:02:16.680]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.650] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:02:16.680]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.652] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:16.680]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.652] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:16.681]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.652]   - Field: ‘label’
[11:02:16.681]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.652]   - Field: ‘local’
[11:02:16.681]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.653]   - Field: ‘owner’
[11:02:16.681]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.653]   - Field: ‘envir’
[11:02:16.681]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.653]   - Field: ‘packages’
[11:02:16.681]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.653]   - Field: ‘gc’
[11:02:16.681]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.653]   - Field: ‘conditions’
[11:02:16.682]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.653]   - Field: ‘expr’
[11:02:16.682]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.653]   - Field: ‘uuid’
[11:02:16.682]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.654]   - Field: ‘seed’
[11:02:16.682]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.654]   - Field: ‘version’
[11:02:16.682]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.654]   - Field: ‘result’
[11:02:16.682]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.654]   - Field: ‘asynchronous’
[11:02:16.682]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.654]   - Field: ‘calls’
[11:02:16.683]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.654]   - Field: ‘globals’
[11:02:16.686]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.654]   - Field: ‘stdout’
[11:02:16.686]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.655]   - Field: ‘earlySignal’
[11:02:16.686]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.655]   - Field: ‘lazy’
[11:02:16.686]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.655]   - Field: ‘state’
[11:02:16.686]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.655] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:16.686]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.655] - Launch lazy future ...
[11:02:16.687]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.656] Packages needed by the future expression (n = 0): <none>
[11:02:16.687]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.656] Packages needed by future strategies (n = 0): <none>
[11:02:16.687]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.657] {
[11:02:16.657]     {
[11:02:16.657]         {
[11:02:16.657]             ...future.startTime <- base::Sys.time()
[11:02:16.657]             {
[11:02:16.657]                 {
[11:02:16.657]                   {
[11:02:16.657]                     base::local({
[11:02:16.657]                       has_future <- base::requireNamespace("future", 
[11:02:16.657]                         quietly = TRUE)
[11:02:16.657]                       if (has_future) {
[11:02:16.657]                         ns <- base::getNamespace("future")
[11:02:16.657]                         version <- ns[[".package"]][["version"]]
[11:02:16.657]                         if (is.null(version)) 
[11:02:16.657]                           version <- utils::packageVersion("future")
[11:02:16.657]                       }
[11:02:16.657]                       else {
[11:02:16.657]                         version <- NULL
[11:02:16.657]                       }
[11:02:16.657]                       if (!has_future || version < "1.8.0") {
[11:02:16.657]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:16.657]                           "", base::R.version$version.string), 
[11:02:16.657]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:16.657]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:16.657]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:16.657]                             "release", "version")], collapse = " "), 
[11:02:16.657]                           hostname = base::Sys.info()[["nodename"]])
[11:02:16.657]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:16.657]                           info)
[11:02:16.657]                         info <- base::paste(info, collapse = "; ")
[11:02:16.657]                         if (!has_future) {
[11:02:16.657]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:16.657]                             info)
[11:02:16.657]                         }
[11:02:16.657]                         else {
[11:02:16.657]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:16.657]                             info, version)
[11:02:16.657]                         }
[11:02:16.657]                         base::stop(msg)
[11:02:16.657]                       }
[11:02:16.657]                     })
[11:02:16.657]                   }
[11:02:16.657]                   ...future.strategy.old <- future::plan("list")
[11:02:16.657]                   options(future.plan = NULL)
[11:02:16.657]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:16.657]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:16.657]                 }
[11:02:16.657]                 ...future.workdir <- getwd()
[11:02:16.657]             }
[11:02:16.657]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:16.657]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:16.657]         }
[11:02:16.657]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:16.657]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:16.657]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:16.657]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:16.657]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:16.657]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:16.657]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:16.657]             base::names(...future.oldOptions))
[11:02:16.657]     }
[11:02:16.657]     if (FALSE) {
[11:02:16.657]     }
[11:02:16.657]     else {
[11:02:16.657]         if (TRUE) {
[11:02:16.657]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:16.657]                 open = "w")
[11:02:16.657]         }
[11:02:16.657]         else {
[11:02:16.657]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:16.657]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:16.657]         }
[11:02:16.657]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:16.657]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:16.657]             base::sink(type = "output", split = FALSE)
[11:02:16.657]             base::close(...future.stdout)
[11:02:16.657]         }, add = TRUE)
[11:02:16.657]     }
[11:02:16.657]     ...future.frame <- base::sys.nframe()
[11:02:16.657]     ...future.conditions <- base::list()
[11:02:16.657]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:16.657]     if (FALSE) {
[11:02:16.657]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:16.657]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:16.657]     }
[11:02:16.657]     ...future.result <- base::tryCatch({
[11:02:16.657]         base::withCallingHandlers({
[11:02:16.657]             ...future.value <- base::withVisible(base::local({
[11:02:16.657]                 b <- 2L
[11:02:16.657]                 plan_b <- future::plan("list")
[11:02:16.657]                 nested_b <- nested_a[-1]
[11:02:16.657]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[11:02:16.657]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[11:02:16.657]                   "sequential"))
[11:02:16.657]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[11:02:16.657]                   b = b, nested_b = nested_b, plan_b = plan_b)
[11:02:16.657]             }))
[11:02:16.657]             future::FutureResult(value = ...future.value$value, 
[11:02:16.657]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:16.657]                   ...future.rng), globalenv = if (FALSE) 
[11:02:16.657]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:16.657]                     ...future.globalenv.names))
[11:02:16.657]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:16.657]         }, condition = base::local({
[11:02:16.657]             c <- base::c
[11:02:16.657]             inherits <- base::inherits
[11:02:16.657]             invokeRestart <- base::invokeRestart
[11:02:16.657]             length <- base::length
[11:02:16.657]             list <- base::list
[11:02:16.657]             seq.int <- base::seq.int
[11:02:16.657]             signalCondition <- base::signalCondition
[11:02:16.657]             sys.calls <- base::sys.calls
[11:02:16.657]             `[[` <- base::`[[`
[11:02:16.657]             `+` <- base::`+`
[11:02:16.657]             `<<-` <- base::`<<-`
[11:02:16.657]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:16.657]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:16.657]                   3L)]
[11:02:16.657]             }
[11:02:16.657]             function(cond) {
[11:02:16.657]                 is_error <- inherits(cond, "error")
[11:02:16.657]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:16.657]                   NULL)
[11:02:16.657]                 if (is_error) {
[11:02:16.657]                   sessionInformation <- function() {
[11:02:16.657]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:16.657]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:16.657]                       search = base::search(), system = base::Sys.info())
[11:02:16.657]                   }
[11:02:16.657]                   ...future.conditions[[length(...future.conditions) + 
[11:02:16.657]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:16.657]                     cond$call), session = sessionInformation(), 
[11:02:16.657]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:16.657]                   signalCondition(cond)
[11:02:16.657]                 }
[11:02:16.657]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:16.657]                 "immediateCondition"))) {
[11:02:16.657]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:16.657]                   ...future.conditions[[length(...future.conditions) + 
[11:02:16.657]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:16.657]                   if (TRUE && !signal) {
[11:02:16.657]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.657]                     {
[11:02:16.657]                       inherits <- base::inherits
[11:02:16.657]                       invokeRestart <- base::invokeRestart
[11:02:16.657]                       is.null <- base::is.null
[11:02:16.657]                       muffled <- FALSE
[11:02:16.657]                       if (inherits(cond, "message")) {
[11:02:16.657]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:16.657]                         if (muffled) 
[11:02:16.657]                           invokeRestart("muffleMessage")
[11:02:16.657]                       }
[11:02:16.657]                       else if (inherits(cond, "warning")) {
[11:02:16.657]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:16.657]                         if (muffled) 
[11:02:16.657]                           invokeRestart("muffleWarning")
[11:02:16.657]                       }
[11:02:16.657]                       else if (inherits(cond, "condition")) {
[11:02:16.657]                         if (!is.null(pattern)) {
[11:02:16.657]                           computeRestarts <- base::computeRestarts
[11:02:16.657]                           grepl <- base::grepl
[11:02:16.657]                           restarts <- computeRestarts(cond)
[11:02:16.657]                           for (restart in restarts) {
[11:02:16.657]                             name <- restart$name
[11:02:16.657]                             if (is.null(name)) 
[11:02:16.657]                               next
[11:02:16.657]                             if (!grepl(pattern, name)) 
[11:02:16.657]                               next
[11:02:16.657]                             invokeRestart(restart)
[11:02:16.657]                             muffled <- TRUE
[11:02:16.657]                             break
[11:02:16.657]                           }
[11:02:16.657]                         }
[11:02:16.657]                       }
[11:02:16.657]                       invisible(muffled)
[11:02:16.657]                     }
[11:02:16.657]                     muffleCondition(cond, pattern = "^muffle")
[11:02:16.657]                   }
[11:02:16.657]                 }
[11:02:16.657]                 else {
[11:02:16.657]                   if (TRUE) {
[11:02:16.657]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.657]                     {
[11:02:16.657]                       inherits <- base::inherits
[11:02:16.657]                       invokeRestart <- base::invokeRestart
[11:02:16.657]                       is.null <- base::is.null
[11:02:16.657]                       muffled <- FALSE
[11:02:16.657]                       if (inherits(cond, "message")) {
[11:02:16.657]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:16.657]                         if (muffled) 
[11:02:16.657]                           invokeRestart("muffleMessage")
[11:02:16.657]                       }
[11:02:16.657]                       else if (inherits(cond, "warning")) {
[11:02:16.657]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:16.657]                         if (muffled) 
[11:02:16.657]                           invokeRestart("muffleWarning")
[11:02:16.657]                       }
[11:02:16.657]                       else if (inherits(cond, "condition")) {
[11:02:16.657]                         if (!is.null(pattern)) {
[11:02:16.657]                           computeRestarts <- base::computeRestarts
[11:02:16.657]                           grepl <- base::grepl
[11:02:16.657]                           restarts <- computeRestarts(cond)
[11:02:16.657]                           for (restart in restarts) {
[11:02:16.657]                             name <- restart$name
[11:02:16.657]                             if (is.null(name)) 
[11:02:16.657]                               next
[11:02:16.657]                             if (!grepl(pattern, name)) 
[11:02:16.657]                               next
[11:02:16.657]                             invokeRestart(restart)
[11:02:16.657]                             muffled <- TRUE
[11:02:16.657]                             break
[11:02:16.657]                           }
[11:02:16.657]                         }
[11:02:16.657]                       }
[11:02:16.657]                       invisible(muffled)
[11:02:16.657]                     }
[11:02:16.657]                     muffleCondition(cond, pattern = "^muffle")
[11:02:16.657]                   }
[11:02:16.657]                 }
[11:02:16.657]             }
[11:02:16.657]         }))
[11:02:16.657]     }, error = function(ex) {
[11:02:16.657]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:16.657]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:16.657]                 ...future.rng), started = ...future.startTime, 
[11:02:16.657]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:16.657]             version = "1.8"), class = "FutureResult")
[11:02:16.657]     }, finally = {
[11:02:16.657]         if (!identical(...future.workdir, getwd())) 
[11:02:16.657]             setwd(...future.workdir)
[11:02:16.657]         {
[11:02:16.657]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:16.657]                 ...future.oldOptions$nwarnings <- NULL
[11:02:16.657]             }
[11:02:16.657]             base::options(...future.oldOptions)
[11:02:16.657]             if (.Platform$OS.type == "windows") {
[11:02:16.657]                 old_names <- names(...future.oldEnvVars)
[11:02:16.657]                 envs <- base::Sys.getenv()
[11:02:16.657]                 names <- names(envs)
[11:02:16.657]                 common <- intersect(names, old_names)
[11:02:16.657]                 added <- setdiff(names, old_names)
[11:02:16.657]                 removed <- setdiff(old_names, names)
[11:02:16.657]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:16.657]                   envs[common]]
[11:02:16.657]                 NAMES <- toupper(changed)
[11:02:16.657]                 args <- list()
[11:02:16.657]                 for (kk in seq_along(NAMES)) {
[11:02:16.657]                   name <- changed[[kk]]
[11:02:16.657]                   NAME <- NAMES[[kk]]
[11:02:16.657]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.657]                     next
[11:02:16.657]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:16.657]                 }
[11:02:16.657]                 NAMES <- toupper(added)
[11:02:16.657]                 for (kk in seq_along(NAMES)) {
[11:02:16.657]                   name <- added[[kk]]
[11:02:16.657]                   NAME <- NAMES[[kk]]
[11:02:16.657]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.657]                     next
[11:02:16.657]                   args[[name]] <- ""
[11:02:16.657]                 }
[11:02:16.657]                 NAMES <- toupper(removed)
[11:02:16.657]                 for (kk in seq_along(NAMES)) {
[11:02:16.657]                   name <- removed[[kk]]
[11:02:16.657]                   NAME <- NAMES[[kk]]
[11:02:16.657]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.657]                     next
[11:02:16.657]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:16.657]                 }
[11:02:16.657]                 if (length(args) > 0) 
[11:02:16.657]                   base::do.call(base::Sys.setenv, args = args)
[11:02:16.657]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:16.657]             }
[11:02:16.657]             else {
[11:02:16.657]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:16.657]             }
[11:02:16.657]             {
[11:02:16.657]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:16.657]                   0L) {
[11:02:16.657]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:16.657]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:16.657]                   base::options(opts)
[11:02:16.657]                 }
[11:02:16.657]                 {
[11:02:16.657]                   {
[11:02:16.657]                     NULL
[11:02:16.657]                     RNGkind("Mersenne-Twister")
[11:02:16.657]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:16.657]                       inherits = FALSE)
[11:02:16.657]                   }
[11:02:16.657]                   options(future.plan = NULL)
[11:02:16.657]                   if (is.na(NA_character_)) 
[11:02:16.657]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:16.657]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:16.657]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:16.657]                     .init = FALSE)
[11:02:16.657]                 }
[11:02:16.657]             }
[11:02:16.657]         }
[11:02:16.657]     })
[11:02:16.657]     if (TRUE) {
[11:02:16.657]         base::sink(type = "output", split = FALSE)
[11:02:16.657]         if (TRUE) {
[11:02:16.657]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:16.657]         }
[11:02:16.657]         else {
[11:02:16.657]             ...future.result["stdout"] <- base::list(NULL)
[11:02:16.657]         }
[11:02:16.657]         base::close(...future.stdout)
[11:02:16.657]         ...future.stdout <- NULL
[11:02:16.657]     }
[11:02:16.657]     ...future.result$conditions <- ...future.conditions
[11:02:16.657]     ...future.result$finished <- base::Sys.time()
[11:02:16.657]     ...future.result
[11:02:16.657] }
[11:02:16.687]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.658] assign_globals() ...
[11:02:16.687]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.658] List of 3
[11:02:16.658]  $ nested_a:List of 1
[11:02:16.658]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[11:02:16.658]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[11:02:16.658]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[11:02:16.658]  $ a       : int 1
[11:02:16.658]  $ plan_a  :List of 1
[11:02:16.658]   ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[11:02:16.658]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[11:02:16.658]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[11:02:16.658]  - attr(*, "where")=List of 3
[11:02:16.658]   ..$ nested_a:<environment: R_EmptyEnv> 
[11:02:16.658]   ..$ a       :<environment: R_EmptyEnv> 
[11:02:16.658]   ..$ plan_a  :<environment: R_EmptyEnv> 
[11:02:16.658]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:02:16.658]  - attr(*, "resolved")= logi FALSE
[11:02:16.658]  - attr(*, "total_size")= num 12841
[11:02:16.658]  - attr(*, "already-done")= logi TRUE
[11:02:16.688]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.666] - copied ‘nested_a’ to environment
[11:02:16.688]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.666] - copied ‘a’ to environment
[11:02:16.688]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.666] - copied ‘plan_a’ to environment
[11:02:16.688]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.666] assign_globals() ... done
[11:02:16.688]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.666] plan(): Setting new future strategy stack:
[11:02:16.688]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.667] List of future strategies:
[11:02:16.667] 1. sequential:
[11:02:16.667]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:16.667]    - tweaked: FALSE
[11:02:16.667]    - call: NULL
[11:02:16.688]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.667] plan(): nbrOfWorkers() = 1
[11:02:16.689]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.668] plan(): Setting new future strategy stack:
[11:02:16.689]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.668] List of future strategies:
[11:02:16.668] 1. multicore:
[11:02:16.668]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:16.668]    - tweaked: FALSE
[11:02:16.668]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:16.689]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.671] plan(): nbrOfWorkers() = 1
[11:02:16.689]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.671] SequentialFuture started (and completed)
[11:02:16.689]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.671] - Launch lazy future ... done
[11:02:16.689]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.671] run() for ‘SequentialFuture’ ... done
[11:02:16.689] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[11:02:16.695] getGlobalsAndPackages() ...
[11:02:16.695] Searching for globals...
[11:02:16.697] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[11:02:16.697] Searching for globals ... DONE
[11:02:16.697] Resolving globals: FALSE
[11:02:16.698] The total size of the 1 globals is 356 bytes (356 bytes)
[11:02:16.698] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[11:02:16.698] - globals: [1] ‘data’
[11:02:16.699] - packages: [1] ‘future’
[11:02:16.699] getGlobalsAndPackages() ... DONE
[11:02:16.699] run() for ‘Future’ ...
[11:02:16.699] - state: ‘created’
[11:02:16.699] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:02:16.701] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:16.701] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:02:16.701]   - Field: ‘label’
[11:02:16.702]   - Field: ‘local’
[11:02:16.702]   - Field: ‘owner’
[11:02:16.702]   - Field: ‘envir’
[11:02:16.702]   - Field: ‘workers’
[11:02:16.702]   - Field: ‘packages’
[11:02:16.702]   - Field: ‘gc’
[11:02:16.702]   - Field: ‘job’
[11:02:16.702]   - Field: ‘conditions’
[11:02:16.702]   - Field: ‘expr’
[11:02:16.702]   - Field: ‘uuid’
[11:02:16.703]   - Field: ‘seed’
[11:02:16.703]   - Field: ‘version’
[11:02:16.703]   - Field: ‘result’
[11:02:16.703]   - Field: ‘asynchronous’
[11:02:16.703]   - Field: ‘calls’
[11:02:16.703]   - Field: ‘globals’
[11:02:16.703]   - Field: ‘stdout’
[11:02:16.703]   - Field: ‘earlySignal’
[11:02:16.703]   - Field: ‘lazy’
[11:02:16.704]   - Field: ‘state’
[11:02:16.704] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:02:16.704] - Launch lazy future ...
[11:02:16.704] Packages needed by the future expression (n = 1): ‘future’
[11:02:16.704] Packages needed by future strategies (n = 1): ‘future’
[11:02:16.705] {
[11:02:16.705]     {
[11:02:16.705]         {
[11:02:16.705]             ...future.startTime <- base::Sys.time()
[11:02:16.705]             {
[11:02:16.705]                 {
[11:02:16.705]                   {
[11:02:16.705]                     {
[11:02:16.705]                       {
[11:02:16.705]                         base::local({
[11:02:16.705]                           has_future <- base::requireNamespace("future", 
[11:02:16.705]                             quietly = TRUE)
[11:02:16.705]                           if (has_future) {
[11:02:16.705]                             ns <- base::getNamespace("future")
[11:02:16.705]                             version <- ns[[".package"]][["version"]]
[11:02:16.705]                             if (is.null(version)) 
[11:02:16.705]                               version <- utils::packageVersion("future")
[11:02:16.705]                           }
[11:02:16.705]                           else {
[11:02:16.705]                             version <- NULL
[11:02:16.705]                           }
[11:02:16.705]                           if (!has_future || version < "1.8.0") {
[11:02:16.705]                             info <- base::c(r_version = base::gsub("R version ", 
[11:02:16.705]                               "", base::R.version$version.string), 
[11:02:16.705]                               platform = base::sprintf("%s (%s-bit)", 
[11:02:16.705]                                 base::R.version$platform, 8 * 
[11:02:16.705]                                   base::.Machine$sizeof.pointer), 
[11:02:16.705]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:16.705]                                 "release", "version")], collapse = " "), 
[11:02:16.705]                               hostname = base::Sys.info()[["nodename"]])
[11:02:16.705]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:02:16.705]                               info)
[11:02:16.705]                             info <- base::paste(info, collapse = "; ")
[11:02:16.705]                             if (!has_future) {
[11:02:16.705]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:16.705]                                 info)
[11:02:16.705]                             }
[11:02:16.705]                             else {
[11:02:16.705]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:16.705]                                 info, version)
[11:02:16.705]                             }
[11:02:16.705]                             base::stop(msg)
[11:02:16.705]                           }
[11:02:16.705]                         })
[11:02:16.705]                       }
[11:02:16.705]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:16.705]                       base::options(mc.cores = 1L)
[11:02:16.705]                     }
[11:02:16.705]                     base::local({
[11:02:16.705]                       for (pkg in "future") {
[11:02:16.705]                         base::loadNamespace(pkg)
[11:02:16.705]                         base::library(pkg, character.only = TRUE)
[11:02:16.705]                       }
[11:02:16.705]                     })
[11:02:16.705]                   }
[11:02:16.705]                   ...future.strategy.old <- future::plan("list")
[11:02:16.705]                   options(future.plan = NULL)
[11:02:16.705]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:16.705]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[11:02:16.705]                     envir = parent.frame()) 
[11:02:16.705]                   {
[11:02:16.705]                     default_workers <- missing(workers)
[11:02:16.705]                     if (is.function(workers)) 
[11:02:16.705]                       workers <- workers()
[11:02:16.705]                     workers <- structure(as.integer(workers), 
[11:02:16.705]                       class = class(workers))
[11:02:16.705]                     stop_if_not(is.finite(workers), workers >= 
[11:02:16.705]                       1L)
[11:02:16.705]                     if ((workers == 1L && !inherits(workers, 
[11:02:16.705]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[11:02:16.705]                       if (default_workers) 
[11:02:16.705]                         supportsMulticore(warn = TRUE)
[11:02:16.705]                       return(sequential(..., envir = envir))
[11:02:16.705]                     }
[11:02:16.705]                     oopts <- options(mc.cores = workers)
[11:02:16.705]                     on.exit(options(oopts))
[11:02:16.705]                     future <- MulticoreFuture(..., workers = workers, 
[11:02:16.705]                       envir = envir)
[11:02:16.705]                     if (!future$lazy) 
[11:02:16.705]                       future <- run(future)
[11:02:16.705]                     invisible(future)
[11:02:16.705]                   }), .cleanup = FALSE, .init = FALSE)
[11:02:16.705]                 }
[11:02:16.705]                 ...future.workdir <- getwd()
[11:02:16.705]             }
[11:02:16.705]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:16.705]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:16.705]         }
[11:02:16.705]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:16.705]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:16.705]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:16.705]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:16.705]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:16.705]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:16.705]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:16.705]             base::names(...future.oldOptions))
[11:02:16.705]     }
[11:02:16.705]     if (FALSE) {
[11:02:16.705]     }
[11:02:16.705]     else {
[11:02:16.705]         if (TRUE) {
[11:02:16.705]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:16.705]                 open = "w")
[11:02:16.705]         }
[11:02:16.705]         else {
[11:02:16.705]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:16.705]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:16.705]         }
[11:02:16.705]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:16.705]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:16.705]             base::sink(type = "output", split = FALSE)
[11:02:16.705]             base::close(...future.stdout)
[11:02:16.705]         }, add = TRUE)
[11:02:16.705]     }
[11:02:16.705]     ...future.frame <- base::sys.nframe()
[11:02:16.705]     ...future.conditions <- base::list()
[11:02:16.705]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:16.705]     if (FALSE) {
[11:02:16.705]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:16.705]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:16.705]     }
[11:02:16.705]     ...future.result <- base::tryCatch({
[11:02:16.705]         base::withCallingHandlers({
[11:02:16.705]             ...future.value <- base::withVisible(base::local({
[11:02:16.705]                 withCallingHandlers({
[11:02:16.705]                   {
[11:02:16.705]                     value(future(subset(data, a == 2)))
[11:02:16.705]                   }
[11:02:16.705]                 }, immediateCondition = function(cond) {
[11:02:16.705]                   save_rds <- function (object, pathname, ...) 
[11:02:16.705]                   {
[11:02:16.705]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:02:16.705]                     if (file_test("-f", pathname_tmp)) {
[11:02:16.705]                       fi_tmp <- file.info(pathname_tmp)
[11:02:16.705]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:02:16.705]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:16.705]                         fi_tmp[["mtime"]])
[11:02:16.705]                     }
[11:02:16.705]                     tryCatch({
[11:02:16.705]                       saveRDS(object, file = pathname_tmp, ...)
[11:02:16.705]                     }, error = function(ex) {
[11:02:16.705]                       msg <- conditionMessage(ex)
[11:02:16.705]                       fi_tmp <- file.info(pathname_tmp)
[11:02:16.705]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:02:16.705]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:16.705]                         fi_tmp[["mtime"]], msg)
[11:02:16.705]                       ex$message <- msg
[11:02:16.705]                       stop(ex)
[11:02:16.705]                     })
[11:02:16.705]                     stopifnot(file_test("-f", pathname_tmp))
[11:02:16.705]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:02:16.705]                     if (!res || file_test("-f", pathname_tmp)) {
[11:02:16.705]                       fi_tmp <- file.info(pathname_tmp)
[11:02:16.705]                       fi <- file.info(pathname)
[11:02:16.705]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:02:16.705]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:16.705]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:02:16.705]                         fi[["size"]], fi[["mtime"]])
[11:02:16.705]                       stop(msg)
[11:02:16.705]                     }
[11:02:16.705]                     invisible(pathname)
[11:02:16.705]                   }
[11:02:16.705]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:02:16.705]                     rootPath = tempdir()) 
[11:02:16.705]                   {
[11:02:16.705]                     obj <- list(time = Sys.time(), condition = cond)
[11:02:16.705]                     file <- tempfile(pattern = class(cond)[1], 
[11:02:16.705]                       tmpdir = path, fileext = ".rds")
[11:02:16.705]                     save_rds(obj, file)
[11:02:16.705]                   }
[11:02:16.705]                   saveImmediateCondition(cond, path = "/tmp/RtmpVZPEla/.future/immediateConditions")
[11:02:16.705]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.705]                   {
[11:02:16.705]                     inherits <- base::inherits
[11:02:16.705]                     invokeRestart <- base::invokeRestart
[11:02:16.705]                     is.null <- base::is.null
[11:02:16.705]                     muffled <- FALSE
[11:02:16.705]                     if (inherits(cond, "message")) {
[11:02:16.705]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:16.705]                       if (muffled) 
[11:02:16.705]                         invokeRestart("muffleMessage")
[11:02:16.705]                     }
[11:02:16.705]                     else if (inherits(cond, "warning")) {
[11:02:16.705]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:16.705]                       if (muffled) 
[11:02:16.705]                         invokeRestart("muffleWarning")
[11:02:16.705]                     }
[11:02:16.705]                     else if (inherits(cond, "condition")) {
[11:02:16.705]                       if (!is.null(pattern)) {
[11:02:16.705]                         computeRestarts <- base::computeRestarts
[11:02:16.705]                         grepl <- base::grepl
[11:02:16.705]                         restarts <- computeRestarts(cond)
[11:02:16.705]                         for (restart in restarts) {
[11:02:16.705]                           name <- restart$name
[11:02:16.705]                           if (is.null(name)) 
[11:02:16.705]                             next
[11:02:16.705]                           if (!grepl(pattern, name)) 
[11:02:16.705]                             next
[11:02:16.705]                           invokeRestart(restart)
[11:02:16.705]                           muffled <- TRUE
[11:02:16.705]                           break
[11:02:16.705]                         }
[11:02:16.705]                       }
[11:02:16.705]                     }
[11:02:16.705]                     invisible(muffled)
[11:02:16.705]                   }
[11:02:16.705]                   muffleCondition(cond)
[11:02:16.705]                 })
[11:02:16.705]             }))
[11:02:16.705]             future::FutureResult(value = ...future.value$value, 
[11:02:16.705]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:16.705]                   ...future.rng), globalenv = if (FALSE) 
[11:02:16.705]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:16.705]                     ...future.globalenv.names))
[11:02:16.705]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:16.705]         }, condition = base::local({
[11:02:16.705]             c <- base::c
[11:02:16.705]             inherits <- base::inherits
[11:02:16.705]             invokeRestart <- base::invokeRestart
[11:02:16.705]             length <- base::length
[11:02:16.705]             list <- base::list
[11:02:16.705]             seq.int <- base::seq.int
[11:02:16.705]             signalCondition <- base::signalCondition
[11:02:16.705]             sys.calls <- base::sys.calls
[11:02:16.705]             `[[` <- base::`[[`
[11:02:16.705]             `+` <- base::`+`
[11:02:16.705]             `<<-` <- base::`<<-`
[11:02:16.705]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:16.705]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:16.705]                   3L)]
[11:02:16.705]             }
[11:02:16.705]             function(cond) {
[11:02:16.705]                 is_error <- inherits(cond, "error")
[11:02:16.705]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:16.705]                   NULL)
[11:02:16.705]                 if (is_error) {
[11:02:16.705]                   sessionInformation <- function() {
[11:02:16.705]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:16.705]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:16.705]                       search = base::search(), system = base::Sys.info())
[11:02:16.705]                   }
[11:02:16.705]                   ...future.conditions[[length(...future.conditions) + 
[11:02:16.705]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:16.705]                     cond$call), session = sessionInformation(), 
[11:02:16.705]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:16.705]                   signalCondition(cond)
[11:02:16.705]                 }
[11:02:16.705]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:16.705]                 "immediateCondition"))) {
[11:02:16.705]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:16.705]                   ...future.conditions[[length(...future.conditions) + 
[11:02:16.705]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:16.705]                   if (TRUE && !signal) {
[11:02:16.705]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.705]                     {
[11:02:16.705]                       inherits <- base::inherits
[11:02:16.705]                       invokeRestart <- base::invokeRestart
[11:02:16.705]                       is.null <- base::is.null
[11:02:16.705]                       muffled <- FALSE
[11:02:16.705]                       if (inherits(cond, "message")) {
[11:02:16.705]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:16.705]                         if (muffled) 
[11:02:16.705]                           invokeRestart("muffleMessage")
[11:02:16.705]                       }
[11:02:16.705]                       else if (inherits(cond, "warning")) {
[11:02:16.705]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:16.705]                         if (muffled) 
[11:02:16.705]                           invokeRestart("muffleWarning")
[11:02:16.705]                       }
[11:02:16.705]                       else if (inherits(cond, "condition")) {
[11:02:16.705]                         if (!is.null(pattern)) {
[11:02:16.705]                           computeRestarts <- base::computeRestarts
[11:02:16.705]                           grepl <- base::grepl
[11:02:16.705]                           restarts <- computeRestarts(cond)
[11:02:16.705]                           for (restart in restarts) {
[11:02:16.705]                             name <- restart$name
[11:02:16.705]                             if (is.null(name)) 
[11:02:16.705]                               next
[11:02:16.705]                             if (!grepl(pattern, name)) 
[11:02:16.705]                               next
[11:02:16.705]                             invokeRestart(restart)
[11:02:16.705]                             muffled <- TRUE
[11:02:16.705]                             break
[11:02:16.705]                           }
[11:02:16.705]                         }
[11:02:16.705]                       }
[11:02:16.705]                       invisible(muffled)
[11:02:16.705]                     }
[11:02:16.705]                     muffleCondition(cond, pattern = "^muffle")
[11:02:16.705]                   }
[11:02:16.705]                 }
[11:02:16.705]                 else {
[11:02:16.705]                   if (TRUE) {
[11:02:16.705]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.705]                     {
[11:02:16.705]                       inherits <- base::inherits
[11:02:16.705]                       invokeRestart <- base::invokeRestart
[11:02:16.705]                       is.null <- base::is.null
[11:02:16.705]                       muffled <- FALSE
[11:02:16.705]                       if (inherits(cond, "message")) {
[11:02:16.705]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:16.705]                         if (muffled) 
[11:02:16.705]                           invokeRestart("muffleMessage")
[11:02:16.705]                       }
[11:02:16.705]                       else if (inherits(cond, "warning")) {
[11:02:16.705]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:16.705]                         if (muffled) 
[11:02:16.705]                           invokeRestart("muffleWarning")
[11:02:16.705]                       }
[11:02:16.705]                       else if (inherits(cond, "condition")) {
[11:02:16.705]                         if (!is.null(pattern)) {
[11:02:16.705]                           computeRestarts <- base::computeRestarts
[11:02:16.705]                           grepl <- base::grepl
[11:02:16.705]                           restarts <- computeRestarts(cond)
[11:02:16.705]                           for (restart in restarts) {
[11:02:16.705]                             name <- restart$name
[11:02:16.705]                             if (is.null(name)) 
[11:02:16.705]                               next
[11:02:16.705]                             if (!grepl(pattern, name)) 
[11:02:16.705]                               next
[11:02:16.705]                             invokeRestart(restart)
[11:02:16.705]                             muffled <- TRUE
[11:02:16.705]                             break
[11:02:16.705]                           }
[11:02:16.705]                         }
[11:02:16.705]                       }
[11:02:16.705]                       invisible(muffled)
[11:02:16.705]                     }
[11:02:16.705]                     muffleCondition(cond, pattern = "^muffle")
[11:02:16.705]                   }
[11:02:16.705]                 }
[11:02:16.705]             }
[11:02:16.705]         }))
[11:02:16.705]     }, error = function(ex) {
[11:02:16.705]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:16.705]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:16.705]                 ...future.rng), started = ...future.startTime, 
[11:02:16.705]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:16.705]             version = "1.8"), class = "FutureResult")
[11:02:16.705]     }, finally = {
[11:02:16.705]         if (!identical(...future.workdir, getwd())) 
[11:02:16.705]             setwd(...future.workdir)
[11:02:16.705]         {
[11:02:16.705]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:16.705]                 ...future.oldOptions$nwarnings <- NULL
[11:02:16.705]             }
[11:02:16.705]             base::options(...future.oldOptions)
[11:02:16.705]             if (.Platform$OS.type == "windows") {
[11:02:16.705]                 old_names <- names(...future.oldEnvVars)
[11:02:16.705]                 envs <- base::Sys.getenv()
[11:02:16.705]                 names <- names(envs)
[11:02:16.705]                 common <- intersect(names, old_names)
[11:02:16.705]                 added <- setdiff(names, old_names)
[11:02:16.705]                 removed <- setdiff(old_names, names)
[11:02:16.705]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:16.705]                   envs[common]]
[11:02:16.705]                 NAMES <- toupper(changed)
[11:02:16.705]                 args <- list()
[11:02:16.705]                 for (kk in seq_along(NAMES)) {
[11:02:16.705]                   name <- changed[[kk]]
[11:02:16.705]                   NAME <- NAMES[[kk]]
[11:02:16.705]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.705]                     next
[11:02:16.705]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:16.705]                 }
[11:02:16.705]                 NAMES <- toupper(added)
[11:02:16.705]                 for (kk in seq_along(NAMES)) {
[11:02:16.705]                   name <- added[[kk]]
[11:02:16.705]                   NAME <- NAMES[[kk]]
[11:02:16.705]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.705]                     next
[11:02:16.705]                   args[[name]] <- ""
[11:02:16.705]                 }
[11:02:16.705]                 NAMES <- toupper(removed)
[11:02:16.705]                 for (kk in seq_along(NAMES)) {
[11:02:16.705]                   name <- removed[[kk]]
[11:02:16.705]                   NAME <- NAMES[[kk]]
[11:02:16.705]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.705]                     next
[11:02:16.705]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:16.705]                 }
[11:02:16.705]                 if (length(args) > 0) 
[11:02:16.705]                   base::do.call(base::Sys.setenv, args = args)
[11:02:16.705]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:16.705]             }
[11:02:16.705]             else {
[11:02:16.705]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:16.705]             }
[11:02:16.705]             {
[11:02:16.705]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:16.705]                   0L) {
[11:02:16.705]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:16.705]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:16.705]                   base::options(opts)
[11:02:16.705]                 }
[11:02:16.705]                 {
[11:02:16.705]                   {
[11:02:16.705]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:16.705]                     NULL
[11:02:16.705]                   }
[11:02:16.705]                   options(future.plan = NULL)
[11:02:16.705]                   if (is.na(NA_character_)) 
[11:02:16.705]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:16.705]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:16.705]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:16.705]                     .init = FALSE)
[11:02:16.705]                 }
[11:02:16.705]             }
[11:02:16.705]         }
[11:02:16.705]     })
[11:02:16.705]     if (TRUE) {
[11:02:16.705]         base::sink(type = "output", split = FALSE)
[11:02:16.705]         if (TRUE) {
[11:02:16.705]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:16.705]         }
[11:02:16.705]         else {
[11:02:16.705]             ...future.result["stdout"] <- base::list(NULL)
[11:02:16.705]         }
[11:02:16.705]         base::close(...future.stdout)
[11:02:16.705]         ...future.stdout <- NULL
[11:02:16.705]     }
[11:02:16.705]     ...future.result$conditions <- ...future.conditions
[11:02:16.705]     ...future.result$finished <- base::Sys.time()
[11:02:16.705]     ...future.result
[11:02:16.705] }
[11:02:16.707] assign_globals() ...
[11:02:16.707] List of 1
[11:02:16.707]  $ data:'data.frame':	3 obs. of  2 variables:
[11:02:16.707]   ..$ a: int [1:3] 1 2 3
[11:02:16.707]   ..$ b: int [1:3] 3 2 1
[11:02:16.707]  - attr(*, "where")=List of 1
[11:02:16.707]   ..$ data:<environment: R_EmptyEnv> 
[11:02:16.707]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:02:16.707]  - attr(*, "resolved")= logi FALSE
[11:02:16.707]  - attr(*, "total_size")= num 356
[11:02:16.707]  - attr(*, "already-done")= logi TRUE
[11:02:16.711] - copied ‘data’ to environment
[11:02:16.711] assign_globals() ... done
[11:02:16.711] requestCore(): workers = 2
[11:02:16.714] MulticoreFuture started
[11:02:16.714] - Launch lazy future ... done
[11:02:16.714] run() for ‘MulticoreFuture’ ... done
[11:02:16.714] result() for MulticoreFuture ...
[11:02:16.715] plan(): Setting new future strategy stack:
[11:02:16.715] List of future strategies:
[11:02:16.715] 1. multicore:
[11:02:16.715]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:16.715]    - tweaked: FALSE
[11:02:16.715]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:16.719] plan(): nbrOfWorkers() = 1
[11:02:16.748] plan(): Setting new future strategy stack:
[11:02:16.748] List of future strategies:
[11:02:16.748] 1. multicore:
[11:02:16.748]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:16.748]    - tweaked: FALSE
[11:02:16.748]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:16.748] 2. multicore:
[11:02:16.748]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:16.748]    - tweaked: FALSE
[11:02:16.748]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:16.750] plan(): nbrOfWorkers() = 2
[11:02:16.751] result() for MulticoreFuture ...
[11:02:16.752] result() for MulticoreFuture ... done
[11:02:16.752] signalConditions() ...
[11:02:16.752]  - include = ‘immediateCondition’
[11:02:16.752]  - exclude = 
[11:02:16.752]  - resignal = FALSE
[11:02:16.752]  - Number of conditions: 52
[11:02:16.752] signalConditions() ... done
[11:02:16.753] result() for MulticoreFuture ... done
[11:02:16.753] result() for MulticoreFuture ...
[11:02:16.753] result() for MulticoreFuture ... done
[11:02:16.753] signalConditions() ...
[11:02:16.753]  - include = ‘immediateCondition’
[11:02:16.753]  - exclude = 
[11:02:16.753]  - resignal = FALSE
[11:02:16.753]  - Number of conditions: 52
[11:02:16.754] signalConditions() ... done
[11:02:16.754] Future state: ‘finished’
[11:02:16.754] result() for MulticoreFuture ...
[11:02:16.754] result() for MulticoreFuture ... done
[11:02:16.754] signalConditions() ...
[11:02:16.754]  - include = ‘condition’
[11:02:16.754]  - exclude = ‘immediateCondition’
[11:02:16.754]  - resignal = TRUE
[11:02:16.755]  - Number of conditions: 52
[11:02:16.755]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.720] getGlobalsAndPackages() ...
[11:02:16.755]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.720] Searching for globals...
[11:02:16.755]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.722] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[11:02:16.755]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.722] Searching for globals ... DONE
[11:02:16.755]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.723] Resolving globals: FALSE
[11:02:16.756]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.723] The total size of the 1 globals is 356 bytes (356 bytes)
[11:02:16.756]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.724] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[11:02:16.756]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.724] - globals: [1] ‘data’
[11:02:16.756]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.725] 
[11:02:16.756]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.725] getGlobalsAndPackages() ... DONE
[11:02:16.756]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.726] run() for ‘Future’ ...
[11:02:16.757]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.726] - state: ‘created’
[11:02:16.757]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.726] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:02:16.757]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.729] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:16.757]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.730] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:16.757]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.730]   - Field: ‘label’
[11:02:16.757]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.730]   - Field: ‘local’
[11:02:16.758]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.730]   - Field: ‘owner’
[11:02:16.758]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.731]   - Field: ‘envir’
[11:02:16.758]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.731]   - Field: ‘packages’
[11:02:16.758]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.731]   - Field: ‘gc’
[11:02:16.758]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.731]   - Field: ‘conditions’
[11:02:16.758]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.732]   - Field: ‘expr’
[11:02:16.758]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.732]   - Field: ‘uuid’
[11:02:16.759]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.732]   - Field: ‘seed’
[11:02:16.759]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.732]   - Field: ‘version’
[11:02:16.759]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.733]   - Field: ‘result’
[11:02:16.759]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.733]   - Field: ‘asynchronous’
[11:02:16.759]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.733]   - Field: ‘calls’
[11:02:16.759]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.733]   - Field: ‘globals’
[11:02:16.759]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.734]   - Field: ‘stdout’
[11:02:16.760]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.734]   - Field: ‘earlySignal’
[11:02:16.760]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.734]   - Field: ‘lazy’
[11:02:16.760]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.734]   - Field: ‘state’
[11:02:16.760]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.734] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:16.760]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.734] - Launch lazy future ...
[11:02:16.760]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.735] Packages needed by the future expression (n = 0): <none>
[11:02:16.761]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.735] Packages needed by future strategies (n = 0): <none>
[11:02:16.761]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.736] {
[11:02:16.736]     {
[11:02:16.736]         {
[11:02:16.736]             ...future.startTime <- base::Sys.time()
[11:02:16.736]             {
[11:02:16.736]                 {
[11:02:16.736]                   {
[11:02:16.736]                     base::local({
[11:02:16.736]                       has_future <- base::requireNamespace("future", 
[11:02:16.736]                         quietly = TRUE)
[11:02:16.736]                       if (has_future) {
[11:02:16.736]                         ns <- base::getNamespace("future")
[11:02:16.736]                         version <- ns[[".package"]][["version"]]
[11:02:16.736]                         if (is.null(version)) 
[11:02:16.736]                           version <- utils::packageVersion("future")
[11:02:16.736]                       }
[11:02:16.736]                       else {
[11:02:16.736]                         version <- NULL
[11:02:16.736]                       }
[11:02:16.736]                       if (!has_future || version < "1.8.0") {
[11:02:16.736]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:16.736]                           "", base::R.version$version.string), 
[11:02:16.736]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:16.736]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:16.736]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:16.736]                             "release", "version")], collapse = " "), 
[11:02:16.736]                           hostname = base::Sys.info()[["nodename"]])
[11:02:16.736]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:16.736]                           info)
[11:02:16.736]                         info <- base::paste(info, collapse = "; ")
[11:02:16.736]                         if (!has_future) {
[11:02:16.736]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:16.736]                             info)
[11:02:16.736]                         }
[11:02:16.736]                         else {
[11:02:16.736]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:16.736]                             info, version)
[11:02:16.736]                         }
[11:02:16.736]                         base::stop(msg)
[11:02:16.736]                       }
[11:02:16.736]                     })
[11:02:16.736]                   }
[11:02:16.736]                   ...future.strategy.old <- future::plan("list")
[11:02:16.736]                   options(future.plan = NULL)
[11:02:16.736]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:16.736]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:16.736]                 }
[11:02:16.736]                 ...future.workdir <- getwd()
[11:02:16.736]             }
[11:02:16.736]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:16.736]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:16.736]         }
[11:02:16.736]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:16.736]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:16.736]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:16.736]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:16.736]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:16.736]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:16.736]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:16.736]             base::names(...future.oldOptions))
[11:02:16.736]     }
[11:02:16.736]     if (FALSE) {
[11:02:16.736]     }
[11:02:16.736]     else {
[11:02:16.736]         if (TRUE) {
[11:02:16.736]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:16.736]                 open = "w")
[11:02:16.736]         }
[11:02:16.736]         else {
[11:02:16.736]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:16.736]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:16.736]         }
[11:02:16.736]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:16.736]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:16.736]             base::sink(type = "output", split = FALSE)
[11:02:16.736]             base::close(...future.stdout)
[11:02:16.736]         }, add = TRUE)
[11:02:16.736]     }
[11:02:16.736]     ...future.frame <- base::sys.nframe()
[11:02:16.736]     ...future.conditions <- base::list()
[11:02:16.736]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:16.736]     if (FALSE) {
[11:02:16.736]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:16.736]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:16.736]     }
[11:02:16.736]     ...future.result <- base::tryCatch({
[11:02:16.736]         base::withCallingHandlers({
[11:02:16.736]             ...future.value <- base::withVisible(base::local(subset(data, 
[11:02:16.736]                 a == 2)))
[11:02:16.736]             future::FutureResult(value = ...future.value$value, 
[11:02:16.736]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:16.736]                   ...future.rng), globalenv = if (FALSE) 
[11:02:16.736]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:16.736]                     ...future.globalenv.names))
[11:02:16.736]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:16.736]         }, condition = base::local({
[11:02:16.736]             c <- base::c
[11:02:16.736]             inherits <- base::inherits
[11:02:16.736]             invokeRestart <- base::invokeRestart
[11:02:16.736]             length <- base::length
[11:02:16.736]             list <- base::list
[11:02:16.736]             seq.int <- base::seq.int
[11:02:16.736]             signalCondition <- base::signalCondition
[11:02:16.736]             sys.calls <- base::sys.calls
[11:02:16.736]             `[[` <- base::`[[`
[11:02:16.736]             `+` <- base::`+`
[11:02:16.736]             `<<-` <- base::`<<-`
[11:02:16.736]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:16.736]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:16.736]                   3L)]
[11:02:16.736]             }
[11:02:16.736]             function(cond) {
[11:02:16.736]                 is_error <- inherits(cond, "error")
[11:02:16.736]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:16.736]                   NULL)
[11:02:16.736]                 if (is_error) {
[11:02:16.736]                   sessionInformation <- function() {
[11:02:16.736]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:16.736]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:16.736]                       search = base::search(), system = base::Sys.info())
[11:02:16.736]                   }
[11:02:16.736]                   ...future.conditions[[length(...future.conditions) + 
[11:02:16.736]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:16.736]                     cond$call), session = sessionInformation(), 
[11:02:16.736]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:16.736]                   signalCondition(cond)
[11:02:16.736]                 }
[11:02:16.736]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:16.736]                 "immediateCondition"))) {
[11:02:16.736]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:16.736]                   ...future.conditions[[length(...future.conditions) + 
[11:02:16.736]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:16.736]                   if (TRUE && !signal) {
[11:02:16.736]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.736]                     {
[11:02:16.736]                       inherits <- base::inherits
[11:02:16.736]                       invokeRestart <- base::invokeRestart
[11:02:16.736]                       is.null <- base::is.null
[11:02:16.736]                       muffled <- FALSE
[11:02:16.736]                       if (inherits(cond, "message")) {
[11:02:16.736]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:16.736]                         if (muffled) 
[11:02:16.736]                           invokeRestart("muffleMessage")
[11:02:16.736]                       }
[11:02:16.736]                       else if (inherits(cond, "warning")) {
[11:02:16.736]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:16.736]                         if (muffled) 
[11:02:16.736]                           invokeRestart("muffleWarning")
[11:02:16.736]                       }
[11:02:16.736]                       else if (inherits(cond, "condition")) {
[11:02:16.736]                         if (!is.null(pattern)) {
[11:02:16.736]                           computeRestarts <- base::computeRestarts
[11:02:16.736]                           grepl <- base::grepl
[11:02:16.736]                           restarts <- computeRestarts(cond)
[11:02:16.736]                           for (restart in restarts) {
[11:02:16.736]                             name <- restart$name
[11:02:16.736]                             if (is.null(name)) 
[11:02:16.736]                               next
[11:02:16.736]                             if (!grepl(pattern, name)) 
[11:02:16.736]                               next
[11:02:16.736]                             invokeRestart(restart)
[11:02:16.736]                             muffled <- TRUE
[11:02:16.736]                             break
[11:02:16.736]                           }
[11:02:16.736]                         }
[11:02:16.736]                       }
[11:02:16.736]                       invisible(muffled)
[11:02:16.736]                     }
[11:02:16.736]                     muffleCondition(cond, pattern = "^muffle")
[11:02:16.736]                   }
[11:02:16.736]                 }
[11:02:16.736]                 else {
[11:02:16.736]                   if (TRUE) {
[11:02:16.736]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.736]                     {
[11:02:16.736]                       inherits <- base::inherits
[11:02:16.736]                       invokeRestart <- base::invokeRestart
[11:02:16.736]                       is.null <- base::is.null
[11:02:16.736]                       muffled <- FALSE
[11:02:16.736]                       if (inherits(cond, "message")) {
[11:02:16.736]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:16.736]                         if (muffled) 
[11:02:16.736]                           invokeRestart("muffleMessage")
[11:02:16.736]                       }
[11:02:16.736]                       else if (inherits(cond, "warning")) {
[11:02:16.736]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:16.736]                         if (muffled) 
[11:02:16.736]                           invokeRestart("muffleWarning")
[11:02:16.736]                       }
[11:02:16.736]                       else if (inherits(cond, "condition")) {
[11:02:16.736]                         if (!is.null(pattern)) {
[11:02:16.736]                           computeRestarts <- base::computeRestarts
[11:02:16.736]                           grepl <- base::grepl
[11:02:16.736]                           restarts <- computeRestarts(cond)
[11:02:16.736]                           for (restart in restarts) {
[11:02:16.736]                             name <- restart$name
[11:02:16.736]                             if (is.null(name)) 
[11:02:16.736]                               next
[11:02:16.736]                             if (!grepl(pattern, name)) 
[11:02:16.736]                               next
[11:02:16.736]                             invokeRestart(restart)
[11:02:16.736]                             muffled <- TRUE
[11:02:16.736]                             break
[11:02:16.736]                           }
[11:02:16.736]                         }
[11:02:16.736]                       }
[11:02:16.736]                       invisible(muffled)
[11:02:16.736]                     }
[11:02:16.736]                     muffleCondition(cond, pattern = "^muffle")
[11:02:16.736]                   }
[11:02:16.736]                 }
[11:02:16.736]             }
[11:02:16.736]         }))
[11:02:16.736]     }, error = function(ex) {
[11:02:16.736]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:16.736]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:16.736]                 ...future.rng), started = ...future.startTime, 
[11:02:16.736]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:16.736]             version = "1.8"), class = "FutureResult")
[11:02:16.736]     }, finally = {
[11:02:16.736]         if (!identical(...future.workdir, getwd())) 
[11:02:16.736]             setwd(...future.workdir)
[11:02:16.736]         {
[11:02:16.736]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:16.736]                 ...future.oldOptions$nwarnings <- NULL
[11:02:16.736]             }
[11:02:16.736]             base::options(...future.oldOptions)
[11:02:16.736]             if (.Platform$OS.type == "windows") {
[11:02:16.736]                 old_names <- names(...future.oldEnvVars)
[11:02:16.736]                 envs <- base::Sys.getenv()
[11:02:16.736]                 names <- names(envs)
[11:02:16.736]                 common <- intersect(names, old_names)
[11:02:16.736]                 added <- setdiff(names, old_names)
[11:02:16.736]                 removed <- setdiff(old_names, names)
[11:02:16.736]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:16.736]                   envs[common]]
[11:02:16.736]                 NAMES <- toupper(changed)
[11:02:16.736]                 args <- list()
[11:02:16.736]                 for (kk in seq_along(NAMES)) {
[11:02:16.736]                   name <- changed[[kk]]
[11:02:16.736]                   NAME <- NAMES[[kk]]
[11:02:16.736]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.736]                     next
[11:02:16.736]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:16.736]                 }
[11:02:16.736]                 NAMES <- toupper(added)
[11:02:16.736]                 for (kk in seq_along(NAMES)) {
[11:02:16.736]                   name <- added[[kk]]
[11:02:16.736]                   NAME <- NAMES[[kk]]
[11:02:16.736]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.736]                     next
[11:02:16.736]                   args[[name]] <- ""
[11:02:16.736]                 }
[11:02:16.736]                 NAMES <- toupper(removed)
[11:02:16.736]                 for (kk in seq_along(NAMES)) {
[11:02:16.736]                   name <- removed[[kk]]
[11:02:16.736]                   NAME <- NAMES[[kk]]
[11:02:16.736]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.736]                     next
[11:02:16.736]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:16.736]                 }
[11:02:16.736]                 if (length(args) > 0) 
[11:02:16.736]                   base::do.call(base::Sys.setenv, args = args)
[11:02:16.736]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:16.736]             }
[11:02:16.736]             else {
[11:02:16.736]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:16.736]             }
[11:02:16.736]             {
[11:02:16.736]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:16.736]                   0L) {
[11:02:16.736]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:16.736]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:16.736]                   base::options(opts)
[11:02:16.736]                 }
[11:02:16.736]                 {
[11:02:16.736]                   {
[11:02:16.736]                     NULL
[11:02:16.736]                     RNGkind("Mersenne-Twister")
[11:02:16.736]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:16.736]                       inherits = FALSE)
[11:02:16.736]                   }
[11:02:16.736]                   options(future.plan = NULL)
[11:02:16.736]                   if (is.na(NA_character_)) 
[11:02:16.736]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:16.736]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:16.736]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:16.736]                     .init = FALSE)
[11:02:16.736]                 }
[11:02:16.736]             }
[11:02:16.736]         }
[11:02:16.736]     })
[11:02:16.736]     if (TRUE) {
[11:02:16.736]         base::sink(type = "output", split = FALSE)
[11:02:16.736]         if (TRUE) {
[11:02:16.736]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:16.736]         }
[11:02:16.736]         else {
[11:02:16.736]             ...future.result["stdout"] <- base::list(NULL)
[11:02:16.736]         }
[11:02:16.736]         base::close(...future.stdout)
[11:02:16.736]         ...future.stdout <- NULL
[11:02:16.736]     }
[11:02:16.736]     ...future.result$conditions <- ...future.conditions
[11:02:16.736]     ...future.result$finished <- base::Sys.time()
[11:02:16.736]     ...future.result
[11:02:16.736] }
[11:02:16.761]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.738] assign_globals() ...
[11:02:16.761]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.738] List of 1
[11:02:16.738]  $ data:'data.frame':	3 obs. of  2 variables:
[11:02:16.738]   ..$ a: int [1:3] 1 2 3
[11:02:16.738]   ..$ b: int [1:3] 3 2 1
[11:02:16.738]  - attr(*, "where")=List of 1
[11:02:16.738]   ..$ data:<environment: R_EmptyEnv> 
[11:02:16.738]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:02:16.738]  - attr(*, "resolved")= logi FALSE
[11:02:16.738]  - attr(*, "total_size")= num 356
[11:02:16.738]  - attr(*, "already-done")= logi TRUE
[11:02:16.761]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.742] - copied ‘data’ to environment
[11:02:16.761]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.743] assign_globals() ... done
[11:02:16.762]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.743] plan(): Setting new future strategy stack:
[11:02:16.762]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.743] List of future strategies:
[11:02:16.743] 1. sequential:
[11:02:16.743]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:16.743]    - tweaked: FALSE
[11:02:16.743]    - call: NULL
[11:02:16.762]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.744] plan(): nbrOfWorkers() = 1
[11:02:16.762]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.745] plan(): Setting new future strategy stack:
[11:02:16.762]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.745] List of future strategies:
[11:02:16.745] 1. multicore:
[11:02:16.745]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:16.745]    - tweaked: FALSE
[11:02:16.745]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:16.762]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.747] plan(): nbrOfWorkers() = 1
[11:02:16.762]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.747] SequentialFuture started (and completed)
[11:02:16.763]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.747] - Launch lazy future ... done
[11:02:16.763]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.747] run() for ‘SequentialFuture’ ... done
[11:02:16.763] signalConditions() ... done
- plan(list('multicore', 'multicore')) ... DONE
- plan(list('multicore', 'multisession')) ...
[11:02:16.763] plan(): Setting new future strategy stack:
[11:02:16.763] List of future strategies:
[11:02:16.763] 1. multicore:
[11:02:16.763]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:16.763]    - tweaked: FALSE
[11:02:16.763]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:16.763] 2. multisession:
[11:02:16.763]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:02:16.763]    - tweaked: FALSE
[11:02:16.763]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:16.766] plan(): nbrOfWorkers() = 2
[11:02:16.766] getGlobalsAndPackages() ...
[11:02:16.766] Searching for globals...
[11:02:16.785] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[11:02:16.785] Searching for globals ... DONE
[11:02:16.785] Resolving globals: FALSE
[11:02:16.786] The total size of the 2 globals is 11.73 KiB (12016 bytes)
[11:02:16.787] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 11.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (11.68 KiB of class ‘list’) and ‘strategy2’ (51 bytes of class ‘character’)
[11:02:16.787] - globals: [2] ‘nested’, ‘strategy2’
[11:02:16.787] - packages: [1] ‘future’
[11:02:16.787] getGlobalsAndPackages() ... DONE
[11:02:16.787] run() for ‘Future’ ...
[11:02:16.788] - state: ‘created’
[11:02:16.788] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:02:16.789] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:16.790] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:02:16.790]   - Field: ‘label’
[11:02:16.790]   - Field: ‘local’
[11:02:16.790]   - Field: ‘owner’
[11:02:16.790]   - Field: ‘envir’
[11:02:16.790]   - Field: ‘workers’
[11:02:16.790]   - Field: ‘packages’
[11:02:16.790]   - Field: ‘gc’
[11:02:16.790]   - Field: ‘job’
[11:02:16.790]   - Field: ‘conditions’
[11:02:16.791]   - Field: ‘expr’
[11:02:16.791]   - Field: ‘uuid’
[11:02:16.791]   - Field: ‘seed’
[11:02:16.791]   - Field: ‘version’
[11:02:16.791]   - Field: ‘result’
[11:02:16.791]   - Field: ‘asynchronous’
[11:02:16.791]   - Field: ‘calls’
[11:02:16.791]   - Field: ‘globals’
[11:02:16.791]   - Field: ‘stdout’
[11:02:16.791]   - Field: ‘earlySignal’
[11:02:16.792]   - Field: ‘lazy’
[11:02:16.792]   - Field: ‘state’
[11:02:16.792] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:02:16.792] - Launch lazy future ...
[11:02:16.792] Packages needed by the future expression (n = 1): ‘future’
[11:02:16.792] Packages needed by future strategies (n = 1): ‘future’
[11:02:16.793] {
[11:02:16.793]     {
[11:02:16.793]         {
[11:02:16.793]             ...future.startTime <- base::Sys.time()
[11:02:16.793]             {
[11:02:16.793]                 {
[11:02:16.793]                   {
[11:02:16.793]                     {
[11:02:16.793]                       {
[11:02:16.793]                         base::local({
[11:02:16.793]                           has_future <- base::requireNamespace("future", 
[11:02:16.793]                             quietly = TRUE)
[11:02:16.793]                           if (has_future) {
[11:02:16.793]                             ns <- base::getNamespace("future")
[11:02:16.793]                             version <- ns[[".package"]][["version"]]
[11:02:16.793]                             if (is.null(version)) 
[11:02:16.793]                               version <- utils::packageVersion("future")
[11:02:16.793]                           }
[11:02:16.793]                           else {
[11:02:16.793]                             version <- NULL
[11:02:16.793]                           }
[11:02:16.793]                           if (!has_future || version < "1.8.0") {
[11:02:16.793]                             info <- base::c(r_version = base::gsub("R version ", 
[11:02:16.793]                               "", base::R.version$version.string), 
[11:02:16.793]                               platform = base::sprintf("%s (%s-bit)", 
[11:02:16.793]                                 base::R.version$platform, 8 * 
[11:02:16.793]                                   base::.Machine$sizeof.pointer), 
[11:02:16.793]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:16.793]                                 "release", "version")], collapse = " "), 
[11:02:16.793]                               hostname = base::Sys.info()[["nodename"]])
[11:02:16.793]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:02:16.793]                               info)
[11:02:16.793]                             info <- base::paste(info, collapse = "; ")
[11:02:16.793]                             if (!has_future) {
[11:02:16.793]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:16.793]                                 info)
[11:02:16.793]                             }
[11:02:16.793]                             else {
[11:02:16.793]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:16.793]                                 info, version)
[11:02:16.793]                             }
[11:02:16.793]                             base::stop(msg)
[11:02:16.793]                           }
[11:02:16.793]                         })
[11:02:16.793]                       }
[11:02:16.793]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:16.793]                       base::options(mc.cores = 1L)
[11:02:16.793]                     }
[11:02:16.793]                     base::local({
[11:02:16.793]                       for (pkg in "future") {
[11:02:16.793]                         base::loadNamespace(pkg)
[11:02:16.793]                         base::library(pkg, character.only = TRUE)
[11:02:16.793]                       }
[11:02:16.793]                     })
[11:02:16.793]                   }
[11:02:16.793]                   ...future.strategy.old <- future::plan("list")
[11:02:16.793]                   options(future.plan = NULL)
[11:02:16.793]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:16.793]                   future::plan(list(b = function (..., workers = availableCores(), 
[11:02:16.793]                     lazy = FALSE, rscript_libs = .libPaths(), 
[11:02:16.793]                     envir = parent.frame()) 
[11:02:16.793]                   {
[11:02:16.793]                     if (is.function(workers)) 
[11:02:16.793]                       workers <- workers()
[11:02:16.793]                     workers <- structure(as.integer(workers), 
[11:02:16.793]                       class = class(workers))
[11:02:16.793]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[11:02:16.793]                       workers >= 1)
[11:02:16.793]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[11:02:16.793]                       return(sequential(..., lazy = TRUE, envir = envir))
[11:02:16.793]                     }
[11:02:16.793]                     future <- MultisessionFuture(..., workers = workers, 
[11:02:16.793]                       lazy = lazy, rscript_libs = rscript_libs, 
[11:02:16.793]                       envir = envir)
[11:02:16.793]                     if (!future$lazy) 
[11:02:16.793]                       future <- run(future)
[11:02:16.793]                     invisible(future)
[11:02:16.793]                   }), .cleanup = FALSE, .init = FALSE)
[11:02:16.793]                 }
[11:02:16.793]                 ...future.workdir <- getwd()
[11:02:16.793]             }
[11:02:16.793]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:16.793]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:16.793]         }
[11:02:16.793]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:16.793]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:16.793]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:16.793]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:16.793]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:16.793]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:16.793]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:16.793]             base::names(...future.oldOptions))
[11:02:16.793]     }
[11:02:16.793]     if (FALSE) {
[11:02:16.793]     }
[11:02:16.793]     else {
[11:02:16.793]         if (TRUE) {
[11:02:16.793]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:16.793]                 open = "w")
[11:02:16.793]         }
[11:02:16.793]         else {
[11:02:16.793]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:16.793]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:16.793]         }
[11:02:16.793]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:16.793]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:16.793]             base::sink(type = "output", split = FALSE)
[11:02:16.793]             base::close(...future.stdout)
[11:02:16.793]         }, add = TRUE)
[11:02:16.793]     }
[11:02:16.793]     ...future.frame <- base::sys.nframe()
[11:02:16.793]     ...future.conditions <- base::list()
[11:02:16.793]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:16.793]     if (FALSE) {
[11:02:16.793]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:16.793]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:16.793]     }
[11:02:16.793]     ...future.result <- base::tryCatch({
[11:02:16.793]         base::withCallingHandlers({
[11:02:16.793]             ...future.value <- base::withVisible(base::local({
[11:02:16.793]                 withCallingHandlers({
[11:02:16.793]                   {
[11:02:16.793]                     a <- 1L
[11:02:16.793]                     plan_a <- unclass(future::plan("list"))
[11:02:16.793]                     nested_a <- nested[-1]
[11:02:16.793]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[11:02:16.793]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[11:02:16.793]                       strategy2))
[11:02:16.793]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[11:02:16.793]                       "init") <- NULL
[11:02:16.793]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[11:02:16.793]                       "init") <- NULL
[11:02:16.793]                     stopifnot(all.equal(plan_a, nested_a))
[11:02:16.793]                     y %<-% {
[11:02:16.793]                       b <- 2L
[11:02:16.793]                       plan_b <- future::plan("list")
[11:02:16.793]                       nested_b <- nested_a[-1]
[11:02:16.793]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[11:02:16.793]                         1L, inherits(plan_b[[1]], "future"), 
[11:02:16.793]                         inherits(future::plan("next"), "sequential"))
[11:02:16.793]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[11:02:16.793]                         b = b, nested_b = nested_b, plan_b = plan_b)
[11:02:16.793]                     }
[11:02:16.793]                     y
[11:02:16.793]                   }
[11:02:16.793]                 }, immediateCondition = function(cond) {
[11:02:16.793]                   save_rds <- function (object, pathname, ...) 
[11:02:16.793]                   {
[11:02:16.793]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:02:16.793]                     if (file_test("-f", pathname_tmp)) {
[11:02:16.793]                       fi_tmp <- file.info(pathname_tmp)
[11:02:16.793]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:02:16.793]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:16.793]                         fi_tmp[["mtime"]])
[11:02:16.793]                     }
[11:02:16.793]                     tryCatch({
[11:02:16.793]                       saveRDS(object, file = pathname_tmp, ...)
[11:02:16.793]                     }, error = function(ex) {
[11:02:16.793]                       msg <- conditionMessage(ex)
[11:02:16.793]                       fi_tmp <- file.info(pathname_tmp)
[11:02:16.793]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:02:16.793]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:16.793]                         fi_tmp[["mtime"]], msg)
[11:02:16.793]                       ex$message <- msg
[11:02:16.793]                       stop(ex)
[11:02:16.793]                     })
[11:02:16.793]                     stopifnot(file_test("-f", pathname_tmp))
[11:02:16.793]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:02:16.793]                     if (!res || file_test("-f", pathname_tmp)) {
[11:02:16.793]                       fi_tmp <- file.info(pathname_tmp)
[11:02:16.793]                       fi <- file.info(pathname)
[11:02:16.793]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:02:16.793]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:16.793]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:02:16.793]                         fi[["size"]], fi[["mtime"]])
[11:02:16.793]                       stop(msg)
[11:02:16.793]                     }
[11:02:16.793]                     invisible(pathname)
[11:02:16.793]                   }
[11:02:16.793]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:02:16.793]                     rootPath = tempdir()) 
[11:02:16.793]                   {
[11:02:16.793]                     obj <- list(time = Sys.time(), condition = cond)
[11:02:16.793]                     file <- tempfile(pattern = class(cond)[1], 
[11:02:16.793]                       tmpdir = path, fileext = ".rds")
[11:02:16.793]                     save_rds(obj, file)
[11:02:16.793]                   }
[11:02:16.793]                   saveImmediateCondition(cond, path = "/tmp/RtmpVZPEla/.future/immediateConditions")
[11:02:16.793]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.793]                   {
[11:02:16.793]                     inherits <- base::inherits
[11:02:16.793]                     invokeRestart <- base::invokeRestart
[11:02:16.793]                     is.null <- base::is.null
[11:02:16.793]                     muffled <- FALSE
[11:02:16.793]                     if (inherits(cond, "message")) {
[11:02:16.793]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:16.793]                       if (muffled) 
[11:02:16.793]                         invokeRestart("muffleMessage")
[11:02:16.793]                     }
[11:02:16.793]                     else if (inherits(cond, "warning")) {
[11:02:16.793]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:16.793]                       if (muffled) 
[11:02:16.793]                         invokeRestart("muffleWarning")
[11:02:16.793]                     }
[11:02:16.793]                     else if (inherits(cond, "condition")) {
[11:02:16.793]                       if (!is.null(pattern)) {
[11:02:16.793]                         computeRestarts <- base::computeRestarts
[11:02:16.793]                         grepl <- base::grepl
[11:02:16.793]                         restarts <- computeRestarts(cond)
[11:02:16.793]                         for (restart in restarts) {
[11:02:16.793]                           name <- restart$name
[11:02:16.793]                           if (is.null(name)) 
[11:02:16.793]                             next
[11:02:16.793]                           if (!grepl(pattern, name)) 
[11:02:16.793]                             next
[11:02:16.793]                           invokeRestart(restart)
[11:02:16.793]                           muffled <- TRUE
[11:02:16.793]                           break
[11:02:16.793]                         }
[11:02:16.793]                       }
[11:02:16.793]                     }
[11:02:16.793]                     invisible(muffled)
[11:02:16.793]                   }
[11:02:16.793]                   muffleCondition(cond)
[11:02:16.793]                 })
[11:02:16.793]             }))
[11:02:16.793]             future::FutureResult(value = ...future.value$value, 
[11:02:16.793]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:16.793]                   ...future.rng), globalenv = if (FALSE) 
[11:02:16.793]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:16.793]                     ...future.globalenv.names))
[11:02:16.793]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:16.793]         }, condition = base::local({
[11:02:16.793]             c <- base::c
[11:02:16.793]             inherits <- base::inherits
[11:02:16.793]             invokeRestart <- base::invokeRestart
[11:02:16.793]             length <- base::length
[11:02:16.793]             list <- base::list
[11:02:16.793]             seq.int <- base::seq.int
[11:02:16.793]             signalCondition <- base::signalCondition
[11:02:16.793]             sys.calls <- base::sys.calls
[11:02:16.793]             `[[` <- base::`[[`
[11:02:16.793]             `+` <- base::`+`
[11:02:16.793]             `<<-` <- base::`<<-`
[11:02:16.793]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:16.793]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:16.793]                   3L)]
[11:02:16.793]             }
[11:02:16.793]             function(cond) {
[11:02:16.793]                 is_error <- inherits(cond, "error")
[11:02:16.793]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:16.793]                   NULL)
[11:02:16.793]                 if (is_error) {
[11:02:16.793]                   sessionInformation <- function() {
[11:02:16.793]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:16.793]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:16.793]                       search = base::search(), system = base::Sys.info())
[11:02:16.793]                   }
[11:02:16.793]                   ...future.conditions[[length(...future.conditions) + 
[11:02:16.793]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:16.793]                     cond$call), session = sessionInformation(), 
[11:02:16.793]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:16.793]                   signalCondition(cond)
[11:02:16.793]                 }
[11:02:16.793]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:16.793]                 "immediateCondition"))) {
[11:02:16.793]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:16.793]                   ...future.conditions[[length(...future.conditions) + 
[11:02:16.793]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:16.793]                   if (TRUE && !signal) {
[11:02:16.793]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.793]                     {
[11:02:16.793]                       inherits <- base::inherits
[11:02:16.793]                       invokeRestart <- base::invokeRestart
[11:02:16.793]                       is.null <- base::is.null
[11:02:16.793]                       muffled <- FALSE
[11:02:16.793]                       if (inherits(cond, "message")) {
[11:02:16.793]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:16.793]                         if (muffled) 
[11:02:16.793]                           invokeRestart("muffleMessage")
[11:02:16.793]                       }
[11:02:16.793]                       else if (inherits(cond, "warning")) {
[11:02:16.793]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:16.793]                         if (muffled) 
[11:02:16.793]                           invokeRestart("muffleWarning")
[11:02:16.793]                       }
[11:02:16.793]                       else if (inherits(cond, "condition")) {
[11:02:16.793]                         if (!is.null(pattern)) {
[11:02:16.793]                           computeRestarts <- base::computeRestarts
[11:02:16.793]                           grepl <- base::grepl
[11:02:16.793]                           restarts <- computeRestarts(cond)
[11:02:16.793]                           for (restart in restarts) {
[11:02:16.793]                             name <- restart$name
[11:02:16.793]                             if (is.null(name)) 
[11:02:16.793]                               next
[11:02:16.793]                             if (!grepl(pattern, name)) 
[11:02:16.793]                               next
[11:02:16.793]                             invokeRestart(restart)
[11:02:16.793]                             muffled <- TRUE
[11:02:16.793]                             break
[11:02:16.793]                           }
[11:02:16.793]                         }
[11:02:16.793]                       }
[11:02:16.793]                       invisible(muffled)
[11:02:16.793]                     }
[11:02:16.793]                     muffleCondition(cond, pattern = "^muffle")
[11:02:16.793]                   }
[11:02:16.793]                 }
[11:02:16.793]                 else {
[11:02:16.793]                   if (TRUE) {
[11:02:16.793]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.793]                     {
[11:02:16.793]                       inherits <- base::inherits
[11:02:16.793]                       invokeRestart <- base::invokeRestart
[11:02:16.793]                       is.null <- base::is.null
[11:02:16.793]                       muffled <- FALSE
[11:02:16.793]                       if (inherits(cond, "message")) {
[11:02:16.793]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:16.793]                         if (muffled) 
[11:02:16.793]                           invokeRestart("muffleMessage")
[11:02:16.793]                       }
[11:02:16.793]                       else if (inherits(cond, "warning")) {
[11:02:16.793]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:16.793]                         if (muffled) 
[11:02:16.793]                           invokeRestart("muffleWarning")
[11:02:16.793]                       }
[11:02:16.793]                       else if (inherits(cond, "condition")) {
[11:02:16.793]                         if (!is.null(pattern)) {
[11:02:16.793]                           computeRestarts <- base::computeRestarts
[11:02:16.793]                           grepl <- base::grepl
[11:02:16.793]                           restarts <- computeRestarts(cond)
[11:02:16.793]                           for (restart in restarts) {
[11:02:16.793]                             name <- restart$name
[11:02:16.793]                             if (is.null(name)) 
[11:02:16.793]                               next
[11:02:16.793]                             if (!grepl(pattern, name)) 
[11:02:16.793]                               next
[11:02:16.793]                             invokeRestart(restart)
[11:02:16.793]                             muffled <- TRUE
[11:02:16.793]                             break
[11:02:16.793]                           }
[11:02:16.793]                         }
[11:02:16.793]                       }
[11:02:16.793]                       invisible(muffled)
[11:02:16.793]                     }
[11:02:16.793]                     muffleCondition(cond, pattern = "^muffle")
[11:02:16.793]                   }
[11:02:16.793]                 }
[11:02:16.793]             }
[11:02:16.793]         }))
[11:02:16.793]     }, error = function(ex) {
[11:02:16.793]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:16.793]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:16.793]                 ...future.rng), started = ...future.startTime, 
[11:02:16.793]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:16.793]             version = "1.8"), class = "FutureResult")
[11:02:16.793]     }, finally = {
[11:02:16.793]         if (!identical(...future.workdir, getwd())) 
[11:02:16.793]             setwd(...future.workdir)
[11:02:16.793]         {
[11:02:16.793]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:16.793]                 ...future.oldOptions$nwarnings <- NULL
[11:02:16.793]             }
[11:02:16.793]             base::options(...future.oldOptions)
[11:02:16.793]             if (.Platform$OS.type == "windows") {
[11:02:16.793]                 old_names <- names(...future.oldEnvVars)
[11:02:16.793]                 envs <- base::Sys.getenv()
[11:02:16.793]                 names <- names(envs)
[11:02:16.793]                 common <- intersect(names, old_names)
[11:02:16.793]                 added <- setdiff(names, old_names)
[11:02:16.793]                 removed <- setdiff(old_names, names)
[11:02:16.793]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:16.793]                   envs[common]]
[11:02:16.793]                 NAMES <- toupper(changed)
[11:02:16.793]                 args <- list()
[11:02:16.793]                 for (kk in seq_along(NAMES)) {
[11:02:16.793]                   name <- changed[[kk]]
[11:02:16.793]                   NAME <- NAMES[[kk]]
[11:02:16.793]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.793]                     next
[11:02:16.793]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:16.793]                 }
[11:02:16.793]                 NAMES <- toupper(added)
[11:02:16.793]                 for (kk in seq_along(NAMES)) {
[11:02:16.793]                   name <- added[[kk]]
[11:02:16.793]                   NAME <- NAMES[[kk]]
[11:02:16.793]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.793]                     next
[11:02:16.793]                   args[[name]] <- ""
[11:02:16.793]                 }
[11:02:16.793]                 NAMES <- toupper(removed)
[11:02:16.793]                 for (kk in seq_along(NAMES)) {
[11:02:16.793]                   name <- removed[[kk]]
[11:02:16.793]                   NAME <- NAMES[[kk]]
[11:02:16.793]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.793]                     next
[11:02:16.793]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:16.793]                 }
[11:02:16.793]                 if (length(args) > 0) 
[11:02:16.793]                   base::do.call(base::Sys.setenv, args = args)
[11:02:16.793]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:16.793]             }
[11:02:16.793]             else {
[11:02:16.793]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:16.793]             }
[11:02:16.793]             {
[11:02:16.793]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:16.793]                   0L) {
[11:02:16.793]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:16.793]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:16.793]                   base::options(opts)
[11:02:16.793]                 }
[11:02:16.793]                 {
[11:02:16.793]                   {
[11:02:16.793]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:16.793]                     NULL
[11:02:16.793]                   }
[11:02:16.793]                   options(future.plan = NULL)
[11:02:16.793]                   if (is.na(NA_character_)) 
[11:02:16.793]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:16.793]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:16.793]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:16.793]                     .init = FALSE)
[11:02:16.793]                 }
[11:02:16.793]             }
[11:02:16.793]         }
[11:02:16.793]     })
[11:02:16.793]     if (TRUE) {
[11:02:16.793]         base::sink(type = "output", split = FALSE)
[11:02:16.793]         if (TRUE) {
[11:02:16.793]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:16.793]         }
[11:02:16.793]         else {
[11:02:16.793]             ...future.result["stdout"] <- base::list(NULL)
[11:02:16.793]         }
[11:02:16.793]         base::close(...future.stdout)
[11:02:16.793]         ...future.stdout <- NULL
[11:02:16.793]     }
[11:02:16.793]     ...future.result$conditions <- ...future.conditions
[11:02:16.793]     ...future.result$finished <- base::Sys.time()
[11:02:16.793]     ...future.result
[11:02:16.793] }
[11:02:16.796] assign_globals() ...
[11:02:16.796] List of 2
[11:02:16.796]  $ nested   :List of 2
[11:02:16.796]   ..$ a:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
[11:02:16.796]   .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
[11:02:16.796]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[11:02:16.796]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[11:02:16.796]     envir = parent.frame())  
[11:02:16.796]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[11:02:16.796]   .. ..- attr(*, "init")= logi TRUE
[11:02:16.796]   .. ..- attr(*, "cleanup")=function ()  
[11:02:16.796]   .. ..- attr(*, "untweakable")= chr "persistent"
[11:02:16.796]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[11:02:16.796]   ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[11:02:16.796]  $ strategy2: chr "multisession"
[11:02:16.796]  - attr(*, "where")=List of 2
[11:02:16.796]   ..$ nested   :<environment: R_EmptyEnv> 
[11:02:16.796]   ..$ strategy2:<environment: R_EmptyEnv> 
[11:02:16.796]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:02:16.796]  - attr(*, "resolved")= logi FALSE
[11:02:16.796]  - attr(*, "total_size")= num 12016
[11:02:16.796]  - attr(*, "already-done")= logi TRUE
[11:02:16.804] - copied ‘nested’ to environment
[11:02:16.804] - copied ‘strategy2’ to environment
[11:02:16.804] assign_globals() ... done
[11:02:16.805] requestCore(): workers = 2
[11:02:16.807] MulticoreFuture started
[11:02:16.807] - Launch lazy future ... done
[11:02:16.807] run() for ‘MulticoreFuture’ ... done
[11:02:16.808] result() for MulticoreFuture ...
[11:02:16.808] plan(): Setting new future strategy stack:
[11:02:16.809] List of future strategies:
[11:02:16.809] 1. multisession:
[11:02:16.809]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:02:16.809]    - tweaked: FALSE
[11:02:16.809]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:16.812] plan(): nbrOfWorkers() = 1
[11:02:16.851] plan(): Setting new future strategy stack:
[11:02:16.851] List of future strategies:
[11:02:16.851] 1. multicore:
[11:02:16.851]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:16.851]    - tweaked: FALSE
[11:02:16.851]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:16.851] 2. multisession:
[11:02:16.851]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:02:16.851]    - tweaked: FALSE
[11:02:16.851]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:16.853] plan(): nbrOfWorkers() = 2
[11:02:16.855] result() for MulticoreFuture ...
[11:02:16.855] result() for MulticoreFuture ... done
[11:02:16.855] signalConditions() ...
[11:02:16.855]  - include = ‘immediateCondition’
[11:02:16.855]  - exclude = 
[11:02:16.855]  - resignal = FALSE
[11:02:16.855]  - Number of conditions: 54
[11:02:16.855] signalConditions() ... done
[11:02:16.856] result() for MulticoreFuture ... done
[11:02:16.856] result() for MulticoreFuture ...
[11:02:16.856] result() for MulticoreFuture ... done
[11:02:16.856] signalConditions() ...
[11:02:16.856]  - include = ‘immediateCondition’
[11:02:16.856]  - exclude = 
[11:02:16.856]  - resignal = FALSE
[11:02:16.856]  - Number of conditions: 54
[11:02:16.856] signalConditions() ... done
[11:02:16.857] Future state: ‘finished’
[11:02:16.857] result() for MulticoreFuture ...
[11:02:16.857] result() for MulticoreFuture ... done
[11:02:16.857] signalConditions() ...
[11:02:16.857]  - include = ‘condition’
[11:02:16.857]  - exclude = ‘immediateCondition’
[11:02:16.857]  - resignal = TRUE
[11:02:16.857]  - Number of conditions: 54
[11:02:16.857]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.814] getGlobalsAndPackages() ...
[11:02:16.858]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.814] Searching for globals...
[11:02:16.858]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.822] - globals found: [14] ‘{’, ‘<-’, ‘::’, ‘[’, ‘nested_a’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘list’, ‘a’, ‘plan_a’
[11:02:16.858]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.822] Searching for globals ... DONE
[11:02:16.858]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.822] Resolving globals: FALSE
[11:02:16.858]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.823] The total size of the 3 globals is 11.81 KiB (12089 bytes)
[11:02:16.858]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.824] The total size of the 3 globals exported for future expression (‘{; b <- 2L; plan_b <- future::plan("list"); nested_b <- nested_a[-1]; stopifnot(length(nested_b) == 0L, length(plan_b) == 1L, inherits(plan_b[[1]],; "future"), inherits(future::plan("next"), "sequential")); list(a = a, nested_a = nested_a, plan_a = plan_a, b = b,; nested_b = nested_b, plan_b = plan_b); }’) is 11.81 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are three globals: ‘nested_a’ (5.89 KiB of class ‘list’), ‘plan_a’ (5.89 KiB of class ‘list’) and ‘a’ (35 bytes of class ‘numeric’)
[11:02:16.859]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.824] - globals: [3] ‘nested_a’, ‘a’, ‘plan_a’
[11:02:16.859]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.824] 
[11:02:16.859]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.824] getGlobalsAndPackages() ... DONE
[11:02:16.859]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.825] run() for ‘Future’ ...
[11:02:16.859]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.825] - state: ‘created’
[11:02:16.859]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.826] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:16.859]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.828] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:16.860]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.828] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:16.860]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.828]   - Field: ‘label’
[11:02:16.860]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.828]   - Field: ‘local’
[11:02:16.860]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.828]   - Field: ‘owner’
[11:02:16.860]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.829]   - Field: ‘envir’
[11:02:16.860]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.829]   - Field: ‘packages’
[11:02:16.861]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.829]   - Field: ‘gc’
[11:02:16.861]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.829]   - Field: ‘conditions’
[11:02:16.861]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.829]   - Field: ‘expr’
[11:02:16.861]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.829]   - Field: ‘uuid’
[11:02:16.861]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.830]   - Field: ‘seed’
[11:02:16.861]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.830]   - Field: ‘version’
[11:02:16.861]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.830]   - Field: ‘result’
[11:02:16.862]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.830]   - Field: ‘asynchronous’
[11:02:16.862]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.830]   - Field: ‘calls’
[11:02:16.862]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.830]   - Field: ‘globals’
[11:02:16.862]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.831]   - Field: ‘stdout’
[11:02:16.862]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.831]   - Field: ‘earlySignal’
[11:02:16.862]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.831]   - Field: ‘lazy’
[11:02:16.862]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.831]   - Field: ‘state’
[11:02:16.863]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.831] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:16.863]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.831] - Launch lazy future ...
[11:02:16.863]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.832] Packages needed by the future expression (n = 0): <none>
[11:02:16.863]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.832] Packages needed by future strategies (n = 0): <none>
[11:02:16.863]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.833] {
[11:02:16.833]     {
[11:02:16.833]         {
[11:02:16.833]             ...future.startTime <- base::Sys.time()
[11:02:16.833]             {
[11:02:16.833]                 {
[11:02:16.833]                   {
[11:02:16.833]                     base::local({
[11:02:16.833]                       has_future <- base::requireNamespace("future", 
[11:02:16.833]                         quietly = TRUE)
[11:02:16.833]                       if (has_future) {
[11:02:16.833]                         ns <- base::getNamespace("future")
[11:02:16.833]                         version <- ns[[".package"]][["version"]]
[11:02:16.833]                         if (is.null(version)) 
[11:02:16.833]                           version <- utils::packageVersion("future")
[11:02:16.833]                       }
[11:02:16.833]                       else {
[11:02:16.833]                         version <- NULL
[11:02:16.833]                       }
[11:02:16.833]                       if (!has_future || version < "1.8.0") {
[11:02:16.833]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:16.833]                           "", base::R.version$version.string), 
[11:02:16.833]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:16.833]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:16.833]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:16.833]                             "release", "version")], collapse = " "), 
[11:02:16.833]                           hostname = base::Sys.info()[["nodename"]])
[11:02:16.833]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:16.833]                           info)
[11:02:16.833]                         info <- base::paste(info, collapse = "; ")
[11:02:16.833]                         if (!has_future) {
[11:02:16.833]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:16.833]                             info)
[11:02:16.833]                         }
[11:02:16.833]                         else {
[11:02:16.833]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:16.833]                             info, version)
[11:02:16.833]                         }
[11:02:16.833]                         base::stop(msg)
[11:02:16.833]                       }
[11:02:16.833]                     })
[11:02:16.833]                   }
[11:02:16.833]                   ...future.strategy.old <- future::plan("list")
[11:02:16.833]                   options(future.plan = NULL)
[11:02:16.833]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:16.833]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:16.833]                 }
[11:02:16.833]                 ...future.workdir <- getwd()
[11:02:16.833]             }
[11:02:16.833]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:16.833]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:16.833]         }
[11:02:16.833]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:16.833]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:16.833]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:16.833]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:16.833]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:16.833]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:16.833]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:16.833]             base::names(...future.oldOptions))
[11:02:16.833]     }
[11:02:16.833]     if (FALSE) {
[11:02:16.833]     }
[11:02:16.833]     else {
[11:02:16.833]         if (TRUE) {
[11:02:16.833]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:16.833]                 open = "w")
[11:02:16.833]         }
[11:02:16.833]         else {
[11:02:16.833]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:16.833]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:16.833]         }
[11:02:16.833]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:16.833]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:16.833]             base::sink(type = "output", split = FALSE)
[11:02:16.833]             base::close(...future.stdout)
[11:02:16.833]         }, add = TRUE)
[11:02:16.833]     }
[11:02:16.833]     ...future.frame <- base::sys.nframe()
[11:02:16.833]     ...future.conditions <- base::list()
[11:02:16.833]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:16.833]     if (FALSE) {
[11:02:16.833]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:16.833]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:16.833]     }
[11:02:16.833]     ...future.result <- base::tryCatch({
[11:02:16.833]         base::withCallingHandlers({
[11:02:16.833]             ...future.value <- base::withVisible(base::local({
[11:02:16.833]                 b <- 2L
[11:02:16.833]                 plan_b <- future::plan("list")
[11:02:16.833]                 nested_b <- nested_a[-1]
[11:02:16.833]                 stopifnot(length(nested_b) == 0L, length(plan_b) == 
[11:02:16.833]                   1L, inherits(plan_b[[1]], "future"), inherits(future::plan("next"), 
[11:02:16.833]                   "sequential"))
[11:02:16.833]                 list(a = a, nested_a = nested_a, plan_a = plan_a, 
[11:02:16.833]                   b = b, nested_b = nested_b, plan_b = plan_b)
[11:02:16.833]             }))
[11:02:16.833]             future::FutureResult(value = ...future.value$value, 
[11:02:16.833]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:16.833]                   ...future.rng), globalenv = if (FALSE) 
[11:02:16.833]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:16.833]                     ...future.globalenv.names))
[11:02:16.833]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:16.833]         }, condition = base::local({
[11:02:16.833]             c <- base::c
[11:02:16.833]             inherits <- base::inherits
[11:02:16.833]             invokeRestart <- base::invokeRestart
[11:02:16.833]             length <- base::length
[11:02:16.833]             list <- base::list
[11:02:16.833]             seq.int <- base::seq.int
[11:02:16.833]             signalCondition <- base::signalCondition
[11:02:16.833]             sys.calls <- base::sys.calls
[11:02:16.833]             `[[` <- base::`[[`
[11:02:16.833]             `+` <- base::`+`
[11:02:16.833]             `<<-` <- base::`<<-`
[11:02:16.833]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:16.833]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:16.833]                   3L)]
[11:02:16.833]             }
[11:02:16.833]             function(cond) {
[11:02:16.833]                 is_error <- inherits(cond, "error")
[11:02:16.833]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:16.833]                   NULL)
[11:02:16.833]                 if (is_error) {
[11:02:16.833]                   sessionInformation <- function() {
[11:02:16.833]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:16.833]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:16.833]                       search = base::search(), system = base::Sys.info())
[11:02:16.833]                   }
[11:02:16.833]                   ...future.conditions[[length(...future.conditions) + 
[11:02:16.833]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:16.833]                     cond$call), session = sessionInformation(), 
[11:02:16.833]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:16.833]                   signalCondition(cond)
[11:02:16.833]                 }
[11:02:16.833]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:16.833]                 "immediateCondition"))) {
[11:02:16.833]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:16.833]                   ...future.conditions[[length(...future.conditions) + 
[11:02:16.833]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:16.833]                   if (TRUE && !signal) {
[11:02:16.833]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.833]                     {
[11:02:16.833]                       inherits <- base::inherits
[11:02:16.833]                       invokeRestart <- base::invokeRestart
[11:02:16.833]                       is.null <- base::is.null
[11:02:16.833]                       muffled <- FALSE
[11:02:16.833]                       if (inherits(cond, "message")) {
[11:02:16.833]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:16.833]                         if (muffled) 
[11:02:16.833]                           invokeRestart("muffleMessage")
[11:02:16.833]                       }
[11:02:16.833]                       else if (inherits(cond, "warning")) {
[11:02:16.833]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:16.833]                         if (muffled) 
[11:02:16.833]                           invokeRestart("muffleWarning")
[11:02:16.833]                       }
[11:02:16.833]                       else if (inherits(cond, "condition")) {
[11:02:16.833]                         if (!is.null(pattern)) {
[11:02:16.833]                           computeRestarts <- base::computeRestarts
[11:02:16.833]                           grepl <- base::grepl
[11:02:16.833]                           restarts <- computeRestarts(cond)
[11:02:16.833]                           for (restart in restarts) {
[11:02:16.833]                             name <- restart$name
[11:02:16.833]                             if (is.null(name)) 
[11:02:16.833]                               next
[11:02:16.833]                             if (!grepl(pattern, name)) 
[11:02:16.833]                               next
[11:02:16.833]                             invokeRestart(restart)
[11:02:16.833]                             muffled <- TRUE
[11:02:16.833]                             break
[11:02:16.833]                           }
[11:02:16.833]                         }
[11:02:16.833]                       }
[11:02:16.833]                       invisible(muffled)
[11:02:16.833]                     }
[11:02:16.833]                     muffleCondition(cond, pattern = "^muffle")
[11:02:16.833]                   }
[11:02:16.833]                 }
[11:02:16.833]                 else {
[11:02:16.833]                   if (TRUE) {
[11:02:16.833]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.833]                     {
[11:02:16.833]                       inherits <- base::inherits
[11:02:16.833]                       invokeRestart <- base::invokeRestart
[11:02:16.833]                       is.null <- base::is.null
[11:02:16.833]                       muffled <- FALSE
[11:02:16.833]                       if (inherits(cond, "message")) {
[11:02:16.833]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:16.833]                         if (muffled) 
[11:02:16.833]                           invokeRestart("muffleMessage")
[11:02:16.833]                       }
[11:02:16.833]                       else if (inherits(cond, "warning")) {
[11:02:16.833]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:16.833]                         if (muffled) 
[11:02:16.833]                           invokeRestart("muffleWarning")
[11:02:16.833]                       }
[11:02:16.833]                       else if (inherits(cond, "condition")) {
[11:02:16.833]                         if (!is.null(pattern)) {
[11:02:16.833]                           computeRestarts <- base::computeRestarts
[11:02:16.833]                           grepl <- base::grepl
[11:02:16.833]                           restarts <- computeRestarts(cond)
[11:02:16.833]                           for (restart in restarts) {
[11:02:16.833]                             name <- restart$name
[11:02:16.833]                             if (is.null(name)) 
[11:02:16.833]                               next
[11:02:16.833]                             if (!grepl(pattern, name)) 
[11:02:16.833]                               next
[11:02:16.833]                             invokeRestart(restart)
[11:02:16.833]                             muffled <- TRUE
[11:02:16.833]                             break
[11:02:16.833]                           }
[11:02:16.833]                         }
[11:02:16.833]                       }
[11:02:16.833]                       invisible(muffled)
[11:02:16.833]                     }
[11:02:16.833]                     muffleCondition(cond, pattern = "^muffle")
[11:02:16.833]                   }
[11:02:16.833]                 }
[11:02:16.833]             }
[11:02:16.833]         }))
[11:02:16.833]     }, error = function(ex) {
[11:02:16.833]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:16.833]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:16.833]                 ...future.rng), started = ...future.startTime, 
[11:02:16.833]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:16.833]             version = "1.8"), class = "FutureResult")
[11:02:16.833]     }, finally = {
[11:02:16.833]         if (!identical(...future.workdir, getwd())) 
[11:02:16.833]             setwd(...future.workdir)
[11:02:16.833]         {
[11:02:16.833]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:16.833]                 ...future.oldOptions$nwarnings <- NULL
[11:02:16.833]             }
[11:02:16.833]             base::options(...future.oldOptions)
[11:02:16.833]             if (.Platform$OS.type == "windows") {
[11:02:16.833]                 old_names <- names(...future.oldEnvVars)
[11:02:16.833]                 envs <- base::Sys.getenv()
[11:02:16.833]                 names <- names(envs)
[11:02:16.833]                 common <- intersect(names, old_names)
[11:02:16.833]                 added <- setdiff(names, old_names)
[11:02:16.833]                 removed <- setdiff(old_names, names)
[11:02:16.833]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:16.833]                   envs[common]]
[11:02:16.833]                 NAMES <- toupper(changed)
[11:02:16.833]                 args <- list()
[11:02:16.833]                 for (kk in seq_along(NAMES)) {
[11:02:16.833]                   name <- changed[[kk]]
[11:02:16.833]                   NAME <- NAMES[[kk]]
[11:02:16.833]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.833]                     next
[11:02:16.833]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:16.833]                 }
[11:02:16.833]                 NAMES <- toupper(added)
[11:02:16.833]                 for (kk in seq_along(NAMES)) {
[11:02:16.833]                   name <- added[[kk]]
[11:02:16.833]                   NAME <- NAMES[[kk]]
[11:02:16.833]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.833]                     next
[11:02:16.833]                   args[[name]] <- ""
[11:02:16.833]                 }
[11:02:16.833]                 NAMES <- toupper(removed)
[11:02:16.833]                 for (kk in seq_along(NAMES)) {
[11:02:16.833]                   name <- removed[[kk]]
[11:02:16.833]                   NAME <- NAMES[[kk]]
[11:02:16.833]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.833]                     next
[11:02:16.833]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:16.833]                 }
[11:02:16.833]                 if (length(args) > 0) 
[11:02:16.833]                   base::do.call(base::Sys.setenv, args = args)
[11:02:16.833]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:16.833]             }
[11:02:16.833]             else {
[11:02:16.833]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:16.833]             }
[11:02:16.833]             {
[11:02:16.833]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:16.833]                   0L) {
[11:02:16.833]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:16.833]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:16.833]                   base::options(opts)
[11:02:16.833]                 }
[11:02:16.833]                 {
[11:02:16.833]                   {
[11:02:16.833]                     NULL
[11:02:16.833]                     RNGkind("Mersenne-Twister")
[11:02:16.833]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:16.833]                       inherits = FALSE)
[11:02:16.833]                   }
[11:02:16.833]                   options(future.plan = NULL)
[11:02:16.833]                   if (is.na(NA_character_)) 
[11:02:16.833]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:16.833]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:16.833]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:16.833]                     .init = FALSE)
[11:02:16.833]                 }
[11:02:16.833]             }
[11:02:16.833]         }
[11:02:16.833]     })
[11:02:16.833]     if (TRUE) {
[11:02:16.833]         base::sink(type = "output", split = FALSE)
[11:02:16.833]         if (TRUE) {
[11:02:16.833]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:16.833]         }
[11:02:16.833]         else {
[11:02:16.833]             ...future.result["stdout"] <- base::list(NULL)
[11:02:16.833]         }
[11:02:16.833]         base::close(...future.stdout)
[11:02:16.833]         ...future.stdout <- NULL
[11:02:16.833]     }
[11:02:16.833]     ...future.result$conditions <- ...future.conditions
[11:02:16.833]     ...future.result$finished <- base::Sys.time()
[11:02:16.833]     ...future.result
[11:02:16.833] }
[11:02:16.863]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.835] assign_globals() ...
[11:02:16.864]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.835] List of 3
[11:02:16.835]  $ nested_a:List of 1
[11:02:16.835]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[11:02:16.835]     envir = parent.frame())  
[11:02:16.835]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[11:02:16.835]   .. ..- attr(*, "cleanup")=function ()  
[11:02:16.835]   .. ..- attr(*, "untweakable")= chr "persistent"
[11:02:16.835]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[11:02:16.835]  $ a       : int 1
[11:02:16.835]  $ plan_a  :List of 1
[11:02:16.835]   ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
[11:02:16.835]     envir = parent.frame())  
[11:02:16.835]   .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
[11:02:16.835]   .. ..- attr(*, "cleanup")=function ()  
[11:02:16.835]   .. ..- attr(*, "untweakable")= chr "persistent"
[11:02:16.835]   .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
[11:02:16.835]  - attr(*, "where")=List of 3
[11:02:16.835]   ..$ nested_a:<environment: R_EmptyEnv> 
[11:02:16.835]   ..$ a       :<environment: R_EmptyEnv> 
[11:02:16.835]   ..$ plan_a  :<environment: R_EmptyEnv> 
[11:02:16.835]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:02:16.835]  - attr(*, "resolved")= logi FALSE
[11:02:16.835]  - attr(*, "total_size")= num 12089
[11:02:16.835]  - attr(*, "already-done")= logi TRUE
[11:02:16.864]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.844] - copied ‘nested_a’ to environment
[11:02:16.864]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.845] - copied ‘a’ to environment
[11:02:16.864]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.845] - copied ‘plan_a’ to environment
[11:02:16.864]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.845] assign_globals() ... done
[11:02:16.864]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.846] plan(): Setting new future strategy stack:
[11:02:16.865]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.846] List of future strategies:
[11:02:16.846] 1. sequential:
[11:02:16.846]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:16.846]    - tweaked: FALSE
[11:02:16.846]    - call: NULL
[11:02:16.865]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.846] plan(): nbrOfWorkers() = 1
[11:02:16.865]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.848] plan(): Setting new future strategy stack:
[11:02:16.865]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.848] List of future strategies:
[11:02:16.848] 1. multisession:
[11:02:16.848]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:02:16.848]    - tweaked: FALSE
[11:02:16.848]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:16.865]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.850] plan(): nbrOfWorkers() = 1
[11:02:16.865]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.850] SequentialFuture started (and completed)
[11:02:16.865]  - Condition #53: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.850] - Launch lazy future ... done
[11:02:16.866]  - Condition #54: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.850] run() for ‘SequentialFuture’ ... done
[11:02:16.866] signalConditions() ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "cleanup")=function ()  
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "cleanup")=function ()  
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[11:02:16.873] getGlobalsAndPackages() ...
[11:02:16.873] Searching for globals...
[11:02:16.875] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[11:02:16.875] Searching for globals ... DONE
[11:02:16.875] Resolving globals: FALSE
[11:02:16.876] The total size of the 1 globals is 356 bytes (356 bytes)
[11:02:16.876] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[11:02:16.877] - globals: [1] ‘data’
[11:02:16.877] - packages: [1] ‘future’
[11:02:16.877] getGlobalsAndPackages() ... DONE
[11:02:16.877] run() for ‘Future’ ...
[11:02:16.877] - state: ‘created’
[11:02:16.878] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:02:16.880] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:16.880] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:02:16.880]   - Field: ‘label’
[11:02:16.880]   - Field: ‘local’
[11:02:16.880]   - Field: ‘owner’
[11:02:16.880]   - Field: ‘envir’
[11:02:16.881]   - Field: ‘workers’
[11:02:16.881]   - Field: ‘packages’
[11:02:16.881]   - Field: ‘gc’
[11:02:16.881]   - Field: ‘job’
[11:02:16.881]   - Field: ‘conditions’
[11:02:16.881]   - Field: ‘expr’
[11:02:16.881]   - Field: ‘uuid’
[11:02:16.881]   - Field: ‘seed’
[11:02:16.882]   - Field: ‘version’
[11:02:16.882]   - Field: ‘result’
[11:02:16.882]   - Field: ‘asynchronous’
[11:02:16.882]   - Field: ‘calls’
[11:02:16.882]   - Field: ‘globals’
[11:02:16.882]   - Field: ‘stdout’
[11:02:16.882]   - Field: ‘earlySignal’
[11:02:16.882]   - Field: ‘lazy’
[11:02:16.882]   - Field: ‘state’
[11:02:16.883] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:02:16.883] - Launch lazy future ...
[11:02:16.883] Packages needed by the future expression (n = 1): ‘future’
[11:02:16.883] Packages needed by future strategies (n = 1): ‘future’
[11:02:16.884] {
[11:02:16.884]     {
[11:02:16.884]         {
[11:02:16.884]             ...future.startTime <- base::Sys.time()
[11:02:16.884]             {
[11:02:16.884]                 {
[11:02:16.884]                   {
[11:02:16.884]                     {
[11:02:16.884]                       {
[11:02:16.884]                         base::local({
[11:02:16.884]                           has_future <- base::requireNamespace("future", 
[11:02:16.884]                             quietly = TRUE)
[11:02:16.884]                           if (has_future) {
[11:02:16.884]                             ns <- base::getNamespace("future")
[11:02:16.884]                             version <- ns[[".package"]][["version"]]
[11:02:16.884]                             if (is.null(version)) 
[11:02:16.884]                               version <- utils::packageVersion("future")
[11:02:16.884]                           }
[11:02:16.884]                           else {
[11:02:16.884]                             version <- NULL
[11:02:16.884]                           }
[11:02:16.884]                           if (!has_future || version < "1.8.0") {
[11:02:16.884]                             info <- base::c(r_version = base::gsub("R version ", 
[11:02:16.884]                               "", base::R.version$version.string), 
[11:02:16.884]                               platform = base::sprintf("%s (%s-bit)", 
[11:02:16.884]                                 base::R.version$platform, 8 * 
[11:02:16.884]                                   base::.Machine$sizeof.pointer), 
[11:02:16.884]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:16.884]                                 "release", "version")], collapse = " "), 
[11:02:16.884]                               hostname = base::Sys.info()[["nodename"]])
[11:02:16.884]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:02:16.884]                               info)
[11:02:16.884]                             info <- base::paste(info, collapse = "; ")
[11:02:16.884]                             if (!has_future) {
[11:02:16.884]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:16.884]                                 info)
[11:02:16.884]                             }
[11:02:16.884]                             else {
[11:02:16.884]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:16.884]                                 info, version)
[11:02:16.884]                             }
[11:02:16.884]                             base::stop(msg)
[11:02:16.884]                           }
[11:02:16.884]                         })
[11:02:16.884]                       }
[11:02:16.884]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:16.884]                       base::options(mc.cores = 1L)
[11:02:16.884]                     }
[11:02:16.884]                     base::local({
[11:02:16.884]                       for (pkg in "future") {
[11:02:16.884]                         base::loadNamespace(pkg)
[11:02:16.884]                         base::library(pkg, character.only = TRUE)
[11:02:16.884]                       }
[11:02:16.884]                     })
[11:02:16.884]                   }
[11:02:16.884]                   ...future.strategy.old <- future::plan("list")
[11:02:16.884]                   options(future.plan = NULL)
[11:02:16.884]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:16.884]                   future::plan(list(b = function (..., workers = availableCores(), 
[11:02:16.884]                     lazy = FALSE, rscript_libs = .libPaths(), 
[11:02:16.884]                     envir = parent.frame()) 
[11:02:16.884]                   {
[11:02:16.884]                     if (is.function(workers)) 
[11:02:16.884]                       workers <- workers()
[11:02:16.884]                     workers <- structure(as.integer(workers), 
[11:02:16.884]                       class = class(workers))
[11:02:16.884]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[11:02:16.884]                       workers >= 1)
[11:02:16.884]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[11:02:16.884]                       return(sequential(..., lazy = TRUE, envir = envir))
[11:02:16.884]                     }
[11:02:16.884]                     future <- MultisessionFuture(..., workers = workers, 
[11:02:16.884]                       lazy = lazy, rscript_libs = rscript_libs, 
[11:02:16.884]                       envir = envir)
[11:02:16.884]                     if (!future$lazy) 
[11:02:16.884]                       future <- run(future)
[11:02:16.884]                     invisible(future)
[11:02:16.884]                   }), .cleanup = FALSE, .init = FALSE)
[11:02:16.884]                 }
[11:02:16.884]                 ...future.workdir <- getwd()
[11:02:16.884]             }
[11:02:16.884]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:16.884]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:16.884]         }
[11:02:16.884]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:16.884]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:16.884]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:16.884]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:16.884]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:16.884]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:16.884]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:16.884]             base::names(...future.oldOptions))
[11:02:16.884]     }
[11:02:16.884]     if (FALSE) {
[11:02:16.884]     }
[11:02:16.884]     else {
[11:02:16.884]         if (TRUE) {
[11:02:16.884]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:16.884]                 open = "w")
[11:02:16.884]         }
[11:02:16.884]         else {
[11:02:16.884]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:16.884]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:16.884]         }
[11:02:16.884]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:16.884]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:16.884]             base::sink(type = "output", split = FALSE)
[11:02:16.884]             base::close(...future.stdout)
[11:02:16.884]         }, add = TRUE)
[11:02:16.884]     }
[11:02:16.884]     ...future.frame <- base::sys.nframe()
[11:02:16.884]     ...future.conditions <- base::list()
[11:02:16.884]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:16.884]     if (FALSE) {
[11:02:16.884]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:16.884]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:16.884]     }
[11:02:16.884]     ...future.result <- base::tryCatch({
[11:02:16.884]         base::withCallingHandlers({
[11:02:16.884]             ...future.value <- base::withVisible(base::local({
[11:02:16.884]                 withCallingHandlers({
[11:02:16.884]                   {
[11:02:16.884]                     value(future(subset(data, a == 2)))
[11:02:16.884]                   }
[11:02:16.884]                 }, immediateCondition = function(cond) {
[11:02:16.884]                   save_rds <- function (object, pathname, ...) 
[11:02:16.884]                   {
[11:02:16.884]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:02:16.884]                     if (file_test("-f", pathname_tmp)) {
[11:02:16.884]                       fi_tmp <- file.info(pathname_tmp)
[11:02:16.884]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:02:16.884]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:16.884]                         fi_tmp[["mtime"]])
[11:02:16.884]                     }
[11:02:16.884]                     tryCatch({
[11:02:16.884]                       saveRDS(object, file = pathname_tmp, ...)
[11:02:16.884]                     }, error = function(ex) {
[11:02:16.884]                       msg <- conditionMessage(ex)
[11:02:16.884]                       fi_tmp <- file.info(pathname_tmp)
[11:02:16.884]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:02:16.884]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:16.884]                         fi_tmp[["mtime"]], msg)
[11:02:16.884]                       ex$message <- msg
[11:02:16.884]                       stop(ex)
[11:02:16.884]                     })
[11:02:16.884]                     stopifnot(file_test("-f", pathname_tmp))
[11:02:16.884]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:02:16.884]                     if (!res || file_test("-f", pathname_tmp)) {
[11:02:16.884]                       fi_tmp <- file.info(pathname_tmp)
[11:02:16.884]                       fi <- file.info(pathname)
[11:02:16.884]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:02:16.884]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:02:16.884]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:02:16.884]                         fi[["size"]], fi[["mtime"]])
[11:02:16.884]                       stop(msg)
[11:02:16.884]                     }
[11:02:16.884]                     invisible(pathname)
[11:02:16.884]                   }
[11:02:16.884]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:02:16.884]                     rootPath = tempdir()) 
[11:02:16.884]                   {
[11:02:16.884]                     obj <- list(time = Sys.time(), condition = cond)
[11:02:16.884]                     file <- tempfile(pattern = class(cond)[1], 
[11:02:16.884]                       tmpdir = path, fileext = ".rds")
[11:02:16.884]                     save_rds(obj, file)
[11:02:16.884]                   }
[11:02:16.884]                   saveImmediateCondition(cond, path = "/tmp/RtmpVZPEla/.future/immediateConditions")
[11:02:16.884]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.884]                   {
[11:02:16.884]                     inherits <- base::inherits
[11:02:16.884]                     invokeRestart <- base::invokeRestart
[11:02:16.884]                     is.null <- base::is.null
[11:02:16.884]                     muffled <- FALSE
[11:02:16.884]                     if (inherits(cond, "message")) {
[11:02:16.884]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:16.884]                       if (muffled) 
[11:02:16.884]                         invokeRestart("muffleMessage")
[11:02:16.884]                     }
[11:02:16.884]                     else if (inherits(cond, "warning")) {
[11:02:16.884]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:16.884]                       if (muffled) 
[11:02:16.884]                         invokeRestart("muffleWarning")
[11:02:16.884]                     }
[11:02:16.884]                     else if (inherits(cond, "condition")) {
[11:02:16.884]                       if (!is.null(pattern)) {
[11:02:16.884]                         computeRestarts <- base::computeRestarts
[11:02:16.884]                         grepl <- base::grepl
[11:02:16.884]                         restarts <- computeRestarts(cond)
[11:02:16.884]                         for (restart in restarts) {
[11:02:16.884]                           name <- restart$name
[11:02:16.884]                           if (is.null(name)) 
[11:02:16.884]                             next
[11:02:16.884]                           if (!grepl(pattern, name)) 
[11:02:16.884]                             next
[11:02:16.884]                           invokeRestart(restart)
[11:02:16.884]                           muffled <- TRUE
[11:02:16.884]                           break
[11:02:16.884]                         }
[11:02:16.884]                       }
[11:02:16.884]                     }
[11:02:16.884]                     invisible(muffled)
[11:02:16.884]                   }
[11:02:16.884]                   muffleCondition(cond)
[11:02:16.884]                 })
[11:02:16.884]             }))
[11:02:16.884]             future::FutureResult(value = ...future.value$value, 
[11:02:16.884]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:16.884]                   ...future.rng), globalenv = if (FALSE) 
[11:02:16.884]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:16.884]                     ...future.globalenv.names))
[11:02:16.884]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:16.884]         }, condition = base::local({
[11:02:16.884]             c <- base::c
[11:02:16.884]             inherits <- base::inherits
[11:02:16.884]             invokeRestart <- base::invokeRestart
[11:02:16.884]             length <- base::length
[11:02:16.884]             list <- base::list
[11:02:16.884]             seq.int <- base::seq.int
[11:02:16.884]             signalCondition <- base::signalCondition
[11:02:16.884]             sys.calls <- base::sys.calls
[11:02:16.884]             `[[` <- base::`[[`
[11:02:16.884]             `+` <- base::`+`
[11:02:16.884]             `<<-` <- base::`<<-`
[11:02:16.884]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:16.884]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:16.884]                   3L)]
[11:02:16.884]             }
[11:02:16.884]             function(cond) {
[11:02:16.884]                 is_error <- inherits(cond, "error")
[11:02:16.884]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:16.884]                   NULL)
[11:02:16.884]                 if (is_error) {
[11:02:16.884]                   sessionInformation <- function() {
[11:02:16.884]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:16.884]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:16.884]                       search = base::search(), system = base::Sys.info())
[11:02:16.884]                   }
[11:02:16.884]                   ...future.conditions[[length(...future.conditions) + 
[11:02:16.884]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:16.884]                     cond$call), session = sessionInformation(), 
[11:02:16.884]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:16.884]                   signalCondition(cond)
[11:02:16.884]                 }
[11:02:16.884]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:16.884]                 "immediateCondition"))) {
[11:02:16.884]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:16.884]                   ...future.conditions[[length(...future.conditions) + 
[11:02:16.884]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:16.884]                   if (TRUE && !signal) {
[11:02:16.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.884]                     {
[11:02:16.884]                       inherits <- base::inherits
[11:02:16.884]                       invokeRestart <- base::invokeRestart
[11:02:16.884]                       is.null <- base::is.null
[11:02:16.884]                       muffled <- FALSE
[11:02:16.884]                       if (inherits(cond, "message")) {
[11:02:16.884]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:16.884]                         if (muffled) 
[11:02:16.884]                           invokeRestart("muffleMessage")
[11:02:16.884]                       }
[11:02:16.884]                       else if (inherits(cond, "warning")) {
[11:02:16.884]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:16.884]                         if (muffled) 
[11:02:16.884]                           invokeRestart("muffleWarning")
[11:02:16.884]                       }
[11:02:16.884]                       else if (inherits(cond, "condition")) {
[11:02:16.884]                         if (!is.null(pattern)) {
[11:02:16.884]                           computeRestarts <- base::computeRestarts
[11:02:16.884]                           grepl <- base::grepl
[11:02:16.884]                           restarts <- computeRestarts(cond)
[11:02:16.884]                           for (restart in restarts) {
[11:02:16.884]                             name <- restart$name
[11:02:16.884]                             if (is.null(name)) 
[11:02:16.884]                               next
[11:02:16.884]                             if (!grepl(pattern, name)) 
[11:02:16.884]                               next
[11:02:16.884]                             invokeRestart(restart)
[11:02:16.884]                             muffled <- TRUE
[11:02:16.884]                             break
[11:02:16.884]                           }
[11:02:16.884]                         }
[11:02:16.884]                       }
[11:02:16.884]                       invisible(muffled)
[11:02:16.884]                     }
[11:02:16.884]                     muffleCondition(cond, pattern = "^muffle")
[11:02:16.884]                   }
[11:02:16.884]                 }
[11:02:16.884]                 else {
[11:02:16.884]                   if (TRUE) {
[11:02:16.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.884]                     {
[11:02:16.884]                       inherits <- base::inherits
[11:02:16.884]                       invokeRestart <- base::invokeRestart
[11:02:16.884]                       is.null <- base::is.null
[11:02:16.884]                       muffled <- FALSE
[11:02:16.884]                       if (inherits(cond, "message")) {
[11:02:16.884]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:16.884]                         if (muffled) 
[11:02:16.884]                           invokeRestart("muffleMessage")
[11:02:16.884]                       }
[11:02:16.884]                       else if (inherits(cond, "warning")) {
[11:02:16.884]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:16.884]                         if (muffled) 
[11:02:16.884]                           invokeRestart("muffleWarning")
[11:02:16.884]                       }
[11:02:16.884]                       else if (inherits(cond, "condition")) {
[11:02:16.884]                         if (!is.null(pattern)) {
[11:02:16.884]                           computeRestarts <- base::computeRestarts
[11:02:16.884]                           grepl <- base::grepl
[11:02:16.884]                           restarts <- computeRestarts(cond)
[11:02:16.884]                           for (restart in restarts) {
[11:02:16.884]                             name <- restart$name
[11:02:16.884]                             if (is.null(name)) 
[11:02:16.884]                               next
[11:02:16.884]                             if (!grepl(pattern, name)) 
[11:02:16.884]                               next
[11:02:16.884]                             invokeRestart(restart)
[11:02:16.884]                             muffled <- TRUE
[11:02:16.884]                             break
[11:02:16.884]                           }
[11:02:16.884]                         }
[11:02:16.884]                       }
[11:02:16.884]                       invisible(muffled)
[11:02:16.884]                     }
[11:02:16.884]                     muffleCondition(cond, pattern = "^muffle")
[11:02:16.884]                   }
[11:02:16.884]                 }
[11:02:16.884]             }
[11:02:16.884]         }))
[11:02:16.884]     }, error = function(ex) {
[11:02:16.884]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:16.884]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:16.884]                 ...future.rng), started = ...future.startTime, 
[11:02:16.884]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:16.884]             version = "1.8"), class = "FutureResult")
[11:02:16.884]     }, finally = {
[11:02:16.884]         if (!identical(...future.workdir, getwd())) 
[11:02:16.884]             setwd(...future.workdir)
[11:02:16.884]         {
[11:02:16.884]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:16.884]                 ...future.oldOptions$nwarnings <- NULL
[11:02:16.884]             }
[11:02:16.884]             base::options(...future.oldOptions)
[11:02:16.884]             if (.Platform$OS.type == "windows") {
[11:02:16.884]                 old_names <- names(...future.oldEnvVars)
[11:02:16.884]                 envs <- base::Sys.getenv()
[11:02:16.884]                 names <- names(envs)
[11:02:16.884]                 common <- intersect(names, old_names)
[11:02:16.884]                 added <- setdiff(names, old_names)
[11:02:16.884]                 removed <- setdiff(old_names, names)
[11:02:16.884]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:16.884]                   envs[common]]
[11:02:16.884]                 NAMES <- toupper(changed)
[11:02:16.884]                 args <- list()
[11:02:16.884]                 for (kk in seq_along(NAMES)) {
[11:02:16.884]                   name <- changed[[kk]]
[11:02:16.884]                   NAME <- NAMES[[kk]]
[11:02:16.884]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.884]                     next
[11:02:16.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:16.884]                 }
[11:02:16.884]                 NAMES <- toupper(added)
[11:02:16.884]                 for (kk in seq_along(NAMES)) {
[11:02:16.884]                   name <- added[[kk]]
[11:02:16.884]                   NAME <- NAMES[[kk]]
[11:02:16.884]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.884]                     next
[11:02:16.884]                   args[[name]] <- ""
[11:02:16.884]                 }
[11:02:16.884]                 NAMES <- toupper(removed)
[11:02:16.884]                 for (kk in seq_along(NAMES)) {
[11:02:16.884]                   name <- removed[[kk]]
[11:02:16.884]                   NAME <- NAMES[[kk]]
[11:02:16.884]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.884]                     next
[11:02:16.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:16.884]                 }
[11:02:16.884]                 if (length(args) > 0) 
[11:02:16.884]                   base::do.call(base::Sys.setenv, args = args)
[11:02:16.884]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:16.884]             }
[11:02:16.884]             else {
[11:02:16.884]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:16.884]             }
[11:02:16.884]             {
[11:02:16.884]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:16.884]                   0L) {
[11:02:16.884]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:16.884]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:16.884]                   base::options(opts)
[11:02:16.884]                 }
[11:02:16.884]                 {
[11:02:16.884]                   {
[11:02:16.884]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:16.884]                     NULL
[11:02:16.884]                   }
[11:02:16.884]                   options(future.plan = NULL)
[11:02:16.884]                   if (is.na(NA_character_)) 
[11:02:16.884]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:16.884]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:16.884]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:16.884]                     .init = FALSE)
[11:02:16.884]                 }
[11:02:16.884]             }
[11:02:16.884]         }
[11:02:16.884]     })
[11:02:16.884]     if (TRUE) {
[11:02:16.884]         base::sink(type = "output", split = FALSE)
[11:02:16.884]         if (TRUE) {
[11:02:16.884]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:16.884]         }
[11:02:16.884]         else {
[11:02:16.884]             ...future.result["stdout"] <- base::list(NULL)
[11:02:16.884]         }
[11:02:16.884]         base::close(...future.stdout)
[11:02:16.884]         ...future.stdout <- NULL
[11:02:16.884]     }
[11:02:16.884]     ...future.result$conditions <- ...future.conditions
[11:02:16.884]     ...future.result$finished <- base::Sys.time()
[11:02:16.884]     ...future.result
[11:02:16.884] }
[11:02:16.887] assign_globals() ...
[11:02:16.887] List of 1
[11:02:16.887]  $ data:'data.frame':	3 obs. of  2 variables:
[11:02:16.887]   ..$ a: int [1:3] 1 2 3
[11:02:16.887]   ..$ b: int [1:3] 3 2 1
[11:02:16.887]  - attr(*, "where")=List of 1
[11:02:16.887]   ..$ data:<environment: R_EmptyEnv> 
[11:02:16.887]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:02:16.887]  - attr(*, "resolved")= logi FALSE
[11:02:16.887]  - attr(*, "total_size")= num 356
[11:02:16.887]  - attr(*, "already-done")= logi TRUE
[11:02:16.890] - copied ‘data’ to environment
[11:02:16.890] assign_globals() ... done
[11:02:16.890] requestCore(): workers = 2
[11:02:16.892] MulticoreFuture started
[11:02:16.893] - Launch lazy future ... done
[11:02:16.893] run() for ‘MulticoreFuture’ ... done
[11:02:16.893] result() for MulticoreFuture ...
[11:02:16.894] plan(): Setting new future strategy stack:
[11:02:16.894] List of future strategies:
[11:02:16.894] 1. multisession:
[11:02:16.894]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:02:16.894]    - tweaked: FALSE
[11:02:16.894]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:16.897] plan(): nbrOfWorkers() = 1
[11:02:16.922] plan(): Setting new future strategy stack:
[11:02:16.923] List of future strategies:
[11:02:16.923] 1. multicore:
[11:02:16.923]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:16.923]    - tweaked: FALSE
[11:02:16.923]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:16.923] 2. multisession:
[11:02:16.923]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:02:16.923]    - tweaked: FALSE
[11:02:16.923]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:16.925] plan(): nbrOfWorkers() = 2
[11:02:16.926] result() for MulticoreFuture ...
[11:02:16.926] result() for MulticoreFuture ... done
[11:02:16.926] signalConditions() ...
[11:02:16.926]  - include = ‘immediateCondition’
[11:02:16.926]  - exclude = 
[11:02:16.926]  - resignal = FALSE
[11:02:16.926]  - Number of conditions: 52
[11:02:16.927] signalConditions() ... done
[11:02:16.927] result() for MulticoreFuture ... done
[11:02:16.927] result() for MulticoreFuture ...
[11:02:16.927] result() for MulticoreFuture ... done
[11:02:16.927] signalConditions() ...
[11:02:16.927]  - include = ‘immediateCondition’
[11:02:16.927]  - exclude = 
[11:02:16.927]  - resignal = FALSE
[11:02:16.927]  - Number of conditions: 52
[11:02:16.928] signalConditions() ... done
[11:02:16.928] Future state: ‘finished’
[11:02:16.928] result() for MulticoreFuture ...
[11:02:16.928] result() for MulticoreFuture ... done
[11:02:16.928] signalConditions() ...
[11:02:16.928]  - include = ‘condition’
[11:02:16.928]  - exclude = ‘immediateCondition’
[11:02:16.928]  - resignal = TRUE
[11:02:16.928]  - Number of conditions: 52
[11:02:16.929]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.898] getGlobalsAndPackages() ...
[11:02:16.929]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.899] Searching for globals...
[11:02:16.929]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.900] - globals found: [4] ‘subset’, ‘data’, ‘==’, ‘a’
[11:02:16.929]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.900] Searching for globals ... DONE
[11:02:16.929]  - Condition #5: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.901] Resolving globals: FALSE
[11:02:16.929]  - Condition #6: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.901] The total size of the 1 globals is 356 bytes (356 bytes)
[11:02:16.929]  - Condition #7: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.902] The total size of the 1 globals exported for future expression (‘subset(data, a == 2)’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[11:02:16.930]  - Condition #8: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.902] - globals: [1] ‘data’
[11:02:16.930]  - Condition #9: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.902] 
[11:02:16.930]  - Condition #10: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.902] getGlobalsAndPackages() ... DONE
[11:02:16.930]  - Condition #11: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.903] run() for ‘Future’ ...
[11:02:16.930]  - Condition #12: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.903] - state: ‘created’
[11:02:16.930]  - Condition #13: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.904] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:16.931]  - Condition #14: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.905] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:02:16.931]  - Condition #15: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.906] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:02:16.931]  - Condition #16: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.906]   - Field: ‘label’
[11:02:16.931]  - Condition #17: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.906]   - Field: ‘local’
[11:02:16.931]  - Condition #18: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.906]   - Field: ‘owner’
[11:02:16.931]  - Condition #19: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.906]   - Field: ‘envir’
[11:02:16.931]  - Condition #20: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.906]   - Field: ‘packages’
[11:02:16.932]  - Condition #21: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.907]   - Field: ‘gc’
[11:02:16.932]  - Condition #22: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.907]   - Field: ‘conditions’
[11:02:16.932]  - Condition #23: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.907]   - Field: ‘expr’
[11:02:16.932]  - Condition #24: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.907]   - Field: ‘uuid’
[11:02:16.932]  - Condition #25: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.907]   - Field: ‘seed’
[11:02:16.932]  - Condition #26: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.907]   - Field: ‘version’
[11:02:16.932]  - Condition #27: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.908]   - Field: ‘result’
[11:02:16.933]  - Condition #28: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.908]   - Field: ‘asynchronous’
[11:02:16.933]  - Condition #29: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.908]   - Field: ‘calls’
[11:02:16.933]  - Condition #30: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.908]   - Field: ‘globals’
[11:02:16.933]  - Condition #31: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.908]   - Field: ‘stdout’
[11:02:16.933]  - Condition #32: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.908]   - Field: ‘earlySignal’
[11:02:16.933]  - Condition #33: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.908]   - Field: ‘lazy’
[11:02:16.933]  - Condition #34: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.909]   - Field: ‘state’
[11:02:16.934]  - Condition #35: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.909] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:02:16.934]  - Condition #36: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.909] - Launch lazy future ...
[11:02:16.934]  - Condition #37: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.909] Packages needed by the future expression (n = 0): <none>
[11:02:16.934]  - Condition #38: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.909] Packages needed by future strategies (n = 0): <none>
[11:02:16.934]  - Condition #39: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.910] {
[11:02:16.910]     {
[11:02:16.910]         {
[11:02:16.910]             ...future.startTime <- base::Sys.time()
[11:02:16.910]             {
[11:02:16.910]                 {
[11:02:16.910]                   {
[11:02:16.910]                     base::local({
[11:02:16.910]                       has_future <- base::requireNamespace("future", 
[11:02:16.910]                         quietly = TRUE)
[11:02:16.910]                       if (has_future) {
[11:02:16.910]                         ns <- base::getNamespace("future")
[11:02:16.910]                         version <- ns[[".package"]][["version"]]
[11:02:16.910]                         if (is.null(version)) 
[11:02:16.910]                           version <- utils::packageVersion("future")
[11:02:16.910]                       }
[11:02:16.910]                       else {
[11:02:16.910]                         version <- NULL
[11:02:16.910]                       }
[11:02:16.910]                       if (!has_future || version < "1.8.0") {
[11:02:16.910]                         info <- base::c(r_version = base::gsub("R version ", 
[11:02:16.910]                           "", base::R.version$version.string), 
[11:02:16.910]                           platform = base::sprintf("%s (%s-bit)", 
[11:02:16.910]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:02:16.910]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:16.910]                             "release", "version")], collapse = " "), 
[11:02:16.910]                           hostname = base::Sys.info()[["nodename"]])
[11:02:16.910]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:02:16.910]                           info)
[11:02:16.910]                         info <- base::paste(info, collapse = "; ")
[11:02:16.910]                         if (!has_future) {
[11:02:16.910]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:16.910]                             info)
[11:02:16.910]                         }
[11:02:16.910]                         else {
[11:02:16.910]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:16.910]                             info, version)
[11:02:16.910]                         }
[11:02:16.910]                         base::stop(msg)
[11:02:16.910]                       }
[11:02:16.910]                     })
[11:02:16.910]                   }
[11:02:16.910]                   ...future.strategy.old <- future::plan("list")
[11:02:16.910]                   options(future.plan = NULL)
[11:02:16.910]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:16.910]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:02:16.910]                 }
[11:02:16.910]                 ...future.workdir <- getwd()
[11:02:16.910]             }
[11:02:16.910]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:16.910]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:16.910]         }
[11:02:16.910]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:16.910]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:16.910]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:16.910]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:16.910]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:16.910]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:16.910]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:16.910]             base::names(...future.oldOptions))
[11:02:16.910]     }
[11:02:16.910]     if (FALSE) {
[11:02:16.910]     }
[11:02:16.910]     else {
[11:02:16.910]         if (TRUE) {
[11:02:16.910]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:16.910]                 open = "w")
[11:02:16.910]         }
[11:02:16.910]         else {
[11:02:16.910]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:16.910]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:16.910]         }
[11:02:16.910]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:16.910]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:16.910]             base::sink(type = "output", split = FALSE)
[11:02:16.910]             base::close(...future.stdout)
[11:02:16.910]         }, add = TRUE)
[11:02:16.910]     }
[11:02:16.910]     ...future.frame <- base::sys.nframe()
[11:02:16.910]     ...future.conditions <- base::list()
[11:02:16.910]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:16.910]     if (FALSE) {
[11:02:16.910]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:16.910]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:16.910]     }
[11:02:16.910]     ...future.result <- base::tryCatch({
[11:02:16.910]         base::withCallingHandlers({
[11:02:16.910]             ...future.value <- base::withVisible(base::local(subset(data, 
[11:02:16.910]                 a == 2)))
[11:02:16.910]             future::FutureResult(value = ...future.value$value, 
[11:02:16.910]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:16.910]                   ...future.rng), globalenv = if (FALSE) 
[11:02:16.910]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:16.910]                     ...future.globalenv.names))
[11:02:16.910]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:16.910]         }, condition = base::local({
[11:02:16.910]             c <- base::c
[11:02:16.910]             inherits <- base::inherits
[11:02:16.910]             invokeRestart <- base::invokeRestart
[11:02:16.910]             length <- base::length
[11:02:16.910]             list <- base::list
[11:02:16.910]             seq.int <- base::seq.int
[11:02:16.910]             signalCondition <- base::signalCondition
[11:02:16.910]             sys.calls <- base::sys.calls
[11:02:16.910]             `[[` <- base::`[[`
[11:02:16.910]             `+` <- base::`+`
[11:02:16.910]             `<<-` <- base::`<<-`
[11:02:16.910]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:16.910]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:16.910]                   3L)]
[11:02:16.910]             }
[11:02:16.910]             function(cond) {
[11:02:16.910]                 is_error <- inherits(cond, "error")
[11:02:16.910]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:16.910]                   NULL)
[11:02:16.910]                 if (is_error) {
[11:02:16.910]                   sessionInformation <- function() {
[11:02:16.910]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:16.910]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:16.910]                       search = base::search(), system = base::Sys.info())
[11:02:16.910]                   }
[11:02:16.910]                   ...future.conditions[[length(...future.conditions) + 
[11:02:16.910]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:16.910]                     cond$call), session = sessionInformation(), 
[11:02:16.910]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:16.910]                   signalCondition(cond)
[11:02:16.910]                 }
[11:02:16.910]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:16.910]                 "immediateCondition"))) {
[11:02:16.910]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:16.910]                   ...future.conditions[[length(...future.conditions) + 
[11:02:16.910]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:16.910]                   if (TRUE && !signal) {
[11:02:16.910]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.910]                     {
[11:02:16.910]                       inherits <- base::inherits
[11:02:16.910]                       invokeRestart <- base::invokeRestart
[11:02:16.910]                       is.null <- base::is.null
[11:02:16.910]                       muffled <- FALSE
[11:02:16.910]                       if (inherits(cond, "message")) {
[11:02:16.910]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:16.910]                         if (muffled) 
[11:02:16.910]                           invokeRestart("muffleMessage")
[11:02:16.910]                       }
[11:02:16.910]                       else if (inherits(cond, "warning")) {
[11:02:16.910]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:16.910]                         if (muffled) 
[11:02:16.910]                           invokeRestart("muffleWarning")
[11:02:16.910]                       }
[11:02:16.910]                       else if (inherits(cond, "condition")) {
[11:02:16.910]                         if (!is.null(pattern)) {
[11:02:16.910]                           computeRestarts <- base::computeRestarts
[11:02:16.910]                           grepl <- base::grepl
[11:02:16.910]                           restarts <- computeRestarts(cond)
[11:02:16.910]                           for (restart in restarts) {
[11:02:16.910]                             name <- restart$name
[11:02:16.910]                             if (is.null(name)) 
[11:02:16.910]                               next
[11:02:16.910]                             if (!grepl(pattern, name)) 
[11:02:16.910]                               next
[11:02:16.910]                             invokeRestart(restart)
[11:02:16.910]                             muffled <- TRUE
[11:02:16.910]                             break
[11:02:16.910]                           }
[11:02:16.910]                         }
[11:02:16.910]                       }
[11:02:16.910]                       invisible(muffled)
[11:02:16.910]                     }
[11:02:16.910]                     muffleCondition(cond, pattern = "^muffle")
[11:02:16.910]                   }
[11:02:16.910]                 }
[11:02:16.910]                 else {
[11:02:16.910]                   if (TRUE) {
[11:02:16.910]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.910]                     {
[11:02:16.910]                       inherits <- base::inherits
[11:02:16.910]                       invokeRestart <- base::invokeRestart
[11:02:16.910]                       is.null <- base::is.null
[11:02:16.910]                       muffled <- FALSE
[11:02:16.910]                       if (inherits(cond, "message")) {
[11:02:16.910]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:16.910]                         if (muffled) 
[11:02:16.910]                           invokeRestart("muffleMessage")
[11:02:16.910]                       }
[11:02:16.910]                       else if (inherits(cond, "warning")) {
[11:02:16.910]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:16.910]                         if (muffled) 
[11:02:16.910]                           invokeRestart("muffleWarning")
[11:02:16.910]                       }
[11:02:16.910]                       else if (inherits(cond, "condition")) {
[11:02:16.910]                         if (!is.null(pattern)) {
[11:02:16.910]                           computeRestarts <- base::computeRestarts
[11:02:16.910]                           grepl <- base::grepl
[11:02:16.910]                           restarts <- computeRestarts(cond)
[11:02:16.910]                           for (restart in restarts) {
[11:02:16.910]                             name <- restart$name
[11:02:16.910]                             if (is.null(name)) 
[11:02:16.910]                               next
[11:02:16.910]                             if (!grepl(pattern, name)) 
[11:02:16.910]                               next
[11:02:16.910]                             invokeRestart(restart)
[11:02:16.910]                             muffled <- TRUE
[11:02:16.910]                             break
[11:02:16.910]                           }
[11:02:16.910]                         }
[11:02:16.910]                       }
[11:02:16.910]                       invisible(muffled)
[11:02:16.910]                     }
[11:02:16.910]                     muffleCondition(cond, pattern = "^muffle")
[11:02:16.910]                   }
[11:02:16.910]                 }
[11:02:16.910]             }
[11:02:16.910]         }))
[11:02:16.910]     }, error = function(ex) {
[11:02:16.910]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:16.910]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:16.910]                 ...future.rng), started = ...future.startTime, 
[11:02:16.910]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:16.910]             version = "1.8"), class = "FutureResult")
[11:02:16.910]     }, finally = {
[11:02:16.910]         if (!identical(...future.workdir, getwd())) 
[11:02:16.910]             setwd(...future.workdir)
[11:02:16.910]         {
[11:02:16.910]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:16.910]                 ...future.oldOptions$nwarnings <- NULL
[11:02:16.910]             }
[11:02:16.910]             base::options(...future.oldOptions)
[11:02:16.910]             if (.Platform$OS.type == "windows") {
[11:02:16.910]                 old_names <- names(...future.oldEnvVars)
[11:02:16.910]                 envs <- base::Sys.getenv()
[11:02:16.910]                 names <- names(envs)
[11:02:16.910]                 common <- intersect(names, old_names)
[11:02:16.910]                 added <- setdiff(names, old_names)
[11:02:16.910]                 removed <- setdiff(old_names, names)
[11:02:16.910]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:16.910]                   envs[common]]
[11:02:16.910]                 NAMES <- toupper(changed)
[11:02:16.910]                 args <- list()
[11:02:16.910]                 for (kk in seq_along(NAMES)) {
[11:02:16.910]                   name <- changed[[kk]]
[11:02:16.910]                   NAME <- NAMES[[kk]]
[11:02:16.910]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.910]                     next
[11:02:16.910]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:16.910]                 }
[11:02:16.910]                 NAMES <- toupper(added)
[11:02:16.910]                 for (kk in seq_along(NAMES)) {
[11:02:16.910]                   name <- added[[kk]]
[11:02:16.910]                   NAME <- NAMES[[kk]]
[11:02:16.910]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.910]                     next
[11:02:16.910]                   args[[name]] <- ""
[11:02:16.910]                 }
[11:02:16.910]                 NAMES <- toupper(removed)
[11:02:16.910]                 for (kk in seq_along(NAMES)) {
[11:02:16.910]                   name <- removed[[kk]]
[11:02:16.910]                   NAME <- NAMES[[kk]]
[11:02:16.910]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.910]                     next
[11:02:16.910]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:16.910]                 }
[11:02:16.910]                 if (length(args) > 0) 
[11:02:16.910]                   base::do.call(base::Sys.setenv, args = args)
[11:02:16.910]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:16.910]             }
[11:02:16.910]             else {
[11:02:16.910]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:16.910]             }
[11:02:16.910]             {
[11:02:16.910]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:16.910]                   0L) {
[11:02:16.910]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:16.910]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:16.910]                   base::options(opts)
[11:02:16.910]                 }
[11:02:16.910]                 {
[11:02:16.910]                   {
[11:02:16.910]                     NULL
[11:02:16.910]                     RNGkind("Mersenne-Twister")
[11:02:16.910]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:02:16.910]                       inherits = FALSE)
[11:02:16.910]                   }
[11:02:16.910]                   options(future.plan = NULL)
[11:02:16.910]                   if (is.na(NA_character_)) 
[11:02:16.910]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:16.910]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:16.910]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:16.910]                     .init = FALSE)
[11:02:16.910]                 }
[11:02:16.910]             }
[11:02:16.910]         }
[11:02:16.910]     })
[11:02:16.910]     if (TRUE) {
[11:02:16.910]         base::sink(type = "output", split = FALSE)
[11:02:16.910]         if (TRUE) {
[11:02:16.910]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:16.910]         }
[11:02:16.910]         else {
[11:02:16.910]             ...future.result["stdout"] <- base::list(NULL)
[11:02:16.910]         }
[11:02:16.910]         base::close(...future.stdout)
[11:02:16.910]         ...future.stdout <- NULL
[11:02:16.910]     }
[11:02:16.910]     ...future.result$conditions <- ...future.conditions
[11:02:16.910]     ...future.result$finished <- base::Sys.time()
[11:02:16.910]     ...future.result
[11:02:16.910] }
[11:02:16.934]  - Condition #40: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.912] assign_globals() ...
[11:02:16.935]  - Condition #41: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.912] List of 1
[11:02:16.912]  $ data:'data.frame':	3 obs. of  2 variables:
[11:02:16.912]   ..$ a: int [1:3] 1 2 3
[11:02:16.912]   ..$ b: int [1:3] 3 2 1
[11:02:16.912]  - attr(*, "where")=List of 1
[11:02:16.912]   ..$ data:<environment: R_EmptyEnv> 
[11:02:16.912]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:02:16.912]  - attr(*, "resolved")= logi FALSE
[11:02:16.912]  - attr(*, "total_size")= num 356
[11:02:16.912]  - attr(*, "already-done")= logi TRUE
[11:02:16.935]  - Condition #42: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.917] - copied ‘data’ to environment
[11:02:16.935]  - Condition #43: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.917] assign_globals() ... done
[11:02:16.935]  - Condition #44: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.917] plan(): Setting new future strategy stack:
[11:02:16.935]  - Condition #45: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.918] List of future strategies:
[11:02:16.918] 1. sequential:
[11:02:16.918]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:16.918]    - tweaked: FALSE
[11:02:16.918]    - call: NULL
[11:02:16.935]  - Condition #46: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.918] plan(): nbrOfWorkers() = 1
[11:02:16.935]  - Condition #47: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.919] plan(): Setting new future strategy stack:
[11:02:16.936]  - Condition #48: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.919] List of future strategies:
[11:02:16.919] 1. multisession:
[11:02:16.919]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:02:16.919]    - tweaked: FALSE
[11:02:16.919]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:16.936]  - Condition #49: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.921] plan(): nbrOfWorkers() = 1
[11:02:16.936]  - Condition #50: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.921] SequentialFuture started (and completed)
[11:02:16.936]  - Condition #51: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.922] - Launch lazy future ... done
[11:02:16.936]  - Condition #52: ‘simpleMessage’, ‘message’, ‘condition’
[11:02:16.922] run() for ‘SequentialFuture’ ... done
[11:02:16.936] signalConditions() ... done
- plan(list('multicore', 'multisession')) ... DONE
- plan(list('multisession', 'sequential')) ...
[11:02:16.937] plan(): Setting new future strategy stack:
[11:02:16.937] List of future strategies:
[11:02:16.937] 1. multisession:
[11:02:16.937]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:02:16.937]    - tweaked: FALSE
[11:02:16.937]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:16.937] 2. sequential:
[11:02:16.937]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:16.937]    - tweaked: FALSE
[11:02:16.937]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:16.938] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[11:02:16.938] multisession:
[11:02:16.938] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:02:16.938] - tweaked: FALSE
[11:02:16.938] - call: plan(list(a = strategy1, b = strategy2))
[11:02:16.940] getGlobalsAndPackages() ...
[11:02:16.940] Not searching for globals
[11:02:16.940] - globals: [0] <none>
[11:02:16.941] getGlobalsAndPackages() ... DONE
[11:02:16.954] Packages needed by the future expression (n = 0): <none>
[11:02:16.954] Packages needed by future strategies (n = 1): ‘future’
[11:02:16.955] {
[11:02:16.955]     {
[11:02:16.955]         {
[11:02:16.955]             ...future.startTime <- base::Sys.time()
[11:02:16.955]             {
[11:02:16.955]                 {
[11:02:16.955]                   {
[11:02:16.955]                     {
[11:02:16.955]                       {
[11:02:16.955]                         base::local({
[11:02:16.955]                           has_future <- base::requireNamespace("future", 
[11:02:16.955]                             quietly = TRUE)
[11:02:16.955]                           if (has_future) {
[11:02:16.955]                             ns <- base::getNamespace("future")
[11:02:16.955]                             version <- ns[[".package"]][["version"]]
[11:02:16.955]                             if (is.null(version)) 
[11:02:16.955]                               version <- utils::packageVersion("future")
[11:02:16.955]                           }
[11:02:16.955]                           else {
[11:02:16.955]                             version <- NULL
[11:02:16.955]                           }
[11:02:16.955]                           if (!has_future || version < "1.8.0") {
[11:02:16.955]                             info <- base::c(r_version = base::gsub("R version ", 
[11:02:16.955]                               "", base::R.version$version.string), 
[11:02:16.955]                               platform = base::sprintf("%s (%s-bit)", 
[11:02:16.955]                                 base::R.version$platform, 8 * 
[11:02:16.955]                                   base::.Machine$sizeof.pointer), 
[11:02:16.955]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:16.955]                                 "release", "version")], collapse = " "), 
[11:02:16.955]                               hostname = base::Sys.info()[["nodename"]])
[11:02:16.955]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:02:16.955]                               info)
[11:02:16.955]                             info <- base::paste(info, collapse = "; ")
[11:02:16.955]                             if (!has_future) {
[11:02:16.955]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:16.955]                                 info)
[11:02:16.955]                             }
[11:02:16.955]                             else {
[11:02:16.955]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:16.955]                                 info, version)
[11:02:16.955]                             }
[11:02:16.955]                             base::stop(msg)
[11:02:16.955]                           }
[11:02:16.955]                         })
[11:02:16.955]                       }
[11:02:16.955]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:16.955]                       base::options(mc.cores = 1L)
[11:02:16.955]                     }
[11:02:16.955]                     base::local({
[11:02:16.955]                       for (pkg in "future") {
[11:02:16.955]                         base::loadNamespace(pkg)
[11:02:16.955]                         base::library(pkg, character.only = TRUE)
[11:02:16.955]                       }
[11:02:16.955]                     })
[11:02:16.955]                   }
[11:02:16.955]                   ...future.strategy.old <- future::plan("list")
[11:02:16.955]                   options(future.plan = NULL)
[11:02:16.955]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:16.955]                   future::plan(list(b = function (..., envir = parent.frame()) 
[11:02:16.955]                   {
[11:02:16.955]                     future <- SequentialFuture(..., envir = envir)
[11:02:16.955]                     if (!future$lazy) 
[11:02:16.955]                       future <- run(future)
[11:02:16.955]                     invisible(future)
[11:02:16.955]                   }), .cleanup = FALSE, .init = FALSE)
[11:02:16.955]                 }
[11:02:16.955]                 ...future.workdir <- getwd()
[11:02:16.955]             }
[11:02:16.955]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:16.955]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:16.955]         }
[11:02:16.955]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:16.955]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:16.955]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:16.955]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:16.955]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:16.955]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:16.955]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:16.955]             base::names(...future.oldOptions))
[11:02:16.955]     }
[11:02:16.955]     if (FALSE) {
[11:02:16.955]     }
[11:02:16.955]     else {
[11:02:16.955]         if (TRUE) {
[11:02:16.955]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:16.955]                 open = "w")
[11:02:16.955]         }
[11:02:16.955]         else {
[11:02:16.955]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:16.955]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:16.955]         }
[11:02:16.955]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:16.955]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:16.955]             base::sink(type = "output", split = FALSE)
[11:02:16.955]             base::close(...future.stdout)
[11:02:16.955]         }, add = TRUE)
[11:02:16.955]     }
[11:02:16.955]     ...future.frame <- base::sys.nframe()
[11:02:16.955]     ...future.conditions <- base::list()
[11:02:16.955]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:16.955]     if (FALSE) {
[11:02:16.955]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:16.955]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:16.955]     }
[11:02:16.955]     ...future.result <- base::tryCatch({
[11:02:16.955]         base::withCallingHandlers({
[11:02:16.955]             ...future.value <- base::withVisible(base::local({
[11:02:16.955]                 ...future.makeSendCondition <- base::local({
[11:02:16.955]                   sendCondition <- NULL
[11:02:16.955]                   function(frame = 1L) {
[11:02:16.955]                     if (is.function(sendCondition)) 
[11:02:16.955]                       return(sendCondition)
[11:02:16.955]                     ns <- getNamespace("parallel")
[11:02:16.955]                     if (exists("sendData", mode = "function", 
[11:02:16.955]                       envir = ns)) {
[11:02:16.955]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:16.955]                         envir = ns)
[11:02:16.955]                       envir <- sys.frame(frame)
[11:02:16.955]                       master <- NULL
[11:02:16.955]                       while (!identical(envir, .GlobalEnv) && 
[11:02:16.955]                         !identical(envir, emptyenv())) {
[11:02:16.955]                         if (exists("master", mode = "list", envir = envir, 
[11:02:16.955]                           inherits = FALSE)) {
[11:02:16.955]                           master <- get("master", mode = "list", 
[11:02:16.955]                             envir = envir, inherits = FALSE)
[11:02:16.955]                           if (inherits(master, c("SOCKnode", 
[11:02:16.955]                             "SOCK0node"))) {
[11:02:16.955]                             sendCondition <<- function(cond) {
[11:02:16.955]                               data <- list(type = "VALUE", value = cond, 
[11:02:16.955]                                 success = TRUE)
[11:02:16.955]                               parallel_sendData(master, data)
[11:02:16.955]                             }
[11:02:16.955]                             return(sendCondition)
[11:02:16.955]                           }
[11:02:16.955]                         }
[11:02:16.955]                         frame <- frame + 1L
[11:02:16.955]                         envir <- sys.frame(frame)
[11:02:16.955]                       }
[11:02:16.955]                     }
[11:02:16.955]                     sendCondition <<- function(cond) NULL
[11:02:16.955]                   }
[11:02:16.955]                 })
[11:02:16.955]                 withCallingHandlers({
[11:02:16.955]                   NA
[11:02:16.955]                 }, immediateCondition = function(cond) {
[11:02:16.955]                   sendCondition <- ...future.makeSendCondition()
[11:02:16.955]                   sendCondition(cond)
[11:02:16.955]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.955]                   {
[11:02:16.955]                     inherits <- base::inherits
[11:02:16.955]                     invokeRestart <- base::invokeRestart
[11:02:16.955]                     is.null <- base::is.null
[11:02:16.955]                     muffled <- FALSE
[11:02:16.955]                     if (inherits(cond, "message")) {
[11:02:16.955]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:16.955]                       if (muffled) 
[11:02:16.955]                         invokeRestart("muffleMessage")
[11:02:16.955]                     }
[11:02:16.955]                     else if (inherits(cond, "warning")) {
[11:02:16.955]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:16.955]                       if (muffled) 
[11:02:16.955]                         invokeRestart("muffleWarning")
[11:02:16.955]                     }
[11:02:16.955]                     else if (inherits(cond, "condition")) {
[11:02:16.955]                       if (!is.null(pattern)) {
[11:02:16.955]                         computeRestarts <- base::computeRestarts
[11:02:16.955]                         grepl <- base::grepl
[11:02:16.955]                         restarts <- computeRestarts(cond)
[11:02:16.955]                         for (restart in restarts) {
[11:02:16.955]                           name <- restart$name
[11:02:16.955]                           if (is.null(name)) 
[11:02:16.955]                             next
[11:02:16.955]                           if (!grepl(pattern, name)) 
[11:02:16.955]                             next
[11:02:16.955]                           invokeRestart(restart)
[11:02:16.955]                           muffled <- TRUE
[11:02:16.955]                           break
[11:02:16.955]                         }
[11:02:16.955]                       }
[11:02:16.955]                     }
[11:02:16.955]                     invisible(muffled)
[11:02:16.955]                   }
[11:02:16.955]                   muffleCondition(cond)
[11:02:16.955]                 })
[11:02:16.955]             }))
[11:02:16.955]             future::FutureResult(value = ...future.value$value, 
[11:02:16.955]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:16.955]                   ...future.rng), globalenv = if (FALSE) 
[11:02:16.955]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:16.955]                     ...future.globalenv.names))
[11:02:16.955]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:16.955]         }, condition = base::local({
[11:02:16.955]             c <- base::c
[11:02:16.955]             inherits <- base::inherits
[11:02:16.955]             invokeRestart <- base::invokeRestart
[11:02:16.955]             length <- base::length
[11:02:16.955]             list <- base::list
[11:02:16.955]             seq.int <- base::seq.int
[11:02:16.955]             signalCondition <- base::signalCondition
[11:02:16.955]             sys.calls <- base::sys.calls
[11:02:16.955]             `[[` <- base::`[[`
[11:02:16.955]             `+` <- base::`+`
[11:02:16.955]             `<<-` <- base::`<<-`
[11:02:16.955]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:16.955]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:16.955]                   3L)]
[11:02:16.955]             }
[11:02:16.955]             function(cond) {
[11:02:16.955]                 is_error <- inherits(cond, "error")
[11:02:16.955]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:16.955]                   NULL)
[11:02:16.955]                 if (is_error) {
[11:02:16.955]                   sessionInformation <- function() {
[11:02:16.955]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:16.955]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:16.955]                       search = base::search(), system = base::Sys.info())
[11:02:16.955]                   }
[11:02:16.955]                   ...future.conditions[[length(...future.conditions) + 
[11:02:16.955]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:16.955]                     cond$call), session = sessionInformation(), 
[11:02:16.955]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:16.955]                   signalCondition(cond)
[11:02:16.955]                 }
[11:02:16.955]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:16.955]                 "immediateCondition"))) {
[11:02:16.955]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:16.955]                   ...future.conditions[[length(...future.conditions) + 
[11:02:16.955]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:16.955]                   if (TRUE && !signal) {
[11:02:16.955]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.955]                     {
[11:02:16.955]                       inherits <- base::inherits
[11:02:16.955]                       invokeRestart <- base::invokeRestart
[11:02:16.955]                       is.null <- base::is.null
[11:02:16.955]                       muffled <- FALSE
[11:02:16.955]                       if (inherits(cond, "message")) {
[11:02:16.955]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:16.955]                         if (muffled) 
[11:02:16.955]                           invokeRestart("muffleMessage")
[11:02:16.955]                       }
[11:02:16.955]                       else if (inherits(cond, "warning")) {
[11:02:16.955]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:16.955]                         if (muffled) 
[11:02:16.955]                           invokeRestart("muffleWarning")
[11:02:16.955]                       }
[11:02:16.955]                       else if (inherits(cond, "condition")) {
[11:02:16.955]                         if (!is.null(pattern)) {
[11:02:16.955]                           computeRestarts <- base::computeRestarts
[11:02:16.955]                           grepl <- base::grepl
[11:02:16.955]                           restarts <- computeRestarts(cond)
[11:02:16.955]                           for (restart in restarts) {
[11:02:16.955]                             name <- restart$name
[11:02:16.955]                             if (is.null(name)) 
[11:02:16.955]                               next
[11:02:16.955]                             if (!grepl(pattern, name)) 
[11:02:16.955]                               next
[11:02:16.955]                             invokeRestart(restart)
[11:02:16.955]                             muffled <- TRUE
[11:02:16.955]                             break
[11:02:16.955]                           }
[11:02:16.955]                         }
[11:02:16.955]                       }
[11:02:16.955]                       invisible(muffled)
[11:02:16.955]                     }
[11:02:16.955]                     muffleCondition(cond, pattern = "^muffle")
[11:02:16.955]                   }
[11:02:16.955]                 }
[11:02:16.955]                 else {
[11:02:16.955]                   if (TRUE) {
[11:02:16.955]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:16.955]                     {
[11:02:16.955]                       inherits <- base::inherits
[11:02:16.955]                       invokeRestart <- base::invokeRestart
[11:02:16.955]                       is.null <- base::is.null
[11:02:16.955]                       muffled <- FALSE
[11:02:16.955]                       if (inherits(cond, "message")) {
[11:02:16.955]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:16.955]                         if (muffled) 
[11:02:16.955]                           invokeRestart("muffleMessage")
[11:02:16.955]                       }
[11:02:16.955]                       else if (inherits(cond, "warning")) {
[11:02:16.955]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:16.955]                         if (muffled) 
[11:02:16.955]                           invokeRestart("muffleWarning")
[11:02:16.955]                       }
[11:02:16.955]                       else if (inherits(cond, "condition")) {
[11:02:16.955]                         if (!is.null(pattern)) {
[11:02:16.955]                           computeRestarts <- base::computeRestarts
[11:02:16.955]                           grepl <- base::grepl
[11:02:16.955]                           restarts <- computeRestarts(cond)
[11:02:16.955]                           for (restart in restarts) {
[11:02:16.955]                             name <- restart$name
[11:02:16.955]                             if (is.null(name)) 
[11:02:16.955]                               next
[11:02:16.955]                             if (!grepl(pattern, name)) 
[11:02:16.955]                               next
[11:02:16.955]                             invokeRestart(restart)
[11:02:16.955]                             muffled <- TRUE
[11:02:16.955]                             break
[11:02:16.955]                           }
[11:02:16.955]                         }
[11:02:16.955]                       }
[11:02:16.955]                       invisible(muffled)
[11:02:16.955]                     }
[11:02:16.955]                     muffleCondition(cond, pattern = "^muffle")
[11:02:16.955]                   }
[11:02:16.955]                 }
[11:02:16.955]             }
[11:02:16.955]         }))
[11:02:16.955]     }, error = function(ex) {
[11:02:16.955]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:16.955]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:16.955]                 ...future.rng), started = ...future.startTime, 
[11:02:16.955]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:16.955]             version = "1.8"), class = "FutureResult")
[11:02:16.955]     }, finally = {
[11:02:16.955]         if (!identical(...future.workdir, getwd())) 
[11:02:16.955]             setwd(...future.workdir)
[11:02:16.955]         {
[11:02:16.955]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:16.955]                 ...future.oldOptions$nwarnings <- NULL
[11:02:16.955]             }
[11:02:16.955]             base::options(...future.oldOptions)
[11:02:16.955]             if (.Platform$OS.type == "windows") {
[11:02:16.955]                 old_names <- names(...future.oldEnvVars)
[11:02:16.955]                 envs <- base::Sys.getenv()
[11:02:16.955]                 names <- names(envs)
[11:02:16.955]                 common <- intersect(names, old_names)
[11:02:16.955]                 added <- setdiff(names, old_names)
[11:02:16.955]                 removed <- setdiff(old_names, names)
[11:02:16.955]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:16.955]                   envs[common]]
[11:02:16.955]                 NAMES <- toupper(changed)
[11:02:16.955]                 args <- list()
[11:02:16.955]                 for (kk in seq_along(NAMES)) {
[11:02:16.955]                   name <- changed[[kk]]
[11:02:16.955]                   NAME <- NAMES[[kk]]
[11:02:16.955]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.955]                     next
[11:02:16.955]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:16.955]                 }
[11:02:16.955]                 NAMES <- toupper(added)
[11:02:16.955]                 for (kk in seq_along(NAMES)) {
[11:02:16.955]                   name <- added[[kk]]
[11:02:16.955]                   NAME <- NAMES[[kk]]
[11:02:16.955]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.955]                     next
[11:02:16.955]                   args[[name]] <- ""
[11:02:16.955]                 }
[11:02:16.955]                 NAMES <- toupper(removed)
[11:02:16.955]                 for (kk in seq_along(NAMES)) {
[11:02:16.955]                   name <- removed[[kk]]
[11:02:16.955]                   NAME <- NAMES[[kk]]
[11:02:16.955]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:16.955]                     next
[11:02:16.955]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:16.955]                 }
[11:02:16.955]                 if (length(args) > 0) 
[11:02:16.955]                   base::do.call(base::Sys.setenv, args = args)
[11:02:16.955]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:16.955]             }
[11:02:16.955]             else {
[11:02:16.955]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:16.955]             }
[11:02:16.955]             {
[11:02:16.955]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:16.955]                   0L) {
[11:02:16.955]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:16.955]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:16.955]                   base::options(opts)
[11:02:16.955]                 }
[11:02:16.955]                 {
[11:02:16.955]                   {
[11:02:16.955]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:16.955]                     NULL
[11:02:16.955]                   }
[11:02:16.955]                   options(future.plan = NULL)
[11:02:16.955]                   if (is.na(NA_character_)) 
[11:02:16.955]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:16.955]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:16.955]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:16.955]                     .init = FALSE)
[11:02:16.955]                 }
[11:02:16.955]             }
[11:02:16.955]         }
[11:02:16.955]     })
[11:02:16.955]     if (TRUE) {
[11:02:16.955]         base::sink(type = "output", split = FALSE)
[11:02:16.955]         if (TRUE) {
[11:02:16.955]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:16.955]         }
[11:02:16.955]         else {
[11:02:16.955]             ...future.result["stdout"] <- base::list(NULL)
[11:02:16.955]         }
[11:02:16.955]         base::close(...future.stdout)
[11:02:16.955]         ...future.stdout <- NULL
[11:02:16.955]     }
[11:02:16.955]     ...future.result$conditions <- ...future.conditions
[11:02:16.955]     ...future.result$finished <- base::Sys.time()
[11:02:16.955]     ...future.result
[11:02:16.955] }
[11:02:16.958] MultisessionFuture started
[11:02:16.958] result() for ClusterFuture ...
[11:02:16.959] receiveMessageFromWorker() for ClusterFuture ...
[11:02:16.959] - Validating connection of MultisessionFuture
[11:02:17.003] - received message: FutureResult
[11:02:17.003] - Received FutureResult
[11:02:17.003] - Erased future from FutureRegistry
[11:02:17.004] result() for ClusterFuture ...
[11:02:17.004] - result already collected: FutureResult
[11:02:17.004] result() for ClusterFuture ... done
[11:02:17.004] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:17.004] result() for ClusterFuture ... done
[11:02:17.004] result() for ClusterFuture ...
[11:02:17.004] - result already collected: FutureResult
[11:02:17.004] result() for ClusterFuture ... done
[11:02:17.004] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[11:02:17.006] plan(): nbrOfWorkers() = 2
[11:02:17.006] getGlobalsAndPackages() ...
[11:02:17.006] Searching for globals...
[11:02:17.027] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[11:02:17.027] Searching for globals ... DONE
[11:02:17.028] Resolving globals: FALSE
[11:02:17.028] The total size of the 2 globals is 7.46 KiB (7637 bytes)
[11:02:17.029] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 7.46 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (7.41 KiB of class ‘list’) and ‘strategy2’ (49 bytes of class ‘character’)
[11:02:17.029] - globals: [2] ‘nested’, ‘strategy2’
[11:02:17.029] - packages: [1] ‘future’
[11:02:17.029] getGlobalsAndPackages() ... DONE
[11:02:17.030] run() for ‘Future’ ...
[11:02:17.030] - state: ‘created’
[11:02:17.030] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:17.044] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:17.044] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:17.044]   - Field: ‘node’
[11:02:17.044]   - Field: ‘label’
[11:02:17.044]   - Field: ‘local’
[11:02:17.045]   - Field: ‘owner’
[11:02:17.045]   - Field: ‘envir’
[11:02:17.045]   - Field: ‘workers’
[11:02:17.045]   - Field: ‘packages’
[11:02:17.045]   - Field: ‘gc’
[11:02:17.045]   - Field: ‘conditions’
[11:02:17.045]   - Field: ‘persistent’
[11:02:17.045]   - Field: ‘expr’
[11:02:17.045]   - Field: ‘uuid’
[11:02:17.045]   - Field: ‘seed’
[11:02:17.045]   - Field: ‘version’
[11:02:17.046]   - Field: ‘result’
[11:02:17.046]   - Field: ‘asynchronous’
[11:02:17.046]   - Field: ‘calls’
[11:02:17.046]   - Field: ‘globals’
[11:02:17.046]   - Field: ‘stdout’
[11:02:17.046]   - Field: ‘earlySignal’
[11:02:17.046]   - Field: ‘lazy’
[11:02:17.046]   - Field: ‘state’
[11:02:17.046] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:17.046] - Launch lazy future ...
[11:02:17.047] Packages needed by the future expression (n = 1): ‘future’
[11:02:17.047] Packages needed by future strategies (n = 1): ‘future’
[11:02:17.047] {
[11:02:17.047]     {
[11:02:17.047]         {
[11:02:17.047]             ...future.startTime <- base::Sys.time()
[11:02:17.047]             {
[11:02:17.047]                 {
[11:02:17.047]                   {
[11:02:17.047]                     {
[11:02:17.047]                       {
[11:02:17.047]                         base::local({
[11:02:17.047]                           has_future <- base::requireNamespace("future", 
[11:02:17.047]                             quietly = TRUE)
[11:02:17.047]                           if (has_future) {
[11:02:17.047]                             ns <- base::getNamespace("future")
[11:02:17.047]                             version <- ns[[".package"]][["version"]]
[11:02:17.047]                             if (is.null(version)) 
[11:02:17.047]                               version <- utils::packageVersion("future")
[11:02:17.047]                           }
[11:02:17.047]                           else {
[11:02:17.047]                             version <- NULL
[11:02:17.047]                           }
[11:02:17.047]                           if (!has_future || version < "1.8.0") {
[11:02:17.047]                             info <- base::c(r_version = base::gsub("R version ", 
[11:02:17.047]                               "", base::R.version$version.string), 
[11:02:17.047]                               platform = base::sprintf("%s (%s-bit)", 
[11:02:17.047]                                 base::R.version$platform, 8 * 
[11:02:17.047]                                   base::.Machine$sizeof.pointer), 
[11:02:17.047]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:17.047]                                 "release", "version")], collapse = " "), 
[11:02:17.047]                               hostname = base::Sys.info()[["nodename"]])
[11:02:17.047]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:02:17.047]                               info)
[11:02:17.047]                             info <- base::paste(info, collapse = "; ")
[11:02:17.047]                             if (!has_future) {
[11:02:17.047]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:17.047]                                 info)
[11:02:17.047]                             }
[11:02:17.047]                             else {
[11:02:17.047]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:17.047]                                 info, version)
[11:02:17.047]                             }
[11:02:17.047]                             base::stop(msg)
[11:02:17.047]                           }
[11:02:17.047]                         })
[11:02:17.047]                       }
[11:02:17.047]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:17.047]                       base::options(mc.cores = 1L)
[11:02:17.047]                     }
[11:02:17.047]                     base::local({
[11:02:17.047]                       for (pkg in "future") {
[11:02:17.047]                         base::loadNamespace(pkg)
[11:02:17.047]                         base::library(pkg, character.only = TRUE)
[11:02:17.047]                       }
[11:02:17.047]                     })
[11:02:17.047]                   }
[11:02:17.047]                   ...future.strategy.old <- future::plan("list")
[11:02:17.047]                   options(future.plan = NULL)
[11:02:17.047]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:17.047]                   future::plan(list(b = function (..., envir = parent.frame()) 
[11:02:17.047]                   {
[11:02:17.047]                     future <- SequentialFuture(..., envir = envir)
[11:02:17.047]                     if (!future$lazy) 
[11:02:17.047]                       future <- run(future)
[11:02:17.047]                     invisible(future)
[11:02:17.047]                   }), .cleanup = FALSE, .init = FALSE)
[11:02:17.047]                 }
[11:02:17.047]                 ...future.workdir <- getwd()
[11:02:17.047]             }
[11:02:17.047]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:17.047]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:17.047]         }
[11:02:17.047]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:17.047]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:17.047]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:17.047]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:17.047]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:17.047]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:17.047]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:17.047]             base::names(...future.oldOptions))
[11:02:17.047]     }
[11:02:17.047]     if (FALSE) {
[11:02:17.047]     }
[11:02:17.047]     else {
[11:02:17.047]         if (TRUE) {
[11:02:17.047]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:17.047]                 open = "w")
[11:02:17.047]         }
[11:02:17.047]         else {
[11:02:17.047]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:17.047]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:17.047]         }
[11:02:17.047]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:17.047]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:17.047]             base::sink(type = "output", split = FALSE)
[11:02:17.047]             base::close(...future.stdout)
[11:02:17.047]         }, add = TRUE)
[11:02:17.047]     }
[11:02:17.047]     ...future.frame <- base::sys.nframe()
[11:02:17.047]     ...future.conditions <- base::list()
[11:02:17.047]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:17.047]     if (FALSE) {
[11:02:17.047]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:17.047]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:17.047]     }
[11:02:17.047]     ...future.result <- base::tryCatch({
[11:02:17.047]         base::withCallingHandlers({
[11:02:17.047]             ...future.value <- base::withVisible(base::local({
[11:02:17.047]                 ...future.makeSendCondition <- base::local({
[11:02:17.047]                   sendCondition <- NULL
[11:02:17.047]                   function(frame = 1L) {
[11:02:17.047]                     if (is.function(sendCondition)) 
[11:02:17.047]                       return(sendCondition)
[11:02:17.047]                     ns <- getNamespace("parallel")
[11:02:17.047]                     if (exists("sendData", mode = "function", 
[11:02:17.047]                       envir = ns)) {
[11:02:17.047]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:17.047]                         envir = ns)
[11:02:17.047]                       envir <- sys.frame(frame)
[11:02:17.047]                       master <- NULL
[11:02:17.047]                       while (!identical(envir, .GlobalEnv) && 
[11:02:17.047]                         !identical(envir, emptyenv())) {
[11:02:17.047]                         if (exists("master", mode = "list", envir = envir, 
[11:02:17.047]                           inherits = FALSE)) {
[11:02:17.047]                           master <- get("master", mode = "list", 
[11:02:17.047]                             envir = envir, inherits = FALSE)
[11:02:17.047]                           if (inherits(master, c("SOCKnode", 
[11:02:17.047]                             "SOCK0node"))) {
[11:02:17.047]                             sendCondition <<- function(cond) {
[11:02:17.047]                               data <- list(type = "VALUE", value = cond, 
[11:02:17.047]                                 success = TRUE)
[11:02:17.047]                               parallel_sendData(master, data)
[11:02:17.047]                             }
[11:02:17.047]                             return(sendCondition)
[11:02:17.047]                           }
[11:02:17.047]                         }
[11:02:17.047]                         frame <- frame + 1L
[11:02:17.047]                         envir <- sys.frame(frame)
[11:02:17.047]                       }
[11:02:17.047]                     }
[11:02:17.047]                     sendCondition <<- function(cond) NULL
[11:02:17.047]                   }
[11:02:17.047]                 })
[11:02:17.047]                 withCallingHandlers({
[11:02:17.047]                   {
[11:02:17.047]                     a <- 1L
[11:02:17.047]                     plan_a <- unclass(future::plan("list"))
[11:02:17.047]                     nested_a <- nested[-1]
[11:02:17.047]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[11:02:17.047]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[11:02:17.047]                       strategy2))
[11:02:17.047]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[11:02:17.047]                       "init") <- NULL
[11:02:17.047]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[11:02:17.047]                       "init") <- NULL
[11:02:17.047]                     stopifnot(all.equal(plan_a, nested_a))
[11:02:17.047]                     y %<-% {
[11:02:17.047]                       b <- 2L
[11:02:17.047]                       plan_b <- future::plan("list")
[11:02:17.047]                       nested_b <- nested_a[-1]
[11:02:17.047]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[11:02:17.047]                         1L, inherits(plan_b[[1]], "future"), 
[11:02:17.047]                         inherits(future::plan("next"), "sequential"))
[11:02:17.047]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[11:02:17.047]                         b = b, nested_b = nested_b, plan_b = plan_b)
[11:02:17.047]                     }
[11:02:17.047]                     y
[11:02:17.047]                   }
[11:02:17.047]                 }, immediateCondition = function(cond) {
[11:02:17.047]                   sendCondition <- ...future.makeSendCondition()
[11:02:17.047]                   sendCondition(cond)
[11:02:17.047]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:17.047]                   {
[11:02:17.047]                     inherits <- base::inherits
[11:02:17.047]                     invokeRestart <- base::invokeRestart
[11:02:17.047]                     is.null <- base::is.null
[11:02:17.047]                     muffled <- FALSE
[11:02:17.047]                     if (inherits(cond, "message")) {
[11:02:17.047]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:17.047]                       if (muffled) 
[11:02:17.047]                         invokeRestart("muffleMessage")
[11:02:17.047]                     }
[11:02:17.047]                     else if (inherits(cond, "warning")) {
[11:02:17.047]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:17.047]                       if (muffled) 
[11:02:17.047]                         invokeRestart("muffleWarning")
[11:02:17.047]                     }
[11:02:17.047]                     else if (inherits(cond, "condition")) {
[11:02:17.047]                       if (!is.null(pattern)) {
[11:02:17.047]                         computeRestarts <- base::computeRestarts
[11:02:17.047]                         grepl <- base::grepl
[11:02:17.047]                         restarts <- computeRestarts(cond)
[11:02:17.047]                         for (restart in restarts) {
[11:02:17.047]                           name <- restart$name
[11:02:17.047]                           if (is.null(name)) 
[11:02:17.047]                             next
[11:02:17.047]                           if (!grepl(pattern, name)) 
[11:02:17.047]                             next
[11:02:17.047]                           invokeRestart(restart)
[11:02:17.047]                           muffled <- TRUE
[11:02:17.047]                           break
[11:02:17.047]                         }
[11:02:17.047]                       }
[11:02:17.047]                     }
[11:02:17.047]                     invisible(muffled)
[11:02:17.047]                   }
[11:02:17.047]                   muffleCondition(cond)
[11:02:17.047]                 })
[11:02:17.047]             }))
[11:02:17.047]             future::FutureResult(value = ...future.value$value, 
[11:02:17.047]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:17.047]                   ...future.rng), globalenv = if (FALSE) 
[11:02:17.047]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:17.047]                     ...future.globalenv.names))
[11:02:17.047]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:17.047]         }, condition = base::local({
[11:02:17.047]             c <- base::c
[11:02:17.047]             inherits <- base::inherits
[11:02:17.047]             invokeRestart <- base::invokeRestart
[11:02:17.047]             length <- base::length
[11:02:17.047]             list <- base::list
[11:02:17.047]             seq.int <- base::seq.int
[11:02:17.047]             signalCondition <- base::signalCondition
[11:02:17.047]             sys.calls <- base::sys.calls
[11:02:17.047]             `[[` <- base::`[[`
[11:02:17.047]             `+` <- base::`+`
[11:02:17.047]             `<<-` <- base::`<<-`
[11:02:17.047]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:17.047]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:17.047]                   3L)]
[11:02:17.047]             }
[11:02:17.047]             function(cond) {
[11:02:17.047]                 is_error <- inherits(cond, "error")
[11:02:17.047]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:17.047]                   NULL)
[11:02:17.047]                 if (is_error) {
[11:02:17.047]                   sessionInformation <- function() {
[11:02:17.047]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:17.047]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:17.047]                       search = base::search(), system = base::Sys.info())
[11:02:17.047]                   }
[11:02:17.047]                   ...future.conditions[[length(...future.conditions) + 
[11:02:17.047]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:17.047]                     cond$call), session = sessionInformation(), 
[11:02:17.047]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:17.047]                   signalCondition(cond)
[11:02:17.047]                 }
[11:02:17.047]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:17.047]                 "immediateCondition"))) {
[11:02:17.047]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:17.047]                   ...future.conditions[[length(...future.conditions) + 
[11:02:17.047]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:17.047]                   if (TRUE && !signal) {
[11:02:17.047]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:17.047]                     {
[11:02:17.047]                       inherits <- base::inherits
[11:02:17.047]                       invokeRestart <- base::invokeRestart
[11:02:17.047]                       is.null <- base::is.null
[11:02:17.047]                       muffled <- FALSE
[11:02:17.047]                       if (inherits(cond, "message")) {
[11:02:17.047]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:17.047]                         if (muffled) 
[11:02:17.047]                           invokeRestart("muffleMessage")
[11:02:17.047]                       }
[11:02:17.047]                       else if (inherits(cond, "warning")) {
[11:02:17.047]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:17.047]                         if (muffled) 
[11:02:17.047]                           invokeRestart("muffleWarning")
[11:02:17.047]                       }
[11:02:17.047]                       else if (inherits(cond, "condition")) {
[11:02:17.047]                         if (!is.null(pattern)) {
[11:02:17.047]                           computeRestarts <- base::computeRestarts
[11:02:17.047]                           grepl <- base::grepl
[11:02:17.047]                           restarts <- computeRestarts(cond)
[11:02:17.047]                           for (restart in restarts) {
[11:02:17.047]                             name <- restart$name
[11:02:17.047]                             if (is.null(name)) 
[11:02:17.047]                               next
[11:02:17.047]                             if (!grepl(pattern, name)) 
[11:02:17.047]                               next
[11:02:17.047]                             invokeRestart(restart)
[11:02:17.047]                             muffled <- TRUE
[11:02:17.047]                             break
[11:02:17.047]                           }
[11:02:17.047]                         }
[11:02:17.047]                       }
[11:02:17.047]                       invisible(muffled)
[11:02:17.047]                     }
[11:02:17.047]                     muffleCondition(cond, pattern = "^muffle")
[11:02:17.047]                   }
[11:02:17.047]                 }
[11:02:17.047]                 else {
[11:02:17.047]                   if (TRUE) {
[11:02:17.047]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:17.047]                     {
[11:02:17.047]                       inherits <- base::inherits
[11:02:17.047]                       invokeRestart <- base::invokeRestart
[11:02:17.047]                       is.null <- base::is.null
[11:02:17.047]                       muffled <- FALSE
[11:02:17.047]                       if (inherits(cond, "message")) {
[11:02:17.047]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:17.047]                         if (muffled) 
[11:02:17.047]                           invokeRestart("muffleMessage")
[11:02:17.047]                       }
[11:02:17.047]                       else if (inherits(cond, "warning")) {
[11:02:17.047]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:17.047]                         if (muffled) 
[11:02:17.047]                           invokeRestart("muffleWarning")
[11:02:17.047]                       }
[11:02:17.047]                       else if (inherits(cond, "condition")) {
[11:02:17.047]                         if (!is.null(pattern)) {
[11:02:17.047]                           computeRestarts <- base::computeRestarts
[11:02:17.047]                           grepl <- base::grepl
[11:02:17.047]                           restarts <- computeRestarts(cond)
[11:02:17.047]                           for (restart in restarts) {
[11:02:17.047]                             name <- restart$name
[11:02:17.047]                             if (is.null(name)) 
[11:02:17.047]                               next
[11:02:17.047]                             if (!grepl(pattern, name)) 
[11:02:17.047]                               next
[11:02:17.047]                             invokeRestart(restart)
[11:02:17.047]                             muffled <- TRUE
[11:02:17.047]                             break
[11:02:17.047]                           }
[11:02:17.047]                         }
[11:02:17.047]                       }
[11:02:17.047]                       invisible(muffled)
[11:02:17.047]                     }
[11:02:17.047]                     muffleCondition(cond, pattern = "^muffle")
[11:02:17.047]                   }
[11:02:17.047]                 }
[11:02:17.047]             }
[11:02:17.047]         }))
[11:02:17.047]     }, error = function(ex) {
[11:02:17.047]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:17.047]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:17.047]                 ...future.rng), started = ...future.startTime, 
[11:02:17.047]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:17.047]             version = "1.8"), class = "FutureResult")
[11:02:17.047]     }, finally = {
[11:02:17.047]         if (!identical(...future.workdir, getwd())) 
[11:02:17.047]             setwd(...future.workdir)
[11:02:17.047]         {
[11:02:17.047]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:17.047]                 ...future.oldOptions$nwarnings <- NULL
[11:02:17.047]             }
[11:02:17.047]             base::options(...future.oldOptions)
[11:02:17.047]             if (.Platform$OS.type == "windows") {
[11:02:17.047]                 old_names <- names(...future.oldEnvVars)
[11:02:17.047]                 envs <- base::Sys.getenv()
[11:02:17.047]                 names <- names(envs)
[11:02:17.047]                 common <- intersect(names, old_names)
[11:02:17.047]                 added <- setdiff(names, old_names)
[11:02:17.047]                 removed <- setdiff(old_names, names)
[11:02:17.047]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:17.047]                   envs[common]]
[11:02:17.047]                 NAMES <- toupper(changed)
[11:02:17.047]                 args <- list()
[11:02:17.047]                 for (kk in seq_along(NAMES)) {
[11:02:17.047]                   name <- changed[[kk]]
[11:02:17.047]                   NAME <- NAMES[[kk]]
[11:02:17.047]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:17.047]                     next
[11:02:17.047]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:17.047]                 }
[11:02:17.047]                 NAMES <- toupper(added)
[11:02:17.047]                 for (kk in seq_along(NAMES)) {
[11:02:17.047]                   name <- added[[kk]]
[11:02:17.047]                   NAME <- NAMES[[kk]]
[11:02:17.047]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:17.047]                     next
[11:02:17.047]                   args[[name]] <- ""
[11:02:17.047]                 }
[11:02:17.047]                 NAMES <- toupper(removed)
[11:02:17.047]                 for (kk in seq_along(NAMES)) {
[11:02:17.047]                   name <- removed[[kk]]
[11:02:17.047]                   NAME <- NAMES[[kk]]
[11:02:17.047]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:17.047]                     next
[11:02:17.047]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:17.047]                 }
[11:02:17.047]                 if (length(args) > 0) 
[11:02:17.047]                   base::do.call(base::Sys.setenv, args = args)
[11:02:17.047]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:17.047]             }
[11:02:17.047]             else {
[11:02:17.047]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:17.047]             }
[11:02:17.047]             {
[11:02:17.047]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:17.047]                   0L) {
[11:02:17.047]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:17.047]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:17.047]                   base::options(opts)
[11:02:17.047]                 }
[11:02:17.047]                 {
[11:02:17.047]                   {
[11:02:17.047]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:17.047]                     NULL
[11:02:17.047]                   }
[11:02:17.047]                   options(future.plan = NULL)
[11:02:17.047]                   if (is.na(NA_character_)) 
[11:02:17.047]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:17.047]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:17.047]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:17.047]                     .init = FALSE)
[11:02:17.047]                 }
[11:02:17.047]             }
[11:02:17.047]         }
[11:02:17.047]     })
[11:02:17.047]     if (TRUE) {
[11:02:17.047]         base::sink(type = "output", split = FALSE)
[11:02:17.047]         if (TRUE) {
[11:02:17.047]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:17.047]         }
[11:02:17.047]         else {
[11:02:17.047]             ...future.result["stdout"] <- base::list(NULL)
[11:02:17.047]         }
[11:02:17.047]         base::close(...future.stdout)
[11:02:17.047]         ...future.stdout <- NULL
[11:02:17.047]     }
[11:02:17.047]     ...future.result$conditions <- ...future.conditions
[11:02:17.047]     ...future.result$finished <- base::Sys.time()
[11:02:17.047]     ...future.result
[11:02:17.047] }
[11:02:17.050] Exporting 2 global objects (7.76 KiB) to cluster node #1 ...
[11:02:17.051] Exporting ‘nested’ (7.41 KiB) to cluster node #1 ...
[11:02:17.092] Exporting ‘nested’ (7.41 KiB) to cluster node #1 ... DONE
[11:02:17.092] Exporting ‘strategy2’ (49 bytes) to cluster node #1 ...
[11:02:17.092] Exporting ‘strategy2’ (49 bytes) to cluster node #1 ... DONE
[11:02:17.092] Exporting 2 global objects (7.76 KiB) to cluster node #1 ... DONE
[11:02:17.093] MultisessionFuture started
[11:02:17.093] - Launch lazy future ... done
[11:02:17.093] run() for ‘MultisessionFuture’ ... done
[11:02:17.093] result() for ClusterFuture ...
[11:02:17.093] receiveMessageFromWorker() for ClusterFuture ...
[11:02:17.093] - Validating connection of MultisessionFuture
[11:02:17.152] - received message: FutureResult
[11:02:17.153] - Received FutureResult
[11:02:17.153] - Erased future from FutureRegistry
[11:02:17.153] result() for ClusterFuture ...
[11:02:17.153] - result already collected: FutureResult
[11:02:17.153] result() for ClusterFuture ... done
[11:02:17.153] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:17.153] result() for ClusterFuture ... done
[11:02:17.153] result() for ClusterFuture ...
[11:02:17.154] - result already collected: FutureResult
[11:02:17.154] result() for ClusterFuture ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[11:02:17.159] getGlobalsAndPackages() ...
[11:02:17.159] Searching for globals...
[11:02:17.161] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[11:02:17.161] Searching for globals ... DONE
[11:02:17.161] Resolving globals: FALSE
[11:02:17.162] The total size of the 1 globals is 356 bytes (356 bytes)
[11:02:17.162] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[11:02:17.162] - globals: [1] ‘data’
[11:02:17.162] - packages: [1] ‘future’
[11:02:17.163] getGlobalsAndPackages() ... DONE
[11:02:17.163] run() for ‘Future’ ...
[11:02:17.163] - state: ‘created’
[11:02:17.163] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:17.177] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:17.178] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:17.178]   - Field: ‘node’
[11:02:17.178]   - Field: ‘label’
[11:02:17.178]   - Field: ‘local’
[11:02:17.178]   - Field: ‘owner’
[11:02:17.178]   - Field: ‘envir’
[11:02:17.178]   - Field: ‘workers’
[11:02:17.178]   - Field: ‘packages’
[11:02:17.178]   - Field: ‘gc’
[11:02:17.178]   - Field: ‘conditions’
[11:02:17.179]   - Field: ‘persistent’
[11:02:17.179]   - Field: ‘expr’
[11:02:17.179]   - Field: ‘uuid’
[11:02:17.179]   - Field: ‘seed’
[11:02:17.179]   - Field: ‘version’
[11:02:17.179]   - Field: ‘result’
[11:02:17.179]   - Field: ‘asynchronous’
[11:02:17.179]   - Field: ‘calls’
[11:02:17.179]   - Field: ‘globals’
[11:02:17.179]   - Field: ‘stdout’
[11:02:17.180]   - Field: ‘earlySignal’
[11:02:17.180]   - Field: ‘lazy’
[11:02:17.180]   - Field: ‘state’
[11:02:17.180] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:17.180] - Launch lazy future ...
[11:02:17.180] Packages needed by the future expression (n = 1): ‘future’
[11:02:17.180] Packages needed by future strategies (n = 1): ‘future’
[11:02:17.181] {
[11:02:17.181]     {
[11:02:17.181]         {
[11:02:17.181]             ...future.startTime <- base::Sys.time()
[11:02:17.181]             {
[11:02:17.181]                 {
[11:02:17.181]                   {
[11:02:17.181]                     {
[11:02:17.181]                       {
[11:02:17.181]                         base::local({
[11:02:17.181]                           has_future <- base::requireNamespace("future", 
[11:02:17.181]                             quietly = TRUE)
[11:02:17.181]                           if (has_future) {
[11:02:17.181]                             ns <- base::getNamespace("future")
[11:02:17.181]                             version <- ns[[".package"]][["version"]]
[11:02:17.181]                             if (is.null(version)) 
[11:02:17.181]                               version <- utils::packageVersion("future")
[11:02:17.181]                           }
[11:02:17.181]                           else {
[11:02:17.181]                             version <- NULL
[11:02:17.181]                           }
[11:02:17.181]                           if (!has_future || version < "1.8.0") {
[11:02:17.181]                             info <- base::c(r_version = base::gsub("R version ", 
[11:02:17.181]                               "", base::R.version$version.string), 
[11:02:17.181]                               platform = base::sprintf("%s (%s-bit)", 
[11:02:17.181]                                 base::R.version$platform, 8 * 
[11:02:17.181]                                   base::.Machine$sizeof.pointer), 
[11:02:17.181]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:17.181]                                 "release", "version")], collapse = " "), 
[11:02:17.181]                               hostname = base::Sys.info()[["nodename"]])
[11:02:17.181]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:02:17.181]                               info)
[11:02:17.181]                             info <- base::paste(info, collapse = "; ")
[11:02:17.181]                             if (!has_future) {
[11:02:17.181]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:17.181]                                 info)
[11:02:17.181]                             }
[11:02:17.181]                             else {
[11:02:17.181]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:17.181]                                 info, version)
[11:02:17.181]                             }
[11:02:17.181]                             base::stop(msg)
[11:02:17.181]                           }
[11:02:17.181]                         })
[11:02:17.181]                       }
[11:02:17.181]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:17.181]                       base::options(mc.cores = 1L)
[11:02:17.181]                     }
[11:02:17.181]                     base::local({
[11:02:17.181]                       for (pkg in "future") {
[11:02:17.181]                         base::loadNamespace(pkg)
[11:02:17.181]                         base::library(pkg, character.only = TRUE)
[11:02:17.181]                       }
[11:02:17.181]                     })
[11:02:17.181]                   }
[11:02:17.181]                   ...future.strategy.old <- future::plan("list")
[11:02:17.181]                   options(future.plan = NULL)
[11:02:17.181]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:17.181]                   future::plan(list(b = function (..., envir = parent.frame()) 
[11:02:17.181]                   {
[11:02:17.181]                     future <- SequentialFuture(..., envir = envir)
[11:02:17.181]                     if (!future$lazy) 
[11:02:17.181]                       future <- run(future)
[11:02:17.181]                     invisible(future)
[11:02:17.181]                   }), .cleanup = FALSE, .init = FALSE)
[11:02:17.181]                 }
[11:02:17.181]                 ...future.workdir <- getwd()
[11:02:17.181]             }
[11:02:17.181]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:17.181]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:17.181]         }
[11:02:17.181]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:17.181]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:17.181]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:17.181]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:17.181]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:17.181]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:17.181]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:17.181]             base::names(...future.oldOptions))
[11:02:17.181]     }
[11:02:17.181]     if (FALSE) {
[11:02:17.181]     }
[11:02:17.181]     else {
[11:02:17.181]         if (TRUE) {
[11:02:17.181]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:17.181]                 open = "w")
[11:02:17.181]         }
[11:02:17.181]         else {
[11:02:17.181]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:17.181]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:17.181]         }
[11:02:17.181]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:17.181]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:17.181]             base::sink(type = "output", split = FALSE)
[11:02:17.181]             base::close(...future.stdout)
[11:02:17.181]         }, add = TRUE)
[11:02:17.181]     }
[11:02:17.181]     ...future.frame <- base::sys.nframe()
[11:02:17.181]     ...future.conditions <- base::list()
[11:02:17.181]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:17.181]     if (FALSE) {
[11:02:17.181]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:17.181]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:17.181]     }
[11:02:17.181]     ...future.result <- base::tryCatch({
[11:02:17.181]         base::withCallingHandlers({
[11:02:17.181]             ...future.value <- base::withVisible(base::local({
[11:02:17.181]                 ...future.makeSendCondition <- base::local({
[11:02:17.181]                   sendCondition <- NULL
[11:02:17.181]                   function(frame = 1L) {
[11:02:17.181]                     if (is.function(sendCondition)) 
[11:02:17.181]                       return(sendCondition)
[11:02:17.181]                     ns <- getNamespace("parallel")
[11:02:17.181]                     if (exists("sendData", mode = "function", 
[11:02:17.181]                       envir = ns)) {
[11:02:17.181]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:17.181]                         envir = ns)
[11:02:17.181]                       envir <- sys.frame(frame)
[11:02:17.181]                       master <- NULL
[11:02:17.181]                       while (!identical(envir, .GlobalEnv) && 
[11:02:17.181]                         !identical(envir, emptyenv())) {
[11:02:17.181]                         if (exists("master", mode = "list", envir = envir, 
[11:02:17.181]                           inherits = FALSE)) {
[11:02:17.181]                           master <- get("master", mode = "list", 
[11:02:17.181]                             envir = envir, inherits = FALSE)
[11:02:17.181]                           if (inherits(master, c("SOCKnode", 
[11:02:17.181]                             "SOCK0node"))) {
[11:02:17.181]                             sendCondition <<- function(cond) {
[11:02:17.181]                               data <- list(type = "VALUE", value = cond, 
[11:02:17.181]                                 success = TRUE)
[11:02:17.181]                               parallel_sendData(master, data)
[11:02:17.181]                             }
[11:02:17.181]                             return(sendCondition)
[11:02:17.181]                           }
[11:02:17.181]                         }
[11:02:17.181]                         frame <- frame + 1L
[11:02:17.181]                         envir <- sys.frame(frame)
[11:02:17.181]                       }
[11:02:17.181]                     }
[11:02:17.181]                     sendCondition <<- function(cond) NULL
[11:02:17.181]                   }
[11:02:17.181]                 })
[11:02:17.181]                 withCallingHandlers({
[11:02:17.181]                   {
[11:02:17.181]                     value(future(subset(data, a == 2)))
[11:02:17.181]                   }
[11:02:17.181]                 }, immediateCondition = function(cond) {
[11:02:17.181]                   sendCondition <- ...future.makeSendCondition()
[11:02:17.181]                   sendCondition(cond)
[11:02:17.181]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:17.181]                   {
[11:02:17.181]                     inherits <- base::inherits
[11:02:17.181]                     invokeRestart <- base::invokeRestart
[11:02:17.181]                     is.null <- base::is.null
[11:02:17.181]                     muffled <- FALSE
[11:02:17.181]                     if (inherits(cond, "message")) {
[11:02:17.181]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:17.181]                       if (muffled) 
[11:02:17.181]                         invokeRestart("muffleMessage")
[11:02:17.181]                     }
[11:02:17.181]                     else if (inherits(cond, "warning")) {
[11:02:17.181]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:17.181]                       if (muffled) 
[11:02:17.181]                         invokeRestart("muffleWarning")
[11:02:17.181]                     }
[11:02:17.181]                     else if (inherits(cond, "condition")) {
[11:02:17.181]                       if (!is.null(pattern)) {
[11:02:17.181]                         computeRestarts <- base::computeRestarts
[11:02:17.181]                         grepl <- base::grepl
[11:02:17.181]                         restarts <- computeRestarts(cond)
[11:02:17.181]                         for (restart in restarts) {
[11:02:17.181]                           name <- restart$name
[11:02:17.181]                           if (is.null(name)) 
[11:02:17.181]                             next
[11:02:17.181]                           if (!grepl(pattern, name)) 
[11:02:17.181]                             next
[11:02:17.181]                           invokeRestart(restart)
[11:02:17.181]                           muffled <- TRUE
[11:02:17.181]                           break
[11:02:17.181]                         }
[11:02:17.181]                       }
[11:02:17.181]                     }
[11:02:17.181]                     invisible(muffled)
[11:02:17.181]                   }
[11:02:17.181]                   muffleCondition(cond)
[11:02:17.181]                 })
[11:02:17.181]             }))
[11:02:17.181]             future::FutureResult(value = ...future.value$value, 
[11:02:17.181]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:17.181]                   ...future.rng), globalenv = if (FALSE) 
[11:02:17.181]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:17.181]                     ...future.globalenv.names))
[11:02:17.181]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:17.181]         }, condition = base::local({
[11:02:17.181]             c <- base::c
[11:02:17.181]             inherits <- base::inherits
[11:02:17.181]             invokeRestart <- base::invokeRestart
[11:02:17.181]             length <- base::length
[11:02:17.181]             list <- base::list
[11:02:17.181]             seq.int <- base::seq.int
[11:02:17.181]             signalCondition <- base::signalCondition
[11:02:17.181]             sys.calls <- base::sys.calls
[11:02:17.181]             `[[` <- base::`[[`
[11:02:17.181]             `+` <- base::`+`
[11:02:17.181]             `<<-` <- base::`<<-`
[11:02:17.181]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:17.181]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:17.181]                   3L)]
[11:02:17.181]             }
[11:02:17.181]             function(cond) {
[11:02:17.181]                 is_error <- inherits(cond, "error")
[11:02:17.181]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:17.181]                   NULL)
[11:02:17.181]                 if (is_error) {
[11:02:17.181]                   sessionInformation <- function() {
[11:02:17.181]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:17.181]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:17.181]                       search = base::search(), system = base::Sys.info())
[11:02:17.181]                   }
[11:02:17.181]                   ...future.conditions[[length(...future.conditions) + 
[11:02:17.181]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:17.181]                     cond$call), session = sessionInformation(), 
[11:02:17.181]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:17.181]                   signalCondition(cond)
[11:02:17.181]                 }
[11:02:17.181]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:17.181]                 "immediateCondition"))) {
[11:02:17.181]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:17.181]                   ...future.conditions[[length(...future.conditions) + 
[11:02:17.181]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:17.181]                   if (TRUE && !signal) {
[11:02:17.181]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:17.181]                     {
[11:02:17.181]                       inherits <- base::inherits
[11:02:17.181]                       invokeRestart <- base::invokeRestart
[11:02:17.181]                       is.null <- base::is.null
[11:02:17.181]                       muffled <- FALSE
[11:02:17.181]                       if (inherits(cond, "message")) {
[11:02:17.181]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:17.181]                         if (muffled) 
[11:02:17.181]                           invokeRestart("muffleMessage")
[11:02:17.181]                       }
[11:02:17.181]                       else if (inherits(cond, "warning")) {
[11:02:17.181]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:17.181]                         if (muffled) 
[11:02:17.181]                           invokeRestart("muffleWarning")
[11:02:17.181]                       }
[11:02:17.181]                       else if (inherits(cond, "condition")) {
[11:02:17.181]                         if (!is.null(pattern)) {
[11:02:17.181]                           computeRestarts <- base::computeRestarts
[11:02:17.181]                           grepl <- base::grepl
[11:02:17.181]                           restarts <- computeRestarts(cond)
[11:02:17.181]                           for (restart in restarts) {
[11:02:17.181]                             name <- restart$name
[11:02:17.181]                             if (is.null(name)) 
[11:02:17.181]                               next
[11:02:17.181]                             if (!grepl(pattern, name)) 
[11:02:17.181]                               next
[11:02:17.181]                             invokeRestart(restart)
[11:02:17.181]                             muffled <- TRUE
[11:02:17.181]                             break
[11:02:17.181]                           }
[11:02:17.181]                         }
[11:02:17.181]                       }
[11:02:17.181]                       invisible(muffled)
[11:02:17.181]                     }
[11:02:17.181]                     muffleCondition(cond, pattern = "^muffle")
[11:02:17.181]                   }
[11:02:17.181]                 }
[11:02:17.181]                 else {
[11:02:17.181]                   if (TRUE) {
[11:02:17.181]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:17.181]                     {
[11:02:17.181]                       inherits <- base::inherits
[11:02:17.181]                       invokeRestart <- base::invokeRestart
[11:02:17.181]                       is.null <- base::is.null
[11:02:17.181]                       muffled <- FALSE
[11:02:17.181]                       if (inherits(cond, "message")) {
[11:02:17.181]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:17.181]                         if (muffled) 
[11:02:17.181]                           invokeRestart("muffleMessage")
[11:02:17.181]                       }
[11:02:17.181]                       else if (inherits(cond, "warning")) {
[11:02:17.181]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:17.181]                         if (muffled) 
[11:02:17.181]                           invokeRestart("muffleWarning")
[11:02:17.181]                       }
[11:02:17.181]                       else if (inherits(cond, "condition")) {
[11:02:17.181]                         if (!is.null(pattern)) {
[11:02:17.181]                           computeRestarts <- base::computeRestarts
[11:02:17.181]                           grepl <- base::grepl
[11:02:17.181]                           restarts <- computeRestarts(cond)
[11:02:17.181]                           for (restart in restarts) {
[11:02:17.181]                             name <- restart$name
[11:02:17.181]                             if (is.null(name)) 
[11:02:17.181]                               next
[11:02:17.181]                             if (!grepl(pattern, name)) 
[11:02:17.181]                               next
[11:02:17.181]                             invokeRestart(restart)
[11:02:17.181]                             muffled <- TRUE
[11:02:17.181]                             break
[11:02:17.181]                           }
[11:02:17.181]                         }
[11:02:17.181]                       }
[11:02:17.181]                       invisible(muffled)
[11:02:17.181]                     }
[11:02:17.181]                     muffleCondition(cond, pattern = "^muffle")
[11:02:17.181]                   }
[11:02:17.181]                 }
[11:02:17.181]             }
[11:02:17.181]         }))
[11:02:17.181]     }, error = function(ex) {
[11:02:17.181]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:17.181]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:17.181]                 ...future.rng), started = ...future.startTime, 
[11:02:17.181]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:17.181]             version = "1.8"), class = "FutureResult")
[11:02:17.181]     }, finally = {
[11:02:17.181]         if (!identical(...future.workdir, getwd())) 
[11:02:17.181]             setwd(...future.workdir)
[11:02:17.181]         {
[11:02:17.181]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:17.181]                 ...future.oldOptions$nwarnings <- NULL
[11:02:17.181]             }
[11:02:17.181]             base::options(...future.oldOptions)
[11:02:17.181]             if (.Platform$OS.type == "windows") {
[11:02:17.181]                 old_names <- names(...future.oldEnvVars)
[11:02:17.181]                 envs <- base::Sys.getenv()
[11:02:17.181]                 names <- names(envs)
[11:02:17.181]                 common <- intersect(names, old_names)
[11:02:17.181]                 added <- setdiff(names, old_names)
[11:02:17.181]                 removed <- setdiff(old_names, names)
[11:02:17.181]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:17.181]                   envs[common]]
[11:02:17.181]                 NAMES <- toupper(changed)
[11:02:17.181]                 args <- list()
[11:02:17.181]                 for (kk in seq_along(NAMES)) {
[11:02:17.181]                   name <- changed[[kk]]
[11:02:17.181]                   NAME <- NAMES[[kk]]
[11:02:17.181]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:17.181]                     next
[11:02:17.181]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:17.181]                 }
[11:02:17.181]                 NAMES <- toupper(added)
[11:02:17.181]                 for (kk in seq_along(NAMES)) {
[11:02:17.181]                   name <- added[[kk]]
[11:02:17.181]                   NAME <- NAMES[[kk]]
[11:02:17.181]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:17.181]                     next
[11:02:17.181]                   args[[name]] <- ""
[11:02:17.181]                 }
[11:02:17.181]                 NAMES <- toupper(removed)
[11:02:17.181]                 for (kk in seq_along(NAMES)) {
[11:02:17.181]                   name <- removed[[kk]]
[11:02:17.181]                   NAME <- NAMES[[kk]]
[11:02:17.181]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:17.181]                     next
[11:02:17.181]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:17.181]                 }
[11:02:17.181]                 if (length(args) > 0) 
[11:02:17.181]                   base::do.call(base::Sys.setenv, args = args)
[11:02:17.181]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:17.181]             }
[11:02:17.181]             else {
[11:02:17.181]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:17.181]             }
[11:02:17.181]             {
[11:02:17.181]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:17.181]                   0L) {
[11:02:17.181]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:17.181]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:17.181]                   base::options(opts)
[11:02:17.181]                 }
[11:02:17.181]                 {
[11:02:17.181]                   {
[11:02:17.181]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:17.181]                     NULL
[11:02:17.181]                   }
[11:02:17.181]                   options(future.plan = NULL)
[11:02:17.181]                   if (is.na(NA_character_)) 
[11:02:17.181]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:17.181]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:17.181]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:17.181]                     .init = FALSE)
[11:02:17.181]                 }
[11:02:17.181]             }
[11:02:17.181]         }
[11:02:17.181]     })
[11:02:17.181]     if (TRUE) {
[11:02:17.181]         base::sink(type = "output", split = FALSE)
[11:02:17.181]         if (TRUE) {
[11:02:17.181]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:17.181]         }
[11:02:17.181]         else {
[11:02:17.181]             ...future.result["stdout"] <- base::list(NULL)
[11:02:17.181]         }
[11:02:17.181]         base::close(...future.stdout)
[11:02:17.181]         ...future.stdout <- NULL
[11:02:17.181]     }
[11:02:17.181]     ...future.result$conditions <- ...future.conditions
[11:02:17.181]     ...future.result$finished <- base::Sys.time()
[11:02:17.181]     ...future.result
[11:02:17.181] }
[11:02:17.184] Exporting 1 global objects (643 bytes) to cluster node #1 ...
[11:02:17.184] Exporting ‘data’ (356 bytes) to cluster node #1 ...
[11:02:17.184] Exporting ‘data’ (356 bytes) to cluster node #1 ... DONE
[11:02:17.184] Exporting 1 global objects (643 bytes) to cluster node #1 ... DONE
[11:02:17.185] MultisessionFuture started
[11:02:17.185] - Launch lazy future ... done
[11:02:17.185] run() for ‘MultisessionFuture’ ... done
[11:02:17.185] result() for ClusterFuture ...
[11:02:17.185] receiveMessageFromWorker() for ClusterFuture ...
[11:02:17.185] - Validating connection of MultisessionFuture
[11:02:17.230] - received message: FutureResult
[11:02:17.230] - Received FutureResult
[11:02:17.230] - Erased future from FutureRegistry
[11:02:17.230] result() for ClusterFuture ...
[11:02:17.231] - result already collected: FutureResult
[11:02:17.231] result() for ClusterFuture ... done
[11:02:17.231] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:17.231] result() for ClusterFuture ... done
[11:02:17.231] result() for ClusterFuture ...
[11:02:17.231] - result already collected: FutureResult
[11:02:17.231] result() for ClusterFuture ... done
- plan(list('multisession', 'sequential')) ... DONE
- plan(list('multisession', 'multicore')) ...
[11:02:17.231] plan(): Setting new future strategy stack:
[11:02:17.232] List of future strategies:
[11:02:17.232] 1. multisession:
[11:02:17.232]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:02:17.232]    - tweaked: FALSE
[11:02:17.232]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:17.232] 2. multicore:
[11:02:17.232]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:02:17.232]    - tweaked: FALSE
[11:02:17.232]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:17.232] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[11:02:17.232] multisession:
[11:02:17.232] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:02:17.232] - tweaked: FALSE
[11:02:17.232] - call: plan(list(a = strategy1, b = strategy2))
[11:02:17.235] getGlobalsAndPackages() ...
[11:02:17.235] Not searching for globals
[11:02:17.235] - globals: [0] <none>
[11:02:17.235] getGlobalsAndPackages() ... DONE
[11:02:17.497] Packages needed by the future expression (n = 0): <none>
[11:02:17.497] Packages needed by future strategies (n = 1): ‘future’
[11:02:17.498] {
[11:02:17.498]     {
[11:02:17.498]         {
[11:02:17.498]             ...future.startTime <- base::Sys.time()
[11:02:17.498]             {
[11:02:17.498]                 {
[11:02:17.498]                   {
[11:02:17.498]                     {
[11:02:17.498]                       {
[11:02:17.498]                         base::local({
[11:02:17.498]                           has_future <- base::requireNamespace("future", 
[11:02:17.498]                             quietly = TRUE)
[11:02:17.498]                           if (has_future) {
[11:02:17.498]                             ns <- base::getNamespace("future")
[11:02:17.498]                             version <- ns[[".package"]][["version"]]
[11:02:17.498]                             if (is.null(version)) 
[11:02:17.498]                               version <- utils::packageVersion("future")
[11:02:17.498]                           }
[11:02:17.498]                           else {
[11:02:17.498]                             version <- NULL
[11:02:17.498]                           }
[11:02:17.498]                           if (!has_future || version < "1.8.0") {
[11:02:17.498]                             info <- base::c(r_version = base::gsub("R version ", 
[11:02:17.498]                               "", base::R.version$version.string), 
[11:02:17.498]                               platform = base::sprintf("%s (%s-bit)", 
[11:02:17.498]                                 base::R.version$platform, 8 * 
[11:02:17.498]                                   base::.Machine$sizeof.pointer), 
[11:02:17.498]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:17.498]                                 "release", "version")], collapse = " "), 
[11:02:17.498]                               hostname = base::Sys.info()[["nodename"]])
[11:02:17.498]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:02:17.498]                               info)
[11:02:17.498]                             info <- base::paste(info, collapse = "; ")
[11:02:17.498]                             if (!has_future) {
[11:02:17.498]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:17.498]                                 info)
[11:02:17.498]                             }
[11:02:17.498]                             else {
[11:02:17.498]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:17.498]                                 info, version)
[11:02:17.498]                             }
[11:02:17.498]                             base::stop(msg)
[11:02:17.498]                           }
[11:02:17.498]                         })
[11:02:17.498]                       }
[11:02:17.498]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:17.498]                       base::options(mc.cores = 1L)
[11:02:17.498]                     }
[11:02:17.498]                     base::local({
[11:02:17.498]                       for (pkg in "future") {
[11:02:17.498]                         base::loadNamespace(pkg)
[11:02:17.498]                         base::library(pkg, character.only = TRUE)
[11:02:17.498]                       }
[11:02:17.498]                     })
[11:02:17.498]                   }
[11:02:17.498]                   ...future.strategy.old <- future::plan("list")
[11:02:17.498]                   options(future.plan = NULL)
[11:02:17.498]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:17.498]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[11:02:17.498]                     envir = parent.frame()) 
[11:02:17.498]                   {
[11:02:17.498]                     default_workers <- missing(workers)
[11:02:17.498]                     if (is.function(workers)) 
[11:02:17.498]                       workers <- workers()
[11:02:17.498]                     workers <- structure(as.integer(workers), 
[11:02:17.498]                       class = class(workers))
[11:02:17.498]                     stop_if_not(is.finite(workers), workers >= 
[11:02:17.498]                       1L)
[11:02:17.498]                     if ((workers == 1L && !inherits(workers, 
[11:02:17.498]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[11:02:17.498]                       if (default_workers) 
[11:02:17.498]                         supportsMulticore(warn = TRUE)
[11:02:17.498]                       return(sequential(..., envir = envir))
[11:02:17.498]                     }
[11:02:17.498]                     oopts <- options(mc.cores = workers)
[11:02:17.498]                     on.exit(options(oopts))
[11:02:17.498]                     future <- MulticoreFuture(..., workers = workers, 
[11:02:17.498]                       envir = envir)
[11:02:17.498]                     if (!future$lazy) 
[11:02:17.498]                       future <- run(future)
[11:02:17.498]                     invisible(future)
[11:02:17.498]                   }), .cleanup = FALSE, .init = FALSE)
[11:02:17.498]                 }
[11:02:17.498]                 ...future.workdir <- getwd()
[11:02:17.498]             }
[11:02:17.498]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:17.498]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:17.498]         }
[11:02:17.498]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:17.498]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:17.498]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:17.498]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:17.498]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:17.498]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:17.498]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:17.498]             base::names(...future.oldOptions))
[11:02:17.498]     }
[11:02:17.498]     if (FALSE) {
[11:02:17.498]     }
[11:02:17.498]     else {
[11:02:17.498]         if (TRUE) {
[11:02:17.498]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:17.498]                 open = "w")
[11:02:17.498]         }
[11:02:17.498]         else {
[11:02:17.498]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:17.498]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:17.498]         }
[11:02:17.498]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:17.498]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:17.498]             base::sink(type = "output", split = FALSE)
[11:02:17.498]             base::close(...future.stdout)
[11:02:17.498]         }, add = TRUE)
[11:02:17.498]     }
[11:02:17.498]     ...future.frame <- base::sys.nframe()
[11:02:17.498]     ...future.conditions <- base::list()
[11:02:17.498]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:17.498]     if (FALSE) {
[11:02:17.498]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:17.498]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:17.498]     }
[11:02:17.498]     ...future.result <- base::tryCatch({
[11:02:17.498]         base::withCallingHandlers({
[11:02:17.498]             ...future.value <- base::withVisible(base::local({
[11:02:17.498]                 ...future.makeSendCondition <- base::local({
[11:02:17.498]                   sendCondition <- NULL
[11:02:17.498]                   function(frame = 1L) {
[11:02:17.498]                     if (is.function(sendCondition)) 
[11:02:17.498]                       return(sendCondition)
[11:02:17.498]                     ns <- getNamespace("parallel")
[11:02:17.498]                     if (exists("sendData", mode = "function", 
[11:02:17.498]                       envir = ns)) {
[11:02:17.498]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:17.498]                         envir = ns)
[11:02:17.498]                       envir <- sys.frame(frame)
[11:02:17.498]                       master <- NULL
[11:02:17.498]                       while (!identical(envir, .GlobalEnv) && 
[11:02:17.498]                         !identical(envir, emptyenv())) {
[11:02:17.498]                         if (exists("master", mode = "list", envir = envir, 
[11:02:17.498]                           inherits = FALSE)) {
[11:02:17.498]                           master <- get("master", mode = "list", 
[11:02:17.498]                             envir = envir, inherits = FALSE)
[11:02:17.498]                           if (inherits(master, c("SOCKnode", 
[11:02:17.498]                             "SOCK0node"))) {
[11:02:17.498]                             sendCondition <<- function(cond) {
[11:02:17.498]                               data <- list(type = "VALUE", value = cond, 
[11:02:17.498]                                 success = TRUE)
[11:02:17.498]                               parallel_sendData(master, data)
[11:02:17.498]                             }
[11:02:17.498]                             return(sendCondition)
[11:02:17.498]                           }
[11:02:17.498]                         }
[11:02:17.498]                         frame <- frame + 1L
[11:02:17.498]                         envir <- sys.frame(frame)
[11:02:17.498]                       }
[11:02:17.498]                     }
[11:02:17.498]                     sendCondition <<- function(cond) NULL
[11:02:17.498]                   }
[11:02:17.498]                 })
[11:02:17.498]                 withCallingHandlers({
[11:02:17.498]                   NA
[11:02:17.498]                 }, immediateCondition = function(cond) {
[11:02:17.498]                   sendCondition <- ...future.makeSendCondition()
[11:02:17.498]                   sendCondition(cond)
[11:02:17.498]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:17.498]                   {
[11:02:17.498]                     inherits <- base::inherits
[11:02:17.498]                     invokeRestart <- base::invokeRestart
[11:02:17.498]                     is.null <- base::is.null
[11:02:17.498]                     muffled <- FALSE
[11:02:17.498]                     if (inherits(cond, "message")) {
[11:02:17.498]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:17.498]                       if (muffled) 
[11:02:17.498]                         invokeRestart("muffleMessage")
[11:02:17.498]                     }
[11:02:17.498]                     else if (inherits(cond, "warning")) {
[11:02:17.498]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:17.498]                       if (muffled) 
[11:02:17.498]                         invokeRestart("muffleWarning")
[11:02:17.498]                     }
[11:02:17.498]                     else if (inherits(cond, "condition")) {
[11:02:17.498]                       if (!is.null(pattern)) {
[11:02:17.498]                         computeRestarts <- base::computeRestarts
[11:02:17.498]                         grepl <- base::grepl
[11:02:17.498]                         restarts <- computeRestarts(cond)
[11:02:17.498]                         for (restart in restarts) {
[11:02:17.498]                           name <- restart$name
[11:02:17.498]                           if (is.null(name)) 
[11:02:17.498]                             next
[11:02:17.498]                           if (!grepl(pattern, name)) 
[11:02:17.498]                             next
[11:02:17.498]                           invokeRestart(restart)
[11:02:17.498]                           muffled <- TRUE
[11:02:17.498]                           break
[11:02:17.498]                         }
[11:02:17.498]                       }
[11:02:17.498]                     }
[11:02:17.498]                     invisible(muffled)
[11:02:17.498]                   }
[11:02:17.498]                   muffleCondition(cond)
[11:02:17.498]                 })
[11:02:17.498]             }))
[11:02:17.498]             future::FutureResult(value = ...future.value$value, 
[11:02:17.498]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:17.498]                   ...future.rng), globalenv = if (FALSE) 
[11:02:17.498]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:17.498]                     ...future.globalenv.names))
[11:02:17.498]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:17.498]         }, condition = base::local({
[11:02:17.498]             c <- base::c
[11:02:17.498]             inherits <- base::inherits
[11:02:17.498]             invokeRestart <- base::invokeRestart
[11:02:17.498]             length <- base::length
[11:02:17.498]             list <- base::list
[11:02:17.498]             seq.int <- base::seq.int
[11:02:17.498]             signalCondition <- base::signalCondition
[11:02:17.498]             sys.calls <- base::sys.calls
[11:02:17.498]             `[[` <- base::`[[`
[11:02:17.498]             `+` <- base::`+`
[11:02:17.498]             `<<-` <- base::`<<-`
[11:02:17.498]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:17.498]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:17.498]                   3L)]
[11:02:17.498]             }
[11:02:17.498]             function(cond) {
[11:02:17.498]                 is_error <- inherits(cond, "error")
[11:02:17.498]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:17.498]                   NULL)
[11:02:17.498]                 if (is_error) {
[11:02:17.498]                   sessionInformation <- function() {
[11:02:17.498]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:17.498]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:17.498]                       search = base::search(), system = base::Sys.info())
[11:02:17.498]                   }
[11:02:17.498]                   ...future.conditions[[length(...future.conditions) + 
[11:02:17.498]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:17.498]                     cond$call), session = sessionInformation(), 
[11:02:17.498]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:17.498]                   signalCondition(cond)
[11:02:17.498]                 }
[11:02:17.498]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:17.498]                 "immediateCondition"))) {
[11:02:17.498]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:17.498]                   ...future.conditions[[length(...future.conditions) + 
[11:02:17.498]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:17.498]                   if (TRUE && !signal) {
[11:02:17.498]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:17.498]                     {
[11:02:17.498]                       inherits <- base::inherits
[11:02:17.498]                       invokeRestart <- base::invokeRestart
[11:02:17.498]                       is.null <- base::is.null
[11:02:17.498]                       muffled <- FALSE
[11:02:17.498]                       if (inherits(cond, "message")) {
[11:02:17.498]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:17.498]                         if (muffled) 
[11:02:17.498]                           invokeRestart("muffleMessage")
[11:02:17.498]                       }
[11:02:17.498]                       else if (inherits(cond, "warning")) {
[11:02:17.498]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:17.498]                         if (muffled) 
[11:02:17.498]                           invokeRestart("muffleWarning")
[11:02:17.498]                       }
[11:02:17.498]                       else if (inherits(cond, "condition")) {
[11:02:17.498]                         if (!is.null(pattern)) {
[11:02:17.498]                           computeRestarts <- base::computeRestarts
[11:02:17.498]                           grepl <- base::grepl
[11:02:17.498]                           restarts <- computeRestarts(cond)
[11:02:17.498]                           for (restart in restarts) {
[11:02:17.498]                             name <- restart$name
[11:02:17.498]                             if (is.null(name)) 
[11:02:17.498]                               next
[11:02:17.498]                             if (!grepl(pattern, name)) 
[11:02:17.498]                               next
[11:02:17.498]                             invokeRestart(restart)
[11:02:17.498]                             muffled <- TRUE
[11:02:17.498]                             break
[11:02:17.498]                           }
[11:02:17.498]                         }
[11:02:17.498]                       }
[11:02:17.498]                       invisible(muffled)
[11:02:17.498]                     }
[11:02:17.498]                     muffleCondition(cond, pattern = "^muffle")
[11:02:17.498]                   }
[11:02:17.498]                 }
[11:02:17.498]                 else {
[11:02:17.498]                   if (TRUE) {
[11:02:17.498]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:17.498]                     {
[11:02:17.498]                       inherits <- base::inherits
[11:02:17.498]                       invokeRestart <- base::invokeRestart
[11:02:17.498]                       is.null <- base::is.null
[11:02:17.498]                       muffled <- FALSE
[11:02:17.498]                       if (inherits(cond, "message")) {
[11:02:17.498]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:17.498]                         if (muffled) 
[11:02:17.498]                           invokeRestart("muffleMessage")
[11:02:17.498]                       }
[11:02:17.498]                       else if (inherits(cond, "warning")) {
[11:02:17.498]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:17.498]                         if (muffled) 
[11:02:17.498]                           invokeRestart("muffleWarning")
[11:02:17.498]                       }
[11:02:17.498]                       else if (inherits(cond, "condition")) {
[11:02:17.498]                         if (!is.null(pattern)) {
[11:02:17.498]                           computeRestarts <- base::computeRestarts
[11:02:17.498]                           grepl <- base::grepl
[11:02:17.498]                           restarts <- computeRestarts(cond)
[11:02:17.498]                           for (restart in restarts) {
[11:02:17.498]                             name <- restart$name
[11:02:17.498]                             if (is.null(name)) 
[11:02:17.498]                               next
[11:02:17.498]                             if (!grepl(pattern, name)) 
[11:02:17.498]                               next
[11:02:17.498]                             invokeRestart(restart)
[11:02:17.498]                             muffled <- TRUE
[11:02:17.498]                             break
[11:02:17.498]                           }
[11:02:17.498]                         }
[11:02:17.498]                       }
[11:02:17.498]                       invisible(muffled)
[11:02:17.498]                     }
[11:02:17.498]                     muffleCondition(cond, pattern = "^muffle")
[11:02:17.498]                   }
[11:02:17.498]                 }
[11:02:17.498]             }
[11:02:17.498]         }))
[11:02:17.498]     }, error = function(ex) {
[11:02:17.498]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:17.498]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:17.498]                 ...future.rng), started = ...future.startTime, 
[11:02:17.498]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:17.498]             version = "1.8"), class = "FutureResult")
[11:02:17.498]     }, finally = {
[11:02:17.498]         if (!identical(...future.workdir, getwd())) 
[11:02:17.498]             setwd(...future.workdir)
[11:02:17.498]         {
[11:02:17.498]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:17.498]                 ...future.oldOptions$nwarnings <- NULL
[11:02:17.498]             }
[11:02:17.498]             base::options(...future.oldOptions)
[11:02:17.498]             if (.Platform$OS.type == "windows") {
[11:02:17.498]                 old_names <- names(...future.oldEnvVars)
[11:02:17.498]                 envs <- base::Sys.getenv()
[11:02:17.498]                 names <- names(envs)
[11:02:17.498]                 common <- intersect(names, old_names)
[11:02:17.498]                 added <- setdiff(names, old_names)
[11:02:17.498]                 removed <- setdiff(old_names, names)
[11:02:17.498]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:17.498]                   envs[common]]
[11:02:17.498]                 NAMES <- toupper(changed)
[11:02:17.498]                 args <- list()
[11:02:17.498]                 for (kk in seq_along(NAMES)) {
[11:02:17.498]                   name <- changed[[kk]]
[11:02:17.498]                   NAME <- NAMES[[kk]]
[11:02:17.498]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:17.498]                     next
[11:02:17.498]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:17.498]                 }
[11:02:17.498]                 NAMES <- toupper(added)
[11:02:17.498]                 for (kk in seq_along(NAMES)) {
[11:02:17.498]                   name <- added[[kk]]
[11:02:17.498]                   NAME <- NAMES[[kk]]
[11:02:17.498]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:17.498]                     next
[11:02:17.498]                   args[[name]] <- ""
[11:02:17.498]                 }
[11:02:17.498]                 NAMES <- toupper(removed)
[11:02:17.498]                 for (kk in seq_along(NAMES)) {
[11:02:17.498]                   name <- removed[[kk]]
[11:02:17.498]                   NAME <- NAMES[[kk]]
[11:02:17.498]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:17.498]                     next
[11:02:17.498]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:17.498]                 }
[11:02:17.498]                 if (length(args) > 0) 
[11:02:17.498]                   base::do.call(base::Sys.setenv, args = args)
[11:02:17.498]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:17.498]             }
[11:02:17.498]             else {
[11:02:17.498]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:17.498]             }
[11:02:17.498]             {
[11:02:17.498]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:17.498]                   0L) {
[11:02:17.498]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:17.498]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:17.498]                   base::options(opts)
[11:02:17.498]                 }
[11:02:17.498]                 {
[11:02:17.498]                   {
[11:02:17.498]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:17.498]                     NULL
[11:02:17.498]                   }
[11:02:17.498]                   options(future.plan = NULL)
[11:02:17.498]                   if (is.na(NA_character_)) 
[11:02:17.498]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:17.498]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:17.498]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:17.498]                     .init = FALSE)
[11:02:17.498]                 }
[11:02:17.498]             }
[11:02:17.498]         }
[11:02:17.498]     })
[11:02:17.498]     if (TRUE) {
[11:02:17.498]         base::sink(type = "output", split = FALSE)
[11:02:17.498]         if (TRUE) {
[11:02:17.498]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:17.498]         }
[11:02:17.498]         else {
[11:02:17.498]             ...future.result["stdout"] <- base::list(NULL)
[11:02:17.498]         }
[11:02:17.498]         base::close(...future.stdout)
[11:02:17.498]         ...future.stdout <- NULL
[11:02:17.498]     }
[11:02:17.498]     ...future.result$conditions <- ...future.conditions
[11:02:17.498]     ...future.result$finished <- base::Sys.time()
[11:02:17.498]     ...future.result
[11:02:17.498] }
[11:02:17.549] MultisessionFuture started
[11:02:17.549] result() for ClusterFuture ...
[11:02:17.549] receiveMessageFromWorker() for ClusterFuture ...
[11:02:17.549] - Validating connection of MultisessionFuture
[11:02:17.598] - received message: FutureResult
[11:02:17.598] - Received FutureResult
[11:02:17.598] - Erased future from FutureRegistry
[11:02:17.598] result() for ClusterFuture ...
[11:02:17.598] - result already collected: FutureResult
[11:02:17.598] result() for ClusterFuture ... done
[11:02:17.599] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:17.599] result() for ClusterFuture ... done
[11:02:17.599] result() for ClusterFuture ...
[11:02:17.599] - result already collected: FutureResult
[11:02:17.599] result() for ClusterFuture ... done
[11:02:17.599] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[11:02:17.601] plan(): nbrOfWorkers() = 2
[11:02:17.601] getGlobalsAndPackages() ...
[11:02:17.601] Searching for globals...
[11:02:17.616] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[11:02:17.616] Searching for globals ... DONE
[11:02:17.616] Resolving globals: FALSE
[11:02:17.617] The total size of the 2 globals is 11.74 KiB (12021 bytes)
[11:02:17.620] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 11.74 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (11.69 KiB of class ‘list’) and ‘strategy2’ (48 bytes of class ‘character’)
[11:02:17.620] - globals: [2] ‘nested’, ‘strategy2’
[11:02:17.620] - packages: [1] ‘future’
[11:02:17.620] getGlobalsAndPackages() ... DONE
[11:02:17.620] run() for ‘Future’ ...
[11:02:17.620] - state: ‘created’
[11:02:17.621] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:17.634] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:17.635] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:17.635]   - Field: ‘node’
[11:02:17.635]   - Field: ‘label’
[11:02:17.635]   - Field: ‘local’
[11:02:17.635]   - Field: ‘owner’
[11:02:17.635]   - Field: ‘envir’
[11:02:17.635]   - Field: ‘workers’
[11:02:17.635]   - Field: ‘packages’
[11:02:17.635]   - Field: ‘gc’
[11:02:17.635]   - Field: ‘conditions’
[11:02:17.635]   - Field: ‘persistent’
[11:02:17.635]   - Field: ‘expr’
[11:02:17.636]   - Field: ‘uuid’
[11:02:17.636]   - Field: ‘seed’
[11:02:17.636]   - Field: ‘version’
[11:02:17.636]   - Field: ‘result’
[11:02:17.636]   - Field: ‘asynchronous’
[11:02:17.636]   - Field: ‘calls’
[11:02:17.636]   - Field: ‘globals’
[11:02:17.636]   - Field: ‘stdout’
[11:02:17.636]   - Field: ‘earlySignal’
[11:02:17.636]   - Field: ‘lazy’
[11:02:17.636]   - Field: ‘state’
[11:02:17.636] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:17.637] - Launch lazy future ...
[11:02:17.637] Packages needed by the future expression (n = 1): ‘future’
[11:02:17.637] Packages needed by future strategies (n = 1): ‘future’
[11:02:17.637] {
[11:02:17.637]     {
[11:02:17.637]         {
[11:02:17.637]             ...future.startTime <- base::Sys.time()
[11:02:17.637]             {
[11:02:17.637]                 {
[11:02:17.637]                   {
[11:02:17.637]                     {
[11:02:17.637]                       {
[11:02:17.637]                         base::local({
[11:02:17.637]                           has_future <- base::requireNamespace("future", 
[11:02:17.637]                             quietly = TRUE)
[11:02:17.637]                           if (has_future) {
[11:02:17.637]                             ns <- base::getNamespace("future")
[11:02:17.637]                             version <- ns[[".package"]][["version"]]
[11:02:17.637]                             if (is.null(version)) 
[11:02:17.637]                               version <- utils::packageVersion("future")
[11:02:17.637]                           }
[11:02:17.637]                           else {
[11:02:17.637]                             version <- NULL
[11:02:17.637]                           }
[11:02:17.637]                           if (!has_future || version < "1.8.0") {
[11:02:17.637]                             info <- base::c(r_version = base::gsub("R version ", 
[11:02:17.637]                               "", base::R.version$version.string), 
[11:02:17.637]                               platform = base::sprintf("%s (%s-bit)", 
[11:02:17.637]                                 base::R.version$platform, 8 * 
[11:02:17.637]                                   base::.Machine$sizeof.pointer), 
[11:02:17.637]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:17.637]                                 "release", "version")], collapse = " "), 
[11:02:17.637]                               hostname = base::Sys.info()[["nodename"]])
[11:02:17.637]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:02:17.637]                               info)
[11:02:17.637]                             info <- base::paste(info, collapse = "; ")
[11:02:17.637]                             if (!has_future) {
[11:02:17.637]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:17.637]                                 info)
[11:02:17.637]                             }
[11:02:17.637]                             else {
[11:02:17.637]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:17.637]                                 info, version)
[11:02:17.637]                             }
[11:02:17.637]                             base::stop(msg)
[11:02:17.637]                           }
[11:02:17.637]                         })
[11:02:17.637]                       }
[11:02:17.637]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:17.637]                       base::options(mc.cores = 1L)
[11:02:17.637]                     }
[11:02:17.637]                     base::local({
[11:02:17.637]                       for (pkg in "future") {
[11:02:17.637]                         base::loadNamespace(pkg)
[11:02:17.637]                         base::library(pkg, character.only = TRUE)
[11:02:17.637]                       }
[11:02:17.637]                     })
[11:02:17.637]                   }
[11:02:17.637]                   ...future.strategy.old <- future::plan("list")
[11:02:17.637]                   options(future.plan = NULL)
[11:02:17.637]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:17.637]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[11:02:17.637]                     envir = parent.frame()) 
[11:02:17.637]                   {
[11:02:17.637]                     default_workers <- missing(workers)
[11:02:17.637]                     if (is.function(workers)) 
[11:02:17.637]                       workers <- workers()
[11:02:17.637]                     workers <- structure(as.integer(workers), 
[11:02:17.637]                       class = class(workers))
[11:02:17.637]                     stop_if_not(is.finite(workers), workers >= 
[11:02:17.637]                       1L)
[11:02:17.637]                     if ((workers == 1L && !inherits(workers, 
[11:02:17.637]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[11:02:17.637]                       if (default_workers) 
[11:02:17.637]                         supportsMulticore(warn = TRUE)
[11:02:17.637]                       return(sequential(..., envir = envir))
[11:02:17.637]                     }
[11:02:17.637]                     oopts <- options(mc.cores = workers)
[11:02:17.637]                     on.exit(options(oopts))
[11:02:17.637]                     future <- MulticoreFuture(..., workers = workers, 
[11:02:17.637]                       envir = envir)
[11:02:17.637]                     if (!future$lazy) 
[11:02:17.637]                       future <- run(future)
[11:02:17.637]                     invisible(future)
[11:02:17.637]                   }), .cleanup = FALSE, .init = FALSE)
[11:02:17.637]                 }
[11:02:17.637]                 ...future.workdir <- getwd()
[11:02:17.637]             }
[11:02:17.637]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:17.637]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:17.637]         }
[11:02:17.637]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:17.637]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:17.637]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:17.637]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:17.637]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:17.637]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:17.637]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:17.637]             base::names(...future.oldOptions))
[11:02:17.637]     }
[11:02:17.637]     if (FALSE) {
[11:02:17.637]     }
[11:02:17.637]     else {
[11:02:17.637]         if (TRUE) {
[11:02:17.637]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:17.637]                 open = "w")
[11:02:17.637]         }
[11:02:17.637]         else {
[11:02:17.637]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:17.637]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:17.637]         }
[11:02:17.637]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:17.637]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:17.637]             base::sink(type = "output", split = FALSE)
[11:02:17.637]             base::close(...future.stdout)
[11:02:17.637]         }, add = TRUE)
[11:02:17.637]     }
[11:02:17.637]     ...future.frame <- base::sys.nframe()
[11:02:17.637]     ...future.conditions <- base::list()
[11:02:17.637]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:17.637]     if (FALSE) {
[11:02:17.637]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:17.637]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:17.637]     }
[11:02:17.637]     ...future.result <- base::tryCatch({
[11:02:17.637]         base::withCallingHandlers({
[11:02:17.637]             ...future.value <- base::withVisible(base::local({
[11:02:17.637]                 ...future.makeSendCondition <- base::local({
[11:02:17.637]                   sendCondition <- NULL
[11:02:17.637]                   function(frame = 1L) {
[11:02:17.637]                     if (is.function(sendCondition)) 
[11:02:17.637]                       return(sendCondition)
[11:02:17.637]                     ns <- getNamespace("parallel")
[11:02:17.637]                     if (exists("sendData", mode = "function", 
[11:02:17.637]                       envir = ns)) {
[11:02:17.637]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:17.637]                         envir = ns)
[11:02:17.637]                       envir <- sys.frame(frame)
[11:02:17.637]                       master <- NULL
[11:02:17.637]                       while (!identical(envir, .GlobalEnv) && 
[11:02:17.637]                         !identical(envir, emptyenv())) {
[11:02:17.637]                         if (exists("master", mode = "list", envir = envir, 
[11:02:17.637]                           inherits = FALSE)) {
[11:02:17.637]                           master <- get("master", mode = "list", 
[11:02:17.637]                             envir = envir, inherits = FALSE)
[11:02:17.637]                           if (inherits(master, c("SOCKnode", 
[11:02:17.637]                             "SOCK0node"))) {
[11:02:17.637]                             sendCondition <<- function(cond) {
[11:02:17.637]                               data <- list(type = "VALUE", value = cond, 
[11:02:17.637]                                 success = TRUE)
[11:02:17.637]                               parallel_sendData(master, data)
[11:02:17.637]                             }
[11:02:17.637]                             return(sendCondition)
[11:02:17.637]                           }
[11:02:17.637]                         }
[11:02:17.637]                         frame <- frame + 1L
[11:02:17.637]                         envir <- sys.frame(frame)
[11:02:17.637]                       }
[11:02:17.637]                     }
[11:02:17.637]                     sendCondition <<- function(cond) NULL
[11:02:17.637]                   }
[11:02:17.637]                 })
[11:02:17.637]                 withCallingHandlers({
[11:02:17.637]                   {
[11:02:17.637]                     a <- 1L
[11:02:17.637]                     plan_a <- unclass(future::plan("list"))
[11:02:17.637]                     nested_a <- nested[-1]
[11:02:17.637]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[11:02:17.637]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[11:02:17.637]                       strategy2))
[11:02:17.637]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[11:02:17.637]                       "init") <- NULL
[11:02:17.637]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[11:02:17.637]                       "init") <- NULL
[11:02:17.637]                     stopifnot(all.equal(plan_a, nested_a))
[11:02:17.637]                     y %<-% {
[11:02:17.637]                       b <- 2L
[11:02:17.637]                       plan_b <- future::plan("list")
[11:02:17.637]                       nested_b <- nested_a[-1]
[11:02:17.637]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[11:02:17.637]                         1L, inherits(plan_b[[1]], "future"), 
[11:02:17.637]                         inherits(future::plan("next"), "sequential"))
[11:02:17.637]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[11:02:17.637]                         b = b, nested_b = nested_b, plan_b = plan_b)
[11:02:17.637]                     }
[11:02:17.637]                     y
[11:02:17.637]                   }
[11:02:17.637]                 }, immediateCondition = function(cond) {
[11:02:17.637]                   sendCondition <- ...future.makeSendCondition()
[11:02:17.637]                   sendCondition(cond)
[11:02:17.637]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:17.637]                   {
[11:02:17.637]                     inherits <- base::inherits
[11:02:17.637]                     invokeRestart <- base::invokeRestart
[11:02:17.637]                     is.null <- base::is.null
[11:02:17.637]                     muffled <- FALSE
[11:02:17.637]                     if (inherits(cond, "message")) {
[11:02:17.637]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:17.637]                       if (muffled) 
[11:02:17.637]                         invokeRestart("muffleMessage")
[11:02:17.637]                     }
[11:02:17.637]                     else if (inherits(cond, "warning")) {
[11:02:17.637]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:17.637]                       if (muffled) 
[11:02:17.637]                         invokeRestart("muffleWarning")
[11:02:17.637]                     }
[11:02:17.637]                     else if (inherits(cond, "condition")) {
[11:02:17.637]                       if (!is.null(pattern)) {
[11:02:17.637]                         computeRestarts <- base::computeRestarts
[11:02:17.637]                         grepl <- base::grepl
[11:02:17.637]                         restarts <- computeRestarts(cond)
[11:02:17.637]                         for (restart in restarts) {
[11:02:17.637]                           name <- restart$name
[11:02:17.637]                           if (is.null(name)) 
[11:02:17.637]                             next
[11:02:17.637]                           if (!grepl(pattern, name)) 
[11:02:17.637]                             next
[11:02:17.637]                           invokeRestart(restart)
[11:02:17.637]                           muffled <- TRUE
[11:02:17.637]                           break
[11:02:17.637]                         }
[11:02:17.637]                       }
[11:02:17.637]                     }
[11:02:17.637]                     invisible(muffled)
[11:02:17.637]                   }
[11:02:17.637]                   muffleCondition(cond)
[11:02:17.637]                 })
[11:02:17.637]             }))
[11:02:17.637]             future::FutureResult(value = ...future.value$value, 
[11:02:17.637]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:17.637]                   ...future.rng), globalenv = if (FALSE) 
[11:02:17.637]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:17.637]                     ...future.globalenv.names))
[11:02:17.637]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:17.637]         }, condition = base::local({
[11:02:17.637]             c <- base::c
[11:02:17.637]             inherits <- base::inherits
[11:02:17.637]             invokeRestart <- base::invokeRestart
[11:02:17.637]             length <- base::length
[11:02:17.637]             list <- base::list
[11:02:17.637]             seq.int <- base::seq.int
[11:02:17.637]             signalCondition <- base::signalCondition
[11:02:17.637]             sys.calls <- base::sys.calls
[11:02:17.637]             `[[` <- base::`[[`
[11:02:17.637]             `+` <- base::`+`
[11:02:17.637]             `<<-` <- base::`<<-`
[11:02:17.637]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:17.637]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:17.637]                   3L)]
[11:02:17.637]             }
[11:02:17.637]             function(cond) {
[11:02:17.637]                 is_error <- inherits(cond, "error")
[11:02:17.637]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:17.637]                   NULL)
[11:02:17.637]                 if (is_error) {
[11:02:17.637]                   sessionInformation <- function() {
[11:02:17.637]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:17.637]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:17.637]                       search = base::search(), system = base::Sys.info())
[11:02:17.637]                   }
[11:02:17.637]                   ...future.conditions[[length(...future.conditions) + 
[11:02:17.637]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:17.637]                     cond$call), session = sessionInformation(), 
[11:02:17.637]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:17.637]                   signalCondition(cond)
[11:02:17.637]                 }
[11:02:17.637]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:17.637]                 "immediateCondition"))) {
[11:02:17.637]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:17.637]                   ...future.conditions[[length(...future.conditions) + 
[11:02:17.637]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:17.637]                   if (TRUE && !signal) {
[11:02:17.637]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:17.637]                     {
[11:02:17.637]                       inherits <- base::inherits
[11:02:17.637]                       invokeRestart <- base::invokeRestart
[11:02:17.637]                       is.null <- base::is.null
[11:02:17.637]                       muffled <- FALSE
[11:02:17.637]                       if (inherits(cond, "message")) {
[11:02:17.637]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:17.637]                         if (muffled) 
[11:02:17.637]                           invokeRestart("muffleMessage")
[11:02:17.637]                       }
[11:02:17.637]                       else if (inherits(cond, "warning")) {
[11:02:17.637]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:17.637]                         if (muffled) 
[11:02:17.637]                           invokeRestart("muffleWarning")
[11:02:17.637]                       }
[11:02:17.637]                       else if (inherits(cond, "condition")) {
[11:02:17.637]                         if (!is.null(pattern)) {
[11:02:17.637]                           computeRestarts <- base::computeRestarts
[11:02:17.637]                           grepl <- base::grepl
[11:02:17.637]                           restarts <- computeRestarts(cond)
[11:02:17.637]                           for (restart in restarts) {
[11:02:17.637]                             name <- restart$name
[11:02:17.637]                             if (is.null(name)) 
[11:02:17.637]                               next
[11:02:17.637]                             if (!grepl(pattern, name)) 
[11:02:17.637]                               next
[11:02:17.637]                             invokeRestart(restart)
[11:02:17.637]                             muffled <- TRUE
[11:02:17.637]                             break
[11:02:17.637]                           }
[11:02:17.637]                         }
[11:02:17.637]                       }
[11:02:17.637]                       invisible(muffled)
[11:02:17.637]                     }
[11:02:17.637]                     muffleCondition(cond, pattern = "^muffle")
[11:02:17.637]                   }
[11:02:17.637]                 }
[11:02:17.637]                 else {
[11:02:17.637]                   if (TRUE) {
[11:02:17.637]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:17.637]                     {
[11:02:17.637]                       inherits <- base::inherits
[11:02:17.637]                       invokeRestart <- base::invokeRestart
[11:02:17.637]                       is.null <- base::is.null
[11:02:17.637]                       muffled <- FALSE
[11:02:17.637]                       if (inherits(cond, "message")) {
[11:02:17.637]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:17.637]                         if (muffled) 
[11:02:17.637]                           invokeRestart("muffleMessage")
[11:02:17.637]                       }
[11:02:17.637]                       else if (inherits(cond, "warning")) {
[11:02:17.637]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:17.637]                         if (muffled) 
[11:02:17.637]                           invokeRestart("muffleWarning")
[11:02:17.637]                       }
[11:02:17.637]                       else if (inherits(cond, "condition")) {
[11:02:17.637]                         if (!is.null(pattern)) {
[11:02:17.637]                           computeRestarts <- base::computeRestarts
[11:02:17.637]                           grepl <- base::grepl
[11:02:17.637]                           restarts <- computeRestarts(cond)
[11:02:17.637]                           for (restart in restarts) {
[11:02:17.637]                             name <- restart$name
[11:02:17.637]                             if (is.null(name)) 
[11:02:17.637]                               next
[11:02:17.637]                             if (!grepl(pattern, name)) 
[11:02:17.637]                               next
[11:02:17.637]                             invokeRestart(restart)
[11:02:17.637]                             muffled <- TRUE
[11:02:17.637]                             break
[11:02:17.637]                           }
[11:02:17.637]                         }
[11:02:17.637]                       }
[11:02:17.637]                       invisible(muffled)
[11:02:17.637]                     }
[11:02:17.637]                     muffleCondition(cond, pattern = "^muffle")
[11:02:17.637]                   }
[11:02:17.637]                 }
[11:02:17.637]             }
[11:02:17.637]         }))
[11:02:17.637]     }, error = function(ex) {
[11:02:17.637]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:17.637]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:17.637]                 ...future.rng), started = ...future.startTime, 
[11:02:17.637]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:17.637]             version = "1.8"), class = "FutureResult")
[11:02:17.637]     }, finally = {
[11:02:17.637]         if (!identical(...future.workdir, getwd())) 
[11:02:17.637]             setwd(...future.workdir)
[11:02:17.637]         {
[11:02:17.637]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:17.637]                 ...future.oldOptions$nwarnings <- NULL
[11:02:17.637]             }
[11:02:17.637]             base::options(...future.oldOptions)
[11:02:17.637]             if (.Platform$OS.type == "windows") {
[11:02:17.637]                 old_names <- names(...future.oldEnvVars)
[11:02:17.637]                 envs <- base::Sys.getenv()
[11:02:17.637]                 names <- names(envs)
[11:02:17.637]                 common <- intersect(names, old_names)
[11:02:17.637]                 added <- setdiff(names, old_names)
[11:02:17.637]                 removed <- setdiff(old_names, names)
[11:02:17.637]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:17.637]                   envs[common]]
[11:02:17.637]                 NAMES <- toupper(changed)
[11:02:17.637]                 args <- list()
[11:02:17.637]                 for (kk in seq_along(NAMES)) {
[11:02:17.637]                   name <- changed[[kk]]
[11:02:17.637]                   NAME <- NAMES[[kk]]
[11:02:17.637]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:17.637]                     next
[11:02:17.637]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:17.637]                 }
[11:02:17.637]                 NAMES <- toupper(added)
[11:02:17.637]                 for (kk in seq_along(NAMES)) {
[11:02:17.637]                   name <- added[[kk]]
[11:02:17.637]                   NAME <- NAMES[[kk]]
[11:02:17.637]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:17.637]                     next
[11:02:17.637]                   args[[name]] <- ""
[11:02:17.637]                 }
[11:02:17.637]                 NAMES <- toupper(removed)
[11:02:17.637]                 for (kk in seq_along(NAMES)) {
[11:02:17.637]                   name <- removed[[kk]]
[11:02:17.637]                   NAME <- NAMES[[kk]]
[11:02:17.637]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:17.637]                     next
[11:02:17.637]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:17.637]                 }
[11:02:17.637]                 if (length(args) > 0) 
[11:02:17.637]                   base::do.call(base::Sys.setenv, args = args)
[11:02:17.637]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:17.637]             }
[11:02:17.637]             else {
[11:02:17.637]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:17.637]             }
[11:02:17.637]             {
[11:02:17.637]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:17.637]                   0L) {
[11:02:17.637]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:17.637]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:17.637]                   base::options(opts)
[11:02:17.637]                 }
[11:02:17.637]                 {
[11:02:17.637]                   {
[11:02:17.637]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:17.637]                     NULL
[11:02:17.637]                   }
[11:02:17.637]                   options(future.plan = NULL)
[11:02:17.637]                   if (is.na(NA_character_)) 
[11:02:17.637]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:17.637]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:17.637]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:17.637]                     .init = FALSE)
[11:02:17.637]                 }
[11:02:17.637]             }
[11:02:17.637]         }
[11:02:17.637]     })
[11:02:17.637]     if (TRUE) {
[11:02:17.637]         base::sink(type = "output", split = FALSE)
[11:02:17.637]         if (TRUE) {
[11:02:17.637]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:17.637]         }
[11:02:17.637]         else {
[11:02:17.637]             ...future.result["stdout"] <- base::list(NULL)
[11:02:17.637]         }
[11:02:17.637]         base::close(...future.stdout)
[11:02:17.637]         ...future.stdout <- NULL
[11:02:17.637]     }
[11:02:17.637]     ...future.result$conditions <- ...future.conditions
[11:02:17.637]     ...future.result$finished <- base::Sys.time()
[11:02:17.637]     ...future.result
[11:02:17.637] }
[11:02:17.641] Exporting 2 global objects (12.04 KiB) to cluster node #1 ...
[11:02:17.641] Exporting ‘nested’ (11.69 KiB) to cluster node #1 ...
[11:02:17.682] Exporting ‘nested’ (11.69 KiB) to cluster node #1 ... DONE
[11:02:17.682] Exporting ‘strategy2’ (48 bytes) to cluster node #1 ...
[11:02:17.682] Exporting ‘strategy2’ (48 bytes) to cluster node #1 ... DONE
[11:02:17.682] Exporting 2 global objects (12.04 KiB) to cluster node #1 ... DONE
[11:02:17.683] MultisessionFuture started
[11:02:17.683] - Launch lazy future ... done
[11:02:17.683] run() for ‘MultisessionFuture’ ... done
[11:02:17.683] result() for ClusterFuture ...
[11:02:17.683] receiveMessageFromWorker() for ClusterFuture ...
[11:02:17.683] - Validating connection of MultisessionFuture
[11:02:17.747] - received message: FutureResult
[11:02:17.747] - Received FutureResult
[11:02:17.747] - Erased future from FutureRegistry
[11:02:17.748] result() for ClusterFuture ...
[11:02:17.748] - result already collected: FutureResult
[11:02:17.748] result() for ClusterFuture ... done
[11:02:17.748] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:17.748] result() for ClusterFuture ... done
[11:02:17.748] result() for ClusterFuture ...
[11:02:17.748] - result already collected: FutureResult
[11:02:17.748] result() for ClusterFuture ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "multicore" "multiprocess" "future" "function"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[11:02:17.753] getGlobalsAndPackages() ...
[11:02:17.753] Searching for globals...
[11:02:17.754] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[11:02:17.754] Searching for globals ... DONE
[11:02:17.755] Resolving globals: FALSE
[11:02:17.755] The total size of the 1 globals is 356 bytes (356 bytes)
[11:02:17.755] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[11:02:17.755] - globals: [1] ‘data’
[11:02:17.756] - packages: [1] ‘future’
[11:02:17.756] getGlobalsAndPackages() ... DONE
[11:02:17.756] run() for ‘Future’ ...
[11:02:17.756] - state: ‘created’
[11:02:17.756] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:17.771] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:17.771] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:17.771]   - Field: ‘node’
[11:02:17.771]   - Field: ‘label’
[11:02:17.771]   - Field: ‘local’
[11:02:17.771]   - Field: ‘owner’
[11:02:17.771]   - Field: ‘envir’
[11:02:17.772]   - Field: ‘workers’
[11:02:17.772]   - Field: ‘packages’
[11:02:17.772]   - Field: ‘gc’
[11:02:17.772]   - Field: ‘conditions’
[11:02:17.772]   - Field: ‘persistent’
[11:02:17.772]   - Field: ‘expr’
[11:02:17.772]   - Field: ‘uuid’
[11:02:17.772]   - Field: ‘seed’
[11:02:17.772]   - Field: ‘version’
[11:02:17.772]   - Field: ‘result’
[11:02:17.772]   - Field: ‘asynchronous’
[11:02:17.772]   - Field: ‘calls’
[11:02:17.773]   - Field: ‘globals’
[11:02:17.773]   - Field: ‘stdout’
[11:02:17.773]   - Field: ‘earlySignal’
[11:02:17.773]   - Field: ‘lazy’
[11:02:17.773]   - Field: ‘state’
[11:02:17.773] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:17.773] - Launch lazy future ...
[11:02:17.773] Packages needed by the future expression (n = 1): ‘future’
[11:02:17.774] Packages needed by future strategies (n = 1): ‘future’
[11:02:17.774] {
[11:02:17.774]     {
[11:02:17.774]         {
[11:02:17.774]             ...future.startTime <- base::Sys.time()
[11:02:17.774]             {
[11:02:17.774]                 {
[11:02:17.774]                   {
[11:02:17.774]                     {
[11:02:17.774]                       {
[11:02:17.774]                         base::local({
[11:02:17.774]                           has_future <- base::requireNamespace("future", 
[11:02:17.774]                             quietly = TRUE)
[11:02:17.774]                           if (has_future) {
[11:02:17.774]                             ns <- base::getNamespace("future")
[11:02:17.774]                             version <- ns[[".package"]][["version"]]
[11:02:17.774]                             if (is.null(version)) 
[11:02:17.774]                               version <- utils::packageVersion("future")
[11:02:17.774]                           }
[11:02:17.774]                           else {
[11:02:17.774]                             version <- NULL
[11:02:17.774]                           }
[11:02:17.774]                           if (!has_future || version < "1.8.0") {
[11:02:17.774]                             info <- base::c(r_version = base::gsub("R version ", 
[11:02:17.774]                               "", base::R.version$version.string), 
[11:02:17.774]                               platform = base::sprintf("%s (%s-bit)", 
[11:02:17.774]                                 base::R.version$platform, 8 * 
[11:02:17.774]                                   base::.Machine$sizeof.pointer), 
[11:02:17.774]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:17.774]                                 "release", "version")], collapse = " "), 
[11:02:17.774]                               hostname = base::Sys.info()[["nodename"]])
[11:02:17.774]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:02:17.774]                               info)
[11:02:17.774]                             info <- base::paste(info, collapse = "; ")
[11:02:17.774]                             if (!has_future) {
[11:02:17.774]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:17.774]                                 info)
[11:02:17.774]                             }
[11:02:17.774]                             else {
[11:02:17.774]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:17.774]                                 info, version)
[11:02:17.774]                             }
[11:02:17.774]                             base::stop(msg)
[11:02:17.774]                           }
[11:02:17.774]                         })
[11:02:17.774]                       }
[11:02:17.774]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:17.774]                       base::options(mc.cores = 1L)
[11:02:17.774]                     }
[11:02:17.774]                     base::local({
[11:02:17.774]                       for (pkg in "future") {
[11:02:17.774]                         base::loadNamespace(pkg)
[11:02:17.774]                         base::library(pkg, character.only = TRUE)
[11:02:17.774]                       }
[11:02:17.774]                     })
[11:02:17.774]                   }
[11:02:17.774]                   ...future.strategy.old <- future::plan("list")
[11:02:17.774]                   options(future.plan = NULL)
[11:02:17.774]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:17.774]                   future::plan(list(b = function (..., workers = availableCores(constraints = "multicore"), 
[11:02:17.774]                     envir = parent.frame()) 
[11:02:17.774]                   {
[11:02:17.774]                     default_workers <- missing(workers)
[11:02:17.774]                     if (is.function(workers)) 
[11:02:17.774]                       workers <- workers()
[11:02:17.774]                     workers <- structure(as.integer(workers), 
[11:02:17.774]                       class = class(workers))
[11:02:17.774]                     stop_if_not(is.finite(workers), workers >= 
[11:02:17.774]                       1L)
[11:02:17.774]                     if ((workers == 1L && !inherits(workers, 
[11:02:17.774]                       "AsIs")) || !supportsMulticore(warn = TRUE)) {
[11:02:17.774]                       if (default_workers) 
[11:02:17.774]                         supportsMulticore(warn = TRUE)
[11:02:17.774]                       return(sequential(..., envir = envir))
[11:02:17.774]                     }
[11:02:17.774]                     oopts <- options(mc.cores = workers)
[11:02:17.774]                     on.exit(options(oopts))
[11:02:17.774]                     future <- MulticoreFuture(..., workers = workers, 
[11:02:17.774]                       envir = envir)
[11:02:17.774]                     if (!future$lazy) 
[11:02:17.774]                       future <- run(future)
[11:02:17.774]                     invisible(future)
[11:02:17.774]                   }), .cleanup = FALSE, .init = FALSE)
[11:02:17.774]                 }
[11:02:17.774]                 ...future.workdir <- getwd()
[11:02:17.774]             }
[11:02:17.774]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:17.774]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:17.774]         }
[11:02:17.774]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:17.774]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:17.774]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:17.774]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:17.774]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:17.774]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:17.774]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:17.774]             base::names(...future.oldOptions))
[11:02:17.774]     }
[11:02:17.774]     if (FALSE) {
[11:02:17.774]     }
[11:02:17.774]     else {
[11:02:17.774]         if (TRUE) {
[11:02:17.774]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:17.774]                 open = "w")
[11:02:17.774]         }
[11:02:17.774]         else {
[11:02:17.774]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:17.774]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:17.774]         }
[11:02:17.774]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:17.774]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:17.774]             base::sink(type = "output", split = FALSE)
[11:02:17.774]             base::close(...future.stdout)
[11:02:17.774]         }, add = TRUE)
[11:02:17.774]     }
[11:02:17.774]     ...future.frame <- base::sys.nframe()
[11:02:17.774]     ...future.conditions <- base::list()
[11:02:17.774]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:17.774]     if (FALSE) {
[11:02:17.774]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:17.774]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:17.774]     }
[11:02:17.774]     ...future.result <- base::tryCatch({
[11:02:17.774]         base::withCallingHandlers({
[11:02:17.774]             ...future.value <- base::withVisible(base::local({
[11:02:17.774]                 ...future.makeSendCondition <- base::local({
[11:02:17.774]                   sendCondition <- NULL
[11:02:17.774]                   function(frame = 1L) {
[11:02:17.774]                     if (is.function(sendCondition)) 
[11:02:17.774]                       return(sendCondition)
[11:02:17.774]                     ns <- getNamespace("parallel")
[11:02:17.774]                     if (exists("sendData", mode = "function", 
[11:02:17.774]                       envir = ns)) {
[11:02:17.774]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:17.774]                         envir = ns)
[11:02:17.774]                       envir <- sys.frame(frame)
[11:02:17.774]                       master <- NULL
[11:02:17.774]                       while (!identical(envir, .GlobalEnv) && 
[11:02:17.774]                         !identical(envir, emptyenv())) {
[11:02:17.774]                         if (exists("master", mode = "list", envir = envir, 
[11:02:17.774]                           inherits = FALSE)) {
[11:02:17.774]                           master <- get("master", mode = "list", 
[11:02:17.774]                             envir = envir, inherits = FALSE)
[11:02:17.774]                           if (inherits(master, c("SOCKnode", 
[11:02:17.774]                             "SOCK0node"))) {
[11:02:17.774]                             sendCondition <<- function(cond) {
[11:02:17.774]                               data <- list(type = "VALUE", value = cond, 
[11:02:17.774]                                 success = TRUE)
[11:02:17.774]                               parallel_sendData(master, data)
[11:02:17.774]                             }
[11:02:17.774]                             return(sendCondition)
[11:02:17.774]                           }
[11:02:17.774]                         }
[11:02:17.774]                         frame <- frame + 1L
[11:02:17.774]                         envir <- sys.frame(frame)
[11:02:17.774]                       }
[11:02:17.774]                     }
[11:02:17.774]                     sendCondition <<- function(cond) NULL
[11:02:17.774]                   }
[11:02:17.774]                 })
[11:02:17.774]                 withCallingHandlers({
[11:02:17.774]                   {
[11:02:17.774]                     value(future(subset(data, a == 2)))
[11:02:17.774]                   }
[11:02:17.774]                 }, immediateCondition = function(cond) {
[11:02:17.774]                   sendCondition <- ...future.makeSendCondition()
[11:02:17.774]                   sendCondition(cond)
[11:02:17.774]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:17.774]                   {
[11:02:17.774]                     inherits <- base::inherits
[11:02:17.774]                     invokeRestart <- base::invokeRestart
[11:02:17.774]                     is.null <- base::is.null
[11:02:17.774]                     muffled <- FALSE
[11:02:17.774]                     if (inherits(cond, "message")) {
[11:02:17.774]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:17.774]                       if (muffled) 
[11:02:17.774]                         invokeRestart("muffleMessage")
[11:02:17.774]                     }
[11:02:17.774]                     else if (inherits(cond, "warning")) {
[11:02:17.774]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:17.774]                       if (muffled) 
[11:02:17.774]                         invokeRestart("muffleWarning")
[11:02:17.774]                     }
[11:02:17.774]                     else if (inherits(cond, "condition")) {
[11:02:17.774]                       if (!is.null(pattern)) {
[11:02:17.774]                         computeRestarts <- base::computeRestarts
[11:02:17.774]                         grepl <- base::grepl
[11:02:17.774]                         restarts <- computeRestarts(cond)
[11:02:17.774]                         for (restart in restarts) {
[11:02:17.774]                           name <- restart$name
[11:02:17.774]                           if (is.null(name)) 
[11:02:17.774]                             next
[11:02:17.774]                           if (!grepl(pattern, name)) 
[11:02:17.774]                             next
[11:02:17.774]                           invokeRestart(restart)
[11:02:17.774]                           muffled <- TRUE
[11:02:17.774]                           break
[11:02:17.774]                         }
[11:02:17.774]                       }
[11:02:17.774]                     }
[11:02:17.774]                     invisible(muffled)
[11:02:17.774]                   }
[11:02:17.774]                   muffleCondition(cond)
[11:02:17.774]                 })
[11:02:17.774]             }))
[11:02:17.774]             future::FutureResult(value = ...future.value$value, 
[11:02:17.774]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:17.774]                   ...future.rng), globalenv = if (FALSE) 
[11:02:17.774]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:17.774]                     ...future.globalenv.names))
[11:02:17.774]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:17.774]         }, condition = base::local({
[11:02:17.774]             c <- base::c
[11:02:17.774]             inherits <- base::inherits
[11:02:17.774]             invokeRestart <- base::invokeRestart
[11:02:17.774]             length <- base::length
[11:02:17.774]             list <- base::list
[11:02:17.774]             seq.int <- base::seq.int
[11:02:17.774]             signalCondition <- base::signalCondition
[11:02:17.774]             sys.calls <- base::sys.calls
[11:02:17.774]             `[[` <- base::`[[`
[11:02:17.774]             `+` <- base::`+`
[11:02:17.774]             `<<-` <- base::`<<-`
[11:02:17.774]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:17.774]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:17.774]                   3L)]
[11:02:17.774]             }
[11:02:17.774]             function(cond) {
[11:02:17.774]                 is_error <- inherits(cond, "error")
[11:02:17.774]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:17.774]                   NULL)
[11:02:17.774]                 if (is_error) {
[11:02:17.774]                   sessionInformation <- function() {
[11:02:17.774]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:17.774]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:17.774]                       search = base::search(), system = base::Sys.info())
[11:02:17.774]                   }
[11:02:17.774]                   ...future.conditions[[length(...future.conditions) + 
[11:02:17.774]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:17.774]                     cond$call), session = sessionInformation(), 
[11:02:17.774]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:17.774]                   signalCondition(cond)
[11:02:17.774]                 }
[11:02:17.774]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:17.774]                 "immediateCondition"))) {
[11:02:17.774]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:17.774]                   ...future.conditions[[length(...future.conditions) + 
[11:02:17.774]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:17.774]                   if (TRUE && !signal) {
[11:02:17.774]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:17.774]                     {
[11:02:17.774]                       inherits <- base::inherits
[11:02:17.774]                       invokeRestart <- base::invokeRestart
[11:02:17.774]                       is.null <- base::is.null
[11:02:17.774]                       muffled <- FALSE
[11:02:17.774]                       if (inherits(cond, "message")) {
[11:02:17.774]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:17.774]                         if (muffled) 
[11:02:17.774]                           invokeRestart("muffleMessage")
[11:02:17.774]                       }
[11:02:17.774]                       else if (inherits(cond, "warning")) {
[11:02:17.774]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:17.774]                         if (muffled) 
[11:02:17.774]                           invokeRestart("muffleWarning")
[11:02:17.774]                       }
[11:02:17.774]                       else if (inherits(cond, "condition")) {
[11:02:17.774]                         if (!is.null(pattern)) {
[11:02:17.774]                           computeRestarts <- base::computeRestarts
[11:02:17.774]                           grepl <- base::grepl
[11:02:17.774]                           restarts <- computeRestarts(cond)
[11:02:17.774]                           for (restart in restarts) {
[11:02:17.774]                             name <- restart$name
[11:02:17.774]                             if (is.null(name)) 
[11:02:17.774]                               next
[11:02:17.774]                             if (!grepl(pattern, name)) 
[11:02:17.774]                               next
[11:02:17.774]                             invokeRestart(restart)
[11:02:17.774]                             muffled <- TRUE
[11:02:17.774]                             break
[11:02:17.774]                           }
[11:02:17.774]                         }
[11:02:17.774]                       }
[11:02:17.774]                       invisible(muffled)
[11:02:17.774]                     }
[11:02:17.774]                     muffleCondition(cond, pattern = "^muffle")
[11:02:17.774]                   }
[11:02:17.774]                 }
[11:02:17.774]                 else {
[11:02:17.774]                   if (TRUE) {
[11:02:17.774]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:17.774]                     {
[11:02:17.774]                       inherits <- base::inherits
[11:02:17.774]                       invokeRestart <- base::invokeRestart
[11:02:17.774]                       is.null <- base::is.null
[11:02:17.774]                       muffled <- FALSE
[11:02:17.774]                       if (inherits(cond, "message")) {
[11:02:17.774]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:17.774]                         if (muffled) 
[11:02:17.774]                           invokeRestart("muffleMessage")
[11:02:17.774]                       }
[11:02:17.774]                       else if (inherits(cond, "warning")) {
[11:02:17.774]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:17.774]                         if (muffled) 
[11:02:17.774]                           invokeRestart("muffleWarning")
[11:02:17.774]                       }
[11:02:17.774]                       else if (inherits(cond, "condition")) {
[11:02:17.774]                         if (!is.null(pattern)) {
[11:02:17.774]                           computeRestarts <- base::computeRestarts
[11:02:17.774]                           grepl <- base::grepl
[11:02:17.774]                           restarts <- computeRestarts(cond)
[11:02:17.774]                           for (restart in restarts) {
[11:02:17.774]                             name <- restart$name
[11:02:17.774]                             if (is.null(name)) 
[11:02:17.774]                               next
[11:02:17.774]                             if (!grepl(pattern, name)) 
[11:02:17.774]                               next
[11:02:17.774]                             invokeRestart(restart)
[11:02:17.774]                             muffled <- TRUE
[11:02:17.774]                             break
[11:02:17.774]                           }
[11:02:17.774]                         }
[11:02:17.774]                       }
[11:02:17.774]                       invisible(muffled)
[11:02:17.774]                     }
[11:02:17.774]                     muffleCondition(cond, pattern = "^muffle")
[11:02:17.774]                   }
[11:02:17.774]                 }
[11:02:17.774]             }
[11:02:17.774]         }))
[11:02:17.774]     }, error = function(ex) {
[11:02:17.774]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:17.774]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:17.774]                 ...future.rng), started = ...future.startTime, 
[11:02:17.774]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:17.774]             version = "1.8"), class = "FutureResult")
[11:02:17.774]     }, finally = {
[11:02:17.774]         if (!identical(...future.workdir, getwd())) 
[11:02:17.774]             setwd(...future.workdir)
[11:02:17.774]         {
[11:02:17.774]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:17.774]                 ...future.oldOptions$nwarnings <- NULL
[11:02:17.774]             }
[11:02:17.774]             base::options(...future.oldOptions)
[11:02:17.774]             if (.Platform$OS.type == "windows") {
[11:02:17.774]                 old_names <- names(...future.oldEnvVars)
[11:02:17.774]                 envs <- base::Sys.getenv()
[11:02:17.774]                 names <- names(envs)
[11:02:17.774]                 common <- intersect(names, old_names)
[11:02:17.774]                 added <- setdiff(names, old_names)
[11:02:17.774]                 removed <- setdiff(old_names, names)
[11:02:17.774]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:17.774]                   envs[common]]
[11:02:17.774]                 NAMES <- toupper(changed)
[11:02:17.774]                 args <- list()
[11:02:17.774]                 for (kk in seq_along(NAMES)) {
[11:02:17.774]                   name <- changed[[kk]]
[11:02:17.774]                   NAME <- NAMES[[kk]]
[11:02:17.774]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:17.774]                     next
[11:02:17.774]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:17.774]                 }
[11:02:17.774]                 NAMES <- toupper(added)
[11:02:17.774]                 for (kk in seq_along(NAMES)) {
[11:02:17.774]                   name <- added[[kk]]
[11:02:17.774]                   NAME <- NAMES[[kk]]
[11:02:17.774]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:17.774]                     next
[11:02:17.774]                   args[[name]] <- ""
[11:02:17.774]                 }
[11:02:17.774]                 NAMES <- toupper(removed)
[11:02:17.774]                 for (kk in seq_along(NAMES)) {
[11:02:17.774]                   name <- removed[[kk]]
[11:02:17.774]                   NAME <- NAMES[[kk]]
[11:02:17.774]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:17.774]                     next
[11:02:17.774]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:17.774]                 }
[11:02:17.774]                 if (length(args) > 0) 
[11:02:17.774]                   base::do.call(base::Sys.setenv, args = args)
[11:02:17.774]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:17.774]             }
[11:02:17.774]             else {
[11:02:17.774]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:17.774]             }
[11:02:17.774]             {
[11:02:17.774]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:17.774]                   0L) {
[11:02:17.774]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:17.774]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:17.774]                   base::options(opts)
[11:02:17.774]                 }
[11:02:17.774]                 {
[11:02:17.774]                   {
[11:02:17.774]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:17.774]                     NULL
[11:02:17.774]                   }
[11:02:17.774]                   options(future.plan = NULL)
[11:02:17.774]                   if (is.na(NA_character_)) 
[11:02:17.774]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:17.774]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:17.774]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:17.774]                     .init = FALSE)
[11:02:17.774]                 }
[11:02:17.774]             }
[11:02:17.774]         }
[11:02:17.774]     })
[11:02:17.774]     if (TRUE) {
[11:02:17.774]         base::sink(type = "output", split = FALSE)
[11:02:17.774]         if (TRUE) {
[11:02:17.774]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:17.774]         }
[11:02:17.774]         else {
[11:02:17.774]             ...future.result["stdout"] <- base::list(NULL)
[11:02:17.774]         }
[11:02:17.774]         base::close(...future.stdout)
[11:02:17.774]         ...future.stdout <- NULL
[11:02:17.774]     }
[11:02:17.774]     ...future.result$conditions <- ...future.conditions
[11:02:17.774]     ...future.result$finished <- base::Sys.time()
[11:02:17.774]     ...future.result
[11:02:17.774] }
[11:02:17.777] Exporting 1 global objects (643 bytes) to cluster node #1 ...
[11:02:17.777] Exporting ‘data’ (356 bytes) to cluster node #1 ...
[11:02:17.777] Exporting ‘data’ (356 bytes) to cluster node #1 ... DONE
[11:02:17.777] Exporting 1 global objects (643 bytes) to cluster node #1 ... DONE
[11:02:17.778] MultisessionFuture started
[11:02:17.778] - Launch lazy future ... done
[11:02:17.778] run() for ‘MultisessionFuture’ ... done
[11:02:17.778] result() for ClusterFuture ...
[11:02:17.778] receiveMessageFromWorker() for ClusterFuture ...
[11:02:17.778] - Validating connection of MultisessionFuture
[11:02:17.826] - received message: FutureResult
[11:02:17.827] - Received FutureResult
[11:02:17.827] - Erased future from FutureRegistry
[11:02:17.827] result() for ClusterFuture ...
[11:02:17.827] - result already collected: FutureResult
[11:02:17.827] result() for ClusterFuture ... done
[11:02:17.827] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:17.827] result() for ClusterFuture ... done
[11:02:17.827] result() for ClusterFuture ...
[11:02:17.827] - result already collected: FutureResult
[11:02:17.828] result() for ClusterFuture ... done
- plan(list('multisession', 'multicore')) ... DONE
- plan(list('multisession', 'multisession')) ...
[11:02:17.828] plan(): Setting new future strategy stack:
[11:02:17.828] List of future strategies:
[11:02:17.828] 1. multisession:
[11:02:17.828]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:02:17.828]    - tweaked: FALSE
[11:02:17.828]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:17.828] 2. multisession:
[11:02:17.828]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:02:17.828]    - tweaked: FALSE
[11:02:17.828]    - call: plan(list(a = strategy1, b = strategy2))
[11:02:17.829] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[11:02:17.829] multisession:
[11:02:17.829] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:02:17.829] - tweaked: FALSE
[11:02:17.829] - call: plan(list(a = strategy1, b = strategy2))
[11:02:17.831] getGlobalsAndPackages() ...
[11:02:17.831] Not searching for globals
[11:02:17.831] - globals: [0] <none>
[11:02:17.831] getGlobalsAndPackages() ... DONE
[11:02:18.090] Packages needed by the future expression (n = 0): <none>
[11:02:18.090] Packages needed by future strategies (n = 1): ‘future’
[11:02:18.091] {
[11:02:18.091]     {
[11:02:18.091]         {
[11:02:18.091]             ...future.startTime <- base::Sys.time()
[11:02:18.091]             {
[11:02:18.091]                 {
[11:02:18.091]                   {
[11:02:18.091]                     {
[11:02:18.091]                       {
[11:02:18.091]                         base::local({
[11:02:18.091]                           has_future <- base::requireNamespace("future", 
[11:02:18.091]                             quietly = TRUE)
[11:02:18.091]                           if (has_future) {
[11:02:18.091]                             ns <- base::getNamespace("future")
[11:02:18.091]                             version <- ns[[".package"]][["version"]]
[11:02:18.091]                             if (is.null(version)) 
[11:02:18.091]                               version <- utils::packageVersion("future")
[11:02:18.091]                           }
[11:02:18.091]                           else {
[11:02:18.091]                             version <- NULL
[11:02:18.091]                           }
[11:02:18.091]                           if (!has_future || version < "1.8.0") {
[11:02:18.091]                             info <- base::c(r_version = base::gsub("R version ", 
[11:02:18.091]                               "", base::R.version$version.string), 
[11:02:18.091]                               platform = base::sprintf("%s (%s-bit)", 
[11:02:18.091]                                 base::R.version$platform, 8 * 
[11:02:18.091]                                   base::.Machine$sizeof.pointer), 
[11:02:18.091]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:18.091]                                 "release", "version")], collapse = " "), 
[11:02:18.091]                               hostname = base::Sys.info()[["nodename"]])
[11:02:18.091]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:02:18.091]                               info)
[11:02:18.091]                             info <- base::paste(info, collapse = "; ")
[11:02:18.091]                             if (!has_future) {
[11:02:18.091]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:18.091]                                 info)
[11:02:18.091]                             }
[11:02:18.091]                             else {
[11:02:18.091]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:18.091]                                 info, version)
[11:02:18.091]                             }
[11:02:18.091]                             base::stop(msg)
[11:02:18.091]                           }
[11:02:18.091]                         })
[11:02:18.091]                       }
[11:02:18.091]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:18.091]                       base::options(mc.cores = 1L)
[11:02:18.091]                     }
[11:02:18.091]                     base::local({
[11:02:18.091]                       for (pkg in "future") {
[11:02:18.091]                         base::loadNamespace(pkg)
[11:02:18.091]                         base::library(pkg, character.only = TRUE)
[11:02:18.091]                       }
[11:02:18.091]                     })
[11:02:18.091]                   }
[11:02:18.091]                   ...future.strategy.old <- future::plan("list")
[11:02:18.091]                   options(future.plan = NULL)
[11:02:18.091]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:18.091]                   future::plan(list(b = function (..., workers = availableCores(), 
[11:02:18.091]                     lazy = FALSE, rscript_libs = .libPaths(), 
[11:02:18.091]                     envir = parent.frame()) 
[11:02:18.091]                   {
[11:02:18.091]                     if (is.function(workers)) 
[11:02:18.091]                       workers <- workers()
[11:02:18.091]                     workers <- structure(as.integer(workers), 
[11:02:18.091]                       class = class(workers))
[11:02:18.091]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[11:02:18.091]                       workers >= 1)
[11:02:18.091]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[11:02:18.091]                       return(sequential(..., lazy = TRUE, envir = envir))
[11:02:18.091]                     }
[11:02:18.091]                     future <- MultisessionFuture(..., workers = workers, 
[11:02:18.091]                       lazy = lazy, rscript_libs = rscript_libs, 
[11:02:18.091]                       envir = envir)
[11:02:18.091]                     if (!future$lazy) 
[11:02:18.091]                       future <- run(future)
[11:02:18.091]                     invisible(future)
[11:02:18.091]                   }), .cleanup = FALSE, .init = FALSE)
[11:02:18.091]                 }
[11:02:18.091]                 ...future.workdir <- getwd()
[11:02:18.091]             }
[11:02:18.091]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:18.091]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:18.091]         }
[11:02:18.091]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:18.091]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:18.091]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:18.091]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:18.091]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:18.091]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:18.091]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:18.091]             base::names(...future.oldOptions))
[11:02:18.091]     }
[11:02:18.091]     if (FALSE) {
[11:02:18.091]     }
[11:02:18.091]     else {
[11:02:18.091]         if (TRUE) {
[11:02:18.091]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:18.091]                 open = "w")
[11:02:18.091]         }
[11:02:18.091]         else {
[11:02:18.091]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:18.091]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:18.091]         }
[11:02:18.091]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:18.091]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:18.091]             base::sink(type = "output", split = FALSE)
[11:02:18.091]             base::close(...future.stdout)
[11:02:18.091]         }, add = TRUE)
[11:02:18.091]     }
[11:02:18.091]     ...future.frame <- base::sys.nframe()
[11:02:18.091]     ...future.conditions <- base::list()
[11:02:18.091]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:18.091]     if (FALSE) {
[11:02:18.091]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:18.091]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:18.091]     }
[11:02:18.091]     ...future.result <- base::tryCatch({
[11:02:18.091]         base::withCallingHandlers({
[11:02:18.091]             ...future.value <- base::withVisible(base::local({
[11:02:18.091]                 ...future.makeSendCondition <- base::local({
[11:02:18.091]                   sendCondition <- NULL
[11:02:18.091]                   function(frame = 1L) {
[11:02:18.091]                     if (is.function(sendCondition)) 
[11:02:18.091]                       return(sendCondition)
[11:02:18.091]                     ns <- getNamespace("parallel")
[11:02:18.091]                     if (exists("sendData", mode = "function", 
[11:02:18.091]                       envir = ns)) {
[11:02:18.091]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:18.091]                         envir = ns)
[11:02:18.091]                       envir <- sys.frame(frame)
[11:02:18.091]                       master <- NULL
[11:02:18.091]                       while (!identical(envir, .GlobalEnv) && 
[11:02:18.091]                         !identical(envir, emptyenv())) {
[11:02:18.091]                         if (exists("master", mode = "list", envir = envir, 
[11:02:18.091]                           inherits = FALSE)) {
[11:02:18.091]                           master <- get("master", mode = "list", 
[11:02:18.091]                             envir = envir, inherits = FALSE)
[11:02:18.091]                           if (inherits(master, c("SOCKnode", 
[11:02:18.091]                             "SOCK0node"))) {
[11:02:18.091]                             sendCondition <<- function(cond) {
[11:02:18.091]                               data <- list(type = "VALUE", value = cond, 
[11:02:18.091]                                 success = TRUE)
[11:02:18.091]                               parallel_sendData(master, data)
[11:02:18.091]                             }
[11:02:18.091]                             return(sendCondition)
[11:02:18.091]                           }
[11:02:18.091]                         }
[11:02:18.091]                         frame <- frame + 1L
[11:02:18.091]                         envir <- sys.frame(frame)
[11:02:18.091]                       }
[11:02:18.091]                     }
[11:02:18.091]                     sendCondition <<- function(cond) NULL
[11:02:18.091]                   }
[11:02:18.091]                 })
[11:02:18.091]                 withCallingHandlers({
[11:02:18.091]                   NA
[11:02:18.091]                 }, immediateCondition = function(cond) {
[11:02:18.091]                   sendCondition <- ...future.makeSendCondition()
[11:02:18.091]                   sendCondition(cond)
[11:02:18.091]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:18.091]                   {
[11:02:18.091]                     inherits <- base::inherits
[11:02:18.091]                     invokeRestart <- base::invokeRestart
[11:02:18.091]                     is.null <- base::is.null
[11:02:18.091]                     muffled <- FALSE
[11:02:18.091]                     if (inherits(cond, "message")) {
[11:02:18.091]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:18.091]                       if (muffled) 
[11:02:18.091]                         invokeRestart("muffleMessage")
[11:02:18.091]                     }
[11:02:18.091]                     else if (inherits(cond, "warning")) {
[11:02:18.091]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:18.091]                       if (muffled) 
[11:02:18.091]                         invokeRestart("muffleWarning")
[11:02:18.091]                     }
[11:02:18.091]                     else if (inherits(cond, "condition")) {
[11:02:18.091]                       if (!is.null(pattern)) {
[11:02:18.091]                         computeRestarts <- base::computeRestarts
[11:02:18.091]                         grepl <- base::grepl
[11:02:18.091]                         restarts <- computeRestarts(cond)
[11:02:18.091]                         for (restart in restarts) {
[11:02:18.091]                           name <- restart$name
[11:02:18.091]                           if (is.null(name)) 
[11:02:18.091]                             next
[11:02:18.091]                           if (!grepl(pattern, name)) 
[11:02:18.091]                             next
[11:02:18.091]                           invokeRestart(restart)
[11:02:18.091]                           muffled <- TRUE
[11:02:18.091]                           break
[11:02:18.091]                         }
[11:02:18.091]                       }
[11:02:18.091]                     }
[11:02:18.091]                     invisible(muffled)
[11:02:18.091]                   }
[11:02:18.091]                   muffleCondition(cond)
[11:02:18.091]                 })
[11:02:18.091]             }))
[11:02:18.091]             future::FutureResult(value = ...future.value$value, 
[11:02:18.091]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:18.091]                   ...future.rng), globalenv = if (FALSE) 
[11:02:18.091]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:18.091]                     ...future.globalenv.names))
[11:02:18.091]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:18.091]         }, condition = base::local({
[11:02:18.091]             c <- base::c
[11:02:18.091]             inherits <- base::inherits
[11:02:18.091]             invokeRestart <- base::invokeRestart
[11:02:18.091]             length <- base::length
[11:02:18.091]             list <- base::list
[11:02:18.091]             seq.int <- base::seq.int
[11:02:18.091]             signalCondition <- base::signalCondition
[11:02:18.091]             sys.calls <- base::sys.calls
[11:02:18.091]             `[[` <- base::`[[`
[11:02:18.091]             `+` <- base::`+`
[11:02:18.091]             `<<-` <- base::`<<-`
[11:02:18.091]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:18.091]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:18.091]                   3L)]
[11:02:18.091]             }
[11:02:18.091]             function(cond) {
[11:02:18.091]                 is_error <- inherits(cond, "error")
[11:02:18.091]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:18.091]                   NULL)
[11:02:18.091]                 if (is_error) {
[11:02:18.091]                   sessionInformation <- function() {
[11:02:18.091]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:18.091]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:18.091]                       search = base::search(), system = base::Sys.info())
[11:02:18.091]                   }
[11:02:18.091]                   ...future.conditions[[length(...future.conditions) + 
[11:02:18.091]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:18.091]                     cond$call), session = sessionInformation(), 
[11:02:18.091]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:18.091]                   signalCondition(cond)
[11:02:18.091]                 }
[11:02:18.091]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:18.091]                 "immediateCondition"))) {
[11:02:18.091]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:18.091]                   ...future.conditions[[length(...future.conditions) + 
[11:02:18.091]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:18.091]                   if (TRUE && !signal) {
[11:02:18.091]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:18.091]                     {
[11:02:18.091]                       inherits <- base::inherits
[11:02:18.091]                       invokeRestart <- base::invokeRestart
[11:02:18.091]                       is.null <- base::is.null
[11:02:18.091]                       muffled <- FALSE
[11:02:18.091]                       if (inherits(cond, "message")) {
[11:02:18.091]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:18.091]                         if (muffled) 
[11:02:18.091]                           invokeRestart("muffleMessage")
[11:02:18.091]                       }
[11:02:18.091]                       else if (inherits(cond, "warning")) {
[11:02:18.091]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:18.091]                         if (muffled) 
[11:02:18.091]                           invokeRestart("muffleWarning")
[11:02:18.091]                       }
[11:02:18.091]                       else if (inherits(cond, "condition")) {
[11:02:18.091]                         if (!is.null(pattern)) {
[11:02:18.091]                           computeRestarts <- base::computeRestarts
[11:02:18.091]                           grepl <- base::grepl
[11:02:18.091]                           restarts <- computeRestarts(cond)
[11:02:18.091]                           for (restart in restarts) {
[11:02:18.091]                             name <- restart$name
[11:02:18.091]                             if (is.null(name)) 
[11:02:18.091]                               next
[11:02:18.091]                             if (!grepl(pattern, name)) 
[11:02:18.091]                               next
[11:02:18.091]                             invokeRestart(restart)
[11:02:18.091]                             muffled <- TRUE
[11:02:18.091]                             break
[11:02:18.091]                           }
[11:02:18.091]                         }
[11:02:18.091]                       }
[11:02:18.091]                       invisible(muffled)
[11:02:18.091]                     }
[11:02:18.091]                     muffleCondition(cond, pattern = "^muffle")
[11:02:18.091]                   }
[11:02:18.091]                 }
[11:02:18.091]                 else {
[11:02:18.091]                   if (TRUE) {
[11:02:18.091]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:18.091]                     {
[11:02:18.091]                       inherits <- base::inherits
[11:02:18.091]                       invokeRestart <- base::invokeRestart
[11:02:18.091]                       is.null <- base::is.null
[11:02:18.091]                       muffled <- FALSE
[11:02:18.091]                       if (inherits(cond, "message")) {
[11:02:18.091]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:18.091]                         if (muffled) 
[11:02:18.091]                           invokeRestart("muffleMessage")
[11:02:18.091]                       }
[11:02:18.091]                       else if (inherits(cond, "warning")) {
[11:02:18.091]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:18.091]                         if (muffled) 
[11:02:18.091]                           invokeRestart("muffleWarning")
[11:02:18.091]                       }
[11:02:18.091]                       else if (inherits(cond, "condition")) {
[11:02:18.091]                         if (!is.null(pattern)) {
[11:02:18.091]                           computeRestarts <- base::computeRestarts
[11:02:18.091]                           grepl <- base::grepl
[11:02:18.091]                           restarts <- computeRestarts(cond)
[11:02:18.091]                           for (restart in restarts) {
[11:02:18.091]                             name <- restart$name
[11:02:18.091]                             if (is.null(name)) 
[11:02:18.091]                               next
[11:02:18.091]                             if (!grepl(pattern, name)) 
[11:02:18.091]                               next
[11:02:18.091]                             invokeRestart(restart)
[11:02:18.091]                             muffled <- TRUE
[11:02:18.091]                             break
[11:02:18.091]                           }
[11:02:18.091]                         }
[11:02:18.091]                       }
[11:02:18.091]                       invisible(muffled)
[11:02:18.091]                     }
[11:02:18.091]                     muffleCondition(cond, pattern = "^muffle")
[11:02:18.091]                   }
[11:02:18.091]                 }
[11:02:18.091]             }
[11:02:18.091]         }))
[11:02:18.091]     }, error = function(ex) {
[11:02:18.091]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:18.091]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:18.091]                 ...future.rng), started = ...future.startTime, 
[11:02:18.091]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:18.091]             version = "1.8"), class = "FutureResult")
[11:02:18.091]     }, finally = {
[11:02:18.091]         if (!identical(...future.workdir, getwd())) 
[11:02:18.091]             setwd(...future.workdir)
[11:02:18.091]         {
[11:02:18.091]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:18.091]                 ...future.oldOptions$nwarnings <- NULL
[11:02:18.091]             }
[11:02:18.091]             base::options(...future.oldOptions)
[11:02:18.091]             if (.Platform$OS.type == "windows") {
[11:02:18.091]                 old_names <- names(...future.oldEnvVars)
[11:02:18.091]                 envs <- base::Sys.getenv()
[11:02:18.091]                 names <- names(envs)
[11:02:18.091]                 common <- intersect(names, old_names)
[11:02:18.091]                 added <- setdiff(names, old_names)
[11:02:18.091]                 removed <- setdiff(old_names, names)
[11:02:18.091]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:18.091]                   envs[common]]
[11:02:18.091]                 NAMES <- toupper(changed)
[11:02:18.091]                 args <- list()
[11:02:18.091]                 for (kk in seq_along(NAMES)) {
[11:02:18.091]                   name <- changed[[kk]]
[11:02:18.091]                   NAME <- NAMES[[kk]]
[11:02:18.091]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:18.091]                     next
[11:02:18.091]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:18.091]                 }
[11:02:18.091]                 NAMES <- toupper(added)
[11:02:18.091]                 for (kk in seq_along(NAMES)) {
[11:02:18.091]                   name <- added[[kk]]
[11:02:18.091]                   NAME <- NAMES[[kk]]
[11:02:18.091]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:18.091]                     next
[11:02:18.091]                   args[[name]] <- ""
[11:02:18.091]                 }
[11:02:18.091]                 NAMES <- toupper(removed)
[11:02:18.091]                 for (kk in seq_along(NAMES)) {
[11:02:18.091]                   name <- removed[[kk]]
[11:02:18.091]                   NAME <- NAMES[[kk]]
[11:02:18.091]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:18.091]                     next
[11:02:18.091]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:18.091]                 }
[11:02:18.091]                 if (length(args) > 0) 
[11:02:18.091]                   base::do.call(base::Sys.setenv, args = args)
[11:02:18.091]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:18.091]             }
[11:02:18.091]             else {
[11:02:18.091]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:18.091]             }
[11:02:18.091]             {
[11:02:18.091]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:18.091]                   0L) {
[11:02:18.091]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:18.091]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:18.091]                   base::options(opts)
[11:02:18.091]                 }
[11:02:18.091]                 {
[11:02:18.091]                   {
[11:02:18.091]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:18.091]                     NULL
[11:02:18.091]                   }
[11:02:18.091]                   options(future.plan = NULL)
[11:02:18.091]                   if (is.na(NA_character_)) 
[11:02:18.091]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:18.091]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:18.091]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:18.091]                     .init = FALSE)
[11:02:18.091]                 }
[11:02:18.091]             }
[11:02:18.091]         }
[11:02:18.091]     })
[11:02:18.091]     if (TRUE) {
[11:02:18.091]         base::sink(type = "output", split = FALSE)
[11:02:18.091]         if (TRUE) {
[11:02:18.091]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:18.091]         }
[11:02:18.091]         else {
[11:02:18.091]             ...future.result["stdout"] <- base::list(NULL)
[11:02:18.091]         }
[11:02:18.091]         base::close(...future.stdout)
[11:02:18.091]         ...future.stdout <- NULL
[11:02:18.091]     }
[11:02:18.091]     ...future.result$conditions <- ...future.conditions
[11:02:18.091]     ...future.result$finished <- base::Sys.time()
[11:02:18.091]     ...future.result
[11:02:18.091] }
[11:02:18.143] MultisessionFuture started
[11:02:18.143] result() for ClusterFuture ...
[11:02:18.143] receiveMessageFromWorker() for ClusterFuture ...
[11:02:18.143] - Validating connection of MultisessionFuture
[11:02:18.192] - received message: FutureResult
[11:02:18.192] - Received FutureResult
[11:02:18.192] - Erased future from FutureRegistry
[11:02:18.192] result() for ClusterFuture ...
[11:02:18.192] - result already collected: FutureResult
[11:02:18.193] result() for ClusterFuture ... done
[11:02:18.193] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:18.193] result() for ClusterFuture ... done
[11:02:18.193] result() for ClusterFuture ...
[11:02:18.193] - result already collected: FutureResult
[11:02:18.193] result() for ClusterFuture ... done
[11:02:18.193] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[11:02:18.195] plan(): nbrOfWorkers() = 2
[11:02:18.195] getGlobalsAndPackages() ...
[11:02:18.195] Searching for globals...
[11:02:18.210] - globals found: [21] ‘{’, ‘<-’, ‘unclass’, ‘::’, ‘[’, ‘nested’, ‘-’, ‘stopifnot’, ‘==’, ‘length’, ‘inherits’, ‘[[’, ‘strategy2’, ‘for’, ‘seq_along’, ‘attr’, ‘attr<-’, ‘[[<-’, ‘all.equal’, ‘list’, ‘%<-%’
[11:02:18.211] Searching for globals ... DONE
[11:02:18.211] Resolving globals: FALSE
[11:02:18.212] The total size of the 2 globals is 11.25 KiB (11520 bytes)
[11:02:18.212] The total size of the 2 globals exported for future expression (‘{; a <- 1L; plan_a <- unclass(future::plan("list")); nested_a <- nested[-1]; stopifnot(length(nested_a) == 1L, length(plan_a) == 1L, inherits(plan_a[[1]],; "future"), inherits(future::plan("next"), strategy2)); ...; }; y; }’) is 11.25 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘nested’ (11.20 KiB of class ‘list’) and ‘strategy2’ (51 bytes of class ‘character’)
[11:02:18.212] - globals: [2] ‘nested’, ‘strategy2’
[11:02:18.212] - packages: [1] ‘future’
[11:02:18.212] getGlobalsAndPackages() ... DONE
[11:02:18.213] run() for ‘Future’ ...
[11:02:18.213] - state: ‘created’
[11:02:18.213] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:18.227] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:18.227] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:18.227]   - Field: ‘node’
[11:02:18.227]   - Field: ‘label’
[11:02:18.227]   - Field: ‘local’
[11:02:18.227]   - Field: ‘owner’
[11:02:18.227]   - Field: ‘envir’
[11:02:18.228]   - Field: ‘workers’
[11:02:18.228]   - Field: ‘packages’
[11:02:18.228]   - Field: ‘gc’
[11:02:18.228]   - Field: ‘conditions’
[11:02:18.228]   - Field: ‘persistent’
[11:02:18.228]   - Field: ‘expr’
[11:02:18.230]   - Field: ‘uuid’
[11:02:18.230]   - Field: ‘seed’
[11:02:18.230]   - Field: ‘version’
[11:02:18.231]   - Field: ‘result’
[11:02:18.231]   - Field: ‘asynchronous’
[11:02:18.231]   - Field: ‘calls’
[11:02:18.231]   - Field: ‘globals’
[11:02:18.231]   - Field: ‘stdout’
[11:02:18.231]   - Field: ‘earlySignal’
[11:02:18.231]   - Field: ‘lazy’
[11:02:18.231]   - Field: ‘state’
[11:02:18.231] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:18.231] - Launch lazy future ...
[11:02:18.232] Packages needed by the future expression (n = 1): ‘future’
[11:02:18.232] Packages needed by future strategies (n = 1): ‘future’
[11:02:18.232] {
[11:02:18.232]     {
[11:02:18.232]         {
[11:02:18.232]             ...future.startTime <- base::Sys.time()
[11:02:18.232]             {
[11:02:18.232]                 {
[11:02:18.232]                   {
[11:02:18.232]                     {
[11:02:18.232]                       {
[11:02:18.232]                         base::local({
[11:02:18.232]                           has_future <- base::requireNamespace("future", 
[11:02:18.232]                             quietly = TRUE)
[11:02:18.232]                           if (has_future) {
[11:02:18.232]                             ns <- base::getNamespace("future")
[11:02:18.232]                             version <- ns[[".package"]][["version"]]
[11:02:18.232]                             if (is.null(version)) 
[11:02:18.232]                               version <- utils::packageVersion("future")
[11:02:18.232]                           }
[11:02:18.232]                           else {
[11:02:18.232]                             version <- NULL
[11:02:18.232]                           }
[11:02:18.232]                           if (!has_future || version < "1.8.0") {
[11:02:18.232]                             info <- base::c(r_version = base::gsub("R version ", 
[11:02:18.232]                               "", base::R.version$version.string), 
[11:02:18.232]                               platform = base::sprintf("%s (%s-bit)", 
[11:02:18.232]                                 base::R.version$platform, 8 * 
[11:02:18.232]                                   base::.Machine$sizeof.pointer), 
[11:02:18.232]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:18.232]                                 "release", "version")], collapse = " "), 
[11:02:18.232]                               hostname = base::Sys.info()[["nodename"]])
[11:02:18.232]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:02:18.232]                               info)
[11:02:18.232]                             info <- base::paste(info, collapse = "; ")
[11:02:18.232]                             if (!has_future) {
[11:02:18.232]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:18.232]                                 info)
[11:02:18.232]                             }
[11:02:18.232]                             else {
[11:02:18.232]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:18.232]                                 info, version)
[11:02:18.232]                             }
[11:02:18.232]                             base::stop(msg)
[11:02:18.232]                           }
[11:02:18.232]                         })
[11:02:18.232]                       }
[11:02:18.232]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:18.232]                       base::options(mc.cores = 1L)
[11:02:18.232]                     }
[11:02:18.232]                     base::local({
[11:02:18.232]                       for (pkg in "future") {
[11:02:18.232]                         base::loadNamespace(pkg)
[11:02:18.232]                         base::library(pkg, character.only = TRUE)
[11:02:18.232]                       }
[11:02:18.232]                     })
[11:02:18.232]                   }
[11:02:18.232]                   ...future.strategy.old <- future::plan("list")
[11:02:18.232]                   options(future.plan = NULL)
[11:02:18.232]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:18.232]                   future::plan(list(b = function (..., workers = availableCores(), 
[11:02:18.232]                     lazy = FALSE, rscript_libs = .libPaths(), 
[11:02:18.232]                     envir = parent.frame()) 
[11:02:18.232]                   {
[11:02:18.232]                     if (is.function(workers)) 
[11:02:18.232]                       workers <- workers()
[11:02:18.232]                     workers <- structure(as.integer(workers), 
[11:02:18.232]                       class = class(workers))
[11:02:18.232]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[11:02:18.232]                       workers >= 1)
[11:02:18.232]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[11:02:18.232]                       return(sequential(..., lazy = TRUE, envir = envir))
[11:02:18.232]                     }
[11:02:18.232]                     future <- MultisessionFuture(..., workers = workers, 
[11:02:18.232]                       lazy = lazy, rscript_libs = rscript_libs, 
[11:02:18.232]                       envir = envir)
[11:02:18.232]                     if (!future$lazy) 
[11:02:18.232]                       future <- run(future)
[11:02:18.232]                     invisible(future)
[11:02:18.232]                   }), .cleanup = FALSE, .init = FALSE)
[11:02:18.232]                 }
[11:02:18.232]                 ...future.workdir <- getwd()
[11:02:18.232]             }
[11:02:18.232]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:18.232]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:18.232]         }
[11:02:18.232]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:18.232]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:18.232]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:18.232]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:18.232]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:18.232]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:18.232]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:18.232]             base::names(...future.oldOptions))
[11:02:18.232]     }
[11:02:18.232]     if (FALSE) {
[11:02:18.232]     }
[11:02:18.232]     else {
[11:02:18.232]         if (TRUE) {
[11:02:18.232]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:18.232]                 open = "w")
[11:02:18.232]         }
[11:02:18.232]         else {
[11:02:18.232]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:18.232]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:18.232]         }
[11:02:18.232]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:18.232]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:18.232]             base::sink(type = "output", split = FALSE)
[11:02:18.232]             base::close(...future.stdout)
[11:02:18.232]         }, add = TRUE)
[11:02:18.232]     }
[11:02:18.232]     ...future.frame <- base::sys.nframe()
[11:02:18.232]     ...future.conditions <- base::list()
[11:02:18.232]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:18.232]     if (FALSE) {
[11:02:18.232]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:18.232]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:18.232]     }
[11:02:18.232]     ...future.result <- base::tryCatch({
[11:02:18.232]         base::withCallingHandlers({
[11:02:18.232]             ...future.value <- base::withVisible(base::local({
[11:02:18.232]                 ...future.makeSendCondition <- base::local({
[11:02:18.232]                   sendCondition <- NULL
[11:02:18.232]                   function(frame = 1L) {
[11:02:18.232]                     if (is.function(sendCondition)) 
[11:02:18.232]                       return(sendCondition)
[11:02:18.232]                     ns <- getNamespace("parallel")
[11:02:18.232]                     if (exists("sendData", mode = "function", 
[11:02:18.232]                       envir = ns)) {
[11:02:18.232]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:18.232]                         envir = ns)
[11:02:18.232]                       envir <- sys.frame(frame)
[11:02:18.232]                       master <- NULL
[11:02:18.232]                       while (!identical(envir, .GlobalEnv) && 
[11:02:18.232]                         !identical(envir, emptyenv())) {
[11:02:18.232]                         if (exists("master", mode = "list", envir = envir, 
[11:02:18.232]                           inherits = FALSE)) {
[11:02:18.232]                           master <- get("master", mode = "list", 
[11:02:18.232]                             envir = envir, inherits = FALSE)
[11:02:18.232]                           if (inherits(master, c("SOCKnode", 
[11:02:18.232]                             "SOCK0node"))) {
[11:02:18.232]                             sendCondition <<- function(cond) {
[11:02:18.232]                               data <- list(type = "VALUE", value = cond, 
[11:02:18.232]                                 success = TRUE)
[11:02:18.232]                               parallel_sendData(master, data)
[11:02:18.232]                             }
[11:02:18.232]                             return(sendCondition)
[11:02:18.232]                           }
[11:02:18.232]                         }
[11:02:18.232]                         frame <- frame + 1L
[11:02:18.232]                         envir <- sys.frame(frame)
[11:02:18.232]                       }
[11:02:18.232]                     }
[11:02:18.232]                     sendCondition <<- function(cond) NULL
[11:02:18.232]                   }
[11:02:18.232]                 })
[11:02:18.232]                 withCallingHandlers({
[11:02:18.232]                   {
[11:02:18.232]                     a <- 1L
[11:02:18.232]                     plan_a <- unclass(future::plan("list"))
[11:02:18.232]                     nested_a <- nested[-1]
[11:02:18.232]                     stopifnot(length(nested_a) == 1L, length(plan_a) == 
[11:02:18.232]                       1L, inherits(plan_a[[1]], "future"), inherits(future::plan("next"), 
[11:02:18.232]                       strategy2))
[11:02:18.232]                     for (kk in seq_along(plan_a)) attr(plan_a[[kk]], 
[11:02:18.232]                       "init") <- NULL
[11:02:18.232]                     for (kk in seq_along(nested_a)) attr(nested_a[[kk]], 
[11:02:18.232]                       "init") <- NULL
[11:02:18.232]                     stopifnot(all.equal(plan_a, nested_a))
[11:02:18.232]                     y %<-% {
[11:02:18.232]                       b <- 2L
[11:02:18.232]                       plan_b <- future::plan("list")
[11:02:18.232]                       nested_b <- nested_a[-1]
[11:02:18.232]                       stopifnot(length(nested_b) == 0L, length(plan_b) == 
[11:02:18.232]                         1L, inherits(plan_b[[1]], "future"), 
[11:02:18.232]                         inherits(future::plan("next"), "sequential"))
[11:02:18.232]                       list(a = a, nested_a = nested_a, plan_a = plan_a, 
[11:02:18.232]                         b = b, nested_b = nested_b, plan_b = plan_b)
[11:02:18.232]                     }
[11:02:18.232]                     y
[11:02:18.232]                   }
[11:02:18.232]                 }, immediateCondition = function(cond) {
[11:02:18.232]                   sendCondition <- ...future.makeSendCondition()
[11:02:18.232]                   sendCondition(cond)
[11:02:18.232]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:18.232]                   {
[11:02:18.232]                     inherits <- base::inherits
[11:02:18.232]                     invokeRestart <- base::invokeRestart
[11:02:18.232]                     is.null <- base::is.null
[11:02:18.232]                     muffled <- FALSE
[11:02:18.232]                     if (inherits(cond, "message")) {
[11:02:18.232]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:18.232]                       if (muffled) 
[11:02:18.232]                         invokeRestart("muffleMessage")
[11:02:18.232]                     }
[11:02:18.232]                     else if (inherits(cond, "warning")) {
[11:02:18.232]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:18.232]                       if (muffled) 
[11:02:18.232]                         invokeRestart("muffleWarning")
[11:02:18.232]                     }
[11:02:18.232]                     else if (inherits(cond, "condition")) {
[11:02:18.232]                       if (!is.null(pattern)) {
[11:02:18.232]                         computeRestarts <- base::computeRestarts
[11:02:18.232]                         grepl <- base::grepl
[11:02:18.232]                         restarts <- computeRestarts(cond)
[11:02:18.232]                         for (restart in restarts) {
[11:02:18.232]                           name <- restart$name
[11:02:18.232]                           if (is.null(name)) 
[11:02:18.232]                             next
[11:02:18.232]                           if (!grepl(pattern, name)) 
[11:02:18.232]                             next
[11:02:18.232]                           invokeRestart(restart)
[11:02:18.232]                           muffled <- TRUE
[11:02:18.232]                           break
[11:02:18.232]                         }
[11:02:18.232]                       }
[11:02:18.232]                     }
[11:02:18.232]                     invisible(muffled)
[11:02:18.232]                   }
[11:02:18.232]                   muffleCondition(cond)
[11:02:18.232]                 })
[11:02:18.232]             }))
[11:02:18.232]             future::FutureResult(value = ...future.value$value, 
[11:02:18.232]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:18.232]                   ...future.rng), globalenv = if (FALSE) 
[11:02:18.232]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:18.232]                     ...future.globalenv.names))
[11:02:18.232]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:18.232]         }, condition = base::local({
[11:02:18.232]             c <- base::c
[11:02:18.232]             inherits <- base::inherits
[11:02:18.232]             invokeRestart <- base::invokeRestart
[11:02:18.232]             length <- base::length
[11:02:18.232]             list <- base::list
[11:02:18.232]             seq.int <- base::seq.int
[11:02:18.232]             signalCondition <- base::signalCondition
[11:02:18.232]             sys.calls <- base::sys.calls
[11:02:18.232]             `[[` <- base::`[[`
[11:02:18.232]             `+` <- base::`+`
[11:02:18.232]             `<<-` <- base::`<<-`
[11:02:18.232]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:18.232]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:18.232]                   3L)]
[11:02:18.232]             }
[11:02:18.232]             function(cond) {
[11:02:18.232]                 is_error <- inherits(cond, "error")
[11:02:18.232]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:18.232]                   NULL)
[11:02:18.232]                 if (is_error) {
[11:02:18.232]                   sessionInformation <- function() {
[11:02:18.232]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:18.232]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:18.232]                       search = base::search(), system = base::Sys.info())
[11:02:18.232]                   }
[11:02:18.232]                   ...future.conditions[[length(...future.conditions) + 
[11:02:18.232]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:18.232]                     cond$call), session = sessionInformation(), 
[11:02:18.232]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:18.232]                   signalCondition(cond)
[11:02:18.232]                 }
[11:02:18.232]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:18.232]                 "immediateCondition"))) {
[11:02:18.232]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:18.232]                   ...future.conditions[[length(...future.conditions) + 
[11:02:18.232]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:18.232]                   if (TRUE && !signal) {
[11:02:18.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:18.232]                     {
[11:02:18.232]                       inherits <- base::inherits
[11:02:18.232]                       invokeRestart <- base::invokeRestart
[11:02:18.232]                       is.null <- base::is.null
[11:02:18.232]                       muffled <- FALSE
[11:02:18.232]                       if (inherits(cond, "message")) {
[11:02:18.232]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:18.232]                         if (muffled) 
[11:02:18.232]                           invokeRestart("muffleMessage")
[11:02:18.232]                       }
[11:02:18.232]                       else if (inherits(cond, "warning")) {
[11:02:18.232]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:18.232]                         if (muffled) 
[11:02:18.232]                           invokeRestart("muffleWarning")
[11:02:18.232]                       }
[11:02:18.232]                       else if (inherits(cond, "condition")) {
[11:02:18.232]                         if (!is.null(pattern)) {
[11:02:18.232]                           computeRestarts <- base::computeRestarts
[11:02:18.232]                           grepl <- base::grepl
[11:02:18.232]                           restarts <- computeRestarts(cond)
[11:02:18.232]                           for (restart in restarts) {
[11:02:18.232]                             name <- restart$name
[11:02:18.232]                             if (is.null(name)) 
[11:02:18.232]                               next
[11:02:18.232]                             if (!grepl(pattern, name)) 
[11:02:18.232]                               next
[11:02:18.232]                             invokeRestart(restart)
[11:02:18.232]                             muffled <- TRUE
[11:02:18.232]                             break
[11:02:18.232]                           }
[11:02:18.232]                         }
[11:02:18.232]                       }
[11:02:18.232]                       invisible(muffled)
[11:02:18.232]                     }
[11:02:18.232]                     muffleCondition(cond, pattern = "^muffle")
[11:02:18.232]                   }
[11:02:18.232]                 }
[11:02:18.232]                 else {
[11:02:18.232]                   if (TRUE) {
[11:02:18.232]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:18.232]                     {
[11:02:18.232]                       inherits <- base::inherits
[11:02:18.232]                       invokeRestart <- base::invokeRestart
[11:02:18.232]                       is.null <- base::is.null
[11:02:18.232]                       muffled <- FALSE
[11:02:18.232]                       if (inherits(cond, "message")) {
[11:02:18.232]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:18.232]                         if (muffled) 
[11:02:18.232]                           invokeRestart("muffleMessage")
[11:02:18.232]                       }
[11:02:18.232]                       else if (inherits(cond, "warning")) {
[11:02:18.232]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:18.232]                         if (muffled) 
[11:02:18.232]                           invokeRestart("muffleWarning")
[11:02:18.232]                       }
[11:02:18.232]                       else if (inherits(cond, "condition")) {
[11:02:18.232]                         if (!is.null(pattern)) {
[11:02:18.232]                           computeRestarts <- base::computeRestarts
[11:02:18.232]                           grepl <- base::grepl
[11:02:18.232]                           restarts <- computeRestarts(cond)
[11:02:18.232]                           for (restart in restarts) {
[11:02:18.232]                             name <- restart$name
[11:02:18.232]                             if (is.null(name)) 
[11:02:18.232]                               next
[11:02:18.232]                             if (!grepl(pattern, name)) 
[11:02:18.232]                               next
[11:02:18.232]                             invokeRestart(restart)
[11:02:18.232]                             muffled <- TRUE
[11:02:18.232]                             break
[11:02:18.232]                           }
[11:02:18.232]                         }
[11:02:18.232]                       }
[11:02:18.232]                       invisible(muffled)
[11:02:18.232]                     }
[11:02:18.232]                     muffleCondition(cond, pattern = "^muffle")
[11:02:18.232]                   }
[11:02:18.232]                 }
[11:02:18.232]             }
[11:02:18.232]         }))
[11:02:18.232]     }, error = function(ex) {
[11:02:18.232]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:18.232]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:18.232]                 ...future.rng), started = ...future.startTime, 
[11:02:18.232]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:18.232]             version = "1.8"), class = "FutureResult")
[11:02:18.232]     }, finally = {
[11:02:18.232]         if (!identical(...future.workdir, getwd())) 
[11:02:18.232]             setwd(...future.workdir)
[11:02:18.232]         {
[11:02:18.232]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:18.232]                 ...future.oldOptions$nwarnings <- NULL
[11:02:18.232]             }
[11:02:18.232]             base::options(...future.oldOptions)
[11:02:18.232]             if (.Platform$OS.type == "windows") {
[11:02:18.232]                 old_names <- names(...future.oldEnvVars)
[11:02:18.232]                 envs <- base::Sys.getenv()
[11:02:18.232]                 names <- names(envs)
[11:02:18.232]                 common <- intersect(names, old_names)
[11:02:18.232]                 added <- setdiff(names, old_names)
[11:02:18.232]                 removed <- setdiff(old_names, names)
[11:02:18.232]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:18.232]                   envs[common]]
[11:02:18.232]                 NAMES <- toupper(changed)
[11:02:18.232]                 args <- list()
[11:02:18.232]                 for (kk in seq_along(NAMES)) {
[11:02:18.232]                   name <- changed[[kk]]
[11:02:18.232]                   NAME <- NAMES[[kk]]
[11:02:18.232]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:18.232]                     next
[11:02:18.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:18.232]                 }
[11:02:18.232]                 NAMES <- toupper(added)
[11:02:18.232]                 for (kk in seq_along(NAMES)) {
[11:02:18.232]                   name <- added[[kk]]
[11:02:18.232]                   NAME <- NAMES[[kk]]
[11:02:18.232]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:18.232]                     next
[11:02:18.232]                   args[[name]] <- ""
[11:02:18.232]                 }
[11:02:18.232]                 NAMES <- toupper(removed)
[11:02:18.232]                 for (kk in seq_along(NAMES)) {
[11:02:18.232]                   name <- removed[[kk]]
[11:02:18.232]                   NAME <- NAMES[[kk]]
[11:02:18.232]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:18.232]                     next
[11:02:18.232]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:18.232]                 }
[11:02:18.232]                 if (length(args) > 0) 
[11:02:18.232]                   base::do.call(base::Sys.setenv, args = args)
[11:02:18.232]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:18.232]             }
[11:02:18.232]             else {
[11:02:18.232]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:18.232]             }
[11:02:18.232]             {
[11:02:18.232]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:18.232]                   0L) {
[11:02:18.232]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:18.232]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:18.232]                   base::options(opts)
[11:02:18.232]                 }
[11:02:18.232]                 {
[11:02:18.232]                   {
[11:02:18.232]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:18.232]                     NULL
[11:02:18.232]                   }
[11:02:18.232]                   options(future.plan = NULL)
[11:02:18.232]                   if (is.na(NA_character_)) 
[11:02:18.232]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:18.232]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:18.232]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:18.232]                     .init = FALSE)
[11:02:18.232]                 }
[11:02:18.232]             }
[11:02:18.232]         }
[11:02:18.232]     })
[11:02:18.232]     if (TRUE) {
[11:02:18.232]         base::sink(type = "output", split = FALSE)
[11:02:18.232]         if (TRUE) {
[11:02:18.232]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:18.232]         }
[11:02:18.232]         else {
[11:02:18.232]             ...future.result["stdout"] <- base::list(NULL)
[11:02:18.232]         }
[11:02:18.232]         base::close(...future.stdout)
[11:02:18.232]         ...future.stdout <- NULL
[11:02:18.232]     }
[11:02:18.232]     ...future.result$conditions <- ...future.conditions
[11:02:18.232]     ...future.result$finished <- base::Sys.time()
[11:02:18.232]     ...future.result
[11:02:18.232] }
[11:02:18.235] Exporting 2 global objects (11.55 KiB) to cluster node #1 ...
[11:02:18.235] Exporting ‘nested’ (11.20 KiB) to cluster node #1 ...
[11:02:18.277] Exporting ‘nested’ (11.20 KiB) to cluster node #1 ... DONE
[11:02:18.277] Exporting ‘strategy2’ (51 bytes) to cluster node #1 ...
[11:02:18.277] Exporting ‘strategy2’ (51 bytes) to cluster node #1 ... DONE
[11:02:18.277] Exporting 2 global objects (11.55 KiB) to cluster node #1 ... DONE
[11:02:18.278] MultisessionFuture started
[11:02:18.278] - Launch lazy future ... done
[11:02:18.278] run() for ‘MultisessionFuture’ ... done
[11:02:18.278] result() for ClusterFuture ...
[11:02:18.278] receiveMessageFromWorker() for ClusterFuture ...
[11:02:18.278] - Validating connection of MultisessionFuture
[11:02:18.340] - received message: FutureResult
[11:02:18.340] - Received FutureResult
[11:02:18.340] - Erased future from FutureRegistry
[11:02:18.341] result() for ClusterFuture ...
[11:02:18.341] - result already collected: FutureResult
[11:02:18.341] result() for ClusterFuture ... done
[11:02:18.341] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:18.341] result() for ClusterFuture ... done
[11:02:18.341] result() for ClusterFuture ...
[11:02:18.341] - result already collected: FutureResult
[11:02:18.341] result() for ClusterFuture ... done
List of 6
 $ a       : int 1
 $ nested_a:List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "cleanup")=function ()  
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ plan_a  :List of 1
  ..$ b:function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), 
    envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:5] "multisession" "cluster" "multiprocess" "future" ...
  .. ..- attr(*, "cleanup")=function ()  
  .. ..- attr(*, "untweakable")= chr "persistent"
  .. ..- attr(*, "call")= language plan(list(a = strategy1, b = strategy2))
 $ b       : int 2
 $ nested_b: Named list()
 $ plan_b  :List of 1
  ..$ :function (..., envir = parent.frame())  
  .. ..- attr(*, "class")= chr [1:4] "sequential" "uniprocess" "future" "function"
  ..- attr(*, "class")= chr [1:2] "FutureStrategyList" "list"
[11:02:18.347] getGlobalsAndPackages() ...
[11:02:18.347] Searching for globals...
[11:02:18.348] - globals found: [7] ‘{’, ‘value’, ‘future’, ‘subset’, ‘data’, ‘==’, ‘a’
[11:02:18.348] Searching for globals ... DONE
[11:02:18.348] Resolving globals: FALSE
[11:02:18.349] The total size of the 1 globals is 356 bytes (356 bytes)
[11:02:18.349] The total size of the 1 globals exported for future expression (‘{; value(future(subset(data, a == 2))); }’) is 356 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘data’ (356 bytes of class ‘list’)
[11:02:18.349] - globals: [1] ‘data’
[11:02:18.349] - packages: [1] ‘future’
[11:02:18.350] getGlobalsAndPackages() ... DONE
[11:02:18.350] run() for ‘Future’ ...
[11:02:18.350] - state: ‘created’
[11:02:18.350] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:02:18.364] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:02:18.364] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:02:18.364]   - Field: ‘node’
[11:02:18.364]   - Field: ‘label’
[11:02:18.364]   - Field: ‘local’
[11:02:18.364]   - Field: ‘owner’
[11:02:18.365]   - Field: ‘envir’
[11:02:18.365]   - Field: ‘workers’
[11:02:18.365]   - Field: ‘packages’
[11:02:18.365]   - Field: ‘gc’
[11:02:18.365]   - Field: ‘conditions’
[11:02:18.365]   - Field: ‘persistent’
[11:02:18.365]   - Field: ‘expr’
[11:02:18.365]   - Field: ‘uuid’
[11:02:18.365]   - Field: ‘seed’
[11:02:18.365]   - Field: ‘version’
[11:02:18.365]   - Field: ‘result’
[11:02:18.365]   - Field: ‘asynchronous’
[11:02:18.366]   - Field: ‘calls’
[11:02:18.366]   - Field: ‘globals’
[11:02:18.366]   - Field: ‘stdout’
[11:02:18.366]   - Field: ‘earlySignal’
[11:02:18.366]   - Field: ‘lazy’
[11:02:18.366]   - Field: ‘state’
[11:02:18.366] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:02:18.366] - Launch lazy future ...
[11:02:18.366] Packages needed by the future expression (n = 1): ‘future’
[11:02:18.367] Packages needed by future strategies (n = 1): ‘future’
[11:02:18.367] {
[11:02:18.367]     {
[11:02:18.367]         {
[11:02:18.367]             ...future.startTime <- base::Sys.time()
[11:02:18.367]             {
[11:02:18.367]                 {
[11:02:18.367]                   {
[11:02:18.367]                     {
[11:02:18.367]                       {
[11:02:18.367]                         base::local({
[11:02:18.367]                           has_future <- base::requireNamespace("future", 
[11:02:18.367]                             quietly = TRUE)
[11:02:18.367]                           if (has_future) {
[11:02:18.367]                             ns <- base::getNamespace("future")
[11:02:18.367]                             version <- ns[[".package"]][["version"]]
[11:02:18.367]                             if (is.null(version)) 
[11:02:18.367]                               version <- utils::packageVersion("future")
[11:02:18.367]                           }
[11:02:18.367]                           else {
[11:02:18.367]                             version <- NULL
[11:02:18.367]                           }
[11:02:18.367]                           if (!has_future || version < "1.8.0") {
[11:02:18.367]                             info <- base::c(r_version = base::gsub("R version ", 
[11:02:18.367]                               "", base::R.version$version.string), 
[11:02:18.367]                               platform = base::sprintf("%s (%s-bit)", 
[11:02:18.367]                                 base::R.version$platform, 8 * 
[11:02:18.367]                                   base::.Machine$sizeof.pointer), 
[11:02:18.367]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:02:18.367]                                 "release", "version")], collapse = " "), 
[11:02:18.367]                               hostname = base::Sys.info()[["nodename"]])
[11:02:18.367]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:02:18.367]                               info)
[11:02:18.367]                             info <- base::paste(info, collapse = "; ")
[11:02:18.367]                             if (!has_future) {
[11:02:18.367]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:02:18.367]                                 info)
[11:02:18.367]                             }
[11:02:18.367]                             else {
[11:02:18.367]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:02:18.367]                                 info, version)
[11:02:18.367]                             }
[11:02:18.367]                             base::stop(msg)
[11:02:18.367]                           }
[11:02:18.367]                         })
[11:02:18.367]                       }
[11:02:18.367]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:02:18.367]                       base::options(mc.cores = 1L)
[11:02:18.367]                     }
[11:02:18.367]                     base::local({
[11:02:18.367]                       for (pkg in "future") {
[11:02:18.367]                         base::loadNamespace(pkg)
[11:02:18.367]                         base::library(pkg, character.only = TRUE)
[11:02:18.367]                       }
[11:02:18.367]                     })
[11:02:18.367]                   }
[11:02:18.367]                   ...future.strategy.old <- future::plan("list")
[11:02:18.367]                   options(future.plan = NULL)
[11:02:18.367]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:02:18.367]                   future::plan(list(b = function (..., workers = availableCores(), 
[11:02:18.367]                     lazy = FALSE, rscript_libs = .libPaths(), 
[11:02:18.367]                     envir = parent.frame()) 
[11:02:18.367]                   {
[11:02:18.367]                     if (is.function(workers)) 
[11:02:18.367]                       workers <- workers()
[11:02:18.367]                     workers <- structure(as.integer(workers), 
[11:02:18.367]                       class = class(workers))
[11:02:18.367]                     stop_if_not(length(workers) == 1, is.finite(workers), 
[11:02:18.367]                       workers >= 1)
[11:02:18.367]                     if (workers == 1L && !inherits(workers, "AsIs")) {
[11:02:18.367]                       return(sequential(..., lazy = TRUE, envir = envir))
[11:02:18.367]                     }
[11:02:18.367]                     future <- MultisessionFuture(..., workers = workers, 
[11:02:18.367]                       lazy = lazy, rscript_libs = rscript_libs, 
[11:02:18.367]                       envir = envir)
[11:02:18.367]                     if (!future$lazy) 
[11:02:18.367]                       future <- run(future)
[11:02:18.367]                     invisible(future)
[11:02:18.367]                   }), .cleanup = FALSE, .init = FALSE)
[11:02:18.367]                 }
[11:02:18.367]                 ...future.workdir <- getwd()
[11:02:18.367]             }
[11:02:18.367]             ...future.oldOptions <- base::as.list(base::.Options)
[11:02:18.367]             ...future.oldEnvVars <- base::Sys.getenv()
[11:02:18.367]         }
[11:02:18.367]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:02:18.367]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:02:18.367]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:02:18.367]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:02:18.367]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:02:18.367]             future.stdout.windows.reencode = NULL, width = 80L)
[11:02:18.367]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:02:18.367]             base::names(...future.oldOptions))
[11:02:18.367]     }
[11:02:18.367]     if (FALSE) {
[11:02:18.367]     }
[11:02:18.367]     else {
[11:02:18.367]         if (TRUE) {
[11:02:18.367]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:02:18.367]                 open = "w")
[11:02:18.367]         }
[11:02:18.367]         else {
[11:02:18.367]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:02:18.367]                 windows = "NUL", "/dev/null"), open = "w")
[11:02:18.367]         }
[11:02:18.367]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:02:18.367]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:02:18.367]             base::sink(type = "output", split = FALSE)
[11:02:18.367]             base::close(...future.stdout)
[11:02:18.367]         }, add = TRUE)
[11:02:18.367]     }
[11:02:18.367]     ...future.frame <- base::sys.nframe()
[11:02:18.367]     ...future.conditions <- base::list()
[11:02:18.367]     ...future.rng <- base::globalenv()$.Random.seed
[11:02:18.367]     if (FALSE) {
[11:02:18.367]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:02:18.367]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:02:18.367]     }
[11:02:18.367]     ...future.result <- base::tryCatch({
[11:02:18.367]         base::withCallingHandlers({
[11:02:18.367]             ...future.value <- base::withVisible(base::local({
[11:02:18.367]                 ...future.makeSendCondition <- base::local({
[11:02:18.367]                   sendCondition <- NULL
[11:02:18.367]                   function(frame = 1L) {
[11:02:18.367]                     if (is.function(sendCondition)) 
[11:02:18.367]                       return(sendCondition)
[11:02:18.367]                     ns <- getNamespace("parallel")
[11:02:18.367]                     if (exists("sendData", mode = "function", 
[11:02:18.367]                       envir = ns)) {
[11:02:18.367]                       parallel_sendData <- get("sendData", mode = "function", 
[11:02:18.367]                         envir = ns)
[11:02:18.367]                       envir <- sys.frame(frame)
[11:02:18.367]                       master <- NULL
[11:02:18.367]                       while (!identical(envir, .GlobalEnv) && 
[11:02:18.367]                         !identical(envir, emptyenv())) {
[11:02:18.367]                         if (exists("master", mode = "list", envir = envir, 
[11:02:18.367]                           inherits = FALSE)) {
[11:02:18.367]                           master <- get("master", mode = "list", 
[11:02:18.367]                             envir = envir, inherits = FALSE)
[11:02:18.367]                           if (inherits(master, c("SOCKnode", 
[11:02:18.367]                             "SOCK0node"))) {
[11:02:18.367]                             sendCondition <<- function(cond) {
[11:02:18.367]                               data <- list(type = "VALUE", value = cond, 
[11:02:18.367]                                 success = TRUE)
[11:02:18.367]                               parallel_sendData(master, data)
[11:02:18.367]                             }
[11:02:18.367]                             return(sendCondition)
[11:02:18.367]                           }
[11:02:18.367]                         }
[11:02:18.367]                         frame <- frame + 1L
[11:02:18.367]                         envir <- sys.frame(frame)
[11:02:18.367]                       }
[11:02:18.367]                     }
[11:02:18.367]                     sendCondition <<- function(cond) NULL
[11:02:18.367]                   }
[11:02:18.367]                 })
[11:02:18.367]                 withCallingHandlers({
[11:02:18.367]                   {
[11:02:18.367]                     value(future(subset(data, a == 2)))
[11:02:18.367]                   }
[11:02:18.367]                 }, immediateCondition = function(cond) {
[11:02:18.367]                   sendCondition <- ...future.makeSendCondition()
[11:02:18.367]                   sendCondition(cond)
[11:02:18.367]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:18.367]                   {
[11:02:18.367]                     inherits <- base::inherits
[11:02:18.367]                     invokeRestart <- base::invokeRestart
[11:02:18.367]                     is.null <- base::is.null
[11:02:18.367]                     muffled <- FALSE
[11:02:18.367]                     if (inherits(cond, "message")) {
[11:02:18.367]                       muffled <- grepl(pattern, "muffleMessage")
[11:02:18.367]                       if (muffled) 
[11:02:18.367]                         invokeRestart("muffleMessage")
[11:02:18.367]                     }
[11:02:18.367]                     else if (inherits(cond, "warning")) {
[11:02:18.367]                       muffled <- grepl(pattern, "muffleWarning")
[11:02:18.367]                       if (muffled) 
[11:02:18.367]                         invokeRestart("muffleWarning")
[11:02:18.367]                     }
[11:02:18.367]                     else if (inherits(cond, "condition")) {
[11:02:18.367]                       if (!is.null(pattern)) {
[11:02:18.367]                         computeRestarts <- base::computeRestarts
[11:02:18.367]                         grepl <- base::grepl
[11:02:18.367]                         restarts <- computeRestarts(cond)
[11:02:18.367]                         for (restart in restarts) {
[11:02:18.367]                           name <- restart$name
[11:02:18.367]                           if (is.null(name)) 
[11:02:18.367]                             next
[11:02:18.367]                           if (!grepl(pattern, name)) 
[11:02:18.367]                             next
[11:02:18.367]                           invokeRestart(restart)
[11:02:18.367]                           muffled <- TRUE
[11:02:18.367]                           break
[11:02:18.367]                         }
[11:02:18.367]                       }
[11:02:18.367]                     }
[11:02:18.367]                     invisible(muffled)
[11:02:18.367]                   }
[11:02:18.367]                   muffleCondition(cond)
[11:02:18.367]                 })
[11:02:18.367]             }))
[11:02:18.367]             future::FutureResult(value = ...future.value$value, 
[11:02:18.367]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:18.367]                   ...future.rng), globalenv = if (FALSE) 
[11:02:18.367]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:02:18.367]                     ...future.globalenv.names))
[11:02:18.367]                 else NULL, started = ...future.startTime, version = "1.8")
[11:02:18.367]         }, condition = base::local({
[11:02:18.367]             c <- base::c
[11:02:18.367]             inherits <- base::inherits
[11:02:18.367]             invokeRestart <- base::invokeRestart
[11:02:18.367]             length <- base::length
[11:02:18.367]             list <- base::list
[11:02:18.367]             seq.int <- base::seq.int
[11:02:18.367]             signalCondition <- base::signalCondition
[11:02:18.367]             sys.calls <- base::sys.calls
[11:02:18.367]             `[[` <- base::`[[`
[11:02:18.367]             `+` <- base::`+`
[11:02:18.367]             `<<-` <- base::`<<-`
[11:02:18.367]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:02:18.367]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:02:18.367]                   3L)]
[11:02:18.367]             }
[11:02:18.367]             function(cond) {
[11:02:18.367]                 is_error <- inherits(cond, "error")
[11:02:18.367]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:02:18.367]                   NULL)
[11:02:18.367]                 if (is_error) {
[11:02:18.367]                   sessionInformation <- function() {
[11:02:18.367]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:02:18.367]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:02:18.367]                       search = base::search(), system = base::Sys.info())
[11:02:18.367]                   }
[11:02:18.367]                   ...future.conditions[[length(...future.conditions) + 
[11:02:18.367]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:02:18.367]                     cond$call), session = sessionInformation(), 
[11:02:18.367]                     timestamp = base::Sys.time(), signaled = 0L)
[11:02:18.367]                   signalCondition(cond)
[11:02:18.367]                 }
[11:02:18.367]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:02:18.367]                 "immediateCondition"))) {
[11:02:18.367]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:02:18.367]                   ...future.conditions[[length(...future.conditions) + 
[11:02:18.367]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:02:18.367]                   if (TRUE && !signal) {
[11:02:18.367]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:18.367]                     {
[11:02:18.367]                       inherits <- base::inherits
[11:02:18.367]                       invokeRestart <- base::invokeRestart
[11:02:18.367]                       is.null <- base::is.null
[11:02:18.367]                       muffled <- FALSE
[11:02:18.367]                       if (inherits(cond, "message")) {
[11:02:18.367]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:18.367]                         if (muffled) 
[11:02:18.367]                           invokeRestart("muffleMessage")
[11:02:18.367]                       }
[11:02:18.367]                       else if (inherits(cond, "warning")) {
[11:02:18.367]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:18.367]                         if (muffled) 
[11:02:18.367]                           invokeRestart("muffleWarning")
[11:02:18.367]                       }
[11:02:18.367]                       else if (inherits(cond, "condition")) {
[11:02:18.367]                         if (!is.null(pattern)) {
[11:02:18.367]                           computeRestarts <- base::computeRestarts
[11:02:18.367]                           grepl <- base::grepl
[11:02:18.367]                           restarts <- computeRestarts(cond)
[11:02:18.367]                           for (restart in restarts) {
[11:02:18.367]                             name <- restart$name
[11:02:18.367]                             if (is.null(name)) 
[11:02:18.367]                               next
[11:02:18.367]                             if (!grepl(pattern, name)) 
[11:02:18.367]                               next
[11:02:18.367]                             invokeRestart(restart)
[11:02:18.367]                             muffled <- TRUE
[11:02:18.367]                             break
[11:02:18.367]                           }
[11:02:18.367]                         }
[11:02:18.367]                       }
[11:02:18.367]                       invisible(muffled)
[11:02:18.367]                     }
[11:02:18.367]                     muffleCondition(cond, pattern = "^muffle")
[11:02:18.367]                   }
[11:02:18.367]                 }
[11:02:18.367]                 else {
[11:02:18.367]                   if (TRUE) {
[11:02:18.367]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:02:18.367]                     {
[11:02:18.367]                       inherits <- base::inherits
[11:02:18.367]                       invokeRestart <- base::invokeRestart
[11:02:18.367]                       is.null <- base::is.null
[11:02:18.367]                       muffled <- FALSE
[11:02:18.367]                       if (inherits(cond, "message")) {
[11:02:18.367]                         muffled <- grepl(pattern, "muffleMessage")
[11:02:18.367]                         if (muffled) 
[11:02:18.367]                           invokeRestart("muffleMessage")
[11:02:18.367]                       }
[11:02:18.367]                       else if (inherits(cond, "warning")) {
[11:02:18.367]                         muffled <- grepl(pattern, "muffleWarning")
[11:02:18.367]                         if (muffled) 
[11:02:18.367]                           invokeRestart("muffleWarning")
[11:02:18.367]                       }
[11:02:18.367]                       else if (inherits(cond, "condition")) {
[11:02:18.367]                         if (!is.null(pattern)) {
[11:02:18.367]                           computeRestarts <- base::computeRestarts
[11:02:18.367]                           grepl <- base::grepl
[11:02:18.367]                           restarts <- computeRestarts(cond)
[11:02:18.367]                           for (restart in restarts) {
[11:02:18.367]                             name <- restart$name
[11:02:18.367]                             if (is.null(name)) 
[11:02:18.367]                               next
[11:02:18.367]                             if (!grepl(pattern, name)) 
[11:02:18.367]                               next
[11:02:18.367]                             invokeRestart(restart)
[11:02:18.367]                             muffled <- TRUE
[11:02:18.367]                             break
[11:02:18.367]                           }
[11:02:18.367]                         }
[11:02:18.367]                       }
[11:02:18.367]                       invisible(muffled)
[11:02:18.367]                     }
[11:02:18.367]                     muffleCondition(cond, pattern = "^muffle")
[11:02:18.367]                   }
[11:02:18.367]                 }
[11:02:18.367]             }
[11:02:18.367]         }))
[11:02:18.367]     }, error = function(ex) {
[11:02:18.367]         base::structure(base::list(value = NULL, visible = NULL, 
[11:02:18.367]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:02:18.367]                 ...future.rng), started = ...future.startTime, 
[11:02:18.367]             finished = Sys.time(), session_uuid = NA_character_, 
[11:02:18.367]             version = "1.8"), class = "FutureResult")
[11:02:18.367]     }, finally = {
[11:02:18.367]         if (!identical(...future.workdir, getwd())) 
[11:02:18.367]             setwd(...future.workdir)
[11:02:18.367]         {
[11:02:18.367]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:02:18.367]                 ...future.oldOptions$nwarnings <- NULL
[11:02:18.367]             }
[11:02:18.367]             base::options(...future.oldOptions)
[11:02:18.367]             if (.Platform$OS.type == "windows") {
[11:02:18.367]                 old_names <- names(...future.oldEnvVars)
[11:02:18.367]                 envs <- base::Sys.getenv()
[11:02:18.367]                 names <- names(envs)
[11:02:18.367]                 common <- intersect(names, old_names)
[11:02:18.367]                 added <- setdiff(names, old_names)
[11:02:18.367]                 removed <- setdiff(old_names, names)
[11:02:18.367]                 changed <- common[...future.oldEnvVars[common] != 
[11:02:18.367]                   envs[common]]
[11:02:18.367]                 NAMES <- toupper(changed)
[11:02:18.367]                 args <- list()
[11:02:18.367]                 for (kk in seq_along(NAMES)) {
[11:02:18.367]                   name <- changed[[kk]]
[11:02:18.367]                   NAME <- NAMES[[kk]]
[11:02:18.367]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:18.367]                     next
[11:02:18.367]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:18.367]                 }
[11:02:18.367]                 NAMES <- toupper(added)
[11:02:18.367]                 for (kk in seq_along(NAMES)) {
[11:02:18.367]                   name <- added[[kk]]
[11:02:18.367]                   NAME <- NAMES[[kk]]
[11:02:18.367]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:18.367]                     next
[11:02:18.367]                   args[[name]] <- ""
[11:02:18.367]                 }
[11:02:18.367]                 NAMES <- toupper(removed)
[11:02:18.367]                 for (kk in seq_along(NAMES)) {
[11:02:18.367]                   name <- removed[[kk]]
[11:02:18.367]                   NAME <- NAMES[[kk]]
[11:02:18.367]                   if (name != NAME && is.element(NAME, old_names)) 
[11:02:18.367]                     next
[11:02:18.367]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:02:18.367]                 }
[11:02:18.367]                 if (length(args) > 0) 
[11:02:18.367]                   base::do.call(base::Sys.setenv, args = args)
[11:02:18.367]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:02:18.367]             }
[11:02:18.367]             else {
[11:02:18.367]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:02:18.367]             }
[11:02:18.367]             {
[11:02:18.367]                 if (base::length(...future.futureOptionsAdded) > 
[11:02:18.367]                   0L) {
[11:02:18.367]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:02:18.367]                   base::names(opts) <- ...future.futureOptionsAdded
[11:02:18.367]                   base::options(opts)
[11:02:18.367]                 }
[11:02:18.367]                 {
[11:02:18.367]                   {
[11:02:18.367]                     base::options(mc.cores = ...future.mc.cores.old)
[11:02:18.367]                     NULL
[11:02:18.367]                   }
[11:02:18.367]                   options(future.plan = NULL)
[11:02:18.367]                   if (is.na(NA_character_)) 
[11:02:18.367]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:02:18.367]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:02:18.367]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:02:18.367]                     .init = FALSE)
[11:02:18.367]                 }
[11:02:18.367]             }
[11:02:18.367]         }
[11:02:18.367]     })
[11:02:18.367]     if (TRUE) {
[11:02:18.367]         base::sink(type = "output", split = FALSE)
[11:02:18.367]         if (TRUE) {
[11:02:18.367]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:02:18.367]         }
[11:02:18.367]         else {
[11:02:18.367]             ...future.result["stdout"] <- base::list(NULL)
[11:02:18.367]         }
[11:02:18.367]         base::close(...future.stdout)
[11:02:18.367]         ...future.stdout <- NULL
[11:02:18.367]     }
[11:02:18.367]     ...future.result$conditions <- ...future.conditions
[11:02:18.367]     ...future.result$finished <- base::Sys.time()
[11:02:18.367]     ...future.result
[11:02:18.367] }
[11:02:18.370] Exporting 1 global objects (643 bytes) to cluster node #1 ...
[11:02:18.370] Exporting ‘data’ (356 bytes) to cluster node #1 ...
[11:02:18.370] Exporting ‘data’ (356 bytes) to cluster node #1 ... DONE
[11:02:18.370] Exporting 1 global objects (643 bytes) to cluster node #1 ... DONE
[11:02:18.371] MultisessionFuture started
[11:02:18.371] - Launch lazy future ... done
[11:02:18.371] run() for ‘MultisessionFuture’ ... done
[11:02:18.371] result() for ClusterFuture ...
[11:02:18.371] receiveMessageFromWorker() for ClusterFuture ...
[11:02:18.371] - Validating connection of MultisessionFuture
[11:02:18.419] - received message: FutureResult
[11:02:18.420] - Received FutureResult
[11:02:18.420] - Erased future from FutureRegistry
[11:02:18.420] result() for ClusterFuture ...
[11:02:18.420] - result already collected: FutureResult
[11:02:18.420] result() for ClusterFuture ... done
[11:02:18.420] receiveMessageFromWorker() for ClusterFuture ... done
[11:02:18.420] result() for ClusterFuture ... done
[11:02:18.420] result() for ClusterFuture ...
[11:02:18.420] - result already collected: FutureResult
[11:02:18.420] result() for ClusterFuture ... done
- plan(list('multisession', 'multisession')) ... DONE
> 
> message("*** Nested futures ... DONE")
*** Nested futures ... DONE
> 
> source("incl/end.R")
[11:02:18.421] plan(): Setting new future strategy stack:
[11:02:18.421] List of future strategies:
[11:02:18.421] 1. FutureStrategy:
[11:02:18.421]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:02:18.421]    - tweaked: FALSE
[11:02:18.421]    - call: future::plan(oplan)
[11:02:18.422] plan(): nbrOfWorkers() = 1
> 
